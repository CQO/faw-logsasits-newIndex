/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

var Cesium = (() => {
    var _ye = Object.create; var $v = Object.defineProperty; var gye = Object.getOwnPropertyDescriptor; var yye = Object.getOwnPropertyNames; var Aye = Object.getPrototypeOf, Cye = Object.prototype.hasOwnProperty; var xp = (e => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, { get: (t, n) => (typeof require < "u" ? require : t)[n] }) : e)(function (e) { if (typeof require < "u") return require.apply(this, arguments); throw new Error('Dynamic require of "' + e + '" is not supported') }); var Wa = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), xye = (e, t) => { for (var n in t) $v(e, n, { get: t[n], enumerable: !0 }) }, Yq = (e, t, n, i) => { if (t && typeof t == "object" || typeof t == "function") for (let o of yye(t)) !Cye.call(e, o) && o !== n && $v(e, o, { get: () => t[o], enumerable: !(i = gye(t, o)) || i.enumerable }); return e }; var po = (e, t, n) => (n = e != null ? _ye(Aye(e)) : {}, Yq(t || !e || !e.__esModule ? $v(n, "default", { value: e, enumerable: !0 }) : n, e)), Tye = e => Yq($v({}, "__esModule", { value: !0 }), e); var eP = Wa((jmt, Kq) => { var jh = function (e) { e == null && (e = new Date().getTime()), this.N = 624, this.M = 397, this.MATRIX_A = 2567483615, this.UPPER_MASK = 2147483648, this.LOWER_MASK = 2147483647, this.mt = new Array(this.N), this.mti = this.N + 1, e.constructor == Array ? this.init_by_array(e, e.length) : this.init_seed(e) }; jh.prototype.init_seed = function (e) { for (this.mt[0] = e >>> 0, this.mti = 1; this.mti < this.N; this.mti++) { var e = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30; this.mt[this.mti] = (((e & 4294901760) >>> 16) * 1812433253 << 16) + (e & 65535) * 1812433253 + this.mti, this.mt[this.mti] >>>= 0 } }; jh.prototype.init_by_array = function (e, t) { var n, i, o; for (this.init_seed(19650218), n = 1, i = 0, o = this.N > t ? this.N : t; o; o--) { var r = this.mt[n - 1] ^ this.mt[n - 1] >>> 30; this.mt[n] = (this.mt[n] ^ (((r & 4294901760) >>> 16) * 1664525 << 16) + (r & 65535) * 1664525) + e[i] + i, this.mt[n] >>>= 0, n++, i++, n >= this.N && (this.mt[0] = this.mt[this.N - 1], n = 1), i >= t && (i = 0) } for (o = this.N - 1; o; o--) { var r = this.mt[n - 1] ^ this.mt[n - 1] >>> 30; this.mt[n] = (this.mt[n] ^ (((r & 4294901760) >>> 16) * 1566083941 << 16) + (r & 65535) * 1566083941) - n, this.mt[n] >>>= 0, n++, n >= this.N && (this.mt[0] = this.mt[this.N - 1], n = 1) } this.mt[0] = 2147483648 }; jh.prototype.random_int = function () { var e, t = new Array(0, this.MATRIX_A); if (this.mti >= this.N) { var n; for (this.mti == this.N + 1 && this.init_seed(5489), n = 0; n < this.N - this.M; n++)e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, this.mt[n] = this.mt[n + this.M] ^ e >>> 1 ^ t[e & 1]; for (; n < this.N - 1; n++)e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, this.mt[n] = this.mt[n + (this.M - this.N)] ^ e >>> 1 ^ t[e & 1]; e = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK, this.mt[this.N - 1] = this.mt[this.M - 1] ^ e >>> 1 ^ t[e & 1], this.mti = 0 } return e = this.mt[this.mti++], e ^= e >>> 11, e ^= e << 7 & 2636928640, e ^= e << 15 & 4022730752, e ^= e >>> 18, e >>> 0 }; jh.prototype.random_int31 = function () { return this.random_int() >>> 1 }; jh.prototype.random_incl = function () { return this.random_int() * (1 / 4294967295) }; jh.prototype.random = function () { return this.random_int() * (1 / 4294967296) }; jh.prototype.random_excl = function () { return (this.random_int() + .5) * (1 / 4294967296) }; jh.prototype.random_long = function () { var e = this.random_int() >>> 5, t = this.random_int() >>> 6; return (e * 67108864 + t) * (1 / 9007199254740992) }; Kq.exports = jh }); var IY = Wa((GA, WA) => {/*! https://mths.be/punycode v1.4.0 by @mathias */(function (e) { var t = typeof GA == "object" && GA && !GA.nodeType && GA, n = typeof WA == "object" && WA && !WA.nodeType && WA, i = typeof global == "object" && global; (i.global === i || i.window === i || i.self === i) && (e = i); var o, r = 2147483647, s = 36, a = 1, c = 26, u = 38, f = 700, d = 72, p = 128, g = "-", m = /^xn--/, A = /[^\x20-\x7E]/, C = /[\x2E\u3002\uFF0E\uFF61]/g, x = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, T = s - a, b = Math.floor, S = String.fromCharCode, D; function P(k) { throw new RangeError(x[k]) } function B(k, G) { for (var N = k.length, X = []; N--;)X[N] = G(k[N]); return X } function R(k, G) { var N = k.split("@"), X = ""; N.length > 1 && (X = N[0] + "@", k = N[1]), k = k.replace(C, "."); var q = k.split("."), J = B(q, G).join("."); return X + J } function M(k) { for (var G = [], N = 0, X = k.length, q, J; N < X;)q = k.charCodeAt(N++), q >= 55296 && q <= 56319 && N < X ? (J = k.charCodeAt(N++), (J & 64512) == 56320 ? G.push(((q & 1023) << 10) + (J & 1023) + 65536) : (G.push(q), N--)) : G.push(q); return G } function L(k) { return B(k, function (G) { var N = ""; return G > 65535 && (G -= 65536, N += S(G >>> 10 & 1023 | 55296), G = 56320 | G & 1023), N += S(G), N }).join("") } function _(k) { return k - 48 < 10 ? k - 22 : k - 65 < 26 ? k - 65 : k - 97 < 26 ? k - 97 : s } function E(k, G) { return k + 22 + 75 * (k < 26) - ((G != 0) << 5) } function w(k, G, N) { var X = 0; for (k = N ? b(k / f) : k >> 1, k += b(k / G); k > T * c >> 1; X += s)k = b(k / T); return b(X + (T + 1) * k / (k + u)) } function v(k) { var G = [], N = k.length, X, q = 0, J = p, W = d, K, Z, de, pe, oe, ue, ge, Ee, Ie; for (K = k.lastIndexOf(g), K < 0 && (K = 0), Z = 0; Z < K; ++Z)k.charCodeAt(Z) >= 128 && P("not-basic"), G.push(k.charCodeAt(Z)); for (de = K > 0 ? K + 1 : 0; de < N;) { for (pe = q, oe = 1, ue = s; de >= N && P("invalid-input"), ge = _(k.charCodeAt(de++)), (ge >= s || ge > b((r - q) / oe)) && P("overflow"), q += ge * oe, Ee = ue <= W ? a : ue >= W + c ? c : ue - W, !(ge < Ee); ue += s)Ie = s - Ee, oe > b(r / Ie) && P("overflow"), oe *= Ie; X = G.length + 1, W = w(q - pe, X, pe == 0), b(q / X) > r - J && P("overflow"), J += b(q / X), q %= X, G.splice(q++, 0, J) } return L(G) } function O(k) { var G, N, X, q, J, W, K, Z, de, pe, oe, ue = [], ge, Ee, Ie, Fe; for (k = M(k), ge = k.length, G = p, N = 0, J = d, W = 0; W < ge; ++W)oe = k[W], oe < 128 && ue.push(S(oe)); for (X = q = ue.length, q && ue.push(g); X < ge;) { for (K = r, W = 0; W < ge; ++W)oe = k[W], oe >= G && oe < K && (K = oe); for (Ee = X + 1, K - G > b((r - N) / Ee) && P("overflow"), N += (K - G) * Ee, G = K, W = 0; W < ge; ++W)if (oe = k[W], oe < G && ++N > r && P("overflow"), oe == G) { for (Z = N, de = s; pe = de <= J ? a : de >= J + c ? c : de - J, !(Z < pe); de += s)Fe = Z - pe, Ie = s - pe, ue.push(S(E(pe + Fe % Ie, 0))), Z = b(Fe / Ie); ue.push(S(E(Z, 0))), J = w(N, Ee, X == q), N = 0, ++X } ++N, ++G } return ue.join("") } function V(k) { return R(k, function (G) { return m.test(G) ? v(G.slice(4).toLowerCase()) : G }) } function z(k) { return R(k, function (G) { return A.test(G) ? "xn--" + O(G) : G }) } if (o = { version: "1.3.2", ucs2: { decode: M, encode: L }, decode: v, encode: O, toASCII: z, toUnicode: V }, typeof define == "function" && typeof define.amd == "object" && define.amd) define("punycode", function () { return o }); else if (t && n) if (WA.exports == t) n.exports = o; else for (D in o) o.hasOwnProperty(D) && (t[D] = o[D]); else e.punycode = o })(GA) }); var BY = Wa((OY, TP) => {/*!
 * URI.js - Mutating URLs
 * IPv6 Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */(function (e, t) { "use strict"; typeof TP == "object" && TP.exports ? TP.exports = t() : typeof define == "function" && define.amd ? define(t) : e.IPv6 = t(e) })(OY, function (e) { "use strict"; var t = e && e.IPv6; function n(o) { var r = o.toLowerCase(), s = r.split(":"), a = s.length, c = 8; s[0] === "" && s[1] === "" && s[2] === "" ? (s.shift(), s.shift()) : s[0] === "" && s[1] === "" ? s.shift() : s[a - 1] === "" && s[a - 2] === "" && s.pop(), a = s.length, s[a - 1].indexOf(".") !== -1 && (c = 7); var u; for (u = 0; u < a && s[u] !== ""; u++); if (u < c) for (s.splice(u, 1, "0000"); s.length < c;)s.splice(u, 0, "0000"); for (var f, d = 0; d < c; d++) { f = s[d].split(""); for (var p = 0; p < 3 && (f[0] === "0" && f.length > 1); p++)f.splice(0, 1); s[d] = f.join("") } var g = -1, m = 0, A = 0, C = -1, x = !1; for (d = 0; d < c; d++)x ? s[d] === "0" ? A += 1 : (x = !1, A > m && (g = C, m = A)) : s[d] === "0" && (x = !0, C = d, A = 1); A > m && (g = C, m = A), m > 1 && s.splice(g, m, ""), a = s.length; var T = ""; for (s[0] === "" && (T = ":"), d = 0; d < a && (T += s[d], d !== a - 1); d++)T += ":"; return s[a - 1] === "" && (T += ":"), T } function i() { return e.IPv6 === this && (e.IPv6 = t), this } return { best: n, noConflict: i } })
    }); var MY = Wa((RY, EP) => {/*!
 * URI.js - Mutating URLs
 * Second Level Domain (SLD) Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */(function (e, t) { "use strict"; typeof EP == "object" && EP.exports ? EP.exports = t() : typeof define == "function" && define.amd ? define(t) : e.SecondLevelDomains = t(e) })(RY, function (e) { "use strict"; var t = e && e.SecondLevelDomains, n = { list: { ac: " com gov mil net org ", ae: " ac co gov mil name net org pro sch ", af: " com edu gov net org ", al: " com edu gov mil net org ", ao: " co ed gv it og pb ", ar: " com edu gob gov int mil net org tur ", at: " ac co gv or ", au: " asn com csiro edu gov id net org ", ba: " co com edu gov mil net org rs unbi unmo unsa untz unze ", bb: " biz co com edu gov info net org store tv ", bh: " biz cc com edu gov info net org ", bn: " com edu gov net org ", bo: " com edu gob gov int mil net org tv ", br: " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ", bs: " com edu gov net org ", bz: " du et om ov rg ", ca: " ab bc mb nb nf nl ns nt nu on pe qc sk yk ", ck: " biz co edu gen gov info net org ", cn: " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ", co: " com edu gov mil net nom org ", cr: " ac c co ed fi go or sa ", cy: " ac biz com ekloges gov ltd name net org parliament press pro tm ", do: " art com edu gob gov mil net org sld web ", dz: " art asso com edu gov net org pol ", ec: " com edu fin gov info med mil net org pro ", eg: " com edu eun gov mil name net org sci ", er: " com edu gov ind mil net org rochest w ", es: " com edu gob nom org ", et: " biz com edu gov info name net org ", fj: " ac biz com info mil name net org pro ", fk: " ac co gov net nom org ", fr: " asso com f gouv nom prd presse tm ", gg: " co net org ", gh: " com edu gov mil org ", gn: " ac com gov net org ", gr: " com edu gov mil net org ", gt: " com edu gob ind mil net org ", gu: " com edu gov net org ", hk: " com edu gov idv net org ", hu: " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ", id: " ac co go mil net or sch web ", il: " ac co gov idf k12 muni net org ", in: " ac co edu ernet firm gen gov i ind mil net nic org res ", iq: " com edu gov i mil net org ", ir: " ac co dnssec gov i id net org sch ", it: " edu gov ", je: " co net org ", jo: " com edu gov mil name net org sch ", jp: " ac ad co ed go gr lg ne or ", ke: " ac co go info me mobi ne or sc ", kh: " com edu gov mil net org per ", ki: " biz com de edu gov info mob net org tel ", km: " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ", kn: " edu gov net org ", kr: " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ", kw: " com edu gov net org ", ky: " com edu gov net org ", kz: " com edu gov mil net org ", lb: " com edu gov net org ", lk: " assn com edu gov grp hotel int ltd net ngo org sch soc web ", lr: " com edu gov net org ", lv: " asn com conf edu gov id mil net org ", ly: " com edu gov id med net org plc sch ", ma: " ac co gov m net org press ", mc: " asso tm ", me: " ac co edu gov its net org priv ", mg: " com edu gov mil nom org prd tm ", mk: " com edu gov inf name net org pro ", ml: " com edu gov net org presse ", mn: " edu gov org ", mo: " com edu gov net org ", mt: " com edu gov net org ", mv: " aero biz com coop edu gov info int mil museum name net org pro ", mw: " ac co com coop edu gov int museum net org ", mx: " com edu gob net org ", my: " com edu gov mil name net org sch ", nf: " arts com firm info net other per rec store web ", ng: " biz com edu gov mil mobi name net org sch ", ni: " ac co com edu gob mil net nom org ", np: " com edu gov mil net org ", nr: " biz com edu gov info net org ", om: " ac biz co com edu gov med mil museum net org pro sch ", pe: " com edu gob mil net nom org sld ", ph: " com edu gov i mil net ngo org ", pk: " biz com edu fam gob gok gon gop gos gov net org web ", pl: " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ", pr: " ac biz com edu est gov info isla name net org pro prof ", ps: " com edu gov net org plo sec ", pw: " belau co ed go ne or ", ro: " arts com firm info nom nt org rec store tm www ", rs: " ac co edu gov in org ", sb: " com edu gov net org ", sc: " com edu gov net org ", sh: " co com edu gov net nom org ", sl: " com edu gov net org ", st: " co com consulado edu embaixada gov mil net org principe saotome store ", sv: " com edu gob org red ", sz: " ac co org ", tr: " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ", tt: " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ", tw: " club com ebiz edu game gov idv mil net org ", mu: " ac co com gov net or org ", mz: " ac co edu gov org ", na: " co com ", nz: " ac co cri geek gen govt health iwi maori mil net org parliament school ", pa: " abo ac com edu gob ing med net nom org sld ", pt: " com edu gov int net nome org publ ", py: " com edu gov mil net org ", qa: " com edu gov mil net org ", re: " asso com nom ", ru: " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ", rw: " ac co com edu gouv gov int mil net ", sa: " com edu gov med net org pub sch ", sd: " com edu gov info med net org tv ", se: " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ", sg: " com edu gov idn net org per ", sn: " art com edu gouv org perso univ ", sy: " com edu gov mil net news org ", th: " ac co go in mi net or ", tj: " ac biz co com edu go gov info int mil name net nic org test web ", tn: " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ", tz: " ac co go ne or ", ua: " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ", ug: " ac co go ne or org sc ", uk: " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ", us: " dni fed isa kids nsn ", uy: " com edu gub mil net org ", ve: " co com edu gob info mil net org web ", vi: " co com k12 net org ", vn: " ac biz com edu gov health info int name net org pro ", ye: " co com gov ltd me net org plc ", yu: " ac co edu gov org ", za: " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ", zm: " ac co com edu gov net org sch ", com: "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ", net: "gb jp se uk ", org: "ae", de: "com " }, has: function (i) { var o = i.lastIndexOf("."); if (o <= 0 || o >= i.length - 1) return !1; var r = i.lastIndexOf(".", o - 1); if (r <= 0 || r >= o - 1) return !1; var s = n.list[i.slice(o + 1)]; return s ? s.indexOf(" " + i.slice(r + 1, o) + " ") >= 0 : !1 }, is: function (i) { var o = i.lastIndexOf("."); if (o <= 0 || o >= i.length - 1) return !1; var r = i.lastIndexOf(".", o - 1); if (r >= 0) return !1; var s = n.list[i.slice(o + 1)]; return s ? s.indexOf(" " + i.slice(0, o) + " ") >= 0 : !1 }, get: function (i) { var o = i.lastIndexOf("."); if (o <= 0 || o >= i.length - 1) return null; var r = i.lastIndexOf(".", o - 1); if (r <= 0 || r >= o - 1) return null; var s = n.list[i.slice(o + 1)]; return !s || s.indexOf(" " + i.slice(r + 1, o) + " ") < 0 ? null : i.slice(r + 1) }, noConflict: function () { return e.SecondLevelDomains === this && (e.SecondLevelDomains = t), this } }; return n })
    }); var al = Wa((LY, bP) => {/*!
 * URI.js - Mutating URLs
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */(function (e, t) { "use strict"; typeof bP == "object" && bP.exports ? bP.exports = t(IY(), BY(), MY()) : typeof define == "function" && define.amd ? define(["./punycode", "./IPv6", "./SecondLevelDomains"], t) : e.URI = t(e.punycode, e.IPv6, e.SecondLevelDomains, e) })(LY, function (e, t, n, i) { "use strict"; var o = i && i.URI; function r(E, w) { var v = arguments.length >= 1, O = arguments.length >= 2; if (!(this instanceof r)) return v ? O ? new r(E, w) : new r(E) : new r; if (E === void 0) { if (v) throw new TypeError("undefined is not a valid argument for URI"); typeof location < "u" ? E = location.href + "" : E = "" } if (E === null && v) throw new TypeError("null is not a valid argument for URI"); return this.href(E), w !== void 0 ? this.absoluteTo(w) : this } function s(E) { return /^[0-9]+$/.test(E) } r.version = "1.19.11"; var a = r.prototype, c = Object.prototype.hasOwnProperty; function u(E) { return E.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1") } function f(E) { return E === void 0 ? "Undefined" : String(Object.prototype.toString.call(E)).slice(8, -1) } function d(E) { return f(E) === "Array" } function p(E, w) { var v = {}, O, V; if (f(w) === "RegExp") v = null; else if (d(w)) for (O = 0, V = w.length; O < V; O++)v[w[O]] = !0; else v[w] = !0; for (O = 0, V = E.length; O < V; O++) { var z = v && v[E[O]] !== void 0 || !v && w.test(E[O]); z && (E.splice(O, 1), V--, O--) } return E } function g(E, w) { var v, O; if (d(w)) { for (v = 0, O = w.length; v < O; v++)if (!g(E, w[v])) return !1; return !0 } var V = f(w); for (v = 0, O = E.length; v < O; v++)if (V === "RegExp") { if (typeof E[v] == "string" && E[v].match(w)) return !0 } else if (E[v] === w) return !0; return !1 } function m(E, w) { if (!d(E) || !d(w) || E.length !== w.length) return !1; E.sort(), w.sort(); for (var v = 0, O = E.length; v < O; v++)if (E[v] !== w[v]) return !1; return !0 } function A(E) { var w = /^\/+|\/+$/g; return E.replace(w, "") } r._parts = function () { return { protocol: null, username: null, password: null, hostname: null, urn: null, port: null, path: null, query: null, fragment: null, preventInvalidHostname: r.preventInvalidHostname, duplicateQueryParameters: r.duplicateQueryParameters, escapeQuerySpace: r.escapeQuerySpace } }, r.preventInvalidHostname = !1, r.duplicateQueryParameters = !1, r.escapeQuerySpace = !0, r.protocol_expression = /^[a-z][a-z0-9.+-]*$/i, r.idn_expression = /[^a-z0-9\._-]/i, r.punycode_expression = /(xn--)/i, r.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, r.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/, r.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig, r.findUri = { start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi, end: /[\s\r\n]|$/, trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/, parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g }, r.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, r.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g, r.defaultPorts = { http: "80", https: "443", ftp: "21", gopher: "70", ws: "80", wss: "443" }, r.hostProtocols = ["http", "https"], r.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/, r.domAttributes = { a: "href", blockquote: "cite", link: "href", base: "href", script: "src", form: "action", img: "src", area: "href", iframe: "src", embed: "src", source: "src", track: "src", input: "src", audio: "src", video: "src" }, r.getDomAttribute = function (E) { if (!(!E || !E.nodeName)) { var w = E.nodeName.toLowerCase(); if (!(w === "input" && E.type !== "image")) return r.domAttributes[w] } }; function C(E) { return escape(E) } function x(E) { return encodeURIComponent(E).replace(/[!'()*]/g, C).replace(/\*/g, "%2A") } r.encode = x, r.decode = decodeURIComponent, r.iso8859 = function () { r.encode = escape, r.decode = unescape }, r.unicode = function () { r.encode = x, r.decode = decodeURIComponent }, r.characters = { pathname: { encode: { expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig, map: { "%24": "$", "%26": "&", "%2B": "+", "%2C": ",", "%3B": ";", "%3D": "=", "%3A": ":", "%40": "@" } }, decode: { expression: /[\/\?#]/g, map: { "/": "%2F", "?": "%3F", "#": "%23" } } }, reserved: { encode: { expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig, map: { "%3A": ":", "%2F": "/", "%3F": "?", "%23": "#", "%5B": "[", "%5D": "]", "%40": "@", "%21": "!", "%24": "$", "%26": "&", "%27": "'", "%28": "(", "%29": ")", "%2A": "*", "%2B": "+", "%2C": ",", "%3B": ";", "%3D": "=" } } }, urnpath: { encode: { expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig, map: { "%21": "!", "%24": "$", "%27": "'", "%28": "(", "%29": ")", "%2A": "*", "%2B": "+", "%2C": ",", "%3B": ";", "%3D": "=", "%40": "@" } }, decode: { expression: /[\/\?#:]/g, map: { "/": "%2F", "?": "%3F", "#": "%23", ":": "%3A" } } } }, r.encodeQuery = function (E, w) { var v = r.encode(E + ""); return w === void 0 && (w = r.escapeQuerySpace), w ? v.replace(/%20/g, "+") : v }, r.decodeQuery = function (E, w) { E += "", w === void 0 && (w = r.escapeQuerySpace); try { return r.decode(w ? E.replace(/\+/g, "%20") : E) } catch { return E } }; var T = { encode: "encode", decode: "decode" }, b, S = function (E, w) { return function (v) { try { return r[w](v + "").replace(r.characters[E][w].expression, function (O) { return r.characters[E][w].map[O] }) } catch { return v } } }; for (b in T) r[b + "PathSegment"] = S("pathname", T[b]), r[b + "UrnPathSegment"] = S("urnpath", T[b]); var D = function (E, w, v) { return function (O) { var V; v ? V = function (N) { return r[w](r[v](N)) } : V = r[w]; for (var z = (O + "").split(E), k = 0, G = z.length; k < G; k++)z[k] = V(z[k]); return z.join(E) } }; r.decodePath = D("/", "decodePathSegment"), r.decodeUrnPath = D(":", "decodeUrnPathSegment"), r.recodePath = D("/", "encodePathSegment", "decode"), r.recodeUrnPath = D(":", "encodeUrnPathSegment", "decode"), r.encodeReserved = S("reserved", "encode"), r.parse = function (E, w) { var v; return w || (w = { preventInvalidHostname: r.preventInvalidHostname }), E = E.replace(r.leading_whitespace_expression, ""), E = E.replace(r.ascii_tab_whitespace, ""), v = E.indexOf("#"), v > -1 && (w.fragment = E.substring(v + 1) || null, E = E.substring(0, v)), v = E.indexOf("?"), v > -1 && (w.query = E.substring(v + 1) || null, E = E.substring(0, v)), E = E.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://"), E = E.replace(/^[/\\]{2,}/i, "//"), E.substring(0, 2) === "//" ? (w.protocol = null, E = E.substring(2), E = r.parseAuthority(E, w)) : (v = E.indexOf(":"), v > -1 && (w.protocol = E.substring(0, v) || null, w.protocol && !w.protocol.match(r.protocol_expression) ? w.protocol = void 0 : E.substring(v + 1, v + 3).replace(/\\/g, "/") === "//" ? (E = E.substring(v + 3), E = r.parseAuthority(E, w)) : (E = E.substring(v + 1), w.urn = !0))), w.path = E, w }, r.parseHost = function (E, w) { E || (E = ""), E = E.replace(/\\/g, "/"); var v = E.indexOf("/"), O, V; if (v === -1 && (v = E.length), E.charAt(0) === "[") O = E.indexOf("]"), w.hostname = E.substring(1, O) || null, w.port = E.substring(O + 2, v) || null, w.port === "/" && (w.port = null); else { var z = E.indexOf(":"), k = E.indexOf("/"), G = E.indexOf(":", z + 1); G !== -1 && (k === -1 || G < k) ? (w.hostname = E.substring(0, v) || null, w.port = null) : (V = E.substring(0, v).split(":"), w.hostname = V[0] || null, w.port = V[1] || null) } return w.hostname && E.substring(v).charAt(0) !== "/" && (v++, E = "/" + E), w.preventInvalidHostname && r.ensureValidHostname(w.hostname, w.protocol), w.port && r.ensureValidPort(w.port), E.substring(v) || "/" }, r.parseAuthority = function (E, w) { return E = r.parseUserinfo(E, w), r.parseHost(E, w) }, r.parseUserinfo = function (E, w) { var v = E, O = E.indexOf("\\"); O !== -1 && (E = E.replace(/\\/g, "/")); var V = E.indexOf("/"), z = E.lastIndexOf("@", V > -1 ? V : E.length - 1), k; return z > -1 && (V === -1 || z < V) ? (k = E.substring(0, z).split(":"), w.username = k[0] ? r.decode(k[0]) : null, k.shift(), w.password = k[0] ? r.decode(k.join(":")) : null, E = v.substring(z + 1)) : (w.username = null, w.password = null), E }, r.parseQuery = function (E, w) { if (!E) return {}; if (E = E.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, ""), !E) return {}; for (var v = {}, O = E.split("&"), V = O.length, z, k, G, N = 0; N < V; N++)z = O[N].split("="), k = r.decodeQuery(z.shift(), w), G = z.length ? r.decodeQuery(z.join("="), w) : null, k !== "__proto__" && (c.call(v, k) ? ((typeof v[k] == "string" || v[k] === null) && (v[k] = [v[k]]), v[k].push(G)) : v[k] = G); return v }, r.build = function (E) { var w = "", v = !1; return E.protocol && (w += E.protocol + ":"), !E.urn && (w || E.hostname) && (w += "//", v = !0), w += r.buildAuthority(E) || "", typeof E.path == "string" && (E.path.charAt(0) !== "/" && v && (w += "/"), w += E.path), typeof E.query == "string" && E.query && (w += "?" + E.query), typeof E.fragment == "string" && E.fragment && (w += "#" + E.fragment), w }, r.buildHost = function (E) { var w = ""; if (E.hostname) r.ip6_expression.test(E.hostname) ? w += "[" + E.hostname + "]" : w += E.hostname; else return ""; return E.port && (w += ":" + E.port), w }, r.buildAuthority = function (E) { return r.buildUserinfo(E) + r.buildHost(E) }, r.buildUserinfo = function (E) { var w = ""; return E.username && (w += r.encode(E.username)), E.password && (w += ":" + r.encode(E.password)), w && (w += "@"), w }, r.buildQuery = function (E, w, v) { var O = "", V, z, k, G; for (z in E) if (z !== "__proto__" && c.call(E, z)) if (d(E[z])) for (V = {}, k = 0, G = E[z].length; k < G; k++)E[z][k] !== void 0 && V[E[z][k] + ""] === void 0 && (O += "&" + r.buildQueryParameter(z, E[z][k], v), w !== !0 && (V[E[z][k] + ""] = !0)); else E[z] !== void 0 && (O += "&" + r.buildQueryParameter(z, E[z], v)); return O.substring(1) }, r.buildQueryParameter = function (E, w, v) { return r.encodeQuery(E, v) + (w !== null ? "=" + r.encodeQuery(w, v) : "") }, r.addQuery = function (E, w, v) { if (typeof w == "object") for (var O in w) c.call(w, O) && r.addQuery(E, O, w[O]); else if (typeof w == "string") { if (E[w] === void 0) { E[w] = v; return } else typeof E[w] == "string" && (E[w] = [E[w]]); d(v) || (v = [v]), E[w] = (E[w] || []).concat(v) } else throw new TypeError("URI.addQuery() accepts an object, string as the name parameter") }, r.setQuery = function (E, w, v) { if (typeof w == "object") for (var O in w) c.call(w, O) && r.setQuery(E, O, w[O]); else if (typeof w == "string") E[w] = v === void 0 ? null : v; else throw new TypeError("URI.setQuery() accepts an object, string as the name parameter") }, r.removeQuery = function (E, w, v) { var O, V, z; if (d(w)) for (O = 0, V = w.length; O < V; O++)E[w[O]] = void 0; else if (f(w) === "RegExp") for (z in E) w.test(z) && (E[z] = void 0); else if (typeof w == "object") for (z in w) c.call(w, z) && r.removeQuery(E, z, w[z]); else if (typeof w == "string") v !== void 0 ? f(v) === "RegExp" ? !d(E[w]) && v.test(E[w]) ? E[w] = void 0 : E[w] = p(E[w], v) : E[w] === String(v) && (!d(v) || v.length === 1) ? E[w] = void 0 : d(E[w]) && (E[w] = p(E[w], v)) : E[w] = void 0; else throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter") }, r.hasQuery = function (E, w, v, O) { switch (f(w)) { case "String": break; case "RegExp": for (var V in E) if (c.call(E, V) && w.test(V) && (v === void 0 || r.hasQuery(E, V, v))) return !0; return !1; case "Object": for (var z in w) if (c.call(w, z) && !r.hasQuery(E, z, w[z])) return !1; return !0; default: throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter") }switch (f(v)) { case "Undefined": return w in E; case "Boolean": var k = Boolean(d(E[w]) ? E[w].length : E[w]); return v === k; case "Function": return !!v(E[w], w, E); case "Array": if (!d(E[w])) return !1; var G = O ? g : m; return G(E[w], v); case "RegExp": return d(E[w]) ? O ? g(E[w], v) : !1 : Boolean(E[w] && E[w].match(v)); case "Number": v = String(v); case "String": return d(E[w]) ? O ? g(E[w], v) : !1 : E[w] === v; default: throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter") } }, r.joinPaths = function () { for (var E = [], w = [], v = 0, O = 0; O < arguments.length; O++) { var V = new r(arguments[O]); E.push(V); for (var z = V.segment(), k = 0; k < z.length; k++)typeof z[k] == "string" && w.push(z[k]), z[k] && v++ } if (!w.length || !v) return new r(""); var G = new r("").segment(w); return (E[0].path() === "" || E[0].path().slice(0, 1) === "/") && G.path("/" + G.path()), G.normalize() }, r.commonPath = function (E, w) { var v = Math.min(E.length, w.length), O; for (O = 0; O < v; O++)if (E.charAt(O) !== w.charAt(O)) { O--; break } return O < 1 ? E.charAt(0) === w.charAt(0) && E.charAt(0) === "/" ? "/" : "" : ((E.charAt(O) !== "/" || w.charAt(O) !== "/") && (O = E.substring(0, O).lastIndexOf("/")), E.substring(0, O + 1)) }, r.withinString = function (E, w, v) { v || (v = {}); var O = v.start || r.findUri.start, V = v.end || r.findUri.end, z = v.trim || r.findUri.trim, k = v.parens || r.findUri.parens, G = /[a-z0-9-]=["']?$/i; for (O.lastIndex = 0; ;) { var N = O.exec(E); if (!N) break; var X = N.index; if (v.ignoreHtml) { var q = E.slice(Math.max(X - 3, 0), X); if (q && G.test(q)) continue } for (var J = X + E.slice(X).search(V), W = E.slice(X, J), K = -1; ;) { var Z = k.exec(W); if (!Z) break; var de = Z.index + Z[0].length; K = Math.max(K, de) } if (K > -1 ? W = W.slice(0, K) + W.slice(K).replace(z, "") : W = W.replace(z, ""), !(W.length <= N[0].length) && !(v.ignore && v.ignore.test(W))) { J = X + W.length; var pe = w(W, X, J, E); if (pe === void 0) { O.lastIndex = J; continue } pe = String(pe), E = E.slice(0, X) + pe + E.slice(J), O.lastIndex = X + pe.length } } return O.lastIndex = 0, E }, r.ensureValidHostname = function (E, w) { var v = !!E, O = !!w, V = !1; if (O && (V = g(r.hostProtocols, w)), V && !v) throw new TypeError("Hostname cannot be empty, if protocol is " + w); if (E && E.match(r.invalid_hostname_characters)) { if (!e) throw new TypeError('Hostname "' + E + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available'); if (e.toASCII(E).match(r.invalid_hostname_characters)) throw new TypeError('Hostname "' + E + '" contains characters other than [A-Z0-9.-:_]') } }, r.ensureValidPort = function (E) { if (!!E) { var w = Number(E); if (!(s(w) && w > 0 && w < 65536)) throw new TypeError('Port "' + E + '" is not a valid port') } }, r.noConflict = function (E) { if (E) { var w = { URI: this.noConflict() }; return i.URITemplate && typeof i.URITemplate.noConflict == "function" && (w.URITemplate = i.URITemplate.noConflict()), i.IPv6 && typeof i.IPv6.noConflict == "function" && (w.IPv6 = i.IPv6.noConflict()), i.SecondLevelDomains && typeof i.SecondLevelDomains.noConflict == "function" && (w.SecondLevelDomains = i.SecondLevelDomains.noConflict()), w } else i.URI === this && (i.URI = o); return this }, a.build = function (E) { return E === !0 ? this._deferred_build = !0 : (E === void 0 || this._deferred_build) && (this._string = r.build(this._parts), this._deferred_build = !1), this }, a.clone = function () { return new r(this) }, a.valueOf = a.toString = function () { return this.build(!1)._string }; function P(E) { return function (w, v) { return w === void 0 ? this._parts[E] || "" : (this._parts[E] = w || null, this.build(!v), this) } } function B(E, w) { return function (v, O) { return v === void 0 ? this._parts[E] || "" : (v !== null && (v = v + "", v.charAt(0) === w && (v = v.substring(1))), this._parts[E] = v, this.build(!O), this) } } a.protocol = P("protocol"), a.username = P("username"), a.password = P("password"), a.hostname = P("hostname"), a.port = P("port"), a.query = B("query", "?"), a.fragment = B("fragment", "#"), a.search = function (E, w) { var v = this.query(E, w); return typeof v == "string" && v.length ? "?" + v : v }, a.hash = function (E, w) { var v = this.fragment(E, w); return typeof v == "string" && v.length ? "#" + v : v }, a.pathname = function (E, w) { if (E === void 0 || E === !0) { var v = this._parts.path || (this._parts.hostname ? "/" : ""); return E ? (this._parts.urn ? r.decodeUrnPath : r.decodePath)(v) : v } else return this._parts.urn ? this._parts.path = E ? r.recodeUrnPath(E) : "" : this._parts.path = E ? r.recodePath(E) : "/", this.build(!w), this }, a.path = a.pathname, a.href = function (E, w) { var v; if (E === void 0) return this.toString(); this._string = "", this._parts = r._parts(); var O = E instanceof r, V = typeof E == "object" && (E.hostname || E.path || E.pathname); if (E.nodeName) { var z = r.getDomAttribute(E); E = E[z] || "", V = !1 } if (!O && V && E.pathname !== void 0 && (E = E.toString()), typeof E == "string" || E instanceof String) this._parts = r.parse(String(E), this._parts); else if (O || V) { var k = O ? E._parts : E; for (v in k) v !== "query" && c.call(this._parts, v) && (this._parts[v] = k[v]); k.query && this.query(k.query, !1) } else throw new TypeError("invalid input"); return this.build(!w), this }, a.is = function (E) { var w = !1, v = !1, O = !1, V = !1, z = !1, k = !1, G = !1, N = !this._parts.urn; switch (this._parts.hostname && (N = !1, v = r.ip4_expression.test(this._parts.hostname), O = r.ip6_expression.test(this._parts.hostname), w = v || O, V = !w, z = V && n && n.has(this._parts.hostname), k = V && r.idn_expression.test(this._parts.hostname), G = V && r.punycode_expression.test(this._parts.hostname)), E.toLowerCase()) { case "relative": return N; case "absolute": return !N; case "domain": case "name": return V; case "sld": return z; case "ip": return w; case "ip4": case "ipv4": case "inet4": return v; case "ip6": case "ipv6": case "inet6": return O; case "idn": return k; case "url": return !this._parts.urn; case "urn": return !!this._parts.urn; case "punycode": return G }return null }; var R = a.protocol, M = a.port, L = a.hostname; a.protocol = function (E, w) { if (E && (E = E.replace(/:(\/\/)?$/, ""), !E.match(r.protocol_expression))) throw new TypeError('Protocol "' + E + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`); return R.call(this, E, w) }, a.scheme = a.protocol, a.port = function (E, w) { return this._parts.urn ? E === void 0 ? "" : this : (E !== void 0 && (E === 0 && (E = null), E && (E += "", E.charAt(0) === ":" && (E = E.substring(1)), r.ensureValidPort(E))), M.call(this, E, w)) }, a.hostname = function (E, w) { if (this._parts.urn) return E === void 0 ? "" : this; if (E !== void 0) { var v = { preventInvalidHostname: this._parts.preventInvalidHostname }, O = r.parseHost(E, v); if (O !== "/") throw new TypeError('Hostname "' + E + '" contains characters other than [A-Z0-9.-]'); E = v.hostname, this._parts.preventInvalidHostname && r.ensureValidHostname(E, this._parts.protocol) } return L.call(this, E, w) }, a.origin = function (E, w) { if (this._parts.urn) return E === void 0 ? "" : this; if (E === void 0) { var v = this.protocol(), O = this.authority(); return O ? (v ? v + "://" : "") + this.authority() : "" } else { var V = r(E); return this.protocol(V.protocol()).authority(V.authority()).build(!w), this } }, a.host = function (E, w) { if (this._parts.urn) return E === void 0 ? "" : this; if (E === void 0) return this._parts.hostname ? r.buildHost(this._parts) : ""; var v = r.parseHost(E, this._parts); if (v !== "/") throw new TypeError('Hostname "' + E + '" contains characters other than [A-Z0-9.-]'); return this.build(!w), this }, a.authority = function (E, w) { if (this._parts.urn) return E === void 0 ? "" : this; if (E === void 0) return this._parts.hostname ? r.buildAuthority(this._parts) : ""; var v = r.parseAuthority(E, this._parts); if (v !== "/") throw new TypeError('Hostname "' + E + '" contains characters other than [A-Z0-9.-]'); return this.build(!w), this }, a.userinfo = function (E, w) { if (this._parts.urn) return E === void 0 ? "" : this; if (E === void 0) { var v = r.buildUserinfo(this._parts); return v && v.substring(0, v.length - 1) } else return E[E.length - 1] !== "@" && (E += "@"), r.parseUserinfo(E, this._parts), this.build(!w), this }, a.resource = function (E, w) { var v; return E === void 0 ? this.path() + this.search() + this.hash() : (v = r.parse(E), this._parts.path = v.path, this._parts.query = v.query, this._parts.fragment = v.fragment, this.build(!w), this) }, a.subdomain = function (E, w) { if (this._parts.urn) return E === void 0 ? "" : this; if (E === void 0) { if (!this._parts.hostname || this.is("IP")) return ""; var v = this._parts.hostname.length - this.domain().length - 1; return this._parts.hostname.substring(0, v) || "" } else { var O = this._parts.hostname.length - this.domain().length, V = this._parts.hostname.substring(0, O), z = new RegExp("^" + u(V)); if (E && E.charAt(E.length - 1) !== "." && (E += "."), E.indexOf(":") !== -1) throw new TypeError("Domains cannot contain colons"); return E && r.ensureValidHostname(E, this._parts.protocol), this._parts.hostname = this._parts.hostname.replace(z, E), this.build(!w), this } }, a.domain = function (E, w) { if (this._parts.urn) return E === void 0 ? "" : this; if (typeof E == "boolean" && (w = E, E = void 0), E === void 0) { if (!this._parts.hostname || this.is("IP")) return ""; var v = this._parts.hostname.match(/\./g); if (v && v.length < 2) return this._parts.hostname; var O = this._parts.hostname.length - this.tld(w).length - 1; return O = this._parts.hostname.lastIndexOf(".", O - 1) + 1, this._parts.hostname.substring(O) || "" } else { if (!E) throw new TypeError("cannot set domain empty"); if (E.indexOf(":") !== -1) throw new TypeError("Domains cannot contain colons"); if (r.ensureValidHostname(E, this._parts.protocol), !this._parts.hostname || this.is("IP")) this._parts.hostname = E; else { var V = new RegExp(u(this.domain()) + "$"); this._parts.hostname = this._parts.hostname.replace(V, E) } return this.build(!w), this } }, a.tld = function (E, w) { if (this._parts.urn) return E === void 0 ? "" : this; if (typeof E == "boolean" && (w = E, E = void 0), E === void 0) { if (!this._parts.hostname || this.is("IP")) return ""; var v = this._parts.hostname.lastIndexOf("."), O = this._parts.hostname.substring(v + 1); return w !== !0 && n && n.list[O.toLowerCase()] && n.get(this._parts.hostname) || O } else { var V; if (E) if (E.match(/[^a-zA-Z0-9-]/)) if (n && n.is(E)) V = new RegExp(u(this.tld()) + "$"), this._parts.hostname = this._parts.hostname.replace(V, E); else throw new TypeError('TLD "' + E + '" contains characters other than [A-Z0-9]'); else { if (!this._parts.hostname || this.is("IP")) throw new ReferenceError("cannot set TLD on non-domain host"); V = new RegExp(u(this.tld()) + "$"), this._parts.hostname = this._parts.hostname.replace(V, E) } else throw new TypeError("cannot set TLD empty"); return this.build(!w), this } }, a.directory = function (E, w) { if (this._parts.urn) return E === void 0 ? "" : this; if (E === void 0 || E === !0) { if (!this._parts.path && !this._parts.hostname) return ""; if (this._parts.path === "/") return "/"; var v = this._parts.path.length - this.filename().length - 1, O = this._parts.path.substring(0, v) || (this._parts.hostname ? "/" : ""); return E ? r.decodePath(O) : O } else { var V = this._parts.path.length - this.filename().length, z = this._parts.path.substring(0, V), k = new RegExp("^" + u(z)); return this.is("relative") || (E || (E = "/"), E.charAt(0) !== "/" && (E = "/" + E)), E && E.charAt(E.length - 1) !== "/" && (E += "/"), E = r.recodePath(E), this._parts.path = this._parts.path.replace(k, E), this.build(!w), this } }, a.filename = function (E, w) { if (this._parts.urn) return E === void 0 ? "" : this; if (typeof E != "string") { if (!this._parts.path || this._parts.path === "/") return ""; var v = this._parts.path.lastIndexOf("/"), O = this._parts.path.substring(v + 1); return E ? r.decodePathSegment(O) : O } else { var V = !1; E.charAt(0) === "/" && (E = E.substring(1)), E.match(/\.?\//) && (V = !0); var z = new RegExp(u(this.filename()) + "$"); return E = r.recodePath(E), this._parts.path = this._parts.path.replace(z, E), V ? this.normalizePath(w) : this.build(!w), this } }, a.suffix = function (E, w) { if (this._parts.urn) return E === void 0 ? "" : this; if (E === void 0 || E === !0) { if (!this._parts.path || this._parts.path === "/") return ""; var v = this.filename(), O = v.lastIndexOf("."), V, z; return O === -1 ? "" : (V = v.substring(O + 1), z = /^[a-z0-9%]+$/i.test(V) ? V : "", E ? r.decodePathSegment(z) : z) } else { E.charAt(0) === "." && (E = E.substring(1)); var k = this.suffix(), G; if (k) E ? G = new RegExp(u(k) + "$") : G = new RegExp(u("." + k) + "$"); else { if (!E) return this; this._parts.path += "." + r.recodePath(E) } return G && (E = r.recodePath(E), this._parts.path = this._parts.path.replace(G, E)), this.build(!w), this } }, a.segment = function (E, w, v) { var O = this._parts.urn ? ":" : "/", V = this.path(), z = V.substring(0, 1) === "/", k = V.split(O); if (E !== void 0 && typeof E != "number" && (v = w, w = E, E = void 0), E !== void 0 && typeof E != "number") throw new Error('Bad segment "' + E + '", must be 0-based integer'); if (z && k.shift(), E < 0 && (E = Math.max(k.length + E, 0)), w === void 0) return E === void 0 ? k : k[E]; if (E === null || k[E] === void 0) if (d(w)) { k = []; for (var G = 0, N = w.length; G < N; G++)!w[G].length && (!k.length || !k[k.length - 1].length) || (k.length && !k[k.length - 1].length && k.pop(), k.push(A(w[G]))) } else (w || typeof w == "string") && (w = A(w), k[k.length - 1] === "" ? k[k.length - 1] = w : k.push(w)); else w ? k[E] = A(w) : k.splice(E, 1); return z && k.unshift(""), this.path(k.join(O), v) }, a.segmentCoded = function (E, w, v) { var O, V, z; if (typeof E != "number" && (v = w, w = E, E = void 0), w === void 0) { if (O = this.segment(E, w, v), !d(O)) O = O !== void 0 ? r.decode(O) : void 0; else for (V = 0, z = O.length; V < z; V++)O[V] = r.decode(O[V]); return O } if (!d(w)) w = typeof w == "string" || w instanceof String ? r.encode(w) : w; else for (V = 0, z = w.length; V < z; V++)w[V] = r.encode(w[V]); return this.segment(E, w, v) }; var _ = a.query; return a.query = function (E, w) { if (E === !0) return r.parseQuery(this._parts.query, this._parts.escapeQuerySpace); if (typeof E == "function") { var v = r.parseQuery(this._parts.query, this._parts.escapeQuerySpace), O = E.call(this, v); return this._parts.query = r.buildQuery(O || v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), this.build(!w), this } else return E !== void 0 && typeof E != "string" ? (this._parts.query = r.buildQuery(E, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), this.build(!w), this) : _.call(this, E, w) }, a.setQuery = function (E, w, v) { var O = r.parseQuery(this._parts.query, this._parts.escapeQuerySpace); if (typeof E == "string" || E instanceof String) O[E] = w !== void 0 ? w : null; else if (typeof E == "object") for (var V in E) c.call(E, V) && (O[V] = E[V]); else throw new TypeError("URI.addQuery() accepts an object, string as the name parameter"); return this._parts.query = r.buildQuery(O, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), typeof E != "string" && (v = w), this.build(!v), this }, a.addQuery = function (E, w, v) { var O = r.parseQuery(this._parts.query, this._parts.escapeQuerySpace); return r.addQuery(O, E, w === void 0 ? null : w), this._parts.query = r.buildQuery(O, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), typeof E != "string" && (v = w), this.build(!v), this }, a.removeQuery = function (E, w, v) { var O = r.parseQuery(this._parts.query, this._parts.escapeQuerySpace); return r.removeQuery(O, E, w), this._parts.query = r.buildQuery(O, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), typeof E != "string" && (v = w), this.build(!v), this }, a.hasQuery = function (E, w, v) { var O = r.parseQuery(this._parts.query, this._parts.escapeQuerySpace); return r.hasQuery(O, E, w, v) }, a.setSearch = a.setQuery, a.addSearch = a.addQuery, a.removeSearch = a.removeQuery, a.hasSearch = a.hasQuery, a.normalize = function () { return this._parts.urn ? this.normalizeProtocol(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build() : this.normalizeProtocol(!1).normalizeHostname(!1).normalizePort(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build() }, a.normalizeProtocol = function (E) { return typeof this._parts.protocol == "string" && (this._parts.protocol = this._parts.protocol.toLowerCase(), this.build(!E)), this }, a.normalizeHostname = function (E) { return this._parts.hostname && (this.is("IDN") && e ? this._parts.hostname = e.toASCII(this._parts.hostname) : this.is("IPv6") && t && (this._parts.hostname = t.best(this._parts.hostname)), this._parts.hostname = this._parts.hostname.toLowerCase(), this.build(!E)), this }, a.normalizePort = function (E) { return typeof this._parts.protocol == "string" && this._parts.port === r.defaultPorts[this._parts.protocol] && (this._parts.port = null, this.build(!E)), this }, a.normalizePath = function (E) { var w = this._parts.path; if (!w) return this; if (this._parts.urn) return this._parts.path = r.recodeUrnPath(this._parts.path), this.build(!E), this; if (this._parts.path === "/") return this; w = r.recodePath(w); var v, O = "", V, z; for (w.charAt(0) !== "/" && (v = !0, w = "/" + w), (w.slice(-3) === "/.." || w.slice(-2) === "/.") && (w += "/"), w = w.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/"), v && (O = w.substring(1).match(/^(\.\.\/)+/) || "", O && (O = O[0])); V = w.search(/\/\.\.(\/|$)/), V !== -1;) { if (V === 0) { w = w.substring(3); continue } z = w.substring(0, V).lastIndexOf("/"), z === -1 && (z = V), w = w.substring(0, z) + w.substring(V + 3) } return v && this.is("relative") && (w = O + w.substring(1)), this._parts.path = w, this.build(!E), this }, a.normalizePathname = a.normalizePath, a.normalizeQuery = function (E) { return typeof this._parts.query == "string" && (this._parts.query.length ? this.query(r.parseQuery(this._parts.query, this._parts.escapeQuerySpace)) : this._parts.query = null, this.build(!E)), this }, a.normalizeFragment = function (E) { return this._parts.fragment || (this._parts.fragment = null, this.build(!E)), this }, a.normalizeSearch = a.normalizeQuery, a.normalizeHash = a.normalizeFragment, a.iso8859 = function () { var E = r.encode, w = r.decode; r.encode = escape, r.decode = decodeURIComponent; try { this.normalize() } finally { r.encode = E, r.decode = w } return this }, a.unicode = function () { var E = r.encode, w = r.decode; r.encode = x, r.decode = unescape; try { this.normalize() } finally { r.encode = E, r.decode = w } return this }, a.readable = function () { var E = this.clone(); E.username("").password("").normalize(); var w = ""; if (E._parts.protocol && (w += E._parts.protocol + "://"), E._parts.hostname && (E.is("punycode") && e ? (w += e.toUnicode(E._parts.hostname), E._parts.port && (w += ":" + E._parts.port)) : w += E.host()), E._parts.hostname && E._parts.path && E._parts.path.charAt(0) !== "/" && (w += "/"), w += E.path(!0), E._parts.query) { for (var v = "", O = 0, V = E._parts.query.split("&"), z = V.length; O < z; O++) { var k = (V[O] || "").split("="); v += "&" + r.decodeQuery(k[0], this._parts.escapeQuerySpace).replace(/&/g, "%26"), k[1] !== void 0 && (v += "=" + r.decodeQuery(k[1], this._parts.escapeQuerySpace).replace(/&/g, "%26")) } w += "?" + v.substring(1) } return w += r.decodeQuery(E.hash(), !0), w }, a.absoluteTo = function (E) { var w = this.clone(), v = ["protocol", "username", "password", "hostname", "port"], O, V, z; if (this._parts.urn) throw new Error("URNs do not have any generally defined hierarchical components"); if (E instanceof r || (E = new r(E)), w._parts.protocol || (w._parts.protocol = E._parts.protocol, this._parts.hostname)) return w; for (V = 0; z = v[V]; V++)w._parts[z] = E._parts[z]; return w._parts.path ? (w._parts.path.substring(-2) === ".." && (w._parts.path += "/"), w.path().charAt(0) !== "/" && (O = E.directory(), O = O || (E.path().indexOf("/") === 0 ? "/" : ""), w._parts.path = (O ? O + "/" : "") + w._parts.path, w.normalizePath())) : (w._parts.path = E._parts.path, w._parts.query || (w._parts.query = E._parts.query)), w.build(), w }, a.relativeTo = function (E) { var w = this.clone().normalize(), v, O, V, z, k; if (w._parts.urn) throw new Error("URNs do not have any generally defined hierarchical components"); if (E = new r(E).normalize(), v = w._parts, O = E._parts, z = w.path(), k = E.path(), z.charAt(0) !== "/") throw new Error("URI is already relative"); if (k.charAt(0) !== "/") throw new Error("Cannot calculate a URI relative to another relative URI"); if (v.protocol === O.protocol && (v.protocol = null), v.username !== O.username || v.password !== O.password || v.protocol !== null || v.username !== null || v.password !== null) return w.build(); if (v.hostname === O.hostname && v.port === O.port) v.hostname = null, v.port = null; else return w.build(); if (z === k) return v.path = "", w.build(); if (V = r.commonPath(z, k), !V) return w.build(); var G = O.path.substring(V.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../"); return v.path = G + v.path.substring(V.length) || "./", w.build() }, a.equals = function (E) { var w = this.clone(), v = new r(E), O = {}, V = {}, z = {}, k, G, N; if (w.normalize(), v.normalize(), w.toString() === v.toString()) return !0; if (k = w.query(), G = v.query(), w.query(""), v.query(""), w.toString() !== v.toString() || k.length !== G.length) return !1; O = r.parseQuery(k, this._parts.escapeQuerySpace), V = r.parseQuery(G, this._parts.escapeQuerySpace); for (N in O) if (c.call(O, N)) { if (d(O[N])) { if (!m(O[N], V[N])) return !1 } else if (O[N] !== V[N]) return !1; z[N] = !0 } for (N in V) if (c.call(V, N) && !z[N]) return !1; return !0 }, a.preventInvalidHostname = function (E) { return this._parts.preventInvalidHostname = !!E, this }, a.duplicateQueryParameters = function (E) { return this._parts.duplicateQueryParameters = !!E, this }, a.escapeQuerySpace = function (E) { return this._parts.escapeQuerySpace = !!E, this }, r })
    }); var zZ = Wa((RG, MG) => {/*! @license DOMPurify 2.4.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.0/LICENSE */(function (e, t) { typeof RG == "object" && typeof MG < "u" ? MG.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis < "u" ? globalThis : e || self, e.DOMPurify = t()) })(RG, function () {
        "use strict"; function e(Ne) { return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (nt) { return typeof nt } : function (nt) { return nt && typeof Symbol == "function" && nt.constructor === Symbol && nt !== Symbol.prototype ? "symbol" : typeof nt }, e(Ne) } function t(Ne, nt) { return t = Object.setPrototypeOf || function (je, ut) { return je.__proto__ = ut, je }, t(Ne, nt) } function n() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch { return !1 } } function i(Ne, nt, Ce) { return n() ? i = Reflect.construct : i = function (ut, Wn, Zn) { var Fi = [null]; Fi.push.apply(Fi, Wn); var mo = Function.bind.apply(ut, Fi), bo = new mo; return Zn && t(bo, Zn.prototype), bo }, i.apply(null, arguments) } function o(Ne) { return r(Ne) || s(Ne) || a(Ne) || u() } function r(Ne) { if (Array.isArray(Ne)) return c(Ne) } function s(Ne) { if (typeof Symbol < "u" && Ne[Symbol.iterator] != null || Ne["@@iterator"] != null) return Array.from(Ne) } function a(Ne, nt) { if (!!Ne) { if (typeof Ne == "string") return c(Ne, nt); var Ce = Object.prototype.toString.call(Ne).slice(8, -1); if (Ce === "Object" && Ne.constructor && (Ce = Ne.constructor.name), Ce === "Map" || Ce === "Set") return Array.from(Ne); if (Ce === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Ce)) return c(Ne, nt) } } function c(Ne, nt) { (nt == null || nt > Ne.length) && (nt = Ne.length); for (var Ce = 0, je = new Array(nt); Ce < nt; Ce++)je[Ce] = Ne[Ce]; return je } function u() {
            throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        } var f = Object.hasOwnProperty, d = Object.setPrototypeOf, p = Object.isFrozen, g = Object.getPrototypeOf, m = Object.getOwnPropertyDescriptor, A = Object.freeze, C = Object.seal, x = Object.create, T = typeof Reflect < "u" && Reflect, b = T.apply, S = T.construct; b || (b = function (nt, Ce, je) { return nt.apply(Ce, je) }), A || (A = function (nt) { return nt }), C || (C = function (nt) { return nt }), S || (S = function (nt, Ce) { return i(nt, o(Ce)) }); var D = O(Array.prototype.forEach), P = O(Array.prototype.pop), B = O(Array.prototype.push), R = O(String.prototype.toLowerCase), M = O(String.prototype.match), L = O(String.prototype.replace), _ = O(String.prototype.indexOf), E = O(String.prototype.trim), w = O(RegExp.prototype.test), v = V(TypeError); function O(Ne) { return function (nt) { for (var Ce = arguments.length, je = new Array(Ce > 1 ? Ce - 1 : 0), ut = 1; ut < Ce; ut++)je[ut - 1] = arguments[ut]; return b(Ne, nt, je) } } function V(Ne) { return function () { for (var nt = arguments.length, Ce = new Array(nt), je = 0; je < nt; je++)Ce[je] = arguments[je]; return S(Ne, Ce) } } function z(Ne, nt, Ce) { Ce = Ce || R, d && d(Ne, null); for (var je = nt.length; je--;) { var ut = nt[je]; if (typeof ut == "string") { var Wn = Ce(ut); Wn !== ut && (p(nt) || (nt[je] = Wn), ut = Wn) } Ne[ut] = !0 } return Ne } function k(Ne) { var nt = x(null), Ce; for (Ce in Ne) b(f, Ne, [Ce]) && (nt[Ce] = Ne[Ce]); return nt } function G(Ne, nt) { for (; Ne !== null;) { var Ce = m(Ne, nt); if (Ce) { if (Ce.get) return O(Ce.get); if (typeof Ce.value == "function") return O(Ce.value) } Ne = g(Ne) } function je(ut) { return console.warn("fallback value for", ut), null } return je } var N = A(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), X = A(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), q = A(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), J = A(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), W = A(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), K = A(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Z = A(["#text"]), de = A(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), pe = A(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), oe = A(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), ue = A(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), ge = C(/\{\{[\w\W]*|[\w\W]*\}\}/gm), Ee = C(/<%[\w\W]*|[\w\W]*%>/gm), Ie = C(/^data-[\-\w.\u00B7-\uFFFF]/), Fe = C(/^aria-[\-\w]+$/), We = C(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), Lt = C(/^(?:\w+script|data):/i), Gt = C(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), cn = C(/^html$/i), _t = function () { return typeof window > "u" ? null : window }, Pn = function (nt, Ce) { if (e(nt) !== "object" || typeof nt.createPolicy != "function") return null; var je = null, ut = "data-tt-policy-suffix"; Ce.currentScript && Ce.currentScript.hasAttribute(ut) && (je = Ce.currentScript.getAttribute(ut)); var Wn = "dompurify" + (je ? "#" + je : ""); try { return nt.createPolicy(Wn, { createHTML: function (Fi) { return Fi }, createScriptURL: function (Fi) { return Fi } }) } catch { return console.warn("TrustedTypes policy " + Wn + " could not be created."), null } }; function Jn() {
            var Ne = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _t(), nt = function (Se) { return Jn(Se) }; if (nt.version = "2.4.0", nt.removed = [], !Ne || !Ne.document || Ne.document.nodeType !== 9) return nt.isSupported = !1, nt; var Ce = Ne.document, je = Ne.document, ut = Ne.DocumentFragment, Wn = Ne.HTMLTemplateElement, Zn = Ne.Node, Fi = Ne.Element, mo = Ne.NodeFilter, bo = Ne.NamedNodeMap, Ii = bo === void 0 ? Ne.NamedNodeMap || Ne.MozNamedAttrMap : bo, Le = Ne.HTMLFormElement, et = Ne.DOMParser, Ke = Ne.trustedTypes, qe = Fi.prototype, mt = G(qe, "cloneNode"), Ft = G(qe, "nextSibling"), Cn = G(qe, "childNodes"), ro = G(qe, "parentNode"); if (typeof Wn == "function") { var So = je.createElement("template"); So.content && So.content.ownerDocument && (je = So.content.ownerDocument) } var Ao = Pn(Ke, Ce), Hs = Ao ? Ao.createHTML("") : "", nr = je, Oi = nr.implementation, Wr = nr.createNodeIterator, jr = nr.createDocumentFragment, Xl = nr.getElementsByTagName, Ni = Ce.importNode, Er = {}; try { Er = k(je).documentMode ? je.documentMode : {} } catch { } var Oo = {}; nt.isSupported = typeof ro == "function" && Oi && typeof Oi.createHTMLDocument < "u" && Er !== 9; var ir = ge, Uh = Ee, br = Ie, Kl = Fe, Jl = Lt, n0 = Gt, qr = We, Bo = null, vA = z({}, [].concat(o(N), o(X), o(q), o(W), o(Z))), rs = null, zh = z({}, [].concat(o(de), o(pe), o(oe), o(ue))), Vi = Object.seal(Object.create(null, { tagNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null }, attributeNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null }, allowCustomizedBuiltInElements: { writable: !0, configurable: !1, enumerable: !0, value: !1 } })), Hh = null, $E = null, yz = !0, Az = !0, Iq = !1, PA = !1, i0 = !1, Cz = !1, xz = !1, IA = !1, Xv = !1, Kv = !1, Oq = !0, Bq = !1, cye = "user-content-", Tz = !0, eb = !1, OA = {}, BA = null, Rq = z({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), Mq = null, Lq = z({}, ["audio", "video", "img", "source", "image", "track"]), Ez = null, Fq = z({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), bz = "http://www.w3.org/1998/Math/MathML", Sz = "http://www.w3.org/2000/svg", Cp = "http://www.w3.org/1999/xhtml", Jv = Cp, wz = !1, RA, lye = ["application/xhtml+xml", "text/html"], uye = "text/html", gs, MA = null, fye = je.createElement("form"), Nq = function (Se) { return Se instanceof RegExp || Se instanceof Function }, Dz = function (Se) { MA && MA === Se || ((!Se || e(Se) !== "object") && (Se = {}), Se = k(Se), RA = lye.indexOf(Se.PARSER_MEDIA_TYPE) === -1 ? RA = uye : RA = Se.PARSER_MEDIA_TYPE, gs = RA === "application/xhtml+xml" ? function (gt) { return gt } : R, Bo = "ALLOWED_TAGS" in Se ? z({}, Se.ALLOWED_TAGS, gs) : vA, rs = "ALLOWED_ATTR" in Se ? z({}, Se.ALLOWED_ATTR, gs) : zh, Ez = "ADD_URI_SAFE_ATTR" in Se ? z(k(Fq), Se.ADD_URI_SAFE_ATTR, gs) : Fq, Mq = "ADD_DATA_URI_TAGS" in Se ? z(k(Lq), Se.ADD_DATA_URI_TAGS, gs) : Lq, BA = "FORBID_CONTENTS" in Se ? z({}, Se.FORBID_CONTENTS, gs) : Rq, Hh = "FORBID_TAGS" in Se ? z({}, Se.FORBID_TAGS, gs) : {}, $E = "FORBID_ATTR" in Se ? z({}, Se.FORBID_ATTR, gs) : {}, OA = "USE_PROFILES" in Se ? Se.USE_PROFILES : !1, yz = Se.ALLOW_ARIA_ATTR !== !1, Az = Se.ALLOW_DATA_ATTR !== !1, Iq = Se.ALLOW_UNKNOWN_PROTOCOLS || !1, PA = Se.SAFE_FOR_TEMPLATES || !1, i0 = Se.WHOLE_DOCUMENT || !1, IA = Se.RETURN_DOM || !1, Xv = Se.RETURN_DOM_FRAGMENT || !1, Kv = Se.RETURN_TRUSTED_TYPE || !1, xz = Se.FORCE_BODY || !1, Oq = Se.SANITIZE_DOM !== !1, Bq = Se.SANITIZE_NAMED_PROPS || !1, Tz = Se.KEEP_CONTENT !== !1, eb = Se.IN_PLACE || !1, qr = Se.ALLOWED_URI_REGEXP || qr, Jv = Se.NAMESPACE || Cp, Se.CUSTOM_ELEMENT_HANDLING && Nq(Se.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Vi.tagNameCheck = Se.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Se.CUSTOM_ELEMENT_HANDLING && Nq(Se.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Vi.attributeNameCheck = Se.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Se.CUSTOM_ELEMENT_HANDLING && typeof Se.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Vi.allowCustomizedBuiltInElements = Se.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), PA && (Az = !1), Xv && (IA = !0), OA && (Bo = z({}, o(Z)), rs = [], OA.html === !0 && (z(Bo, N), z(rs, de)), OA.svg === !0 && (z(Bo, X), z(rs, pe), z(rs, ue)), OA.svgFilters === !0 && (z(Bo, q), z(rs, pe), z(rs, ue)), OA.mathMl === !0 && (z(Bo, W), z(rs, oe), z(rs, ue))), Se.ADD_TAGS && (Bo === vA && (Bo = k(Bo)), z(Bo, Se.ADD_TAGS, gs)), Se.ADD_ATTR && (rs === zh && (rs = k(rs)), z(rs, Se.ADD_ATTR, gs)), Se.ADD_URI_SAFE_ATTR && z(Ez, Se.ADD_URI_SAFE_ATTR, gs), Se.FORBID_CONTENTS && (BA === Rq && (BA = k(BA)), z(BA, Se.FORBID_CONTENTS, gs)), Tz && (Bo["#text"] = !0), i0 && z(Bo, ["html", "head", "body"]), Bo.table && (z(Bo, ["tbody"]), delete Hh.tbody), A && A(Se), MA = Se) }, Vq = z({}, ["mi", "mo", "mn", "ms", "mtext"]), kq = z({}, ["foreignobject", "desc", "title", "annotation-xml"]), dye = z({}, ["title", "style", "font", "a", "script"]), Zv = z({}, X); z(Zv, q), z(Zv, J); var vz = z({}, W); z(vz, K); var hye = function (Se) { var gt = ro(Se); (!gt || !gt.tagName) && (gt = { namespaceURI: Cp, tagName: "template" }); var Wt = R(Se.tagName), $i = R(gt.tagName); return Se.namespaceURI === Sz ? gt.namespaceURI === Cp ? Wt === "svg" : gt.namespaceURI === bz ? Wt === "svg" && ($i === "annotation-xml" || Vq[$i]) : Boolean(Zv[Wt]) : Se.namespaceURI === bz ? gt.namespaceURI === Cp ? Wt === "math" : gt.namespaceURI === Sz ? Wt === "math" && kq[$i] : Boolean(vz[Wt]) : Se.namespaceURI === Cp ? gt.namespaceURI === Sz && !kq[$i] || gt.namespaceURI === bz && !Vq[$i] ? !1 : !vz[Wt] && (dye[Wt] || !Zv[Wt]) : !1 }, Gh = function (Se) { B(nt.removed, { element: Se }); try { Se.parentNode.removeChild(Se) } catch { try { Se.outerHTML = Hs } catch { Se.remove() } } }, Pz = function (Se, gt) { try { B(nt.removed, { attribute: gt.getAttributeNode(Se), from: gt }) } catch { B(nt.removed, { attribute: null, from: gt }) } if (gt.removeAttribute(Se), Se === "is" && !rs[Se]) if (IA || Xv) try { Gh(gt) } catch { } else try { gt.setAttribute(Se, "") } catch { } }, Uq = function (Se) { var gt, Wt; if (xz) Se = "<remove></remove>" + Se; else { var $i = M(Se, /^[\r\n\t ]+/); Wt = $i && $i[0] } RA === "application/xhtml+xml" && (Se = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Se + "</body></html>"); var Sc = Ao ? Ao.createHTML(Se) : Se; if (Jv === Cp) try { gt = new et().parseFromString(Sc, RA) } catch { } if (!gt || !gt.documentElement) { gt = Oi.createDocument(Jv, "template", null); try { gt.documentElement.innerHTML = wz ? "" : Sc } catch { } } var ca = gt.body || gt.documentElement; return Se && Wt && ca.insertBefore(je.createTextNode(Wt), ca.childNodes[0] || null), Jv === Cp ? Xl.call(gt, i0 ? "html" : "body")[0] : i0 ? gt.documentElement : ca }, zq = function (Se) { return Wr.call(Se.ownerDocument || Se, Se, mo.SHOW_ELEMENT | mo.SHOW_COMMENT | mo.SHOW_TEXT, null, !1) }, mye = function (Se) { return Se instanceof Le && (typeof Se.nodeName != "string" || typeof Se.textContent != "string" || typeof Se.removeChild != "function" || !(Se.attributes instanceof Ii) || typeof Se.removeAttribute != "function" || typeof Se.setAttribute != "function" || typeof Se.namespaceURI != "string" || typeof Se.insertBefore != "function") }, tb = function (Se) { return e(Zn) === "object" ? Se instanceof Zn : Se && e(Se) === "object" && typeof Se.nodeType == "number" && typeof Se.nodeName == "string" }, Wh = function (Se, gt, Wt) { !Oo[Se] || D(Oo[Se], function ($i) { $i.call(nt, gt, Wt, MA) }) }, Hq = function (Se) { var gt; if (Wh("beforeSanitizeElements", Se, null), mye(Se) || w(/[\u0080-\uFFFF]/, Se.nodeName)) return Gh(Se), !0; var Wt = gs(Se.nodeName); if (Wh("uponSanitizeElement", Se, { tagName: Wt, allowedTags: Bo }), Se.hasChildNodes() && !tb(Se.firstElementChild) && (!tb(Se.content) || !tb(Se.content.firstElementChild)) && w(/<[/\w]/g, Se.innerHTML) && w(/<[/\w]/g, Se.textContent) || Wt === "select" && w(/<template/i, Se.innerHTML)) return Gh(Se), !0; if (!Bo[Wt] || Hh[Wt]) { if (!Hh[Wt] && Wq(Wt) && (Vi.tagNameCheck instanceof RegExp && w(Vi.tagNameCheck, Wt) || Vi.tagNameCheck instanceof Function && Vi.tagNameCheck(Wt))) return !1; if (Tz && !BA[Wt]) { var $i = ro(Se) || Se.parentNode, Sc = Cn(Se) || Se.childNodes; if (Sc && $i) for (var ca = Sc.length, Gs = ca - 1; Gs >= 0; --Gs)$i.insertBefore(mt(Sc[Gs], !0), Ft(Se)) } return Gh(Se), !0 } return Se instanceof Fi && !hye(Se) || (Wt === "noscript" || Wt === "noembed") && w(/<\/no(script|embed)/i, Se.innerHTML) ? (Gh(Se), !0) : (PA && Se.nodeType === 3 && (gt = Se.textContent, gt = L(gt, ir, " "), gt = L(gt, Uh, " "), Se.textContent !== gt && (B(nt.removed, { element: Se.cloneNode() }), Se.textContent = gt)), Wh("afterSanitizeElements", Se, null), !1) }, Gq = function (Se, gt, Wt) { if (Oq && (gt === "id" || gt === "name") && (Wt in je || Wt in fye)) return !1; if (!(Az && !$E[gt] && w(br, gt))) { if (!(yz && w(Kl, gt))) { if (!rs[gt] || $E[gt]) { if (!(Wq(Se) && (Vi.tagNameCheck instanceof RegExp && w(Vi.tagNameCheck, Se) || Vi.tagNameCheck instanceof Function && Vi.tagNameCheck(Se)) && (Vi.attributeNameCheck instanceof RegExp && w(Vi.attributeNameCheck, gt) || Vi.attributeNameCheck instanceof Function && Vi.attributeNameCheck(gt)) || gt === "is" && Vi.allowCustomizedBuiltInElements && (Vi.tagNameCheck instanceof RegExp && w(Vi.tagNameCheck, Wt) || Vi.tagNameCheck instanceof Function && Vi.tagNameCheck(Wt)))) return !1 } else if (!Ez[gt]) { if (!w(qr, L(Wt, n0, ""))) { if (!((gt === "src" || gt === "xlink:href" || gt === "href") && Se !== "script" && _(Wt, "data:") === 0 && Mq[Se])) { if (!(Iq && !w(Jl, L(Wt, n0, "")))) { if (Wt) return !1 } } } } } } return !0 }, Wq = function (Se) { return Se.indexOf("-") > 0 }, jq = function (Se) { var gt, Wt, $i, Sc; Wh("beforeSanitizeAttributes", Se, null); var ca = Se.attributes; if (!!ca) { var Gs = { attrName: "", attrValue: "", keepAttr: !0, allowedAttributes: rs }; for (Sc = ca.length; Sc--;) { gt = ca[Sc]; var Qv = gt, la = Qv.name, Iz = Qv.namespaceURI; if (Wt = la === "value" ? gt.value : E(gt.value), $i = gs(la), Gs.attrName = $i, Gs.attrValue = Wt, Gs.keepAttr = !0, Gs.forceKeepAttr = void 0, Wh("uponSanitizeAttribute", Se, Gs), Wt = Gs.attrValue, !Gs.forceKeepAttr && (Pz(la, Se), !!Gs.keepAttr)) { if (w(/\/>/i, Wt)) { Pz(la, Se); continue } PA && (Wt = L(Wt, ir, " "), Wt = L(Wt, Uh, " ")); var qq = gs(Se.nodeName); if (!!Gq(qq, $i, Wt)) { if (Bq && ($i === "id" || $i === "name") && (Pz(la, Se), Wt = cye + Wt), Ao && e(Ke) === "object" && typeof Ke.getAttributeType == "function" && !Iz) switch (Ke.getAttributeType(qq, $i)) { case "TrustedHTML": Wt = Ao.createHTML(Wt); break; case "TrustedScriptURL": Wt = Ao.createScriptURL(Wt); break }try { Iz ? Se.setAttributeNS(Iz, la, Wt) : Se.setAttribute(la, Wt), P(nt.removed) } catch { } } } } Wh("afterSanitizeAttributes", Se, null) } }, pye = function _n(Se) { var gt, Wt = zq(Se); for (Wh("beforeSanitizeShadowDOM", Se, null); gt = Wt.nextNode();)Wh("uponSanitizeShadowNode", gt, null), !Hq(gt) && (gt.content instanceof ut && _n(gt.content), jq(gt)); Wh("afterSanitizeShadowDOM", Se, null) }; return nt.sanitize = function (_n) {
                var Se = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, gt, Wt, $i, Sc, ca; if (wz = !_n, wz && (_n = "<!-->"), typeof _n != "string" && !tb(_n)) { if (typeof _n.toString != "function") throw v("toString is not a function"); if (_n = _n.toString(), typeof _n != "string") throw v("dirty is not a string, aborting") } if (!nt.isSupported) { if (e(Ne.toStaticHTML) === "object" || typeof Ne.toStaticHTML == "function") { if (typeof _n == "string") return Ne.toStaticHTML(_n); if (tb(_n)) return Ne.toStaticHTML(_n.outerHTML) } return _n } if (Cz || Dz(Se), nt.removed = [], typeof _n == "string" && (eb = !1), eb) { if (_n.nodeName) { var Gs = gs(_n.nodeName); if (!Bo[Gs] || Hh[Gs]) throw v("root node is forbidden and cannot be sanitized in-place") } } else if (_n instanceof Zn) gt = Uq("<!---->"), Wt = gt.ownerDocument.importNode(_n, !0), Wt.nodeType === 1 && Wt.nodeName === "BODY" || Wt.nodeName === "HTML" ? gt = Wt : gt.appendChild(Wt); else { if (!IA && !PA && !i0 && _n.indexOf("<") === -1) return Ao && Kv ? Ao.createHTML(_n) : _n; if (gt = Uq(_n), !gt) return IA ? null : Kv ? Hs : "" } gt && xz && Gh(gt.firstChild); for (var Qv = zq(eb ? _n : gt); $i = Qv.nextNode();)$i.nodeType === 3 && $i === Sc || Hq($i) || ($i.content instanceof ut && pye($i.content), jq($i), Sc = $i); if (Sc = null, eb) return _n; if (IA) { if (Xv) for (ca = jr.call(gt.ownerDocument); gt.firstChild;)ca.appendChild(gt.firstChild); else ca = gt; return rs.shadowroot && (ca = Ni.call(Ce, ca, !0)), ca } var la = i0 ? gt.outerHTML : gt.innerHTML; return i0 && Bo["!doctype"] && gt.ownerDocument && gt.ownerDocument.doctype && gt.ownerDocument.doctype.name && w(cn, gt.ownerDocument.doctype.name) && (la = "<!DOCTYPE " + gt.ownerDocument.doctype.name + `>
`+ la), PA && (la = L(la, ir, " "), la = L(la, Uh, " ")), Ao && Kv ? Ao.createHTML(la) : la
            }, nt.setConfig = function (_n) { Dz(_n), Cz = !0 }, nt.clearConfig = function () { MA = null, Cz = !1 }, nt.isValidAttribute = function (_n, Se, gt) { MA || Dz({}); var Wt = gs(_n), $i = gs(Se); return Gq(Wt, $i, gt) }, nt.addHook = function (_n, Se) { typeof Se == "function" && (Oo[_n] = Oo[_n] || [], B(Oo[_n], Se)) }, nt.removeHook = function (_n) { if (Oo[_n]) return P(Oo[_n]) }, nt.removeHooks = function (_n) { Oo[_n] && (Oo[_n] = []) }, nt.removeAllHooks = function () { Oo = {} }, nt
        } var at = Jn(); return at
    })
    }); var rQ = Wa((iS, OB) => {
        (function (e) {
            "use strict"; var t = "Compound", n = "Identifier", i = "MemberExpression", o = "Literal", r = "ThisExpression", s = "CallExpression", a = "UnaryExpression", c = "BinaryExpression", u = "LogicalExpression", f = "ConditionalExpression", d = "ArrayExpression", p = 46, g = 44, m = 39, A = 34, C = 40, x = 41, T = 91, b = 93, S = 63, D = 59, P = 58, B = function (J, W) { var K = new Error(J + " at character " + W); throw K.index = W, K.description = J, K }, R = !0, M = { "-": R, "!": R, "~": R, "+": R }, L = { "||": 1, "&&": 2, "|": 3, "^": 4, "&": 5, "==": 6, "!=": 6, "===": 6, "!==": 6, "<": 7, ">": 7, "<=": 7, ">=": 7, "<<": 8, ">>": 8, ">>>": 8, "+": 9, "-": 9, "*": 10, "/": 10, "%": 10 }, _ = function (J) { var W = 0, K; for (var Z in J) (K = Z.length) > W && J.hasOwnProperty(Z) && (W = K); return W }, E = _(M), w = _(L), v = { true: !0, false: !1, null: null }, O = "this", V = function (J) { return L[J] || 0 }, z = function (J, W, K) { var Z = J === "||" || J === "&&" ? u : c; return { type: Z, operator: J, left: W, right: K } }, k = function (J) { return J >= 48 && J <= 57 }, G = function (J) { return J === 36 || J === 95 || J >= 65 && J <= 90 || J >= 97 && J <= 122 || J >= 128 && !L[String.fromCharCode(J)] }, N = function (J) { return J === 36 || J === 95 || J >= 65 && J <= 90 || J >= 97 && J <= 122 || J >= 48 && J <= 57 || J >= 128 && !L[String.fromCharCode(J)] }, X = function (J) {
                for (var W = 0, K = J.charAt, Z = J.charCodeAt, de = function (Ce) { return K.call(J, Ce) }, pe = function (Ce) { return Z.call(J, Ce) }, oe = J.length, ue = function () { for (var Ce = pe(W); Ce === 32 || Ce === 9 || Ce === 10 || Ce === 13;)Ce = pe(++W) }, ge = function () { var Ce = Ie(), je, ut; if (ue(), pe(W) === S) { if (W++, je = ge(), je || B("Expected expression", W), ue(), pe(W) === P) return W++, ut = ge(), ut || B("Expected expression", W), { type: f, test: Ce, consequent: je, alternate: ut }; B("Expected :", W) } else return Ce }, Ee = function () { ue(); for (var Ce, je = J.substr(W, w), ut = je.length; ut > 0;) { if (L.hasOwnProperty(je) && (!G(pe(W)) || W + je.length < J.length && !N(pe(W + je.length)))) return W += ut, je; je = je.substr(0, --ut) } return !1 }, Ie = function () { var Ce, je, ut, Wn, Zn, Fi, mo, bo, Ii, Le; if (mo = Fe(), ut = Ee(), !ut) return mo; for (Fi = { value: ut, prec: V(ut) }, bo = Fe(), bo || B("Expected expression after " + ut, W), Zn = [mo, Fi, bo]; (ut = Ee()) && (Wn = V(ut), Wn !== 0);) { for (Fi = { value: ut, prec: Wn }, Le = ut; Zn.length > 2 && Wn <= Zn[Zn.length - 2].prec;)bo = Zn.pop(), ut = Zn.pop().value, mo = Zn.pop(), je = z(ut, mo, bo), Zn.push(je); je = Fe(), je || B("Expected expression after " + Le, W), Zn.push(Fi, je) } for (Ii = Zn.length - 1, je = Zn[Ii]; Ii > 1;)je = z(Zn[Ii - 1].value, Zn[Ii - 2], je), Ii -= 2; return je }, Fe = function () { var Ce, je, ut; if (ue(), Ce = pe(W), k(Ce) || Ce === p) return We(); if (Ce === m || Ce === A) return Lt(); if (Ce === T) return Jn(); for (je = J.substr(W, E), ut = je.length; ut > 0;) { if (M.hasOwnProperty(je) && (!G(pe(W)) || W + je.length < J.length && !N(pe(W + je.length)))) return W += ut, { type: a, operator: je, argument: Fe(), prefix: !0 }; je = je.substr(0, --ut) } return G(Ce) || Ce === C ? _t() : !1 }, We = function () { for (var Ce = "", je, ut; k(pe(W));)Ce += de(W++); if (pe(W) === p) for (Ce += de(W++); k(pe(W));)Ce += de(W++); if (je = de(W), je === "e" || je === "E") { for (Ce += de(W++), je = de(W), (je === "+" || je === "-") && (Ce += de(W++)); k(pe(W));)Ce += de(W++); k(pe(W - 1)) || B("Expected exponent (" + Ce + de(W) + ")", W) } return ut = pe(W), G(ut) ? B("Variable names cannot start with a number (" + Ce + de(W) + ")", W) : ut === p && B("Unexpected period", W), { type: o, value: parseFloat(Ce), raw: Ce } }, Lt = function () {
                    for (var Ce = "", je = de(W++), ut = !1, Wn; W < oe;)if (Wn = de(W++), Wn === je) { ut = !0; break } else if (Wn === "\\") switch (Wn = de(W++), Wn) {
                        case "n": Ce += `
`; break; case "r": Ce += "\r"; break; case "t": Ce += "	"; break; case "b": Ce += "\b"; break; case "f": Ce += "\f"; break; case "v": Ce += "\v"; break; default: Ce += Wn
                    } else Ce += Wn; return ut || B('Unclosed quote after "' + Ce + '"', W), { type: o, value: Ce, raw: je + Ce + je }
                }, Gt = function () { var Ce = pe(W), je = W, ut; for (G(Ce) ? W++ : B("Unexpected " + de(W), W); W < oe && (Ce = pe(W), N(Ce));)W++; return ut = J.slice(je, W), v.hasOwnProperty(ut) ? { type: o, value: v[ut], raw: ut } : ut === O ? { type: r } : { type: n, name: ut } }, cn = function (Ce) { for (var je, ut = [], Wn, Zn = !1, Fi = 0; W < oe;)if (ue(), je = pe(W), je === Ce) { Zn = !0, W++, Ce === x && Fi && Fi >= ut.length && B("Unexpected token " + String.fromCharCode(Ce), W); break } else if (je === g) { if (W++, Fi++, Fi !== ut.length) { if (Ce === x) B("Unexpected token ,", W); else if (Ce === b) for (var mo = ut.length; mo < Fi; mo++)ut.push(null) } } else Wn = ge(), (!Wn || Wn.type === t) && B("Expected comma", W), ut.push(Wn); return Zn || B("Expected " + String.fromCharCode(Ce), W), ut }, _t = function () { var Ce, je; for (Ce = pe(W), Ce === C ? je = Pn() : je = Gt(), ue(), Ce = pe(W); Ce === p || Ce === T || Ce === C;)W++, Ce === p ? (ue(), je = { type: i, computed: !1, object: je, property: Gt() }) : Ce === T ? (je = { type: i, computed: !0, object: je, property: ge() }, ue(), Ce = pe(W), Ce !== b && B("Unclosed [", W), W++) : Ce === C && (je = { type: s, arguments: cn(x), callee: je }), ue(), Ce = pe(W); return je }, Pn = function () { W++; var Ce = ge(); if (ue(), pe(W) === x) return W++, Ce; B("Unclosed (", W) }, Jn = function () { return W++, { type: d, elements: cn(b) } }, at = [], Ne, nt; W < oe;)Ne = pe(W), Ne === D || Ne === g ? W++ : (nt = ge()) ? at.push(nt) : W < oe && B('Unexpected "' + de(W) + '"', W); return at.length === 1 ? at[0] : { type: t, body: at }
            }; if (X.version = "0.3.5", X.toString = function () { return "JavaScript Expression Parser (JSEP) v" + X.version }, X.addUnaryOp = function (J) { return E = Math.max(J.length, E), M[J] = R, this }, X.addBinaryOp = function (J, W) { return w = Math.max(J.length, w), L[J] = W, this }, X.addLiteral = function (J, W) { return v[J] = W, this }, X.removeUnaryOp = function (J) { return delete M[J], J.length === E && (E = _(M)), this }, X.removeAllUnaryOps = function () { return M = {}, E = 0, this }, X.removeBinaryOp = function (J) { return delete L[J], J.length === w && (w = _(L)), this }, X.removeAllBinaryOps = function () { return L = {}, w = 0, this }, X.removeLiteral = function (J) { return delete v[J], this }, X.removeAllLiterals = function () { return v = {}, this }, typeof iS > "u") { var q = e.jsep; e.jsep = X, X.noConflict = function () { return e.jsep === X && (e.jsep = q), X } } else typeof OB < "u" && OB.exports ? iS = OB.exports = X : iS.parse = X
        })(iS)
    }); var one = Wa((Kan, ine) => { "use strict"; ine.exports = Tke; var HS = 1e20; function Tke(e, t) { t || (t = {}); var n = t.cutoff == null ? .25 : t.cutoff, i = t.radius == null ? 8 : t.radius, o = t.channel || 0, r, s, a, c, u, f, d, p, g, m, A; if (ArrayBuffer.isView(e) || Array.isArray(e)) { if (!t.width || !t.height) throw Error("For raw data width and height should be provided by options"); r = t.width, s = t.height, c = e, t.stride ? f = t.stride : f = Math.floor(e.length / r / s) } else window.HTMLCanvasElement && e instanceof window.HTMLCanvasElement ? (p = e, d = p.getContext("2d"), r = p.width, s = p.height, g = d.getImageData(0, 0, r, s), c = g.data, f = 4) : window.CanvasRenderingContext2D && e instanceof window.CanvasRenderingContext2D ? (p = e.canvas, d = e, r = p.width, s = p.height, g = d.getImageData(0, 0, r, s), c = g.data, f = 4) : window.ImageData && e instanceof window.ImageData && (g = e, r = e.width, s = e.height, c = g.data, f = 4); if (a = Math.max(r, s), window.Uint8ClampedArray && c instanceof window.Uint8ClampedArray || window.Uint8Array && c instanceof window.Uint8Array) for (u = c, c = Array(r * s), m = 0, A = Math.floor(u.length / f); m < A; m++)c[m] = u[m * f + o] / 255; else if (f !== 1) throw Error("Raw data can have only 1 value per pixel"); var C = Array(r * s), x = Array(r * s), T = Array(a), b = Array(a), S = Array(a + 1), D = Array(a); for (m = 0, A = r * s; m < A; m++) { var P = c[m]; C[m] = P === 1 ? 0 : P === 0 ? HS : Math.pow(Math.max(0, .5 - P), 2), x[m] = P === 1 ? HS : P === 0 ? 0 : Math.pow(Math.max(0, P - .5), 2) } tne(C, r, s, T, b, D, S), tne(x, r, s, T, b, D, S); var B = window.Float32Array ? new Float32Array(r * s) : new Array(r * s); for (m = 0, A = r * s; m < A; m++)B[m] = Math.min(Math.max(1 - ((C[m] - x[m]) / i + n), 0), 1); return B } function tne(e, t, n, i, o, r, s) { for (var a = 0; a < t; a++) { for (var c = 0; c < n; c++)i[c] = e[c * t + a]; for (nne(i, o, r, s, n), c = 0; c < n; c++)e[c * t + a] = o[c] } for (c = 0; c < n; c++) { for (a = 0; a < t; a++)i[a] = e[c * t + a]; for (nne(i, o, r, s, t), a = 0; a < t; a++)e[c * t + a] = Math.sqrt(o[a]) } } function nne(e, t, n, i, o) { n[0] = 0, i[0] = -HS, i[1] = +HS; for (var r = 1, s = 0; r < o; r++) { for (var a = (e[r] + r * r - (e[n[s]] + n[s] * n[s])) / (2 * r - 2 * n[s]); a <= i[s];)s--, a = (e[r] + r * r - (e[n[s]] + n[s] * n[s])) / (2 * r - 2 * n[s]); s++, n[s] = r, i[s] = a, i[s + 1] = +HS } for (r = 0, s = 0; r < o; r++) { for (; i[s + 1] < r;)s++; t[r] = (r - n[s]) * (r - n[s]) + e[n[s]] } } }); var lne = Wa((dcn, IL) => { function Rke() { var e = 0, t = 1, n = 2, i = 3, o = 4, r = 5, s = 6, a = 7, c = 8, u = 9, f = 10, d = 11, p = 12, g = 13, m = 14, A = 15, C = 16, x = 17, T = 0, b = 1, S = 2, D = 3, P = 4; function B(_, E) { return 55296 <= _.charCodeAt(E) && _.charCodeAt(E) <= 56319 && 56320 <= _.charCodeAt(E + 1) && _.charCodeAt(E + 1) <= 57343 } function R(_, E) { E === void 0 && (E = 0); var w = _.charCodeAt(E); if (55296 <= w && w <= 56319 && E < _.length - 1) { var v = w, O = _.charCodeAt(E + 1); return 56320 <= O && O <= 57343 ? (v - 55296) * 1024 + (O - 56320) + 65536 : v } if (56320 <= w && w <= 57343 && E >= 1) { var v = _.charCodeAt(E - 1), O = w; return 55296 <= v && v <= 56319 ? (v - 55296) * 1024 + (O - 56320) + 65536 : O } return w } function M(_, E, w) { var v = [_].concat(E).concat([w]), O = v[v.length - 2], V = w, z = v.lastIndexOf(m); if (z > 1 && v.slice(1, z).every(function (N) { return N == i }) && [i, g, x].indexOf(_) == -1) return S; var k = v.lastIndexOf(o); if (k > 0 && v.slice(1, k).every(function (N) { return N == o }) && [p, o].indexOf(O) == -1) return v.filter(function (N) { return N == o }).length % 2 == 1 ? D : P; if (O == e && V == t) return T; if (O == n || O == e || O == t) return V == m && E.every(function (N) { return N == i }) ? S : b; if (V == n || V == e || V == t) return b; if (O == s && (V == s || V == a || V == u || V == f)) return T; if ((O == u || O == a) && (V == a || V == c)) return T; if ((O == f || O == c) && V == c) return T; if (V == i || V == A) return T; if (V == r) return T; if (O == p) return T; var G = v.indexOf(i) != -1 ? v.lastIndexOf(i) - 1 : v.length - 2; return [g, x].indexOf(v[G]) != -1 && v.slice(G + 1, -1).every(function (N) { return N == i }) && V == m || O == A && [C, x].indexOf(V) != -1 ? T : E.indexOf(o) != -1 ? S : O == o && V == o ? T : b } this.nextBreak = function (_, E) { if (E === void 0 && (E = 0), E < 0) return 0; if (E >= _.length - 1) return _.length; for (var w = L(R(_, E)), v = [], O = E + 1; O < _.length; O++)if (!B(_, O - 1)) { var V = L(R(_, O)); if (M(w, v, V)) return O; v.push(V) } return _.length }, this.splitGraphemes = function (_) { for (var E = [], w = 0, v; (v = this.nextBreak(_, w)) < _.length;)E.push(_.slice(w, v)), w = v; return w < _.length && E.push(_.slice(w)), E }, this.iterateGraphemes = function (_) { var E = 0, w = { next: function () { var v, O; return (O = this.nextBreak(_, E)) < _.length ? (v = _.slice(E, O), E = O, { value: v, done: !1 }) : E < _.length ? (v = _.slice(E), E = _.length, { value: v, done: !1 }) : { value: void 0, done: !0 } }.bind(this) }; return typeof Symbol < "u" && Symbol.iterator && (w[Symbol.iterator] = function () { return w }), w }, this.countGraphemes = function (_) { for (var E = 0, w = 0, v; (v = this.nextBreak(_, w)) < _.length;)w = v, E++; return w < _.length && E++, E }; function L(_) { return 1536 <= _ && _ <= 1541 || _ == 1757 || _ == 1807 || _ == 2274 || _ == 3406 || _ == 69821 || 70082 <= _ && _ <= 70083 || _ == 72250 || 72326 <= _ && _ <= 72329 || _ == 73030 ? p : _ == 13 ? e : _ == 10 ? t : 0 <= _ && _ <= 9 || 11 <= _ && _ <= 12 || 14 <= _ && _ <= 31 || 127 <= _ && _ <= 159 || _ == 173 || _ == 1564 || _ == 6158 || _ == 8203 || 8206 <= _ && _ <= 8207 || _ == 8232 || _ == 8233 || 8234 <= _ && _ <= 8238 || 8288 <= _ && _ <= 8292 || _ == 8293 || 8294 <= _ && _ <= 8303 || 55296 <= _ && _ <= 57343 || _ == 65279 || 65520 <= _ && _ <= 65528 || 65529 <= _ && _ <= 65531 || 113824 <= _ && _ <= 113827 || 119155 <= _ && _ <= 119162 || _ == 917504 || _ == 917505 || 917506 <= _ && _ <= 917535 || 917632 <= _ && _ <= 917759 || 918e3 <= _ && _ <= 921599 ? n : 768 <= _ && _ <= 879 || 1155 <= _ && _ <= 1159 || 1160 <= _ && _ <= 1161 || 1425 <= _ && _ <= 1469 || _ == 1471 || 1473 <= _ && _ <= 1474 || 1476 <= _ && _ <= 1477 || _ == 1479 || 1552 <= _ && _ <= 1562 || 1611 <= _ && _ <= 1631 || _ == 1648 || 1750 <= _ && _ <= 1756 || 1759 <= _ && _ <= 1764 || 1767 <= _ && _ <= 1768 || 1770 <= _ && _ <= 1773 || _ == 1809 || 1840 <= _ && _ <= 1866 || 1958 <= _ && _ <= 1968 || 2027 <= _ && _ <= 2035 || 2070 <= _ && _ <= 2073 || 2075 <= _ && _ <= 2083 || 2085 <= _ && _ <= 2087 || 2089 <= _ && _ <= 2093 || 2137 <= _ && _ <= 2139 || 2260 <= _ && _ <= 2273 || 2275 <= _ && _ <= 2306 || _ == 2362 || _ == 2364 || 2369 <= _ && _ <= 2376 || _ == 2381 || 2385 <= _ && _ <= 2391 || 2402 <= _ && _ <= 2403 || _ == 2433 || _ == 2492 || _ == 2494 || 2497 <= _ && _ <= 2500 || _ == 2509 || _ == 2519 || 2530 <= _ && _ <= 2531 || 2561 <= _ && _ <= 2562 || _ == 2620 || 2625 <= _ && _ <= 2626 || 2631 <= _ && _ <= 2632 || 2635 <= _ && _ <= 2637 || _ == 2641 || 2672 <= _ && _ <= 2673 || _ == 2677 || 2689 <= _ && _ <= 2690 || _ == 2748 || 2753 <= _ && _ <= 2757 || 2759 <= _ && _ <= 2760 || _ == 2765 || 2786 <= _ && _ <= 2787 || 2810 <= _ && _ <= 2815 || _ == 2817 || _ == 2876 || _ == 2878 || _ == 2879 || 2881 <= _ && _ <= 2884 || _ == 2893 || _ == 2902 || _ == 2903 || 2914 <= _ && _ <= 2915 || _ == 2946 || _ == 3006 || _ == 3008 || _ == 3021 || _ == 3031 || _ == 3072 || 3134 <= _ && _ <= 3136 || 3142 <= _ && _ <= 3144 || 3146 <= _ && _ <= 3149 || 3157 <= _ && _ <= 3158 || 3170 <= _ && _ <= 3171 || _ == 3201 || _ == 3260 || _ == 3263 || _ == 3266 || _ == 3270 || 3276 <= _ && _ <= 3277 || 3285 <= _ && _ <= 3286 || 3298 <= _ && _ <= 3299 || 3328 <= _ && _ <= 3329 || 3387 <= _ && _ <= 3388 || _ == 3390 || 3393 <= _ && _ <= 3396 || _ == 3405 || _ == 3415 || 3426 <= _ && _ <= 3427 || _ == 3530 || _ == 3535 || 3538 <= _ && _ <= 3540 || _ == 3542 || _ == 3551 || _ == 3633 || 3636 <= _ && _ <= 3642 || 3655 <= _ && _ <= 3662 || _ == 3761 || 3764 <= _ && _ <= 3769 || 3771 <= _ && _ <= 3772 || 3784 <= _ && _ <= 3789 || 3864 <= _ && _ <= 3865 || _ == 3893 || _ == 3895 || _ == 3897 || 3953 <= _ && _ <= 3966 || 3968 <= _ && _ <= 3972 || 3974 <= _ && _ <= 3975 || 3981 <= _ && _ <= 3991 || 3993 <= _ && _ <= 4028 || _ == 4038 || 4141 <= _ && _ <= 4144 || 4146 <= _ && _ <= 4151 || 4153 <= _ && _ <= 4154 || 4157 <= _ && _ <= 4158 || 4184 <= _ && _ <= 4185 || 4190 <= _ && _ <= 4192 || 4209 <= _ && _ <= 4212 || _ == 4226 || 4229 <= _ && _ <= 4230 || _ == 4237 || _ == 4253 || 4957 <= _ && _ <= 4959 || 5906 <= _ && _ <= 5908 || 5938 <= _ && _ <= 5940 || 5970 <= _ && _ <= 5971 || 6002 <= _ && _ <= 6003 || 6068 <= _ && _ <= 6069 || 6071 <= _ && _ <= 6077 || _ == 6086 || 6089 <= _ && _ <= 6099 || _ == 6109 || 6155 <= _ && _ <= 6157 || 6277 <= _ && _ <= 6278 || _ == 6313 || 6432 <= _ && _ <= 6434 || 6439 <= _ && _ <= 6440 || _ == 6450 || 6457 <= _ && _ <= 6459 || 6679 <= _ && _ <= 6680 || _ == 6683 || _ == 6742 || 6744 <= _ && _ <= 6750 || _ == 6752 || _ == 6754 || 6757 <= _ && _ <= 6764 || 6771 <= _ && _ <= 6780 || _ == 6783 || 6832 <= _ && _ <= 6845 || _ == 6846 || 6912 <= _ && _ <= 6915 || _ == 6964 || 6966 <= _ && _ <= 6970 || _ == 6972 || _ == 6978 || 7019 <= _ && _ <= 7027 || 7040 <= _ && _ <= 7041 || 7074 <= _ && _ <= 7077 || 7080 <= _ && _ <= 7081 || 7083 <= _ && _ <= 7085 || _ == 7142 || 7144 <= _ && _ <= 7145 || _ == 7149 || 7151 <= _ && _ <= 7153 || 7212 <= _ && _ <= 7219 || 7222 <= _ && _ <= 7223 || 7376 <= _ && _ <= 7378 || 7380 <= _ && _ <= 7392 || 7394 <= _ && _ <= 7400 || _ == 7405 || _ == 7412 || 7416 <= _ && _ <= 7417 || 7616 <= _ && _ <= 7673 || 7675 <= _ && _ <= 7679 || _ == 8204 || 8400 <= _ && _ <= 8412 || 8413 <= _ && _ <= 8416 || _ == 8417 || 8418 <= _ && _ <= 8420 || 8421 <= _ && _ <= 8432 || 11503 <= _ && _ <= 11505 || _ == 11647 || 11744 <= _ && _ <= 11775 || 12330 <= _ && _ <= 12333 || 12334 <= _ && _ <= 12335 || 12441 <= _ && _ <= 12442 || _ == 42607 || 42608 <= _ && _ <= 42610 || 42612 <= _ && _ <= 42621 || 42654 <= _ && _ <= 42655 || 42736 <= _ && _ <= 42737 || _ == 43010 || _ == 43014 || _ == 43019 || 43045 <= _ && _ <= 43046 || 43204 <= _ && _ <= 43205 || 43232 <= _ && _ <= 43249 || 43302 <= _ && _ <= 43309 || 43335 <= _ && _ <= 43345 || 43392 <= _ && _ <= 43394 || _ == 43443 || 43446 <= _ && _ <= 43449 || _ == 43452 || _ == 43493 || 43561 <= _ && _ <= 43566 || 43569 <= _ && _ <= 43570 || 43573 <= _ && _ <= 43574 || _ == 43587 || _ == 43596 || _ == 43644 || _ == 43696 || 43698 <= _ && _ <= 43700 || 43703 <= _ && _ <= 43704 || 43710 <= _ && _ <= 43711 || _ == 43713 || 43756 <= _ && _ <= 43757 || _ == 43766 || _ == 44005 || _ == 44008 || _ == 44013 || _ == 64286 || 65024 <= _ && _ <= 65039 || 65056 <= _ && _ <= 65071 || 65438 <= _ && _ <= 65439 || _ == 66045 || _ == 66272 || 66422 <= _ && _ <= 66426 || 68097 <= _ && _ <= 68099 || 68101 <= _ && _ <= 68102 || 68108 <= _ && _ <= 68111 || 68152 <= _ && _ <= 68154 || _ == 68159 || 68325 <= _ && _ <= 68326 || _ == 69633 || 69688 <= _ && _ <= 69702 || 69759 <= _ && _ <= 69761 || 69811 <= _ && _ <= 69814 || 69817 <= _ && _ <= 69818 || 69888 <= _ && _ <= 69890 || 69927 <= _ && _ <= 69931 || 69933 <= _ && _ <= 69940 || _ == 70003 || 70016 <= _ && _ <= 70017 || 70070 <= _ && _ <= 70078 || 70090 <= _ && _ <= 70092 || 70191 <= _ && _ <= 70193 || _ == 70196 || 70198 <= _ && _ <= 70199 || _ == 70206 || _ == 70367 || 70371 <= _ && _ <= 70378 || 70400 <= _ && _ <= 70401 || _ == 70460 || _ == 70462 || _ == 70464 || _ == 70487 || 70502 <= _ && _ <= 70508 || 70512 <= _ && _ <= 70516 || 70712 <= _ && _ <= 70719 || 70722 <= _ && _ <= 70724 || _ == 70726 || _ == 70832 || 70835 <= _ && _ <= 70840 || _ == 70842 || _ == 70845 || 70847 <= _ && _ <= 70848 || 70850 <= _ && _ <= 70851 || _ == 71087 || 71090 <= _ && _ <= 71093 || 71100 <= _ && _ <= 71101 || 71103 <= _ && _ <= 71104 || 71132 <= _ && _ <= 71133 || 71219 <= _ && _ <= 71226 || _ == 71229 || 71231 <= _ && _ <= 71232 || _ == 71339 || _ == 71341 || 71344 <= _ && _ <= 71349 || _ == 71351 || 71453 <= _ && _ <= 71455 || 71458 <= _ && _ <= 71461 || 71463 <= _ && _ <= 71467 || 72193 <= _ && _ <= 72198 || 72201 <= _ && _ <= 72202 || 72243 <= _ && _ <= 72248 || 72251 <= _ && _ <= 72254 || _ == 72263 || 72273 <= _ && _ <= 72278 || 72281 <= _ && _ <= 72283 || 72330 <= _ && _ <= 72342 || 72344 <= _ && _ <= 72345 || 72752 <= _ && _ <= 72758 || 72760 <= _ && _ <= 72765 || _ == 72767 || 72850 <= _ && _ <= 72871 || 72874 <= _ && _ <= 72880 || 72882 <= _ && _ <= 72883 || 72885 <= _ && _ <= 72886 || 73009 <= _ && _ <= 73014 || _ == 73018 || 73020 <= _ && _ <= 73021 || 73023 <= _ && _ <= 73029 || _ == 73031 || 92912 <= _ && _ <= 92916 || 92976 <= _ && _ <= 92982 || 94095 <= _ && _ <= 94098 || 113821 <= _ && _ <= 113822 || _ == 119141 || 119143 <= _ && _ <= 119145 || 119150 <= _ && _ <= 119154 || 119163 <= _ && _ <= 119170 || 119173 <= _ && _ <= 119179 || 119210 <= _ && _ <= 119213 || 119362 <= _ && _ <= 119364 || 121344 <= _ && _ <= 121398 || 121403 <= _ && _ <= 121452 || _ == 121461 || _ == 121476 || 121499 <= _ && _ <= 121503 || 121505 <= _ && _ <= 121519 || 122880 <= _ && _ <= 122886 || 122888 <= _ && _ <= 122904 || 122907 <= _ && _ <= 122913 || 122915 <= _ && _ <= 122916 || 122918 <= _ && _ <= 122922 || 125136 <= _ && _ <= 125142 || 125252 <= _ && _ <= 125258 || 917536 <= _ && _ <= 917631 || 917760 <= _ && _ <= 917999 ? i : 127462 <= _ && _ <= 127487 ? o : _ == 2307 || _ == 2363 || 2366 <= _ && _ <= 2368 || 2377 <= _ && _ <= 2380 || 2382 <= _ && _ <= 2383 || 2434 <= _ && _ <= 2435 || 2495 <= _ && _ <= 2496 || 2503 <= _ && _ <= 2504 || 2507 <= _ && _ <= 2508 || _ == 2563 || 2622 <= _ && _ <= 2624 || _ == 2691 || 2750 <= _ && _ <= 2752 || _ == 2761 || 2763 <= _ && _ <= 2764 || 2818 <= _ && _ <= 2819 || _ == 2880 || 2887 <= _ && _ <= 2888 || 2891 <= _ && _ <= 2892 || _ == 3007 || 3009 <= _ && _ <= 3010 || 3014 <= _ && _ <= 3016 || 3018 <= _ && _ <= 3020 || 3073 <= _ && _ <= 3075 || 3137 <= _ && _ <= 3140 || 3202 <= _ && _ <= 3203 || _ == 3262 || 3264 <= _ && _ <= 3265 || 3267 <= _ && _ <= 3268 || 3271 <= _ && _ <= 3272 || 3274 <= _ && _ <= 3275 || 3330 <= _ && _ <= 3331 || 3391 <= _ && _ <= 3392 || 3398 <= _ && _ <= 3400 || 3402 <= _ && _ <= 3404 || 3458 <= _ && _ <= 3459 || 3536 <= _ && _ <= 3537 || 3544 <= _ && _ <= 3550 || 3570 <= _ && _ <= 3571 || _ == 3635 || _ == 3763 || 3902 <= _ && _ <= 3903 || _ == 3967 || _ == 4145 || 4155 <= _ && _ <= 4156 || 4182 <= _ && _ <= 4183 || _ == 4228 || _ == 6070 || 6078 <= _ && _ <= 6085 || 6087 <= _ && _ <= 6088 || 6435 <= _ && _ <= 6438 || 6441 <= _ && _ <= 6443 || 6448 <= _ && _ <= 6449 || 6451 <= _ && _ <= 6456 || 6681 <= _ && _ <= 6682 || _ == 6741 || _ == 6743 || 6765 <= _ && _ <= 6770 || _ == 6916 || _ == 6965 || _ == 6971 || 6973 <= _ && _ <= 6977 || 6979 <= _ && _ <= 6980 || _ == 7042 || _ == 7073 || 7078 <= _ && _ <= 7079 || _ == 7082 || _ == 7143 || 7146 <= _ && _ <= 7148 || _ == 7150 || 7154 <= _ && _ <= 7155 || 7204 <= _ && _ <= 7211 || 7220 <= _ && _ <= 7221 || _ == 7393 || 7410 <= _ && _ <= 7411 || _ == 7415 || 43043 <= _ && _ <= 43044 || _ == 43047 || 43136 <= _ && _ <= 43137 || 43188 <= _ && _ <= 43203 || 43346 <= _ && _ <= 43347 || _ == 43395 || 43444 <= _ && _ <= 43445 || 43450 <= _ && _ <= 43451 || 43453 <= _ && _ <= 43456 || 43567 <= _ && _ <= 43568 || 43571 <= _ && _ <= 43572 || _ == 43597 || _ == 43755 || 43758 <= _ && _ <= 43759 || _ == 43765 || 44003 <= _ && _ <= 44004 || 44006 <= _ && _ <= 44007 || 44009 <= _ && _ <= 44010 || _ == 44012 || _ == 69632 || _ == 69634 || _ == 69762 || 69808 <= _ && _ <= 69810 || 69815 <= _ && _ <= 69816 || _ == 69932 || _ == 70018 || 70067 <= _ && _ <= 70069 || 70079 <= _ && _ <= 70080 || 70188 <= _ && _ <= 70190 || 70194 <= _ && _ <= 70195 || _ == 70197 || 70368 <= _ && _ <= 70370 || 70402 <= _ && _ <= 70403 || _ == 70463 || 70465 <= _ && _ <= 70468 || 70471 <= _ && _ <= 70472 || 70475 <= _ && _ <= 70477 || 70498 <= _ && _ <= 70499 || 70709 <= _ && _ <= 70711 || 70720 <= _ && _ <= 70721 || _ == 70725 || 70833 <= _ && _ <= 70834 || _ == 70841 || 70843 <= _ && _ <= 70844 || _ == 70846 || _ == 70849 || 71088 <= _ && _ <= 71089 || 71096 <= _ && _ <= 71099 || _ == 71102 || 71216 <= _ && _ <= 71218 || 71227 <= _ && _ <= 71228 || _ == 71230 || _ == 71340 || 71342 <= _ && _ <= 71343 || _ == 71350 || 71456 <= _ && _ <= 71457 || _ == 71462 || 72199 <= _ && _ <= 72200 || _ == 72249 || 72279 <= _ && _ <= 72280 || _ == 72343 || _ == 72751 || _ == 72766 || _ == 72873 || _ == 72881 || _ == 72884 || 94033 <= _ && _ <= 94078 || _ == 119142 || _ == 119149 ? r : 4352 <= _ && _ <= 4447 || 43360 <= _ && _ <= 43388 ? s : 4448 <= _ && _ <= 4519 || 55216 <= _ && _ <= 55238 ? a : 4520 <= _ && _ <= 4607 || 55243 <= _ && _ <= 55291 ? c : _ == 44032 || _ == 44060 || _ == 44088 || _ == 44116 || _ == 44144 || _ == 44172 || _ == 44200 || _ == 44228 || _ == 44256 || _ == 44284 || _ == 44312 || _ == 44340 || _ == 44368 || _ == 44396 || _ == 44424 || _ == 44452 || _ == 44480 || _ == 44508 || _ == 44536 || _ == 44564 || _ == 44592 || _ == 44620 || _ == 44648 || _ == 44676 || _ == 44704 || _ == 44732 || _ == 44760 || _ == 44788 || _ == 44816 || _ == 44844 || _ == 44872 || _ == 44900 || _ == 44928 || _ == 44956 || _ == 44984 || _ == 45012 || _ == 45040 || _ == 45068 || _ == 45096 || _ == 45124 || _ == 45152 || _ == 45180 || _ == 45208 || _ == 45236 || _ == 45264 || _ == 45292 || _ == 45320 || _ == 45348 || _ == 45376 || _ == 45404 || _ == 45432 || _ == 45460 || _ == 45488 || _ == 45516 || _ == 45544 || _ == 45572 || _ == 45600 || _ == 45628 || _ == 45656 || _ == 45684 || _ == 45712 || _ == 45740 || _ == 45768 || _ == 45796 || _ == 45824 || _ == 45852 || _ == 45880 || _ == 45908 || _ == 45936 || _ == 45964 || _ == 45992 || _ == 46020 || _ == 46048 || _ == 46076 || _ == 46104 || _ == 46132 || _ == 46160 || _ == 46188 || _ == 46216 || _ == 46244 || _ == 46272 || _ == 46300 || _ == 46328 || _ == 46356 || _ == 46384 || _ == 46412 || _ == 46440 || _ == 46468 || _ == 46496 || _ == 46524 || _ == 46552 || _ == 46580 || _ == 46608 || _ == 46636 || _ == 46664 || _ == 46692 || _ == 46720 || _ == 46748 || _ == 46776 || _ == 46804 || _ == 46832 || _ == 46860 || _ == 46888 || _ == 46916 || _ == 46944 || _ == 46972 || _ == 47e3 || _ == 47028 || _ == 47056 || _ == 47084 || _ == 47112 || _ == 47140 || _ == 47168 || _ == 47196 || _ == 47224 || _ == 47252 || _ == 47280 || _ == 47308 || _ == 47336 || _ == 47364 || _ == 47392 || _ == 47420 || _ == 47448 || _ == 47476 || _ == 47504 || _ == 47532 || _ == 47560 || _ == 47588 || _ == 47616 || _ == 47644 || _ == 47672 || _ == 47700 || _ == 47728 || _ == 47756 || _ == 47784 || _ == 47812 || _ == 47840 || _ == 47868 || _ == 47896 || _ == 47924 || _ == 47952 || _ == 47980 || _ == 48008 || _ == 48036 || _ == 48064 || _ == 48092 || _ == 48120 || _ == 48148 || _ == 48176 || _ == 48204 || _ == 48232 || _ == 48260 || _ == 48288 || _ == 48316 || _ == 48344 || _ == 48372 || _ == 48400 || _ == 48428 || _ == 48456 || _ == 48484 || _ == 48512 || _ == 48540 || _ == 48568 || _ == 48596 || _ == 48624 || _ == 48652 || _ == 48680 || _ == 48708 || _ == 48736 || _ == 48764 || _ == 48792 || _ == 48820 || _ == 48848 || _ == 48876 || _ == 48904 || _ == 48932 || _ == 48960 || _ == 48988 || _ == 49016 || _ == 49044 || _ == 49072 || _ == 49100 || _ == 49128 || _ == 49156 || _ == 49184 || _ == 49212 || _ == 49240 || _ == 49268 || _ == 49296 || _ == 49324 || _ == 49352 || _ == 49380 || _ == 49408 || _ == 49436 || _ == 49464 || _ == 49492 || _ == 49520 || _ == 49548 || _ == 49576 || _ == 49604 || _ == 49632 || _ == 49660 || _ == 49688 || _ == 49716 || _ == 49744 || _ == 49772 || _ == 49800 || _ == 49828 || _ == 49856 || _ == 49884 || _ == 49912 || _ == 49940 || _ == 49968 || _ == 49996 || _ == 50024 || _ == 50052 || _ == 50080 || _ == 50108 || _ == 50136 || _ == 50164 || _ == 50192 || _ == 50220 || _ == 50248 || _ == 50276 || _ == 50304 || _ == 50332 || _ == 50360 || _ == 50388 || _ == 50416 || _ == 50444 || _ == 50472 || _ == 50500 || _ == 50528 || _ == 50556 || _ == 50584 || _ == 50612 || _ == 50640 || _ == 50668 || _ == 50696 || _ == 50724 || _ == 50752 || _ == 50780 || _ == 50808 || _ == 50836 || _ == 50864 || _ == 50892 || _ == 50920 || _ == 50948 || _ == 50976 || _ == 51004 || _ == 51032 || _ == 51060 || _ == 51088 || _ == 51116 || _ == 51144 || _ == 51172 || _ == 51200 || _ == 51228 || _ == 51256 || _ == 51284 || _ == 51312 || _ == 51340 || _ == 51368 || _ == 51396 || _ == 51424 || _ == 51452 || _ == 51480 || _ == 51508 || _ == 51536 || _ == 51564 || _ == 51592 || _ == 51620 || _ == 51648 || _ == 51676 || _ == 51704 || _ == 51732 || _ == 51760 || _ == 51788 || _ == 51816 || _ == 51844 || _ == 51872 || _ == 51900 || _ == 51928 || _ == 51956 || _ == 51984 || _ == 52012 || _ == 52040 || _ == 52068 || _ == 52096 || _ == 52124 || _ == 52152 || _ == 52180 || _ == 52208 || _ == 52236 || _ == 52264 || _ == 52292 || _ == 52320 || _ == 52348 || _ == 52376 || _ == 52404 || _ == 52432 || _ == 52460 || _ == 52488 || _ == 52516 || _ == 52544 || _ == 52572 || _ == 52600 || _ == 52628 || _ == 52656 || _ == 52684 || _ == 52712 || _ == 52740 || _ == 52768 || _ == 52796 || _ == 52824 || _ == 52852 || _ == 52880 || _ == 52908 || _ == 52936 || _ == 52964 || _ == 52992 || _ == 53020 || _ == 53048 || _ == 53076 || _ == 53104 || _ == 53132 || _ == 53160 || _ == 53188 || _ == 53216 || _ == 53244 || _ == 53272 || _ == 53300 || _ == 53328 || _ == 53356 || _ == 53384 || _ == 53412 || _ == 53440 || _ == 53468 || _ == 53496 || _ == 53524 || _ == 53552 || _ == 53580 || _ == 53608 || _ == 53636 || _ == 53664 || _ == 53692 || _ == 53720 || _ == 53748 || _ == 53776 || _ == 53804 || _ == 53832 || _ == 53860 || _ == 53888 || _ == 53916 || _ == 53944 || _ == 53972 || _ == 54e3 || _ == 54028 || _ == 54056 || _ == 54084 || _ == 54112 || _ == 54140 || _ == 54168 || _ == 54196 || _ == 54224 || _ == 54252 || _ == 54280 || _ == 54308 || _ == 54336 || _ == 54364 || _ == 54392 || _ == 54420 || _ == 54448 || _ == 54476 || _ == 54504 || _ == 54532 || _ == 54560 || _ == 54588 || _ == 54616 || _ == 54644 || _ == 54672 || _ == 54700 || _ == 54728 || _ == 54756 || _ == 54784 || _ == 54812 || _ == 54840 || _ == 54868 || _ == 54896 || _ == 54924 || _ == 54952 || _ == 54980 || _ == 55008 || _ == 55036 || _ == 55064 || _ == 55092 || _ == 55120 || _ == 55148 || _ == 55176 ? u : 44033 <= _ && _ <= 44059 || 44061 <= _ && _ <= 44087 || 44089 <= _ && _ <= 44115 || 44117 <= _ && _ <= 44143 || 44145 <= _ && _ <= 44171 || 44173 <= _ && _ <= 44199 || 44201 <= _ && _ <= 44227 || 44229 <= _ && _ <= 44255 || 44257 <= _ && _ <= 44283 || 44285 <= _ && _ <= 44311 || 44313 <= _ && _ <= 44339 || 44341 <= _ && _ <= 44367 || 44369 <= _ && _ <= 44395 || 44397 <= _ && _ <= 44423 || 44425 <= _ && _ <= 44451 || 44453 <= _ && _ <= 44479 || 44481 <= _ && _ <= 44507 || 44509 <= _ && _ <= 44535 || 44537 <= _ && _ <= 44563 || 44565 <= _ && _ <= 44591 || 44593 <= _ && _ <= 44619 || 44621 <= _ && _ <= 44647 || 44649 <= _ && _ <= 44675 || 44677 <= _ && _ <= 44703 || 44705 <= _ && _ <= 44731 || 44733 <= _ && _ <= 44759 || 44761 <= _ && _ <= 44787 || 44789 <= _ && _ <= 44815 || 44817 <= _ && _ <= 44843 || 44845 <= _ && _ <= 44871 || 44873 <= _ && _ <= 44899 || 44901 <= _ && _ <= 44927 || 44929 <= _ && _ <= 44955 || 44957 <= _ && _ <= 44983 || 44985 <= _ && _ <= 45011 || 45013 <= _ && _ <= 45039 || 45041 <= _ && _ <= 45067 || 45069 <= _ && _ <= 45095 || 45097 <= _ && _ <= 45123 || 45125 <= _ && _ <= 45151 || 45153 <= _ && _ <= 45179 || 45181 <= _ && _ <= 45207 || 45209 <= _ && _ <= 45235 || 45237 <= _ && _ <= 45263 || 45265 <= _ && _ <= 45291 || 45293 <= _ && _ <= 45319 || 45321 <= _ && _ <= 45347 || 45349 <= _ && _ <= 45375 || 45377 <= _ && _ <= 45403 || 45405 <= _ && _ <= 45431 || 45433 <= _ && _ <= 45459 || 45461 <= _ && _ <= 45487 || 45489 <= _ && _ <= 45515 || 45517 <= _ && _ <= 45543 || 45545 <= _ && _ <= 45571 || 45573 <= _ && _ <= 45599 || 45601 <= _ && _ <= 45627 || 45629 <= _ && _ <= 45655 || 45657 <= _ && _ <= 45683 || 45685 <= _ && _ <= 45711 || 45713 <= _ && _ <= 45739 || 45741 <= _ && _ <= 45767 || 45769 <= _ && _ <= 45795 || 45797 <= _ && _ <= 45823 || 45825 <= _ && _ <= 45851 || 45853 <= _ && _ <= 45879 || 45881 <= _ && _ <= 45907 || 45909 <= _ && _ <= 45935 || 45937 <= _ && _ <= 45963 || 45965 <= _ && _ <= 45991 || 45993 <= _ && _ <= 46019 || 46021 <= _ && _ <= 46047 || 46049 <= _ && _ <= 46075 || 46077 <= _ && _ <= 46103 || 46105 <= _ && _ <= 46131 || 46133 <= _ && _ <= 46159 || 46161 <= _ && _ <= 46187 || 46189 <= _ && _ <= 46215 || 46217 <= _ && _ <= 46243 || 46245 <= _ && _ <= 46271 || 46273 <= _ && _ <= 46299 || 46301 <= _ && _ <= 46327 || 46329 <= _ && _ <= 46355 || 46357 <= _ && _ <= 46383 || 46385 <= _ && _ <= 46411 || 46413 <= _ && _ <= 46439 || 46441 <= _ && _ <= 46467 || 46469 <= _ && _ <= 46495 || 46497 <= _ && _ <= 46523 || 46525 <= _ && _ <= 46551 || 46553 <= _ && _ <= 46579 || 46581 <= _ && _ <= 46607 || 46609 <= _ && _ <= 46635 || 46637 <= _ && _ <= 46663 || 46665 <= _ && _ <= 46691 || 46693 <= _ && _ <= 46719 || 46721 <= _ && _ <= 46747 || 46749 <= _ && _ <= 46775 || 46777 <= _ && _ <= 46803 || 46805 <= _ && _ <= 46831 || 46833 <= _ && _ <= 46859 || 46861 <= _ && _ <= 46887 || 46889 <= _ && _ <= 46915 || 46917 <= _ && _ <= 46943 || 46945 <= _ && _ <= 46971 || 46973 <= _ && _ <= 46999 || 47001 <= _ && _ <= 47027 || 47029 <= _ && _ <= 47055 || 47057 <= _ && _ <= 47083 || 47085 <= _ && _ <= 47111 || 47113 <= _ && _ <= 47139 || 47141 <= _ && _ <= 47167 || 47169 <= _ && _ <= 47195 || 47197 <= _ && _ <= 47223 || 47225 <= _ && _ <= 47251 || 47253 <= _ && _ <= 47279 || 47281 <= _ && _ <= 47307 || 47309 <= _ && _ <= 47335 || 47337 <= _ && _ <= 47363 || 47365 <= _ && _ <= 47391 || 47393 <= _ && _ <= 47419 || 47421 <= _ && _ <= 47447 || 47449 <= _ && _ <= 47475 || 47477 <= _ && _ <= 47503 || 47505 <= _ && _ <= 47531 || 47533 <= _ && _ <= 47559 || 47561 <= _ && _ <= 47587 || 47589 <= _ && _ <= 47615 || 47617 <= _ && _ <= 47643 || 47645 <= _ && _ <= 47671 || 47673 <= _ && _ <= 47699 || 47701 <= _ && _ <= 47727 || 47729 <= _ && _ <= 47755 || 47757 <= _ && _ <= 47783 || 47785 <= _ && _ <= 47811 || 47813 <= _ && _ <= 47839 || 47841 <= _ && _ <= 47867 || 47869 <= _ && _ <= 47895 || 47897 <= _ && _ <= 47923 || 47925 <= _ && _ <= 47951 || 47953 <= _ && _ <= 47979 || 47981 <= _ && _ <= 48007 || 48009 <= _ && _ <= 48035 || 48037 <= _ && _ <= 48063 || 48065 <= _ && _ <= 48091 || 48093 <= _ && _ <= 48119 || 48121 <= _ && _ <= 48147 || 48149 <= _ && _ <= 48175 || 48177 <= _ && _ <= 48203 || 48205 <= _ && _ <= 48231 || 48233 <= _ && _ <= 48259 || 48261 <= _ && _ <= 48287 || 48289 <= _ && _ <= 48315 || 48317 <= _ && _ <= 48343 || 48345 <= _ && _ <= 48371 || 48373 <= _ && _ <= 48399 || 48401 <= _ && _ <= 48427 || 48429 <= _ && _ <= 48455 || 48457 <= _ && _ <= 48483 || 48485 <= _ && _ <= 48511 || 48513 <= _ && _ <= 48539 || 48541 <= _ && _ <= 48567 || 48569 <= _ && _ <= 48595 || 48597 <= _ && _ <= 48623 || 48625 <= _ && _ <= 48651 || 48653 <= _ && _ <= 48679 || 48681 <= _ && _ <= 48707 || 48709 <= _ && _ <= 48735 || 48737 <= _ && _ <= 48763 || 48765 <= _ && _ <= 48791 || 48793 <= _ && _ <= 48819 || 48821 <= _ && _ <= 48847 || 48849 <= _ && _ <= 48875 || 48877 <= _ && _ <= 48903 || 48905 <= _ && _ <= 48931 || 48933 <= _ && _ <= 48959 || 48961 <= _ && _ <= 48987 || 48989 <= _ && _ <= 49015 || 49017 <= _ && _ <= 49043 || 49045 <= _ && _ <= 49071 || 49073 <= _ && _ <= 49099 || 49101 <= _ && _ <= 49127 || 49129 <= _ && _ <= 49155 || 49157 <= _ && _ <= 49183 || 49185 <= _ && _ <= 49211 || 49213 <= _ && _ <= 49239 || 49241 <= _ && _ <= 49267 || 49269 <= _ && _ <= 49295 || 49297 <= _ && _ <= 49323 || 49325 <= _ && _ <= 49351 || 49353 <= _ && _ <= 49379 || 49381 <= _ && _ <= 49407 || 49409 <= _ && _ <= 49435 || 49437 <= _ && _ <= 49463 || 49465 <= _ && _ <= 49491 || 49493 <= _ && _ <= 49519 || 49521 <= _ && _ <= 49547 || 49549 <= _ && _ <= 49575 || 49577 <= _ && _ <= 49603 || 49605 <= _ && _ <= 49631 || 49633 <= _ && _ <= 49659 || 49661 <= _ && _ <= 49687 || 49689 <= _ && _ <= 49715 || 49717 <= _ && _ <= 49743 || 49745 <= _ && _ <= 49771 || 49773 <= _ && _ <= 49799 || 49801 <= _ && _ <= 49827 || 49829 <= _ && _ <= 49855 || 49857 <= _ && _ <= 49883 || 49885 <= _ && _ <= 49911 || 49913 <= _ && _ <= 49939 || 49941 <= _ && _ <= 49967 || 49969 <= _ && _ <= 49995 || 49997 <= _ && _ <= 50023 || 50025 <= _ && _ <= 50051 || 50053 <= _ && _ <= 50079 || 50081 <= _ && _ <= 50107 || 50109 <= _ && _ <= 50135 || 50137 <= _ && _ <= 50163 || 50165 <= _ && _ <= 50191 || 50193 <= _ && _ <= 50219 || 50221 <= _ && _ <= 50247 || 50249 <= _ && _ <= 50275 || 50277 <= _ && _ <= 50303 || 50305 <= _ && _ <= 50331 || 50333 <= _ && _ <= 50359 || 50361 <= _ && _ <= 50387 || 50389 <= _ && _ <= 50415 || 50417 <= _ && _ <= 50443 || 50445 <= _ && _ <= 50471 || 50473 <= _ && _ <= 50499 || 50501 <= _ && _ <= 50527 || 50529 <= _ && _ <= 50555 || 50557 <= _ && _ <= 50583 || 50585 <= _ && _ <= 50611 || 50613 <= _ && _ <= 50639 || 50641 <= _ && _ <= 50667 || 50669 <= _ && _ <= 50695 || 50697 <= _ && _ <= 50723 || 50725 <= _ && _ <= 50751 || 50753 <= _ && _ <= 50779 || 50781 <= _ && _ <= 50807 || 50809 <= _ && _ <= 50835 || 50837 <= _ && _ <= 50863 || 50865 <= _ && _ <= 50891 || 50893 <= _ && _ <= 50919 || 50921 <= _ && _ <= 50947 || 50949 <= _ && _ <= 50975 || 50977 <= _ && _ <= 51003 || 51005 <= _ && _ <= 51031 || 51033 <= _ && _ <= 51059 || 51061 <= _ && _ <= 51087 || 51089 <= _ && _ <= 51115 || 51117 <= _ && _ <= 51143 || 51145 <= _ && _ <= 51171 || 51173 <= _ && _ <= 51199 || 51201 <= _ && _ <= 51227 || 51229 <= _ && _ <= 51255 || 51257 <= _ && _ <= 51283 || 51285 <= _ && _ <= 51311 || 51313 <= _ && _ <= 51339 || 51341 <= _ && _ <= 51367 || 51369 <= _ && _ <= 51395 || 51397 <= _ && _ <= 51423 || 51425 <= _ && _ <= 51451 || 51453 <= _ && _ <= 51479 || 51481 <= _ && _ <= 51507 || 51509 <= _ && _ <= 51535 || 51537 <= _ && _ <= 51563 || 51565 <= _ && _ <= 51591 || 51593 <= _ && _ <= 51619 || 51621 <= _ && _ <= 51647 || 51649 <= _ && _ <= 51675 || 51677 <= _ && _ <= 51703 || 51705 <= _ && _ <= 51731 || 51733 <= _ && _ <= 51759 || 51761 <= _ && _ <= 51787 || 51789 <= _ && _ <= 51815 || 51817 <= _ && _ <= 51843 || 51845 <= _ && _ <= 51871 || 51873 <= _ && _ <= 51899 || 51901 <= _ && _ <= 51927 || 51929 <= _ && _ <= 51955 || 51957 <= _ && _ <= 51983 || 51985 <= _ && _ <= 52011 || 52013 <= _ && _ <= 52039 || 52041 <= _ && _ <= 52067 || 52069 <= _ && _ <= 52095 || 52097 <= _ && _ <= 52123 || 52125 <= _ && _ <= 52151 || 52153 <= _ && _ <= 52179 || 52181 <= _ && _ <= 52207 || 52209 <= _ && _ <= 52235 || 52237 <= _ && _ <= 52263 || 52265 <= _ && _ <= 52291 || 52293 <= _ && _ <= 52319 || 52321 <= _ && _ <= 52347 || 52349 <= _ && _ <= 52375 || 52377 <= _ && _ <= 52403 || 52405 <= _ && _ <= 52431 || 52433 <= _ && _ <= 52459 || 52461 <= _ && _ <= 52487 || 52489 <= _ && _ <= 52515 || 52517 <= _ && _ <= 52543 || 52545 <= _ && _ <= 52571 || 52573 <= _ && _ <= 52599 || 52601 <= _ && _ <= 52627 || 52629 <= _ && _ <= 52655 || 52657 <= _ && _ <= 52683 || 52685 <= _ && _ <= 52711 || 52713 <= _ && _ <= 52739 || 52741 <= _ && _ <= 52767 || 52769 <= _ && _ <= 52795 || 52797 <= _ && _ <= 52823 || 52825 <= _ && _ <= 52851 || 52853 <= _ && _ <= 52879 || 52881 <= _ && _ <= 52907 || 52909 <= _ && _ <= 52935 || 52937 <= _ && _ <= 52963 || 52965 <= _ && _ <= 52991 || 52993 <= _ && _ <= 53019 || 53021 <= _ && _ <= 53047 || 53049 <= _ && _ <= 53075 || 53077 <= _ && _ <= 53103 || 53105 <= _ && _ <= 53131 || 53133 <= _ && _ <= 53159 || 53161 <= _ && _ <= 53187 || 53189 <= _ && _ <= 53215 || 53217 <= _ && _ <= 53243 || 53245 <= _ && _ <= 53271 || 53273 <= _ && _ <= 53299 || 53301 <= _ && _ <= 53327 || 53329 <= _ && _ <= 53355 || 53357 <= _ && _ <= 53383 || 53385 <= _ && _ <= 53411 || 53413 <= _ && _ <= 53439 || 53441 <= _ && _ <= 53467 || 53469 <= _ && _ <= 53495 || 53497 <= _ && _ <= 53523 || 53525 <= _ && _ <= 53551 || 53553 <= _ && _ <= 53579 || 53581 <= _ && _ <= 53607 || 53609 <= _ && _ <= 53635 || 53637 <= _ && _ <= 53663 || 53665 <= _ && _ <= 53691 || 53693 <= _ && _ <= 53719 || 53721 <= _ && _ <= 53747 || 53749 <= _ && _ <= 53775 || 53777 <= _ && _ <= 53803 || 53805 <= _ && _ <= 53831 || 53833 <= _ && _ <= 53859 || 53861 <= _ && _ <= 53887 || 53889 <= _ && _ <= 53915 || 53917 <= _ && _ <= 53943 || 53945 <= _ && _ <= 53971 || 53973 <= _ && _ <= 53999 || 54001 <= _ && _ <= 54027 || 54029 <= _ && _ <= 54055 || 54057 <= _ && _ <= 54083 || 54085 <= _ && _ <= 54111 || 54113 <= _ && _ <= 54139 || 54141 <= _ && _ <= 54167 || 54169 <= _ && _ <= 54195 || 54197 <= _ && _ <= 54223 || 54225 <= _ && _ <= 54251 || 54253 <= _ && _ <= 54279 || 54281 <= _ && _ <= 54307 || 54309 <= _ && _ <= 54335 || 54337 <= _ && _ <= 54363 || 54365 <= _ && _ <= 54391 || 54393 <= _ && _ <= 54419 || 54421 <= _ && _ <= 54447 || 54449 <= _ && _ <= 54475 || 54477 <= _ && _ <= 54503 || 54505 <= _ && _ <= 54531 || 54533 <= _ && _ <= 54559 || 54561 <= _ && _ <= 54587 || 54589 <= _ && _ <= 54615 || 54617 <= _ && _ <= 54643 || 54645 <= _ && _ <= 54671 || 54673 <= _ && _ <= 54699 || 54701 <= _ && _ <= 54727 || 54729 <= _ && _ <= 54755 || 54757 <= _ && _ <= 54783 || 54785 <= _ && _ <= 54811 || 54813 <= _ && _ <= 54839 || 54841 <= _ && _ <= 54867 || 54869 <= _ && _ <= 54895 || 54897 <= _ && _ <= 54923 || 54925 <= _ && _ <= 54951 || 54953 <= _ && _ <= 54979 || 54981 <= _ && _ <= 55007 || 55009 <= _ && _ <= 55035 || 55037 <= _ && _ <= 55063 || 55065 <= _ && _ <= 55091 || 55093 <= _ && _ <= 55119 || 55121 <= _ && _ <= 55147 || 55149 <= _ && _ <= 55175 || 55177 <= _ && _ <= 55203 ? f : _ == 9757 || _ == 9977 || 9994 <= _ && _ <= 9997 || _ == 127877 || 127938 <= _ && _ <= 127940 || _ == 127943 || 127946 <= _ && _ <= 127948 || 128066 <= _ && _ <= 128067 || 128070 <= _ && _ <= 128080 || _ == 128110 || 128112 <= _ && _ <= 128120 || _ == 128124 || 128129 <= _ && _ <= 128131 || 128133 <= _ && _ <= 128135 || _ == 128170 || 128372 <= _ && _ <= 128373 || _ == 128378 || _ == 128400 || 128405 <= _ && _ <= 128406 || 128581 <= _ && _ <= 128583 || 128587 <= _ && _ <= 128591 || _ == 128675 || 128692 <= _ && _ <= 128694 || _ == 128704 || _ == 128716 || 129304 <= _ && _ <= 129308 || 129310 <= _ && _ <= 129311 || _ == 129318 || 129328 <= _ && _ <= 129337 || 129341 <= _ && _ <= 129342 || 129489 <= _ && _ <= 129501 ? g : 127995 <= _ && _ <= 127999 ? m : _ == 8205 ? A : _ == 9792 || _ == 9794 || 9877 <= _ && _ <= 9878 || _ == 9992 || _ == 10084 || _ == 127752 || _ == 127806 || _ == 127859 || _ == 127891 || _ == 127908 || _ == 127912 || _ == 127979 || _ == 127981 || _ == 128139 || 128187 <= _ && _ <= 128188 || _ == 128295 || _ == 128300 || _ == 128488 || _ == 128640 || _ == 128658 ? C : 128102 <= _ && _ <= 128105 ? x : d } return this } typeof IL < "u" && IL.exports && (IL.exports = Rke) }); var Qne = Wa((lhn, C5) => { "use strict"; C5.exports = $L; C5.exports.default = $L; function $L(e, t, n) { n = n || 2; var i = t && t.length, o = i ? t[0] * n : e.length, r = Kne(e, 0, o, n, !0), s = []; if (!r || r.next === r.prev) return s; var a, c, u, f, d, p, g; if (i && (r = fze(e, t, r, n)), e.length > 80 * n) { a = u = e[0], c = f = e[1]; for (var m = n; m < o; m += n)d = e[m], p = e[m + 1], d < a && (a = d), p < c && (c = p), d > u && (u = d), p > f && (f = p); g = Math.max(u - a, f - c), g = g !== 0 ? 32767 / g : 0 } return cw(r, s, n, a, c, g, 0), s } function Kne(e, t, n, i, o) { var r, s; if (o === A5(e, t, n, i) > 0) for (r = t; r < n; r += i)s = Xne(r, e[r], e[r + 1], s); else for (r = n - i; r >= t; r -= i)s = Xne(r, e[r], e[r + 1], s); return s && eF(s, s.next) && (uw(s), s = s.next), s } function oy(e, t) { if (!e) return e; t || (t = e); var n = e, i; do if (i = !1, !n.steiner && (eF(n, n.next) || gr(n.prev, n, n.next) === 0)) { if (uw(n), n = t = n.prev, n === n.next) break; i = !0 } else n = n.next; while (i || n !== t); return t } function cw(e, t, n, i, o, r, s) { if (!!e) { !s && r && _ze(e, i, o, r); for (var a = e, c, u; e.prev !== e.next;) { if (c = e.prev, u = e.next, r ? cze(e, i, o, r) : aze(e)) { t.push(c.i / n | 0), t.push(e.i / n | 0), t.push(u.i / n | 0), uw(e), e = u.next, a = u.next; continue } if (e = u, e === a) { s ? s === 1 ? (e = lze(oy(e), t, n), cw(e, t, n, i, o, r, 2)) : s === 2 && uze(e, t, n, i, o, r) : cw(oy(e), t, n, i, o, r, 1); break } } } } function aze(e) { var t = e.prev, n = e, i = e.next; if (gr(t, n, i) >= 0) return !1; for (var o = t.x, r = n.x, s = i.x, a = t.y, c = n.y, u = i.y, f = o < r ? o < s ? o : s : r < s ? r : s, d = a < c ? a < u ? a : u : c < u ? c : u, p = o > r ? o > s ? o : s : r > s ? r : s, g = a > c ? a > u ? a : u : c > u ? c : u, m = i.next; m !== t;) { if (m.x >= f && m.x <= p && m.y >= d && m.y <= g && Dx(o, a, r, c, s, u, m.x, m.y) && gr(m.prev, m, m.next) >= 0) return !1; m = m.next } return !0 } function cze(e, t, n, i) { var o = e.prev, r = e, s = e.next; if (gr(o, r, s) >= 0) return !1; for (var a = o.x, c = r.x, u = s.x, f = o.y, d = r.y, p = s.y, g = a < c ? a < u ? a : u : c < u ? c : u, m = f < d ? f < p ? f : p : d < p ? d : p, A = a > c ? a > u ? a : u : c > u ? c : u, C = f > d ? f > p ? f : p : d > p ? d : p, x = g5(g, m, t, n, i), T = g5(A, C, t, n, i), b = e.prevZ, S = e.nextZ; b && b.z >= x && S && S.z <= T;) { if (b.x >= g && b.x <= A && b.y >= m && b.y <= C && b !== o && b !== s && Dx(a, f, c, d, u, p, b.x, b.y) && gr(b.prev, b, b.next) >= 0 || (b = b.prevZ, S.x >= g && S.x <= A && S.y >= m && S.y <= C && S !== o && S !== s && Dx(a, f, c, d, u, p, S.x, S.y) && gr(S.prev, S, S.next) >= 0)) return !1; S = S.nextZ } for (; b && b.z >= x;) { if (b.x >= g && b.x <= A && b.y >= m && b.y <= C && b !== o && b !== s && Dx(a, f, c, d, u, p, b.x, b.y) && gr(b.prev, b, b.next) >= 0) return !1; b = b.prevZ } for (; S && S.z <= T;) { if (S.x >= g && S.x <= A && S.y >= m && S.y <= C && S !== o && S !== s && Dx(a, f, c, d, u, p, S.x, S.y) && gr(S.prev, S, S.next) >= 0) return !1; S = S.nextZ } return !0 } function lze(e, t, n) { var i = e; do { var o = i.prev, r = i.next.next; !eF(o, r) && Jne(o, i, i.next, r) && lw(o, r) && lw(r, o) && (t.push(o.i / n | 0), t.push(i.i / n | 0), t.push(r.i / n | 0), uw(i), uw(i.next), i = e = r), i = i.next } while (i !== e); return oy(i) } function uze(e, t, n, i, o, r) { var s = e; do { for (var a = s.next.next; a !== s.prev;) { if (s.i !== a.i && Aze(s, a)) { var c = Zne(s, a); s = oy(s, s.next), c = oy(c, c.next), cw(s, t, n, i, o, r, 0), cw(c, t, n, i, o, r, 0); return } a = a.next } s = s.next } while (s !== e) } function fze(e, t, n, i) { var o = [], r, s, a, c, u; for (r = 0, s = t.length; r < s; r++)a = t[r] * i, c = r < s - 1 ? t[r + 1] * i : e.length, u = Kne(e, a, c, i, !1), u === u.next && (u.steiner = !0), o.push(yze(u)); for (o.sort(dze), r = 0; r < o.length; r++)n = hze(o[r], n); return n } function dze(e, t) { return e.x - t.x } function hze(e, t) { var n = mze(e, t); if (!n) return t; var i = Zne(n, e); return oy(i, i.next), oy(n, n.next) } function mze(e, t) { var n = t, i = e.x, o = e.y, r = -1 / 0, s; do { if (o <= n.y && o >= n.next.y && n.next.y !== n.y) { var a = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (a <= i && a > r && (r = a, s = n.x < n.next.x ? n : n.next, a === i)) return s } n = n.next } while (n !== t); if (!s) return null; var c = s, u = s.x, f = s.y, d = 1 / 0, p; n = s; do i >= n.x && n.x >= u && i !== n.x && Dx(o < f ? i : r, o, u, f, o < f ? r : i, o, n.x, n.y) && (p = Math.abs(o - n.y) / (i - n.x), lw(n, e) && (p < d || p === d && (n.x > s.x || n.x === s.x && pze(s, n))) && (s = n, d = p)), n = n.next; while (n !== c); return s } function pze(e, t) { return gr(e.prev, e, t.prev) < 0 && gr(t.next, e, e.next) < 0 } function _ze(e, t, n, i) { var o = e; do o.z === 0 && (o.z = g5(o.x, o.y, t, n, i)), o.prevZ = o.prev, o.nextZ = o.next, o = o.next; while (o !== e); o.prevZ.nextZ = null, o.prevZ = null, gze(o) } function gze(e) { var t, n, i, o, r, s, a, c, u = 1; do { for (n = e, e = null, r = null, s = 0; n;) { for (s++, i = n, a = 0, t = 0; t < u && (a++, i = i.nextZ, !!i); t++); for (c = u; a > 0 || c > 0 && i;)a !== 0 && (c === 0 || !i || n.z <= i.z) ? (o = n, n = n.nextZ, a--) : (o = i, i = i.nextZ, c--), r ? r.nextZ = o : e = o, o.prevZ = r, r = o; n = i } r.nextZ = null, u *= 2 } while (s > 1); return e } function g5(e, t, n, i, o) { return e = (e - n) * o | 0, t = (t - i) * o | 0, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e | t << 1 } function yze(e) { var t = e, n = e; do (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next; while (t !== e); return n } function Dx(e, t, n, i, o, r, s, a) { return (o - s) * (t - a) >= (e - s) * (r - a) && (e - s) * (i - a) >= (n - s) * (t - a) && (n - s) * (r - a) >= (o - s) * (i - a) } function Aze(e, t) { return e.next.i !== t.i && e.prev.i !== t.i && !Cze(e, t) && (lw(e, t) && lw(t, e) && xze(e, t) && (gr(e.prev, e, t.prev) || gr(e, t.prev, t)) || eF(e, t) && gr(e.prev, e, e.next) > 0 && gr(t.prev, t, t.next) > 0) } function gr(e, t, n) { return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y) } function eF(e, t) { return e.x === t.x && e.y === t.y } function Jne(e, t, n, i) { var o = QL(gr(e, t, n)), r = QL(gr(e, t, i)), s = QL(gr(n, i, e)), a = QL(gr(n, i, t)); return !!(o !== r && s !== a || o === 0 && ZL(e, n, t) || r === 0 && ZL(e, i, t) || s === 0 && ZL(n, e, i) || a === 0 && ZL(n, t, i)) } function ZL(e, t, n) { return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y) } function QL(e) { return e > 0 ? 1 : e < 0 ? -1 : 0 } function Cze(e, t) { var n = e; do { if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Jne(n, n.next, e, t)) return !0; n = n.next } while (n !== e); return !1 } function lw(e, t) { return gr(e.prev, e, e.next) < 0 ? gr(e, t, e.next) >= 0 && gr(e, e.prev, t) >= 0 : gr(e, t, e.prev) < 0 || gr(e, e.next, t) < 0 } function xze(e, t) { var n = e, i = !1, o = (e.x + t.x) / 2, r = (e.y + t.y) / 2; do n.y > r != n.next.y > r && n.next.y !== n.y && o < (n.next.x - n.x) * (r - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next; while (n !== e); return i } function Zne(e, t) { var n = new y5(e.i, e.x, e.y), i = new y5(t.i, t.x, t.y), o = e.next, r = t.prev; return e.next = t, t.prev = e, n.next = o, o.prev = n, i.next = n, n.prev = i, r.next = i, i.prev = r, i } function Xne(e, t, n, i) { var o = new y5(e, t, n); return i ? (o.next = i.next, o.prev = i, i.next.prev = o, i.next = o) : (o.prev = o, o.next = o), o } function uw(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) } function y5(e, t, n) { this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } $L.deviation = function (e, t, n, i) { var o = t && t.length, r = o ? t[0] * n : e.length, s = Math.abs(A5(e, 0, r, n)); if (o) for (var a = 0, c = t.length; a < c; a++) { var u = t[a] * n, f = a < c - 1 ? t[a + 1] * n : e.length; s -= Math.abs(A5(e, u, f, n)) } var d = 0; for (a = 0; a < i.length; a += 3) { var p = i[a] * n, g = i[a + 1] * n, m = i[a + 2] * n; d += Math.abs((e[p] - e[m]) * (e[g + 1] - e[p + 1]) - (e[p] - e[g]) * (e[m + 1] - e[p + 1])) } return s === 0 && d === 0 ? 0 : Math.abs((d - s) / s) }; function A5(e, t, n, i) { for (var o = 0, r = t, s = n - i; r < n; r += i)o += (e[s] - e[r]) * (e[r + 1] + e[s + 1]), s = r; return o } $L.flatten = function (e) { for (var t = e[0][0].length, n = { vertices: [], holes: [], dimensions: t }, i = 0, o = 0; o < e.length; o++) { for (var r = 0; r < e[o].length; r++)for (var s = 0; s < t; s++)n.vertices.push(e[o][r][s]); o > 0 && (i += e[o - 1].length, n.holes.push(i)) } return n } }); var fae = Wa((J6, Z6) => { (function (e, t) { typeof J6 == "object" && typeof Z6 < "u" ? Z6.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = e || self).RBush = t() })(J6, function () { "use strict"; function e(C, x, T, b, S) { (function D(P, B, R, M, L) { for (; M > R;) { if (M - R > 600) { var _ = M - R + 1, E = B - R + 1, w = Math.log(_), v = .5 * Math.exp(2 * w / 3), O = .5 * Math.sqrt(w * v * (_ - v) / _) * (E - _ / 2 < 0 ? -1 : 1), V = Math.max(R, Math.floor(B - E * v / _ + O)), z = Math.min(M, Math.floor(B + (_ - E) * v / _ + O)); D(P, B, V, z, L) } var k = P[B], G = R, N = M; for (t(P, R, B), L(P[M], k) > 0 && t(P, R, M); G < N;) { for (t(P, G, N), G++, N--; L(P[G], k) < 0;)G++; for (; L(P[N], k) > 0;)N-- } L(P[R], k) === 0 ? t(P, R, N) : t(P, ++N, M), N <= B && (R = N + 1), B <= N && (M = N - 1) } })(C, x, T || 0, b || C.length - 1, S || n) } function t(C, x, T) { var b = C[x]; C[x] = C[T], C[T] = b } function n(C, x) { return C < x ? -1 : C > x ? 1 : 0 } var i = function (C) { C === void 0 && (C = 9), this._maxEntries = Math.max(4, C), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear() }; function o(C, x, T) { if (!T) return x.indexOf(C); for (var b = 0; b < x.length; b++)if (T(C, x[b])) return b; return -1 } function r(C, x) { s(C, 0, C.children.length, x, C) } function s(C, x, T, b, S) { S || (S = m(null)), S.minX = 1 / 0, S.minY = 1 / 0, S.maxX = -1 / 0, S.maxY = -1 / 0; for (var D = x; D < T; D++) { var P = C.children[D]; a(S, C.leaf ? b(P) : P) } return S } function a(C, x) { return C.minX = Math.min(C.minX, x.minX), C.minY = Math.min(C.minY, x.minY), C.maxX = Math.max(C.maxX, x.maxX), C.maxY = Math.max(C.maxY, x.maxY), C } function c(C, x) { return C.minX - x.minX } function u(C, x) { return C.minY - x.minY } function f(C) { return (C.maxX - C.minX) * (C.maxY - C.minY) } function d(C) { return C.maxX - C.minX + (C.maxY - C.minY) } function p(C, x) { return C.minX <= x.minX && C.minY <= x.minY && x.maxX <= C.maxX && x.maxY <= C.maxY } function g(C, x) { return x.minX <= C.maxX && x.minY <= C.maxY && x.maxX >= C.minX && x.maxY >= C.minY } function m(C) { return { children: C, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } } function A(C, x, T, b, S) { for (var D = [x, T]; D.length;)if (!((T = D.pop()) - (x = D.pop()) <= b)) { var P = x + Math.ceil((T - x) / b / 2) * b; e(C, P, x, T, S), D.push(x, P, P, T) } } return i.prototype.all = function () { return this._all(this.data, []) }, i.prototype.search = function (C) { var x = this.data, T = []; if (!g(C, x)) return T; for (var b = this.toBBox, S = []; x;) { for (var D = 0; D < x.children.length; D++) { var P = x.children[D], B = x.leaf ? b(P) : P; g(C, B) && (x.leaf ? T.push(P) : p(C, B) ? this._all(P, T) : S.push(P)) } x = S.pop() } return T }, i.prototype.collides = function (C) { var x = this.data; if (!g(C, x)) return !1; for (var T = []; x;) { for (var b = 0; b < x.children.length; b++) { var S = x.children[b], D = x.leaf ? this.toBBox(S) : S; if (g(C, D)) { if (x.leaf || p(C, D)) return !0; T.push(S) } } x = T.pop() } return !1 }, i.prototype.load = function (C) { if (!C || !C.length) return this; if (C.length < this._minEntries) { for (var x = 0; x < C.length; x++)this.insert(C[x]); return this } var T = this._build(C.slice(), 0, C.length - 1, 0); if (this.data.children.length) if (this.data.height === T.height) this._splitRoot(this.data, T); else { if (this.data.height < T.height) { var b = this.data; this.data = T, T = b } this._insert(T, this.data.height - T.height - 1, !0) } else this.data = T; return this }, i.prototype.insert = function (C) { return C && this._insert(C, this.data.height - 1), this }, i.prototype.clear = function () { return this.data = m([]), this }, i.prototype.remove = function (C, x) { if (!C) return this; for (var T, b, S, D = this.data, P = this.toBBox(C), B = [], R = []; D || B.length;) { if (D || (D = B.pop(), b = B[B.length - 1], T = R.pop(), S = !0), D.leaf) { var M = o(C, D.children, x); if (M !== -1) return D.children.splice(M, 1), B.push(D), this._condense(B), this } S || D.leaf || !p(D, P) ? b ? (T++, D = b.children[T], S = !1) : D = null : (B.push(D), R.push(T), T = 0, b = D, D = D.children[0]) } return this }, i.prototype.toBBox = function (C) { return C }, i.prototype.compareMinX = function (C, x) { return C.minX - x.minX }, i.prototype.compareMinY = function (C, x) { return C.minY - x.minY }, i.prototype.toJSON = function () { return this.data }, i.prototype.fromJSON = function (C) { return this.data = C, this }, i.prototype._all = function (C, x) { for (var T = []; C;)C.leaf ? x.push.apply(x, C.children) : T.push.apply(T, C.children), C = T.pop(); return x }, i.prototype._build = function (C, x, T, b) { var S, D = T - x + 1, P = this._maxEntries; if (D <= P) return r(S = m(C.slice(x, T + 1)), this.toBBox), S; b || (b = Math.ceil(Math.log(D) / Math.log(P)), P = Math.ceil(D / Math.pow(P, b - 1))), (S = m([])).leaf = !1, S.height = b; var B = Math.ceil(D / P), R = B * Math.ceil(Math.sqrt(P)); A(C, x, T, R, this.compareMinX); for (var M = x; M <= T; M += R) { var L = Math.min(M + R - 1, T); A(C, M, L, B, this.compareMinY); for (var _ = M; _ <= L; _ += B) { var E = Math.min(_ + B - 1, L); S.children.push(this._build(C, _, E, b - 1)) } } return r(S, this.toBBox), S }, i.prototype._chooseSubtree = function (C, x, T, b) { for (; b.push(x), !x.leaf && b.length - 1 !== T;) { for (var S = 1 / 0, D = 1 / 0, P = void 0, B = 0; B < x.children.length; B++) { var R = x.children[B], M = f(R), L = (_ = C, E = R, (Math.max(E.maxX, _.maxX) - Math.min(E.minX, _.minX)) * (Math.max(E.maxY, _.maxY) - Math.min(E.minY, _.minY)) - M); L < D ? (D = L, S = M < S ? M : S, P = R) : L === D && M < S && (S = M, P = R) } x = P || x.children[0] } var _, E; return x }, i.prototype._insert = function (C, x, T) { var b = T ? C : this.toBBox(C), S = [], D = this._chooseSubtree(b, this.data, x, S); for (D.children.push(C), a(D, b); x >= 0 && S[x].children.length > this._maxEntries;)this._split(S, x), x--; this._adjustParentBBoxes(b, S, x) }, i.prototype._split = function (C, x) { var T = C[x], b = T.children.length, S = this._minEntries; this._chooseSplitAxis(T, S, b); var D = this._chooseSplitIndex(T, S, b), P = m(T.children.splice(D, T.children.length - D)); P.height = T.height, P.leaf = T.leaf, r(T, this.toBBox), r(P, this.toBBox), x ? C[x - 1].children.push(P) : this._splitRoot(T, P) }, i.prototype._splitRoot = function (C, x) { this.data = m([C, x]), this.data.height = C.height + 1, this.data.leaf = !1, r(this.data, this.toBBox) }, i.prototype._chooseSplitIndex = function (C, x, T) { for (var b, S, D, P, B, R, M, L = 1 / 0, _ = 1 / 0, E = x; E <= T - x; E++) { var w = s(C, 0, E, this.toBBox), v = s(C, E, T, this.toBBox), O = (S = w, D = v, P = void 0, B = void 0, R = void 0, M = void 0, P = Math.max(S.minX, D.minX), B = Math.max(S.minY, D.minY), R = Math.min(S.maxX, D.maxX), M = Math.min(S.maxY, D.maxY), Math.max(0, R - P) * Math.max(0, M - B)), V = f(w) + f(v); O < L ? (L = O, b = E, _ = V < _ ? V : _) : O === L && V < _ && (_ = V, b = E) } return b || T - x }, i.prototype._chooseSplitAxis = function (C, x, T) { var b = C.leaf ? this.compareMinX : c, S = C.leaf ? this.compareMinY : u; this._allDistMargin(C, x, T, b) < this._allDistMargin(C, x, T, S) && C.children.sort(b) }, i.prototype._allDistMargin = function (C, x, T, b) { C.children.sort(b); for (var S = this.toBBox, D = s(C, 0, x, S), P = s(C, T - x, T, S), B = d(D) + d(P), R = x; R < T - x; R++) { var M = C.children[R]; a(D, C.leaf ? S(M) : M), B += d(D) } for (var L = T - x - 1; L >= x; L--) { var _ = C.children[L]; a(P, C.leaf ? S(_) : _), B += d(P) } return B }, i.prototype._adjustParentBBoxes = function (C, x, T) { for (var b = T; b >= 0; b--)a(x[b], C) }, i.prototype._condense = function (C) { for (var x = C.length - 1, T = void 0; x >= 0; x--)C[x].children.length === 0 ? x > 0 ? (T = C[x - 1].children).splice(T.indexOf(C[x]), 1) : this.clear() : r(C[x], this.toBBox) }, i }) }); var Sue = Wa((d4n, H2) => { var oue, rue, sue, aue, cue, lue, uue, fue, due, U2, uW, hue, mue, pue, YT, _ue, gue, yue, Aue, Cue, xue, Tue, Eue, bue, z2; (function (e) { var t = typeof global == "object" ? global : typeof self == "object" ? self : typeof this == "object" ? this : {}; typeof define == "function" && define.amd ? define("tslib", ["exports"], function (i) { e(n(t, n(i))) }) : typeof H2 == "object" && typeof H2.exports == "object" ? e(n(t, n(H2.exports))) : e(n(t)); function n(i, o) { return i !== t && (typeof Object.create == "function" ? Object.defineProperty(i, "__esModule", { value: !0 }) : i.__esModule = !0), function (r, s) { return i[r] = o ? o(r, s) : s } } })(function (e) { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (i, o) { i.__proto__ = o } || function (i, o) { for (var r in o) Object.prototype.hasOwnProperty.call(o, r) && (i[r] = o[r]) }; oue = function (i, o) { if (typeof o != "function" && o !== null) throw new TypeError("Class extends value " + String(o) + " is not a constructor or null"); t(i, o); function r() { this.constructor = i } i.prototype = o === null ? Object.create(o) : (r.prototype = o.prototype, new r) }, rue = Object.assign || function (i) { for (var o, r = 1, s = arguments.length; r < s; r++) { o = arguments[r]; for (var a in o) Object.prototype.hasOwnProperty.call(o, a) && (i[a] = o[a]) } return i }, sue = function (i, o) { var r = {}; for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && o.indexOf(s) < 0 && (r[s] = i[s]); if (i != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, s = Object.getOwnPropertySymbols(i); a < s.length; a++)o.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(i, s[a]) && (r[s[a]] = i[s[a]]); return r }, aue = function (i, o, r, s) { var a = arguments.length, c = a < 3 ? o : s === null ? s = Object.getOwnPropertyDescriptor(o, r) : s, u; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") c = Reflect.decorate(i, o, r, s); else for (var f = i.length - 1; f >= 0; f--)(u = i[f]) && (c = (a < 3 ? u(c) : a > 3 ? u(o, r, c) : u(o, r)) || c); return a > 3 && c && Object.defineProperty(o, r, c), c }, cue = function (i, o) { return function (r, s) { o(r, s, i) } }, lue = function (i, o) { if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(i, o) }, uue = function (i, o, r, s) { function a(c) { return c instanceof r ? c : new r(function (u) { u(c) }) } return new (r || (r = Promise))(function (c, u) { function f(g) { try { p(s.next(g)) } catch (m) { u(m) } } function d(g) { try { p(s.throw(g)) } catch (m) { u(m) } } function p(g) { g.done ? c(g.value) : a(g.value).then(f, d) } p((s = s.apply(i, o || [])).next()) }) }, fue = function (i, o) { var r = { label: 0, sent: function () { if (c[0] & 1) throw c[1]; return c[1] }, trys: [], ops: [] }, s, a, c, u; return u = { next: f(0), throw: f(1), return: f(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function () { return this }), u; function f(p) { return function (g) { return d([p, g]) } } function d(p) { if (s) throw new TypeError("Generator is already executing."); for (; r;)try { if (s = 1, a && (c = p[0] & 2 ? a.return : p[0] ? a.throw || ((c = a.return) && c.call(a), 0) : a.next) && !(c = c.call(a, p[1])).done) return c; switch (a = 0, c && (p = [p[0] & 2, c.value]), p[0]) { case 0: case 1: c = p; break; case 4: return r.label++, { value: p[1], done: !1 }; case 5: r.label++, a = p[1], p = [0]; continue; case 7: p = r.ops.pop(), r.trys.pop(); continue; default: if (c = r.trys, !(c = c.length > 0 && c[c.length - 1]) && (p[0] === 6 || p[0] === 2)) { r = 0; continue } if (p[0] === 3 && (!c || p[1] > c[0] && p[1] < c[3])) { r.label = p[1]; break } if (p[0] === 6 && r.label < c[1]) { r.label = c[1], c = p; break } if (c && r.label < c[2]) { r.label = c[2], r.ops.push(p); break } c[2] && r.ops.pop(), r.trys.pop(); continue }p = o.call(i, r) } catch (g) { p = [6, g], a = 0 } finally { s = c = 0 } if (p[0] & 5) throw p[1]; return { value: p[0] ? p[1] : void 0, done: !0 } } }, due = function (i, o) { for (var r in i) r !== "default" && !Object.prototype.hasOwnProperty.call(o, r) && z2(o, i, r) }, z2 = Object.create ? function (i, o, r, s) { s === void 0 && (s = r); var a = Object.getOwnPropertyDescriptor(o, r); (!a || ("get" in a ? !o.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function () { return o[r] } }), Object.defineProperty(i, s, a) } : function (i, o, r, s) { s === void 0 && (s = r), i[s] = o[r] }, U2 = function (i) { var o = typeof Symbol == "function" && Symbol.iterator, r = o && i[o], s = 0; if (r) return r.call(i); if (i && typeof i.length == "number") return { next: function () { return i && s >= i.length && (i = void 0), { value: i && i[s++], done: !i } } }; throw new TypeError(o ? "Object is not iterable." : "Symbol.iterator is not defined.") }, uW = function (i, o) { var r = typeof Symbol == "function" && i[Symbol.iterator]; if (!r) return i; var s = r.call(i), a, c = [], u; try { for (; (o === void 0 || o-- > 0) && !(a = s.next()).done;)c.push(a.value) } catch (f) { u = { error: f } } finally { try { a && !a.done && (r = s.return) && r.call(s) } finally { if (u) throw u.error } } return c }, hue = function () { for (var i = [], o = 0; o < arguments.length; o++)i = i.concat(uW(arguments[o])); return i }, mue = function () { for (var i = 0, o = 0, r = arguments.length; o < r; o++)i += arguments[o].length; for (var s = Array(i), a = 0, o = 0; o < r; o++)for (var c = arguments[o], u = 0, f = c.length; u < f; u++, a++)s[a] = c[u]; return s }, pue = function (i, o, r) { if (r || arguments.length === 2) for (var s = 0, a = o.length, c; s < a; s++)(c || !(s in o)) && (c || (c = Array.prototype.slice.call(o, 0, s)), c[s] = o[s]); return i.concat(c || Array.prototype.slice.call(o)) }, YT = function (i) { return this instanceof YT ? (this.v = i, this) : new YT(i) }, _ue = function (i, o, r) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var s = r.apply(i, o || []), a, c = []; return a = {}, u("next"), u("throw"), u("return"), a[Symbol.asyncIterator] = function () { return this }, a; function u(A) { s[A] && (a[A] = function (C) { return new Promise(function (x, T) { c.push([A, C, x, T]) > 1 || f(A, C) }) }) } function f(A, C) { try { d(s[A](C)) } catch (x) { m(c[0][3], x) } } function d(A) { A.value instanceof YT ? Promise.resolve(A.value.v).then(p, g) : m(c[0][2], A) } function p(A) { f("next", A) } function g(A) { f("throw", A) } function m(A, C) { A(C), c.shift(), c.length && f(c[0][0], c[0][1]) } }, gue = function (i) { var o, r; return o = {}, s("next"), s("throw", function (a) { throw a }), s("return"), o[Symbol.iterator] = function () { return this }, o; function s(a, c) { o[a] = i[a] ? function (u) { return (r = !r) ? { value: YT(i[a](u)), done: a === "return" } : c ? c(u) : u } : c } }, yue = function (i) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var o = i[Symbol.asyncIterator], r; return o ? o.call(i) : (i = typeof U2 == "function" ? U2(i) : i[Symbol.iterator](), r = {}, s("next"), s("throw"), s("return"), r[Symbol.asyncIterator] = function () { return this }, r); function s(c) { r[c] = i[c] && function (u) { return new Promise(function (f, d) { u = i[c](u), a(f, d, u.done, u.value) }) } } function a(c, u, f, d) { Promise.resolve(d).then(function (p) { c({ value: p, done: f }) }, u) } }, Aue = function (i, o) { return Object.defineProperty ? Object.defineProperty(i, "raw", { value: o }) : i.raw = o, i }; var n = Object.create ? function (i, o) { Object.defineProperty(i, "default", { enumerable: !0, value: o }) } : function (i, o) { i.default = o }; Cue = function (i) { if (i && i.__esModule) return i; var o = {}; if (i != null) for (var r in i) r !== "default" && Object.prototype.hasOwnProperty.call(i, r) && z2(o, i, r); return n(o, i), o }, xue = function (i) { return i && i.__esModule ? i : { default: i } }, Tue = function (i, o, r, s) { if (r === "a" && !s) throw new TypeError("Private accessor was defined without a getter"); if (typeof o == "function" ? i !== o || !s : !o.has(i)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return r === "m" ? s : r === "a" ? s.call(i) : s ? s.value : o.get(i) }, Eue = function (i, o, r, s, a) { if (s === "m") throw new TypeError("Private method is not writable"); if (s === "a" && !a) throw new TypeError("Private accessor was defined without a setter"); if (typeof o == "function" ? i !== o || !a : !o.has(i)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return s === "a" ? a.call(i, r) : a ? a.value = r : o.set(i, r), r }, bue = function (i, o) { if (o === null || typeof o != "object" && typeof o != "function") throw new TypeError("Cannot use 'in' operator on non-object"); return typeof i == "function" ? o === i : i.has(o) }, e("__extends", oue), e("__assign", rue), e("__rest", sue), e("__decorate", aue), e("__param", cue), e("__metadata", lue), e("__awaiter", uue), e("__generator", fue), e("__exportStar", due), e("__createBinding", z2), e("__values", U2), e("__read", uW), e("__spread", hue), e("__spreadArrays", mue), e("__spreadArray", pue), e("__await", YT), e("__asyncGenerator", _ue), e("__asyncDelegator", gue), e("__asyncValues", yue), e("__makeTemplateObject", Aue), e("__importStar", Cue), e("__importDefault", xue), e("__classPrivateFieldGet", Tue), e("__classPrivateFieldSet", Eue), e("__classPrivateFieldIn", bue) }) }); var i7 = Wa((exports, module) => {/*!
 * protobuf.js v7.1.0 (c) 2016, daniel wirtz
 * compiled thu, 22 sep 2022 17:16:10 utc
 * licensed under the bsd-3-clause license
 * see: https://github.com/dcodeio/protobuf.js for details
 */(function (undefined) { "use strict"; (function (t, n, i) { function o(s) { var a = n[s]; return a || t[s][0].call(a = n[s] = { exports: {} }, o, a, a.exports), a.exports } var r = o(i[0]); r.util.global.protobuf = r, typeof define == "function" && define.amd && define(["long"], function (s) { return s && s.isLong && (r.util.Long = s, r.configure()), r }), typeof module == "object" && module && module.exports && (module.exports = r) })({ 1: [function (e, t, n) { "use strict"; t.exports = i; function i(o, r) { for (var s = new Array(arguments.length - 1), a = 0, c = 2, u = !0; c < arguments.length;)s[a++] = arguments[c++]; return new Promise(function (d, p) { s[a] = function (m) { if (u) if (u = !1, m) p(m); else { for (var A = new Array(arguments.length - 1), C = 0; C < A.length;)A[C++] = arguments[C]; d.apply(null, A) } }; try { o.apply(r || null, s) } catch (g) { u && (u = !1, p(g)) } }) } }, {}], 2: [function (e, t, n) { "use strict"; var i = n; i.length = function (u) { var f = u.length; if (!f) return 0; for (var d = 0; --f % 4 > 1 && u.charAt(f) === "=";)++d; return Math.ceil(u.length * 3) / 4 - d }; for (var o = new Array(64), r = new Array(123), s = 0; s < 64;)r[o[s] = s < 26 ? s + 65 : s < 52 ? s + 71 : s < 62 ? s - 4 : s - 59 | 43] = s++; i.encode = function (u, f, d) { for (var p = null, g = [], m = 0, A = 0, C; f < d;) { var x = u[f++]; switch (A) { case 0: g[m++] = o[x >> 2], C = (x & 3) << 4, A = 1; break; case 1: g[m++] = o[C | x >> 4], C = (x & 15) << 2, A = 2; break; case 2: g[m++] = o[C | x >> 6], g[m++] = o[x & 63], A = 0; break }m > 8191 && ((p || (p = [])).push(String.fromCharCode.apply(String, g)), m = 0) } return A && (g[m++] = o[C], g[m++] = 61, A === 1 && (g[m++] = 61)), p ? (m && p.push(String.fromCharCode.apply(String, g.slice(0, m))), p.join("")) : String.fromCharCode.apply(String, g.slice(0, m)) }; var a = "invalid encoding"; i.decode = function (u, f, d) { for (var p = d, g = 0, m, A = 0; A < u.length;) { var C = u.charCodeAt(A++); if (C === 61 && g > 1) break; if ((C = r[C]) === undefined) throw Error(a); switch (g) { case 0: m = C, g = 1; break; case 1: f[d++] = m << 2 | (C & 48) >> 4, m = C, g = 2; break; case 2: f[d++] = (m & 15) << 4 | (C & 60) >> 2, m = C, g = 3; break; case 3: f[d++] = (m & 3) << 6 | C, g = 0; break } } if (g === 1) throw Error(a); return d - p }, i.test = function (u) { return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(u) } }, {}], 3: [function (e, t, n) { "use strict"; t.exports = i; function i() { this._listeners = {} } i.prototype.on = function (r, s, a) { return (this._listeners[r] || (this._listeners[r] = [])).push({ fn: s, ctx: a || this }), this }, i.prototype.off = function (r, s) { if (r === undefined) this._listeners = {}; else if (s === undefined) this._listeners[r] = []; else for (var a = this._listeners[r], c = 0; c < a.length;)a[c].fn === s ? a.splice(c, 1) : ++c; return this }, i.prototype.emit = function (r) { var s = this._listeners[r]; if (s) { for (var a = [], c = 1; c < arguments.length;)a.push(arguments[c++]); for (c = 0; c < s.length;)s[c].fn.apply(s[c++].ctx, a) } return this } }, {}], 4: [function (e, t, n) { "use strict"; t.exports = i(i); function i(c) { return typeof Float32Array < "u" ? function () { var u = new Float32Array([-0]), f = new Uint8Array(u.buffer), d = f[3] === 128; function p(C, x, T) { u[0] = C, x[T] = f[0], x[T + 1] = f[1], x[T + 2] = f[2], x[T + 3] = f[3] } function g(C, x, T) { u[0] = C, x[T] = f[3], x[T + 1] = f[2], x[T + 2] = f[1], x[T + 3] = f[0] } c.writeFloatLE = d ? p : g, c.writeFloatBE = d ? g : p; function m(C, x) { return f[0] = C[x], f[1] = C[x + 1], f[2] = C[x + 2], f[3] = C[x + 3], u[0] } function A(C, x) { return f[3] = C[x], f[2] = C[x + 1], f[1] = C[x + 2], f[0] = C[x + 3], u[0] } c.readFloatLE = d ? m : A, c.readFloatBE = d ? A : m }() : function () { function u(d, p, g, m) { var A = p < 0 ? 1 : 0; if (A && (p = -p), p === 0) d(1 / p > 0 ? 0 : 2147483648, g, m); else if (isNaN(p)) d(2143289344, g, m); else if (p > 34028234663852886e22) d((A << 31 | 2139095040) >>> 0, g, m); else if (p < 11754943508222875e-54) d((A << 31 | Math.round(p / 1401298464324817e-60)) >>> 0, g, m); else { var C = Math.floor(Math.log(p) / Math.LN2), x = Math.round(p * Math.pow(2, -C) * 8388608) & 8388607; d((A << 31 | C + 127 << 23 | x) >>> 0, g, m) } } c.writeFloatLE = u.bind(null, o), c.writeFloatBE = u.bind(null, r); function f(d, p, g) { var m = d(p, g), A = (m >> 31) * 2 + 1, C = m >>> 23 & 255, x = m & 8388607; return C === 255 ? x ? NaN : A * (1 / 0) : C === 0 ? A * 1401298464324817e-60 * x : A * Math.pow(2, C - 150) * (x + 8388608) } c.readFloatLE = f.bind(null, s), c.readFloatBE = f.bind(null, a) }(), typeof Float64Array < "u" ? function () { var u = new Float64Array([-0]), f = new Uint8Array(u.buffer), d = f[7] === 128; function p(C, x, T) { u[0] = C, x[T] = f[0], x[T + 1] = f[1], x[T + 2] = f[2], x[T + 3] = f[3], x[T + 4] = f[4], x[T + 5] = f[5], x[T + 6] = f[6], x[T + 7] = f[7] } function g(C, x, T) { u[0] = C, x[T] = f[7], x[T + 1] = f[6], x[T + 2] = f[5], x[T + 3] = f[4], x[T + 4] = f[3], x[T + 5] = f[2], x[T + 6] = f[1], x[T + 7] = f[0] } c.writeDoubleLE = d ? p : g, c.writeDoubleBE = d ? g : p; function m(C, x) { return f[0] = C[x], f[1] = C[x + 1], f[2] = C[x + 2], f[3] = C[x + 3], f[4] = C[x + 4], f[5] = C[x + 5], f[6] = C[x + 6], f[7] = C[x + 7], u[0] } function A(C, x) { return f[7] = C[x], f[6] = C[x + 1], f[5] = C[x + 2], f[4] = C[x + 3], f[3] = C[x + 4], f[2] = C[x + 5], f[1] = C[x + 6], f[0] = C[x + 7], u[0] } c.readDoubleLE = d ? m : A, c.readDoubleBE = d ? A : m }() : function () { function u(d, p, g, m, A, C) { var x = m < 0 ? 1 : 0; if (x && (m = -m), m === 0) d(0, A, C + p), d(1 / m > 0 ? 0 : 2147483648, A, C + g); else if (isNaN(m)) d(0, A, C + p), d(2146959360, A, C + g); else if (m > 17976931348623157e292) d(0, A, C + p), d((x << 31 | 2146435072) >>> 0, A, C + g); else { var T; if (m < 22250738585072014e-324) T = m / 5e-324, d(T >>> 0, A, C + p), d((x << 31 | T / 4294967296) >>> 0, A, C + g); else { var b = Math.floor(Math.log(m) / Math.LN2); b === 1024 && (b = 1023), T = m * Math.pow(2, -b), d(T * 4503599627370496 >>> 0, A, C + p), d((x << 31 | b + 1023 << 20 | T * 1048576 & 1048575) >>> 0, A, C + g) } } } c.writeDoubleLE = u.bind(null, o, 0, 4), c.writeDoubleBE = u.bind(null, r, 4, 0); function f(d, p, g, m, A) { var C = d(m, A + p), x = d(m, A + g), T = (x >> 31) * 2 + 1, b = x >>> 20 & 2047, S = 4294967296 * (x & 1048575) + C; return b === 2047 ? S ? NaN : T * (1 / 0) : b === 0 ? T * 5e-324 * S : T * Math.pow(2, b - 1075) * (S + 4503599627370496) } c.readDoubleLE = f.bind(null, s, 0, 4), c.readDoubleBE = f.bind(null, a, 4, 0) }(), c } function o(c, u, f) { u[f] = c & 255, u[f + 1] = c >>> 8 & 255, u[f + 2] = c >>> 16 & 255, u[f + 3] = c >>> 24 } function r(c, u, f) { u[f] = c >>> 24, u[f + 1] = c >>> 16 & 255, u[f + 2] = c >>> 8 & 255, u[f + 3] = c & 255 } function s(c, u) { return (c[u] | c[u + 1] << 8 | c[u + 2] << 16 | c[u + 3] << 24) >>> 0 } function a(c, u) { return (c[u] << 24 | c[u + 1] << 16 | c[u + 2] << 8 | c[u + 3]) >>> 0 } }, {}], 5: [function (require, module, exports) { "use strict"; module.exports = inquire; function inquire(moduleName) { try { var mod = eval("quire".replace(/^/, "re"))(moduleName); if (mod && (mod.length || Object.keys(mod).length)) return mod } catch (e) { } return null } }, {}], 6: [function (e, t, n) { "use strict"; t.exports = i; function i(o, r, s) { var a = s || 8192, c = a >>> 1, u = null, f = a; return function (p) { if (p < 1 || p > c) return o(p); f + p > a && (u = o(a), f = 0); var g = r.call(u, f, f += p); return f & 7 && (f = (f | 7) + 1), g } } }, {}], 7: [function (e, t, n) { "use strict"; var i = n; i.length = function (r) { for (var s = 0, a = 0, c = 0; c < r.length; ++c)a = r.charCodeAt(c), a < 128 ? s += 1 : a < 2048 ? s += 2 : (a & 64512) === 55296 && (r.charCodeAt(c + 1) & 64512) === 56320 ? (++c, s += 4) : s += 3; return s }, i.read = function (r, s, a) { var c = a - s; if (c < 1) return ""; for (var u = null, f = [], d = 0, p; s < a;)p = r[s++], p < 128 ? f[d++] = p : p > 191 && p < 224 ? f[d++] = (p & 31) << 6 | r[s++] & 63 : p > 239 && p < 365 ? (p = ((p & 7) << 18 | (r[s++] & 63) << 12 | (r[s++] & 63) << 6 | r[s++] & 63) - 65536, f[d++] = 55296 + (p >> 10), f[d++] = 56320 + (p & 1023)) : f[d++] = (p & 15) << 12 | (r[s++] & 63) << 6 | r[s++] & 63, d > 8191 && ((u || (u = [])).push(String.fromCharCode.apply(String, f)), d = 0); return u ? (d && u.push(String.fromCharCode.apply(String, f.slice(0, d))), u.join("")) : String.fromCharCode.apply(String, f.slice(0, d)) }, i.write = function (r, s, a) { for (var c = a, u, f, d = 0; d < r.length; ++d)u = r.charCodeAt(d), u < 128 ? s[a++] = u : u < 2048 ? (s[a++] = u >> 6 | 192, s[a++] = u & 63 | 128) : (u & 64512) === 55296 && ((f = r.charCodeAt(d + 1)) & 64512) === 56320 ? (u = 65536 + ((u & 1023) << 10) + (f & 1023), ++d, s[a++] = u >> 18 | 240, s[a++] = u >> 12 & 63 | 128, s[a++] = u >> 6 & 63 | 128, s[a++] = u & 63 | 128) : (s[a++] = u >> 12 | 224, s[a++] = u >> 6 & 63 | 128, s[a++] = u & 63 | 128); return a - c } }, {}], 8: [function (e, t, n) { "use strict"; var i = n; i.build = "minimal", i.Writer = e(16), i.BufferWriter = e(17), i.Reader = e(9), i.BufferReader = e(10), i.util = e(15), i.rpc = e(12), i.roots = e(11), i.configure = o; function o() { i.util._configure(), i.Writer._configure(i.BufferWriter), i.Reader._configure(i.BufferReader) } o() }, { 10: 10, 11: 11, 12: 12, 15: 15, 16: 16, 17: 17, 9: 9 }], 9: [function (e, t, n) { "use strict"; t.exports = c; var i = e(15), o, r = i.LongBits, s = i.utf8; function a(m, A) { return RangeError("index out of range: " + m.pos + " + " + (A || 1) + " > " + m.len) } function c(m) { this.buf = m, this.pos = 0, this.len = m.length } var u = typeof Uint8Array < "u" ? function (A) { if (A instanceof Uint8Array || Array.isArray(A)) return new c(A); throw Error("illegal buffer") } : function (A) { if (Array.isArray(A)) return new c(A); throw Error("illegal buffer") }, f = function () { return i.Buffer ? function (C) { return (c.create = function (T) { return i.Buffer.isBuffer(T) ? new o(T) : u(T) })(C) } : u }; c.create = f(), c.prototype._slice = i.Array.prototype.subarray || i.Array.prototype.slice, c.prototype.uint32 = function () { var A = 4294967295; return function () { if (A = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (A = (A | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (A = (A | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (A = (A | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (A = (A | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128)) return A; if ((this.pos += 5) > this.len) throw this.pos = this.len, a(this, 10); return A } }(), c.prototype.int32 = function () { return this.uint32() | 0 }, c.prototype.sint32 = function () { var A = this.uint32(); return A >>> 1 ^ -(A & 1) | 0 }; function d() { var m = new r(0, 0), A = 0; if (this.len - this.pos > 4) { for (; A < 4; ++A)if (m.lo = (m.lo | (this.buf[this.pos] & 127) << A * 7) >>> 0, this.buf[this.pos++] < 128) return m; if (m.lo = (m.lo | (this.buf[this.pos] & 127) << 28) >>> 0, m.hi = (m.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128) return m; A = 0 } else { for (; A < 3; ++A) { if (this.pos >= this.len) throw a(this); if (m.lo = (m.lo | (this.buf[this.pos] & 127) << A * 7) >>> 0, this.buf[this.pos++] < 128) return m } return m.lo = (m.lo | (this.buf[this.pos++] & 127) << A * 7) >>> 0, m } if (this.len - this.pos > 4) { for (; A < 5; ++A)if (m.hi = (m.hi | (this.buf[this.pos] & 127) << A * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return m } else for (; A < 5; ++A) { if (this.pos >= this.len) throw a(this); if (m.hi = (m.hi | (this.buf[this.pos] & 127) << A * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return m } throw Error("invalid varint encoding") } c.prototype.bool = function () { return this.uint32() !== 0 }; function p(m, A) { return (m[A - 4] | m[A - 3] << 8 | m[A - 2] << 16 | m[A - 1] << 24) >>> 0 } c.prototype.fixed32 = function () { if (this.pos + 4 > this.len) throw a(this, 4); return p(this.buf, this.pos += 4) }, c.prototype.sfixed32 = function () { if (this.pos + 4 > this.len) throw a(this, 4); return p(this.buf, this.pos += 4) | 0 }; function g() { if (this.pos + 8 > this.len) throw a(this, 8); return new r(p(this.buf, this.pos += 4), p(this.buf, this.pos += 4)) } c.prototype.float = function () { if (this.pos + 4 > this.len) throw a(this, 4); var A = i.float.readFloatLE(this.buf, this.pos); return this.pos += 4, A }, c.prototype.double = function () { if (this.pos + 8 > this.len) throw a(this, 4); var A = i.float.readDoubleLE(this.buf, this.pos); return this.pos += 8, A }, c.prototype.bytes = function () { var A = this.uint32(), C = this.pos, x = this.pos + A; if (x > this.len) throw a(this, A); return this.pos += A, Array.isArray(this.buf) ? this.buf.slice(C, x) : C === x ? new this.buf.constructor(0) : this._slice.call(this.buf, C, x) }, c.prototype.string = function () { var A = this.bytes(); return s.read(A, 0, A.length) }, c.prototype.skip = function (A) { if (typeof A == "number") { if (this.pos + A > this.len) throw a(this, A); this.pos += A } else do if (this.pos >= this.len) throw a(this); while (this.buf[this.pos++] & 128); return this }, c.prototype.skipType = function (m) { switch (m) { case 0: this.skip(); break; case 1: this.skip(8); break; case 2: this.skip(this.uint32()); break; case 3: for (; (m = this.uint32() & 7) !== 4;)this.skipType(m); break; case 5: this.skip(4); break; default: throw Error("invalid wire type " + m + " at offset " + this.pos) }return this }, c._configure = function (m) { o = m, c.create = f(), o._configure(); var A = i.Long ? "toLong" : "toNumber"; i.merge(c.prototype, { int64: function () { return d.call(this)[A](!1) }, uint64: function () { return d.call(this)[A](!0) }, sint64: function () { return d.call(this).zzDecode()[A](!1) }, fixed64: function () { return g.call(this)[A](!0) }, sfixed64: function () { return g.call(this)[A](!1) } }) } }, { 15: 15 }], 10: [function (e, t, n) { "use strict"; t.exports = r; var i = e(9); (r.prototype = Object.create(i.prototype)).constructor = r; var o = e(15); function r(s) { i.call(this, s) } r._configure = function () { o.Buffer && (r.prototype._slice = o.Buffer.prototype.slice) }, r.prototype.string = function () { var a = this.uint32(); return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + a, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + a, this.len)) }, r._configure() }, { 15: 15, 9: 9 }], 11: [function (e, t, n) { "use strict"; t.exports = {} }, {}], 12: [function (e, t, n) { "use strict"; var i = n; i.Service = e(13) }, { 13: 13 }], 13: [function (e, t, n) { "use strict"; t.exports = o; var i = e(15); (o.prototype = Object.create(i.EventEmitter.prototype)).constructor = o; function o(r, s, a) { if (typeof r != "function") throw TypeError("rpcImpl must be a function"); i.EventEmitter.call(this), this.rpcImpl = r, this.requestDelimited = Boolean(s), this.responseDelimited = Boolean(a) } o.prototype.rpcCall = function r(s, a, c, u, f) { if (!u) throw TypeError("request must be specified"); var d = this; if (!f) return i.asPromise(r, d, s, a, c, u); if (!d.rpcImpl) return setTimeout(function () { f(Error("already ended")) }, 0), undefined; try { return d.rpcImpl(s, a[d.requestDelimited ? "encodeDelimited" : "encode"](u).finish(), function (g, m) { if (g) return d.emit("error", g, s), f(g); if (m === null) return d.end(!0), undefined; if (!(m instanceof c)) try { m = c[d.responseDelimited ? "decodeDelimited" : "decode"](m) } catch (A) { return d.emit("error", A, s), f(A) } return d.emit("data", m, s), f(null, m) }) } catch (p) { return d.emit("error", p, s), setTimeout(function () { f(p) }, 0), undefined } }, o.prototype.end = function (s) { return this.rpcImpl && (s || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this } }, { 15: 15 }], 14: [function (e, t, n) { "use strict"; t.exports = o; var i = e(15); function o(c, u) { this.lo = c >>> 0, this.hi = u >>> 0 } var r = o.zero = new o(0, 0); r.toNumber = function () { return 0 }, r.zzEncode = r.zzDecode = function () { return this }, r.length = function () { return 1 }; var s = o.zeroHash = "\0\0\0\0\0\0\0\0"; o.fromNumber = function (u) { if (u === 0) return r; var f = u < 0; f && (u = -u); var d = u >>> 0, p = (u - d) / 4294967296 >>> 0; return f && (p = ~p >>> 0, d = ~d >>> 0, ++d > 4294967295 && (d = 0, ++p > 4294967295 && (p = 0))), new o(d, p) }, o.from = function (u) { if (typeof u == "number") return o.fromNumber(u); if (i.isString(u)) if (i.Long) u = i.Long.fromString(u); else return o.fromNumber(parseInt(u, 10)); return u.low || u.high ? new o(u.low >>> 0, u.high >>> 0) : r }, o.prototype.toNumber = function (u) { if (!u && this.hi >>> 31) { var f = ~this.lo + 1 >>> 0, d = ~this.hi >>> 0; return f || (d = d + 1 >>> 0), -(f + d * 4294967296) } return this.lo + this.hi * 4294967296 }, o.prototype.toLong = function (u) { return i.Long ? new i.Long(this.lo | 0, this.hi | 0, Boolean(u)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(u) } }; var a = String.prototype.charCodeAt; o.fromHash = function (u) { return u === s ? r : new o((a.call(u, 0) | a.call(u, 1) << 8 | a.call(u, 2) << 16 | a.call(u, 3) << 24) >>> 0, (a.call(u, 4) | a.call(u, 5) << 8 | a.call(u, 6) << 16 | a.call(u, 7) << 24) >>> 0) }, o.prototype.toHash = function () { return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24) }, o.prototype.zzEncode = function () { var u = this.hi >> 31; return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ u) >>> 0, this.lo = (this.lo << 1 ^ u) >>> 0, this }, o.prototype.zzDecode = function () { var u = -(this.lo & 1); return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ u) >>> 0, this.hi = (this.hi >>> 1 ^ u) >>> 0, this }, o.prototype.length = function () { var u = this.lo, f = (this.lo >>> 28 | this.hi << 4) >>> 0, d = this.hi >>> 24; return d === 0 ? f === 0 ? u < 16384 ? u < 128 ? 1 : 2 : u < 2097152 ? 3 : 4 : f < 16384 ? f < 128 ? 5 : 6 : f < 2097152 ? 7 : 8 : d < 128 ? 9 : 10 } }, { 15: 15 }], 15: [function (e, t, n) { "use strict"; var i = n; i.asPromise = e(1), i.base64 = e(2), i.EventEmitter = e(3), i.float = e(4), i.inquire = e(5), i.utf8 = e(7), i.pool = e(6), i.LongBits = e(14), i.isNode = Boolean(typeof global < "u" && global && global.process && global.process.versions && global.process.versions.node), i.global = i.isNode && global || typeof window < "u" && window || typeof self < "u" && self || this, i.emptyArray = Object.freeze ? Object.freeze([]) : [], i.emptyObject = Object.freeze ? Object.freeze({}) : {}, i.isInteger = Number.isInteger || function (a) { return typeof a == "number" && isFinite(a) && Math.floor(a) === a }, i.isString = function (a) { return typeof a == "string" || a instanceof String }, i.isObject = function (a) { return a && typeof a == "object" }, i.isset = i.isSet = function (a, c) { var u = a[c]; return u != null && a.hasOwnProperty(c) ? typeof u != "object" || (Array.isArray(u) ? u.length : Object.keys(u).length) > 0 : !1 }, i.Buffer = function () { try { var s = i.inquire("buffer").Buffer; return s.prototype.utf8Write ? s : null } catch { return null } }(), i._Buffer_from = null, i._Buffer_allocUnsafe = null, i.newBuffer = function (a) { return typeof a == "number" ? i.Buffer ? i._Buffer_allocUnsafe(a) : new i.Array(a) : i.Buffer ? i._Buffer_from(a) : typeof Uint8Array > "u" ? a : new Uint8Array(a) }, i.Array = typeof Uint8Array < "u" ? Uint8Array : Array, i.Long = i.global.dcodeIO && i.global.dcodeIO.Long || i.global.Long || i.inquire("long"), i.key2Re = /^true|false|0|1$/, i.key32Re = /^-?(?:0|[1-9][0-9]*)$/, i.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, i.longToHash = function (a) { return a ? i.LongBits.from(a).toHash() : i.LongBits.zeroHash }, i.longFromHash = function (a, c) { var u = i.LongBits.fromHash(a); return i.Long ? i.Long.fromBits(u.lo, u.hi, c) : u.toNumber(Boolean(c)) }; function o(s, a, c) { for (var u = Object.keys(a), f = 0; f < u.length; ++f)(s[u[f]] === undefined || !c) && (s[u[f]] = a[u[f]]); return s } i.merge = o, i.lcFirst = function (a) { return a.charAt(0).toLowerCase() + a.substring(1) }; function r(s) { function a(c, u) { if (!(this instanceof a)) return new a(c, u); Object.defineProperty(this, "message", { get: function () { return c } }), Error.captureStackTrace ? Error.captureStackTrace(this, a) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), u && o(this, u) } return a.prototype = Object.create(Error.prototype, { constructor: { value: a, writable: !0, enumerable: !1, configurable: !0 }, name: { get() { return s }, set: undefined, enumerable: !1, configurable: !0 }, toString: { value() { return this.name + ": " + this.message }, writable: !0, enumerable: !1, configurable: !0 } }), a } i.newError = r, i.ProtocolError = r("ProtocolError"), i.oneOfGetter = function (a) { for (var c = {}, u = 0; u < a.length; ++u)c[a[u]] = 1; return function () { for (var f = Object.keys(this), d = f.length - 1; d > -1; --d)if (c[f[d]] === 1 && this[f[d]] !== undefined && this[f[d]] !== null) return f[d] } }, i.oneOfSetter = function (a) { return function (c) { for (var u = 0; u < a.length; ++u)a[u] !== c && delete this[a[u]] } }, i.toJSONOptions = { longs: String, enums: String, bytes: String, json: !0 }, i._configure = function () { var s = i.Buffer; if (!s) { i._Buffer_from = i._Buffer_allocUnsafe = null; return } i._Buffer_from = s.from !== Uint8Array.from && s.from || function (c, u) { return new s(c, u) }, i._Buffer_allocUnsafe = s.allocUnsafe || function (c) { return new s(c) } } }, { 1: 1, 14: 14, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7 }], 16: [function (e, t, n) { "use strict"; t.exports = d; var i = e(15), o, r = i.LongBits, s = i.base64, a = i.utf8; function c(b, S, D) { this.fn = b, this.len = S, this.next = undefined, this.val = D } function u() { } function f(b) { this.head = b.head, this.tail = b.tail, this.len = b.len, this.next = b.states } function d() { this.len = 0, this.head = new c(u, 0, 0), this.tail = this.head, this.states = null } var p = function () { return i.Buffer ? function () { return (d.create = function () { return new o })() } : function () { return new d } }; d.create = p(), d.alloc = function (S) { return new i.Array(S) }, i.Array !== Array && (d.alloc = i.pool(d.alloc, i.Array.prototype.subarray)), d.prototype._push = function (S, D, P) { return this.tail = this.tail.next = new c(S, D, P), this.len += D, this }; function g(b, S, D) { S[D] = b & 255 } function m(b, S, D) { for (; b > 127;)S[D++] = b & 127 | 128, b >>>= 7; S[D] = b } function A(b, S) { this.len = b, this.next = undefined, this.val = S } A.prototype = Object.create(c.prototype), A.prototype.fn = m, d.prototype.uint32 = function (S) { return this.len += (this.tail = this.tail.next = new A((S = S >>> 0) < 128 ? 1 : S < 16384 ? 2 : S < 2097152 ? 3 : S < 268435456 ? 4 : 5, S)).len, this }, d.prototype.int32 = function (S) { return S < 0 ? this._push(C, 10, r.fromNumber(S)) : this.uint32(S) }, d.prototype.sint32 = function (S) { return this.uint32((S << 1 ^ S >> 31) >>> 0) }; function C(b, S, D) { for (; b.hi;)S[D++] = b.lo & 127 | 128, b.lo = (b.lo >>> 7 | b.hi << 25) >>> 0, b.hi >>>= 7; for (; b.lo > 127;)S[D++] = b.lo & 127 | 128, b.lo = b.lo >>> 7; S[D++] = b.lo } d.prototype.uint64 = function (S) { var D = r.from(S); return this._push(C, D.length(), D) }, d.prototype.int64 = d.prototype.uint64, d.prototype.sint64 = function (S) { var D = r.from(S).zzEncode(); return this._push(C, D.length(), D) }, d.prototype.bool = function (S) { return this._push(g, 1, S ? 1 : 0) }; function x(b, S, D) { S[D] = b & 255, S[D + 1] = b >>> 8 & 255, S[D + 2] = b >>> 16 & 255, S[D + 3] = b >>> 24 } d.prototype.fixed32 = function (S) { return this._push(x, 4, S >>> 0) }, d.prototype.sfixed32 = d.prototype.fixed32, d.prototype.fixed64 = function (S) { var D = r.from(S); return this._push(x, 4, D.lo)._push(x, 4, D.hi) }, d.prototype.sfixed64 = d.prototype.fixed64, d.prototype.float = function (S) { return this._push(i.float.writeFloatLE, 4, S) }, d.prototype.double = function (S) { return this._push(i.float.writeDoubleLE, 8, S) }; var T = i.Array.prototype.set ? function (S, D, P) { D.set(S, P) } : function (S, D, P) { for (var B = 0; B < S.length; ++B)D[P + B] = S[B] }; d.prototype.bytes = function (S) { var D = S.length >>> 0; if (!D) return this._push(g, 1, 0); if (i.isString(S)) { var P = d.alloc(D = s.length(S)); s.decode(S, P, 0), S = P } return this.uint32(D)._push(T, D, S) }, d.prototype.string = function (S) { var D = a.length(S); return D ? this.uint32(D)._push(a.write, D, S) : this._push(g, 1, 0) }, d.prototype.fork = function () { return this.states = new f(this), this.head = this.tail = new c(u, 0, 0), this.len = 0, this }, d.prototype.reset = function () { return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new c(u, 0, 0), this.len = 0), this }, d.prototype.ldelim = function () { var S = this.head, D = this.tail, P = this.len; return this.reset().uint32(P), P && (this.tail.next = S.next, this.tail = D, this.len += P), this }, d.prototype.finish = function () { for (var S = this.head.next, D = this.constructor.alloc(this.len), P = 0; S;)S.fn(S.val, D, P), P += S.len, S = S.next; return D }, d._configure = function (b) { o = b, d.create = p(), o._configure() } }, { 15: 15 }], 17: [function (e, t, n) { "use strict"; t.exports = r; var i = e(16); (r.prototype = Object.create(i.prototype)).constructor = r; var o = e(15); function r() { i.call(this) } r._configure = function () { r.alloc = o._Buffer_allocUnsafe, r.writeBytesBuffer = o.Buffer && o.Buffer.prototype instanceof Uint8Array && o.Buffer.prototype.set.name === "set" ? function (c, u, f) { u.set(c, f) } : function (c, u, f) { if (c.copy) c.copy(u, f, 0, c.length); else for (var d = 0; d < c.length;)u[f++] = c[d++] } }, r.prototype.bytes = function (c) { o.isString(c) && (c = o._Buffer_from(c, "base64")); var u = c.length >>> 0; return this.uint32(u), u && this._push(r.writeBytesBuffer, u, c), this }; function s(a, c, u) { a.length < 40 ? o.utf8.write(a, c, u) : c.utf8Write ? c.utf8Write(a, u) : c.write(a, u) } r.prototype.string = function (c) { var u = o.Buffer.byteLength(c); return this.uint32(u), u && this._push(s, u, c), this }, r._configure() }, { 15: 15, 16: 16 }] }, {}, [8]) })()
    }); var W0e = Wa((pwi, G0e) => { G0e.exports = { webm: "data:video/webm;base64,GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4EEQoWBAhhTgGcBAAAAAAAVkhFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsghV17AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU1LjMzLjEwMFdBjUxhdmY1NS4zMy4xMDBzpJBlrrXf3DCDVB8KcgbMpcr+RImIQJBgAAAAAAAWVK5rAQAAAAAAD++uAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDiDgQEj44OEAmJaAOABAAAAAAAABrCBsLqBkK4BAAAAAAAPq9eBAnPFgQKcgQAitZyDdW5khohBX1ZPUkJJU4OBAuEBAAAAAAAAEZ+BArWIQOdwAAAAAABiZIEgY6JPbwIeVgF2b3JiaXMAAAAAAoC7AAAAAAAAgLUBAAAAAAC4AQN2b3JiaXMtAAAAWGlwaC5PcmcgbGliVm9yYmlzIEkgMjAxMDExMDEgKFNjaGF1ZmVudWdnZXQpAQAAABUAAABlbmNvZGVyPUxhdmM1NS41Mi4xMDIBBXZvcmJpcyVCQ1YBAEAAACRzGCpGpXMWhBAaQlAZ4xxCzmvsGUJMEYIcMkxbyyVzkCGkoEKIWyiB0JBVAABAAACHQXgUhIpBCCGEJT1YkoMnPQghhIg5eBSEaUEIIYQQQgghhBBCCCGERTlokoMnQQgdhOMwOAyD5Tj4HIRFOVgQgydB6CCED0K4moOsOQghhCQ1SFCDBjnoHITCLCiKgsQwuBaEBDUojILkMMjUgwtCiJqDSTX4GoRnQXgWhGlBCCGEJEFIkIMGQcgYhEZBWJKDBjm4FITLQagahCo5CB+EIDRkFQCQAACgoiiKoigKEBqyCgDIAAAQQFEUx3EcyZEcybEcCwgNWQUAAAEACAAAoEiKpEiO5EiSJFmSJVmSJVmS5omqLMuyLMuyLMsyEBqyCgBIAABQUQxFcRQHCA1ZBQBkAAAIoDiKpViKpWiK54iOCISGrAIAgAAABAAAEDRDUzxHlETPVFXXtm3btm3btm3btm3btm1blmUZCA1ZBQBAAAAQ0mlmqQaIMAMZBkJDVgEACAAAgBGKMMSA0JBVAABAAACAGEoOogmtOd+c46BZDppKsTkdnEi1eZKbirk555xzzsnmnDHOOeecopxZDJoJrTnnnMSgWQqaCa0555wnsXnQmiqtOeeccc7pYJwRxjnnnCateZCajbU555wFrWmOmkuxOeecSLl5UptLtTnnnHPOOeecc84555zqxekcnBPOOeecqL25lpvQxTnnnE/G6d6cEM4555xzzjnnnHPOOeecIDRkFQAABABAEIaNYdwpCNLnaCBGEWIaMulB9+gwCRqDnELq0ehopJQ6CCWVcVJKJwgNWQUAAAIAQAghhRRSSCGFFFJIIYUUYoghhhhyyimnoIJKKqmooowyyyyzzDLLLLPMOuyssw47DDHEEEMrrcRSU2011lhr7jnnmoO0VlprrbVSSimllFIKQkNWAQAgAAAEQgYZZJBRSCGFFGKIKaeccgoqqIDQkFUAACAAgAAAAABP8hzRER3RER3RER3RER3R8RzPESVREiVREi3TMjXTU0VVdWXXlnVZt31b2IVd933d933d+HVhWJZlWZZlWZZlWZZlWZZlWZYgNGQVAAACAAAghBBCSCGFFFJIKcYYc8w56CSUEAgNWQUAAAIACAAAAHAUR3EcyZEcSbIkS9IkzdIsT/M0TxM9URRF0zRV0RVdUTdtUTZl0zVdUzZdVVZtV5ZtW7Z125dl2/d93/d93/d93/d93/d9XQdCQ1YBABIAADqSIymSIimS4ziOJElAaMgqAEAGAEAAAIriKI7jOJIkSZIlaZJneZaomZrpmZ4qqkBoyCoAABAAQAAAAAAAAIqmeIqpeIqoeI7oiJJomZaoqZoryqbsuq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq4LhIasAgAkAAB0JEdyJEdSJEVSJEdygNCQVQCADACAAAAcwzEkRXIsy9I0T/M0TxM90RM901NFV3SB0JBVAAAgAIAAAAAAAAAMybAUy9EcTRIl1VItVVMt1VJF1VNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVN0zRNEwgNWQkAkAEAkBBTLS3GmgmLJGLSaqugYwxS7KWxSCpntbfKMYUYtV4ah5RREHupJGOKQcwtpNApJq3WVEKFFKSYYyoVUg5SIDRkhQAQmgHgcBxAsixAsiwAAAAAAAAAkDQN0DwPsDQPAAAAAAAAACRNAyxPAzTPAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA0jRA8zxA8zwAAAAAAAAA0DwP8DwR8EQRAAAAAAAAACzPAzTRAzxRBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA0jRA8zxA8zwAAAAAAAAAsDwP8EQR0DwRAAAAAAAAACzPAzxRBDzRAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEOAAABBgIRQasiIAiBMAcEgSJAmSBM0DSJYFTYOmwTQBkmVB06BpME0AAAAAAAAAAAAAJE2DpkHTIIoASdOgadA0iCIAAAAAAAAAAAAAkqZB06BpEEWApGnQNGgaRBEAAAAAAAAAAAAAzzQhihBFmCbAM02IIkQRpgkAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAGHAAAAgwoQwUGrIiAIgTAHA4imUBAIDjOJYFAACO41gWAABYliWKAABgWZooAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAYcAAACDChDBQashIAiAIAcCiKZQHHsSzgOJYFJMmyAJYF0DyApgFEEQAIAAAocAAACLBBU2JxgEJDVgIAUQAABsWxLE0TRZKkaZoniiRJ0zxPFGma53meacLzPM80IYqiaJoQRVE0TZimaaoqME1VFQAAUOAAABBgg6bE4gCFhqwEAEICAByKYlma5nmeJ4qmqZokSdM8TxRF0TRNU1VJkqZ5niiKommapqqyLE3zPFEURdNUVVWFpnmeKIqiaaqq6sLzPE8URdE0VdV14XmeJ4qiaJqq6roQRVE0TdNUTVV1XSCKpmmaqqqqrgtETxRNU1Vd13WB54miaaqqq7ouEE3TVFVVdV1ZBpimaaqq68oyQFVV1XVdV5YBqqqqruu6sgxQVdd1XVmWZQCu67qyLMsCAAAOHAAAAoygk4wqi7DRhAsPQKEhKwKAKAAAwBimFFPKMCYhpBAaxiSEFEImJaXSUqogpFJSKRWEVEoqJaOUUmopVRBSKamUCkIqJZVSAADYgQMA2IGFUGjISgAgDwCAMEYpxhhzTiKkFGPOOScRUoox55yTSjHmnHPOSSkZc8w556SUzjnnnHNSSuacc845KaVzzjnnnJRSSuecc05KKSWEzkEnpZTSOeecEwAAVOAAABBgo8jmBCNBhYasBABSAQAMjmNZmuZ5omialiRpmud5niiapiZJmuZ5nieKqsnzPE8URdE0VZXneZ4oiqJpqirXFUXTNE1VVV2yLIqmaZqq6rowTdNUVdd1XZimaaqq67oubFtVVdV1ZRm2raqq6rqyDFzXdWXZloEsu67s2rIAAPAEBwCgAhtWRzgpGgssNGQlAJABAEAYg5BCCCFlEEIKIYSUUggJAAAYcAAACDChDBQashIASAUAAIyx1lprrbXWQGettdZaa62AzFprrbXWWmuttdZaa6211lJrrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmstpZRSSimllFJKKaWUUkoppZRSSgUA+lU4APg/2LA6wknRWGChISsBgHAAAMAYpRhzDEIppVQIMeacdFRai7FCiDHnJKTUWmzFc85BKCGV1mIsnnMOQikpxVZjUSmEUlJKLbZYi0qho5JSSq3VWIwxqaTWWoutxmKMSSm01FqLMRYjbE2ptdhqq7EYY2sqLbQYY4zFCF9kbC2m2moNxggjWywt1VprMMYY3VuLpbaaizE++NpSLDHWXAAAd4MDAESCjTOsJJ0VjgYXGrISAAgJACAQUooxxhhzzjnnpFKMOeaccw5CCKFUijHGnHMOQgghlIwx5pxzEEIIIYRSSsaccxBCCCGEkFLqnHMQQgghhBBKKZ1zDkIIIYQQQimlgxBCCCGEEEoopaQUQgghhBBCCKmklEIIIYRSQighlZRSCCGEEEIpJaSUUgohhFJCCKGElFJKKYUQQgillJJSSimlEkoJJYQSUikppRRKCCGUUkpKKaVUSgmhhBJKKSWllFJKIYQQSikFAAAcOAAABBhBJxlVFmGjCRcegEJDVgIAZAAAkKKUUiktRYIipRikGEtGFXNQWoqocgxSzalSziDmJJaIMYSUk1Qy5hRCDELqHHVMKQYtlRhCxhik2HJLoXMOAAAAQQCAgJAAAAMEBTMAwOAA4XMQdAIERxsAgCBEZohEw0JweFAJEBFTAUBigkIuAFRYXKRdXECXAS7o4q4DIQQhCEEsDqCABByccMMTb3jCDU7QKSp1IAAAAAAADADwAACQXAAREdHMYWRobHB0eHyAhIiMkAgAAAAAABcAfAAAJCVAREQ0cxgZGhscHR4fICEiIyQBAIAAAgAAAAAggAAEBAQAAAAAAAIAAAAEBB9DtnUBAAAAAAAEPueBAKOFggAAgACjzoEAA4BwBwCdASqwAJAAAEcIhYWIhYSIAgIABhwJ7kPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99YAD+/6tQgKOFggADgAqjhYIAD4AOo4WCACSADqOZgQArADECAAEQEAAYABhYL/QACIBDmAYAAKOFggA6gA6jhYIAT4AOo5mBAFMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAGSADqOFggB6gA6jmYEAewAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIAj4AOo5mBAKMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAKSADqOFggC6gA6jmYEAywAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIAz4AOo4WCAOSADqOZgQDzADECAAEQEAAYABhYL/QACIBDmAYAAKOFggD6gA6jhYIBD4AOo5iBARsAEQIAARAQFGAAYWC/0AAiAQ5gGACjhYIBJIAOo4WCATqADqOZgQFDADECAAEQEAAYABhYL/QACIBDmAYAAKOFggFPgA6jhYIBZIAOo5mBAWsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAXqADqOFggGPgA6jmYEBkwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIBpIAOo4WCAbqADqOZgQG7ADECAAEQEAAYABhYL/QACIBDmAYAAKOFggHPgA6jmYEB4wAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIB5IAOo4WCAfqADqOZgQILADECAAEQEAAYABhYL/QACIBDmAYAAKOFggIPgA6jhYICJIAOo5mBAjMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAjqADqOFggJPgA6jmYECWwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYICZIAOo4WCAnqADqOZgQKDADECAAEQEAAYABhYL/QACIBDmAYAAKOFggKPgA6jhYICpIAOo5mBAqsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCArqADqOFggLPgA6jmIEC0wARAgABEBAUYABhYL/QACIBDmAYAKOFggLkgA6jhYIC+oAOo5mBAvsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAw+ADqOZgQMjADECAAEQEAAYABhYL/QACIBDmAYAAKOFggMkgA6jhYIDOoAOo5mBA0sAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCA0+ADqOFggNkgA6jmYEDcwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIDeoAOo4WCA4+ADqOZgQObADECAAEQEAAYABhYL/QACIBDmAYAAKOFggOkgA6jhYIDuoAOo5mBA8MAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCA8+ADqOFggPkgA6jhYID+oAOo4WCBA+ADhxTu2sBAAAAAAAAEbuPs4EDt4r3gQHxghEr8IEK", mp4: "data:video/mp4;base64,AAAAHGZ0eXBNNFYgAAACAGlzb21pc28yYXZjMQAAAAhmcmVlAAAGF21kYXTeBAAAbGliZmFhYyAxLjI4AABCAJMgBDIARwAAArEGBf//rdxF6b3m2Ui3lizYINkj7u94MjY0IC0gY29yZSAxNDIgcjIgOTU2YzhkOCAtIEguMjY0L01QRUctNCBBVkMgY29kZWMgLSBDb3B5bGVmdCAyMDAzLTIwMTQgLSBodHRwOi8vd3d3LnZpZGVvbGFuLm9yZy94MjY0Lmh0bWwgLSBvcHRpb25zOiBjYWJhYz0wIHJlZj0zIGRlYmxvY2s9MTowOjAgYW5hbHlzZT0weDE6MHgxMTEgbWU9aGV4IHN1Ym1lPTcgcHN5PTEgcHN5X3JkPTEuMDA6MC4wMCBtaXhlZF9yZWY9MSBtZV9yYW5nZT0xNiBjaHJvbWFfbWU9MSB0cmVsbGlzPTEgOHg4ZGN0PTAgY3FtPTAgZGVhZHpvbmU9MjEsMTEgZmFzdF9wc2tpcD0xIGNocm9tYV9xcF9vZmZzZXQ9LTIgdGhyZWFkcz02IGxvb2thaGVhZF90aHJlYWRzPTEgc2xpY2VkX3RocmVhZHM9MCBucj0wIGRlY2ltYXRlPTEgaW50ZXJsYWNlZD0wIGJsdXJheV9jb21wYXQ9MCBjb25zdHJhaW5lZF9pbnRyYT0wIGJmcmFtZXM9MCB3ZWlnaHRwPTAga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCB2YnZfbWF4cmF0ZT03NjggdmJ2X2J1ZnNpemU9MzAwMCBjcmZfbWF4PTAuMCBuYWxfaHJkPW5vbmUgZmlsbGVyPTAgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAAFZliIQL8mKAAKvMnJycnJycnJycnXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXiEASZACGQAjgCEASZACGQAjgAAAAAdBmjgX4GSAIQBJkAIZACOAAAAAB0GaVAX4GSAhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGagC/AySEASZACGQAjgAAAAAZBmqAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZrAL8DJIQBJkAIZACOAAAAABkGa4C/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmwAvwMkhAEmQAhkAI4AAAAAGQZsgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGbQC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm2AvwMkhAEmQAhkAI4AAAAAGQZuAL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGboC/AySEASZACGQAjgAAAAAZBm8AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZvgL8DJIQBJkAIZACOAAAAABkGaAC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmiAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpAL8DJIQBJkAIZACOAAAAABkGaYC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmoAvwMkhAEmQAhkAI4AAAAAGQZqgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGawC/AySEASZACGQAjgAAAAAZBmuAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZsAL8DJIQBJkAIZACOAAAAABkGbIC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm0AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZtgL8DJIQBJkAIZACOAAAAABkGbgCvAySEASZACGQAjgCEASZACGQAjgAAAAAZBm6AnwMkhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AAAAhubW9vdgAAAGxtdmhkAAAAAAAAAAAAAAAAAAAD6AAABDcAAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAzB0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAABAAAAAAAAA+kAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAALAAAACQAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAPpAAAAAAABAAAAAAKobWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAB1MAAAdU5VxAAAAAAALWhkbHIAAAAAAAAAAHZpZGUAAAAAAAAAAAAAAABWaWRlb0hhbmRsZXIAAAACU21pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAhNzdGJsAAAAr3N0c2QAAAAAAAAAAQAAAJ9hdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAALAAkABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP//AAAALWF2Y0MBQsAN/+EAFWdCwA3ZAsTsBEAAAPpAADqYA8UKkgEABWjLg8sgAAAAHHV1aWRraEDyXyRPxbo5pRvPAyPzAAAAAAAAABhzdHRzAAAAAAAAAAEAAAAeAAAD6QAAABRzdHNzAAAAAAAAAAEAAAABAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAABAAAAAQAAAIxzdHN6AAAAAAAAAAAAAAAeAAADDwAAAAsAAAALAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAAiHN0Y28AAAAAAAAAHgAAAEYAAANnAAADewAAA5gAAAO0AAADxwAAA+MAAAP2AAAEEgAABCUAAARBAAAEXQAABHAAAASMAAAEnwAABLsAAATOAAAE6gAABQYAAAUZAAAFNQAABUgAAAVkAAAFdwAABZMAAAWmAAAFwgAABd4AAAXxAAAGDQAABGh0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAACAAAAAAAABDcAAAAAAAAAAAAAAAEBAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAQkAAADcAABAAAAAAPgbWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAC7gAAAykBVxAAAAAAALWhkbHIAAAAAAAAAAHNvdW4AAAAAAAAAAAAAAABTb3VuZEhhbmRsZXIAAAADi21pbmYAAAAQc21oZAAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAADT3N0YmwAAABnc3RzZAAAAAAAAAABAAAAV21wNGEAAAAAAAAAAQAAAAAAAAAAAAIAEAAAAAC7gAAAAAAAM2VzZHMAAAAAA4CAgCIAAgAEgICAFEAVBbjYAAu4AAAADcoFgICAAhGQBoCAgAECAAAAIHN0dHMAAAAAAAAAAgAAADIAAAQAAAAAAQAAAkAAAAFUc3RzYwAAAAAAAAAbAAAAAQAAAAEAAAABAAAAAgAAAAIAAAABAAAAAwAAAAEAAAABAAAABAAAAAIAAAABAAAABgAAAAEAAAABAAAABwAAAAIAAAABAAAACAAAAAEAAAABAAAACQAAAAIAAAABAAAACgAAAAEAAAABAAAACwAAAAIAAAABAAAADQAAAAEAAAABAAAADgAAAAIAAAABAAAADwAAAAEAAAABAAAAEAAAAAIAAAABAAAAEQAAAAEAAAABAAAAEgAAAAIAAAABAAAAFAAAAAEAAAABAAAAFQAAAAIAAAABAAAAFgAAAAEAAAABAAAAFwAAAAIAAAABAAAAGAAAAAEAAAABAAAAGQAAAAIAAAABAAAAGgAAAAEAAAABAAAAGwAAAAIAAAABAAAAHQAAAAEAAAABAAAAHgAAAAIAAAABAAAAHwAAAAQAAAABAAAA4HN0c3oAAAAAAAAAAAAAADMAAAAaAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAACMc3RjbwAAAAAAAAAfAAAALAAAA1UAAANyAAADhgAAA6IAAAO+AAAD0QAAA+0AAAQAAAAEHAAABC8AAARLAAAEZwAABHoAAASWAAAEqQAABMUAAATYAAAE9AAABRAAAAUjAAAFPwAABVIAAAVuAAAFgQAABZ0AAAWwAAAFzAAABegAAAX7AAAGFwAAAGJ1ZHRhAAAAWm1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAALWlsc3QAAAAlqXRvbwAAAB1kYXRhAAAAAQAAAABMYXZmNTUuMzMuMTAw" } }); var q0e = Wa((_wi, j0e) => {
        var { webm: Jht, mp4: Zht } = W0e(), wq = () => typeof navigator < "u" && parseFloat(("" + (/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ""])[1]).replace("undefined", "3_2").replace("_", ".").replace("_", "")) < 10 && !window.MSStream, Dq = () => "wakeLock" in navigator, vq = class {
            constructor() { if (this.enabled = !1, Dq()) { this._wakeLock = null; let t = () => { this._wakeLock !== null && document.visibilityState === "visible" && this.enable() }; document.addEventListener("visibilitychange", t), document.addEventListener("fullscreenchange", t) } else wq() ? this.noSleepTimer = null : (this.noSleepVideo = document.createElement("video"), this.noSleepVideo.setAttribute("title", "No Sleep"), this.noSleepVideo.setAttribute("playsinline", ""), this._addSourceToVideo(this.noSleepVideo, "webm", Jht), this._addSourceToVideo(this.noSleepVideo, "mp4", Zht), this.noSleepVideo.addEventListener("loadedmetadata", () => { this.noSleepVideo.duration <= 1 ? this.noSleepVideo.setAttribute("loop", "") : this.noSleepVideo.addEventListener("timeupdate", () => { this.noSleepVideo.currentTime > .5 && (this.noSleepVideo.currentTime = Math.random()) }) })) } _addSourceToVideo(t, n, i) { var o = document.createElement("source"); o.src = i, o.type = `video/${n}`, t.appendChild(o) } get isEnabled() { return this.enabled } enable() {
                return Dq() ? navigator.wakeLock.request("screen").then(t => { this._wakeLock = t, this.enabled = !0, console.log("Wake Lock active."), this._wakeLock.addEventListener("release", () => { console.log("Wake Lock released.") }) }).catch(t => { throw this.enabled = !1, console.error(`${t.name}, ${t.message}`), t }) : wq() ? (this.disable(), console.warn(`
        NoSleep enabled for older iOS devices. This can interrupt
        active or long-running network requests from completing successfully.
        See https://github.com/richtr/NoSleep.js/issues/15 for more details.
      `), this.noSleepTimer = window.setInterval(() => { document.hidden || (window.location.href = window.location.href.split("#")[0], window.setTimeout(window.stop, 0)) }, 15e3), this.enabled = !0, Promise.resolve()) : this.noSleepVideo.play().then(n => (this.enabled = !0, n)).catch(n => { throw this.enabled = !1, n })
            } disable() {
                Dq() ? (this._wakeLock && this._wakeLock.release(), this._wakeLock = null) : wq() ? this.noSleepTimer && (console.warn(`
          NoSleep now disabled for older iOS devices.
        `), window.clearInterval(this.noSleepTimer), this.noSleepTimer = null) : this.noSleepVideo.pause(), this.enabled = !1
            }
        }; j0e.exports = vq
    }); var Amt = {}; xye(Amt, { AlphaMode: () => xm, AlphaPipelineStage: () => CM, Animation: () => E4, AnimationViewModel: () => b4, Appearance: () => Yi, ApproximateTerrainHeights: () => oi, ArcGISTiledElevationTerrainProvider: () => fde, ArcGisMapServerImageryProvider: () => Mg, ArcType: () => Yt, ArticulationStageType: () => rc, AssociativeArray: () => Ct, AttributeCompression: () => kn, AttributeType: () => en, AutoExposure: () => fV, AutomaticUniforms: () => Fp, Axis: () => Do, AxisAlignedBoundingBox: () => h0, B3dmLoader: () => RR, B3dmParser: () => BR, BaseLayerPicker: () => _4, BaseLayerPickerViewModel: () => m4, BatchTable: () => fC, BatchTableHierarchy: () => UC, BatchTexture: () => Nc, BatchTexturePipelineStage: () => xM, Billboard: () => co, BillboardCollection: () => yu, BillboardGraphics: () => ja, BillboardVisualizer: () => hP, BingMapsGeocoderService: () => hde, BingMapsImageryProvider: () => mV, BingMapsStyle: () => dV, BlendEquation: () => ma, BlendFunction: () => Co, BlendOption: () => xo, BlendingState: () => an, BoundingRectangle: () => Ge, BoundingSphere: () => re, BoundingSphereState: () => rt, BoxEmitter: () => eme, BoxGeometry: () => ll, BoxGeometryUpdater: () => bB, BoxGraphics: () => bC, BoxOutlineGeometry: () => bd, BrdfLutGenerator: () => _V, Buffer: () => ct, BufferLoader: () => GC, BufferUsage: () => Re, CPUStylingPipelineStage: () => SM, CallbackProperty: () => Nd, Camera: () => oo, CameraEventAggregator: () => SV, CameraEventType: () => wi, CameraFlightPath: () => gV, Cartesian2: () => H, Cartesian3: () => h, Cartesian4: () => se, Cartographic: () => he, CartographicGeocoderService: () => B3, CatmullRomSpline: () => gde, Cesium3DContentGroup: () => kC, Cesium3DTile: () => hw, Cesium3DTileBatchTable: () => Xp, Cesium3DTileColorBlendMode: () => _l, Cesium3DTileContent: () => Bme, Cesium3DTileContentFactory: () => Ex, Cesium3DTileContentState: () => To, Cesium3DTileContentType: () => ws, Cesium3DTileFeature: () => xs, Cesium3DTileFeatureTable: () => Yd, Cesium3DTileOptimizationHint: () => Pf, Cesium3DTileOptimizations: () => uF, Cesium3DTilePass: () => Qo, Cesium3DTilePassState: () => ad, Cesium3DTilePointFeature: () => S_, Cesium3DTileRefine: () => vr, Cesium3DTileStyle: () => xE, Cesium3DTileStyleEngine: () => _F, Cesium3DTilesInspector: () => v4, Cesium3DTilesInspectorViewModel: () => w4, Cesium3DTileset: () => Su, Cesium3DTilesetCache: () => dF, Cesium3DTilesetGraphics: () => OC, Cesium3DTilesetHeatmap: () => mF, Cesium3DTilesetMetadata: () => lF, Cesium3DTilesetMostDetailedTraversal: () => ew, Cesium3DTilesetStatistics: () => V_, Cesium3DTilesetTraversal: () => km, Cesium3DTilesetVisualizer: () => CF, CesiumInspector: () => O4, CesiumInspectorViewModel: () => P4, CesiumTerrainProvider: () => F3, CesiumWidget: () => H4, Check: () => rl, CheckerboardMaterialProperty: () => yw, CircleEmitter: () => DV, CircleGeometry: () => bde, CircleOutlineGeometry: () => Sde, ClassificationModelDrawCommand: () => QR, ClassificationPipelineStage: () => TM, ClassificationPrimitive: () => Ib, ClassificationType: () => Ln, ClearCommand: () => ti, ClippingPlane: () => KC, ClippingPlaneCollection: () => Ks, Clock: () => sh, ClockRange: () => Br, ClockStep: () => uo, ClockViewModel: () => f4, CloudCollection: () => kme, CloudType: () => qD, Color: () => U, ColorBlendMode: () => oc, ColorGeometryInstanceAttribute: () => Bt, ColorMaterialProperty: () => Ot, Command: () => p0e, ComponentDatatype: () => Y, Composite3DTileContent: () => IB, CompositeEntityCollection: () => noe, CompositeMaterialProperty: () => Tw, CompositePositionProperty: () => $s, CompositeProperty: () => cc, CompressedTextureBuffer: () => jP, ComputeCommand: () => pf, ComputeEngine: () => y3, ConditionsExpression: () => wV, ConeEmitter: () => Ume, ConstantPositionProperty: () => Mc, ConstantProperty: () => Yn, ConstantSpline: () => zR, ContentMetadata: () => YL, Context: () => E3, ContextLimits: () => Ut, CoplanarPolygonGeometry: () => mN, CoplanarPolygonGeometryLibrary: () => O_, CoplanarPolygonOutlineGeometry: () => Rf, CornerType: () => Ti, CorridorGeometry: () => jx, CorridorGeometryLibrary: () => vi, CorridorGeometryUpdater: () => IF, CorridorGraphics: () => wC, CorridorOutlineGeometry: () => PF, Credit: () => Xt, CreditDisplay: () => qV, CubeMap: () => Xa, CubeMapFace: () => Qh, CubicRealPolynomial: () => lC, CullFace: () => gi, CullingVolume: () => Xs, CumulusCloud: () => Ju, CustomDataSource: () => LF, CustomHeightmapTerrainProvider: () => Dde, CustomShader: () => C0e, CustomShaderMode: () => C_, CustomShaderPipelineStage: () => BM, CustomShaderTranslucencyMode: () => X0, CylinderGeometry: () => FF, CylinderGeometryLibrary: () => Yx, CylinderGeometryUpdater: () => VF, CylinderGraphics: () => DC, CylinderOutlineGeometry: () => NF, CzmlDataSource: () => KF, DataSource: () => Or, DataSourceClock: () => ah, DataSourceCollection: () => ZF, DataSourceDisplay: () => UN, DebugAppearance: () => mpe, DebugCameraPrimitive: () => dp, DebugInspector: () => XV, DebugModelMatrixPrimitive: () => JV, DefaultProxy: () => Pde, DepthFunction: () => Ja, DepthPlane: () => ek, DequantizationPipelineStage: () => RM, DerivedCommand: () => zg, DeveloperError: () => ye, DeviceOrientationCameraController: () => nk, DirectionalLight: () => Cpe, DiscardEmptyTileImagePolicy: () => zD, DiscardMissingTileImagePolicy: () => uV, DistanceDisplayCondition: () => bt, DistanceDisplayConditionGeometryInstanceAttribute: () => Mn, DoubleEndedPriorityQueue: () => Bde, DoublyLinkedList: () => fF, DracoLoader: () => i_, DrawCommand: () => $e, DynamicGeometryBatch: () => aT, DynamicGeometryUpdater: () => $n, EarthOrientationParameters: () => MP, EarthOrientationParametersSample: () => a0, EasingFunction: () => Mr, EllipseGeometry: () => Yc, EllipseGeometryLibrary: () => Dl, EllipseGeometryUpdater: () => sN, EllipseGraphics: () => vC, EllipseOutlineGeometry: () => Mu, Ellipsoid: () => ie, EllipsoidGeodesic: () => mf, EllipsoidGeometry: () => Bs, EllipsoidGeometryUpdater: () => aN, EllipsoidGraphics: () => PC, EllipsoidOutlineGeometry: () => bu, EllipsoidPrimitive: () => ok, EllipsoidRhumbLine: () => ga, EllipsoidSurfaceAppearance: () => Tpe, EllipsoidTangentPlane: () => pa, EllipsoidTerrainProvider: () => Pg, EllipsoidalOccluder: () => j_, Empty3DTileContent: () => aw, EncodedCartesian3: () => Vn, Entity: () => Xo, EntityCluster: () => Iu, EntityCollection: () => vs, EntityView: () => GN, Event: () => _e, EventHelper: () => Pr, Expression: () => gf, ExpressionNodeType: () => ft, ExtrapolationType: () => Ou, FeatureDetection: () => Nt, FeatureIdPipelineStage: () => Y0, Fog: () => ck, ForEach: () => De, FrameRateMonitor: () => lk, FrameState: () => uk, Framebuffer: () => Js, FramebufferManager: () => si, FrustumCommands: () => fk, FrustumGeometry: () => fE, FrustumOutlineGeometry: () => H3, Fullscreen: () => hr, FullscreenButton: () => L4, FullscreenButtonViewModel: () => R4, GeoJsonDataSource: () => k2, GeoJsonLoader: () => LR, GeocodeType: () => qy, Geocoder: () => V4, GeocoderService: () => Vde, GeocoderViewModel: () => F4, GeographicProjection: () => _i, GeographicTilingScheme: () => Hi, Geometry: () => st, Geometry3DTileContent: () => UB, GeometryAttribute: () => be, GeometryAttributes: () => sn, GeometryFactory: () => Ude, GeometryInstance: () => At, GeometryInstanceAttribute: () => Qa, GeometryOffsetAttribute: () => Qt, GeometryPipeline: () => Bn, GeometryPipelineStage: () => FM, GeometryType: () => af, GeometryUpdater: () => ei, GeometryVisualizer: () => IN, GetFeatureInfoFormat: () => vE, Globe: () => Uk, GlobeDepth: () => zk, GlobeSurfaceShaderSet: () => pk, GlobeSurfaceTile: () => fd, GlobeSurfaceTileProvider: () => Pk, GlobeTranslucency: () => Ik, GlobeTranslucencyFramebuffer: () => Hk, GlobeTranslucencyState: () => Gk, GltfBufferViewLoader: () => cS, GltfDracoLoader: () => lS, GltfImageLoader: () => uS, GltfIndexBufferLoader: () => fS, GltfJsonLoader: () => hS, GltfLoader: () => h_, GltfLoaderUtil: () => Al, GltfStructuralMetadataLoader: () => bR, GltfTextureLoader: () => mS, GltfVertexBufferLoader: () => pS, GoogleEarthEnterpriseImageryProvider: () => y_e, GoogleEarthEnterpriseMapsProvider: () => kV, GoogleEarthEnterpriseMetadata: () => Ih, GoogleEarthEnterpriseTerrainData: () => MD, GoogleEarthEnterpriseTerrainProvider: () => Kde, GoogleEarthEnterpriseTileInformation: () => W3, GpxDataSource: () => n3, GregorianDate: () => Sp, GridImageryProvider: () => A_e, GridMaterialProperty: () => Bw, GroundGeometryUpdater: () => zn, GroundPolylineGeometry: () => xC, GroundPolylinePrimitive: () => Bd, GroundPrimitive: () => Rc, GroupMetadata: () => mw, HeadingPitchRange: () => ku, HeadingPitchRoll: () => lf, Heap: () => PP, HeightReference: () => ze, HeightmapEncoding: () => rp, HeightmapTerrainData: () => Ma, HeightmapTessellator: () => vD, HermitePolynomialApproximation: () => UF, HermiteSpline: () => H0, HilbertOrder: () => oS, HomeButton: () => z4, HomeButtonViewModel: () => k4, HorizontalOrigin: () => ai, I3dmLoader: () => UR, I3dmParser: () => NR, Iau2000Orientation: () => X3, Iau2006XysData: () => FP, Iau2006XysSample: () => tC, IauOrientationAxes: () => K3, IauOrientationParameters: () => Y3, ImageBasedLighting: () => VC, ImageBasedLightingPipelineStage: () => oM, ImageMaterialProperty: () => S0, Imagery: () => av, ImageryLayer: () => Qu, ImageryLayerCollection: () => Bk, ImageryLayerFeatureInfo: () => Oh, ImageryProvider: () => tl, ImageryState: () => ii, Implicit3DTileContent: () => CS, ImplicitAvailabilityBitstream: () => rS, ImplicitMetadataView: () => sS, ImplicitSubdivisionScheme: () => kr, ImplicitSubtree: () => _R, ImplicitSubtreeMetadata: () => WB, ImplicitTileCoordinates: () => yF, ImplicitTileset: () => gF, IndexDatatype: () => Me, InfoBox: () => j4, InfoBoxViewModel: () => G4, InspectorShared: () => Zg, InstanceAttributeSemantic: () => Ur, InstancingPipelineStage: () => _M, InterpolationAlgorithm: () => fhe, InterpolationType: () => qd, Intersect: () => Kt, IntersectionTests: () => Gi, Intersections2D: () => Dg, Interval: () => Dc, InvertClassification: () => pv, Ion: () => Sh, IonGeocoderService: () => Z3, IonImageryProvider: () => Vg, IonResource: () => wh, IonWorldImageryStyle: () => kg, Iso8601: () => ke, JobScheduler: () => jk, JobType: () => Ca, JsonMetadataTable: () => f_, JulianDate: () => $, KTX2Transcoder: () => qP, KeyboardEventModifier: () => oa, KmlCamera: () => i3, KmlDataSource: () => _3, KmlLookAt: () => o3, KmlTour: () => s3, KmlTourFlyTo: () => c3, KmlTourWait: () => l3, Label: () => ty, LabelCollection: () => Lm, LabelGraphics: () => Rd, LabelStyle: () => Fo, LabelVisualizer: () => ON, LagrangePolynomialApproximation: () => zF, LeapSecond: () => Bi, Light: () => x_e, LightingModel: () => Im, LightingPipelineStage: () => VM, LinearApproximation: () => Zx, LinearSpline: () => z0, ManagedArray: () => su, MapMode2D: () => Ul, MapProjection: () => hhe, MapboxImageryProvider: () => UV, MapboxStyleImageryProvider: () => E_e, Material: () => Ki, MaterialAppearance: () => eo, MaterialPipelineStage: () => UM, MaterialProperty: () => Yo, Math: () => I, Matrix2: () => qi, Matrix3: () => Q, Matrix4: () => F, MetadataClass: () => Wd, MetadataClassProperty: () => M0, MetadataComponentType: () => wn, MetadataEntity: () => Rn, MetadataEnum: () => hR, MetadataEnumValue: () => dR, MetadataPipelineStage: () => bf, MetadataSchema: () => jd, MetadataSchemaLoader: () => _S, MetadataSemantic: () => gR, MetadataTable: () => Af, MetadataTableProperty: () => qB, MetadataType: () => Dn, MipmapHint: () => $h, Model: () => Jd, Model3DTileContent: () => Om, ModelAlphaOptions: () => nL, ModelAnimation: () => jR, ModelAnimationChannel: () => WR, ModelAnimationCollection: () => YR, ModelAnimationLoop: () => ic, ModelAnimationState: () => Xd, ModelArticulation: () => aM, ModelArticulationStage: () => rM, ModelClippingPlanesPipelineStage: () => uM, ModelColorPipelineStage: () => q0, ModelComponents: () => Dt, ModelDrawCommand: () => eM, ModelFeature: () => XR, ModelFeatureTable: () => KR, ModelGraphics: () => zp, ModelLightingOptions: () => pL, ModelMatrixUpdateStage: () => gM, ModelNode: () => fM, ModelRenderResources: () => sL, ModelRuntimeNode: () => AM, ModelRuntimePrimitive: () => eL, ModelSceneGraph: () => yL, ModelSilhouettePipelineStage: () => uL, ModelSkin: () => tL, ModelSplitterPipelineStage: () => hL, ModelStatistics: () => AL, ModelType: () => ar, ModelUtility: () => tn, ModelVisualizer: () => RN, Moon: () => Xk, MorphTargetsPipelineStage: () => HM, MorphWeightSpline: () => mhe, MortonOrder: () => my, Multiple3DTileContent: () => JL, MultisampleFramebuffer: () => IR, NavigationHelpButton: () => Z4, NavigationHelpButtonViewModel: () => K4, NearFarScalar: () => wt, NeverTileDiscardPolicy: () => b_e, NodeRenderResources: () => mL, NodeStatisticsPipelineStage: () => yM, NodeTransformationProperty: () => IC, OIT: () => Jk, Occluder: () => nV, OctahedralProjectedCubeMap: () => Vd, OffsetGeometryInstanceAttribute: () => zi, OpenCageGeocoderService: () => ghe, OpenStreetMapImageryProvider: () => NE, OrderedGroundPrimitiveCollection: () => $F, OrientedBoundingBox: () => di, OrthographicFrustum: () => Zt, OrthographicOffCenterFrustum: () => wr, Packable: () => yhe, PackableForInterpolation: () => Ahe, Particle: () => yv, ParticleBurst: () => P_e, ParticleEmitter: () => O_e, ParticleSystem: () => M_e, Pass: () => xe, PassState: () => pc, PathGraphics: () => Hp, PathVisualizer: () => MN, PeliasGeocoderService: () => J3, PerInstanceColorAppearance: () => $t, PerformanceDisplay: () => jg, PerformanceWatchdog: () => X4, PerformanceWatchdogViewModel: () => q4, PerspectiveFrustum: () => mi, PerspectiveOffCenterFrustum: () => $c, PickDepth: () => eU, PickDepthFramebuffer: () => tU, PickFramebuffer: () => nU, Picking: () => uU, PickingPipelineStage: () => GM, PinBuilder: () => pg, PixelDatatype: () => Ye, PixelFormat: () => ht, Plane: () => nn, PlaneGeometry: () => uN, PlaneGeometryUpdater: () => hN, PlaneGraphics: () => EB, PlaneOutlineGeometry: () => dN, PntsLoader: () => xL, PntsParser: () => px, PointCloud: () => hU, PointCloudEyeDomeLighting: () => m_, PointCloudShading: () => bm, PointCloudStylingPipelineStage: () => jM, PointGraphics: () => BC, PointPrimitive: () => Is, PointPrimitiveCollection: () => vw, PointVisualizer: () => LN, PolygonGeometry: () => gT, PolygonGeometryLibrary: () => Un, PolygonGeometryUpdater: () => yN, PolygonGraphics: () => Md, PolygonHierarchy: () => Lc, PolygonOutlineGeometry: () => gN, PolygonPipeline: () => ni, Polyline: () => Sf, PolylineArrowMaterialProperty: () => Rw, PolylineCollection: () => D_, PolylineColorAppearance: () => Vr, PolylineDashMaterialProperty: () => Mw, PolylineGeometry: () => lg, PolylineGeometryUpdater: () => NN, PolylineGlowMaterialProperty: () => Lw, PolylineGraphics: () => ec, PolylineMaterialAppearance: () => Ys, PolylineOutlineMaterialProperty: () => Cy, PolylinePipeline: () => xi, PolylineVisualizer: () => kN, PolylineVolumeGeometry: () => AN, PolylineVolumeGeometryLibrary: () => oh, PolylineVolumeGeometryUpdater: () => xN, PolylineVolumeGraphics: () => RC, PolylineVolumeOutlineGeometry: () => CN, PositionProperty: () => Up, PositionPropertyArray: () => Y_, PostProcessStage: () => ho, PostProcessStageCollection: () => RU, PostProcessStageComposite: () => ol, PostProcessStageLibrary: () => md, PostProcessStageSampleMode: () => tf, PostProcessStageTextureCache: () => GE, Primitive: () => xn, PrimitiveCollection: () => wl, PrimitiveLoadPlan: () => ex, PrimitiveOutlineGenerator: () => $C, PrimitiveOutlinePipelineStage: () => XM, PrimitivePipeline: () => gC, PrimitiveRenderResources: () => _L, PrimitiveState: () => mr, PrimitiveStatisticsPipelineStage: () => KM, PrimitiveType: () => Oe, ProjectionPicker: () => tz, ProjectionPickerViewModel: () => $4, Property: () => j, PropertyArray: () => Fw, PropertyAttribute: () => ZC, PropertyAttributeProperty: () => xR, PropertyBag: () => hl, PropertyTable: () => Vc, PropertyTexture: () => JC, PropertyTextureProperty: () => CR, ProviderViewModel: () => _s, Proxy: () => The, QuadraticRealPolynomial: () => Pc, QuadtreeOccluders: () => Rk, QuadtreePrimitive: () => kk, QuadtreeTile: () => Lk, QuadtreeTileLoadState: () => ks, QuadtreeTileProvider: () => dge, QuantizedMeshTerrainData: () => sE, QuarticRealPolynomial: () => A1, Quaternion: () => Be, QuaternionSpline: () => GR, Queue: () => ry, Ray: () => En, Rectangle: () => ce, RectangleCollisionChecker: () => wT, RectangleGeometry: () => TT, RectangleGeometryLibrary: () => ms, RectangleGeometryUpdater: () => TN, RectangleGraphics: () => Ld, RectangleOutlineGeometry: () => Ox, ReferenceFrame: () => Ji, ReferenceProperty: () => K_, RenderState: () => Ve, Renderbuffer: () => hu, RenderbufferFormat: () => Uc, Request: () => jo, RequestErrorEvent: () => Kh, RequestScheduler: () => Ya, RequestState: () => ri, RequestType: () => Xr, Resource: () => Pe, ResourceCache: () => ao, ResourceCacheKey: () => Cl, ResourceCacheStatistics: () => pR, ResourceLoader: () => Zi, ResourceLoaderState: () => kt, Rotation: () => Vf, RuntimeError: () => fe, S2Cell: () => e_, SDFSettings: () => bs, SampledPositionProperty: () => ea, SampledProperty: () => Bu, Sampler: () => dn, ScaledPositionProperty: () => ip, Scene: () => JU, SceneFramebuffer: () => VE, SceneMode: () => ee, SceneMode2DPipelineStage: () => JM, SceneModePicker: () => rz, SceneModePickerViewModel: () => iz, SceneTransforms: () => ji, SceneTransitioner: () => LU, ScreenSpaceCameraController: () => WU, ScreenSpaceEventHandler: () => Xu, ScreenSpaceEventType: () => pn, SelectedFeatureIdPipelineStage: () => K0, SelectionIndicator: () => lz, SelectionIndicatorViewModel: () => az, ShaderBuilder: () => rL, ShaderCache: () => A3, ShaderDestination: () => Te, ShaderFunction: () => oL, ShaderProgram: () => qt, ShaderSource: () => Ue, ShaderStruct: () => iL, ShadowMap: () => Yg, ShadowMapShader: () => _p, ShadowMode: () => hn, ShadowVolumeAppearance: () => ou, ShowGeometryInstanceAttribute: () => fn, Simon1994PlanetaryPositions: () => zy, SimplePolylineGeometry: () => Vhe, SingleTileImageryProvider: () => zV, SkinningPipelineStage: () => QM, SkyAtmosphere: () => $U, SkyBox: () => i4, SphereEmitter: () => s0e, SphereGeometry: () => khe, SphereOutlineGeometry: () => L_, Spherical: () => HF, Spline: () => Qi, SplitDirection: () => zc, Splitter: () => bv, StaticGeometryColorBatch: () => Wf, StaticGeometryPerMaterialBatch: () => qf, StaticGroundGeometryColorBatch: () => Kw, StaticGroundGeometryPerMaterialBatch: () => SN, StaticGroundPolylinePerMaterialBatch: () => VN, StaticOutlineGeometryBatch: () => Jw, StencilConstants: () => vt, StencilFunction: () => Fn, StencilOperation: () => lt, SteppedSpline: () => HR, StripeMaterialProperty: () => Nw, StripeOrientation: () => ch, StructuralMetadata: () => ba, StyleCommandsNeeded: () => Kd, StyleExpression: () => a0e, Sun: () => a4, SunLight: () => Eg, SunPostProcess: () => YU, SupportedImageFormats: () => DR, SvgPathBindingHandler: () => lV, TaskProcessor: () => yi, TerrainData: () => Eh, TerrainEncoding: () => _c, TerrainExaggeration: () => Ic, TerrainFillMesh: () => uv, TerrainMesh: () => id, TerrainOffsetProperty: () => FC, TerrainProvider: () => Hr, TerrainQuantization: () => Fs, TerrainState: () => fo, Texture: () => Rt, TextureAtlas: () => Q0, TextureCache: () => C3, TextureMagnificationFilter: () => Xi, TextureManager: () => h4, TextureMinificationFilter: () => ln, TextureUniform: () => x0e, TextureWrap: () => In, TileAvailability: () => bh, TileBoundingRegion: () => Bf, TileBoundingS2Cell: () => oF, TileBoundingSphere: () => F_, TileBoundingVolume: () => c0e, TileCoordinatesImageryProvider: () => c4, TileDiscardPolicy: () => l0e, TileEdge: () => un, TileImagery: () => cv, TileMapServiceImageryProvider: () => tA, TileMetadata: () => XL, TileOrientedBoundingBox: () => Mf, TileProviderError: () => Gn, TileReplacementQueue: () => Nk, TileSelectionResult: () => qn, TileState: () => u0e, Tileset3DTileContent: () => EL, TilesetMetadata: () => cF, TilesetPipelineStage: () => nM, TilingScheme: () => Uhe, TimeConstants: () => jn, TimeDynamicImagery: () => PE, TimeDynamicPointCloud: () => Vv, TimeInterval: () => yn, TimeIntervalCollection: () => Ir, TimeIntervalCollectionPositionProperty: () => Z_, TimeIntervalCollectionProperty: () => Q_, TimeStandard: () => Hn, Timeline: () => dz, TimelineHighlightRange: () => uz, TimelineTrack: () => fz, Tipsify: () => eB, ToggleButtonViewModel: () => TA, Tonemapper: () => pA, Transforms: () => It, TranslationRotationScale: () => D0, TranslucentTileClassification: () => rU, TridiagonalSystemSolver: () => vS, TrustedServers: () => fb, TweenCollection: () => WE, UniformState: () => T3, UniformType: () => Uv, UrlTemplateImageryProvider: () => Ua, VERSION: () => ymt, VRButton: () => _z, VRButtonViewModel: () => mz, VRTheWorldTerrainProvider: () => Ghe, VaryingType: () => T0e, Vector3DTileBatch: () => mm, Vector3DTileClampedPolylines: () => zL, Vector3DTileContent: () => GL, Vector3DTileGeometry: () => Jp, Vector3DTilePoints: () => FL, Vector3DTilePolygons: () => NL, Vector3DTilePolylines: () => Tx, Vector3DTilePrimitive: () => zC, VelocityOrientationProperty: () => WF, VelocityVectorProperty: () => rT, VertexArray: () => Qn, VertexArrayFacade: () => E_, VertexAttributeSemantic: () => xt, VertexFormat: () => we, VerticalOrigin: () => Sn, VideoSynchronizer: () => zhe, View: () => UE, Viewer: () => eye, ViewportQuad: () => m0e, Visibility: () => lr, Visualizer: () => Sfe, VulkanConstants: () => Whe, WallGeometry: () => DN, WallGeometryLibrary: () => IT, WallGeometryUpdater: () => PN, WallGraphics: () => Gp, WallOutlineGeometry: () => vN, WebGLConstants: () => te, WebMapServiceImageryProvider: () => GV, WebMapTileServiceImageryProvider: () => WV, WebMercatorProjection: () => Ri, WebMercatorTilingScheme: () => Gr, WindingOrder: () => Kr, WireframeIndexGenerator: () => LS, WireframePipelineStage: () => $M, _shadersAcesTonemappingStage: () => mU, _shadersAdditiveBlend: () => jU, _shadersAdjustTranslucentFS: () => gv, _shadersAllMaterialAppearanceFS: () => kP, _shadersAllMaterialAppearanceVS: () => UP, _shadersAmbientOcclusionGenerate: () => pU, _shadersAmbientOcclusionModulate: () => _U, _shadersAspectRampMaterial: () => ZP, _shadersAtmosphereCommon: () => Hg, _shadersBasicMaterialAppearanceFS: () => zP, _shadersBasicMaterialAppearanceVS: () => HP, _shadersBillboardCollectionFS: () => bL, _shadersBillboardCollectionVS: () => SL, _shadersBlackAndWhite: () => gU, _shadersBloomComposite: () => yU, _shadersBrdfLutGeneratorFS: () => pV, _shadersBrightPass: () => qU, _shadersBrightness: () => AU, _shadersBumpMapMaterial: () => QP, _shadersCPUStylingStageFS: () => bM, _shadersCPUStylingStageVS: () => EM, _shadersCheckerboardMaterial: () => $P, _shadersCloudCollectionFS: () => vV, _shadersCloudCollectionVS: () => PV, _shadersCloudNoiseFS: () => IV, _shadersCloudNoiseVS: () => OV, _shadersCompareAndPackTranslucentDepth: () => oU, _shadersCompositeOITFS: () => Kk, _shadersCompositeTranslucentClassification: () => kE, _shadersContrastBias: () => CU, _shadersCustomShaderStageFS: () => DM, _shadersCustomShaderStageVS: () => wM, _shadersCzmBuiltins: () => uC, _shadersDepthOfField: () => xU, _shadersDepthPlaneFS: () => ZV, _shadersDepthPlaneVS: () => QV, _shadersDepthView: () => TU, _shadersDepthViewPacked: () => sye, _shadersDotMaterial: () => e1, _shadersEdgeDetection: () => EU, _shadersElevationBandMaterial: () => t1, _shadersElevationContourMaterial: () => n1, _shadersElevationRampMaterial: () => i1, _shadersEllipsoidFS: () => ov, _shadersEllipsoidSurfaceAppearanceFS: () => rk, _shadersEllipsoidSurfaceAppearanceVS: () => sk, _shadersEllipsoidVS: () => rv, _shadersFXAA: () => SU, _shadersFXAA3_11: () => OU, _shadersFadeMaterial: () => o1, _shadersFeatureIdStageFS: () => vM, _shadersFeatureIdStageVS: () => PM, _shadersFilmicTonemapping: () => bU, _shadersGaussianBlur1D: () => hA, _shadersGeometryStageFS: () => MM, _shadersGeometryStageVS: () => LM, _shadersGlobeFS: () => hk, _shadersGlobeVS: () => mk, _shadersGridMaterial: () => r1, _shadersGroundAtmosphere: () => sv, _shadersHSBToRGB: () => ZI, _shadersHSLToRGB: () => QI, _shadersImageBasedLightingStageFS: () => iM, _shadersInstancingStageCommon: () => dM, _shadersInstancingStageVS: () => hM, _shadersLegacyInstancingStageVS: () => mM, _shadersLensFlare: () => wU, _shadersLightingStageFS: () => NM, _shadersMaterialStageFS: () => kM, _shadersMetadataStageFS: () => IM, _shadersMetadataStageVS: () => OM, _shadersModelClippingPlanesStageFS: () => lM, _shadersModelColorStageFS: () => cM, _shadersModelFS: () => JR, _shadersModelSilhouetteStageFS: () => aL, _shadersModelSilhouetteStageVS: () => cL, _shadersModelSplitterStageFS: () => fL, _shadersModelVS: () => ZR, _shadersModifiedReinhardTonemapping: () => DU, _shadersMorphTargetsStageVS: () => zM, _shadersNightVision: () => vU, _shadersNormalMapMaterial: () => s1, _shadersOctahedralProjectionAtlasFS: () => SB, _shadersOctahedralProjectionFS: () => wB, _shadersOctahedralProjectionVS: () => DB, _shadersPassThrough: () => Wl, _shadersPassThroughDepth: () => oA, _shadersPerInstanceColorAppearanceFS: () => p1, _shadersPerInstanceColorAppearanceVS: () => _1, _shadersPerInstanceFlatColorAppearanceFS: () => aC, _shadersPerInstanceFlatColorAppearanceVS: () => g1, _shadersPointCloudEyeDomeLighting: () => OR, _shadersPointCloudStylingStageVS: () => WM, _shadersPointPrimitiveCollectionFS: () => gy, _shadersPointPrimitiveCollectionVS: () => RF, _shadersPolylineArrowMaterial: () => a1, _shadersPolylineColorAppearanceVS: () => xB, _shadersPolylineCommon: () => ru, _shadersPolylineDashMaterial: () => c1, _shadersPolylineFS: () => TC, _shadersPolylineGlowMaterial: () => l1, _shadersPolylineMaterialAppearanceVS: () => TB, _shadersPolylineOutlineMaterial: () => u1, _shadersPolylineShadowVolumeFS: () => gB, _shadersPolylineShadowVolumeMorphFS: () => yB, _shadersPolylineShadowVolumeMorphVS: () => AB, _shadersPolylineShadowVolumeVS: () => CB, _shadersPolylineVS: () => OL, _shadersPrimitiveOutlineStageFS: () => YM, _shadersPrimitiveOutlineStageVS: () => qM, _shadersRGBToHSB: () => bO, _shadersRGBToHSL: () => SO, _shadersRGBToXYZ: () => wO, _shadersReinhardTonemapping: () => PU, _shadersReprojectWebMercatorFS: () => _k, _shadersReprojectWebMercatorVS: () => gk, _shadersRimLightingMaterial: () => f1, _shadersSelectedFeatureIdStageCommon: () => RS, _shadersShadowVolumeAppearanceFS: () => Pb, _shadersShadowVolumeAppearanceVS: () => JO, _shadersShadowVolumeFS: () => _0, _shadersSilhouette: () => IU, _shadersSkinningStageVS: () => ZM, _shadersSkyAtmosphereCommon: () => Rv, _shadersSkyAtmosphereFS: () => ZU, _shadersSkyAtmosphereVS: () => QU, _shadersSkyBoxFS: () => e4, _shadersSkyBoxVS: () => t4, _shadersSlopeRampMaterial: () => d1, _shadersStripeMaterial: () => h1, _shadersSunFS: () => o4, _shadersSunTextureFS: () => r4, _shadersSunVS: () => s4, _shadersTexturedMaterialAppearanceFS: () => GP, _shadersTexturedMaterialAppearanceVS: () => WP, _shadersVector3DTileClampedPolylinesFS: () => UL, _shadersVector3DTileClampedPolylinesVS: () => kL, _shadersVector3DTilePolylinesVS: () => VL, _shadersVectorTileVS: () => nS, _shadersViewportQuadFS: () => l4, _shadersViewportQuadVS: () => QT, _shadersWater: () => m1, _shadersXYZToRGB: () => KO, _shadersacesTonemapping: () => xI, _shadersalphaWeight: () => TI, _shadersantialias: () => EI, _shadersapproximateSphericalCoordinates: () => bI, _shadersbackFacing: () => SI, _shadersbranchFreeTernary: () => wI, _shaderscascadeColor: () => DI, _shaderscascadeDistance: () => vI, _shaderscascadeMatrix: () => PI, _shaderscascadeWeights: () => II, _shaderscolumbusViewMorph: () => OI, _shaderscomputePosition: () => BI, _shaderscosineAndSine: () => RI, _shadersdecompressTextureCoordinates: () => MI, _shadersdefaultPbrMaterial: () => LI, _shadersdegreesPerRadian: () => P1, _shadersdepthClamp: () => FI, _shadersdepthRange: () => I1, _shadersdepthRangeStruct: () => dI, _shaderseastNorthUpToEyeCoordinates: () => NI, _shadersellipsoidContainsPoint: () => VI, _shadersellipsoidWgs84TextureCoordinates: () => kI, _shadersepsilon1: () => O1, _shadersepsilon2: () => B1, _shadersepsilon3: () => R1, _shadersepsilon4: () => M1, _shadersepsilon5: () => L1, _shadersepsilon6: () => F1, _shadersepsilon7: () => N1, _shadersequalsEpsilon: () => UI, _shaderseyeOffset: () => zI, _shaderseyeToWindowCoordinates: () => HI, _shadersfastApproximateAtan: () => GI, _shadersfog: () => WI, _shadersgammaCorrect: () => jI, _shadersgeodeticSurfaceNormal: () => qI, _shadersgetDefaultMaterial: () => YI, _shadersgetLambertDiffuse: () => XI, _shadersgetSpecular: () => KI, _shadersgetWaterNoise: () => JI, _shadershue: () => $I, _shadersinfinity: () => V1, _shadersinverseGamma: () => eO, _shadersisEmpty: () => tO, _shadersisFull: () => nO, _shaderslatitudeToWebMercatorFraction: () => iO, _shaderslineDistance: () => rO, _shaderslinearToSrgb: () => oO, _shadersluminance: () => sO, _shadersmaterial: () => hI, _shadersmaterialInput: () => mI, _shadersmetersPerPixel: () => aO, _shadersmodelMaterial: () => pI, _shadersmodelToWindowCoordinates: () => cO, _shadersmodelVertexOutput: () => _I, _shadersmultiplyWithColorBalance: () => lO, _shadersnearFarScalar: () => uO, _shadersoctDecode: () => fO, _shadersoneOverPi: () => k1, _shadersoneOverTwoPi: () => U1, _shaderspackDepth: () => dO, _shaderspassCesium3DTile: () => z1, _shaderspassCesium3DTileClassification: () => H1, _shaderspassCesium3DTileClassificationIgnoreShow: () => G1, _shaderspassClassification: () => W1, _shaderspassCompute: () => j1, _shaderspassEnvironment: () => q1, _shaderspassGlobe: () => Y1, _shaderspassOpaque: () => X1, _shaderspassOverlay: () => K1, _shaderspassTerrainClassification: () => J1, _shaderspassTranslucent: () => Z1, _shaderspbrLighting: () => hO, _shaderspbrMetallicRoughnessMaterial: () => mO, _shaderspbrParameters: () => gI, _shaderspbrSpecularGlossinessMaterial: () => pO, _shadersphong: () => _O, _shaderspi: () => Q1, _shaderspiOverFour: () => $1, _shaderspiOverSix: () => eI, _shaderspiOverThree: () => tI, _shaderspiOverTwo: () => nI, _shadersplaneDistance: () => gO, _shaderspointAlongRay: () => yO, _shadersradiansPerDegree: () => iI, _shadersray: () => yI, _shadersrayEllipsoidIntersectionInterval: () => AO, _shadersraySegment: () => AI, _shadersraySphereIntersectionInterval: () => CO, _shadersreadDepth: () => xO, _shadersreadNonPerspective: () => TO, _shadersreverseLogDepth: () => EO, _shadersround: () => DO, _shaderssampleOctahedralProjection: () => vO, _shaderssaturation: () => PO, _shaderssceneMode2D: () => oI, _shaderssceneMode3D: () => rI, _shaderssceneModeColumbusView: () => sI, _shaderssceneModeMorphing: () => aI, _shadersshadowDepthCompare: () => IO, _shadersshadowParameters: () => CI, _shadersshadowVisibility: () => OO, _shaderssignNotZero: () => BO, _shaderssolarRadius: () => cI, _shaderssphericalHarmonics: () => RO, _shaderssrgbToLinear: () => MO, _shaderstangentToEyeSpaceMatrix: () => LO, _shadersthreePiOver2: () => lI, _shaderstransformPlane: () => FO, _shaderstranslateRelativeToEye: () => NO, _shaderstranslucentPhong: () => VO, _shaderstranspose: () => kO, _shaderstwoPi: () => uI, _shadersunpackDepth: () => UO, _shadersunpackFloat: () => zO, _shadersunpackUint: () => HO, _shadersvalueTransform: () => GO, _shadersvertexLogDepth: () => WO, _shaderswebMercatorMaxLatitude: () => fI, _shaderswindowToEyeCoordinates: () => jO, _shaderswriteDepthClamp: () => qO, _shaderswriteLogDepth: () => YO, _shaderswriteNonPerspective: () => XO, addBuffer: () => iR, addDefaults: () => YB, addExtensionsRequired: () => eR, addExtensionsUsed: () => Cf, addPipelineExtras: () => F0, addToArray: () => us, appendForwardSlash: () => SP, arrayRemoveDuplicates: () => _o, barycentricCoordinates: () => dC, binarySearch: () => Wo, buildDrawCommand: () => tM, buildModuleUrl: () => Jt, cancelAnimationFrame: () => mde, clone: () => tt, combine: () => yt, computeFlyToLocationForRectangle: () => TE, createBillboardPointCallback: () => gx, createCommand: () => An, createDefaultImageryProviderViewModels: () => g4, createDefaultTerrainProviderViewModels: () => y4, createElevationBandMaterial: () => Wme, createGuid: () => Nn, createMaterialPropertyDescriptor: () => wo, createOsmBuildings: () => jme, createPropertyDescriptor: () => ae, createRawPropertyDescriptor: () => dl, createTangentSpaceDebugPrimitive: () => qme, createTaskProcessorWorker: () => aye, createUniform: () => S1, createUniformArray: () => w1, createWorldImagery: () => Ug, createWorldTerrain: () => V3, decodeGoogleEarthEnterpriseData: () => k3, decodeVectorPolylinePositions: () => HL, defaultValue: () => y, defer: () => js, defined: () => l, deprecationWarning: () => Jr, destroyObject: () => le, exportKml: () => Ple, findAccessorMinMax: () => qC, findContentMetadata: () => bx, findGroupMetadata: () => Sx, findTileMetadata: () => KL, forEachTextureInMaterial: () => dS, formatError: () => ap, freezeRenderState: () => eK, getAbsoluteUri: () => vp, getAccessorByteStride: () => yl, getBaseUri: () => wP, getBinaryAccessor: () => cu, getClipAndStyleCode: () => dk, getClippingFunction: () => IE, getComponentReader: () => s_, getElement: () => vn, getExtensionFromUri: () => jA, getFilenameFromUri: () => q_, getImageFromTypedArray: () => G3, getImagePixels: () => Ad, getJsonFromTypedArray: () => Ko, getMagic: () => zd, getStringFromTypedArray: () => pl, getTimestamp: () => Ei, hasExtension: () => Mi, heightReferenceOnEntityPropertyChanged: () => Wp, isBitSet: () => Ac, isBlobUri: () => qA, isCrossOriginUrl: () => YA, isDataUri: () => Pp, isLeapYear: () => wp, knockout: () => Ae, knockout_3_5_1: () => _E, knockout_es5: () => cV, loadAndExecuteScript: () => XA, loadCubeMap: () => b3, loadImageFromTypedArray: () => WC, loadKTX2: () => ul, mergeSort: () => Xy, modernizeShader: () => v1, moveTechniqueRenderStates: () => $B, moveTechniquesToExtension: () => tR, numberOfComponentsForType: () => uu, objectToQuery: () => KA, oneTimeWarning: () => Pt, parseBatchTable: () => p_, parseBoundingVolumeSemantics: () => yR, parseFeatureMetadataLegacy: () => ER, parseGlb: () => JB, parseResponseHeaders: () => vP, parseStructuralMetadata: () => TR, pointInsideTriangle: () => Che, preprocess3DTileContent: () => wx, queryToObject: () => $l, readAccessorPacked: () => oR, removeExtension: () => YC, removeExtensionsRequired: () => KB, removeExtensionsUsed: () => jC, removePipelineExtras: () => QB, removeUnusedElements: () => nR, requestAnimationFrame: () => Ehe, resizeImageToNextPowerOfTwo: () => V0, sampleTerrain: () => BN, sampleTerrainMostDetailed: () => rg, scaleToGeodeticSurface: () => NA, subdivideArray: () => ZO, subscribeAndEvaluate: () => aa, updateAccessorComponentTypes: () => sR, updateVersion: () => uR, usesExtension: () => pr, viewerCesium3DTilesInspectorMixin: () => tye, viewerCesiumInspectorMixin: () => nye, viewerDragDropMixin: () => oye, viewerPerformanceWatchdogMixin: () => rye, webGLConstantToGlslType: () => jhe, wrapFunction: () => aV, writeTextToCanvas: () => Ax }); function Xq(e, t) { return e ?? t } Xq.EMPTY_OBJECT = Object.freeze({}); var y = Xq; function Eye(e) { return e != null } var l = Eye; function o0(e) { this.name = "DeveloperError", this.message = e; let t; try { throw new Error } catch (n) { t = n.stack } this.stack = t } l(Object.create) && (o0.prototype = Object.create(Error.prototype), o0.prototype.constructor = o0); o0.prototype.toString = function () {
        let e = `${this.name}: ${this.message}`; return l(this.stack) && (e += `
${this.stack.toString()}`), e
    }; o0.throwInstantiationError = function () { throw new o0("This function defines an interface and should not be called directly.") }; var ye = o0; var Yr = {}; Yr.typeOf = {}; function bye(e) { return `${e} is required, actual value was undefined` } function LA(e, t, n) { return `Expected ${n} to be typeof ${t}, actual typeof was ${e}` } Yr.defined = function (e, t) { if (!l(t)) throw new ye(bye(e)) }; Yr.typeOf.func = function (e, t) { if (typeof t != "function") throw new ye(LA(typeof t, "function", e)) }; Yr.typeOf.string = function (e, t) { if (typeof t != "string") throw new ye(LA(typeof t, "string", e)) }; Yr.typeOf.number = function (e, t) { if (typeof t != "number") throw new ye(LA(typeof t, "number", e)) }; Yr.typeOf.number.lessThan = function (e, t, n) { if (Yr.typeOf.number(e, t), t >= n) throw new ye(`Expected ${e} to be less than ${n}, actual value was ${t}`) }; Yr.typeOf.number.lessThanOrEquals = function (e, t, n) { if (Yr.typeOf.number(e, t), t > n) throw new ye(`Expected ${e} to be less than or equal to ${n}, actual value was ${t}`) }; Yr.typeOf.number.greaterThan = function (e, t, n) { if (Yr.typeOf.number(e, t), t <= n) throw new ye(`Expected ${e} to be greater than ${n}, actual value was ${t}`) }; Yr.typeOf.number.greaterThanOrEquals = function (e, t, n) { if (Yr.typeOf.number(e, t), t < n) throw new ye(`Expected ${e} to be greater than or equal to ${n}, actual value was ${t}`) }; Yr.typeOf.object = function (e, t) { if (typeof t != "object") throw new ye(LA(typeof t, "object", e)) }; Yr.typeOf.bool = function (e, t) { if (typeof t != "boolean") throw new ye(LA(typeof t, "boolean", e)) }; Yr.typeOf.bigint = function (e, t) { if (typeof t != "bigint") throw new ye(LA(typeof t, "bigint", e)) }; Yr.typeOf.number.equals = function (e, t, n, i) { if (Yr.typeOf.number(e, n), Yr.typeOf.number(t, i), n !== i) throw new ye(`${e} must be equal to ${t}, the actual values are ${n} and ${i}`) }; var rl = Yr; function nb() { this._listeners = [], this._scopes = [], this._toRemove = [], this._insideRaiseEvent = !1 } Object.defineProperties(nb.prototype, { numberOfListeners: { get: function () { return this._listeners.length - this._toRemove.length } } }); nb.prototype.addEventListener = function (e, t) { this._listeners.push(e), this._scopes.push(t); let n = this; return function () { n.removeEventListener(e, t) } }; nb.prototype.removeEventListener = function (e, t) { let n = this._listeners, i = this._scopes, o = -1; for (let r = 0; r < n.length; r++)if (n[r] === e && i[r] === t) { o = r; break } return o !== -1 ? (this._insideRaiseEvent ? (this._toRemove.push(o), n[o] = void 0, i[o] = void 0) : (n.splice(o, 1), i.splice(o, 1)), !0) : !1 }; function Sye(e, t) { return t - e } nb.prototype.raiseEvent = function () { this._insideRaiseEvent = !0; let e, t = this._listeners, n = this._scopes, i = t.length; for (e = 0; e < i; e++) { let r = t[e]; l(r) && t[e].apply(n[e], arguments) } let o = this._toRemove; if (i = o.length, i > 0) { for (o.sort(Sye), e = 0; e < i; e++) { let r = o[e]; t.splice(r, 1), n.splice(r, 1) } o.length = 0 } this._insideRaiseEvent = !1 }; var _e = nb; function Tp(e) { this._value = void 0, this._hasClone = !1, this._hasEquals = !1, this._definitionChanged = new _e, this.setValue(e) } Object.defineProperties(Tp.prototype, { isConstant: { value: !0 }, definitionChanged: { get: function () { return this._definitionChanged } } }); Tp.prototype.getValue = function (e, t) { return this._hasClone ? this._value.clone(t) : this._value }; Tp.prototype.setValue = function (e) { let t = this._value; if (t !== e) { let n = l(e), i = n && typeof e.clone == "function", o = n && typeof e.equals == "function"; (!o || !e.equals(t)) && (this._hasClone = i, this._hasEquals = o, this._value = i ? e.clone(this._value) : e, this._definitionChanged.raiseEvent(this)) } }; Tp.prototype.equals = function (e) { return this === e || e instanceof Tp && (!this._hasEquals && this._value === e._value || this._hasEquals && this._value.equals(e._value)) }; Tp.prototype.valueOf = function () { return this._value }; Tp.prototype.toString = function () { return String(this._value) }; var Yn = Tp; function wye(e, t, n, i, o) { return { configurable: i, get: function () { return this[t] }, set: function (r) { let s = this[t], a = this[n]; l(a) && (a(), this[n] = void 0), r !== void 0 && (!l(r) || !l(r.getValue)) && l(o) && (r = o(r)), s !== r && (this[t] = r, this._definitionChanged.raiseEvent(this, e, r, s)), l(r) && l(r.definitionChanged) && (this[n] = r.definitionChanged.addEventListener(function () { this._definitionChanged.raiseEvent(this, e, r, r) }, this)) } } } function Dye(e) { return new Yn(e) } function vye(e, t, n) { return wye(e, `_${e.toString()}`, `_${e.toString()}Subscription`, y(t, !1), y(n, Dye)) } var ae = vye; function ib(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._image = void 0, this._imageSubscription = void 0, this._scale = void 0, this._scaleSubscription = void 0, this._pixelOffset = void 0, this._pixelOffsetSubscription = void 0, this._eyeOffset = void 0, this._eyeOffsetSubscription = void 0, this._horizontalOrigin = void 0, this._horizontalOriginSubscription = void 0, this._verticalOrigin = void 0, this._verticalOriginSubscription = void 0, this._heightReference = void 0, this._heightReferenceSubscription = void 0, this._color = void 0, this._colorSubscription = void 0, this._rotation = void 0, this._rotationSubscription = void 0, this._alignedAxis = void 0, this._alignedAxisSubscription = void 0, this._sizeInMeters = void 0, this._sizeInMetersSubscription = void 0, this._width = void 0, this._widthSubscription = void 0, this._height = void 0, this._heightSubscription = void 0, this._scaleByDistance = void 0, this._scaleByDistanceSubscription = void 0, this._translucencyByDistance = void 0, this._translucencyByDistanceSubscription = void 0, this._pixelOffsetScaleByDistance = void 0, this._pixelOffsetScaleByDistanceSubscription = void 0, this._imageSubRegion = void 0, this._imageSubRegionSubscription = void 0, this._distanceDisplayCondition = void 0, this._distanceDisplayConditionSubscription = void 0, this._disableDepthTestDistance = void 0, this._disableDepthTestDistanceSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(ib.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), image: ae("image"), scale: ae("scale"), pixelOffset: ae("pixelOffset"), eyeOffset: ae("eyeOffset"), horizontalOrigin: ae("horizontalOrigin"), verticalOrigin: ae("verticalOrigin"), heightReference: ae("heightReference"), color: ae("color"), rotation: ae("rotation"), alignedAxis: ae("alignedAxis"), sizeInMeters: ae("sizeInMeters"), width: ae("width"), height: ae("height"), scaleByDistance: ae("scaleByDistance"), translucencyByDistance: ae("translucencyByDistance"), pixelOffsetScaleByDistance: ae("pixelOffsetScaleByDistance"), imageSubRegion: ae("imageSubRegion"), distanceDisplayCondition: ae("distanceDisplayCondition"), disableDepthTestDistance: ae("disableDepthTestDistance") }); ib.prototype.clone = function (e) { return l(e) ? (e.show = this._show, e.image = this._image, e.scale = this._scale, e.pixelOffset = this._pixelOffset, e.eyeOffset = this._eyeOffset, e.horizontalOrigin = this._horizontalOrigin, e.verticalOrigin = this._verticalOrigin, e.heightReference = this._heightReference, e.color = this._color, e.rotation = this._rotation, e.alignedAxis = this._alignedAxis, e.sizeInMeters = this._sizeInMeters, e.width = this._width, e.height = this._height, e.scaleByDistance = this._scaleByDistance, e.translucencyByDistance = this._translucencyByDistance, e.pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance, e.imageSubRegion = this._imageSubRegion, e.distanceDisplayCondition = this._distanceDisplayCondition, e.disableDepthTestDistance = this._disableDepthTestDistance, e) : new ib(this) }; ib.prototype.merge = function (e) { this.show = y(this._show, e.show), this.image = y(this._image, e.image), this.scale = y(this._scale, e.scale), this.pixelOffset = y(this._pixelOffset, e.pixelOffset), this.eyeOffset = y(this._eyeOffset, e.eyeOffset), this.horizontalOrigin = y(this._horizontalOrigin, e.horizontalOrigin), this.verticalOrigin = y(this._verticalOrigin, e.verticalOrigin), this.heightReference = y(this._heightReference, e.heightReference), this.color = y(this._color, e.color), this.rotation = y(this._rotation, e.rotation), this.alignedAxis = y(this._alignedAxis, e.alignedAxis), this.sizeInMeters = y(this._sizeInMeters, e.sizeInMeters), this.width = y(this._width, e.width), this.height = y(this._height, e.height), this.scaleByDistance = y(this._scaleByDistance, e.scaleByDistance), this.translucencyByDistance = y(this._translucencyByDistance, e.translucencyByDistance), this.pixelOffsetScaleByDistance = y(this._pixelOffsetScaleByDistance, e.pixelOffsetScaleByDistance), this.imageSubRegion = y(this._imageSubRegion, e.imageSubRegion), this.distanceDisplayCondition = y(this._distanceDisplayCondition, e.distanceDisplayCondition), this.disableDepthTestDistance = y(this._disableDepthTestDistance, e.disableDepthTestDistance) }; var ja = ib; function r0() { this._array = [], this._hash = {} } Object.defineProperties(r0.prototype, { length: { get: function () { return this._array.length } }, values: { get: function () { return this._array } } }); r0.prototype.contains = function (e) { return l(this._hash[e]) }; r0.prototype.set = function (e, t) { let n = this._hash[e]; t !== n && (this.remove(e), this._hash[e] = t, this._array.push(t)) }; r0.prototype.get = function (e) { return this._hash[e] }; r0.prototype.remove = function (e) { let t = this._hash[e], n = l(t); if (n) { let i = this._array; i.splice(i.indexOf(t), 1), delete this._hash[e] } return n }; r0.prototype.removeAll = function () { let e = this._array; e.length > 0 && (this._hash = {}, e.length = 0) }; var Ct = r0; var Oz = po(eP(), 1); var it = {}; it.EPSILON1 = .1; it.EPSILON2 = .01; it.EPSILON3 = .001; it.EPSILON4 = 1e-4; it.EPSILON5 = 1e-5; it.EPSILON6 = 1e-6; it.EPSILON7 = 1e-7; it.EPSILON8 = 1e-8; it.EPSILON9 = 1e-9; it.EPSILON10 = 1e-10; it.EPSILON11 = 1e-11; it.EPSILON12 = 1e-12; it.EPSILON13 = 1e-13; it.EPSILON14 = 1e-14; it.EPSILON15 = 1e-15; it.EPSILON16 = 1e-16; it.EPSILON17 = 1e-17; it.EPSILON18 = 1e-18; it.EPSILON19 = 1e-19; it.EPSILON20 = 1e-20; it.EPSILON21 = 1e-21; it.GRAVITATIONALPARAMETER = 3986004418e5; it.SOLAR_RADIUS = 6955e5; it.LUNAR_RADIUS = 1737400; it.SIXTY_FOUR_KILOBYTES = 64 * 1024; it.FOUR_GIGABYTES = 4 * 1024 * 1024 * 1024; it.sign = y(Math.sign, function (t) { return t = +t, t === 0 || t !== t ? t : t > 0 ? 1 : -1 }); it.signNotZero = function (e) { return e < 0 ? -1 : 1 }; it.toSNorm = function (e, t) { return t = y(t, 255), Math.round((it.clamp(e, -1, 1) * .5 + .5) * t) }; it.fromSNorm = function (e, t) { return t = y(t, 255), it.clamp(e, 0, t) / t * 2 - 1 }; it.normalize = function (e, t, n) { return n = Math.max(n - t, 0), n === 0 ? 0 : it.clamp((e - t) / n, 0, 1) }; it.sinh = y(Math.sinh, function (t) { return (Math.exp(t) - Math.exp(-t)) / 2 }); it.cosh = y(Math.cosh, function (t) { return (Math.exp(t) + Math.exp(-t)) / 2 }); it.lerp = function (e, t, n) { return (1 - n) * e + n * t }; it.PI = Math.PI; it.ONE_OVER_PI = 1 / Math.PI; it.PI_OVER_TWO = Math.PI / 2; it.PI_OVER_THREE = Math.PI / 3; it.PI_OVER_FOUR = Math.PI / 4; it.PI_OVER_SIX = Math.PI / 6; it.THREE_PI_OVER_TWO = 3 * Math.PI / 2; it.TWO_PI = 2 * Math.PI; it.ONE_OVER_TWO_PI = 1 / (2 * Math.PI); it.RADIANS_PER_DEGREE = Math.PI / 180; it.DEGREES_PER_RADIAN = 180 / Math.PI; it.RADIANS_PER_ARCSECOND = it.RADIANS_PER_DEGREE / 3600; it.toRadians = function (e) { return e * it.RADIANS_PER_DEGREE }; it.toDegrees = function (e) { return e * it.DEGREES_PER_RADIAN }; it.convertLongitudeRange = function (e) { let t = it.TWO_PI, n = e - Math.floor(e / t) * t; return n < -Math.PI ? n + t : n >= Math.PI ? n - t : n }; it.clampToLatitudeRange = function (e) { return it.clamp(e, -1 * it.PI_OVER_TWO, it.PI_OVER_TWO) }; it.negativePiToPi = function (e) { return e >= -it.PI && e <= it.PI ? e : it.zeroToTwoPi(e + it.PI) - it.PI }; it.zeroToTwoPi = function (e) { if (e >= 0 && e <= it.TWO_PI) return e; let t = it.mod(e, it.TWO_PI); return Math.abs(t) < it.EPSILON14 && Math.abs(e) > it.EPSILON14 ? it.TWO_PI : t }; it.mod = function (e, t) { return it.sign(e) === it.sign(t) && Math.abs(e) < Math.abs(t) ? e : (e % t + t) % t }; it.equalsEpsilon = function (e, t, n, i) { n = y(n, 0), i = y(i, n); let o = Math.abs(e - t); return o <= i || o <= n * Math.max(Math.abs(e), Math.abs(t)) }; it.lessThan = function (e, t, n) { return e - t < -n }; it.lessThanOrEquals = function (e, t, n) { return e - t < n }; it.greaterThan = function (e, t, n) { return e - t > n }; it.greaterThanOrEquals = function (e, t, n) { return e - t > -n }; var tP = [1]; it.factorial = function (e) { let t = tP.length; if (e >= t) { let n = tP[t - 1]; for (let i = t; i <= e; i++) { let o = n * i; tP.push(o), n = o } } return tP[e] }; it.incrementWrap = function (e, t, n) { return n = y(n, 0), ++e, e > t && (e = n), e }; it.isPowerOfTwo = function (e) { return e !== 0 && (e & e - 1) === 0 }; it.nextPowerOfTwo = function (e) { return --e, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, ++e, e }; it.previousPowerOfTwo = function (e) { return e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, e |= e >> 32, e = (e >>> 0) - (e >>> 1), e }; it.clamp = function (e, t, n) { return e < t ? t : e > n ? n : e }; var Jq = new Oz.default; it.setRandomNumberSeed = function (e) { Jq = new Oz.default(e) }; it.nextRandomNumber = function () { return Jq.random() }; it.randomBetween = function (e, t) { return it.nextRandomNumber() * (t - e) + e }; it.acosClamped = function (e) { return Math.acos(it.clamp(e, -1, 1)) }; it.asinClamped = function (e) { return Math.asin(it.clamp(e, -1, 1)) }; it.chordLength = function (e, t) { return 2 * t * Math.sin(e * .5) }; it.logBase = function (e, t) { return Math.log(e) / Math.log(t) }; it.cbrt = y(Math.cbrt, function (t) { let n = Math.pow(Math.abs(t), .3333333333333333); return t < 0 ? -n : n }); it.log2 = y(Math.log2, function (t) { return Math.log(t) * Math.LOG2E }); it.fog = function (e, t) { let n = e * t; return 1 - Math.exp(-(n * n)) }; it.fastApproximateAtan = function (e) { return e * (-.1784 * Math.abs(e) - .0663 * e * e + 1.0301) }; it.fastApproximateAtan2 = function (e, t) { let n, i = Math.abs(e); n = Math.abs(t); let o = Math.max(i, n); n = Math.min(i, n); let r = n / o; return i = it.fastApproximateAtan(r), i = Math.abs(t) > Math.abs(e) ? it.PI_OVER_TWO - i : i, i = e < 0 ? it.PI - i : i, i = t < 0 ? -i : i, i }; var I = it; function St(e, t) { this.x = y(e, 0), this.y = y(t, 0) } St.fromElements = function (e, t, n) { return l(n) ? (n.x = e, n.y = t, n) : new St(e, t) }; St.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.x = e.x, t.y = e.y, t) : new St(e.x, e.y) }; St.fromCartesian3 = St.clone; St.fromCartesian4 = St.clone; St.packedLength = 2; St.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e.x, t[n] = e.y, t }; St.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new St), n.x = e[t++], n.y = e[t], n }; St.packArray = function (e, t) { let n = e.length, i = n * 2; l(t) ? !Array.isArray(t) && t.length !== i || t.length !== i && (t.length = i) : t = new Array(i); for (let o = 0; o < n; ++o)St.pack(e[o], t, o * 2); return t }; St.unpackArray = function (e, t) { let n = e.length; l(t) ? t.length = n / 2 : t = new Array(n / 2); for (let i = 0; i < n; i += 2) { let o = i / 2; t[o] = St.unpack(e, i, t[o]) } return t }; St.fromArray = St.unpack; St.maximumComponent = function (e) { return Math.max(e.x, e.y) }; St.minimumComponent = function (e) { return Math.min(e.x, e.y) }; St.minimumByComponent = function (e, t, n) { return n.x = Math.min(e.x, t.x), n.y = Math.min(e.y, t.y), n }; St.maximumByComponent = function (e, t, n) { return n.x = Math.max(e.x, t.x), n.y = Math.max(e.y, t.y), n }; St.clamp = function (e, t, n, i) { let o = I.clamp(e.x, t.x, n.x), r = I.clamp(e.y, t.y, n.y); return i.x = o, i.y = r, i }; St.magnitudeSquared = function (e) { return e.x * e.x + e.y * e.y }; St.magnitude = function (e) { return Math.sqrt(St.magnitudeSquared(e)) }; var nP = new St; St.distance = function (e, t) { return St.subtract(e, t, nP), St.magnitude(nP) }; St.distanceSquared = function (e, t) { return St.subtract(e, t, nP), St.magnitudeSquared(nP) }; St.normalize = function (e, t) { let n = St.magnitude(e); return t.x = e.x / n, t.y = e.y / n, t }; St.dot = function (e, t) { return e.x * t.x + e.y * t.y }; St.cross = function (e, t) { return e.x * t.y - e.y * t.x }; St.multiplyComponents = function (e, t, n) { return n.x = e.x * t.x, n.y = e.y * t.y, n }; St.divideComponents = function (e, t, n) { return n.x = e.x / t.x, n.y = e.y / t.y, n }; St.add = function (e, t, n) { return n.x = e.x + t.x, n.y = e.y + t.y, n }; St.subtract = function (e, t, n) { return n.x = e.x - t.x, n.y = e.y - t.y, n }; St.multiplyByScalar = function (e, t, n) { return n.x = e.x * t, n.y = e.y * t, n }; St.divideByScalar = function (e, t, n) { return n.x = e.x / t, n.y = e.y / t, n }; St.negate = function (e, t) { return t.x = -e.x, t.y = -e.y, t }; St.abs = function (e, t) { return t.x = Math.abs(e.x), t.y = Math.abs(e.y), t }; var Zq = new St; St.lerp = function (e, t, n, i) { return St.multiplyByScalar(t, n, Zq), i = St.multiplyByScalar(e, 1 - n, i), St.add(Zq, i, i) }; var Qq = new St, $q = new St; St.angleBetween = function (e, t) { return St.normalize(e, Qq), St.normalize(t, $q), I.acosClamped(St.dot(Qq, $q)) }; var Pye = new St; St.mostOrthogonalAxis = function (e, t) { let n = St.normalize(e, Pye); return St.abs(n, n), n.x <= n.y ? t = St.clone(St.UNIT_X, t) : t = St.clone(St.UNIT_Y, t), t }; St.equals = function (e, t) { return e === t || l(e) && l(t) && e.x === t.x && e.y === t.y }; St.equalsArray = function (e, t, n) { return e.x === t[n] && e.y === t[n + 1] }; St.equalsEpsilon = function (e, t, n, i) { return e === t || l(e) && l(t) && I.equalsEpsilon(e.x, t.x, n, i) && I.equalsEpsilon(e.y, t.y, n, i) }; St.ZERO = Object.freeze(new St(0, 0)); St.ONE = Object.freeze(new St(1, 1)); St.UNIT_X = Object.freeze(new St(1, 0)); St.UNIT_Y = Object.freeze(new St(0, 1)); St.prototype.clone = function (e) { return St.clone(this, e) }; St.prototype.equals = function (e) { return St.equals(this, e) }; St.prototype.equalsEpsilon = function (e, t, n) { return St.equalsEpsilon(this, e, t, n) }; St.prototype.toString = function () { return `(${this.x}, ${this.y})` }; var H = St; function Je(e, t, n) { this.x = y(e, 0), this.y = y(t, 0), this.z = y(n, 0) } Je.fromSpherical = function (e, t) { l(t) || (t = new Je); let n = e.clock, i = e.cone, o = y(e.magnitude, 1), r = o * Math.sin(i); return t.x = r * Math.cos(n), t.y = r * Math.sin(n), t.z = o * Math.cos(i), t }; Je.fromElements = function (e, t, n, i) { return l(i) ? (i.x = e, i.y = t, i.z = n, i) : new Je(e, t, n) }; Je.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.x = e.x, t.y = e.y, t.z = e.z, t) : new Je(e.x, e.y, e.z) }; Je.fromCartesian4 = Je.clone; Je.packedLength = 3; Je.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e.x, t[n++] = e.y, t[n] = e.z, t }; Je.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new Je), n.x = e[t++], n.y = e[t++], n.z = e[t], n }; Je.packArray = function (e, t) { let n = e.length, i = n * 3; l(t) ? !Array.isArray(t) && t.length !== i || t.length !== i && (t.length = i) : t = new Array(i); for (let o = 0; o < n; ++o)Je.pack(e[o], t, o * 3); return t }; Je.unpackArray = function (e, t) { let n = e.length; l(t) ? t.length = n / 3 : t = new Array(n / 3); for (let i = 0; i < n; i += 3) { let o = i / 3; t[o] = Je.unpack(e, i, t[o]) } return t }; Je.fromArray = Je.unpack; Je.maximumComponent = function (e) { return Math.max(e.x, e.y, e.z) }; Je.minimumComponent = function (e) { return Math.min(e.x, e.y, e.z) }; Je.minimumByComponent = function (e, t, n) { return n.x = Math.min(e.x, t.x), n.y = Math.min(e.y, t.y), n.z = Math.min(e.z, t.z), n }; Je.maximumByComponent = function (e, t, n) { return n.x = Math.max(e.x, t.x), n.y = Math.max(e.y, t.y), n.z = Math.max(e.z, t.z), n }; Je.clamp = function (e, t, n, i) { let o = I.clamp(e.x, t.x, n.x), r = I.clamp(e.y, t.y, n.y), s = I.clamp(e.z, t.z, n.z); return i.x = o, i.y = r, i.z = s, i }; Je.magnitudeSquared = function (e) { return e.x * e.x + e.y * e.y + e.z * e.z }; Je.magnitude = function (e) { return Math.sqrt(Je.magnitudeSquared(e)) }; var oP = new Je; Je.distance = function (e, t) { return Je.subtract(e, t, oP), Je.magnitude(oP) }; Je.distanceSquared = function (e, t) { return Je.subtract(e, t, oP), Je.magnitudeSquared(oP) }; Je.normalize = function (e, t) { let n = Je.magnitude(e); return t.x = e.x / n, t.y = e.y / n, t.z = e.z / n, t }; Je.dot = function (e, t) { return e.x * t.x + e.y * t.y + e.z * t.z }; Je.multiplyComponents = function (e, t, n) { return n.x = e.x * t.x, n.y = e.y * t.y, n.z = e.z * t.z, n }; Je.divideComponents = function (e, t, n) { return n.x = e.x / t.x, n.y = e.y / t.y, n.z = e.z / t.z, n }; Je.add = function (e, t, n) { return n.x = e.x + t.x, n.y = e.y + t.y, n.z = e.z + t.z, n }; Je.subtract = function (e, t, n) { return n.x = e.x - t.x, n.y = e.y - t.y, n.z = e.z - t.z, n }; Je.multiplyByScalar = function (e, t, n) { return n.x = e.x * t, n.y = e.y * t, n.z = e.z * t, n }; Je.divideByScalar = function (e, t, n) { return n.x = e.x / t, n.y = e.y / t, n.z = e.z / t, n }; Je.negate = function (e, t) { return t.x = -e.x, t.y = -e.y, t.z = -e.z, t }; Je.abs = function (e, t) { return t.x = Math.abs(e.x), t.y = Math.abs(e.y), t.z = Math.abs(e.z), t }; var eY = new Je; Je.lerp = function (e, t, n, i) { return Je.multiplyByScalar(t, n, eY), i = Je.multiplyByScalar(e, 1 - n, i), Je.add(eY, i, i) }; var iP = new Je, Bz = new Je; Je.angleBetween = function (e, t) { Je.normalize(e, iP), Je.normalize(t, Bz); let n = Je.dot(iP, Bz), i = Je.magnitude(Je.cross(iP, Bz, iP)); return Math.atan2(i, n) }; var Iye = new Je; Je.mostOrthogonalAxis = function (e, t) { let n = Je.normalize(e, Iye); return Je.abs(n, n), n.x <= n.y ? n.x <= n.z ? t = Je.clone(Je.UNIT_X, t) : t = Je.clone(Je.UNIT_Z, t) : n.y <= n.z ? t = Je.clone(Je.UNIT_Y, t) : t = Je.clone(Je.UNIT_Z, t), t }; Je.projectVector = function (e, t, n) { let i = Je.dot(e, t) / Je.dot(t, t); return Je.multiplyByScalar(t, i, n) }; Je.equals = function (e, t) { return e === t || l(e) && l(t) && e.x === t.x && e.y === t.y && e.z === t.z }; Je.equalsArray = function (e, t, n) { return e.x === t[n] && e.y === t[n + 1] && e.z === t[n + 2] }; Je.equalsEpsilon = function (e, t, n, i) { return e === t || l(e) && l(t) && I.equalsEpsilon(e.x, t.x, n, i) && I.equalsEpsilon(e.y, t.y, n, i) && I.equalsEpsilon(e.z, t.z, n, i) }; Je.cross = function (e, t, n) { let i = e.x, o = e.y, r = e.z, s = t.x, a = t.y, c = t.z, u = o * c - r * a, f = r * s - i * c, d = i * a - o * s; return n.x = u, n.y = f, n.z = d, n }; Je.midpoint = function (e, t, n) { return n.x = (e.x + t.x) * .5, n.y = (e.y + t.y) * .5, n.z = (e.z + t.z) * .5, n }; Je.fromDegrees = function (e, t, n, i, o) { return e = I.toRadians(e), t = I.toRadians(t), Je.fromRadians(e, t, n, i, o) }; var Zl = new Je, FA = new Je, Oye = new Je(6378137 * 6378137, 6378137 * 6378137, 6356752314245179e-9 * 6356752314245179e-9); Je.fromRadians = function (e, t, n, i, o) { n = y(n, 0); let r = l(i) ? i.radiiSquared : Oye, s = Math.cos(t); Zl.x = s * Math.cos(e), Zl.y = s * Math.sin(e), Zl.z = Math.sin(t), Zl = Je.normalize(Zl, Zl), Je.multiplyComponents(r, Zl, FA); let a = Math.sqrt(Je.dot(Zl, FA)); return FA = Je.divideByScalar(FA, a, FA), Zl = Je.multiplyByScalar(Zl, n, Zl), l(o) || (o = new Je), Je.add(FA, Zl, o) }; Je.fromDegreesArray = function (e, t, n) { let i = e.length; l(n) ? n.length = i / 2 : n = new Array(i / 2); for (let o = 0; o < i; o += 2) { let r = e[o], s = e[o + 1], a = o / 2; n[a] = Je.fromDegrees(r, s, 0, t, n[a]) } return n }; Je.fromRadiansArray = function (e, t, n) { let i = e.length; l(n) ? n.length = i / 2 : n = new Array(i / 2); for (let o = 0; o < i; o += 2) { let r = e[o], s = e[o + 1], a = o / 2; n[a] = Je.fromRadians(r, s, 0, t, n[a]) } return n }; Je.fromDegreesArrayHeights = function (e, t, n) { let i = e.length; l(n) ? n.length = i / 3 : n = new Array(i / 3); for (let o = 0; o < i; o += 3) { let r = e[o], s = e[o + 1], a = e[o + 2], c = o / 3; n[c] = Je.fromDegrees(r, s, a, t, n[c]) } return n }; Je.fromRadiansArrayHeights = function (e, t, n) { let i = e.length; l(n) ? n.length = i / 3 : n = new Array(i / 3); for (let o = 0; o < i; o += 3) { let r = e[o], s = e[o + 1], a = e[o + 2], c = o / 3; n[c] = Je.fromRadians(r, s, a, t, n[c]) } return n }; Je.ZERO = Object.freeze(new Je(0, 0, 0)); Je.ONE = Object.freeze(new Je(1, 1, 1)); Je.UNIT_X = Object.freeze(new Je(1, 0, 0)); Je.UNIT_Y = Object.freeze(new Je(0, 1, 0)); Je.UNIT_Z = Object.freeze(new Je(0, 0, 1)); Je.prototype.clone = function (e) { return Je.clone(this, e) }; Je.prototype.equals = function (e) { return Je.equals(this, e) }; Je.prototype.equalsEpsilon = function (e, t, n) { return Je.equalsEpsilon(this, e, t, n) }; Je.prototype.toString = function () { return `(${this.x}, ${this.y}, ${this.z})` }; var h = Je; var Bye = new h, Rye = new h; function Mye(e, t, n, i, o) { let r = e.x, s = e.y, a = e.z, c = t.x, u = t.y, f = t.z, d = r * r * c * c, p = s * s * u * u, g = a * a * f * f, m = d + p + g, A = Math.sqrt(1 / m), C = h.multiplyByScalar(e, A, Bye); if (m < i) return isFinite(A) ? h.clone(C, o) : void 0; let x = n.x, T = n.y, b = n.z, S = Rye; S.x = C.x * x * 2, S.y = C.y * T * 2, S.z = C.z * b * 2; let D = (1 - A) * h.magnitude(e) / (.5 * h.magnitude(S)), P = 0, B, R, M, L, _, E, w, v, O, V, z; do { D -= P, M = 1 / (1 + D * x), L = 1 / (1 + D * T), _ = 1 / (1 + D * b), E = M * M, w = L * L, v = _ * _, O = E * M, V = w * L, z = v * _, B = d * E + p * w + g * v - 1, R = d * O * x + p * V * T + g * z * b; let k = -2 * R; P = B / k } while (Math.abs(B) > I.EPSILON12); return l(o) ? (o.x = r * M, o.y = s * L, o.z = a * _, o) : new h(r * M, s * L, a * _) } var NA = Mye; function Fr(e, t, n) { this.longitude = y(e, 0), this.latitude = y(t, 0), this.height = y(n, 0) } Fr.fromRadians = function (e, t, n, i) { return n = y(n, 0), l(i) ? (i.longitude = e, i.latitude = t, i.height = n, i) : new Fr(e, t, n) }; Fr.fromDegrees = function (e, t, n, i) { return e = I.toRadians(e), t = I.toRadians(t), Fr.fromRadians(e, t, n, i) }; var Lye = new h, Fye = new h, Nye = new h, Vye = new h(1 / 6378137, 1 / 6378137, 1 / 6356752314245179e-9), kye = new h(1 / (6378137 * 6378137), 1 / (6378137 * 6378137), 1 / (6356752314245179e-9 * 6356752314245179e-9)), Uye = I.EPSILON1; Fr.fromCartesian = function (e, t, n) { let i = l(t) ? t.oneOverRadii : Vye, o = l(t) ? t.oneOverRadiiSquared : kye, r = l(t) ? t._centerToleranceSquared : Uye, s = NA(e, i, o, r, Fye); if (!l(s)) return; let a = h.multiplyComponents(s, o, Lye); a = h.normalize(a, a); let c = h.subtract(e, s, Nye), u = Math.atan2(a.y, a.x), f = Math.asin(a.z), d = I.sign(h.dot(c, e)) * h.magnitude(c); return l(n) ? (n.longitude = u, n.latitude = f, n.height = d, n) : new Fr(u, f, d) }; Fr.toCartesian = function (e, t, n) { return h.fromRadians(e.longitude, e.latitude, e.height, t, n) }; Fr.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.longitude = e.longitude, t.latitude = e.latitude, t.height = e.height, t) : new Fr(e.longitude, e.latitude, e.height) }; Fr.equals = function (e, t) { return e === t || l(e) && l(t) && e.longitude === t.longitude && e.latitude === t.latitude && e.height === t.height }; Fr.equalsEpsilon = function (e, t, n) { return n = y(n, 0), e === t || l(e) && l(t) && Math.abs(e.longitude - t.longitude) <= n && Math.abs(e.latitude - t.latitude) <= n && Math.abs(e.height - t.height) <= n }; Fr.ZERO = Object.freeze(new Fr(0, 0, 0)); Fr.prototype.clone = function (e) { return Fr.clone(this, e) }; Fr.prototype.equals = function (e) { return Fr.equals(this, e) }; Fr.prototype.equalsEpsilon = function (e, t) { return Fr.equalsEpsilon(this, e, t) }; Fr.prototype.toString = function () { return `(${this.longitude}, ${this.latitude}, ${this.height})` }; var he = Fr; function nY(e, t, n, i) { t = y(t, 0), n = y(n, 0), i = y(i, 0), e._radii = new h(t, n, i), e._radiiSquared = new h(t * t, n * n, i * i), e._radiiToTheFourth = new h(t * t * t * t, n * n * n * n, i * i * i * i), e._oneOverRadii = new h(t === 0 ? 0 : 1 / t, n === 0 ? 0 : 1 / n, i === 0 ? 0 : 1 / i), e._oneOverRadiiSquared = new h(t === 0 ? 0 : 1 / (t * t), n === 0 ? 0 : 1 / (n * n), i === 0 ? 0 : 1 / (i * i)), e._minimumRadius = Math.min(t, n, i), e._maximumRadius = Math.max(t, n, i), e._centerToleranceSquared = I.EPSILON1, e._radiiSquared.z !== 0 && (e._squaredXOverSquaredZ = e._radiiSquared.x / e._radiiSquared.z) } function ki(e, t, n) { this._radii = void 0, this._radiiSquared = void 0, this._radiiToTheFourth = void 0, this._oneOverRadii = void 0, this._oneOverRadiiSquared = void 0, this._minimumRadius = void 0, this._maximumRadius = void 0, this._centerToleranceSquared = void 0, this._squaredXOverSquaredZ = void 0, nY(this, e, t, n) } Object.defineProperties(ki.prototype, { radii: { get: function () { return this._radii } }, radiiSquared: { get: function () { return this._radiiSquared } }, radiiToTheFourth: { get: function () { return this._radiiToTheFourth } }, oneOverRadii: { get: function () { return this._oneOverRadii } }, oneOverRadiiSquared: { get: function () { return this._oneOverRadiiSquared } }, minimumRadius: { get: function () { return this._minimumRadius } }, maximumRadius: { get: function () { return this._maximumRadius } } }); ki.clone = function (e, t) { if (!l(e)) return; let n = e._radii; return l(t) ? (h.clone(n, t._radii), h.clone(e._radiiSquared, t._radiiSquared), h.clone(e._radiiToTheFourth, t._radiiToTheFourth), h.clone(e._oneOverRadii, t._oneOverRadii), h.clone(e._oneOverRadiiSquared, t._oneOverRadiiSquared), t._minimumRadius = e._minimumRadius, t._maximumRadius = e._maximumRadius, t._centerToleranceSquared = e._centerToleranceSquared, t) : new ki(n.x, n.y, n.z) }; ki.fromCartesian3 = function (e, t) { return l(t) || (t = new ki), l(e) && nY(t, e.x, e.y, e.z), t }; ki.WGS84 = Object.freeze(new ki(6378137, 6378137, 6356752314245179e-9)); ki.UNIT_SPHERE = Object.freeze(new ki(1, 1, 1)); ki.MOON = Object.freeze(new ki(I.LUNAR_RADIUS, I.LUNAR_RADIUS, I.LUNAR_RADIUS)); ki.prototype.clone = function (e) { return ki.clone(this, e) }; ki.packedLength = h.packedLength; ki.pack = function (e, t, n) { return n = y(n, 0), h.pack(e._radii, t, n), t }; ki.unpack = function (e, t, n) { t = y(t, 0); let i = h.unpack(e, t); return ki.fromCartesian3(i, n) }; ki.prototype.geocentricSurfaceNormal = h.normalize; ki.prototype.geodeticSurfaceNormalCartographic = function (e, t) { let n = e.longitude, i = e.latitude, o = Math.cos(i), r = o * Math.cos(n), s = o * Math.sin(n), a = Math.sin(i); return l(t) || (t = new h), t.x = r, t.y = s, t.z = a, h.normalize(t, t) }; ki.prototype.geodeticSurfaceNormal = function (e, t) { if (!h.equalsEpsilon(e, h.ZERO, I.EPSILON14)) return l(t) || (t = new h), t = h.multiplyComponents(e, this._oneOverRadiiSquared, t), h.normalize(t, t) }; var zye = new h, Hye = new h; ki.prototype.cartographicToCartesian = function (e, t) { let n = zye, i = Hye; this.geodeticSurfaceNormalCartographic(e, n), h.multiplyComponents(this._radiiSquared, n, i); let o = Math.sqrt(h.dot(n, i)); return h.divideByScalar(i, o, i), h.multiplyByScalar(n, e.height, n), l(t) || (t = new h), h.add(i, n, t) }; ki.prototype.cartographicArrayToCartesianArray = function (e, t) { let n = e.length; l(t) ? t.length = n : t = new Array(n); for (let i = 0; i < n; i++)t[i] = this.cartographicToCartesian(e[i], t[i]); return t }; var Gye = new h, Wye = new h, jye = new h; ki.prototype.cartesianToCartographic = function (e, t) { let n = this.scaleToGeodeticSurface(e, Wye); if (!l(n)) return; let i = this.geodeticSurfaceNormal(n, Gye), o = h.subtract(e, n, jye), r = Math.atan2(i.y, i.x), s = Math.asin(i.z), a = I.sign(h.dot(o, e)) * h.magnitude(o); return l(t) ? (t.longitude = r, t.latitude = s, t.height = a, t) : new he(r, s, a) }; ki.prototype.cartesianArrayToCartographicArray = function (e, t) { let n = e.length; l(t) ? t.length = n : t = new Array(n); for (let i = 0; i < n; ++i)t[i] = this.cartesianToCartographic(e[i], t[i]); return t }; ki.prototype.scaleToGeodeticSurface = function (e, t) { return NA(e, this._oneOverRadii, this._oneOverRadiiSquared, this._centerToleranceSquared, t) }; ki.prototype.scaleToGeocentricSurface = function (e, t) { l(t) || (t = new h); let n = e.x, i = e.y, o = e.z, r = this._oneOverRadiiSquared, s = 1 / Math.sqrt(n * n * r.x + i * i * r.y + o * o * r.z); return h.multiplyByScalar(e, s, t) }; ki.prototype.transformPositionToScaledSpace = function (e, t) { return l(t) || (t = new h), h.multiplyComponents(e, this._oneOverRadii, t) }; ki.prototype.transformPositionFromScaledSpace = function (e, t) { return l(t) || (t = new h), h.multiplyComponents(e, this._radii, t) }; ki.prototype.equals = function (e) { return this === e || l(e) && h.equals(this._radii, e._radii) }; ki.prototype.toString = function () { return this._radii.toString() }; ki.prototype.getSurfaceNormalIntersectionWithZAxis = function (e, t, n) { t = y(t, 0); let i = this._squaredXOverSquaredZ; if (l(n) || (n = new h), n.x = 0, n.y = 0, n.z = e.z * (1 - i), !(Math.abs(n.z) >= this._radii.z - t)) return n }; var qye = [.14887433898163, .43339539412925, .67940956829902, .86506336668898, .97390652851717, 0], Yye = [.29552422471475, .26926671930999, .21908636251598, .14945134915058, .066671344308684, 0]; function tY(e, t, n) { let i = .5 * (t + e), o = .5 * (t - e), r = 0; for (let s = 0; s < 5; s++) { let a = o * qye[s]; r += Yye[s] * (n(i + a) + n(i - a)) } return r *= o, r } ki.prototype.surfaceArea = function (e) { let t = e.west, n = e.east, i = e.south, o = e.north; for (; n < t;)n += I.TWO_PI; let r = this._radiiSquared, s = r.x, a = r.y, c = r.z, u = s * a; return tY(i, o, function (f) { let d = Math.cos(f), p = Math.sin(f); return Math.cos(f) * tY(t, n, function (g) { let m = Math.cos(g), A = Math.sin(g); return Math.sqrt(u * p * p + c * (a * m * m + s * A * A) * d * d) }) }) }; var ie = ki; function rP(e) { this._ellipsoid = y(e, ie.WGS84), this._semimajorAxis = this._ellipsoid.maximumRadius, this._oneOverSemimajorAxis = 1 / this._semimajorAxis } Object.defineProperties(rP.prototype, { ellipsoid: { get: function () { return this._ellipsoid } } }); rP.prototype.project = function (e, t) { let n = this._semimajorAxis, i = e.longitude * n, o = e.latitude * n, r = e.height; return l(t) ? (t.x = i, t.y = o, t.z = r, t) : new h(i, o, r) }; rP.prototype.unproject = function (e, t) { let n = this._oneOverSemimajorAxis, i = e.x * n, o = e.y * n, r = e.z; return l(t) ? (t.longitude = i, t.latitude = o, t.height = r, t) : new he(i, o, r) }; var _i = rP; var Xye = { OUTSIDE: -1, INTERSECTING: 0, INSIDE: 1 }, Kt = Object.freeze(Xye); function On(e, t, n, i) { this.west = y(e, 0), this.south = y(t, 0), this.east = y(n, 0), this.north = y(i, 0) } Object.defineProperties(On.prototype, { width: { get: function () { return On.computeWidth(this) } }, height: { get: function () { return On.computeHeight(this) } } }); On.packedLength = 4; On.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e.west, t[n++] = e.south, t[n++] = e.east, t[n] = e.north, t }; On.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new On), n.west = e[t++], n.south = e[t++], n.east = e[t++], n.north = e[t], n }; On.computeWidth = function (e) { let t = e.east, n = e.west; return t < n && (t += I.TWO_PI), t - n }; On.computeHeight = function (e) { return e.north - e.south }; On.fromDegrees = function (e, t, n, i, o) { return e = I.toRadians(y(e, 0)), t = I.toRadians(y(t, 0)), n = I.toRadians(y(n, 0)), i = I.toRadians(y(i, 0)), l(o) ? (o.west = e, o.south = t, o.east = n, o.north = i, o) : new On(e, t, n, i) }; On.fromRadians = function (e, t, n, i, o) { return l(o) ? (o.west = y(e, 0), o.south = y(t, 0), o.east = y(n, 0), o.north = y(i, 0), o) : new On(e, t, n, i) }; On.fromCartographicArray = function (e, t) { let n = Number.MAX_VALUE, i = -Number.MAX_VALUE, o = Number.MAX_VALUE, r = -Number.MAX_VALUE, s = Number.MAX_VALUE, a = -Number.MAX_VALUE; for (let c = 0, u = e.length; c < u; c++) { let f = e[c]; n = Math.min(n, f.longitude), i = Math.max(i, f.longitude), s = Math.min(s, f.latitude), a = Math.max(a, f.latitude); let d = f.longitude >= 0 ? f.longitude : f.longitude + I.TWO_PI; o = Math.min(o, d), r = Math.max(r, d) } return i - n > r - o && (n = o, i = r, i > I.PI && (i = i - I.TWO_PI), n > I.PI && (n = n - I.TWO_PI)), l(t) ? (t.west = n, t.south = s, t.east = i, t.north = a, t) : new On(n, s, i, a) }; On.fromCartesianArray = function (e, t, n) { t = y(t, ie.WGS84); let i = Number.MAX_VALUE, o = -Number.MAX_VALUE, r = Number.MAX_VALUE, s = -Number.MAX_VALUE, a = Number.MAX_VALUE, c = -Number.MAX_VALUE; for (let u = 0, f = e.length; u < f; u++) { let d = t.cartesianToCartographic(e[u]); i = Math.min(i, d.longitude), o = Math.max(o, d.longitude), a = Math.min(a, d.latitude), c = Math.max(c, d.latitude); let p = d.longitude >= 0 ? d.longitude : d.longitude + I.TWO_PI; r = Math.min(r, p), s = Math.max(s, p) } return o - i > s - r && (i = r, o = s, o > I.PI && (o = o - I.TWO_PI), i > I.PI && (i = i - I.TWO_PI)), l(n) ? (n.west = i, n.south = a, n.east = o, n.north = c, n) : new On(i, a, o, c) }; On.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.west = e.west, t.south = e.south, t.east = e.east, t.north = e.north, t) : new On(e.west, e.south, e.east, e.north) }; On.equalsEpsilon = function (e, t, n) { return n = y(n, 0), e === t || l(e) && l(t) && Math.abs(e.west - t.west) <= n && Math.abs(e.south - t.south) <= n && Math.abs(e.east - t.east) <= n && Math.abs(e.north - t.north) <= n }; On.prototype.clone = function (e) { return On.clone(this, e) }; On.prototype.equals = function (e) { return On.equals(this, e) }; On.equals = function (e, t) { return e === t || l(e) && l(t) && e.west === t.west && e.south === t.south && e.east === t.east && e.north === t.north }; On.prototype.equalsEpsilon = function (e, t) { return On.equalsEpsilon(this, e, t) }; On.validate = function (e) { }; On.southwest = function (e, t) { return l(t) ? (t.longitude = e.west, t.latitude = e.south, t.height = 0, t) : new he(e.west, e.south) }; On.northwest = function (e, t) { return l(t) ? (t.longitude = e.west, t.latitude = e.north, t.height = 0, t) : new he(e.west, e.north) }; On.northeast = function (e, t) { return l(t) ? (t.longitude = e.east, t.latitude = e.north, t.height = 0, t) : new he(e.east, e.north) }; On.southeast = function (e, t) { return l(t) ? (t.longitude = e.east, t.latitude = e.south, t.height = 0, t) : new he(e.east, e.south) }; On.center = function (e, t) { let n = e.east, i = e.west; n < i && (n += I.TWO_PI); let o = I.negativePiToPi((i + n) * .5), r = (e.south + e.north) * .5; return l(t) ? (t.longitude = o, t.latitude = r, t.height = 0, t) : new he(o, r) }; On.intersection = function (e, t, n) { let i = e.east, o = e.west, r = t.east, s = t.west; i < o && r > 0 ? i += I.TWO_PI : r < s && i > 0 && (r += I.TWO_PI), i < o && s < 0 ? s += I.TWO_PI : r < s && o < 0 && (o += I.TWO_PI); let a = I.negativePiToPi(Math.max(o, s)), c = I.negativePiToPi(Math.min(i, r)); if ((e.west < e.east || t.west < t.east) && c <= a) return; let u = Math.max(e.south, t.south), f = Math.min(e.north, t.north); if (!(u >= f)) return l(n) ? (n.west = a, n.south = u, n.east = c, n.north = f, n) : new On(a, u, c, f) }; On.simpleIntersection = function (e, t, n) { let i = Math.max(e.west, t.west), o = Math.max(e.south, t.south), r = Math.min(e.east, t.east), s = Math.min(e.north, t.north); if (!(o >= s || i >= r)) return l(n) ? (n.west = i, n.south = o, n.east = r, n.north = s, n) : new On(i, o, r, s) }; On.union = function (e, t, n) { l(n) || (n = new On); let i = e.east, o = e.west, r = t.east, s = t.west; i < o && r > 0 ? i += I.TWO_PI : r < s && i > 0 && (r += I.TWO_PI), i < o && s < 0 ? s += I.TWO_PI : r < s && o < 0 && (o += I.TWO_PI); let a = I.negativePiToPi(Math.min(o, s)), c = I.negativePiToPi(Math.max(i, r)); return n.west = a, n.south = Math.min(e.south, t.south), n.east = c, n.north = Math.max(e.north, t.north), n }; On.expand = function (e, t, n) { return l(n) || (n = new On), n.west = Math.min(e.west, t.longitude), n.south = Math.min(e.south, t.latitude), n.east = Math.max(e.east, t.longitude), n.north = Math.max(e.north, t.latitude), n }; On.contains = function (e, t) { let n = t.longitude, i = t.latitude, o = e.west, r = e.east; return r < o && (r += I.TWO_PI, n < 0 && (n += I.TWO_PI)), (n > o || I.equalsEpsilon(n, o, I.EPSILON14)) && (n < r || I.equalsEpsilon(n, r, I.EPSILON14)) && i >= e.south && i <= e.north }; var Kye = new he; On.subsample = function (e, t, n, i) { t = y(t, ie.WGS84), n = y(n, 0), l(i) || (i = []); let o = 0, r = e.north, s = e.south, a = e.east, c = e.west, u = Kye; u.height = n, u.longitude = c, u.latitude = r, i[o] = t.cartographicToCartesian(u, i[o]), o++, u.longitude = a, i[o] = t.cartographicToCartesian(u, i[o]), o++, u.latitude = s, i[o] = t.cartographicToCartesian(u, i[o]), o++, u.longitude = c, i[o] = t.cartographicToCartesian(u, i[o]), o++, r < 0 ? u.latitude = r : s > 0 ? u.latitude = s : u.latitude = 0; for (let f = 1; f < 8; ++f)u.longitude = -Math.PI + f * I.PI_OVER_TWO, On.contains(e, u) && (i[o] = t.cartographicToCartesian(u, i[o]), o++); return u.latitude === 0 && (u.longitude = c, i[o] = t.cartographicToCartesian(u, i[o]), o++, u.longitude = a, i[o] = t.cartographicToCartesian(u, i[o]), o++), i.length = o, i }; On.subsection = function (e, t, n, i, o, r) { if (l(r) || (r = new On), e.west <= e.east) { let a = e.east - e.west; r.west = e.west + t * a, r.east = e.west + i * a } else { let a = I.TWO_PI + e.east - e.west; r.west = I.negativePiToPi(e.west + t * a), r.east = I.negativePiToPi(e.west + i * a) } let s = e.north - e.south; return r.south = e.south + n * s, r.north = e.south + o * s, t === 1 && (r.west = e.east), i === 1 && (r.east = e.east), n === 1 && (r.south = e.north), o === 1 && (r.north = e.north), r }; On.MAX_VALUE = Object.freeze(new On(-Math.PI, -I.PI_OVER_TWO, Math.PI, I.PI_OVER_TWO)); var ce = On; function fr(e, t, n, i) { this.x = y(e, 0), this.y = y(t, 0), this.width = y(n, 0), this.height = y(i, 0) } fr.packedLength = 4; fr.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e.x, t[n++] = e.y, t[n++] = e.width, t[n] = e.height, t }; fr.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new fr), n.x = e[t++], n.y = e[t++], n.width = e[t++], n.height = e[t], n }; fr.fromPoints = function (e, t) { if (l(t) || (t = new fr), !l(e) || e.length === 0) return t.x = 0, t.y = 0, t.width = 0, t.height = 0, t; let n = e.length, i = e[0].x, o = e[0].y, r = e[0].x, s = e[0].y; for (let a = 1; a < n; a++) { let c = e[a], u = c.x, f = c.y; i = Math.min(u, i), r = Math.max(u, r), o = Math.min(f, o), s = Math.max(f, s) } return t.x = i, t.y = o, t.width = r - i, t.height = s - o, t }; var Jye = new _i, Zye = new he, Qye = new he; fr.fromRectangle = function (e, t, n) { if (l(n) || (n = new fr), !l(e)) return n.x = 0, n.y = 0, n.width = 0, n.height = 0, n; t = y(t, Jye); let i = t.project(ce.southwest(e, Zye)), o = t.project(ce.northeast(e, Qye)); return H.subtract(o, i, o), n.x = i.x, n.y = i.y, n.width = o.x, n.height = o.y, n }; fr.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.x = e.x, t.y = e.y, t.width = e.width, t.height = e.height, t) : new fr(e.x, e.y, e.width, e.height) }; fr.union = function (e, t, n) { l(n) || (n = new fr); let i = Math.min(e.x, t.x), o = Math.min(e.y, t.y), r = Math.max(e.x + e.width, t.x + t.width), s = Math.max(e.y + e.height, t.y + t.height); return n.x = i, n.y = o, n.width = r - i, n.height = s - o, n }; fr.expand = function (e, t, n) { n = fr.clone(e, n); let i = t.x - n.x, o = t.y - n.y; return i > n.width ? n.width = i : i < 0 && (n.width -= i, n.x = t.x), o > n.height ? n.height = o : o < 0 && (n.height -= o, n.y = t.y), n }; fr.intersect = function (e, t) { let n = e.x, i = e.y, o = t.x, r = t.y; return n > o + t.width || n + e.width < o || i + e.height < r || i > r + t.height ? Kt.OUTSIDE : Kt.INTERSECTING }; fr.equals = function (e, t) { return e === t || l(e) && l(t) && e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height }; fr.prototype.clone = function (e) { return fr.clone(this, e) }; fr.prototype.intersect = function (e) { return fr.intersect(this, e) }; fr.prototype.equals = function (e) { return fr.equals(this, e) }; var Ge = fr; var Ep, dr = { requestFullscreen: void 0, exitFullscreen: void 0, fullscreenEnabled: void 0, fullscreenElement: void 0, fullscreenchange: void 0, fullscreenerror: void 0 }, wc = {}; Object.defineProperties(wc, { element: { get: function () { if (!!wc.supportsFullscreen()) return document[dr.fullscreenElement] } }, changeEventName: { get: function () { if (!!wc.supportsFullscreen()) return dr.fullscreenchange } }, errorEventName: { get: function () { if (!!wc.supportsFullscreen()) return dr.fullscreenerror } }, enabled: { get: function () { if (!!wc.supportsFullscreen()) return document[dr.fullscreenEnabled] } }, fullscreen: { get: function () { if (!!wc.supportsFullscreen()) return wc.element !== null } } }); wc.supportsFullscreen = function () { if (l(Ep)) return Ep; Ep = !1; let e = document.body; if (typeof e.requestFullscreen == "function") return dr.requestFullscreen = "requestFullscreen", dr.exitFullscreen = "exitFullscreen", dr.fullscreenEnabled = "fullscreenEnabled", dr.fullscreenElement = "fullscreenElement", dr.fullscreenchange = "fullscreenchange", dr.fullscreenerror = "fullscreenerror", Ep = !0, Ep; let t = ["webkit", "moz", "o", "ms", "khtml"], n; for (let i = 0, o = t.length; i < o; ++i) { let r = t[i]; n = `${r}RequestFullscreen`, typeof e[n] == "function" ? (dr.requestFullscreen = n, Ep = !0) : (n = `${r}RequestFullScreen`, typeof e[n] == "function" && (dr.requestFullscreen = n, Ep = !0)), n = `${r}ExitFullscreen`, typeof document[n] == "function" ? dr.exitFullscreen = n : (n = `${r}CancelFullScreen`, typeof document[n] == "function" && (dr.exitFullscreen = n)), n = `${r}FullscreenEnabled`, document[n] !== void 0 ? dr.fullscreenEnabled = n : (n = `${r}FullScreenEnabled`, document[n] !== void 0 && (dr.fullscreenEnabled = n)), n = `${r}FullscreenElement`, document[n] !== void 0 ? dr.fullscreenElement = n : (n = `${r}FullScreenElement`, document[n] !== void 0 && (dr.fullscreenElement = n)), n = `${r}fullscreenchange`, document[`on${n}`] !== void 0 && (r === "ms" && (n = "MSFullscreenChange"), dr.fullscreenchange = n), n = `${r}fullscreenerror`, document[`on${n}`] !== void 0 && (r === "ms" && (n = "MSFullscreenError"), dr.fullscreenerror = n) } return Ep }; wc.requestFullscreen = function (e, t) { !wc.supportsFullscreen() || e[dr.requestFullscreen]({ vrDisplay: t }) }; wc.exitFullscreen = function () { !wc.supportsFullscreen() || document[dr.exitFullscreen]() }; wc._names = dr; var hr = wc; var ua; typeof navigator < "u" ? ua = navigator : ua = {}; function s0(e) { let t = e.split("."); for (let n = 0, i = t.length; n < i; ++n)t[n] = parseInt(t[n], 10); return t } var sP, iY; function Vz() { if (!l(sP) && (sP = !1, !dP())) { let e = / Chrome\/([\.0-9]+)/.exec(ua.userAgent); e !== null && (sP = !0, iY = s0(e[1])) } return sP } function $ye() { return Vz() && iY } var aP, oY; function rY() { if (!l(aP) && (aP = !1, !Vz() && !dP() && / Safari\/[\.0-9]+/.test(ua.userAgent))) { let e = / Version\/([\.0-9]+)/.exec(ua.userAgent); e !== null && (aP = !0, oY = s0(e[1])) } return aP } function eAe() { return rY() && oY } var cP, Fz; function sY() { if (!l(cP)) { cP = !1; let e = / AppleWebKit\/([\.0-9]+)(\+?)/.exec(ua.userAgent); e !== null && (cP = !0, Fz = s0(e[1]), Fz.isNightly = !!e[2]) } return cP } function tAe() { return sY() && Fz } var ob, Nz; function aY() { if (!l(ob)) { ob = !1; let e; ua.appName === "Microsoft Internet Explorer" ? (e = /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(ua.userAgent), e !== null && (ob = !0, Nz = s0(e[1]))) : ua.appName === "Netscape" && (e = /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(ua.userAgent), e !== null && (ob = !0, Nz = s0(e[1]))) } return ob } function nAe() { return aY() && Nz } var lP, cY; function dP() { if (!l(lP)) { lP = !1; let e = / Edg\/([\.0-9]+)/.exec(ua.userAgent); e !== null && (lP = !0, cY = s0(e[1])) } return lP } function iAe() { return dP() && cY } var uP, lY; function kz() { if (!l(uP)) { uP = !1; let e = /Firefox\/([\.0-9]+)/.exec(ua.userAgent); e !== null && (uP = !0, lY = s0(e[1])) } return uP } var Rz; function oAe() { return l(Rz) || (Rz = /Windows/i.test(ua.appVersion)), Rz } var Mz; function rAe() { return l(Mz) || (Mz = navigator.platform === "iPhone" || navigator.platform === "iPod" || navigator.platform === "iPad"), Mz } function sAe() { return kz() && lY } var Lz; function aAe() { return l(Lz) || (Lz = !kz() && typeof PointerEvent < "u" && (!l(ua.pointerEnabled) || ua.pointerEnabled)), Lz } var uY, fP; function fY() { if (!l(fP)) { let e = document.createElement("canvas"); e.setAttribute("style", "image-rendering: -moz-crisp-edges;image-rendering: pixelated;"); let t = e.style.imageRendering; fP = l(t) && t !== "", fP && (uY = t) } return fP } function cAe() { return fY() ? uY : void 0 } function qa() { return qa._result } qa._promise = void 0; qa._result = void 0; qa.initialize = function () { return l(qa._promise) || (qa._promise = new Promise(e => { let t = new Image; t.onload = function () { qa._result = t.width > 0 && t.height > 0, e(qa._result) }, t.onerror = function () { qa._result = !1, e(qa._result) }, t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA" })), qa._promise }; Object.defineProperties(qa, { initialized: { get: function () { return l(qa._result) } } }); var VA = []; typeof ArrayBuffer < "u" && (VA.push(Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array), typeof Uint8ClampedArray < "u" && VA.push(Uint8ClampedArray), typeof Uint8ClampedArray < "u" && VA.push(Uint8ClampedArray), typeof BigInt64Array < "u" && VA.push(BigInt64Array), typeof BigUint64Array < "u" && VA.push(BigUint64Array)); var yd = { isChrome: Vz, chromeVersion: $ye, isSafari: rY, safariVersion: eAe, isWebkit: sY, webkitVersion: tAe, isInternetExplorer: aY, internetExplorerVersion: nAe, isEdge: dP, edgeVersion: iAe, isFirefox: kz, firefoxVersion: sAe, isWindows: oAe, isIPadOrIOS: rAe, hardwareConcurrency: y(ua.hardwareConcurrency, 3), supportsPointerEvents: aAe, supportsImageRenderingPixelated: fY, supportsWebP: qa, imageRenderingValue: cAe, typedArrayTypes: VA }; yd.supportsBasis = function (e) { return yd.supportsWebAssembly() && e.context.supportsBasis }; yd.supportsFullscreen = function () { return hr.supportsFullscreen() }; yd.supportsTypedArrays = function () { return typeof ArrayBuffer < "u" }; yd.supportsBigInt64Array = function () { return typeof BigInt64Array < "u" }; yd.supportsBigUint64Array = function () { return typeof BigUint64Array < "u" }; yd.supportsBigInt = function () { return typeof BigInt < "u" }; yd.supportsWebWorkers = function () { return typeof Worker < "u" }; yd.supportsWebAssembly = function () { return typeof WebAssembly < "u" }; var Nt = yd; function Uz(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n * 6 < 1 ? e + (t - e) * 6 * n : n * 2 < 1 ? t : n * 3 < 2 ? e + (t - e) * (2 / 3 - n) * 6 : e } function ne(e, t, n, i) { this.red = y(e, 1), this.green = y(t, 1), this.blue = y(n, 1), this.alpha = y(i, 1) } ne.fromCartesian4 = function (e, t) { return l(t) ? (t.red = e.x, t.green = e.y, t.blue = e.z, t.alpha = e.w, t) : new ne(e.x, e.y, e.z, e.w) }; ne.fromBytes = function (e, t, n, i, o) { return e = ne.byteToFloat(y(e, 255)), t = ne.byteToFloat(y(t, 255)), n = ne.byteToFloat(y(n, 255)), i = ne.byteToFloat(y(i, 255)), l(o) ? (o.red = e, o.green = t, o.blue = n, o.alpha = i, o) : new ne(e, t, n, i) }; ne.fromAlpha = function (e, t, n) { return l(n) ? (n.red = e.red, n.green = e.green, n.blue = e.blue, n.alpha = t, n) : new ne(e.red, e.green, e.blue, t) }; var zz, Hz, qh; Nt.supportsTypedArrays() && (zz = new ArrayBuffer(4), Hz = new Uint32Array(zz), qh = new Uint8Array(zz)); ne.fromRgba = function (e, t) { return Hz[0] = e, ne.fromBytes(qh[0], qh[1], qh[2], qh[3], t) }; ne.fromHsl = function (e, t, n, i, o) { e = y(e, 0) % 1, t = y(t, 0), n = y(n, 0), i = y(i, 1); let r = n, s = n, a = n; if (t !== 0) { let c; n < .5 ? c = n * (1 + t) : c = n + t - n * t; let u = 2 * n - c; r = Uz(u, c, e + 1 / 3), s = Uz(u, c, e), a = Uz(u, c, e - 1 / 3) } return l(o) ? (o.red = r, o.green = s, o.blue = a, o.alpha = i, o) : new ne(r, s, a, i) }; ne.fromRandom = function (e, t) { e = y(e, y.EMPTY_OBJECT); let n = e.red; if (!l(n)) { let s = y(e.minimumRed, 0), a = y(e.maximumRed, 1); n = s + I.nextRandomNumber() * (a - s) } let i = e.green; if (!l(i)) { let s = y(e.minimumGreen, 0), a = y(e.maximumGreen, 1); i = s + I.nextRandomNumber() * (a - s) } let o = e.blue; if (!l(o)) { let s = y(e.minimumBlue, 0), a = y(e.maximumBlue, 1); o = s + I.nextRandomNumber() * (a - s) } let r = e.alpha; if (!l(r)) { let s = y(e.minimumAlpha, 0), a = y(e.maximumAlpha, 1); r = s + I.nextRandomNumber() * (a - s) } return l(t) ? (t.red = n, t.green = i, t.blue = o, t.alpha = r, t) : new ne(n, i, o, r) }; var lAe = /^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i, uAe = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i, fAe = /^rgba?\(\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)(?:\s*,\s*([0-9.]+))?\s*\)$/i, dAe = /^hsla?\(\s*([0-9.]+)\s*,\s*([0-9.]+%)\s*,\s*([0-9.]+%)(?:\s*,\s*([0-9.]+))?\s*\)$/i; ne.fromCssColorString = function (e, t) { l(t) || (t = new ne), e = e.replace(/\s/g, ""); let n = ne[e.toUpperCase()]; if (l(n)) return ne.clone(n, t), t; let i = lAe.exec(e); return i !== null ? (t.red = parseInt(i[1], 16) / 15, t.green = parseInt(i[2], 16) / 15, t.blue = parseInt(i[3], 16) / 15, t.alpha = parseInt(y(i[4], "f"), 16) / 15, t) : (i = uAe.exec(e), i !== null ? (t.red = parseInt(i[1], 16) / 255, t.green = parseInt(i[2], 16) / 255, t.blue = parseInt(i[3], 16) / 255, t.alpha = parseInt(y(i[4], "ff"), 16) / 255, t) : (i = fAe.exec(e), i !== null ? (t.red = parseFloat(i[1]) / (i[1].substr(-1) === "%" ? 100 : 255), t.green = parseFloat(i[2]) / (i[2].substr(-1) === "%" ? 100 : 255), t.blue = parseFloat(i[3]) / (i[3].substr(-1) === "%" ? 100 : 255), t.alpha = parseFloat(y(i[4], "1.0")), t) : (i = dAe.exec(e), i !== null ? ne.fromHsl(parseFloat(i[1]) / 360, parseFloat(i[2]) / 100, parseFloat(i[3]) / 100, parseFloat(y(i[4], "1.0")), t) : (t = void 0, t)))) }; ne.packedLength = 4; ne.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e.red, t[n++] = e.green, t[n++] = e.blue, t[n] = e.alpha, t }; ne.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new ne), n.red = e[t++], n.green = e[t++], n.blue = e[t++], n.alpha = e[t], n }; ne.byteToFloat = function (e) { return e / 255 }; ne.floatToByte = function (e) { return e === 1 ? 255 : e * 256 | 0 }; ne.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.red = e.red, t.green = e.green, t.blue = e.blue, t.alpha = e.alpha, t) : new ne(e.red, e.green, e.blue, e.alpha) }; ne.equals = function (e, t) { return e === t || l(e) && l(t) && e.red === t.red && e.green === t.green && e.blue === t.blue && e.alpha === t.alpha }; ne.equalsArray = function (e, t, n) { return e.red === t[n] && e.green === t[n + 1] && e.blue === t[n + 2] && e.alpha === t[n + 3] }; ne.prototype.clone = function (e) { return ne.clone(this, e) }; ne.prototype.equals = function (e) { return ne.equals(this, e) }; ne.prototype.equalsEpsilon = function (e, t) { return this === e || l(e) && Math.abs(this.red - e.red) <= t && Math.abs(this.green - e.green) <= t && Math.abs(this.blue - e.blue) <= t && Math.abs(this.alpha - e.alpha) <= t }; ne.prototype.toString = function () { return `(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})` }; ne.prototype.toCssColorString = function () { let e = ne.floatToByte(this.red), t = ne.floatToByte(this.green), n = ne.floatToByte(this.blue); return this.alpha === 1 ? `rgb(${e},${t},${n})` : `rgba(${e},${t},${n},${this.alpha})` }; ne.prototype.toCssHexString = function () { let e = ne.floatToByte(this.red).toString(16); e.length < 2 && (e = `0${e}`); let t = ne.floatToByte(this.green).toString(16); t.length < 2 && (t = `0${t}`); let n = ne.floatToByte(this.blue).toString(16); if (n.length < 2 && (n = `0${n}`), this.alpha < 1) { let i = ne.floatToByte(this.alpha).toString(16); return i.length < 2 && (i = `0${i}`), `#${e}${t}${n}${i}` } return `#${e}${t}${n}` }; ne.prototype.toBytes = function (e) { let t = ne.floatToByte(this.red), n = ne.floatToByte(this.green), i = ne.floatToByte(this.blue), o = ne.floatToByte(this.alpha); return l(e) ? (e[0] = t, e[1] = n, e[2] = i, e[3] = o, e) : [t, n, i, o] }; ne.prototype.toRgba = function () { return qh[0] = ne.floatToByte(this.red), qh[1] = ne.floatToByte(this.green), qh[2] = ne.floatToByte(this.blue), qh[3] = ne.floatToByte(this.alpha), Hz[0] }; ne.prototype.brighten = function (e, t) { return e = 1 - e, t.red = 1 - (1 - this.red) * e, t.green = 1 - (1 - this.green) * e, t.blue = 1 - (1 - this.blue) * e, t.alpha = this.alpha, t }; ne.prototype.darken = function (e, t) { return e = 1 - e, t.red = this.red * e, t.green = this.green * e, t.blue = this.blue * e, t.alpha = this.alpha, t }; ne.prototype.withAlpha = function (e, t) { return ne.fromAlpha(this, e, t) }; ne.add = function (e, t, n) { return n.red = e.red + t.red, n.green = e.green + t.green, n.blue = e.blue + t.blue, n.alpha = e.alpha + t.alpha, n }; ne.subtract = function (e, t, n) { return n.red = e.red - t.red, n.green = e.green - t.green, n.blue = e.blue - t.blue, n.alpha = e.alpha - t.alpha, n }; ne.multiply = function (e, t, n) { return n.red = e.red * t.red, n.green = e.green * t.green, n.blue = e.blue * t.blue, n.alpha = e.alpha * t.alpha, n }; ne.divide = function (e, t, n) { return n.red = e.red / t.red, n.green = e.green / t.green, n.blue = e.blue / t.blue, n.alpha = e.alpha / t.alpha, n }; ne.mod = function (e, t, n) { return n.red = e.red % t.red, n.green = e.green % t.green, n.blue = e.blue % t.blue, n.alpha = e.alpha % t.alpha, n }; ne.lerp = function (e, t, n, i) { return i.red = I.lerp(e.red, t.red, n), i.green = I.lerp(e.green, t.green, n), i.blue = I.lerp(e.blue, t.blue, n), i.alpha = I.lerp(e.alpha, t.alpha, n), i }; ne.multiplyByScalar = function (e, t, n) { return n.red = e.red * t, n.green = e.green * t, n.blue = e.blue * t, n.alpha = e.alpha * t, n }; ne.divideByScalar = function (e, t, n) { return n.red = e.red / t, n.green = e.green / t, n.blue = e.blue / t, n.alpha = e.alpha / t, n }; ne.ALICEBLUE = Object.freeze(ne.fromCssColorString("#F0F8FF")); ne.ANTIQUEWHITE = Object.freeze(ne.fromCssColorString("#FAEBD7")); ne.AQUA = Object.freeze(ne.fromCssColorString("#00FFFF")); ne.AQUAMARINE = Object.freeze(ne.fromCssColorString("#7FFFD4")); ne.AZURE = Object.freeze(ne.fromCssColorString("#F0FFFF")); ne.BEIGE = Object.freeze(ne.fromCssColorString("#F5F5DC")); ne.BISQUE = Object.freeze(ne.fromCssColorString("#FFE4C4")); ne.BLACK = Object.freeze(ne.fromCssColorString("#000000")); ne.BLANCHEDALMOND = Object.freeze(ne.fromCssColorString("#FFEBCD")); ne.BLUE = Object.freeze(ne.fromCssColorString("#0000FF")); ne.BLUEVIOLET = Object.freeze(ne.fromCssColorString("#8A2BE2")); ne.BROWN = Object.freeze(ne.fromCssColorString("#A52A2A")); ne.BURLYWOOD = Object.freeze(ne.fromCssColorString("#DEB887")); ne.CADETBLUE = Object.freeze(ne.fromCssColorString("#5F9EA0")); ne.CHARTREUSE = Object.freeze(ne.fromCssColorString("#7FFF00")); ne.CHOCOLATE = Object.freeze(ne.fromCssColorString("#D2691E")); ne.CORAL = Object.freeze(ne.fromCssColorString("#FF7F50")); ne.CORNFLOWERBLUE = Object.freeze(ne.fromCssColorString("#6495ED")); ne.CORNSILK = Object.freeze(ne.fromCssColorString("#FFF8DC")); ne.CRIMSON = Object.freeze(ne.fromCssColorString("#DC143C")); ne.CYAN = Object.freeze(ne.fromCssColorString("#00FFFF")); ne.DARKBLUE = Object.freeze(ne.fromCssColorString("#00008B")); ne.DARKCYAN = Object.freeze(ne.fromCssColorString("#008B8B")); ne.DARKGOLDENROD = Object.freeze(ne.fromCssColorString("#B8860B")); ne.DARKGRAY = Object.freeze(ne.fromCssColorString("#A9A9A9")); ne.DARKGREEN = Object.freeze(ne.fromCssColorString("#006400")); ne.DARKGREY = ne.DARKGRAY; ne.DARKKHAKI = Object.freeze(ne.fromCssColorString("#BDB76B")); ne.DARKMAGENTA = Object.freeze(ne.fromCssColorString("#8B008B")); ne.DARKOLIVEGREEN = Object.freeze(ne.fromCssColorString("#556B2F")); ne.DARKORANGE = Object.freeze(ne.fromCssColorString("#FF8C00")); ne.DARKORCHID = Object.freeze(ne.fromCssColorString("#9932CC")); ne.DARKRED = Object.freeze(ne.fromCssColorString("#8B0000")); ne.DARKSALMON = Object.freeze(ne.fromCssColorString("#E9967A")); ne.DARKSEAGREEN = Object.freeze(ne.fromCssColorString("#8FBC8F")); ne.DARKSLATEBLUE = Object.freeze(ne.fromCssColorString("#483D8B")); ne.DARKSLATEGRAY = Object.freeze(ne.fromCssColorString("#2F4F4F")); ne.DARKSLATEGREY = ne.DARKSLATEGRAY; ne.DARKTURQUOISE = Object.freeze(ne.fromCssColorString("#00CED1")); ne.DARKVIOLET = Object.freeze(ne.fromCssColorString("#9400D3")); ne.DEEPPINK = Object.freeze(ne.fromCssColorString("#FF1493")); ne.DEEPSKYBLUE = Object.freeze(ne.fromCssColorString("#00BFFF")); ne.DIMGRAY = Object.freeze(ne.fromCssColorString("#696969")); ne.DIMGREY = ne.DIMGRAY; ne.DODGERBLUE = Object.freeze(ne.fromCssColorString("#1E90FF")); ne.FIREBRICK = Object.freeze(ne.fromCssColorString("#B22222")); ne.FLORALWHITE = Object.freeze(ne.fromCssColorString("#FFFAF0")); ne.FORESTGREEN = Object.freeze(ne.fromCssColorString("#228B22")); ne.FUCHSIA = Object.freeze(ne.fromCssColorString("#FF00FF")); ne.GAINSBORO = Object.freeze(ne.fromCssColorString("#DCDCDC")); ne.GHOSTWHITE = Object.freeze(ne.fromCssColorString("#F8F8FF")); ne.GOLD = Object.freeze(ne.fromCssColorString("#FFD700")); ne.GOLDENROD = Object.freeze(ne.fromCssColorString("#DAA520")); ne.GRAY = Object.freeze(ne.fromCssColorString("#808080")); ne.GREEN = Object.freeze(ne.fromCssColorString("#008000")); ne.GREENYELLOW = Object.freeze(ne.fromCssColorString("#ADFF2F")); ne.GREY = ne.GRAY; ne.HONEYDEW = Object.freeze(ne.fromCssColorString("#F0FFF0")); ne.HOTPINK = Object.freeze(ne.fromCssColorString("#FF69B4")); ne.INDIANRED = Object.freeze(ne.fromCssColorString("#CD5C5C")); ne.INDIGO = Object.freeze(ne.fromCssColorString("#4B0082")); ne.IVORY = Object.freeze(ne.fromCssColorString("#FFFFF0")); ne.KHAKI = Object.freeze(ne.fromCssColorString("#F0E68C")); ne.LAVENDER = Object.freeze(ne.fromCssColorString("#E6E6FA")); ne.LAVENDAR_BLUSH = Object.freeze(ne.fromCssColorString("#FFF0F5")); ne.LAWNGREEN = Object.freeze(ne.fromCssColorString("#7CFC00")); ne.LEMONCHIFFON = Object.freeze(ne.fromCssColorString("#FFFACD")); ne.LIGHTBLUE = Object.freeze(ne.fromCssColorString("#ADD8E6")); ne.LIGHTCORAL = Object.freeze(ne.fromCssColorString("#F08080")); ne.LIGHTCYAN = Object.freeze(ne.fromCssColorString("#E0FFFF")); ne.LIGHTGOLDENRODYELLOW = Object.freeze(ne.fromCssColorString("#FAFAD2")); ne.LIGHTGRAY = Object.freeze(ne.fromCssColorString("#D3D3D3")); ne.LIGHTGREEN = Object.freeze(ne.fromCssColorString("#90EE90")); ne.LIGHTGREY = ne.LIGHTGRAY; ne.LIGHTPINK = Object.freeze(ne.fromCssColorString("#FFB6C1")); ne.LIGHTSEAGREEN = Object.freeze(ne.fromCssColorString("#20B2AA")); ne.LIGHTSKYBLUE = Object.freeze(ne.fromCssColorString("#87CEFA")); ne.LIGHTSLATEGRAY = Object.freeze(ne.fromCssColorString("#778899")); ne.LIGHTSLATEGREY = ne.LIGHTSLATEGRAY; ne.LIGHTSTEELBLUE = Object.freeze(ne.fromCssColorString("#B0C4DE")); ne.LIGHTYELLOW = Object.freeze(ne.fromCssColorString("#FFFFE0")); ne.LIME = Object.freeze(ne.fromCssColorString("#00FF00")); ne.LIMEGREEN = Object.freeze(ne.fromCssColorString("#32CD32")); ne.LINEN = Object.freeze(ne.fromCssColorString("#FAF0E6")); ne.MAGENTA = Object.freeze(ne.fromCssColorString("#FF00FF")); ne.MAROON = Object.freeze(ne.fromCssColorString("#800000")); ne.MEDIUMAQUAMARINE = Object.freeze(ne.fromCssColorString("#66CDAA")); ne.MEDIUMBLUE = Object.freeze(ne.fromCssColorString("#0000CD")); ne.MEDIUMORCHID = Object.freeze(ne.fromCssColorString("#BA55D3")); ne.MEDIUMPURPLE = Object.freeze(ne.fromCssColorString("#9370DB")); ne.MEDIUMSEAGREEN = Object.freeze(ne.fromCssColorString("#3CB371")); ne.MEDIUMSLATEBLUE = Object.freeze(ne.fromCssColorString("#7B68EE")); ne.MEDIUMSPRINGGREEN = Object.freeze(ne.fromCssColorString("#00FA9A")); ne.MEDIUMTURQUOISE = Object.freeze(ne.fromCssColorString("#48D1CC")); ne.MEDIUMVIOLETRED = Object.freeze(ne.fromCssColorString("#C71585")); ne.MIDNIGHTBLUE = Object.freeze(ne.fromCssColorString("#191970")); ne.MINTCREAM = Object.freeze(ne.fromCssColorString("#F5FFFA")); ne.MISTYROSE = Object.freeze(ne.fromCssColorString("#FFE4E1")); ne.MOCCASIN = Object.freeze(ne.fromCssColorString("#FFE4B5")); ne.NAVAJOWHITE = Object.freeze(ne.fromCssColorString("#FFDEAD")); ne.NAVY = Object.freeze(ne.fromCssColorString("#000080")); ne.OLDLACE = Object.freeze(ne.fromCssColorString("#FDF5E6")); ne.OLIVE = Object.freeze(ne.fromCssColorString("#808000")); ne.OLIVEDRAB = Object.freeze(ne.fromCssColorString("#6B8E23")); ne.ORANGE = Object.freeze(ne.fromCssColorString("#FFA500")); ne.ORANGERED = Object.freeze(ne.fromCssColorString("#FF4500")); ne.ORCHID = Object.freeze(ne.fromCssColorString("#DA70D6")); ne.PALEGOLDENROD = Object.freeze(ne.fromCssColorString("#EEE8AA")); ne.PALEGREEN = Object.freeze(ne.fromCssColorString("#98FB98")); ne.PALETURQUOISE = Object.freeze(ne.fromCssColorString("#AFEEEE")); ne.PALEVIOLETRED = Object.freeze(ne.fromCssColorString("#DB7093")); ne.PAPAYAWHIP = Object.freeze(ne.fromCssColorString("#FFEFD5")); ne.PEACHPUFF = Object.freeze(ne.fromCssColorString("#FFDAB9")); ne.PERU = Object.freeze(ne.fromCssColorString("#CD853F")); ne.PINK = Object.freeze(ne.fromCssColorString("#FFC0CB")); ne.PLUM = Object.freeze(ne.fromCssColorString("#DDA0DD")); ne.POWDERBLUE = Object.freeze(ne.fromCssColorString("#B0E0E6")); ne.PURPLE = Object.freeze(ne.fromCssColorString("#800080")); ne.RED = Object.freeze(ne.fromCssColorString("#FF0000")); ne.ROSYBROWN = Object.freeze(ne.fromCssColorString("#BC8F8F")); ne.ROYALBLUE = Object.freeze(ne.fromCssColorString("#4169E1")); ne.SADDLEBROWN = Object.freeze(ne.fromCssColorString("#8B4513")); ne.SALMON = Object.freeze(ne.fromCssColorString("#FA8072")); ne.SANDYBROWN = Object.freeze(ne.fromCssColorString("#F4A460")); ne.SEAGREEN = Object.freeze(ne.fromCssColorString("#2E8B57")); ne.SEASHELL = Object.freeze(ne.fromCssColorString("#FFF5EE")); ne.SIENNA = Object.freeze(ne.fromCssColorString("#A0522D")); ne.SILVER = Object.freeze(ne.fromCssColorString("#C0C0C0")); ne.SKYBLUE = Object.freeze(ne.fromCssColorString("#87CEEB")); ne.SLATEBLUE = Object.freeze(ne.fromCssColorString("#6A5ACD")); ne.SLATEGRAY = Object.freeze(ne.fromCssColorString("#708090")); ne.SLATEGREY = ne.SLATEGRAY; ne.SNOW = Object.freeze(ne.fromCssColorString("#FFFAFA")); ne.SPRINGGREEN = Object.freeze(ne.fromCssColorString("#00FF7F")); ne.STEELBLUE = Object.freeze(ne.fromCssColorString("#4682B4")); ne.TAN = Object.freeze(ne.fromCssColorString("#D2B48C")); ne.TEAL = Object.freeze(ne.fromCssColorString("#008080")); ne.THISTLE = Object.freeze(ne.fromCssColorString("#D8BFD8")); ne.TOMATO = Object.freeze(ne.fromCssColorString("#FF6347")); ne.TURQUOISE = Object.freeze(ne.fromCssColorString("#40E0D0")); ne.VIOLET = Object.freeze(ne.fromCssColorString("#EE82EE")); ne.WHEAT = Object.freeze(ne.fromCssColorString("#F5DEB3")); ne.WHITE = Object.freeze(ne.fromCssColorString("#FFFFFF")); ne.WHITESMOKE = Object.freeze(ne.fromCssColorString("#F5F5F5")); ne.YELLOW = Object.freeze(ne.fromCssColorString("#FFFF00")); ne.YELLOWGREEN = Object.freeze(ne.fromCssColorString("#9ACD32")); ne.TRANSPARENT = Object.freeze(new ne(0, 0, 0, 0)); var U = ne; function hAe() { return !0 } function mAe(e, t) { t = y(t, "This object was destroyed, i.e., destroy() was called."); function n() { } for (let i in e) typeof e[i] == "function" && (e[i] = n); e.isDestroyed = hAe } var le = mAe; function sl(e, t) { e = y(e, 0), this._near = e, t = y(t, Number.MAX_VALUE), this._far = t } Object.defineProperties(sl.prototype, { near: { get: function () { return this._near }, set: function (e) { this._near = e } }, far: { get: function () { return this._far }, set: function (e) { this._far = e } } }); sl.packedLength = 2; sl.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e.near, t[n] = e.far, t }; sl.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new sl), n.near = e[t++], n.far = e[t], n }; sl.equals = function (e, t) { return e === t || l(e) && l(t) && e.near === t.near && e.far === t.far }; sl.clone = function (e, t) { if (!!l(e)) return l(t) || (t = new sl), t.near = e.near, t.far = e.far, t }; sl.prototype.clone = function (e) { return sl.clone(this, e) }; sl.prototype.equals = function (e) { return sl.equals(this, e) }; var bt = sl; function Ql(e, t, n, i) { this.near = y(e, 0), this.nearValue = y(t, 0), this.far = y(n, 1), this.farValue = y(i, 0) } Ql.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.near = e.near, t.nearValue = e.nearValue, t.far = e.far, t.farValue = e.farValue, t) : new Ql(e.near, e.nearValue, e.far, e.farValue) }; Ql.packedLength = 4; Ql.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e.near, t[n++] = e.nearValue, t[n++] = e.far, t[n] = e.farValue, t }; Ql.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new Ql), n.near = e[t++], n.nearValue = e[t++], n.far = e[t++], n.farValue = e[t], n }; Ql.equals = function (e, t) { return e === t || l(e) && l(t) && e.near === t.near && e.nearValue === t.nearValue && e.far === t.far && e.farValue === t.farValue }; Ql.prototype.clone = function (e) { return Ql.clone(this, e) }; Ql.prototype.equals = function (e) { return Ql.equals(this, e) }; var wt = Ql; var pAe = { NONE: 0, CLAMP_TO_GROUND: 1, RELATIVE_TO_GROUND: 2 }, ze = Object.freeze(pAe); var _Ae = { CENTER: 0, LEFT: 1, RIGHT: -1 }, ai = Object.freeze(_Ae); var gAe = { CENTER: 0, BOTTOM: 1, BASELINE: 2, TOP: -1 }, Sn = Object.freeze(gAe); var yAe = { DONE: 0, PENDING: 1, FAILED: 2 }, rt = Object.freeze(yAe); function sf() { ye.throwInstantiationError() } Object.defineProperties(sf.prototype, { isConstant: { get: ye.throwInstantiationError }, definitionChanged: { get: ye.throwInstantiationError } }); sf.prototype.getValue = ye.throwInstantiationError; sf.prototype.equals = ye.throwInstantiationError; sf.equals = function (e, t) { return e === t || l(e) && e.equals(t) }; sf.arrayEquals = function (e, t) { if (e === t) return !0; if (!l(e) || !l(t) || e.length !== t.length) return !1; let n = e.length; for (let i = 0; i < n; i++)if (!sf.equals(e[i], t[i])) return !1; return !0 }; sf.isConstant = function (e) { return !l(e) || e.isConstant }; sf.getValueOrUndefined = function (e, t, n) { return l(e) ? e.getValue(t, n) : void 0 }; sf.getValueOrDefault = function (e, t, n, i) { return l(e) ? y(e.getValue(t, i), n) : n }; sf.getValueOrClonedDefault = function (e, t, n, i) { let o; return l(e) && (o = e.getValue(t, i)), l(o) || (o = n.clone(o)), o }; var j = sf; var AAe = U.WHITE, CAe = h.ZERO, xAe = ze.NONE, TAe = H.ZERO, EAe = 1, bAe = 0, SAe = h.ZERO, wAe = ai.CENTER, DAe = Sn.CENTER, vAe = !1, PAe = new h, IAe = new U, OAe = new h, BAe = new H, RAe = new wt, MAe = new wt, LAe = new wt, FAe = new Ge, NAe = new bt; function dY(e) { this.entity = e, this.billboard = void 0, this.textureValue = void 0 } function bp(e, t) { t.collectionChanged.addEventListener(bp.prototype._onCollectionChanged, this), this._cluster = e, this._entityCollection = t, this._items = new Ct, this._onCollectionChanged(t, t.values, [], []) } bp.prototype.update = function (e) { let t = this._items.values, n = this._cluster; for (let i = 0, o = t.length; i < o; i++) { let r = t[i], s = r.entity, a = s._billboard, c, u = r.billboard, f = s.isShowing && s.isAvailable(e) && j.getValueOrDefault(a._show, e, !0), d; if (f && (d = j.getValueOrUndefined(s._position, e, PAe), c = j.getValueOrUndefined(a._image, e), f = l(d) && l(c)), !f) { Gz(r, s, n); continue } j.isConstant(s._position) || (n._clusterDirty = !0), l(u) || (u = n.getBillboard(s), u.id = s, u.image = void 0, r.billboard = u), u.show = f, (!l(u.image) || r.textureValue !== c) && (u.image = c, r.textureValue = c), u.position = d, u.color = j.getValueOrDefault(a._color, e, AAe, IAe), u.eyeOffset = j.getValueOrDefault(a._eyeOffset, e, CAe, OAe), u.heightReference = j.getValueOrDefault(a._heightReference, e, xAe), u.pixelOffset = j.getValueOrDefault(a._pixelOffset, e, TAe, BAe), u.scale = j.getValueOrDefault(a._scale, e, EAe), u.rotation = j.getValueOrDefault(a._rotation, e, bAe), u.alignedAxis = j.getValueOrDefault(a._alignedAxis, e, SAe), u.horizontalOrigin = j.getValueOrDefault(a._horizontalOrigin, e, wAe), u.verticalOrigin = j.getValueOrDefault(a._verticalOrigin, e, DAe), u.width = j.getValueOrUndefined(a._width, e), u.height = j.getValueOrUndefined(a._height, e), u.scaleByDistance = j.getValueOrUndefined(a._scaleByDistance, e, RAe), u.translucencyByDistance = j.getValueOrUndefined(a._translucencyByDistance, e, MAe), u.pixelOffsetScaleByDistance = j.getValueOrUndefined(a._pixelOffsetScaleByDistance, e, LAe), u.sizeInMeters = j.getValueOrDefault(a._sizeInMeters, e, vAe), u.distanceDisplayCondition = j.getValueOrUndefined(a._distanceDisplayCondition, e, NAe), u.disableDepthTestDistance = j.getValueOrUndefined(a._disableDepthTestDistance, e); let p = j.getValueOrUndefined(a._imageSubRegion, e, FAe); l(p) && u.setImageSubRegion(u._imageId, p) } return !0 }; bp.prototype.getBoundingSphere = function (e, t) { let n = this._items.get(e.id); if (!l(n) || !l(n.billboard)) return rt.FAILED; let i = n.billboard; if (i.heightReference === ze.NONE) t.center = h.clone(i.position, t.center); else { if (!l(i._clampedPosition)) return rt.PENDING; t.center = h.clone(i._clampedPosition, t.center) } return t.radius = 0, rt.DONE }; bp.prototype.isDestroyed = function () { return !1 }; bp.prototype.destroy = function () { this._entityCollection.collectionChanged.removeEventListener(bp.prototype._onCollectionChanged, this); let e = this._entityCollection.values; for (let t = 0; t < e.length; t++)this._cluster.removeBillboard(e[t]); return le(this) }; bp.prototype._onCollectionChanged = function (e, t, n, i) { let o, r, s = this._items, a = this._cluster; for (o = t.length - 1; o > -1; o--)r = t[o], l(r._billboard) && l(r._position) && s.set(r.id, new dY(r)); for (o = i.length - 1; o > -1; o--)r = i[o], l(r._billboard) && l(r._position) ? s.contains(r.id) || s.set(r.id, new dY(r)) : (Gz(s.get(r.id), r, a), s.remove(r.id)); for (o = n.length - 1; o > -1; o--)r = n[o], Gz(s.get(r.id), r, a), s.remove(r.id) }; function Gz(e, t, n) { l(e) && (e.billboard = void 0, n.removeBillboard(t)) } var hP = bp; function VAe(e, t) { this.start = y(e, 0), this.stop = y(t, 0) } var Dc = VAe; function Ze(e, t, n, i, o, r, s, a, c) { this[0] = y(e, 0), this[1] = y(i, 0), this[2] = y(s, 0), this[3] = y(t, 0), this[4] = y(o, 0), this[5] = y(a, 0), this[6] = y(n, 0), this[7] = y(r, 0), this[8] = y(c, 0) } Ze.packedLength = 9; Ze.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e[0], t[n++] = e[1], t[n++] = e[2], t[n++] = e[3], t[n++] = e[4], t[n++] = e[5], t[n++] = e[6], t[n++] = e[7], t[n++] = e[8], t }; Ze.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new Ze), n[0] = e[t++], n[1] = e[t++], n[2] = e[t++], n[3] = e[t++], n[4] = e[t++], n[5] = e[t++], n[6] = e[t++], n[7] = e[t++], n[8] = e[t++], n }; Ze.packArray = function (e, t) { let n = e.length, i = n * 9; l(t) ? !Array.isArray(t) && t.length !== i || t.length !== i && (t.length = i) : t = new Array(i); for (let o = 0; o < n; ++o)Ze.pack(e[o], t, o * 9); return t }; Ze.unpackArray = function (e, t) { let n = e.length; l(t) ? t.length = n / 9 : t = new Array(n / 9); for (let i = 0; i < n; i += 9) { let o = i / 9; t[o] = Ze.unpack(e, i, t[o]) } return t }; Ze.clone = function (e, t) { if (!!l(e)) return l(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t) : new Ze(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]) }; Ze.fromArray = Ze.unpack; Ze.fromColumnMajorArray = function (e, t) { return Ze.clone(e, t) }; Ze.fromRowMajorArray = function (e, t) { return l(t) ? (t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], t) : new Ze(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]) }; Ze.fromQuaternion = function (e, t) { let n = e.x * e.x, i = e.x * e.y, o = e.x * e.z, r = e.x * e.w, s = e.y * e.y, a = e.y * e.z, c = e.y * e.w, u = e.z * e.z, f = e.z * e.w, d = e.w * e.w, p = n - s - u + d, g = 2 * (i - f), m = 2 * (o + c), A = 2 * (i + f), C = -n + s - u + d, x = 2 * (a - r), T = 2 * (o - c), b = 2 * (a + r), S = -n - s + u + d; return l(t) ? (t[0] = p, t[1] = A, t[2] = T, t[3] = g, t[4] = C, t[5] = b, t[6] = m, t[7] = x, t[8] = S, t) : new Ze(p, g, m, A, C, x, T, b, S) }; Ze.fromHeadingPitchRoll = function (e, t) { let n = Math.cos(-e.pitch), i = Math.cos(-e.heading), o = Math.cos(e.roll), r = Math.sin(-e.pitch), s = Math.sin(-e.heading), a = Math.sin(e.roll), c = n * i, u = -o * s + a * r * i, f = a * s + o * r * i, d = n * s, p = o * i + a * r * s, g = -a * i + o * r * s, m = -r, A = a * n, C = o * n; return l(t) ? (t[0] = c, t[1] = d, t[2] = m, t[3] = u, t[4] = p, t[5] = A, t[6] = f, t[7] = g, t[8] = C, t) : new Ze(c, u, f, d, p, g, m, A, C) }; Ze.fromScale = function (e, t) { return l(t) ? (t[0] = e.x, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e.y, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = e.z, t) : new Ze(e.x, 0, 0, 0, e.y, 0, 0, 0, e.z) }; Ze.fromUniformScale = function (e, t) { return l(t) ? (t[0] = e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = e, t) : new Ze(e, 0, 0, 0, e, 0, 0, 0, e) }; Ze.fromCrossProduct = function (e, t) { return l(t) ? (t[0] = 0, t[1] = e.z, t[2] = -e.y, t[3] = -e.z, t[4] = 0, t[5] = e.x, t[6] = e.y, t[7] = -e.x, t[8] = 0, t) : new Ze(0, -e.z, e.y, e.z, 0, -e.x, -e.y, e.x, 0) }; Ze.fromRotationX = function (e, t) { let n = Math.cos(e), i = Math.sin(e); return l(t) ? (t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = n, t[5] = i, t[6] = 0, t[7] = -i, t[8] = n, t) : new Ze(1, 0, 0, 0, n, -i, 0, i, n) }; Ze.fromRotationY = function (e, t) { let n = Math.cos(e), i = Math.sin(e); return l(t) ? (t[0] = n, t[1] = 0, t[2] = -i, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = i, t[7] = 0, t[8] = n, t) : new Ze(n, 0, i, 0, 1, 0, -i, 0, n) }; Ze.fromRotationZ = function (e, t) { let n = Math.cos(e), i = Math.sin(e); return l(t) ? (t[0] = n, t[1] = i, t[2] = 0, t[3] = -i, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t) : new Ze(n, -i, 0, i, n, 0, 0, 0, 1) }; Ze.toArray = function (e, t) { return l(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t) : [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]] }; Ze.getElementIndex = function (e, t) { return e * 3 + t }; Ze.getColumn = function (e, t, n) { let i = t * 3, o = e[i], r = e[i + 1], s = e[i + 2]; return n.x = o, n.y = r, n.z = s, n }; Ze.setColumn = function (e, t, n, i) { i = Ze.clone(e, i); let o = t * 3; return i[o] = n.x, i[o + 1] = n.y, i[o + 2] = n.z, i }; Ze.getRow = function (e, t, n) { let i = e[t], o = e[t + 3], r = e[t + 6]; return n.x = i, n.y = o, n.z = r, n }; Ze.setRow = function (e, t, n, i) { return i = Ze.clone(e, i), i[t] = n.x, i[t + 3] = n.y, i[t + 6] = n.z, i }; var kAe = new h; Ze.setScale = function (e, t, n) { let i = Ze.getScale(e, kAe), o = t.x / i.x, r = t.y / i.y, s = t.z / i.z; return n[0] = e[0] * o, n[1] = e[1] * o, n[2] = e[2] * o, n[3] = e[3] * r, n[4] = e[4] * r, n[5] = e[5] * r, n[6] = e[6] * s, n[7] = e[7] * s, n[8] = e[8] * s, n }; var UAe = new h; Ze.setUniformScale = function (e, t, n) { let i = Ze.getScale(e, UAe), o = t / i.x, r = t / i.y, s = t / i.z; return n[0] = e[0] * o, n[1] = e[1] * o, n[2] = e[2] * o, n[3] = e[3] * r, n[4] = e[4] * r, n[5] = e[5] * r, n[6] = e[6] * s, n[7] = e[7] * s, n[8] = e[8] * s, n }; var Wz = new h; Ze.getScale = function (e, t) { return t.x = h.magnitude(h.fromElements(e[0], e[1], e[2], Wz)), t.y = h.magnitude(h.fromElements(e[3], e[4], e[5], Wz)), t.z = h.magnitude(h.fromElements(e[6], e[7], e[8], Wz)), t }; var hY = new h; Ze.getMaximumScale = function (e) { return Ze.getScale(e, hY), h.maximumComponent(hY) }; var zAe = new h; Ze.setRotation = function (e, t, n) { let i = Ze.getScale(e, zAe); return n[0] = t[0] * i.x, n[1] = t[1] * i.x, n[2] = t[2] * i.x, n[3] = t[3] * i.y, n[4] = t[4] * i.y, n[5] = t[5] * i.y, n[6] = t[6] * i.z, n[7] = t[7] * i.z, n[8] = t[8] * i.z, n }; var HAe = new h; Ze.getRotation = function (e, t) { let n = Ze.getScale(e, HAe); return t[0] = e[0] / n.x, t[1] = e[1] / n.x, t[2] = e[2] / n.x, t[3] = e[3] / n.y, t[4] = e[4] / n.y, t[5] = e[5] / n.y, t[6] = e[6] / n.z, t[7] = e[7] / n.z, t[8] = e[8] / n.z, t }; Ze.multiply = function (e, t, n) { let i = e[0] * t[0] + e[3] * t[1] + e[6] * t[2], o = e[1] * t[0] + e[4] * t[1] + e[7] * t[2], r = e[2] * t[0] + e[5] * t[1] + e[8] * t[2], s = e[0] * t[3] + e[3] * t[4] + e[6] * t[5], a = e[1] * t[3] + e[4] * t[4] + e[7] * t[5], c = e[2] * t[3] + e[5] * t[4] + e[8] * t[5], u = e[0] * t[6] + e[3] * t[7] + e[6] * t[8], f = e[1] * t[6] + e[4] * t[7] + e[7] * t[8], d = e[2] * t[6] + e[5] * t[7] + e[8] * t[8]; return n[0] = i, n[1] = o, n[2] = r, n[3] = s, n[4] = a, n[5] = c, n[6] = u, n[7] = f, n[8] = d, n }; Ze.add = function (e, t, n) { return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n[2] = e[2] + t[2], n[3] = e[3] + t[3], n[4] = e[4] + t[4], n[5] = e[5] + t[5], n[6] = e[6] + t[6], n[7] = e[7] + t[7], n[8] = e[8] + t[8], n }; Ze.subtract = function (e, t, n) { return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n[3] = e[3] - t[3], n[4] = e[4] - t[4], n[5] = e[5] - t[5], n[6] = e[6] - t[6], n[7] = e[7] - t[7], n[8] = e[8] - t[8], n }; Ze.multiplyByVector = function (e, t, n) { let i = t.x, o = t.y, r = t.z, s = e[0] * i + e[3] * o + e[6] * r, a = e[1] * i + e[4] * o + e[7] * r, c = e[2] * i + e[5] * o + e[8] * r; return n.x = s, n.y = a, n.z = c, n }; Ze.multiplyByScalar = function (e, t, n) { return n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n[3] = e[3] * t, n[4] = e[4] * t, n[5] = e[5] * t, n[6] = e[6] * t, n[7] = e[7] * t, n[8] = e[8] * t, n }; Ze.multiplyByScale = function (e, t, n) { return n[0] = e[0] * t.x, n[1] = e[1] * t.x, n[2] = e[2] * t.x, n[3] = e[3] * t.y, n[4] = e[4] * t.y, n[5] = e[5] * t.y, n[6] = e[6] * t.z, n[7] = e[7] * t.z, n[8] = e[8] * t.z, n }; Ze.multiplyByUniformScale = function (e, t, n) { return n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n[3] = e[3] * t, n[4] = e[4] * t, n[5] = e[5] * t, n[6] = e[6] * t, n[7] = e[7] * t, n[8] = e[8] * t, n }; Ze.negate = function (e, t) { return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t[4] = -e[4], t[5] = -e[5], t[6] = -e[6], t[7] = -e[7], t[8] = -e[8], t }; Ze.transpose = function (e, t) { let n = e[0], i = e[3], o = e[6], r = e[1], s = e[4], a = e[7], c = e[2], u = e[5], f = e[8]; return t[0] = n, t[1] = i, t[2] = o, t[3] = r, t[4] = s, t[5] = a, t[6] = c, t[7] = u, t[8] = f, t }; function GAe(e) { let t = 0; for (let n = 0; n < 9; ++n) { let i = e[n]; t += i * i } return Math.sqrt(t) } var jz = [1, 0, 0], qz = [2, 2, 1]; function WAe(e) { let t = 0; for (let n = 0; n < 3; ++n) { let i = e[Ze.getElementIndex(qz[n], jz[n])]; t += 2 * i * i } return Math.sqrt(t) } function jAe(e, t) { let n = I.EPSILON15, i = 0, o = 1; for (let u = 0; u < 3; ++u) { let f = Math.abs(e[Ze.getElementIndex(qz[u], jz[u])]); f > i && (o = u, i = f) } let r = 1, s = 0, a = jz[o], c = qz[o]; if (Math.abs(e[Ze.getElementIndex(c, a)]) > n) { let u = e[Ze.getElementIndex(c, c)], f = e[Ze.getElementIndex(a, a)], d = e[Ze.getElementIndex(c, a)], p = (u - f) / 2 / d, g; p < 0 ? g = -1 / (-p + Math.sqrt(1 + p * p)) : g = 1 / (p + Math.sqrt(1 + p * p)), r = 1 / Math.sqrt(1 + g * g), s = g * r } return t = Ze.clone(Ze.IDENTITY, t), t[Ze.getElementIndex(a, a)] = t[Ze.getElementIndex(c, c)] = r, t[Ze.getElementIndex(c, a)] = s, t[Ze.getElementIndex(a, c)] = -s, t } var mP = new Ze, mY = new Ze; Ze.computeEigenDecomposition = function (e, t) { let n = I.EPSILON20, i = 10, o = 0, r = 0; l(t) || (t = {}); let s = t.unitary = Ze.clone(Ze.IDENTITY, t.unitary), a = t.diagonal = Ze.clone(e, t.diagonal), c = n * GAe(a); for (; r < i && WAe(a) > c;)jAe(a, mP), Ze.transpose(mP, mY), Ze.multiply(a, mP, a), Ze.multiply(mY, a, a), Ze.multiply(s, mP, s), ++o > 2 && (++r, o = 0); return t }; Ze.abs = function (e, t) { return t[0] = Math.abs(e[0]), t[1] = Math.abs(e[1]), t[2] = Math.abs(e[2]), t[3] = Math.abs(e[3]), t[4] = Math.abs(e[4]), t[5] = Math.abs(e[5]), t[6] = Math.abs(e[6]), t[7] = Math.abs(e[7]), t[8] = Math.abs(e[8]), t }; Ze.determinant = function (e) { let t = e[0], n = e[3], i = e[6], o = e[1], r = e[4], s = e[7], a = e[2], c = e[5], u = e[8]; return t * (r * u - c * s) + o * (c * i - n * u) + a * (n * s - r * i) }; Ze.inverse = function (e, t) { let n = e[0], i = e[1], o = e[2], r = e[3], s = e[4], a = e[5], c = e[6], u = e[7], f = e[8], d = Ze.determinant(e); t[0] = s * f - u * a, t[1] = u * o - i * f, t[2] = i * a - s * o, t[3] = c * a - r * f, t[4] = n * f - c * o, t[5] = r * o - n * a, t[6] = r * u - c * s, t[7] = c * i - n * u, t[8] = n * s - r * i; let p = 1 / d; return Ze.multiplyByScalar(t, p, t) }; var qAe = new Ze; Ze.inverseTranspose = function (e, t) { return Ze.inverse(Ze.transpose(e, qAe), t) }; Ze.equals = function (e, t) { return e === t || l(e) && l(t) && e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] }; Ze.equalsEpsilon = function (e, t, n) { return n = y(n, 0), e === t || l(e) && l(t) && Math.abs(e[0] - t[0]) <= n && Math.abs(e[1] - t[1]) <= n && Math.abs(e[2] - t[2]) <= n && Math.abs(e[3] - t[3]) <= n && Math.abs(e[4] - t[4]) <= n && Math.abs(e[5] - t[5]) <= n && Math.abs(e[6] - t[6]) <= n && Math.abs(e[7] - t[7]) <= n && Math.abs(e[8] - t[8]) <= n }; Ze.IDENTITY = Object.freeze(new Ze(1, 0, 0, 0, 1, 0, 0, 0, 1)); Ze.ZERO = Object.freeze(new Ze(0, 0, 0, 0, 0, 0, 0, 0, 0)); Ze.COLUMN0ROW0 = 0; Ze.COLUMN0ROW1 = 1; Ze.COLUMN0ROW2 = 2; Ze.COLUMN1ROW0 = 3; Ze.COLUMN1ROW1 = 4; Ze.COLUMN1ROW2 = 5; Ze.COLUMN2ROW0 = 6; Ze.COLUMN2ROW1 = 7; Ze.COLUMN2ROW2 = 8; Object.defineProperties(Ze.prototype, { length: { get: function () { return Ze.packedLength } } }); Ze.prototype.clone = function (e) { return Ze.clone(this, e) }; Ze.prototype.equals = function (e) { return Ze.equals(this, e) }; Ze.equalsArray = function (e, t, n) { return e[0] === t[n] && e[1] === t[n + 1] && e[2] === t[n + 2] && e[3] === t[n + 3] && e[4] === t[n + 4] && e[5] === t[n + 5] && e[6] === t[n + 6] && e[7] === t[n + 7] && e[8] === t[n + 8] }; Ze.prototype.equalsEpsilon = function (e, t) { return Ze.equalsEpsilon(this, e, t) }; Ze.prototype.toString = function () {
        return `(${this[0]}, ${this[3]}, ${this[6]})
(${this[1]}, ${this[4]}, ${this[7]})
(${this[2]}, ${this[5]}, ${this[8]})`
    }; var Q = Ze; function dt(e, t, n, i) { this.x = y(e, 0), this.y = y(t, 0), this.z = y(n, 0), this.w = y(i, 0) } dt.fromElements = function (e, t, n, i, o) { return l(o) ? (o.x = e, o.y = t, o.z = n, o.w = i, o) : new dt(e, t, n, i) }; dt.fromColor = function (e, t) { return l(t) ? (t.x = e.red, t.y = e.green, t.z = e.blue, t.w = e.alpha, t) : new dt(e.red, e.green, e.blue, e.alpha) }; dt.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t) : new dt(e.x, e.y, e.z, e.w) }; dt.packedLength = 4; dt.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e.x, t[n++] = e.y, t[n++] = e.z, t[n] = e.w, t }; dt.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new dt), n.x = e[t++], n.y = e[t++], n.z = e[t++], n.w = e[t], n }; dt.packArray = function (e, t) { let n = e.length, i = n * 4; l(t) ? !Array.isArray(t) && t.length !== i || t.length !== i && (t.length = i) : t = new Array(i); for (let o = 0; o < n; ++o)dt.pack(e[o], t, o * 4); return t }; dt.unpackArray = function (e, t) { let n = e.length; l(t) ? t.length = n / 4 : t = new Array(n / 4); for (let i = 0; i < n; i += 4) { let o = i / 4; t[o] = dt.unpack(e, i, t[o]) } return t }; dt.fromArray = dt.unpack; dt.maximumComponent = function (e) { return Math.max(e.x, e.y, e.z, e.w) }; dt.minimumComponent = function (e) { return Math.min(e.x, e.y, e.z, e.w) }; dt.minimumByComponent = function (e, t, n) { return n.x = Math.min(e.x, t.x), n.y = Math.min(e.y, t.y), n.z = Math.min(e.z, t.z), n.w = Math.min(e.w, t.w), n }; dt.maximumByComponent = function (e, t, n) { return n.x = Math.max(e.x, t.x), n.y = Math.max(e.y, t.y), n.z = Math.max(e.z, t.z), n.w = Math.max(e.w, t.w), n }; dt.clamp = function (e, t, n, i) { let o = I.clamp(e.x, t.x, n.x), r = I.clamp(e.y, t.y, n.y), s = I.clamp(e.z, t.z, n.z), a = I.clamp(e.w, t.w, n.w); return i.x = o, i.y = r, i.z = s, i.w = a, i }; dt.magnitudeSquared = function (e) { return e.x * e.x + e.y * e.y + e.z * e.z + e.w * e.w }; dt.magnitude = function (e) { return Math.sqrt(dt.magnitudeSquared(e)) }; var pP = new dt; dt.distance = function (e, t) { return dt.subtract(e, t, pP), dt.magnitude(pP) }; dt.distanceSquared = function (e, t) { return dt.subtract(e, t, pP), dt.magnitudeSquared(pP) }; dt.normalize = function (e, t) { let n = dt.magnitude(e); return t.x = e.x / n, t.y = e.y / n, t.z = e.z / n, t.w = e.w / n, t }; dt.dot = function (e, t) { return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w }; dt.multiplyComponents = function (e, t, n) { return n.x = e.x * t.x, n.y = e.y * t.y, n.z = e.z * t.z, n.w = e.w * t.w, n }; dt.divideComponents = function (e, t, n) { return n.x = e.x / t.x, n.y = e.y / t.y, n.z = e.z / t.z, n.w = e.w / t.w, n }; dt.add = function (e, t, n) { return n.x = e.x + t.x, n.y = e.y + t.y, n.z = e.z + t.z, n.w = e.w + t.w, n }; dt.subtract = function (e, t, n) { return n.x = e.x - t.x, n.y = e.y - t.y, n.z = e.z - t.z, n.w = e.w - t.w, n }; dt.multiplyByScalar = function (e, t, n) { return n.x = e.x * t, n.y = e.y * t, n.z = e.z * t, n.w = e.w * t, n }; dt.divideByScalar = function (e, t, n) { return n.x = e.x / t, n.y = e.y / t, n.z = e.z / t, n.w = e.w / t, n }; dt.negate = function (e, t) { return t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = -e.w, t }; dt.abs = function (e, t) { return t.x = Math.abs(e.x), t.y = Math.abs(e.y), t.z = Math.abs(e.z), t.w = Math.abs(e.w), t }; var pY = new dt; dt.lerp = function (e, t, n, i) { return dt.multiplyByScalar(t, n, pY), i = dt.multiplyByScalar(e, 1 - n, i), dt.add(pY, i, i) }; var YAe = new dt; dt.mostOrthogonalAxis = function (e, t) { let n = dt.normalize(e, YAe); return dt.abs(n, n), n.x <= n.y ? n.x <= n.z ? n.x <= n.w ? t = dt.clone(dt.UNIT_X, t) : t = dt.clone(dt.UNIT_W, t) : n.z <= n.w ? t = dt.clone(dt.UNIT_Z, t) : t = dt.clone(dt.UNIT_W, t) : n.y <= n.z ? n.y <= n.w ? t = dt.clone(dt.UNIT_Y, t) : t = dt.clone(dt.UNIT_W, t) : n.z <= n.w ? t = dt.clone(dt.UNIT_Z, t) : t = dt.clone(dt.UNIT_W, t), t }; dt.equals = function (e, t) { return e === t || l(e) && l(t) && e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w }; dt.equalsArray = function (e, t, n) { return e.x === t[n] && e.y === t[n + 1] && e.z === t[n + 2] && e.w === t[n + 3] }; dt.equalsEpsilon = function (e, t, n, i) { return e === t || l(e) && l(t) && I.equalsEpsilon(e.x, t.x, n, i) && I.equalsEpsilon(e.y, t.y, n, i) && I.equalsEpsilon(e.z, t.z, n, i) && I.equalsEpsilon(e.w, t.w, n, i) }; dt.ZERO = Object.freeze(new dt(0, 0, 0, 0)); dt.ONE = Object.freeze(new dt(1, 1, 1, 1)); dt.UNIT_X = Object.freeze(new dt(1, 0, 0, 0)); dt.UNIT_Y = Object.freeze(new dt(0, 1, 0, 0)); dt.UNIT_Z = Object.freeze(new dt(0, 0, 1, 0)); dt.UNIT_W = Object.freeze(new dt(0, 0, 0, 1)); dt.prototype.clone = function (e) { return dt.clone(this, e) }; dt.prototype.equals = function (e) { return dt.equals(this, e) }; dt.prototype.equalsEpsilon = function (e, t, n) { return dt.equalsEpsilon(this, e, t, n) }; dt.prototype.toString = function () { return `(${this.x}, ${this.y}, ${this.z}, ${this.w})` }; var Yz = new Float32Array(1), fa = new Uint8Array(Yz.buffer), XAe = new Uint32Array([287454020]), KAe = new Uint8Array(XAe.buffer), _Y = KAe[0] === 68; dt.packFloat = function (e, t) { return l(t) || (t = new dt), Yz[0] = e, _Y ? (t.x = fa[0], t.y = fa[1], t.z = fa[2], t.w = fa[3]) : (t.x = fa[3], t.y = fa[2], t.z = fa[1], t.w = fa[0]), t }; dt.unpackFloat = function (e) { return _Y ? (fa[0] = e.x, fa[1] = e.y, fa[2] = e.z, fa[3] = e.w) : (fa[0] = e.w, fa[1] = e.z, fa[2] = e.y, fa[3] = e.x), Yz[0] }; var se = dt; function rb(e) { this.name = "RuntimeError", this.message = e; let t; try { throw new Error } catch (n) { t = n.stack } this.stack = t } l(Object.create) && (rb.prototype = Object.create(Error.prototype), rb.prototype.constructor = rb); rb.prototype.toString = function () {
        let e = `${this.name}: ${this.message}`; return l(this.stack) && (e += `
${this.stack.toString()}`), e
    }; var fe = rb; function Xe(e, t, n, i, o, r, s, a, c, u, f, d, p, g, m, A) { this[0] = y(e, 0), this[1] = y(o, 0), this[2] = y(c, 0), this[3] = y(p, 0), this[4] = y(t, 0), this[5] = y(r, 0), this[6] = y(u, 0), this[7] = y(g, 0), this[8] = y(n, 0), this[9] = y(s, 0), this[10] = y(f, 0), this[11] = y(m, 0), this[12] = y(i, 0), this[13] = y(a, 0), this[14] = y(d, 0), this[15] = y(A, 0) } Xe.packedLength = 16; Xe.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e[0], t[n++] = e[1], t[n++] = e[2], t[n++] = e[3], t[n++] = e[4], t[n++] = e[5], t[n++] = e[6], t[n++] = e[7], t[n++] = e[8], t[n++] = e[9], t[n++] = e[10], t[n++] = e[11], t[n++] = e[12], t[n++] = e[13], t[n++] = e[14], t[n] = e[15], t }; Xe.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new Xe), n[0] = e[t++], n[1] = e[t++], n[2] = e[t++], n[3] = e[t++], n[4] = e[t++], n[5] = e[t++], n[6] = e[t++], n[7] = e[t++], n[8] = e[t++], n[9] = e[t++], n[10] = e[t++], n[11] = e[t++], n[12] = e[t++], n[13] = e[t++], n[14] = e[t++], n[15] = e[t], n }; Xe.packArray = function (e, t) { let n = e.length, i = n * 16; l(t) ? !Array.isArray(t) && t.length !== i || t.length !== i && (t.length = i) : t = new Array(i); for (let o = 0; o < n; ++o)Xe.pack(e[o], t, o * 16); return t }; Xe.unpackArray = function (e, t) { let n = e.length; l(t) ? t.length = n / 16 : t = new Array(n / 16); for (let i = 0; i < n; i += 16) { let o = i / 16; t[o] = Xe.unpack(e, i, t[o]) } return t }; Xe.clone = function (e, t) { if (!!l(e)) return l(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t) : new Xe(e[0], e[4], e[8], e[12], e[1], e[5], e[9], e[13], e[2], e[6], e[10], e[14], e[3], e[7], e[11], e[15]) }; Xe.fromArray = Xe.unpack; Xe.fromColumnMajorArray = function (e, t) { return Xe.clone(e, t) }; Xe.fromRowMajorArray = function (e, t) { return l(t) ? (t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15], t) : new Xe(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]) }; Xe.fromRotationTranslation = function (e, t, n) { return t = y(t, h.ZERO), l(n) ? (n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = 0, n[4] = e[3], n[5] = e[4], n[6] = e[5], n[7] = 0, n[8] = e[6], n[9] = e[7], n[10] = e[8], n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, n) : new Xe(e[0], e[3], e[6], t.x, e[1], e[4], e[7], t.y, e[2], e[5], e[8], t.z, 0, 0, 0, 1) }; Xe.fromTranslationQuaternionRotationScale = function (e, t, n, i) { l(i) || (i = new Xe); let o = n.x, r = n.y, s = n.z, a = t.x * t.x, c = t.x * t.y, u = t.x * t.z, f = t.x * t.w, d = t.y * t.y, p = t.y * t.z, g = t.y * t.w, m = t.z * t.z, A = t.z * t.w, C = t.w * t.w, x = a - d - m + C, T = 2 * (c - A), b = 2 * (u + g), S = 2 * (c + A), D = -a + d - m + C, P = 2 * (p - f), B = 2 * (u - g), R = 2 * (p + f), M = -a - d + m + C; return i[0] = x * o, i[1] = S * o, i[2] = B * o, i[3] = 0, i[4] = T * r, i[5] = D * r, i[6] = R * r, i[7] = 0, i[8] = b * s, i[9] = P * s, i[10] = M * s, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, i }; Xe.fromTranslationRotationScale = function (e, t) { return Xe.fromTranslationQuaternionRotationScale(e.translation, e.rotation, e.scale, t) }; Xe.fromTranslation = function (e, t) { return Xe.fromRotationTranslation(Q.IDENTITY, e, t) }; Xe.fromScale = function (e, t) { return l(t) ? (t[0] = e.x, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e.y, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e.z, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t) : new Xe(e.x, 0, 0, 0, 0, e.y, 0, 0, 0, 0, e.z, 0, 0, 0, 0, 1) }; Xe.fromUniformScale = function (e, t) { return l(t) ? (t[0] = e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t) : new Xe(e, 0, 0, 0, 0, e, 0, 0, 0, 0, e, 0, 0, 0, 0, 1) }; Xe.fromRotation = function (e, t) { return l(t) || (t = new Xe), t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = 0, t[4] = e[3], t[5] = e[4], t[6] = e[5], t[7] = 0, t[8] = e[6], t[9] = e[7], t[10] = e[8], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t }; var kA = new h, UA = new h, sb = new h; Xe.fromCamera = function (e, t) { let n = e.position, i = e.direction, o = e.up; h.normalize(i, kA), h.normalize(h.cross(kA, o, UA), UA), h.normalize(h.cross(UA, kA, sb), sb); let r = UA.x, s = UA.y, a = UA.z, c = kA.x, u = kA.y, f = kA.z, d = sb.x, p = sb.y, g = sb.z, m = n.x, A = n.y, C = n.z, x = r * -m + s * -A + a * -C, T = d * -m + p * -A + g * -C, b = c * m + u * A + f * C; return l(t) ? (t[0] = r, t[1] = d, t[2] = -c, t[3] = 0, t[4] = s, t[5] = p, t[6] = -u, t[7] = 0, t[8] = a, t[9] = g, t[10] = -f, t[11] = 0, t[12] = x, t[13] = T, t[14] = b, t[15] = 1, t) : new Xe(r, s, a, x, d, p, g, T, -c, -u, -f, b, 0, 0, 0, 1) }; Xe.computePerspectiveFieldOfView = function (e, t, n, i, o) { let r = Math.tan(e * .5), s = 1 / r, a = s / t, c = (i + n) / (n - i), u = 2 * i * n / (n - i); return o[0] = a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = s, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = c, o[11] = -1, o[12] = 0, o[13] = 0, o[14] = u, o[15] = 0, o }; Xe.computeOrthographicOffCenter = function (e, t, n, i, o, r, s) { let a = 1 / (t - e), c = 1 / (i - n), u = 1 / (r - o), f = -(t + e) * a, d = -(i + n) * c, p = -(r + o) * u; return a *= 2, c *= 2, u *= -2, s[0] = a, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = c, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = u, s[11] = 0, s[12] = f, s[13] = d, s[14] = p, s[15] = 1, s }; Xe.computePerspectiveOffCenter = function (e, t, n, i, o, r, s) { let a = 2 * o / (t - e), c = 2 * o / (i - n), u = (t + e) / (t - e), f = (i + n) / (i - n), d = -(r + o) / (r - o), p = -1, g = -2 * r * o / (r - o); return s[0] = a, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = c, s[6] = 0, s[7] = 0, s[8] = u, s[9] = f, s[10] = d, s[11] = p, s[12] = 0, s[13] = 0, s[14] = g, s[15] = 0, s }; Xe.computeInfinitePerspectiveOffCenter = function (e, t, n, i, o, r) { let s = 2 * o / (t - e), a = 2 * o / (i - n), c = (t + e) / (t - e), u = (i + n) / (i - n), f = -1, d = -1, p = -2 * o; return r[0] = s, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = a, r[6] = 0, r[7] = 0, r[8] = c, r[9] = u, r[10] = f, r[11] = d, r[12] = 0, r[13] = 0, r[14] = p, r[15] = 0, r }; Xe.computeViewportTransformation = function (e, t, n, i) { l(i) || (i = new Xe), e = y(e, y.EMPTY_OBJECT); let o = y(e.x, 0), r = y(e.y, 0), s = y(e.width, 0), a = y(e.height, 0); t = y(t, 0), n = y(n, 1); let c = s * .5, u = a * .5, f = (n - t) * .5, d = c, p = u, g = f, m = o + c, A = r + u, C = t + f, x = 1; return i[0] = d, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = p, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = g, i[11] = 0, i[12] = m, i[13] = A, i[14] = C, i[15] = x, i }; Xe.computeView = function (e, t, n, i, o) { return o[0] = i.x, o[1] = n.x, o[2] = -t.x, o[3] = 0, o[4] = i.y, o[5] = n.y, o[6] = -t.y, o[7] = 0, o[8] = i.z, o[9] = n.z, o[10] = -t.z, o[11] = 0, o[12] = -h.dot(i, e), o[13] = -h.dot(n, e), o[14] = h.dot(t, e), o[15] = 1, o }; Xe.toArray = function (e, t) { return l(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t) : [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]] }; Xe.getElementIndex = function (e, t) { return e * 4 + t }; Xe.getColumn = function (e, t, n) { let i = t * 4, o = e[i], r = e[i + 1], s = e[i + 2], a = e[i + 3]; return n.x = o, n.y = r, n.z = s, n.w = a, n }; Xe.setColumn = function (e, t, n, i) { i = Xe.clone(e, i); let o = t * 4; return i[o] = n.x, i[o + 1] = n.y, i[o + 2] = n.z, i[o + 3] = n.w, i }; Xe.getRow = function (e, t, n) { let i = e[t], o = e[t + 4], r = e[t + 8], s = e[t + 12]; return n.x = i, n.y = o, n.z = r, n.w = s, n }; Xe.setRow = function (e, t, n, i) { return i = Xe.clone(e, i), i[t] = n.x, i[t + 4] = n.y, i[t + 8] = n.z, i[t + 12] = n.w, i }; Xe.setTranslation = function (e, t, n) { return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4], n[5] = e[5], n[6] = e[6], n[7] = e[7], n[8] = e[8], n[9] = e[9], n[10] = e[10], n[11] = e[11], n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = e[15], n }; var JAe = new h; Xe.setScale = function (e, t, n) { let i = Xe.getScale(e, JAe), o = t.x / i.x, r = t.y / i.y, s = t.z / i.z; return n[0] = e[0] * o, n[1] = e[1] * o, n[2] = e[2] * o, n[3] = e[3], n[4] = e[4] * r, n[5] = e[5] * r, n[6] = e[6] * r, n[7] = e[7], n[8] = e[8] * s, n[9] = e[9] * s, n[10] = e[10] * s, n[11] = e[11], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n }; var ZAe = new h; Xe.setUniformScale = function (e, t, n) { let i = Xe.getScale(e, ZAe), o = t / i.x, r = t / i.y, s = t / i.z; return n[0] = e[0] * o, n[1] = e[1] * o, n[2] = e[2] * o, n[3] = e[3], n[4] = e[4] * r, n[5] = e[5] * r, n[6] = e[6] * r, n[7] = e[7], n[8] = e[8] * s, n[9] = e[9] * s, n[10] = e[10] * s, n[11] = e[11], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n }; var Xz = new h; Xe.getScale = function (e, t) { return t.x = h.magnitude(h.fromElements(e[0], e[1], e[2], Xz)), t.y = h.magnitude(h.fromElements(e[4], e[5], e[6], Xz)), t.z = h.magnitude(h.fromElements(e[8], e[9], e[10], Xz)), t }; var gY = new h; Xe.getMaximumScale = function (e) { return Xe.getScale(e, gY), h.maximumComponent(gY) }; var QAe = new h; Xe.setRotation = function (e, t, n) { let i = Xe.getScale(e, QAe); return n[0] = t[0] * i.x, n[1] = t[1] * i.x, n[2] = t[2] * i.x, n[3] = e[3], n[4] = t[3] * i.y, n[5] = t[4] * i.y, n[6] = t[5] * i.y, n[7] = e[7], n[8] = t[6] * i.z, n[9] = t[7] * i.z, n[10] = t[8] * i.z, n[11] = e[11], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n }; var $Ae = new h; Xe.getRotation = function (e, t) { let n = Xe.getScale(e, $Ae); return t[0] = e[0] / n.x, t[1] = e[1] / n.x, t[2] = e[2] / n.x, t[3] = e[4] / n.y, t[4] = e[5] / n.y, t[5] = e[6] / n.y, t[6] = e[8] / n.z, t[7] = e[9] / n.z, t[8] = e[10] / n.z, t }; Xe.multiply = function (e, t, n) { let i = e[0], o = e[1], r = e[2], s = e[3], a = e[4], c = e[5], u = e[6], f = e[7], d = e[8], p = e[9], g = e[10], m = e[11], A = e[12], C = e[13], x = e[14], T = e[15], b = t[0], S = t[1], D = t[2], P = t[3], B = t[4], R = t[5], M = t[6], L = t[7], _ = t[8], E = t[9], w = t[10], v = t[11], O = t[12], V = t[13], z = t[14], k = t[15], G = i * b + a * S + d * D + A * P, N = o * b + c * S + p * D + C * P, X = r * b + u * S + g * D + x * P, q = s * b + f * S + m * D + T * P, J = i * B + a * R + d * M + A * L, W = o * B + c * R + p * M + C * L, K = r * B + u * R + g * M + x * L, Z = s * B + f * R + m * M + T * L, de = i * _ + a * E + d * w + A * v, pe = o * _ + c * E + p * w + C * v, oe = r * _ + u * E + g * w + x * v, ue = s * _ + f * E + m * w + T * v, ge = i * O + a * V + d * z + A * k, Ee = o * O + c * V + p * z + C * k, Ie = r * O + u * V + g * z + x * k, Fe = s * O + f * V + m * z + T * k; return n[0] = G, n[1] = N, n[2] = X, n[3] = q, n[4] = J, n[5] = W, n[6] = K, n[7] = Z, n[8] = de, n[9] = pe, n[10] = oe, n[11] = ue, n[12] = ge, n[13] = Ee, n[14] = Ie, n[15] = Fe, n }; Xe.add = function (e, t, n) { return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n[2] = e[2] + t[2], n[3] = e[3] + t[3], n[4] = e[4] + t[4], n[5] = e[5] + t[5], n[6] = e[6] + t[6], n[7] = e[7] + t[7], n[8] = e[8] + t[8], n[9] = e[9] + t[9], n[10] = e[10] + t[10], n[11] = e[11] + t[11], n[12] = e[12] + t[12], n[13] = e[13] + t[13], n[14] = e[14] + t[14], n[15] = e[15] + t[15], n }; Xe.subtract = function (e, t, n) { return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n[3] = e[3] - t[3], n[4] = e[4] - t[4], n[5] = e[5] - t[5], n[6] = e[6] - t[6], n[7] = e[7] - t[7], n[8] = e[8] - t[8], n[9] = e[9] - t[9], n[10] = e[10] - t[10], n[11] = e[11] - t[11], n[12] = e[12] - t[12], n[13] = e[13] - t[13], n[14] = e[14] - t[14], n[15] = e[15] - t[15], n }; Xe.multiplyTransformation = function (e, t, n) { let i = e[0], o = e[1], r = e[2], s = e[4], a = e[5], c = e[6], u = e[8], f = e[9], d = e[10], p = e[12], g = e[13], m = e[14], A = t[0], C = t[1], x = t[2], T = t[4], b = t[5], S = t[6], D = t[8], P = t[9], B = t[10], R = t[12], M = t[13], L = t[14], _ = i * A + s * C + u * x, E = o * A + a * C + f * x, w = r * A + c * C + d * x, v = i * T + s * b + u * S, O = o * T + a * b + f * S, V = r * T + c * b + d * S, z = i * D + s * P + u * B, k = o * D + a * P + f * B, G = r * D + c * P + d * B, N = i * R + s * M + u * L + p, X = o * R + a * M + f * L + g, q = r * R + c * M + d * L + m; return n[0] = _, n[1] = E, n[2] = w, n[3] = 0, n[4] = v, n[5] = O, n[6] = V, n[7] = 0, n[8] = z, n[9] = k, n[10] = G, n[11] = 0, n[12] = N, n[13] = X, n[14] = q, n[15] = 1, n }; Xe.multiplyByMatrix3 = function (e, t, n) { let i = e[0], o = e[1], r = e[2], s = e[4], a = e[5], c = e[6], u = e[8], f = e[9], d = e[10], p = t[0], g = t[1], m = t[2], A = t[3], C = t[4], x = t[5], T = t[6], b = t[7], S = t[8], D = i * p + s * g + u * m, P = o * p + a * g + f * m, B = r * p + c * g + d * m, R = i * A + s * C + u * x, M = o * A + a * C + f * x, L = r * A + c * C + d * x, _ = i * T + s * b + u * S, E = o * T + a * b + f * S, w = r * T + c * b + d * S; return n[0] = D, n[1] = P, n[2] = B, n[3] = 0, n[4] = R, n[5] = M, n[6] = L, n[7] = 0, n[8] = _, n[9] = E, n[10] = w, n[11] = 0, n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n }; Xe.multiplyByTranslation = function (e, t, n) { let i = t.x, o = t.y, r = t.z, s = i * e[0] + o * e[4] + r * e[8] + e[12], a = i * e[1] + o * e[5] + r * e[9] + e[13], c = i * e[2] + o * e[6] + r * e[10] + e[14]; return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4], n[5] = e[5], n[6] = e[6], n[7] = e[7], n[8] = e[8], n[9] = e[9], n[10] = e[10], n[11] = e[11], n[12] = s, n[13] = a, n[14] = c, n[15] = e[15], n }; Xe.multiplyByScale = function (e, t, n) { let i = t.x, o = t.y, r = t.z; return i === 1 && o === 1 && r === 1 ? Xe.clone(e, n) : (n[0] = i * e[0], n[1] = i * e[1], n[2] = i * e[2], n[3] = e[3], n[4] = o * e[4], n[5] = o * e[5], n[6] = o * e[6], n[7] = e[7], n[8] = r * e[8], n[9] = r * e[9], n[10] = r * e[10], n[11] = e[11], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n) }; Xe.multiplyByUniformScale = function (e, t, n) { return n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n[3] = e[3], n[4] = e[4] * t, n[5] = e[5] * t, n[6] = e[6] * t, n[7] = e[7], n[8] = e[8] * t, n[9] = e[9] * t, n[10] = e[10] * t, n[11] = e[11], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n }; Xe.multiplyByVector = function (e, t, n) { let i = t.x, o = t.y, r = t.z, s = t.w, a = e[0] * i + e[4] * o + e[8] * r + e[12] * s, c = e[1] * i + e[5] * o + e[9] * r + e[13] * s, u = e[2] * i + e[6] * o + e[10] * r + e[14] * s, f = e[3] * i + e[7] * o + e[11] * r + e[15] * s; return n.x = a, n.y = c, n.z = u, n.w = f, n }; Xe.multiplyByPointAsVector = function (e, t, n) { let i = t.x, o = t.y, r = t.z, s = e[0] * i + e[4] * o + e[8] * r, a = e[1] * i + e[5] * o + e[9] * r, c = e[2] * i + e[6] * o + e[10] * r; return n.x = s, n.y = a, n.z = c, n }; Xe.multiplyByPoint = function (e, t, n) { let i = t.x, o = t.y, r = t.z, s = e[0] * i + e[4] * o + e[8] * r + e[12], a = e[1] * i + e[5] * o + e[9] * r + e[13], c = e[2] * i + e[6] * o + e[10] * r + e[14]; return n.x = s, n.y = a, n.z = c, n }; Xe.multiplyByScalar = function (e, t, n) { return n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n[3] = e[3] * t, n[4] = e[4] * t, n[5] = e[5] * t, n[6] = e[6] * t, n[7] = e[7] * t, n[8] = e[8] * t, n[9] = e[9] * t, n[10] = e[10] * t, n[11] = e[11] * t, n[12] = e[12] * t, n[13] = e[13] * t, n[14] = e[14] * t, n[15] = e[15] * t, n }; Xe.negate = function (e, t) { return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t[4] = -e[4], t[5] = -e[5], t[6] = -e[6], t[7] = -e[7], t[8] = -e[8], t[9] = -e[9], t[10] = -e[10], t[11] = -e[11], t[12] = -e[12], t[13] = -e[13], t[14] = -e[14], t[15] = -e[15], t }; Xe.transpose = function (e, t) { let n = e[1], i = e[2], o = e[3], r = e[6], s = e[7], a = e[11]; return t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = n, t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = i, t[9] = r, t[10] = e[10], t[11] = e[14], t[12] = o, t[13] = s, t[14] = a, t[15] = e[15], t }; Xe.abs = function (e, t) { return t[0] = Math.abs(e[0]), t[1] = Math.abs(e[1]), t[2] = Math.abs(e[2]), t[3] = Math.abs(e[3]), t[4] = Math.abs(e[4]), t[5] = Math.abs(e[5]), t[6] = Math.abs(e[6]), t[7] = Math.abs(e[7]), t[8] = Math.abs(e[8]), t[9] = Math.abs(e[9]), t[10] = Math.abs(e[10]), t[11] = Math.abs(e[11]), t[12] = Math.abs(e[12]), t[13] = Math.abs(e[13]), t[14] = Math.abs(e[14]), t[15] = Math.abs(e[15]), t }; Xe.equals = function (e, t) { return e === t || l(e) && l(t) && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[3] === t[3] && e[7] === t[7] && e[11] === t[11] && e[15] === t[15] }; Xe.equalsEpsilon = function (e, t, n) { return n = y(n, 0), e === t || l(e) && l(t) && Math.abs(e[0] - t[0]) <= n && Math.abs(e[1] - t[1]) <= n && Math.abs(e[2] - t[2]) <= n && Math.abs(e[3] - t[3]) <= n && Math.abs(e[4] - t[4]) <= n && Math.abs(e[5] - t[5]) <= n && Math.abs(e[6] - t[6]) <= n && Math.abs(e[7] - t[7]) <= n && Math.abs(e[8] - t[8]) <= n && Math.abs(e[9] - t[9]) <= n && Math.abs(e[10] - t[10]) <= n && Math.abs(e[11] - t[11]) <= n && Math.abs(e[12] - t[12]) <= n && Math.abs(e[13] - t[13]) <= n && Math.abs(e[14] - t[14]) <= n && Math.abs(e[15] - t[15]) <= n }; Xe.getTranslation = function (e, t) { return t.x = e[12], t.y = e[13], t.z = e[14], t }; Xe.getMatrix3 = function (e, t) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t }; var eCe = new Q, tCe = new Q, nCe = new se, iCe = new se(0, 0, 0, 1); Xe.inverse = function (e, t) { let n = e[0], i = e[4], o = e[8], r = e[12], s = e[1], a = e[5], c = e[9], u = e[13], f = e[2], d = e[6], p = e[10], g = e[14], m = e[3], A = e[7], C = e[11], x = e[15], T = p * x, b = g * C, S = d * x, D = g * A, P = d * C, B = p * A, R = f * x, M = g * m, L = f * C, _ = p * m, E = f * A, w = d * m, v = T * a + D * c + P * u - (b * a + S * c + B * u), O = b * s + R * c + _ * u - (T * s + M * c + L * u), V = S * s + M * a + E * u - (D * s + R * a + w * u), z = B * s + L * a + w * c - (P * s + _ * a + E * c), k = b * i + S * o + B * r - (T * i + D * o + P * r), G = T * n + M * o + L * r - (b * n + R * o + _ * r), N = D * n + R * i + w * r - (S * n + M * i + E * r), X = P * n + _ * i + E * o - (B * n + L * i + w * o); T = o * u, b = r * c, S = i * u, D = r * a, P = i * c, B = o * a, R = n * u, M = r * s, L = n * c, _ = o * s, E = n * a, w = i * s; let q = T * A + D * C + P * x - (b * A + S * C + B * x), J = b * m + R * C + _ * x - (T * m + M * C + L * x), W = S * m + M * A + E * x - (D * m + R * A + w * x), K = B * m + L * A + w * C - (P * m + _ * A + E * C), Z = S * p + B * g + b * d - (P * g + T * d + D * p), de = L * g + T * f + M * p - (R * p + _ * g + b * f), pe = R * d + w * g + D * f - (E * g + S * f + M * d), oe = E * p + P * f + _ * d - (L * d + w * p + B * f), ue = n * v + i * O + o * V + r * z; if (Math.abs(ue) < I.EPSILON21) { if (Q.equalsEpsilon(Xe.getMatrix3(e, eCe), tCe, I.EPSILON7) && se.equals(Xe.getRow(e, 3, nCe), iCe)) return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 0, t[11] = 0, t[12] = -e[12], t[13] = -e[13], t[14] = -e[14], t[15] = 1, t; throw new fe("matrix is not invertible because its determinate is zero.") } return ue = 1 / ue, t[0] = v * ue, t[1] = O * ue, t[2] = V * ue, t[3] = z * ue, t[4] = k * ue, t[5] = G * ue, t[6] = N * ue, t[7] = X * ue, t[8] = q * ue, t[9] = J * ue, t[10] = W * ue, t[11] = K * ue, t[12] = Z * ue, t[13] = de * ue, t[14] = pe * ue, t[15] = oe * ue, t }; Xe.inverseTransformation = function (e, t) { let n = e[0], i = e[1], o = e[2], r = e[4], s = e[5], a = e[6], c = e[8], u = e[9], f = e[10], d = e[12], p = e[13], g = e[14], m = -n * d - i * p - o * g, A = -r * d - s * p - a * g, C = -c * d - u * p - f * g; return t[0] = n, t[1] = r, t[2] = c, t[3] = 0, t[4] = i, t[5] = s, t[6] = u, t[7] = 0, t[8] = o, t[9] = a, t[10] = f, t[11] = 0, t[12] = m, t[13] = A, t[14] = C, t[15] = 1, t }; var oCe = new Xe; Xe.inverseTranspose = function (e, t) { return Xe.inverse(Xe.transpose(e, oCe), t) }; Xe.IDENTITY = Object.freeze(new Xe(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)); Xe.ZERO = Object.freeze(new Xe(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)); Xe.COLUMN0ROW0 = 0; Xe.COLUMN0ROW1 = 1; Xe.COLUMN0ROW2 = 2; Xe.COLUMN0ROW3 = 3; Xe.COLUMN1ROW0 = 4; Xe.COLUMN1ROW1 = 5; Xe.COLUMN1ROW2 = 6; Xe.COLUMN1ROW3 = 7; Xe.COLUMN2ROW0 = 8; Xe.COLUMN2ROW1 = 9; Xe.COLUMN2ROW2 = 10; Xe.COLUMN2ROW3 = 11; Xe.COLUMN3ROW0 = 12; Xe.COLUMN3ROW1 = 13; Xe.COLUMN3ROW2 = 14; Xe.COLUMN3ROW3 = 15; Object.defineProperties(Xe.prototype, { length: { get: function () { return Xe.packedLength } } }); Xe.prototype.clone = function (e) { return Xe.clone(this, e) }; Xe.prototype.equals = function (e) { return Xe.equals(this, e) }; Xe.equalsArray = function (e, t, n) { return e[0] === t[n] && e[1] === t[n + 1] && e[2] === t[n + 2] && e[3] === t[n + 3] && e[4] === t[n + 4] && e[5] === t[n + 5] && e[6] === t[n + 6] && e[7] === t[n + 7] && e[8] === t[n + 8] && e[9] === t[n + 9] && e[10] === t[n + 10] && e[11] === t[n + 11] && e[12] === t[n + 12] && e[13] === t[n + 13] && e[14] === t[n + 14] && e[15] === t[n + 15] }; Xe.prototype.equalsEpsilon = function (e, t) { return Xe.equalsEpsilon(this, e, t) }; Xe.prototype.toString = function () {
        return `(${this[0]}, ${this[4]}, ${this[8]}, ${this[12]})
(${this[1]}, ${this[5]}, ${this[9]}, ${this[13]})
(${this[2]}, ${this[6]}, ${this[10]}, ${this[14]})
(${this[3]}, ${this[7]}, ${this[11]}, ${this[15]})`
    }; var F = Xe; function rn(e, t) { this.center = h.clone(y(e, h.ZERO)), this.radius = y(t, 0) } var Zz = new h, Qz = new h, $z = new h, eH = new h, tH = new h, nH = new h, iH = new h, ys = new h, oH = new h, rH = new h, sH = new h, aH = new h, rCe = 4 / 3 * I.PI; rn.fromPoints = function (e, t) { if (l(t) || (t = new rn), !l(e) || e.length === 0) return t.center = h.clone(h.ZERO, t.center), t.radius = 0, t; let n = h.clone(e[0], iH), i = h.clone(n, Zz), o = h.clone(n, Qz), r = h.clone(n, $z), s = h.clone(n, eH), a = h.clone(n, tH), c = h.clone(n, nH), u = e.length, f; for (f = 1; f < u; f++) { h.clone(e[f], n); let R = n.x, M = n.y, L = n.z; R < i.x && h.clone(n, i), R > s.x && h.clone(n, s), M < o.y && h.clone(n, o), M > a.y && h.clone(n, a), L < r.z && h.clone(n, r), L > c.z && h.clone(n, c) } let d = h.magnitudeSquared(h.subtract(s, i, ys)), p = h.magnitudeSquared(h.subtract(a, o, ys)), g = h.magnitudeSquared(h.subtract(c, r, ys)), m = i, A = s, C = d; p > C && (C = p, m = o, A = a), g > C && (C = g, m = r, A = c); let x = oH; x.x = (m.x + A.x) * .5, x.y = (m.y + A.y) * .5, x.z = (m.z + A.z) * .5; let T = h.magnitudeSquared(h.subtract(A, x, ys)), b = Math.sqrt(T), S = rH; S.x = i.x, S.y = o.y, S.z = r.z; let D = sH; D.x = s.x, D.y = a.y, D.z = c.z; let P = h.midpoint(S, D, aH), B = 0; for (f = 0; f < u; f++) { h.clone(e[f], n); let R = h.magnitude(h.subtract(n, P, ys)); R > B && (B = R); let M = h.magnitudeSquared(h.subtract(n, x, ys)); if (M > T) { let L = Math.sqrt(M); b = (b + L) * .5, T = b * b; let _ = L - b; x.x = (b * x.x + _ * n.x) / L, x.y = (b * x.y + _ * n.y) / L, x.z = (b * x.z + _ * n.z) / L } } return b < B ? (h.clone(x, t.center), t.radius = b) : (h.clone(P, t.center), t.radius = B), t }; var sCe = new _i, aCe = new h, cCe = new h, Kz = new he, Jz = new he; rn.fromRectangle2D = function (e, t, n) { return rn.fromRectangleWithHeights2D(e, t, 0, 0, n) }; rn.fromRectangleWithHeights2D = function (e, t, n, i, o) { if (l(o) || (o = new rn), !l(e)) return o.center = h.clone(h.ZERO, o.center), o.radius = 0, o; t = y(t, sCe), ce.southwest(e, Kz), Kz.height = n, ce.northeast(e, Jz), Jz.height = i; let r = t.project(Kz, aCe), s = t.project(Jz, cCe), a = s.x - r.x, c = s.y - r.y, u = s.z - r.z; o.radius = Math.sqrt(a * a + c * c + u * u) * .5; let f = o.center; return f.x = r.x + a * .5, f.y = r.y + c * .5, f.z = r.z + u * .5, o }; var lCe = []; rn.fromRectangle3D = function (e, t, n, i) { if (t = y(t, ie.WGS84), n = y(n, 0), l(i) || (i = new rn), !l(e)) return i.center = h.clone(h.ZERO, i.center), i.radius = 0, i; let o = ce.subsample(e, t, n, lCe); return rn.fromPoints(o, i) }; rn.fromVertices = function (e, t, n, i) { if (l(i) || (i = new rn), !l(e) || e.length === 0) return i.center = h.clone(h.ZERO, i.center), i.radius = 0, i; t = y(t, h.ZERO), n = y(n, 3); let o = iH; o.x = e[0] + t.x, o.y = e[1] + t.y, o.z = e[2] + t.z; let r = h.clone(o, Zz), s = h.clone(o, Qz), a = h.clone(o, $z), c = h.clone(o, eH), u = h.clone(o, tH), f = h.clone(o, nH), d = e.length, p; for (p = 0; p < d; p += n) { let L = e[p] + t.x, _ = e[p + 1] + t.y, E = e[p + 2] + t.z; o.x = L, o.y = _, o.z = E, L < r.x && h.clone(o, r), L > c.x && h.clone(o, c), _ < s.y && h.clone(o, s), _ > u.y && h.clone(o, u), E < a.z && h.clone(o, a), E > f.z && h.clone(o, f) } let g = h.magnitudeSquared(h.subtract(c, r, ys)), m = h.magnitudeSquared(h.subtract(u, s, ys)), A = h.magnitudeSquared(h.subtract(f, a, ys)), C = r, x = c, T = g; m > T && (T = m, C = s, x = u), A > T && (T = A, C = a, x = f); let b = oH; b.x = (C.x + x.x) * .5, b.y = (C.y + x.y) * .5, b.z = (C.z + x.z) * .5; let S = h.magnitudeSquared(h.subtract(x, b, ys)), D = Math.sqrt(S), P = rH; P.x = r.x, P.y = s.y, P.z = a.z; let B = sH; B.x = c.x, B.y = u.y, B.z = f.z; let R = h.midpoint(P, B, aH), M = 0; for (p = 0; p < d; p += n) { o.x = e[p] + t.x, o.y = e[p + 1] + t.y, o.z = e[p + 2] + t.z; let L = h.magnitude(h.subtract(o, R, ys)); L > M && (M = L); let _ = h.magnitudeSquared(h.subtract(o, b, ys)); if (_ > S) { let E = Math.sqrt(_); D = (D + E) * .5, S = D * D; let w = E - D; b.x = (D * b.x + w * o.x) / E, b.y = (D * b.y + w * o.y) / E, b.z = (D * b.z + w * o.z) / E } } return D < M ? (h.clone(b, i.center), i.radius = D) : (h.clone(R, i.center), i.radius = M), i }; rn.fromEncodedCartesianVertices = function (e, t, n) { if (l(n) || (n = new rn), !l(e) || !l(t) || e.length !== t.length || e.length === 0) return n.center = h.clone(h.ZERO, n.center), n.radius = 0, n; let i = iH; i.x = e[0] + t[0], i.y = e[1] + t[1], i.z = e[2] + t[2]; let o = h.clone(i, Zz), r = h.clone(i, Qz), s = h.clone(i, $z), a = h.clone(i, eH), c = h.clone(i, tH), u = h.clone(i, nH), f = e.length, d; for (d = 0; d < f; d += 3) { let M = e[d] + t[d], L = e[d + 1] + t[d + 1], _ = e[d + 2] + t[d + 2]; i.x = M, i.y = L, i.z = _, M < o.x && h.clone(i, o), M > a.x && h.clone(i, a), L < r.y && h.clone(i, r), L > c.y && h.clone(i, c), _ < s.z && h.clone(i, s), _ > u.z && h.clone(i, u) } let p = h.magnitudeSquared(h.subtract(a, o, ys)), g = h.magnitudeSquared(h.subtract(c, r, ys)), m = h.magnitudeSquared(h.subtract(u, s, ys)), A = o, C = a, x = p; g > x && (x = g, A = r, C = c), m > x && (x = m, A = s, C = u); let T = oH; T.x = (A.x + C.x) * .5, T.y = (A.y + C.y) * .5, T.z = (A.z + C.z) * .5; let b = h.magnitudeSquared(h.subtract(C, T, ys)), S = Math.sqrt(b), D = rH; D.x = o.x, D.y = r.y, D.z = s.z; let P = sH; P.x = a.x, P.y = c.y, P.z = u.z; let B = h.midpoint(D, P, aH), R = 0; for (d = 0; d < f; d += 3) { i.x = e[d] + t[d], i.y = e[d + 1] + t[d + 1], i.z = e[d + 2] + t[d + 2]; let M = h.magnitude(h.subtract(i, B, ys)); M > R && (R = M); let L = h.magnitudeSquared(h.subtract(i, T, ys)); if (L > b) { let _ = Math.sqrt(L); S = (S + _) * .5, b = S * S; let E = _ - S; T.x = (S * T.x + E * i.x) / _, T.y = (S * T.y + E * i.y) / _, T.z = (S * T.z + E * i.z) / _ } } return S < R ? (h.clone(T, n.center), n.radius = S) : (h.clone(B, n.center), n.radius = R), n }; rn.fromCornerPoints = function (e, t, n) { l(n) || (n = new rn); let i = h.midpoint(e, t, n.center); return n.radius = h.distance(i, t), n }; rn.fromEllipsoid = function (e, t) { return l(t) || (t = new rn), h.clone(h.ZERO, t.center), t.radius = e.maximumRadius, t }; var uCe = new h; rn.fromBoundingSpheres = function (e, t) { if (l(t) || (t = new rn), !l(e) || e.length === 0) return t.center = h.clone(h.ZERO, t.center), t.radius = 0, t; let n = e.length; if (n === 1) return rn.clone(e[0], t); if (n === 2) return rn.union(e[0], e[1], t); let i = [], o; for (o = 0; o < n; o++)i.push(e[o].center); t = rn.fromPoints(i, t); let r = t.center, s = t.radius; for (o = 0; o < n; o++) { let a = e[o]; s = Math.max(s, h.distance(r, a.center, uCe) + a.radius) } return t.radius = s, t }; var fCe = new h, dCe = new h, hCe = new h; rn.fromOrientedBoundingBox = function (e, t) { l(t) || (t = new rn); let n = e.halfAxes, i = Q.getColumn(n, 0, fCe), o = Q.getColumn(n, 1, dCe), r = Q.getColumn(n, 2, hCe); return h.add(i, o, i), h.add(i, r, i), t.center = h.clone(e.center, t.center), t.radius = h.magnitude(i), t }; var mCe = new h, pCe = new h; rn.fromTransformation = function (e, t) { l(t) || (t = new rn); let n = F.getTranslation(e, mCe), i = F.getScale(e, pCe), o = .5 * h.magnitude(i); return t.center = h.clone(n, t.center), t.radius = o, t }; rn.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.center = h.clone(e.center, t.center), t.radius = e.radius, t) : new rn(e.center, e.radius) }; rn.packedLength = 4; rn.pack = function (e, t, n) { n = y(n, 0); let i = e.center; return t[n++] = i.x, t[n++] = i.y, t[n++] = i.z, t[n] = e.radius, t }; rn.unpack = function (e, t, n) { t = y(t, 0), l(n) || (n = new rn); let i = n.center; return i.x = e[t++], i.y = e[t++], i.z = e[t++], n.radius = e[t], n }; var _Ce = new h, gCe = new h; rn.union = function (e, t, n) { l(n) || (n = new rn); let i = e.center, o = e.radius, r = t.center, s = t.radius, a = h.subtract(r, i, _Ce), c = h.magnitude(a); if (o >= c + s) return e.clone(n), n; if (s >= c + o) return t.clone(n), n; let u = (o + c + s) * .5, f = h.multiplyByScalar(a, (-o + u) / c, gCe); return h.add(f, i, f), h.clone(f, n.center), n.radius = u, n }; var yCe = new h; rn.expand = function (e, t, n) { n = rn.clone(e, n); let i = h.magnitude(h.subtract(t, n.center, yCe)); return i > n.radius && (n.radius = i), n }; rn.intersectPlane = function (e, t) { let n = e.center, i = e.radius, o = t.normal, r = h.dot(o, n) + t.distance; return r < -i ? Kt.OUTSIDE : r < i ? Kt.INTERSECTING : Kt.INSIDE }; rn.transform = function (e, t, n) { return l(n) || (n = new rn), n.center = F.multiplyByPoint(t, e.center, n.center), n.radius = F.getMaximumScale(t) * e.radius, n }; var ACe = new h; rn.distanceSquaredTo = function (e, t) { let n = h.subtract(e.center, t, ACe), i = h.magnitude(n) - e.radius; return i <= 0 ? 0 : i * i }; rn.transformWithoutScale = function (e, t, n) { return l(n) || (n = new rn), n.center = F.multiplyByPoint(t, e.center, n.center), n.radius = e.radius, n }; var CCe = new h; rn.computePlaneDistances = function (e, t, n, i) { l(i) || (i = new Dc); let o = h.subtract(e.center, t, CCe), r = h.dot(n, o); return i.start = r - e.radius, i.stop = r + e.radius, i }; var yY = new h, xCe = new h, TCe = new h, ECe = new h, bCe = new h, SCe = new he, AY = new Array(8); for (let e = 0; e < 8; ++e)AY[e] = new h; var wCe = new _i; rn.projectTo2D = function (e, t, n) { t = y(t, wCe); let i = t.ellipsoid, o = e.center, r = e.radius, s; h.equals(o, h.ZERO) ? s = h.clone(h.UNIT_X, yY) : s = i.geodeticSurfaceNormal(o, yY); let a = h.cross(h.UNIT_Z, s, xCe); h.normalize(a, a); let c = h.cross(s, a, TCe); h.normalize(c, c), h.multiplyByScalar(s, r, s), h.multiplyByScalar(c, r, c), h.multiplyByScalar(a, r, a); let u = h.negate(c, bCe), f = h.negate(a, ECe), d = AY, p = d[0]; h.add(s, c, p), h.add(p, a, p), p = d[1], h.add(s, c, p), h.add(p, f, p), p = d[2], h.add(s, u, p), h.add(p, f, p), p = d[3], h.add(s, u, p), h.add(p, a, p), h.negate(s, s), p = d[4], h.add(s, c, p), h.add(p, a, p), p = d[5], h.add(s, c, p), h.add(p, f, p), p = d[6], h.add(s, u, p), h.add(p, f, p), p = d[7], h.add(s, u, p), h.add(p, a, p); let g = d.length; for (let x = 0; x < g; ++x) { let T = d[x]; h.add(o, T, T); let b = i.cartesianToCartographic(T, SCe); t.project(b, T) } n = rn.fromPoints(d, n), o = n.center; let m = o.x, A = o.y, C = o.z; return o.x = C, o.y = m, o.z = A, n }; rn.isOccluded = function (e, t) { return !t.isBoundingSphereVisible(e) }; rn.equals = function (e, t) { return e === t || l(e) && l(t) && h.equals(e.center, t.center) && e.radius === t.radius }; rn.prototype.intersectPlane = function (e) { return rn.intersectPlane(this, e) }; rn.prototype.distanceSquaredTo = function (e) { return rn.distanceSquaredTo(this, e) }; rn.prototype.computePlaneDistances = function (e, t, n) { return rn.computePlaneDistances(this, e, t, n) }; rn.prototype.isOccluded = function (e) { return rn.isOccluded(this, e) }; rn.prototype.equals = function (e) { return rn.equals(this, e) }; rn.prototype.clone = function (e) { return rn.clone(this, e) }; rn.prototype.volume = function () { let e = this.radius; return rCe * e * e * e }; var re = rn; var DCe = { DEPTH_BUFFER_BIT: 256, STENCIL_BUFFER_BIT: 1024, COLOR_BUFFER_BIT: 16384, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, ZERO: 0, ONE: 1, SRC_COLOR: 768, ONE_MINUS_SRC_COLOR: 769, SRC_ALPHA: 770, ONE_MINUS_SRC_ALPHA: 771, DST_ALPHA: 772, ONE_MINUS_DST_ALPHA: 773, DST_COLOR: 774, ONE_MINUS_DST_COLOR: 775, SRC_ALPHA_SATURATE: 776, FUNC_ADD: 32774, BLEND_EQUATION: 32777, BLEND_EQUATION_RGB: 32777, BLEND_EQUATION_ALPHA: 34877, FUNC_SUBTRACT: 32778, FUNC_REVERSE_SUBTRACT: 32779, BLEND_DST_RGB: 32968, BLEND_SRC_RGB: 32969, BLEND_DST_ALPHA: 32970, BLEND_SRC_ALPHA: 32971, CONSTANT_COLOR: 32769, ONE_MINUS_CONSTANT_COLOR: 32770, CONSTANT_ALPHA: 32771, ONE_MINUS_CONSTANT_ALPHA: 32772, BLEND_COLOR: 32773, ARRAY_BUFFER: 34962, ELEMENT_ARRAY_BUFFER: 34963, ARRAY_BUFFER_BINDING: 34964, ELEMENT_ARRAY_BUFFER_BINDING: 34965, STREAM_DRAW: 35040, STATIC_DRAW: 35044, DYNAMIC_DRAW: 35048, BUFFER_SIZE: 34660, BUFFER_USAGE: 34661, CURRENT_VERTEX_ATTRIB: 34342, FRONT: 1028, BACK: 1029, FRONT_AND_BACK: 1032, CULL_FACE: 2884, BLEND: 3042, DITHER: 3024, STENCIL_TEST: 2960, DEPTH_TEST: 2929, SCISSOR_TEST: 3089, POLYGON_OFFSET_FILL: 32823, SAMPLE_ALPHA_TO_COVERAGE: 32926, SAMPLE_COVERAGE: 32928, NO_ERROR: 0, INVALID_ENUM: 1280, INVALID_VALUE: 1281, INVALID_OPERATION: 1282, OUT_OF_MEMORY: 1285, CW: 2304, CCW: 2305, LINE_WIDTH: 2849, ALIASED_POINT_SIZE_RANGE: 33901, ALIASED_LINE_WIDTH_RANGE: 33902, CULL_FACE_MODE: 2885, FRONT_FACE: 2886, DEPTH_RANGE: 2928, DEPTH_WRITEMASK: 2930, DEPTH_CLEAR_VALUE: 2931, DEPTH_FUNC: 2932, STENCIL_CLEAR_VALUE: 2961, STENCIL_FUNC: 2962, STENCIL_FAIL: 2964, STENCIL_PASS_DEPTH_FAIL: 2965, STENCIL_PASS_DEPTH_PASS: 2966, STENCIL_REF: 2967, STENCIL_VALUE_MASK: 2963, STENCIL_WRITEMASK: 2968, STENCIL_BACK_FUNC: 34816, STENCIL_BACK_FAIL: 34817, STENCIL_BACK_PASS_DEPTH_FAIL: 34818, STENCIL_BACK_PASS_DEPTH_PASS: 34819, STENCIL_BACK_REF: 36003, STENCIL_BACK_VALUE_MASK: 36004, STENCIL_BACK_WRITEMASK: 36005, VIEWPORT: 2978, SCISSOR_BOX: 3088, COLOR_CLEAR_VALUE: 3106, COLOR_WRITEMASK: 3107, UNPACK_ALIGNMENT: 3317, PACK_ALIGNMENT: 3333, MAX_TEXTURE_SIZE: 3379, MAX_VIEWPORT_DIMS: 3386, SUBPIXEL_BITS: 3408, RED_BITS: 3410, GREEN_BITS: 3411, BLUE_BITS: 3412, ALPHA_BITS: 3413, DEPTH_BITS: 3414, STENCIL_BITS: 3415, POLYGON_OFFSET_UNITS: 10752, POLYGON_OFFSET_FACTOR: 32824, TEXTURE_BINDING_2D: 32873, SAMPLE_BUFFERS: 32936, SAMPLES: 32937, SAMPLE_COVERAGE_VALUE: 32938, SAMPLE_COVERAGE_INVERT: 32939, COMPRESSED_TEXTURE_FORMATS: 34467, DONT_CARE: 4352, FASTEST: 4353, NICEST: 4354, GENERATE_MIPMAP_HINT: 33170, BYTE: 5120, UNSIGNED_BYTE: 5121, SHORT: 5122, UNSIGNED_SHORT: 5123, INT: 5124, UNSIGNED_INT: 5125, FLOAT: 5126, DEPTH_COMPONENT: 6402, ALPHA: 6406, RGB: 6407, RGBA: 6408, LUMINANCE: 6409, LUMINANCE_ALPHA: 6410, UNSIGNED_SHORT_4_4_4_4: 32819, UNSIGNED_SHORT_5_5_5_1: 32820, UNSIGNED_SHORT_5_6_5: 33635, FRAGMENT_SHADER: 35632, VERTEX_SHADER: 35633, MAX_VERTEX_ATTRIBS: 34921, MAX_VERTEX_UNIFORM_VECTORS: 36347, MAX_VARYING_VECTORS: 36348, MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661, MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660, MAX_TEXTURE_IMAGE_UNITS: 34930, MAX_FRAGMENT_UNIFORM_VECTORS: 36349, SHADER_TYPE: 35663, DELETE_STATUS: 35712, LINK_STATUS: 35714, VALIDATE_STATUS: 35715, ATTACHED_SHADERS: 35717, ACTIVE_UNIFORMS: 35718, ACTIVE_ATTRIBUTES: 35721, SHADING_LANGUAGE_VERSION: 35724, CURRENT_PROGRAM: 35725, NEVER: 512, LESS: 513, EQUAL: 514, LEQUAL: 515, GREATER: 516, NOTEQUAL: 517, GEQUAL: 518, ALWAYS: 519, KEEP: 7680, REPLACE: 7681, INCR: 7682, DECR: 7683, INVERT: 5386, INCR_WRAP: 34055, DECR_WRAP: 34056, VENDOR: 7936, RENDERER: 7937, VERSION: 7938, NEAREST: 9728, LINEAR: 9729, NEAREST_MIPMAP_NEAREST: 9984, LINEAR_MIPMAP_NEAREST: 9985, NEAREST_MIPMAP_LINEAR: 9986, LINEAR_MIPMAP_LINEAR: 9987, TEXTURE_MAG_FILTER: 10240, TEXTURE_MIN_FILTER: 10241, TEXTURE_WRAP_S: 10242, TEXTURE_WRAP_T: 10243, TEXTURE_2D: 3553, TEXTURE: 5890, TEXTURE_CUBE_MAP: 34067, TEXTURE_BINDING_CUBE_MAP: 34068, TEXTURE_CUBE_MAP_POSITIVE_X: 34069, TEXTURE_CUBE_MAP_NEGATIVE_X: 34070, TEXTURE_CUBE_MAP_POSITIVE_Y: 34071, TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072, TEXTURE_CUBE_MAP_POSITIVE_Z: 34073, TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074, MAX_CUBE_MAP_TEXTURE_SIZE: 34076, TEXTURE0: 33984, TEXTURE1: 33985, TEXTURE2: 33986, TEXTURE3: 33987, TEXTURE4: 33988, TEXTURE5: 33989, TEXTURE6: 33990, TEXTURE7: 33991, TEXTURE8: 33992, TEXTURE9: 33993, TEXTURE10: 33994, TEXTURE11: 33995, TEXTURE12: 33996, TEXTURE13: 33997, TEXTURE14: 33998, TEXTURE15: 33999, TEXTURE16: 34e3, TEXTURE17: 34001, TEXTURE18: 34002, TEXTURE19: 34003, TEXTURE20: 34004, TEXTURE21: 34005, TEXTURE22: 34006, TEXTURE23: 34007, TEXTURE24: 34008, TEXTURE25: 34009, TEXTURE26: 34010, TEXTURE27: 34011, TEXTURE28: 34012, TEXTURE29: 34013, TEXTURE30: 34014, TEXTURE31: 34015, ACTIVE_TEXTURE: 34016, REPEAT: 10497, CLAMP_TO_EDGE: 33071, MIRRORED_REPEAT: 33648, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, INT_VEC2: 35667, INT_VEC3: 35668, INT_VEC4: 35669, BOOL: 35670, BOOL_VEC2: 35671, BOOL_VEC3: 35672, BOOL_VEC4: 35673, FLOAT_MAT2: 35674, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, SAMPLER_2D: 35678, SAMPLER_CUBE: 35680, VERTEX_ATTRIB_ARRAY_ENABLED: 34338, VERTEX_ATTRIB_ARRAY_SIZE: 34339, VERTEX_ATTRIB_ARRAY_STRIDE: 34340, VERTEX_ATTRIB_ARRAY_TYPE: 34341, VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922, VERTEX_ATTRIB_ARRAY_POINTER: 34373, VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975, IMPLEMENTATION_COLOR_READ_TYPE: 35738, IMPLEMENTATION_COLOR_READ_FORMAT: 35739, COMPILE_STATUS: 35713, LOW_FLOAT: 36336, MEDIUM_FLOAT: 36337, HIGH_FLOAT: 36338, LOW_INT: 36339, MEDIUM_INT: 36340, HIGH_INT: 36341, FRAMEBUFFER: 36160, RENDERBUFFER: 36161, RGBA4: 32854, RGB5_A1: 32855, RGB565: 36194, DEPTH_COMPONENT16: 33189, STENCIL_INDEX: 6401, STENCIL_INDEX8: 36168, DEPTH_STENCIL: 34041, RENDERBUFFER_WIDTH: 36162, RENDERBUFFER_HEIGHT: 36163, RENDERBUFFER_INTERNAL_FORMAT: 36164, RENDERBUFFER_RED_SIZE: 36176, RENDERBUFFER_GREEN_SIZE: 36177, RENDERBUFFER_BLUE_SIZE: 36178, RENDERBUFFER_ALPHA_SIZE: 36179, RENDERBUFFER_DEPTH_SIZE: 36180, RENDERBUFFER_STENCIL_SIZE: 36181, FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048, FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049, FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050, FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051, COLOR_ATTACHMENT0: 36064, DEPTH_ATTACHMENT: 36096, STENCIL_ATTACHMENT: 36128, DEPTH_STENCIL_ATTACHMENT: 33306, NONE: 0, FRAMEBUFFER_COMPLETE: 36053, FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054, FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055, FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057, FRAMEBUFFER_UNSUPPORTED: 36061, FRAMEBUFFER_BINDING: 36006, RENDERBUFFER_BINDING: 36007, MAX_RENDERBUFFER_SIZE: 34024, INVALID_FRAMEBUFFER_OPERATION: 1286, UNPACK_FLIP_Y_WEBGL: 37440, UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441, CONTEXT_LOST_WEBGL: 37442, UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443, BROWSER_DEFAULT_WEBGL: 37444, COMPRESSED_RGB_S3TC_DXT1_EXT: 33776, COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777, COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778, COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779, COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840, COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841, COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842, COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843, COMPRESSED_RGBA_ASTC_4x4_WEBGL: 37808, COMPRESSED_RGB_ETC1_WEBGL: 36196, COMPRESSED_RGBA_BPTC_UNORM: 36492, HALF_FLOAT_OES: 36193, DOUBLE: 5130, READ_BUFFER: 3074, UNPACK_ROW_LENGTH: 3314, UNPACK_SKIP_ROWS: 3315, UNPACK_SKIP_PIXELS: 3316, PACK_ROW_LENGTH: 3330, PACK_SKIP_ROWS: 3331, PACK_SKIP_PIXELS: 3332, COLOR: 6144, DEPTH: 6145, STENCIL: 6146, RED: 6403, RGB8: 32849, RGBA8: 32856, RGB10_A2: 32857, TEXTURE_BINDING_3D: 32874, UNPACK_SKIP_IMAGES: 32877, UNPACK_IMAGE_HEIGHT: 32878, TEXTURE_3D: 32879, TEXTURE_WRAP_R: 32882, MAX_3D_TEXTURE_SIZE: 32883, UNSIGNED_INT_2_10_10_10_REV: 33640, MAX_ELEMENTS_VERTICES: 33e3, MAX_ELEMENTS_INDICES: 33001, TEXTURE_MIN_LOD: 33082, TEXTURE_MAX_LOD: 33083, TEXTURE_BASE_LEVEL: 33084, TEXTURE_MAX_LEVEL: 33085, MIN: 32775, MAX: 32776, DEPTH_COMPONENT24: 33190, MAX_TEXTURE_LOD_BIAS: 34045, TEXTURE_COMPARE_MODE: 34892, TEXTURE_COMPARE_FUNC: 34893, CURRENT_QUERY: 34917, QUERY_RESULT: 34918, QUERY_RESULT_AVAILABLE: 34919, STREAM_READ: 35041, STREAM_COPY: 35042, STATIC_READ: 35045, STATIC_COPY: 35046, DYNAMIC_READ: 35049, DYNAMIC_COPY: 35050, MAX_DRAW_BUFFERS: 34852, DRAW_BUFFER0: 34853, DRAW_BUFFER1: 34854, DRAW_BUFFER2: 34855, DRAW_BUFFER3: 34856, DRAW_BUFFER4: 34857, DRAW_BUFFER5: 34858, DRAW_BUFFER6: 34859, DRAW_BUFFER7: 34860, DRAW_BUFFER8: 34861, DRAW_BUFFER9: 34862, DRAW_BUFFER10: 34863, DRAW_BUFFER11: 34864, DRAW_BUFFER12: 34865, DRAW_BUFFER13: 34866, DRAW_BUFFER14: 34867, DRAW_BUFFER15: 34868, MAX_FRAGMENT_UNIFORM_COMPONENTS: 35657, MAX_VERTEX_UNIFORM_COMPONENTS: 35658, SAMPLER_3D: 35679, SAMPLER_2D_SHADOW: 35682, FRAGMENT_SHADER_DERIVATIVE_HINT: 35723, PIXEL_PACK_BUFFER: 35051, PIXEL_UNPACK_BUFFER: 35052, PIXEL_PACK_BUFFER_BINDING: 35053, PIXEL_UNPACK_BUFFER_BINDING: 35055, FLOAT_MAT2x3: 35685, FLOAT_MAT2x4: 35686, FLOAT_MAT3x2: 35687, FLOAT_MAT3x4: 35688, FLOAT_MAT4x2: 35689, FLOAT_MAT4x3: 35690, SRGB: 35904, SRGB8: 35905, SRGB8_ALPHA8: 35907, COMPARE_REF_TO_TEXTURE: 34894, RGBA32F: 34836, RGB32F: 34837, RGBA16F: 34842, RGB16F: 34843, VERTEX_ATTRIB_ARRAY_INTEGER: 35069, MAX_ARRAY_TEXTURE_LAYERS: 35071, MIN_PROGRAM_TEXEL_OFFSET: 35076, MAX_PROGRAM_TEXEL_OFFSET: 35077, MAX_VARYING_COMPONENTS: 35659, TEXTURE_2D_ARRAY: 35866, TEXTURE_BINDING_2D_ARRAY: 35869, R11F_G11F_B10F: 35898, UNSIGNED_INT_10F_11F_11F_REV: 35899, RGB9_E5: 35901, UNSIGNED_INT_5_9_9_9_REV: 35902, TRANSFORM_FEEDBACK_BUFFER_MODE: 35967, MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 35968, TRANSFORM_FEEDBACK_VARYINGS: 35971, TRANSFORM_FEEDBACK_BUFFER_START: 35972, TRANSFORM_FEEDBACK_BUFFER_SIZE: 35973, TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 35976, RASTERIZER_DISCARD: 35977, MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 35978, MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 35979, INTERLEAVED_ATTRIBS: 35980, SEPARATE_ATTRIBS: 35981, TRANSFORM_FEEDBACK_BUFFER: 35982, TRANSFORM_FEEDBACK_BUFFER_BINDING: 35983, RGBA32UI: 36208, RGB32UI: 36209, RGBA16UI: 36214, RGB16UI: 36215, RGBA8UI: 36220, RGB8UI: 36221, RGBA32I: 36226, RGB32I: 36227, RGBA16I: 36232, RGB16I: 36233, RGBA8I: 36238, RGB8I: 36239, RED_INTEGER: 36244, RGB_INTEGER: 36248, RGBA_INTEGER: 36249, SAMPLER_2D_ARRAY: 36289, SAMPLER_2D_ARRAY_SHADOW: 36292, SAMPLER_CUBE_SHADOW: 36293, UNSIGNED_INT_VEC2: 36294, UNSIGNED_INT_VEC3: 36295, UNSIGNED_INT_VEC4: 36296, INT_SAMPLER_2D: 36298, INT_SAMPLER_3D: 36299, INT_SAMPLER_CUBE: 36300, INT_SAMPLER_2D_ARRAY: 36303, UNSIGNED_INT_SAMPLER_2D: 36306, UNSIGNED_INT_SAMPLER_3D: 36307, UNSIGNED_INT_SAMPLER_CUBE: 36308, UNSIGNED_INT_SAMPLER_2D_ARRAY: 36311, DEPTH_COMPONENT32F: 36012, DEPTH32F_STENCIL8: 36013, FLOAT_32_UNSIGNED_INT_24_8_REV: 36269, FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 33296, FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 33297, FRAMEBUFFER_ATTACHMENT_RED_SIZE: 33298, FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 33299, FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 33300, FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 33301, FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 33302, FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 33303, FRAMEBUFFER_DEFAULT: 33304, UNSIGNED_INT_24_8: 34042, DEPTH24_STENCIL8: 35056, UNSIGNED_NORMALIZED: 35863, DRAW_FRAMEBUFFER_BINDING: 36006, READ_FRAMEBUFFER: 36008, DRAW_FRAMEBUFFER: 36009, READ_FRAMEBUFFER_BINDING: 36010, RENDERBUFFER_SAMPLES: 36011, FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 36052, MAX_COLOR_ATTACHMENTS: 36063, COLOR_ATTACHMENT1: 36065, COLOR_ATTACHMENT2: 36066, COLOR_ATTACHMENT3: 36067, COLOR_ATTACHMENT4: 36068, COLOR_ATTACHMENT5: 36069, COLOR_ATTACHMENT6: 36070, COLOR_ATTACHMENT7: 36071, COLOR_ATTACHMENT8: 36072, COLOR_ATTACHMENT9: 36073, COLOR_ATTACHMENT10: 36074, COLOR_ATTACHMENT11: 36075, COLOR_ATTACHMENT12: 36076, COLOR_ATTACHMENT13: 36077, COLOR_ATTACHMENT14: 36078, COLOR_ATTACHMENT15: 36079, FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 36182, MAX_SAMPLES: 36183, HALF_FLOAT: 5131, RG: 33319, RG_INTEGER: 33320, R8: 33321, RG8: 33323, R16F: 33325, R32F: 33326, RG16F: 33327, RG32F: 33328, R8I: 33329, R8UI: 33330, R16I: 33331, R16UI: 33332, R32I: 33333, R32UI: 33334, RG8I: 33335, RG8UI: 33336, RG16I: 33337, RG16UI: 33338, RG32I: 33339, RG32UI: 33340, VERTEX_ARRAY_BINDING: 34229, R8_SNORM: 36756, RG8_SNORM: 36757, RGB8_SNORM: 36758, RGBA8_SNORM: 36759, SIGNED_NORMALIZED: 36764, COPY_READ_BUFFER: 36662, COPY_WRITE_BUFFER: 36663, COPY_READ_BUFFER_BINDING: 36662, COPY_WRITE_BUFFER_BINDING: 36663, UNIFORM_BUFFER: 35345, UNIFORM_BUFFER_BINDING: 35368, UNIFORM_BUFFER_START: 35369, UNIFORM_BUFFER_SIZE: 35370, MAX_VERTEX_UNIFORM_BLOCKS: 35371, MAX_FRAGMENT_UNIFORM_BLOCKS: 35373, MAX_COMBINED_UNIFORM_BLOCKS: 35374, MAX_UNIFORM_BUFFER_BINDINGS: 35375, MAX_UNIFORM_BLOCK_SIZE: 35376, MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 35377, MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 35379, UNIFORM_BUFFER_OFFSET_ALIGNMENT: 35380, ACTIVE_UNIFORM_BLOCKS: 35382, UNIFORM_TYPE: 35383, UNIFORM_SIZE: 35384, UNIFORM_BLOCK_INDEX: 35386, UNIFORM_OFFSET: 35387, UNIFORM_ARRAY_STRIDE: 35388, UNIFORM_MATRIX_STRIDE: 35389, UNIFORM_IS_ROW_MAJOR: 35390, UNIFORM_BLOCK_BINDING: 35391, UNIFORM_BLOCK_DATA_SIZE: 35392, UNIFORM_BLOCK_ACTIVE_UNIFORMS: 35394, UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 35395, UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 35396, UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 35398, INVALID_INDEX: 4294967295, MAX_VERTEX_OUTPUT_COMPONENTS: 37154, MAX_FRAGMENT_INPUT_COMPONENTS: 37157, MAX_SERVER_WAIT_TIMEOUT: 37137, OBJECT_TYPE: 37138, SYNC_CONDITION: 37139, SYNC_STATUS: 37140, SYNC_FLAGS: 37141, SYNC_FENCE: 37142, SYNC_GPU_COMMANDS_COMPLETE: 37143, UNSIGNALED: 37144, SIGNALED: 37145, ALREADY_SIGNALED: 37146, TIMEOUT_EXPIRED: 37147, CONDITION_SATISFIED: 37148, WAIT_FAILED: 37149, SYNC_FLUSH_COMMANDS_BIT: 1, VERTEX_ATTRIB_ARRAY_DIVISOR: 35070, ANY_SAMPLES_PASSED: 35887, ANY_SAMPLES_PASSED_CONSERVATIVE: 36202, SAMPLER_BINDING: 35097, RGB10_A2UI: 36975, INT_2_10_10_10_REV: 36255, TRANSFORM_FEEDBACK: 36386, TRANSFORM_FEEDBACK_PAUSED: 36387, TRANSFORM_FEEDBACK_ACTIVE: 36388, TRANSFORM_FEEDBACK_BINDING: 36389, COMPRESSED_R11_EAC: 37488, COMPRESSED_SIGNED_R11_EAC: 37489, COMPRESSED_RG11_EAC: 37490, COMPRESSED_SIGNED_RG11_EAC: 37491, COMPRESSED_RGB8_ETC2: 37492, COMPRESSED_SRGB8_ETC2: 37493, COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37494, COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37495, COMPRESSED_RGBA8_ETC2_EAC: 37496, COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37497, TEXTURE_IMMUTABLE_FORMAT: 37167, MAX_ELEMENT_INDEX: 36203, TEXTURE_IMMUTABLE_LEVELS: 33503, MAX_TEXTURE_MAX_ANISOTROPY_EXT: 34047 }, te = Object.freeze(DCe); var gn = { BYTE: te.BYTE, UNSIGNED_BYTE: te.UNSIGNED_BYTE, SHORT: te.SHORT, UNSIGNED_SHORT: te.UNSIGNED_SHORT, INT: te.INT, UNSIGNED_INT: te.UNSIGNED_INT, FLOAT: te.FLOAT, DOUBLE: te.DOUBLE }; gn.getSizeInBytes = function (e) { switch (e) { case gn.BYTE: return Int8Array.BYTES_PER_ELEMENT; case gn.UNSIGNED_BYTE: return Uint8Array.BYTES_PER_ELEMENT; case gn.SHORT: return Int16Array.BYTES_PER_ELEMENT; case gn.UNSIGNED_SHORT: return Uint16Array.BYTES_PER_ELEMENT; case gn.INT: return Int32Array.BYTES_PER_ELEMENT; case gn.UNSIGNED_INT: return Uint32Array.BYTES_PER_ELEMENT; case gn.FLOAT: return Float32Array.BYTES_PER_ELEMENT; case gn.DOUBLE: return Float64Array.BYTES_PER_ELEMENT } }; gn.fromTypedArray = function (e) { if (e instanceof Int8Array) return gn.BYTE; if (e instanceof Uint8Array) return gn.UNSIGNED_BYTE; if (e instanceof Int16Array) return gn.SHORT; if (e instanceof Uint16Array) return gn.UNSIGNED_SHORT; if (e instanceof Int32Array) return gn.INT; if (e instanceof Uint32Array) return gn.UNSIGNED_INT; if (e instanceof Float32Array) return gn.FLOAT; if (e instanceof Float64Array) return gn.DOUBLE }; gn.validate = function (e) { return l(e) && (e === gn.BYTE || e === gn.UNSIGNED_BYTE || e === gn.SHORT || e === gn.UNSIGNED_SHORT || e === gn.INT || e === gn.UNSIGNED_INT || e === gn.FLOAT || e === gn.DOUBLE) }; gn.createTypedArray = function (e, t) { switch (e) { case gn.BYTE: return new Int8Array(t); case gn.UNSIGNED_BYTE: return new Uint8Array(t); case gn.SHORT: return new Int16Array(t); case gn.UNSIGNED_SHORT: return new Uint16Array(t); case gn.INT: return new Int32Array(t); case gn.UNSIGNED_INT: return new Uint32Array(t); case gn.FLOAT: return new Float32Array(t); case gn.DOUBLE: return new Float64Array(t) } }; gn.createArrayBufferView = function (e, t, n, i) { switch (n = y(n, 0), i = y(i, (t.byteLength - n) / gn.getSizeInBytes(e)), e) { case gn.BYTE: return new Int8Array(t, n, i); case gn.UNSIGNED_BYTE: return new Uint8Array(t, n, i); case gn.SHORT: return new Int16Array(t, n, i); case gn.UNSIGNED_SHORT: return new Uint16Array(t, n, i); case gn.INT: return new Int32Array(t, n, i); case gn.UNSIGNED_INT: return new Uint32Array(t, n, i); case gn.FLOAT: return new Float32Array(t, n, i); case gn.DOUBLE: return new Float64Array(t, n, i) } }; gn.fromName = function (e) { switch (e) { case "BYTE": return gn.BYTE; case "UNSIGNED_BYTE": return gn.UNSIGNED_BYTE; case "SHORT": return gn.SHORT; case "UNSIGNED_SHORT": return gn.UNSIGNED_SHORT; case "INT": return gn.INT; case "UNSIGNED_INT": return gn.UNSIGNED_INT; case "FLOAT": return gn.FLOAT; case "DOUBLE": return gn.DOUBLE } }; var Y = Object.freeze(gn); var vCe = { NONE: 0, TRIANGLES: 1, LINES: 2, POLYLINES: 3 }, af = Object.freeze(vCe); function Ht(e, t, n, i) { this[0] = y(e, 0), this[1] = y(n, 0), this[2] = y(t, 0), this[3] = y(i, 0) } Ht.packedLength = 4; Ht.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e[0], t[n++] = e[1], t[n++] = e[2], t[n++] = e[3], t }; Ht.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new Ht), n[0] = e[t++], n[1] = e[t++], n[2] = e[t++], n[3] = e[t++], n }; Ht.packArray = function (e, t) { let n = e.length, i = n * 4; l(t) ? !Array.isArray(t) && t.length !== i || t.length !== i && (t.length = i) : t = new Array(i); for (let o = 0; o < n; ++o)Ht.pack(e[o], t, o * 4); return t }; Ht.unpackArray = function (e, t) { let n = e.length; l(t) ? t.length = n / 4 : t = new Array(n / 4); for (let i = 0; i < n; i += 4) { let o = i / 4; t[o] = Ht.unpack(e, i, t[o]) } return t }; Ht.clone = function (e, t) { if (!!l(e)) return l(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t) : new Ht(e[0], e[2], e[1], e[3]) }; Ht.fromArray = Ht.unpack; Ht.fromColumnMajorArray = function (e, t) { return Ht.clone(e, t) }; Ht.fromRowMajorArray = function (e, t) { return l(t) ? (t[0] = e[0], t[1] = e[2], t[2] = e[1], t[3] = e[3], t) : new Ht(e[0], e[1], e[2], e[3]) }; Ht.fromScale = function (e, t) { return l(t) ? (t[0] = e.x, t[1] = 0, t[2] = 0, t[3] = e.y, t) : new Ht(e.x, 0, 0, e.y) }; Ht.fromUniformScale = function (e, t) { return l(t) ? (t[0] = e, t[1] = 0, t[2] = 0, t[3] = e, t) : new Ht(e, 0, 0, e) }; Ht.fromRotation = function (e, t) { let n = Math.cos(e), i = Math.sin(e); return l(t) ? (t[0] = n, t[1] = i, t[2] = -i, t[3] = n, t) : new Ht(n, -i, i, n) }; Ht.toArray = function (e, t) { return l(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t) : [e[0], e[1], e[2], e[3]] }; Ht.getElementIndex = function (e, t) { return e * 2 + t }; Ht.getColumn = function (e, t, n) { let i = t * 2, o = e[i], r = e[i + 1]; return n.x = o, n.y = r, n }; Ht.setColumn = function (e, t, n, i) { i = Ht.clone(e, i); let o = t * 2; return i[o] = n.x, i[o + 1] = n.y, i }; Ht.getRow = function (e, t, n) { let i = e[t], o = e[t + 2]; return n.x = i, n.y = o, n }; Ht.setRow = function (e, t, n, i) { return i = Ht.clone(e, i), i[t] = n.x, i[t + 2] = n.y, i }; var PCe = new H; Ht.setScale = function (e, t, n) { let i = Ht.getScale(e, PCe), o = t.x / i.x, r = t.y / i.y; return n[0] = e[0] * o, n[1] = e[1] * o, n[2] = e[2] * r, n[3] = e[3] * r, n }; var ICe = new H; Ht.setUniformScale = function (e, t, n) { let i = Ht.getScale(e, ICe), o = t / i.x, r = t / i.y; return n[0] = e[0] * o, n[1] = e[1] * o, n[2] = e[2] * r, n[3] = e[3] * r, n }; var CY = new H; Ht.getScale = function (e, t) { return t.x = H.magnitude(H.fromElements(e[0], e[1], CY)), t.y = H.magnitude(H.fromElements(e[2], e[3], CY)), t }; var xY = new H; Ht.getMaximumScale = function (e) { return Ht.getScale(e, xY), H.maximumComponent(xY) }; var OCe = new H; Ht.setRotation = function (e, t, n) { let i = Ht.getScale(e, OCe); return n[0] = t[0] * i.x, n[1] = t[1] * i.x, n[2] = t[2] * i.y, n[3] = t[3] * i.y, n }; var BCe = new H; Ht.getRotation = function (e, t) { let n = Ht.getScale(e, BCe); return t[0] = e[0] / n.x, t[1] = e[1] / n.x, t[2] = e[2] / n.y, t[3] = e[3] / n.y, t }; Ht.multiply = function (e, t, n) { let i = e[0] * t[0] + e[2] * t[1], o = e[0] * t[2] + e[2] * t[3], r = e[1] * t[0] + e[3] * t[1], s = e[1] * t[2] + e[3] * t[3]; return n[0] = i, n[1] = r, n[2] = o, n[3] = s, n }; Ht.add = function (e, t, n) { return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n[2] = e[2] + t[2], n[3] = e[3] + t[3], n }; Ht.subtract = function (e, t, n) { return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n[3] = e[3] - t[3], n }; Ht.multiplyByVector = function (e, t, n) { let i = e[0] * t.x + e[2] * t.y, o = e[1] * t.x + e[3] * t.y; return n.x = i, n.y = o, n }; Ht.multiplyByScalar = function (e, t, n) { return n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n[3] = e[3] * t, n }; Ht.multiplyByScale = function (e, t, n) { return n[0] = e[0] * t.x, n[1] = e[1] * t.x, n[2] = e[2] * t.y, n[3] = e[3] * t.y, n }; Ht.multiplyByUniformScale = function (e, t, n) { return n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n[3] = e[3] * t, n }; Ht.negate = function (e, t) { return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t }; Ht.transpose = function (e, t) { let n = e[0], i = e[2], o = e[1], r = e[3]; return t[0] = n, t[1] = i, t[2] = o, t[3] = r, t }; Ht.abs = function (e, t) { return t[0] = Math.abs(e[0]), t[1] = Math.abs(e[1]), t[2] = Math.abs(e[2]), t[3] = Math.abs(e[3]), t }; Ht.equals = function (e, t) { return e === t || l(e) && l(t) && e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] }; Ht.equalsArray = function (e, t, n) { return e[0] === t[n] && e[1] === t[n + 1] && e[2] === t[n + 2] && e[3] === t[n + 3] }; Ht.equalsEpsilon = function (e, t, n) { return n = y(n, 0), e === t || l(e) && l(t) && Math.abs(e[0] - t[0]) <= n && Math.abs(e[1] - t[1]) <= n && Math.abs(e[2] - t[2]) <= n && Math.abs(e[3] - t[3]) <= n }; Ht.IDENTITY = Object.freeze(new Ht(1, 0, 0, 1)); Ht.ZERO = Object.freeze(new Ht(0, 0, 0, 0)); Ht.COLUMN0ROW0 = 0; Ht.COLUMN0ROW1 = 1; Ht.COLUMN1ROW0 = 2; Ht.COLUMN1ROW1 = 3; Object.defineProperties(Ht.prototype, { length: { get: function () { return Ht.packedLength } } }); Ht.prototype.clone = function (e) { return Ht.clone(this, e) }; Ht.prototype.equals = function (e) { return Ht.equals(this, e) }; Ht.prototype.equalsEpsilon = function (e, t) { return Ht.equalsEpsilon(this, e, t) }; Ht.prototype.toString = function () {
        return `(${this[0]}, ${this[2]})
(${this[1]}, ${this[3]})`
    }; var qi = Ht; var Ws = { POINTS: te.POINTS, LINES: te.LINES, LINE_LOOP: te.LINE_LOOP, LINE_STRIP: te.LINE_STRIP, TRIANGLES: te.TRIANGLES, TRIANGLE_STRIP: te.TRIANGLE_STRIP, TRIANGLE_FAN: te.TRIANGLE_FAN }; Ws.isLines = function (e) { return e === Ws.LINES || e === Ws.LINE_LOOP || e === Ws.LINE_STRIP }; Ws.isTriangles = function (e) { return e === Ws.TRIANGLES || e === Ws.TRIANGLE_STRIP || e === Ws.TRIANGLE_FAN }; Ws.validate = function (e) { return e === Ws.POINTS || e === Ws.LINES || e === Ws.LINE_LOOP || e === Ws.LINE_STRIP || e === Ws.TRIANGLES || e === Ws.TRIANGLE_STRIP || e === Ws.TRIANGLE_FAN }; var Oe = Object.freeze(Ws); function Qe(e, t, n, i) { this.x = y(e, 0), this.y = y(t, 0), this.z = y(n, 0), this.w = y(i, 0) } var ab = new h; Qe.fromAxisAngle = function (e, t, n) { let i = t / 2, o = Math.sin(i); ab = h.normalize(e, ab); let r = ab.x * o, s = ab.y * o, a = ab.z * o, c = Math.cos(i); return l(n) ? (n.x = r, n.y = s, n.z = a, n.w = c, n) : new Qe(r, s, a, c) }; var RCe = [1, 2, 0], MCe = new Array(3); Qe.fromRotationMatrix = function (e, t) { let n, i, o, r, s, a = e[Q.COLUMN0ROW0], c = e[Q.COLUMN1ROW1], u = e[Q.COLUMN2ROW2], f = a + c + u; if (f > 0) n = Math.sqrt(f + 1), s = .5 * n, n = .5 / n, i = (e[Q.COLUMN1ROW2] - e[Q.COLUMN2ROW1]) * n, o = (e[Q.COLUMN2ROW0] - e[Q.COLUMN0ROW2]) * n, r = (e[Q.COLUMN0ROW1] - e[Q.COLUMN1ROW0]) * n; else { let d = RCe, p = 0; c > a && (p = 1), u > a && u > c && (p = 2); let g = d[p], m = d[g]; n = Math.sqrt(e[Q.getElementIndex(p, p)] - e[Q.getElementIndex(g, g)] - e[Q.getElementIndex(m, m)] + 1); let A = MCe; A[p] = .5 * n, n = .5 / n, s = (e[Q.getElementIndex(m, g)] - e[Q.getElementIndex(g, m)]) * n, A[g] = (e[Q.getElementIndex(g, p)] + e[Q.getElementIndex(p, g)]) * n, A[m] = (e[Q.getElementIndex(m, p)] + e[Q.getElementIndex(p, m)]) * n, i = -A[0], o = -A[1], r = -A[2] } return l(t) ? (t.x = i, t.y = o, t.z = r, t.w = s, t) : new Qe(i, o, r, s) }; var TY = new Qe, EY = new Qe, cH = new Qe, bY = new Qe; Qe.fromHeadingPitchRoll = function (e, t) { return bY = Qe.fromAxisAngle(h.UNIT_X, e.roll, TY), cH = Qe.fromAxisAngle(h.UNIT_Y, -e.pitch, t), t = Qe.multiply(cH, bY, cH), EY = Qe.fromAxisAngle(h.UNIT_Z, -e.heading, TY), Qe.multiply(EY, t, t) }; var _P = new h, lH = new h, cf = new Qe, SY = new Qe, gP = new Qe; Qe.packedLength = 4; Qe.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e.x, t[n++] = e.y, t[n++] = e.z, t[n] = e.w, t }; Qe.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new Qe), n.x = e[t], n.y = e[t + 1], n.z = e[t + 2], n.w = e[t + 3], n }; Qe.packedInterpolationLength = 3; Qe.convertPackedArrayForInterpolation = function (e, t, n, i) { Qe.unpack(e, n * 4, gP), Qe.conjugate(gP, gP); for (let o = 0, r = n - t + 1; o < r; o++) { let s = o * 3; Qe.unpack(e, (t + o) * 4, cf), Qe.multiply(cf, gP, cf), cf.w < 0 && Qe.negate(cf, cf), Qe.computeAxis(cf, _P); let a = Qe.computeAngle(cf); l(i) || (i = []), i[s] = _P.x * a, i[s + 1] = _P.y * a, i[s + 2] = _P.z * a } }; Qe.unpackInterpolationResult = function (e, t, n, i, o) { l(o) || (o = new Qe), h.fromArray(e, 0, lH); let r = h.magnitude(lH); return Qe.unpack(t, i * 4, SY), r === 0 ? Qe.clone(Qe.IDENTITY, cf) : Qe.fromAxisAngle(lH, r, cf), Qe.multiply(cf, SY, o) }; Qe.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t) : new Qe(e.x, e.y, e.z, e.w) }; Qe.conjugate = function (e, t) { return t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = e.w, t }; Qe.magnitudeSquared = function (e) { return e.x * e.x + e.y * e.y + e.z * e.z + e.w * e.w }; Qe.magnitude = function (e) { return Math.sqrt(Qe.magnitudeSquared(e)) }; Qe.normalize = function (e, t) { let n = 1 / Qe.magnitude(e), i = e.x * n, o = e.y * n, r = e.z * n, s = e.w * n; return t.x = i, t.y = o, t.z = r, t.w = s, t }; Qe.inverse = function (e, t) { let n = Qe.magnitudeSquared(e); return t = Qe.conjugate(e, t), Qe.multiplyByScalar(t, 1 / n, t) }; Qe.add = function (e, t, n) { return n.x = e.x + t.x, n.y = e.y + t.y, n.z = e.z + t.z, n.w = e.w + t.w, n }; Qe.subtract = function (e, t, n) { return n.x = e.x - t.x, n.y = e.y - t.y, n.z = e.z - t.z, n.w = e.w - t.w, n }; Qe.negate = function (e, t) { return t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = -e.w, t }; Qe.dot = function (e, t) { return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w }; Qe.multiply = function (e, t, n) { let i = e.x, o = e.y, r = e.z, s = e.w, a = t.x, c = t.y, u = t.z, f = t.w, d = s * a + i * f + o * u - r * c, p = s * c - i * u + o * f + r * a, g = s * u + i * c - o * a + r * f, m = s * f - i * a - o * c - r * u; return n.x = d, n.y = p, n.z = g, n.w = m, n }; Qe.multiplyByScalar = function (e, t, n) { return n.x = e.x * t, n.y = e.y * t, n.z = e.z * t, n.w = e.w * t, n }; Qe.divideByScalar = function (e, t, n) { return n.x = e.x / t, n.y = e.y / t, n.z = e.z / t, n.w = e.w / t, n }; Qe.computeAxis = function (e, t) { let n = e.w; if (Math.abs(n - 1) < I.EPSILON6) return t.x = t.y = t.z = 0, t; let i = 1 / Math.sqrt(1 - n * n); return t.x = e.x * i, t.y = e.y * i, t.z = e.z * i, t }; Qe.computeAngle = function (e) { return Math.abs(e.w - 1) < I.EPSILON6 ? 0 : 2 * Math.acos(e.w) }; var uH = new Qe; Qe.lerp = function (e, t, n, i) { return uH = Qe.multiplyByScalar(t, n, uH), i = Qe.multiplyByScalar(e, 1 - n, i), Qe.add(uH, i, i) }; var wY = new Qe, fH = new Qe, dH = new Qe; Qe.slerp = function (e, t, n, i) { let o = Qe.dot(e, t), r = t; if (o < 0 && (o = -o, r = wY = Qe.negate(t, wY)), 1 - o < I.EPSILON6) return Qe.lerp(e, r, n, i); let s = Math.acos(o); return fH = Qe.multiplyByScalar(e, Math.sin((1 - n) * s), fH), dH = Qe.multiplyByScalar(r, Math.sin(n * s), dH), i = Qe.add(fH, dH, i), Qe.multiplyByScalar(i, 1 / Math.sin(s), i) }; Qe.log = function (e, t) { let n = I.acosClamped(e.w), i = 0; return n !== 0 && (i = n / Math.sin(n)), h.multiplyByScalar(e, i, t) }; Qe.exp = function (e, t) { let n = h.magnitude(e), i = 0; return n !== 0 && (i = Math.sin(n) / n), t.x = e.x * i, t.y = e.y * i, t.z = e.z * i, t.w = Math.cos(n), t }; var LCe = new h, FCe = new h, cb = new Qe, zA = new Qe; Qe.computeInnerQuadrangle = function (e, t, n, i) { let o = Qe.conjugate(t, cb); Qe.multiply(o, n, zA); let r = Qe.log(zA, LCe); Qe.multiply(o, e, zA); let s = Qe.log(zA, FCe); return h.add(r, s, r), h.multiplyByScalar(r, .25, r), h.negate(r, r), Qe.exp(r, cb), Qe.multiply(t, cb, i) }; Qe.squad = function (e, t, n, i, o, r) { let s = Qe.slerp(e, t, o, cb), a = Qe.slerp(n, i, o, zA); return Qe.slerp(s, a, 2 * o * (1 - o), r) }; var NCe = new Qe, DY = 1.9011074535173003, yP = Nt.supportsTypedArrays() ? new Float32Array(8) : [], AP = Nt.supportsTypedArrays() ? new Float32Array(8) : [], Yh = Nt.supportsTypedArrays() ? new Float32Array(8) : [], Xh = Nt.supportsTypedArrays() ? new Float32Array(8) : []; for (let e = 0; e < 7; ++e) { let t = e + 1, n = 2 * t + 1; yP[e] = 1 / (t * n), AP[e] = t / n } yP[7] = DY / (8 * 17); AP[7] = DY * 8 / 17; Qe.fastSlerp = function (e, t, n, i) { let o = Qe.dot(e, t), r; o >= 0 ? r = 1 : (r = -1, o = -o); let s = o - 1, a = 1 - n, c = n * n, u = a * a; for (let g = 7; g >= 0; --g)Yh[g] = (yP[g] * c - AP[g]) * s, Xh[g] = (yP[g] * u - AP[g]) * s; let f = r * n * (1 + Yh[0] * (1 + Yh[1] * (1 + Yh[2] * (1 + Yh[3] * (1 + Yh[4] * (1 + Yh[5] * (1 + Yh[6] * (1 + Yh[7])))))))), d = a * (1 + Xh[0] * (1 + Xh[1] * (1 + Xh[2] * (1 + Xh[3] * (1 + Xh[4] * (1 + Xh[5] * (1 + Xh[6] * (1 + Xh[7])))))))), p = Qe.multiplyByScalar(e, d, NCe); return Qe.multiplyByScalar(t, f, i), Qe.add(p, i, i) }; Qe.fastSquad = function (e, t, n, i, o, r) { let s = Qe.fastSlerp(e, t, o, cb), a = Qe.fastSlerp(n, i, o, zA); return Qe.fastSlerp(s, a, 2 * o * (1 - o), r) }; Qe.equals = function (e, t) { return e === t || l(e) && l(t) && e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w }; Qe.equalsEpsilon = function (e, t, n) { return n = y(n, 0), e === t || l(e) && l(t) && Math.abs(e.x - t.x) <= n && Math.abs(e.y - t.y) <= n && Math.abs(e.z - t.z) <= n && Math.abs(e.w - t.w) <= n }; Qe.ZERO = Object.freeze(new Qe(0, 0, 0, 0)); Qe.IDENTITY = Object.freeze(new Qe(0, 0, 0, 1)); Qe.prototype.clone = function (e) { return Qe.clone(this, e) }; Qe.prototype.equals = function (e) { return Qe.equals(this, e) }; Qe.prototype.equalsEpsilon = function (e, t) { return Qe.equalsEpsilon(this, e, t) }; Qe.prototype.toString = function () { return `(${this.x}, ${this.y}, ${this.z}, ${this.w})` }; var Be = Qe; function VCe(e, t, n) { let i = 0, o = e.length - 1, r, s; for (; i <= o;) { if (r = ~~((i + o) / 2), s = n(e[r], t), s < 0) { i = r + 1; continue } if (s > 0) { o = r - 1; continue } return r } return ~(o + 1) } var Wo = VCe; function kCe(e, t, n, i, o) { this.xPoleWander = e, this.yPoleWander = t, this.xPoleOffset = n, this.yPoleOffset = i, this.ut1MinusUtc = o } var a0 = kCe; function UCe(e, t, n, i, o, r, s, a) { this.year = e, this.month = t, this.day = n, this.hour = i, this.minute = o, this.second = r, this.millisecond = s, this.isLeapSecond = a } var Sp = UCe; function zCe(e) { return e % 4 === 0 && e % 100 !== 0 || e % 400 === 0 } var wp = zCe; function HCe(e, t) { this.julianDate = e, this.offset = t } var Bi = HCe; var GCe = { SECONDS_PER_MILLISECOND: .001, SECONDS_PER_MINUTE: 60, MINUTES_PER_HOUR: 60, HOURS_PER_DAY: 24, SECONDS_PER_HOUR: 3600, MINUTES_PER_DAY: 1440, SECONDS_PER_DAY: 86400, DAYS_PER_JULIAN_CENTURY: 36525, PICOSECOND: 1e-9, MODIFIED_JULIAN_DATE_DIFFERENCE: 24000005e-1 }, jn = Object.freeze(GCe); var WCe = { UTC: 0, TAI: 1 }, Hn = Object.freeze(WCe); var PY = new Sp, hH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], mH = 29; function pH(e, t) { return Tt.compare(e.julianDate, t.julianDate) } var HA = new Bi; function xP(e) { HA.julianDate = e; let t = Tt.leapSeconds, n = Wo(t, HA, pH); n < 0 && (n = ~n), n >= t.length && (n = t.length - 1); let i = t[n].offset; n > 0 && Tt.secondsDifference(t[n].julianDate, e) > i && (n--, i = t[n].offset), Tt.addSeconds(e, i, e) } function vY(e, t) { HA.julianDate = e; let n = Tt.leapSeconds, i = Wo(n, HA, pH); if (i < 0 && (i = ~i), i === 0) return Tt.addSeconds(e, -n[0].offset, t); if (i >= n.length) return Tt.addSeconds(e, -n[i - 1].offset, t); let o = Tt.secondsDifference(n[i].julianDate, e); if (o === 0) return Tt.addSeconds(e, -n[i].offset, t); if (!(o <= 1)) return Tt.addSeconds(e, -n[--i].offset, t) } function Dp(e, t, n) { let i = t / jn.SECONDS_PER_DAY | 0; return e += i, t -= jn.SECONDS_PER_DAY * i, t < 0 && (e--, t += jn.SECONDS_PER_DAY), n.dayNumber = e, n.secondsOfDay = t, n } function _H(e, t, n, i, o, r, s) { let a = (t - 14) / 12 | 0, c = e + 4800 + a, u = (1461 * c / 4 | 0) + (367 * (t - 2 - 12 * a) / 12 | 0) - (3 * ((c + 100) / 100 | 0) / 4 | 0) + n - 32075; i = i - 12, i < 0 && (i += 24); let f = r + (i * jn.SECONDS_PER_HOUR + o * jn.SECONDS_PER_MINUTE + s * jn.SECONDS_PER_MILLISECOND); return f >= 43200 && (u -= 1), [u, f] } var jCe = /^(\d{4})$/, qCe = /^(\d{4})-(\d{2})$/, YCe = /^(\d{4})-?(\d{3})$/, XCe = /^(\d{4})-?W(\d{2})-?(\d{1})?$/, KCe = /^(\d{4})-?(\d{2})-?(\d{2})$/, gH = /([Z+\-])?(\d{2})?:?(\d{2})?$/, JCe = /^(\d{2})(\.\d+)?/.source + gH.source, ZCe = /^(\d{2}):?(\d{2})(\.\d+)?/.source + gH.source, QCe = /^(\d{2}):?(\d{2}):?(\d{2})(\.\d+)?/.source + gH.source; function Tt(e, t, n) { this.dayNumber = void 0, this.secondsOfDay = void 0, e = y(e, 0), t = y(t, 0), n = y(n, Hn.UTC); let i = e | 0; t = t + (e - i) * jn.SECONDS_PER_DAY, Dp(i, t, this), n === Hn.UTC && xP(this) } Tt.fromGregorianDate = function (e, t) { let n = _H(e.year, e.month, e.day, e.hour, e.minute, e.second, e.millisecond); return l(t) ? (Dp(n[0], n[1], t), xP(t), t) : new Tt(n[0], n[1], Hn.UTC) }; Tt.fromDate = function (e, t) { let n = _H(e.getUTCFullYear(), e.getUTCMonth() + 1, e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds(), e.getUTCMilliseconds()); return l(t) ? (Dp(n[0], n[1], t), xP(t), t) : new Tt(n[0], n[1], Hn.UTC) }; Tt.fromIso8601 = function (e, t) { e = e.replace(",", "."); let n = e.split("T"), i, o = 1, r = 1, s = 0, a = 0, c = 0, u = 0, f = n[0], d = n[1], p, g; if (n = f.match(KCe), n !== null) i = +n[1], o = +n[2], r = +n[3]; else if (n = f.match(qCe), n !== null) i = +n[1], o = +n[2]; else if (n = f.match(jCe), n !== null) i = +n[1]; else { let x; if (n = f.match(YCe), n !== null) i = +n[1], x = +n[2], g = wp(i); else if (n = f.match(XCe), n !== null) { i = +n[1]; let T = +n[2], b = +n[3] || 0, S = new Date(Date.UTC(i, 0, 4)); x = T * 7 + b - S.getUTCDay() - 3 } p = new Date(Date.UTC(i, 0, 1)), p.setUTCDate(x), o = p.getUTCMonth() + 1, r = p.getUTCDate() } g = wp(i); let m; if (l(d)) { n = d.match(QCe), n !== null ? (s = +n[1], a = +n[2], c = +n[3], u = +(n[4] || 0) * 1e3, m = 5) : (n = d.match(ZCe), n !== null ? (s = +n[1], a = +n[2], c = +(n[3] || 0) * 60, m = 4) : (n = d.match(JCe), n !== null && (s = +n[1], a = +(n[2] || 0) * 60, m = 3))); let x = n[m], T = +n[m + 1], b = +(n[m + 2] || 0); switch (x) { case "+": s = s - T, a = a - b; break; case "-": s = s + T, a = a + b; break; case "Z": break; default: a = a + new Date(Date.UTC(i, o - 1, r, s, a)).getTimezoneOffset(); break } } let A = c === 60; for (A && c--; a >= 60;)a -= 60, s++; for (; s >= 24;)s -= 24, r++; for (p = g && o === 2 ? mH : hH[o - 1]; r > p;)r -= p, o++, o > 12 && (o -= 12, i++), p = g && o === 2 ? mH : hH[o - 1]; for (; a < 0;)a += 60, s--; for (; s < 0;)s += 24, r--; for (; r < 1;)o--, o < 1 && (o += 12, i--), p = g && o === 2 ? mH : hH[o - 1], r += p; let C = _H(i, o, r, s, a, c, u); return l(t) ? (Dp(C[0], C[1], t), xP(t)) : t = new Tt(C[0], C[1], Hn.UTC), A && Tt.addSeconds(t, 1, t), t }; Tt.now = function (e) { return Tt.fromDate(new Date, e) }; var CP = new Tt(0, 0, Hn.TAI); Tt.toGregorianDate = function (e, t) { let n = !1, i = vY(e, CP); l(i) || (Tt.addSeconds(e, -1, CP), i = vY(CP, CP), n = !0); let o = i.dayNumber, r = i.secondsOfDay; r >= 43200 && (o += 1); let s = o + 68569 | 0, a = 4 * s / 146097 | 0; s = s - ((146097 * a + 3) / 4 | 0) | 0; let c = 4e3 * (s + 1) / 1461001 | 0; s = s - (1461 * c / 4 | 0) + 31 | 0; let u = 80 * s / 2447 | 0, f = s - (2447 * u / 80 | 0) | 0; s = u / 11 | 0; let d = u + 2 - 12 * s | 0, p = 100 * (a - 49) + c + s | 0, g = r / jn.SECONDS_PER_HOUR | 0, m = r - g * jn.SECONDS_PER_HOUR, A = m / jn.SECONDS_PER_MINUTE | 0; m = m - A * jn.SECONDS_PER_MINUTE; let C = m | 0, x = (m - C) / jn.SECONDS_PER_MILLISECOND; return g += 12, g > 23 && (g -= 24), n && (C += 1), l(t) ? (t.year = p, t.month = d, t.day = f, t.hour = g, t.minute = A, t.second = C, t.millisecond = x, t.isLeapSecond = n, t) : new Sp(p, d, f, g, A, C, x, n) }; Tt.toDate = function (e) { let t = Tt.toGregorianDate(e, PY), n = t.second; return t.isLeapSecond && (n -= 1), new Date(Date.UTC(t.year, t.month - 1, t.day, t.hour, t.minute, n, t.millisecond)) }; Tt.toIso8601 = function (e, t) { let n = Tt.toGregorianDate(e, PY), i = n.year, o = n.month, r = n.day, s = n.hour, a = n.minute, c = n.second, u = n.millisecond; i === 1e4 && o === 1 && r === 1 && s === 0 && a === 0 && c === 0 && u === 0 && (i = 9999, o = 12, r = 31, s = 24); let f; return !l(t) && u !== 0 ? (f = (u * .01).toString().replace(".", ""), `${i.toString().padStart(4, "0")}-${o.toString().padStart(2, "0")}-${r.toString().padStart(2, "0")}T${s.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}:${c.toString().padStart(2, "0")}.${f}Z`) : !l(t) || t === 0 ? `${i.toString().padStart(4, "0")}-${o.toString().padStart(2, "0")}-${r.toString().padStart(2, "0")}T${s.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}:${c.toString().padStart(2, "0")}Z` : (f = (u * .01).toFixed(t).replace(".", "").slice(0, t), `${i.toString().padStart(4, "0")}-${o.toString().padStart(2, "0")}-${r.toString().padStart(2, "0")}T${s.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}:${c.toString().padStart(2, "0")}.${f}Z`) }; Tt.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.dayNumber = e.dayNumber, t.secondsOfDay = e.secondsOfDay, t) : new Tt(e.dayNumber, e.secondsOfDay, Hn.TAI) }; Tt.compare = function (e, t) { let n = e.dayNumber - t.dayNumber; return n !== 0 ? n : e.secondsOfDay - t.secondsOfDay }; Tt.equals = function (e, t) { return e === t || l(e) && l(t) && e.dayNumber === t.dayNumber && e.secondsOfDay === t.secondsOfDay }; Tt.equalsEpsilon = function (e, t, n) { return n = y(n, 0), e === t || l(e) && l(t) && Math.abs(Tt.secondsDifference(e, t)) <= n }; Tt.totalDays = function (e) { return e.dayNumber + e.secondsOfDay / jn.SECONDS_PER_DAY }; Tt.secondsDifference = function (e, t) { return (e.dayNumber - t.dayNumber) * jn.SECONDS_PER_DAY + (e.secondsOfDay - t.secondsOfDay) }; Tt.daysDifference = function (e, t) { let n = e.dayNumber - t.dayNumber, i = (e.secondsOfDay - t.secondsOfDay) / jn.SECONDS_PER_DAY; return n + i }; Tt.computeTaiMinusUtc = function (e) { HA.julianDate = e; let t = Tt.leapSeconds, n = Wo(t, HA, pH); return n < 0 && (n = ~n, --n, n < 0 && (n = 0)), t[n].offset }; Tt.addSeconds = function (e, t, n) { return Dp(e.dayNumber, e.secondsOfDay + t, n) }; Tt.addMinutes = function (e, t, n) { let i = e.secondsOfDay + t * jn.SECONDS_PER_MINUTE; return Dp(e.dayNumber, i, n) }; Tt.addHours = function (e, t, n) { let i = e.secondsOfDay + t * jn.SECONDS_PER_HOUR; return Dp(e.dayNumber, i, n) }; Tt.addDays = function (e, t, n) { let i = e.dayNumber + t; return Dp(i, e.secondsOfDay, n) }; Tt.lessThan = function (e, t) { return Tt.compare(e, t) < 0 }; Tt.lessThanOrEquals = function (e, t) { return Tt.compare(e, t) <= 0 }; Tt.greaterThan = function (e, t) { return Tt.compare(e, t) > 0 }; Tt.greaterThanOrEquals = function (e, t) { return Tt.compare(e, t) >= 0 }; Tt.prototype.clone = function (e) { return Tt.clone(this, e) }; Tt.prototype.equals = function (e) { return Tt.equals(this, e) }; Tt.prototype.equalsEpsilon = function (e, t) { return Tt.equalsEpsilon(this, e, t) }; Tt.prototype.toString = function () { return Tt.toIso8601(this) }; Tt.leapSeconds = [new Bi(new Tt(2441317, 43210, Hn.TAI), 10), new Bi(new Tt(2441499, 43211, Hn.TAI), 11), new Bi(new Tt(2441683, 43212, Hn.TAI), 12), new Bi(new Tt(2442048, 43213, Hn.TAI), 13), new Bi(new Tt(2442413, 43214, Hn.TAI), 14), new Bi(new Tt(2442778, 43215, Hn.TAI), 15), new Bi(new Tt(2443144, 43216, Hn.TAI), 16), new Bi(new Tt(2443509, 43217, Hn.TAI), 17), new Bi(new Tt(2443874, 43218, Hn.TAI), 18), new Bi(new Tt(2444239, 43219, Hn.TAI), 19), new Bi(new Tt(2444786, 43220, Hn.TAI), 20), new Bi(new Tt(2445151, 43221, Hn.TAI), 21), new Bi(new Tt(2445516, 43222, Hn.TAI), 22), new Bi(new Tt(2446247, 43223, Hn.TAI), 23), new Bi(new Tt(2447161, 43224, Hn.TAI), 24), new Bi(new Tt(2447892, 43225, Hn.TAI), 25), new Bi(new Tt(2448257, 43226, Hn.TAI), 26), new Bi(new Tt(2448804, 43227, Hn.TAI), 27), new Bi(new Tt(2449169, 43228, Hn.TAI), 28), new Bi(new Tt(2449534, 43229, Hn.TAI), 29), new Bi(new Tt(2450083, 43230, Hn.TAI), 30), new Bi(new Tt(2450630, 43231, Hn.TAI), 31), new Bi(new Tt(2451179, 43232, Hn.TAI), 32), new Bi(new Tt(2453736, 43233, Hn.TAI), 33), new Bi(new Tt(2454832, 43234, Hn.TAI), 34), new Bi(new Tt(2456109, 43235, Hn.TAI), 35), new Bi(new Tt(2457204, 43236, Hn.TAI), 36), new Bi(new Tt(2457754, 43237, Hn.TAI), 37)]; var $ = Tt; var $A = po(al(), 1); function $Ce(e) { return (e.length === 0 || e[e.length - 1] !== "/") && (e = `${e}/`), e } var SP = $Ce; function FY(e, t) { if (e === null || typeof e != "object") return e; t = y(t, !1); let n = new e.constructor; for (let i in e) if (e.hasOwnProperty(i)) { let o = e[i]; t && (o = FY(o, t)), n[i] = o } return n } var tt = FY; function NY(e, t, n) { n = y(n, !1); let i = {}, o = l(e), r = l(t), s, a, c; if (o) for (s in e) e.hasOwnProperty(s) && (a = e[s], r && n && typeof a == "object" && t.hasOwnProperty(s) ? (c = t[s], typeof c == "object" ? i[s] = NY(a, c, n) : i[s] = a) : i[s] = a); if (r) for (s in t) t.hasOwnProperty(s) && !i.hasOwnProperty(s) && (c = t[s], i[s] = c); return i } var yt = NY; function exe() { let e, t, n = new Promise(function (i, o) { e = i, t = o }); return { resolve: e, reject: t, promise: n } } var js = exe; var VY = po(al(), 1); function yH(e, t) { let n; return typeof document < "u" && (n = document), yH._implementation(e, t, n) } yH._implementation = function (e, t, n) { if (!l(t)) { if (typeof n > "u") return e; t = y(n.baseURI, n.location.href) } let i = new VY.default(e); return i.scheme() !== "" ? i.toString() : i.absoluteTo(t).toString() }; var vp = yH; var kY = po(al(), 1); function txe(e, t) { let n = "", i = e.lastIndexOf("/"); return i !== -1 && (n = e.substring(0, i + 1)), t && (e = new kY.default(e), e.query().length !== 0 && (n += `?${e.query()}`), e.fragment().length !== 0 && (n += `#${e.fragment()}`)), n } var wP = txe; var UY = po(al(), 1); function nxe(e) { let t = new UY.default(e); t.normalize(); let n = t.path(), i = n.lastIndexOf("/"); return i !== -1 && (n = n.substr(i + 1)), i = n.lastIndexOf("."), i === -1 ? n = "" : n = n.substr(i + 1), n } var jA = nxe; var zY = {}; function ixe(e, t, n) { l(t) || (t = e.width), l(n) || (n = e.height); let i = zY[t]; l(i) || (i = {}, zY[t] = i); let o = i[n]; if (!l(o)) { let r = document.createElement("canvas"); r.width = t, r.height = n, o = r.getContext("2d"), o.globalCompositeOperation = "copy", i[n] = o } return o.drawImage(e, 0, 0, t, n), o.getImageData(0, 0, t, n).data } var Ad = ixe; var oxe = /^blob:/i; function rxe(e) { return oxe.test(e) } var qA = rxe; var Cd; function sxe(e) { l(Cd) || (Cd = document.createElement("a")), Cd.href = window.location.href; let t = Cd.host, n = Cd.protocol; return Cd.href = e, Cd.href = Cd.href, n !== Cd.protocol || t !== Cd.host } var YA = sxe; var axe = /^data:/i; function cxe(e) { return axe.test(e) } var Pp = cxe; function lxe(e) { let t = document.createElement("script"); return t.async = !0, t.src = e, new Promise((n, i) => { window.crossOriginIsolated && t.setAttribute("crossorigin", "anonymous"); let o = document.getElementsByTagName("head")[0]; t.onload = function () { t.onload = void 0, o.removeChild(t), n() }, t.onerror = function (r) { i(r) }, o.appendChild(t) }) } var XA = lxe; function uxe(e) { let t = ""; for (let n in e) if (e.hasOwnProperty(n)) { let i = e[n], o = `${encodeURIComponent(n)}=`; if (Array.isArray(i)) for (let r = 0, s = i.length; r < s; ++r)t += `${o + encodeURIComponent(i[r])}&`; else t += `${o + encodeURIComponent(i)}&` } return t = t.slice(0, -1), t } var KA = uxe; function fxe(e) { let t = {}; if (e === "") return t; let n = e.replace(/\+/g, "%20").split(/[&;]/); for (let i = 0, o = n.length; i < o; ++i) { let r = n[i].split("="), s = decodeURIComponent(r[0]), a = r[1]; l(a) ? a = decodeURIComponent(a) : a = ""; let c = t[s]; typeof c == "string" ? t[s] = [c, a] : Array.isArray(c) ? c.push(a) : t[s] = a } return t } var $l = fxe; var dxe = { UNISSUED: 0, ISSUED: 1, ACTIVE: 2, RECEIVED: 3, CANCELLED: 4, FAILED: 5 }, ri = Object.freeze(dxe); var hxe = { TERRAIN: 0, IMAGERY: 1, TILES3D: 2, OTHER: 3 }, Xr = Object.freeze(hxe); function DP(e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.throttleByServer, !1), n = y(e.throttle, !1); this.url = e.url, this.requestFunction = e.requestFunction, this.cancelFunction = e.cancelFunction, this.priorityFunction = e.priorityFunction, this.priority = y(e.priority, 0), this.throttle = n, this.throttleByServer = t, this.type = y(e.type, Xr.OTHER), this.serverKey = void 0, this.state = ri.UNISSUED, this.deferred = void 0, this.cancelled = !1 } DP.prototype.cancel = function () { this.cancelled = !0 }; DP.prototype.clone = function (e) { return l(e) ? (e.url = this.url, e.requestFunction = this.requestFunction, e.cancelFunction = this.cancelFunction, e.priorityFunction = this.priorityFunction, e.priority = this.priority, e.throttle = this.throttle, e.throttleByServer = this.throttleByServer, e.type = this.type, e.serverKey = this.serverKey, e.state = this.RequestState.UNISSUED, e.deferred = void 0, e.cancelled = !1, e) : new DP(this) }; var jo = DP; function mxe(e) {
        let t = {}; if (!e) return t; let n = e.split(`\r
`); for (let i = 0; i < n.length; ++i) { let o = n[i], r = o.indexOf(": "); if (r > 0) { let s = o.substring(0, r), a = o.substring(r + 2); t[s] = a } } return t
    } var vP = mxe; function HY(e, t, n) { this.statusCode = e, this.response = t, this.responseHeaders = n, typeof this.responseHeaders == "string" && (this.responseHeaders = vP(this.responseHeaders)) } HY.prototype.toString = function () { let e = "Request has failed."; return l(this.statusCode) && (e += ` Status Code: ${this.statusCode}`), e }; var Kh = HY; var lb = po(al(), 1); function c0(e) { this._comparator = e.comparator, this._array = [], this._length = 0, this._maximumLength = void 0 } Object.defineProperties(c0.prototype, { length: { get: function () { return this._length } }, internalArray: { get: function () { return this._array } }, maximumLength: { get: function () { return this._maximumLength }, set: function (e) { let t = this._length; if (e < t) { let n = this._array; for (let i = e; i < t; ++i)n[i] = void 0; this._length = e, n.length = e } this._maximumLength = e } }, comparator: { get: function () { return this._comparator } } }); function AH(e, t, n) { let i = e[t]; e[t] = e[n], e[n] = i } c0.prototype.reserve = function (e) { e = y(e, this._length), this._array.length = e }; c0.prototype.heapify = function (e) { e = y(e, 0); let t = this._length, n = this._comparator, i = this._array, o = -1, r = !0; for (; r;) { let s = 2 * (e + 1), a = s - 1; a < t && n(i[a], i[e]) < 0 ? o = a : o = e, s < t && n(i[s], i[o]) < 0 && (o = s), o !== e ? (AH(i, o, e), e = o) : r = !1 } }; c0.prototype.resort = function () { let e = this._length; for (let t = Math.ceil(e / 2); t >= 0; --t)this.heapify(t) }; c0.prototype.insert = function (e) { let t = this._array, n = this._comparator, i = this._maximumLength, o = this._length++; for (o < t.length ? t[o] = e : t.push(e); o !== 0;) { let s = Math.floor((o - 1) / 2); if (n(t[o], t[s]) < 0) AH(t, o, s), o = s; else break } let r; return l(i) && this._length > i && (r = t[i], this._length = i), r }; c0.prototype.pop = function (e) { if (e = y(e, 0), this._length === 0) return; let t = this._array, n = t[e]; return AH(t, e, --this._length), this.heapify(e), t[this._length] = void 0, n }; var PP = c0; function pxe(e, t) { return e.priority - t.priority } var Ui = { numberOfAttemptedRequests: 0, numberOfActiveRequests: 0, numberOfCancelledRequests: 0, numberOfCancelledActiveRequests: 0, numberOfFailedRequests: 0, numberOfActiveRequestsEver: 0, lastNumberOfActiveRequests: 0 }, JA = 20, da = new PP({ comparator: pxe }); da.maximumLength = JA; da.reserve(JA); var xd = [], Jh = {}, _xe = typeof document < "u" ? new lb.default(document.location.href) : new lb.default, IP = new _e; function Ro() { } Ro.maximumRequests = 50; Ro.maximumRequestsPerServer = 6; Ro.requestsByServer = { "api.cesium.com:443": 18, "assets.cesium.com:443": 18 }; Ro.throttleRequests = !0; Ro.debugShowStatistics = !1; Ro.requestCompletedEvent = IP; Object.defineProperties(Ro, { statistics: { get: function () { return Ui } }, priorityHeapLength: { get: function () { return JA }, set: function (e) { if (e < JA) for (; da.length > e;) { let t = da.pop(); l0(t) } JA = e, da.maximumLength = e, da.reserve(e) } } }); function GY(e) { l(e.priorityFunction) && (e.priority = e.priorityFunction()) } Ro.serverHasOpenSlots = function (e, t) { t = y(t, 1); let n = y(Ro.requestsByServer[e], Ro.maximumRequestsPerServer); return Jh[e] + t <= n }; Ro.heapHasOpenSlots = function (e) { return da.length + e <= JA }; function WY(e) { return e.state === ri.UNISSUED && (e.state = ri.ISSUED, e.deferred = js()), e.deferred.promise } function gxe(e) { return function (t) { if (e.state === ri.CANCELLED) return; let n = e.deferred; --Ui.numberOfActiveRequests, --Jh[e.serverKey], IP.raiseEvent(), e.state = ri.RECEIVED, e.deferred = void 0, n.resolve(t) } } function yxe(e) { return function (t) { e.state !== ri.CANCELLED && (++Ui.numberOfFailedRequests, --Ui.numberOfActiveRequests, --Jh[e.serverKey], IP.raiseEvent(t), e.state = ri.FAILED, e.deferred.reject(t)) } } function jY(e) { let t = WY(e); return e.state = ri.ACTIVE, xd.push(e), ++Ui.numberOfActiveRequests, ++Ui.numberOfActiveRequestsEver, ++Jh[e.serverKey], e.requestFunction().then(gxe(e)).catch(yxe(e)), t } function l0(e) { let t = e.state === ri.ACTIVE; if (e.state = ri.CANCELLED, ++Ui.numberOfCancelledRequests, l(e.deferred)) { let n = e.deferred; e.deferred = void 0, n.reject() } t && (--Ui.numberOfActiveRequests, --Jh[e.serverKey], ++Ui.numberOfCancelledActiveRequests), l(e.cancelFunction) && e.cancelFunction() } Ro.update = function () { let e, t, n = 0, i = xd.length; for (e = 0; e < i; ++e) { if (t = xd[e], t.cancelled && l0(t), t.state !== ri.ACTIVE) { ++n; continue } n > 0 && (xd[e - n] = t) } xd.length -= n; let o = da.internalArray, r = da.length; for (e = 0; e < r; ++e)GY(o[e]); da.resort(); let s = Math.max(Ro.maximumRequests - xd.length, 0), a = 0; for (; a < s && da.length > 0;) { if (t = da.pop(), t.cancelled) { l0(t); continue } if (t.throttleByServer && !Ro.serverHasOpenSlots(t.serverKey)) { l0(t); continue } jY(t), ++a } Axe() }; Ro.getServerKey = function (e) { let t = new lb.default(e); t.scheme() === "" && (t = new lb.default(e).absoluteTo(_xe), t.normalize()); let n = t.authority(); /:/.test(n) || (n = `${n}:${t.scheme() === "https" ? "443" : "80"}`); let i = Jh[n]; return l(i) || (Jh[n] = 0), n }; Ro.request = function (e) { if (Pp(e.url) || qA(e.url)) return IP.raiseEvent(), e.state = ri.RECEIVED, e.requestFunction(); if (++Ui.numberOfAttemptedRequests, l(e.serverKey) || (e.serverKey = Ro.getServerKey(e.url)), Ro.throttleRequests && e.throttleByServer && !Ro.serverHasOpenSlots(e.serverKey)) return; if (!Ro.throttleRequests || !e.throttle) return jY(e); if (xd.length >= Ro.maximumRequests) return; GY(e); let t = da.insert(e); if (l(t)) { if (t === e) return; l0(t) } return WY(e) }; function Axe() { !Ro.debugShowStatistics || (Ui.numberOfActiveRequests === 0 && Ui.lastNumberOfActiveRequests > 0 && (Ui.numberOfAttemptedRequests > 0 && (console.log(`Number of attempted requests: ${Ui.numberOfAttemptedRequests}`), Ui.numberOfAttemptedRequests = 0), Ui.numberOfCancelledRequests > 0 && (console.log(`Number of cancelled requests: ${Ui.numberOfCancelledRequests}`), Ui.numberOfCancelledRequests = 0), Ui.numberOfCancelledActiveRequests > 0 && (console.log(`Number of cancelled active requests: ${Ui.numberOfCancelledActiveRequests}`), Ui.numberOfCancelledActiveRequests = 0), Ui.numberOfFailedRequests > 0 && (console.log(`Number of failed requests: ${Ui.numberOfFailedRequests}`), Ui.numberOfFailedRequests = 0)), Ui.lastNumberOfActiveRequests = Ui.numberOfActiveRequests) } Ro.clearForSpecs = function () { for (; da.length > 0;) { let t = da.pop(); l0(t) } let e = xd.length; for (let t = 0; t < e; ++t)l0(xd[t]); xd.length = 0, Jh = {}, Ui.numberOfAttemptedRequests = 0, Ui.numberOfActiveRequests = 0, Ui.numberOfCancelledRequests = 0, Ui.numberOfCancelledActiveRequests = 0, Ui.numberOfFailedRequests = 0, Ui.numberOfActiveRequestsEver = 0, Ui.lastNumberOfActiveRequests = 0 }; Ro.numberOfActiveRequestsByServer = function (e) { return Jh[e] }; Ro.requestHeap = da; var Ya = Ro; var qY = po(al(), 1); var ub = {}, ZA = {}; ub.add = function (e, t) { let n = `${e.toLowerCase()}:${t}`; l(ZA[n]) || (ZA[n] = !0) }; ub.remove = function (e, t) { let n = `${e.toLowerCase()}:${t}`; l(ZA[n]) && delete ZA[n] }; function Cxe(e) { let t = new qY.default(e); t.normalize(); let n = t.authority(); if (n.length !== 0) { if (t.authority(n), n.indexOf("@") !== -1 && (n = n.split("@")[1]), n.indexOf(":") === -1) { let i = t.scheme(); if (i.length === 0 && (i = window.location.protocol, i = i.substring(0, i.length - 1)), i === "http") n += ":80"; else if (i === "https") n += ":443"; else return } return n } } ub.contains = function (e) { let t = Cxe(e); return !!(l(t) && l(ZA[t])) }; ub.clear = function () { ZA = {} }; var fb = ub; var KY = function () { try { let e = new XMLHttpRequest; return e.open("GET", "#", !0), e.responseType = "blob", e.responseType === "blob" } catch { return !1 } }(); function xH(e, t, n, i) { let o = e.query(); if (o.length === 0) return {}; let r; if (o.indexOf("=") === -1) { let s = {}; s[o] = void 0, r = s } else r = $l(o); n ? t._queryParameters = BP(r, t._queryParameters, i) : t._queryParameters = r, e.search("") } function xxe(e, t) { let n = t._queryParameters, i = Object.keys(n); i.length === 1 && !l(n[i[0]]) ? e.search(i[0]) : e.search(KA(n)) } function Td(e, t) { return l(e) ? l(e.clone) ? e.clone() : tt(e) : t } function TH(e) { if (e.state === ri.ISSUED || e.state === ri.ACTIVE) throw new fe("The Resource is already being fetched."); e.state = ri.UNISSUED, e.deferred = void 0 } function BP(e, t, n) { if (!n) return yt(e, t); let i = tt(e, !0); for (let o in t) if (t.hasOwnProperty(o)) { let r = i[o], s = t[o]; l(r) ? (Array.isArray(r) || (r = i[o] = [r]), i[o] = r.concat(s)) : i[o] = Array.isArray(s) ? s.slice() : s } return i } function Et(e) { e = y(e, y.EMPTY_OBJECT), typeof e == "string" && (e = { url: e }), this._url = void 0, this._templateValues = Td(e.templateValues, {}), this._queryParameters = Td(e.queryParameters, {}), this.headers = Td(e.headers, {}), this.request = y(e.request, new jo), this.proxy = e.proxy, this.retryCallback = e.retryCallback, this.retryAttempts = y(e.retryAttempts, 0), this._retryCount = 0; let t = new $A.default(e.url); xH(t, this, !0, !0), t.fragment(""), this._url = t.toString() } Et.createIfNeeded = function (e) { return e instanceof Et ? e.getDerivedResource({ request: e.request }) : typeof e != "string" ? e : new Et({ url: e }) }; var QA; Et.supportsImageBitmapOptions = function () { if (l(QA)) return QA; if (typeof createImageBitmap != "function") return QA = Promise.resolve(!1), QA; let e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAABGdBTUEAAE4g3rEiDgAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAADElEQVQI12Ng6GAAAAEUAIngE3ZiAAAAAElFTkSuQmCC"; return QA = Et.fetchBlob({ url: e }).then(function (t) { let n = { imageOrientation: "flipY", premultiplyAlpha: "none", colorSpaceConversion: "none" }; return Promise.all([createImageBitmap(t, n), createImageBitmap(t)]) }).then(function (t) { let n = Ad(t[0]), i = Ad(t[1]); return n[1] !== i[1] }).catch(function () { return !1 }), QA }; Object.defineProperties(Et, { isBlobSupported: { get: function () { return KY } } }); Object.defineProperties(Et.prototype, { queryParameters: { get: function () { return this._queryParameters } }, templateValues: { get: function () { return this._templateValues } }, url: { get: function () { return this.getUrlComponent(!0, !0) }, set: function (e) { let t = new $A.default(e); xH(t, this, !1), t.fragment(""), this._url = t.toString() } }, extension: { get: function () { return jA(this._url) } }, isDataUri: { get: function () { return Pp(this._url) } }, isBlobUri: { get: function () { return qA(this._url) } }, isCrossOriginUrl: { get: function () { return YA(this._url) } }, hasHeaders: { get: function () { return Object.keys(this.headers).length > 0 } } }); Et.prototype.toString = function () { return this.getUrlComponent(!0, !0) }; Et.prototype.getUrlComponent = function (e, t) { if (this.isDataUri) return this._url; let n = new $A.default(this._url); e && xxe(n, this); let i = n.toString().replace(/%7B/g, "{").replace(/%7D/g, "}"), o = this._templateValues; return i = i.replace(/{(.*?)}/g, function (r, s) { let a = o[s]; return l(a) ? encodeURIComponent(a) : r }), t && l(this.proxy) && (i = this.proxy.getURL(i)), i }; Et.prototype.setQueryParameters = function (e, t) { t ? this._queryParameters = BP(this._queryParameters, e, !1) : this._queryParameters = BP(e, this._queryParameters, !1) }; Et.prototype.appendQueryParameters = function (e) { this._queryParameters = BP(e, this._queryParameters, !0) }; Et.prototype.setTemplateValues = function (e, t) { t ? this._templateValues = yt(this._templateValues, e) : this._templateValues = yt(e, this._templateValues) }; Et.prototype.getDerivedResource = function (e) { let t = this.clone(); if (t._retryCount = 0, l(e.url)) { let n = new $A.default(e.url), i = y(e.preserveQueryParameters, !1); xH(n, t, !0, i), n.fragment(""), n.scheme() !== "" ? t._url = n.toString() : t._url = n.absoluteTo(new $A.default(vp(this._url))).toString() } return l(e.queryParameters) && (t._queryParameters = yt(e.queryParameters, t._queryParameters)), l(e.templateValues) && (t._templateValues = yt(e.templateValues, t.templateValues)), l(e.headers) && (t.headers = yt(e.headers, t.headers)), l(e.proxy) && (t.proxy = e.proxy), l(e.request) && (t.request = e.request), l(e.retryCallback) && (t.retryCallback = e.retryCallback), l(e.retryAttempts) && (t.retryAttempts = e.retryAttempts), t }; Et.prototype.retryOnError = function (e) { let t = this.retryCallback; if (typeof t != "function" || this._retryCount >= this.retryAttempts) return Promise.resolve(!1); let n = this; return Promise.resolve(t(this, e)).then(function (i) { return ++n._retryCount, i }) }; Et.prototype.clone = function (e) { return l(e) || (e = new Et({ url: this._url })), e._url = this._url, e._queryParameters = tt(this._queryParameters), e._templateValues = tt(this._templateValues), e.headers = tt(this.headers), e.proxy = this.proxy, e.retryCallback = this.retryCallback, e.retryAttempts = this.retryAttempts, e._retryCount = 0, e.request = this.request.clone(), e }; Et.prototype.getBaseUri = function (e) { return wP(this.getUrlComponent(e), e) }; Et.prototype.appendForwardSlash = function () { this._url = SP(this._url) }; Et.prototype.fetchArrayBuffer = function () { return this.fetch({ responseType: "arraybuffer" }) }; Et.fetchArrayBuffer = function (e) { return new Et(e).fetchArrayBuffer() }; Et.prototype.fetchBlob = function () { return this.fetch({ responseType: "blob" }) }; Et.fetchBlob = function (e) { return new Et(e).fetchBlob() }; Et.prototype.fetchImage = function (e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.preferImageBitmap, !1), n = y(e.preferBlob, !1), i = y(e.flipY, !1), o = y(e.skipColorSpaceConversion, !1); if (TH(this.request), !KY || this.isDataUri || this.isBlobUri || !this.hasHeaders && !n) return CH({ resource: this, flipY: i, skipColorSpaceConversion: o, preferImageBitmap: t }); let r = this.fetchBlob(); if (!l(r)) return; let s, a, c, u; return Et.supportsImageBitmapOptions().then(function (f) { return s = f, a = s && t, r }).then(function (f) { if (!l(f)) return; if (u = f, a) return Et.createImageBitmapFromBlob(f, { flipY: i, premultiplyAlpha: !1, skipColorSpaceConversion: o }); let d = window.URL.createObjectURL(f); return c = new Et({ url: d }), CH({ resource: c, flipY: i, skipColorSpaceConversion: o, preferImageBitmap: !1 }) }).then(function (f) { if (!!l(f)) return f.blob = u, a || window.URL.revokeObjectURL(c.url), f }).catch(function (f) { return l(c) && window.URL.revokeObjectURL(c.url), f.blob = u, Promise.reject(f) }) }; function CH(e) { let t = e.resource, n = e.flipY, i = e.skipColorSpaceConversion, o = e.preferImageBitmap, r = t.request; r.url = t.url, r.requestFunction = function () { let a = !1; !t.isDataUri && !t.isBlobUri && (a = t.isCrossOriginUrl); let c = js(); return Et._Implementations.createImage(r, a, c, n, i, o), c.promise }; let s = Ya.request(r); if (!!l(s)) return s.catch(function (a) { return r.state !== ri.FAILED ? Promise.reject(a) : t.retryOnError(a).then(function (c) { return c ? (r.state = ri.UNISSUED, r.deferred = void 0, CH({ resource: t, flipY: n, skipColorSpaceConversion: i, preferImageBitmap: o })) : Promise.reject(a) }) }) } Et.fetchImage = function (e) { return new Et(e).fetchImage({ flipY: e.flipY, skipColorSpaceConversion: e.skipColorSpaceConversion, preferBlob: e.preferBlob, preferImageBitmap: e.preferImageBitmap }) }; Et.prototype.fetchText = function () { return this.fetch({ responseType: "text" }) }; Et.fetchText = function (e) { return new Et(e).fetchText() }; Et.prototype.fetchJson = function () { let e = this.fetch({ responseType: "text", headers: { Accept: "application/json,*/*;q=0.01" } }); if (!!l(e)) return e.then(function (t) { if (!!l(t)) return JSON.parse(t) }) }; Et.fetchJson = function (e) { return new Et(e).fetchJson() }; Et.prototype.fetchXML = function () { return this.fetch({ responseType: "document", overrideMimeType: "text/xml" }) }; Et.fetchXML = function (e) { return new Et(e).fetchXML() }; Et.prototype.fetchJsonp = function (e) { e = y(e, "callback"), TH(this.request); let t; do t = `loadJsonp${I.nextRandomNumber().toString().substring(2, 8)}`; while (l(window[t])); return JY(this, e, t) }; function JY(e, t, n) { let i = {}; i[t] = n, e.setQueryParameters(i); let o = e.request; o.url = e.url, o.requestFunction = function () { let s = js(); return window[n] = function (a) { s.resolve(a); try { delete window[n] } catch { window[n] = void 0 } }, Et._Implementations.loadAndExecuteScript(e.url, n, s), s.promise }; let r = Ya.request(o); if (!!l(r)) return r.catch(function (s) { return o.state !== ri.FAILED ? Promise.reject(s) : e.retryOnError(s).then(function (a) { return a ? (o.state = ri.UNISSUED, o.deferred = void 0, JY(e, t, n)) : Promise.reject(s) }) }) } Et.fetchJsonp = function (e) { return new Et(e).fetchJsonp(e.callbackParameterName) }; Et.prototype._makeRequest = function (e) { let t = this; TH(t.request); let n = t.request; n.url = t.url, n.requestFunction = function () { let o = e.responseType, r = yt(e.headers, t.headers), s = e.overrideMimeType, a = e.method, c = e.data, u = js(), f = Et._Implementations.loadWithXhr(t.url, o, a, c, r, u, s); return l(f) && l(f.abort) && (n.cancelFunction = function () { f.abort() }), u.promise }; let i = Ya.request(n); if (!!l(i)) return i.then(function (o) { return n.cancelFunction = void 0, o }).catch(function (o) { return n.cancelFunction = void 0, n.state !== ri.FAILED ? Promise.reject(o) : t.retryOnError(o).then(function (r) { return r ? (n.state = ri.UNISSUED, n.deferred = void 0, t.fetch(e)) : Promise.reject(o) }) }) }; var Txe = /^data:(.*?)(;base64)?,(.*)$/; function OP(e, t) { let n = decodeURIComponent(t); return e ? atob(n) : n } function YY(e, t) { let n = OP(e, t), i = new ArrayBuffer(n.length), o = new Uint8Array(i); for (let r = 0; r < n.length; r++)o[r] = n.charCodeAt(r); return i } function Exe(e, t) { t = y(t, ""); let n = e[1], i = !!e[2], o = e[3], r, s; switch (t) { case "": case "text": return OP(i, o); case "arraybuffer": return YY(i, o); case "blob": return r = YY(i, o), new Blob([r], { type: n }); case "document": return s = new DOMParser, s.parseFromString(OP(i, o), n); case "json": return JSON.parse(OP(i, o)); default: } } Et.prototype.fetch = function (e) { return e = Td(e, {}), e.method = "GET", this._makeRequest(e) }; Et.fetch = function (e) { return new Et(e).fetch({ responseType: e.responseType, overrideMimeType: e.overrideMimeType }) }; Et.prototype.delete = function (e) { return e = Td(e, {}), e.method = "DELETE", this._makeRequest(e) }; Et.delete = function (e) { return new Et(e).delete({ responseType: e.responseType, overrideMimeType: e.overrideMimeType, data: e.data }) }; Et.prototype.head = function (e) { return e = Td(e, {}), e.method = "HEAD", this._makeRequest(e) }; Et.head = function (e) { return new Et(e).head({ responseType: e.responseType, overrideMimeType: e.overrideMimeType }) }; Et.prototype.options = function (e) { return e = Td(e, {}), e.method = "OPTIONS", this._makeRequest(e) }; Et.options = function (e) { return new Et(e).options({ responseType: e.responseType, overrideMimeType: e.overrideMimeType }) }; Et.prototype.post = function (e, t) { return rl.defined("data", e), t = Td(t, {}), t.method = "POST", t.data = e, this._makeRequest(t) }; Et.post = function (e) { return new Et(e).post(e.data, { responseType: e.responseType, overrideMimeType: e.overrideMimeType }) }; Et.prototype.put = function (e, t) { return rl.defined("data", e), t = Td(t, {}), t.method = "PUT", t.data = e, this._makeRequest(t) }; Et.put = function (e) { return new Et(e).put(e.data, { responseType: e.responseType, overrideMimeType: e.overrideMimeType }) }; Et.prototype.patch = function (e, t) { return rl.defined("data", e), t = Td(t, {}), t.method = "PATCH", t.data = e, this._makeRequest(t) }; Et.patch = function (e) { return new Et(e).patch(e.data, { responseType: e.responseType, overrideMimeType: e.overrideMimeType }) }; Et._Implementations = {}; Et._Implementations.loadImageElement = function (e, t, n) { let i = new Image; i.onload = function () { i.naturalWidth === 0 && i.naturalHeight === 0 && i.width === 0 && i.height === 0 && (i.width = 300, i.height = 150), n.resolve(i) }, i.onerror = function (o) { n.reject(o) }, t && (fb.contains(e) ? i.crossOrigin = "use-credentials" : i.crossOrigin = ""), i.src = e }; Et._Implementations.createImage = function (e, t, n, i, o, r) { let s = e.url; Et.supportsImageBitmapOptions().then(function (a) { if (!(a && r)) { Et._Implementations.loadImageElement(s, t, n); return } let c = "blob", u = "GET", f = js(), d = Et._Implementations.loadWithXhr(s, c, u, void 0, void 0, f, void 0, void 0, void 0); return l(d) && l(d.abort) && (e.cancelFunction = function () { d.abort() }), f.promise.then(function (p) { if (!l(p)) { n.reject(new fe(`Successfully retrieved ${s} but it contained no content.`)); return } return Et.createImageBitmapFromBlob(p, { flipY: i, premultiplyAlpha: !1, skipColorSpaceConversion: o }) }).then(function (p) { n.resolve(p) }) }).catch(function (a) { n.reject(a) }) }; Et.createImageBitmapFromBlob = function (e, t) { return rl.defined("options", t), rl.typeOf.bool("options.flipY", t.flipY), rl.typeOf.bool("options.premultiplyAlpha", t.premultiplyAlpha), rl.typeOf.bool("options.skipColorSpaceConversion", t.skipColorSpaceConversion), createImageBitmap(e, { imageOrientation: t.flipY ? "flipY" : "none", premultiplyAlpha: t.premultiplyAlpha ? "premultiply" : "none", colorSpaceConversion: t.skipColorSpaceConversion ? "none" : "default" }) }; function XY(e, t) { switch (t) { case "text": return e.toString("utf8"); case "json": return JSON.parse(e.toString("utf8")); default: return new Uint8Array(e).buffer } } function bxe(e, t, n, i, o, r, s) { let a, c; Promise.all([import("url"), import("zlib")]).then(([u, f]) => (a = u.parse(e), c = f, a.protocol === "https:" ? import("https") : import("http"))).then(u => { let f = { protocol: a.protocol, hostname: a.hostname, port: a.port, path: a.path, query: a.query, method: n, headers: o }; u.request(f).on("response", function (d) { if (d.statusCode < 200 || d.statusCode >= 300) { r.reject(new Kh(d.statusCode, d, d.headers)); return } let p = []; d.on("data", function (g) { p.push(g) }), d.on("end", function () { let g = Buffer.concat(p); d.headers["content-encoding"] === "gzip" ? c.gunzip(g, function (m, A) { m ? r.reject(new fe("Error decompressing response.")) : r.resolve(XY(A, t)) }) : r.resolve(XY(g, t)) }) }).on("error", function (d) { r.reject(new Kh) }).end() }) } var Sxe = typeof XMLHttpRequest > "u"; Et._Implementations.loadWithXhr = function (e, t, n, i, o, r, s) { let a = Txe.exec(e); if (a !== null) { r.resolve(Exe(a, t)); return } if (Sxe) { bxe(e, t, n, i, o, r, s); return } let c = new XMLHttpRequest; if (fb.contains(e) && (c.withCredentials = !0), c.open(n, e, !0), l(s) && l(c.overrideMimeType) && c.overrideMimeType(s), l(o)) for (let f in o) o.hasOwnProperty(f) && c.setRequestHeader(f, o[f]); l(t) && (c.responseType = t); let u = !1; return typeof e == "string" && (u = e.indexOf("file://") === 0 || typeof window < "u" && window.location.origin === "file://"), c.onload = function () { if ((c.status < 200 || c.status >= 300) && !(u && c.status === 0)) { r.reject(new Kh(c.status, c.response, c.getAllResponseHeaders())); return } let f = c.response, d = c.responseType; if (n === "HEAD" || n === "OPTIONS") { let g = c.getAllResponseHeaders().trim().split(/[\r\n]+/), m = {}; g.forEach(function (A) { let C = A.split(": "), x = C.shift(); m[x] = C.join(": ") }), r.resolve(m); return } if (c.status === 204) r.resolve(); else if (l(f) && (!l(t) || d === t)) r.resolve(f); else if (t === "json" && typeof f == "string") try { r.resolve(JSON.parse(f)) } catch (p) { r.reject(p) } else (d === "" || d === "document") && l(c.responseXML) && c.responseXML.hasChildNodes() ? r.resolve(c.responseXML) : (d === "" || d === "text") && l(c.responseText) ? r.resolve(c.responseText) : r.reject(new fe("Invalid XMLHttpRequest response type.")) }, c.onerror = function (f) { r.reject(new Kh) }, c.send(i), c }; Et._Implementations.loadAndExecuteScript = function (e, t, n) { return XA(e, t).catch(function (i) { n.reject(i) }) }; Et._DefaultImplementations = {}; Et._DefaultImplementations.createImage = Et._Implementations.createImage; Et._DefaultImplementations.loadWithXhr = Et._Implementations.loadWithXhr; Et._DefaultImplementations.loadAndExecuteScript = Et._Implementations.loadAndExecuteScript; Et.DEFAULT = Object.freeze(new Et({ url: typeof document > "u" ? "" : document.location.href.split("?")[0] })); var Pe = Et; function RP(e) { if (e = y(e, y.EMPTY_OBJECT), this._dates = void 0, this._samples = void 0, this._dateColumn = -1, this._xPoleWanderRadiansColumn = -1, this._yPoleWanderRadiansColumn = -1, this._ut1MinusUtcSecondsColumn = -1, this._xCelestialPoleOffsetRadiansColumn = -1, this._yCelestialPoleOffsetRadiansColumn = -1, this._taiMinusUtcSecondsColumn = -1, this._columnCount = 0, this._lastIndex = -1, this._downloadPromise = void 0, this._dataError = void 0, this._addNewLeapSeconds = y(e.addNewLeapSeconds, !0), l(e.data)) EH(this, e.data); else if (l(e.url)) { let t = Pe.createIfNeeded(e.url), n = this; this._downloadPromise = t.fetchJson().then(function (i) { EH(n, i) }).catch(function () { n._dataError = `An error occurred while retrieving the EOP data from the URL ${t.url}.` }) } else EH(this, { columnNames: ["dateIso8601", "modifiedJulianDateUtc", "xPoleWanderRadians", "yPoleWanderRadians", "ut1MinusUtcSeconds", "lengthOfDayCorrectionSeconds", "xCelestialPoleOffsetRadians", "yCelestialPoleOffsetRadians", "taiMinusUtcSeconds"], samples: [] }) } RP.NONE = Object.freeze({ getPromiseToLoad: function () { return Promise.resolve() }, compute: function (e, t) { return l(t) ? (t.xPoleWander = 0, t.yPoleWander = 0, t.xPoleOffset = 0, t.yPoleOffset = 0, t.ut1MinusUtc = 0) : t = new a0(0, 0, 0, 0, 0), t } }); RP.prototype.getPromiseToLoad = function () { return Promise.resolve(this._downloadPromise) }; RP.prototype.compute = function (e, t) { if (!l(this._samples)) { if (l(this._dataError)) throw new fe(this._dataError); return } if (l(t) || (t = new a0(0, 0, 0, 0, 0)), this._samples.length === 0) return t.xPoleWander = 0, t.yPoleWander = 0, t.xPoleOffset = 0, t.yPoleOffset = 0, t.ut1MinusUtc = 0, t; let n = this._dates, i = this._lastIndex, o = 0, r = 0; if (l(i)) { let a = n[i], c = n[i + 1], u = $.lessThanOrEquals(a, e), f = !l(c), d = f || $.greaterThanOrEquals(c, e); if (u && d) return o = i, !f && c.equals(e) && ++o, r = o + 1, QY(this, n, this._samples, e, o, r, t), t } let s = Wo(n, e, $.compare, this._dateColumn); return s >= 0 ? (s < n.length - 1 && n[s + 1].equals(e) && ++s, o = s, r = s) : (r = ~s, o = r - 1, o < 0 && (o = 0)), this._lastIndex = o, QY(this, n, this._samples, e, o, r, t), t }; function wxe(e, t) { return $.compare(e.julianDate, t) } function EH(e, t) { if (!l(t.columnNames)) { e._dataError = "Error in loaded EOP data: The columnNames property is required."; return } if (!l(t.samples)) { e._dataError = "Error in loaded EOP data: The samples property is required."; return } let n = t.columnNames.indexOf("modifiedJulianDateUtc"), i = t.columnNames.indexOf("xPoleWanderRadians"), o = t.columnNames.indexOf("yPoleWanderRadians"), r = t.columnNames.indexOf("ut1MinusUtcSeconds"), s = t.columnNames.indexOf("xCelestialPoleOffsetRadians"), a = t.columnNames.indexOf("yCelestialPoleOffsetRadians"), c = t.columnNames.indexOf("taiMinusUtcSeconds"); if (n < 0 || i < 0 || o < 0 || r < 0 || s < 0 || a < 0 || c < 0) { e._dataError = "Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns"; return } let u = e._samples = t.samples, f = e._dates = []; e._dateColumn = n, e._xPoleWanderRadiansColumn = i, e._yPoleWanderRadiansColumn = o, e._ut1MinusUtcSecondsColumn = r, e._xCelestialPoleOffsetRadiansColumn = s, e._yCelestialPoleOffsetRadiansColumn = a, e._taiMinusUtcSecondsColumn = c, e._columnCount = t.columnNames.length, e._lastIndex = void 0; let d, p = e._addNewLeapSeconds; for (let g = 0, m = u.length; g < m; g += e._columnCount) { let A = u[g + n], C = u[g + c], x = A + jn.MODIFIED_JULIAN_DATE_DIFFERENCE, T = new $(x, C, Hn.TAI); if (f.push(T), p) { if (C !== d && l(d)) { let b = $.leapSeconds, S = Wo(b, T, wxe); if (S < 0) { let D = new Bi(T, C); b.splice(~S, 0, D) } } d = C } } } function ZY(e, t, n, i, o) { let r = n * i; o.xPoleWander = t[r + e._xPoleWanderRadiansColumn], o.yPoleWander = t[r + e._yPoleWanderRadiansColumn], o.xPoleOffset = t[r + e._xCelestialPoleOffsetRadiansColumn], o.yPoleOffset = t[r + e._yCelestialPoleOffsetRadiansColumn], o.ut1MinusUtc = t[r + e._ut1MinusUtcSecondsColumn] } function db(e, t, n) { return t + e * (n - t) } function QY(e, t, n, i, o, r, s) { let a = e._columnCount; if (r > t.length - 1) return s.xPoleWander = 0, s.yPoleWander = 0, s.xPoleOffset = 0, s.yPoleOffset = 0, s.ut1MinusUtc = 0, s; let c = t[o], u = t[r]; if (c.equals(u) || i.equals(c)) return ZY(e, n, o, a, s), s; if (i.equals(u)) return ZY(e, n, r, a, s), s; let f = $.secondsDifference(i, c) / $.secondsDifference(u, c), d = o * a, p = r * a, g = n[d + e._ut1MinusUtcSecondsColumn], m = n[p + e._ut1MinusUtcSecondsColumn], A = m - g; if (A > .5 || A < -.5) { let C = n[d + e._taiMinusUtcSecondsColumn], x = n[p + e._taiMinusUtcSecondsColumn]; C !== x && (u.equals(i) ? g = m : m -= x - C) } return s.xPoleWander = db(f, n[d + e._xPoleWanderRadiansColumn], n[p + e._xPoleWanderRadiansColumn]), s.yPoleWander = db(f, n[d + e._yPoleWanderRadiansColumn], n[p + e._yPoleWanderRadiansColumn]), s.xPoleOffset = db(f, n[d + e._xCelestialPoleOffsetRadiansColumn], n[p + e._xCelestialPoleOffsetRadiansColumn]), s.yPoleOffset = db(f, n[d + e._yCelestialPoleOffsetRadiansColumn], n[p + e._yCelestialPoleOffsetRadiansColumn]), s.ut1MinusUtc = db(f, g, m), s } var MP = RP; function ha(e, t, n) { this.heading = y(e, 0), this.pitch = y(t, 0), this.roll = y(n, 0) } ha.fromQuaternion = function (e, t) { l(t) || (t = new ha); let n = 2 * (e.w * e.y - e.z * e.x), i = 1 - 2 * (e.x * e.x + e.y * e.y), o = 2 * (e.w * e.x + e.y * e.z), r = 1 - 2 * (e.y * e.y + e.z * e.z), s = 2 * (e.w * e.z + e.x * e.y); return t.heading = -Math.atan2(s, r), t.roll = Math.atan2(o, i), t.pitch = -I.asinClamped(n), t }; ha.fromDegrees = function (e, t, n, i) { return l(i) || (i = new ha), i.heading = e * I.RADIANS_PER_DEGREE, i.pitch = t * I.RADIANS_PER_DEGREE, i.roll = n * I.RADIANS_PER_DEGREE, i }; ha.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.heading = e.heading, t.pitch = e.pitch, t.roll = e.roll, t) : new ha(e.heading, e.pitch, e.roll) }; ha.equals = function (e, t) { return e === t || l(e) && l(t) && e.heading === t.heading && e.pitch === t.pitch && e.roll === t.roll }; ha.equalsEpsilon = function (e, t, n, i) { return e === t || l(e) && l(t) && I.equalsEpsilon(e.heading, t.heading, n, i) && I.equalsEpsilon(e.pitch, t.pitch, n, i) && I.equalsEpsilon(e.roll, t.roll, n, i) }; ha.prototype.clone = function (e) { return ha.clone(this, e) }; ha.prototype.equals = function (e) { return ha.equals(this, e) }; ha.prototype.equalsEpsilon = function (e, t, n) { return ha.equalsEpsilon(this, e, t, n) }; ha.prototype.toString = function () { return `(${this.heading}, ${this.pitch}, ${this.roll})` }; var lf = ha; var $Y = /((?:.*\/)|^)Cesium\.js(?:\?|\#|$)/; function Dxe() { let e = document.getElementsByTagName("script"); for (let t = 0, n = e.length; t < n; ++t) { let i = e[t].getAttribute("src"), o = $Y.exec(i); if (o !== null) return o[1] } } var eC; function eX(e) { return typeof document > "u" ? e : (l(eC) || (eC = document.createElement("a")), eC.href = e, eC.href = eC.href, eC.href) } var u0; function tX() { if (l(u0)) return u0; let e; return typeof CESIUM_BASE_URL < "u" ? e = CESIUM_BASE_URL : typeof define == "object" && l(define.amd) && !define.amd.toUrlUndefined && l(xp.toUrl) ? e = vp("..", f0("Core/buildModuleUrl.js")) : e = Dxe(), u0 = new Pe({ url: eX(e) }), u0.appendForwardSlash(), u0 } function vxe(e) { return eX(xp.toUrl(`../${e}`)) } function nX(e) { return tX().getDerivedResource({ url: e }).url } var LP; function f0(e) { return l(LP) || (typeof define == "object" && l(define.amd) && !define.amd.toUrlUndefined && l(xp.toUrl) ? LP = vxe : LP = nX), LP(e) } f0._cesiumScriptRegex = $Y; f0._buildModuleUrlFromBaseUrl = nX; f0._clearBaseResource = function () { u0 = void 0 }; f0.setBaseUrl = function (e) { u0 = Pe.DEFAULT.getDerivedResource({ url: e }) }; f0.getCesiumBaseUrl = tX; var Jt = f0; function Pxe(e, t, n) { this.x = e, this.y = t, this.s = n } var tC = Pxe; function wH(e) { e = y(e, y.EMPTY_OBJECT), this._xysFileUrlTemplate = Pe.createIfNeeded(e.xysFileUrlTemplate), this._interpolationOrder = y(e.interpolationOrder, 9), this._sampleZeroJulianEphemerisDate = y(e.sampleZeroJulianEphemerisDate, 24423965e-1), this._sampleZeroDateTT = new $(this._sampleZeroJulianEphemerisDate, 0, Hn.TAI), this._stepSizeDays = y(e.stepSizeDays, 1), this._samplesPerXysFile = y(e.samplesPerXysFile, 1e3), this._totalSamples = y(e.totalSamples, 27426), this._samples = new Array(this._totalSamples * 3), this._chunkDownloadsInProgress = []; let t = this._interpolationOrder, n = this._denominators = new Array(t + 1), i = this._xTable = new Array(t + 1), o = Math.pow(this._stepSizeDays, t); for (let r = 0; r <= t; ++r) { n[r] = o, i[r] = r * this._stepSizeDays; for (let s = 0; s <= t; ++s)s !== r && (n[r] *= r - s); n[r] = 1 / n[r] } this._work = new Array(t + 1), this._coef = new Array(t + 1) } var Ixe = new $(0, 0, Hn.TAI); function bH(e, t, n) { let i = Ixe; return i.dayNumber = t, i.secondsOfDay = n, $.daysDifference(i, e._sampleZeroDateTT) } wH.prototype.preload = function (e, t, n, i) { let o = bH(this, e, t), r = bH(this, n, i), s = o / this._stepSizeDays - this._interpolationOrder / 2 | 0; s < 0 && (s = 0); let a = r / this._stepSizeDays - this._interpolationOrder / 2 | 0 + this._interpolationOrder; a >= this._totalSamples && (a = this._totalSamples - 1); let c = s / this._samplesPerXysFile | 0, u = a / this._samplesPerXysFile | 0, f = []; for (let d = c; d <= u; ++d)f.push(SH(this, d)); return Promise.all(f) }; wH.prototype.computeXysRadians = function (e, t, n) { let i = bH(this, e, t); if (i < 0) return; let o = i / this._stepSizeDays | 0; if (o >= this._totalSamples) return; let r = this._interpolationOrder, s = o - (r / 2 | 0); s < 0 && (s = 0); let a = s + r; a >= this._totalSamples && (a = this._totalSamples - 1, s = a - r, s < 0 && (s = 0)); let c = !1, u = this._samples; if (l(u[s * 3]) || (SH(this, s / this._samplesPerXysFile | 0), c = !0), l(u[a * 3]) || (SH(this, a / this._samplesPerXysFile | 0), c = !0), c) return; l(n) ? (n.x = 0, n.y = 0, n.s = 0) : n = new tC(0, 0, 0); let f = i - s * this._stepSizeDays, d = this._work, p = this._denominators, g = this._coef, m = this._xTable, A, C; for (A = 0; A <= r; ++A)d[A] = f - m[A]; for (A = 0; A <= r; ++A) { for (g[A] = 1, C = 0; C <= r; ++C)C !== A && (g[A] *= d[C]); g[A] *= p[A]; let x = (s + A) * 3; n.x += g[A] * u[x++], n.y += g[A] * u[x++], n.s += g[A] * u[x] } return n }; function SH(e, t) { if (e._chunkDownloadsInProgress[t]) return e._chunkDownloadsInProgress[t]; let n, i = e._xysFileUrlTemplate; l(i) ? n = i.getDerivedResource({ templateValues: { 0: t } }) : n = new Pe({ url: Jt(`Assets/IAU2006_XYS/IAU2006_XYS_${t}.json`) }); let o = n.fetchJson().then(function (r) { e._chunkDownloadsInProgress[t] = !1; let s = e._samples, a = r.samples, c = t * e._samplesPerXysFile * 3; for (let u = 0, f = a.length; u < f; ++u)s[c + u] = a[u] }); return e._chunkDownloadsInProgress[t] = o, o } var FP = wH; var Di = {}, DH = { up: { south: "east", north: "west", west: "south", east: "north" }, down: { south: "west", north: "east", west: "north", east: "south" }, south: { up: "west", down: "east", west: "down", east: "up" }, north: { up: "east", down: "west", west: "up", east: "down" }, west: { up: "north", down: "south", north: "down", south: "up" }, east: { up: "south", down: "north", north: "up", south: "down" } }, nC = { north: [-1, 0, 0], east: [0, 1, 0], up: [0, 0, 1], south: [1, 0, 0], west: [0, -1, 0], down: [0, 0, -1] }, vH = {}, vc = { east: new h, north: new h, up: new h, west: new h, south: new h, down: new h }, Ip = new h, Op = new h, Bp = new h; Di.localFrameToFixedFrameGenerator = function (e, t) { if (!DH.hasOwnProperty(e) || !DH[e].hasOwnProperty(t)) throw new ye("firstAxis and secondAxis must be east, north, up, west, south or down."); let n = DH[e][t], i, o = e + t; return l(vH[o]) ? i = vH[o] : (i = function (r, s, a) { if (l(a) || (a = new F), h.equalsEpsilon(r, h.ZERO, I.EPSILON14)) h.unpack(nC[e], 0, Ip), h.unpack(nC[t], 0, Op), h.unpack(nC[n], 0, Bp); else if (I.equalsEpsilon(r.x, 0, I.EPSILON14) && I.equalsEpsilon(r.y, 0, I.EPSILON14)) { let c = I.sign(r.z); h.unpack(nC[e], 0, Ip), e !== "east" && e !== "west" && h.multiplyByScalar(Ip, c, Ip), h.unpack(nC[t], 0, Op), t !== "east" && t !== "west" && h.multiplyByScalar(Op, c, Op), h.unpack(nC[n], 0, Bp), n !== "east" && n !== "west" && h.multiplyByScalar(Bp, c, Bp) } else { s = y(s, ie.WGS84), s.geodeticSurfaceNormal(r, vc.up); let c = vc.up, u = vc.east; u.x = -r.y, u.y = r.x, u.z = 0, h.normalize(u, vc.east), h.cross(c, u, vc.north), h.multiplyByScalar(vc.up, -1, vc.down), h.multiplyByScalar(vc.east, -1, vc.west), h.multiplyByScalar(vc.north, -1, vc.south), Ip = vc[e], Op = vc[t], Bp = vc[n] } return a[0] = Ip.x, a[1] = Ip.y, a[2] = Ip.z, a[3] = 0, a[4] = Op.x, a[5] = Op.y, a[6] = Op.z, a[7] = 0, a[8] = Bp.x, a[9] = Bp.y, a[10] = Bp.z, a[11] = 0, a[12] = r.x, a[13] = r.y, a[14] = r.z, a[15] = 1, a }, vH[o] = i), i }; Di.eastNorthUpToFixedFrame = Di.localFrameToFixedFrameGenerator("east", "north"); Di.northEastDownToFixedFrame = Di.localFrameToFixedFrameGenerator("north", "east"); Di.northUpEastToFixedFrame = Di.localFrameToFixedFrameGenerator("north", "up"); Di.northWestUpToFixedFrame = Di.localFrameToFixedFrameGenerator("north", "west"); var Oxe = new Be, Bxe = new h(1, 1, 1), Rxe = new F; Di.headingPitchRollToFixedFrame = function (e, t, n, i, o) { i = y(i, Di.eastNorthUpToFixedFrame); let r = Be.fromHeadingPitchRoll(t, Oxe), s = F.fromTranslationQuaternionRotationScale(h.ZERO, r, Bxe, Rxe); return o = i(e, n, o), F.multiply(o, s, o) }; var Mxe = new F, Lxe = new Q; Di.headingPitchRollQuaternion = function (e, t, n, i, o) { let r = Di.headingPitchRollToFixedFrame(e, t, n, i, Mxe), s = F.getMatrix3(r, Lxe); return Be.fromRotationMatrix(s, o) }; var Fxe = new h(1, 1, 1), Nxe = new h, iX = new F, Vxe = new F, kxe = new Q, Uxe = new Be; Di.fixedFrameToHeadingPitchRoll = function (e, t, n, i) { t = y(t, ie.WGS84), n = y(n, Di.eastNorthUpToFixedFrame), l(i) || (i = new lf); let o = F.getTranslation(e, Nxe); if (h.equals(o, h.ZERO)) return i.heading = 0, i.pitch = 0, i.roll = 0, i; let r = F.inverseTransformation(n(o, t, iX), iX), s = F.setScale(e, Fxe, Vxe); s = F.setTranslation(s, h.ZERO, s), r = F.multiply(r, s, r); let a = Be.fromRotationMatrix(F.getMatrix3(r, kxe), Uxe); return a = Be.normalize(a, a), lf.fromQuaternion(a, i) }; var zxe = 6 * 3600 + 41 * 60 + 50.54841, Hxe = 8640184812866e-6, Gxe = .093104, Wxe = -62e-7, jxe = 11772758384668e-32, qxe = 72921158553e-15, Yxe = I.TWO_PI / 86400, NP = new $; Di.computeTemeToPseudoFixedMatrix = function (e, t) { NP = $.addSeconds(e, -$.computeTaiMinusUtc(e), NP); let n = NP.dayNumber, i = NP.secondsOfDay, o, r = n - 2451545; i >= 43200 ? o = (r + .5) / jn.DAYS_PER_JULIAN_CENTURY : o = (r - .5) / jn.DAYS_PER_JULIAN_CENTURY; let a = (zxe + o * (Hxe + o * (Gxe + o * Wxe))) * Yxe % I.TWO_PI, c = qxe + jxe * (n - 24515455e-1), u = (i + jn.SECONDS_PER_DAY * .5) % jn.SECONDS_PER_DAY, f = a + c * u, d = Math.cos(f), p = Math.sin(f); return l(t) ? (t[0] = d, t[1] = -p, t[2] = 0, t[3] = p, t[4] = d, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t) : new Q(d, p, 0, -p, d, 0, 0, 0, 1) }; Di.iau2006XysData = new FP; Di.earthOrientationParameters = MP.NONE; var OH = 32.184, Xxe = 2451545; Di.preloadIcrfFixed = function (e) { let t = e.start.dayNumber, n = e.start.secondsOfDay + OH, i = e.stop.dayNumber, o = e.stop.secondsOfDay + OH, r = Di.iau2006XysData.preload(t, n, i, o), s = Di.earthOrientationParameters.getPromiseToLoad(); return Promise.all([r, s]) }; Di.computeIcrfToFixedMatrix = function (e, t) { l(t) || (t = new Q); let n = Di.computeFixedToIcrfMatrix(e, t); if (!!l(n)) return Q.transpose(n, t) }; var Kxe = new tC(0, 0, 0), Jxe = new a0(0, 0, 0, 0, 0, 0), PH = new Q, IH = new Q; Di.computeFixedToIcrfMatrix = function (e, t) { l(t) || (t = new Q); let n = Di.earthOrientationParameters.compute(e, Jxe); if (!l(n)) return; let i = e.dayNumber, o = e.secondsOfDay + OH, r = Di.iau2006XysData.computeXysRadians(i, o, Kxe); if (!l(r)) return; let s = r.x + n.xPoleOffset, a = r.y + n.yPoleOffset, c = 1 / (1 + Math.sqrt(1 - s * s - a * a)), u = PH; u[0] = 1 - c * s * s, u[3] = -c * s * a, u[6] = s, u[1] = -c * s * a, u[4] = 1 - c * a * a, u[7] = a, u[2] = -s, u[5] = -a, u[8] = 1 - c * (s * s + a * a); let f = Q.fromRotationZ(-r.s, IH), d = Q.multiply(u, f, PH), p = e.dayNumber, g = e.secondsOfDay - $.computeTaiMinusUtc(e) + n.ut1MinusUtc, m = p - 2451545, A = g / jn.SECONDS_PER_DAY, C = .779057273264 + A + .00273781191135448 * (m + A); C = C % 1 * I.TWO_PI; let x = Q.fromRotationZ(C, IH), T = Q.multiply(d, x, PH), b = Math.cos(n.xPoleWander), S = Math.cos(n.yPoleWander), D = Math.sin(n.xPoleWander), P = Math.sin(n.yPoleWander), B = i - Xxe + o / jn.SECONDS_PER_DAY; B /= 36525; let R = -47e-6 * B * I.RADIANS_PER_DEGREE / 3600, M = Math.cos(R), L = Math.sin(R), _ = IH; return _[0] = b * M, _[1] = b * L, _[2] = D, _[3] = -S * L + P * D * M, _[4] = S * M + P * D * L, _[5] = -P * b, _[6] = -P * L - S * D * M, _[7] = P * M - S * D * L, _[8] = S * b, Q.multiply(T, _, t) }; var Zxe = new se; Di.pointToWindowCoordinates = function (e, t, n, i) { return i = Di.pointToGLWindowCoordinates(e, t, n, i), i.y = 2 * t[5] - i.y, i }; Di.pointToGLWindowCoordinates = function (e, t, n, i) { l(i) || (i = new H); let o = Zxe; return F.multiplyByVector(e, se.fromElements(n.x, n.y, n.z, 1, o), o), se.multiplyByScalar(o, 1 / o.w, o), F.multiplyByVector(t, o, o), H.fromCartesian4(o, i) }; var Qxe = new h, $xe = new h, eTe = new h; Di.rotationMatrixFromPositionVelocity = function (e, t, n, i) { let o = y(n, ie.WGS84).geodeticSurfaceNormal(e, Qxe), r = h.cross(t, o, $xe); h.equalsEpsilon(r, h.ZERO, I.EPSILON6) && (r = h.clone(h.UNIT_X, r)); let s = h.cross(r, t, eTe); return h.normalize(s, s), h.cross(t, s, r), h.negate(r, r), h.normalize(r, r), l(i) || (i = new Q), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = r.x, i[4] = r.y, i[5] = r.z, i[6] = s.x, i[7] = s.y, i[8] = s.z, i }; var oX = new F(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1), rX = new he, sX = new h, tTe = new h, nTe = new Q, BH = new F, aX = new F; Di.basisTo2D = function (e, t, n) { let i = F.getTranslation(t, tTe), o = e.ellipsoid, r = o.cartesianToCartographic(i, rX), s = e.project(r, sX); h.fromElements(s.z, s.x, s.y, s); let a = Di.eastNorthUpToFixedFrame(i, o, BH), c = F.inverseTransformation(a, aX), u = F.getMatrix3(t, nTe), f = F.multiplyByMatrix3(c, u, n); return F.multiply(oX, f, n), F.setTranslation(n, s, n), n }; Di.wgs84To2DModelMatrix = function (e, t, n) { let i = e.ellipsoid, o = Di.eastNorthUpToFixedFrame(t, i, BH), r = F.inverseTransformation(o, aX), s = i.cartesianToCartographic(t, rX), a = e.project(s, sX); h.fromElements(a.z, a.x, a.y, a); let c = F.fromTranslation(a, BH); return F.multiply(oX, r, n), F.multiply(c, n, n), n }; var It = Di; function RH(e) { e = y(e, y.EMPTY_OBJECT), this.attributes = e.attributes, this.indices = e.indices, this.primitiveType = y(e.primitiveType, Oe.TRIANGLES), this.boundingSphere = e.boundingSphere, this.geometryType = y(e.geometryType, af.NONE), this.boundingSphereCV = e.boundingSphereCV, this.offsetAttribute = e.offsetAttribute } RH.computeNumberOfVertices = function (e) { let t = -1; for (let n in e.attributes) if (e.attributes.hasOwnProperty(n) && l(e.attributes[n]) && l(e.attributes[n].values)) { let i = e.attributes[n]; t = i.values.length / i.componentsPerAttribute } return t }; var iTe = new he, oTe = new h, cX = new F, rTe = [new he, new he, new he], sTe = [new H, new H, new H], aTe = [new H, new H, new H], cTe = new h, lTe = new Be, uTe = new F, fTe = new qi; RH._textureCoordinateRotationPoints = function (e, t, n, i) { let o, r = ce.center(i, iTe), s = he.toCartesian(r, n, oTe), a = It.eastNorthUpToFixedFrame(s, n, cX), c = F.inverse(a, cX), u = sTe, f = rTe; f[0].longitude = i.west, f[0].latitude = i.south, f[1].longitude = i.west, f[1].latitude = i.north, f[2].longitude = i.east, f[2].latitude = i.south; let d = cTe; for (o = 0; o < 3; o++)he.toCartesian(f[o], n, d), d = F.multiplyByPointAsVector(c, d, d), u[o].x = d.x, u[o].y = d.y; let p = Be.fromAxisAngle(h.UNIT_Z, -t, lTe), g = Q.fromQuaternion(p, uTe), m = e.length, A = Number.POSITIVE_INFINITY, C = Number.POSITIVE_INFINITY, x = Number.NEGATIVE_INFINITY, T = Number.NEGATIVE_INFINITY; for (o = 0; o < m; o++)d = F.multiplyByPointAsVector(c, e[o], d), d = Q.multiplyByVector(g, d, d), A = Math.min(A, d.x), C = Math.min(C, d.y), x = Math.max(x, d.x), T = Math.max(T, d.y); let b = qi.fromRotation(t, fTe), S = aTe; S[0].x = A, S[0].y = C, S[1].x = A, S[1].y = T, S[2].x = x, S[2].y = C; let D = u[0], P = u[2].x - D.x, B = u[1].y - D.y; for (o = 0; o < 3; o++) { let E = S[o]; qi.multiplyByVector(b, E, E), E.x = (E.x - D.x) / P, E.y = (E.y - D.y) / B } let R = S[0], M = S[1], L = S[2], _ = new Array(6); return H.pack(R, _), H.pack(M, _, 2), H.pack(L, _, 4), _ }; var st = RH; function dTe(e) { e = y(e, y.EMPTY_OBJECT), this.componentDatatype = e.componentDatatype, this.componentsPerAttribute = e.componentsPerAttribute, this.normalize = y(e.normalize, !1), this.values = e.values } var be = dTe; function hTe(e) { e = y(e, y.EMPTY_OBJECT), this.position = e.position, this.normal = e.normal, this.st = e.st, this.bitangent = e.bitangent, this.tangent = e.tangent, this.color = e.color } var sn = hTe; var mTe = { NONE: 0, TOP: 1, ALL: 2 }, Qt = Object.freeze(mTe); function Nr(e) { e = y(e, y.EMPTY_OBJECT), this.position = y(e.position, !1), this.normal = y(e.normal, !1), this.st = y(e.st, !1), this.bitangent = y(e.bitangent, !1), this.tangent = y(e.tangent, !1), this.color = y(e.color, !1) } Nr.POSITION_ONLY = Object.freeze(new Nr({ position: !0 })); Nr.POSITION_AND_NORMAL = Object.freeze(new Nr({ position: !0, normal: !0 })); Nr.POSITION_NORMAL_AND_ST = Object.freeze(new Nr({ position: !0, normal: !0, st: !0 })); Nr.POSITION_AND_ST = Object.freeze(new Nr({ position: !0, st: !0 })); Nr.POSITION_AND_COLOR = Object.freeze(new Nr({ position: !0, color: !0 })); Nr.ALL = Object.freeze(new Nr({ position: !0, normal: !0, st: !0, tangent: !0, bitangent: !0 })); Nr.DEFAULT = Nr.POSITION_NORMAL_AND_ST; Nr.packedLength = 6; Nr.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e.position ? 1 : 0, t[n++] = e.normal ? 1 : 0, t[n++] = e.st ? 1 : 0, t[n++] = e.tangent ? 1 : 0, t[n++] = e.bitangent ? 1 : 0, t[n] = e.color ? 1 : 0, t }; Nr.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new Nr), n.position = e[t++] === 1, n.normal = e[t++] === 1, n.st = e[t++] === 1, n.tangent = e[t++] === 1, n.bitangent = e[t++] === 1, n.color = e[t] === 1, n }; Nr.clone = function (e, t) { if (!!l(e)) return l(t) || (t = new Nr), t.position = e.position, t.normal = e.normal, t.st = e.st, t.tangent = e.tangent, t.bitangent = e.bitangent, t.color = e.color, t }; var we = Nr; var pTe = new h; function cl(e) { e = y(e, y.EMPTY_OBJECT); let t = e.minimum, n = e.maximum, i = y(e.vertexFormat, we.DEFAULT); this._minimum = h.clone(t), this._maximum = h.clone(n), this._vertexFormat = i, this._offsetAttribute = e.offsetAttribute, this._workerName = "createBoxGeometry" } cl.fromDimensions = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.dimensions, n = h.multiplyByScalar(t, .5, new h); return new cl({ minimum: h.negate(n, new h), maximum: n, vertexFormat: e.vertexFormat, offsetAttribute: e.offsetAttribute }) }; cl.fromAxisAlignedBoundingBox = function (e) { return new cl({ minimum: e.minimum, maximum: e.maximum }) }; cl.packedLength = 2 * h.packedLength + we.packedLength + 1; cl.pack = function (e, t, n) { return n = y(n, 0), h.pack(e._minimum, t, n), h.pack(e._maximum, t, n + h.packedLength), we.pack(e._vertexFormat, t, n + 2 * h.packedLength), t[n + 2 * h.packedLength + we.packedLength] = y(e._offsetAttribute, -1), t }; var uX = new h, fX = new h, dX = new we, lX = { minimum: uX, maximum: fX, vertexFormat: dX, offsetAttribute: void 0 }; cl.unpack = function (e, t, n) { t = y(t, 0); let i = h.unpack(e, t, uX), o = h.unpack(e, t + h.packedLength, fX), r = we.unpack(e, t + 2 * h.packedLength, dX), s = e[t + 2 * h.packedLength + we.packedLength]; return l(n) ? (n._minimum = h.clone(i, n._minimum), n._maximum = h.clone(o, n._maximum), n._vertexFormat = we.clone(r, n._vertexFormat), n._offsetAttribute = s === -1 ? void 0 : s, n) : (lX.offsetAttribute = s === -1 ? void 0 : s, new cl(lX)) }; cl.createGeometry = function (e) { let t = e._minimum, n = e._maximum, i = e._vertexFormat; if (h.equals(t, n)) return; let o = new sn, r, s; if (i.position && (i.st || i.normal || i.tangent || i.bitangent)) { if (i.position && (s = new Float64Array(6 * 4 * 3), s[0] = t.x, s[1] = t.y, s[2] = n.z, s[3] = n.x, s[4] = t.y, s[5] = n.z, s[6] = n.x, s[7] = n.y, s[8] = n.z, s[9] = t.x, s[10] = n.y, s[11] = n.z, s[12] = t.x, s[13] = t.y, s[14] = t.z, s[15] = n.x, s[16] = t.y, s[17] = t.z, s[18] = n.x, s[19] = n.y, s[20] = t.z, s[21] = t.x, s[22] = n.y, s[23] = t.z, s[24] = n.x, s[25] = t.y, s[26] = t.z, s[27] = n.x, s[28] = n.y, s[29] = t.z, s[30] = n.x, s[31] = n.y, s[32] = n.z, s[33] = n.x, s[34] = t.y, s[35] = n.z, s[36] = t.x, s[37] = t.y, s[38] = t.z, s[39] = t.x, s[40] = n.y, s[41] = t.z, s[42] = t.x, s[43] = n.y, s[44] = n.z, s[45] = t.x, s[46] = t.y, s[47] = n.z, s[48] = t.x, s[49] = n.y, s[50] = t.z, s[51] = n.x, s[52] = n.y, s[53] = t.z, s[54] = n.x, s[55] = n.y, s[56] = n.z, s[57] = t.x, s[58] = n.y, s[59] = n.z, s[60] = t.x, s[61] = t.y, s[62] = t.z, s[63] = n.x, s[64] = t.y, s[65] = t.z, s[66] = n.x, s[67] = t.y, s[68] = n.z, s[69] = t.x, s[70] = t.y, s[71] = n.z, o.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: s })), i.normal) { let u = new Float32Array(72); u[0] = 0, u[1] = 0, u[2] = 1, u[3] = 0, u[4] = 0, u[5] = 1, u[6] = 0, u[7] = 0, u[8] = 1, u[9] = 0, u[10] = 0, u[11] = 1, u[12] = 0, u[13] = 0, u[14] = -1, u[15] = 0, u[16] = 0, u[17] = -1, u[18] = 0, u[19] = 0, u[20] = -1, u[21] = 0, u[22] = 0, u[23] = -1, u[24] = 1, u[25] = 0, u[26] = 0, u[27] = 1, u[28] = 0, u[29] = 0, u[30] = 1, u[31] = 0, u[32] = 0, u[33] = 1, u[34] = 0, u[35] = 0, u[36] = -1, u[37] = 0, u[38] = 0, u[39] = -1, u[40] = 0, u[41] = 0, u[42] = -1, u[43] = 0, u[44] = 0, u[45] = -1, u[46] = 0, u[47] = 0, u[48] = 0, u[49] = 1, u[50] = 0, u[51] = 0, u[52] = 1, u[53] = 0, u[54] = 0, u[55] = 1, u[56] = 0, u[57] = 0, u[58] = 1, u[59] = 0, u[60] = 0, u[61] = -1, u[62] = 0, u[63] = 0, u[64] = -1, u[65] = 0, u[66] = 0, u[67] = -1, u[68] = 0, u[69] = 0, u[70] = -1, u[71] = 0, o.normal = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: u }) } if (i.st) { let u = new Float32Array(48); u[0] = 0, u[1] = 0, u[2] = 1, u[3] = 0, u[4] = 1, u[5] = 1, u[6] = 0, u[7] = 1, u[8] = 1, u[9] = 0, u[10] = 0, u[11] = 0, u[12] = 0, u[13] = 1, u[14] = 1, u[15] = 1, u[16] = 0, u[17] = 0, u[18] = 1, u[19] = 0, u[20] = 1, u[21] = 1, u[22] = 0, u[23] = 1, u[24] = 1, u[25] = 0, u[26] = 0, u[27] = 0, u[28] = 0, u[29] = 1, u[30] = 1, u[31] = 1, u[32] = 1, u[33] = 0, u[34] = 0, u[35] = 0, u[36] = 0, u[37] = 1, u[38] = 1, u[39] = 1, u[40] = 0, u[41] = 0, u[42] = 1, u[43] = 0, u[44] = 1, u[45] = 1, u[46] = 0, u[47] = 1, o.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: u }) } if (i.tangent) { let u = new Float32Array(72); u[0] = 1, u[1] = 0, u[2] = 0, u[3] = 1, u[4] = 0, u[5] = 0, u[6] = 1, u[7] = 0, u[8] = 0, u[9] = 1, u[10] = 0, u[11] = 0, u[12] = -1, u[13] = 0, u[14] = 0, u[15] = -1, u[16] = 0, u[17] = 0, u[18] = -1, u[19] = 0, u[20] = 0, u[21] = -1, u[22] = 0, u[23] = 0, u[24] = 0, u[25] = 1, u[26] = 0, u[27] = 0, u[28] = 1, u[29] = 0, u[30] = 0, u[31] = 1, u[32] = 0, u[33] = 0, u[34] = 1, u[35] = 0, u[36] = 0, u[37] = -1, u[38] = 0, u[39] = 0, u[40] = -1, u[41] = 0, u[42] = 0, u[43] = -1, u[44] = 0, u[45] = 0, u[46] = -1, u[47] = 0, u[48] = -1, u[49] = 0, u[50] = 0, u[51] = -1, u[52] = 0, u[53] = 0, u[54] = -1, u[55] = 0, u[56] = 0, u[57] = -1, u[58] = 0, u[59] = 0, u[60] = 1, u[61] = 0, u[62] = 0, u[63] = 1, u[64] = 0, u[65] = 0, u[66] = 1, u[67] = 0, u[68] = 0, u[69] = 1, u[70] = 0, u[71] = 0, o.tangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: u }) } if (i.bitangent) { let u = new Float32Array(72); u[0] = 0, u[1] = 1, u[2] = 0, u[3] = 0, u[4] = 1, u[5] = 0, u[6] = 0, u[7] = 1, u[8] = 0, u[9] = 0, u[10] = 1, u[11] = 0, u[12] = 0, u[13] = 1, u[14] = 0, u[15] = 0, u[16] = 1, u[17] = 0, u[18] = 0, u[19] = 1, u[20] = 0, u[21] = 0, u[22] = 1, u[23] = 0, u[24] = 0, u[25] = 0, u[26] = 1, u[27] = 0, u[28] = 0, u[29] = 1, u[30] = 0, u[31] = 0, u[32] = 1, u[33] = 0, u[34] = 0, u[35] = 1, u[36] = 0, u[37] = 0, u[38] = 1, u[39] = 0, u[40] = 0, u[41] = 1, u[42] = 0, u[43] = 0, u[44] = 1, u[45] = 0, u[46] = 0, u[47] = 1, u[48] = 0, u[49] = 0, u[50] = 1, u[51] = 0, u[52] = 0, u[53] = 1, u[54] = 0, u[55] = 0, u[56] = 1, u[57] = 0, u[58] = 0, u[59] = 1, u[60] = 0, u[61] = 0, u[62] = 1, u[63] = 0, u[64] = 0, u[65] = 1, u[66] = 0, u[67] = 0, u[68] = 1, u[69] = 0, u[70] = 0, u[71] = 1, o.bitangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: u }) } r = new Uint16Array(6 * 2 * 3), r[0] = 0, r[1] = 1, r[2] = 2, r[3] = 0, r[4] = 2, r[5] = 3, r[6] = 4 + 2, r[7] = 4 + 1, r[8] = 4 + 0, r[9] = 4 + 3, r[10] = 4 + 2, r[11] = 4 + 0, r[12] = 8 + 0, r[13] = 8 + 1, r[14] = 8 + 2, r[15] = 8 + 0, r[16] = 8 + 2, r[17] = 8 + 3, r[18] = 12 + 2, r[19] = 12 + 1, r[20] = 12 + 0, r[21] = 12 + 3, r[22] = 12 + 2, r[23] = 12 + 0, r[24] = 16 + 2, r[25] = 16 + 1, r[26] = 16 + 0, r[27] = 16 + 3, r[28] = 16 + 2, r[29] = 16 + 0, r[30] = 20 + 0, r[31] = 20 + 1, r[32] = 20 + 2, r[33] = 20 + 0, r[34] = 20 + 2, r[35] = 20 + 3 } else s = new Float64Array(8 * 3), s[0] = t.x, s[1] = t.y, s[2] = t.z, s[3] = n.x, s[4] = t.y, s[5] = t.z, s[6] = n.x, s[7] = n.y, s[8] = t.z, s[9] = t.x, s[10] = n.y, s[11] = t.z, s[12] = t.x, s[13] = t.y, s[14] = n.z, s[15] = n.x, s[16] = t.y, s[17] = n.z, s[18] = n.x, s[19] = n.y, s[20] = n.z, s[21] = t.x, s[22] = n.y, s[23] = n.z, o.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: s }), r = new Uint16Array(6 * 2 * 3), r[0] = 4, r[1] = 5, r[2] = 6, r[3] = 4, r[4] = 6, r[5] = 7, r[6] = 1, r[7] = 0, r[8] = 3, r[9] = 1, r[10] = 3, r[11] = 2, r[12] = 1, r[13] = 6, r[14] = 5, r[15] = 1, r[16] = 2, r[17] = 6, r[18] = 2, r[19] = 3, r[20] = 7, r[21] = 2, r[22] = 7, r[23] = 6, r[24] = 3, r[25] = 0, r[26] = 4, r[27] = 3, r[28] = 4, r[29] = 7, r[30] = 0, r[31] = 1, r[32] = 5, r[33] = 0, r[34] = 5, r[35] = 4; let a = h.subtract(n, t, pTe), c = h.magnitude(a) * .5; if (l(e._offsetAttribute)) { let u = s.length, f = e._offsetAttribute === Qt.NONE ? 0 : 1, d = new Uint8Array(u / 3).fill(f); o.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: d }) } return new st({ attributes: o, indices: r, primitiveType: Oe.TRIANGLES, boundingSphere: new re(h.ZERO, c), offsetAttribute: e._offsetAttribute }) }; var MH; cl.getUnitBox = function () { return l(MH) || (MH = cl.createGeometry(cl.fromDimensions({ dimensions: new h(1, 1, 1), vertexFormat: we.POSITION_ONLY }))), MH }; var ll = cl; var _Te = new h; function Ed(e) { e = y(e, y.EMPTY_OBJECT); let t = e.minimum, n = e.maximum; this._min = h.clone(t), this._max = h.clone(n), this._offsetAttribute = e.offsetAttribute, this._workerName = "createBoxOutlineGeometry" } Ed.fromDimensions = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.dimensions, n = h.multiplyByScalar(t, .5, new h); return new Ed({ minimum: h.negate(n, new h), maximum: n, offsetAttribute: e.offsetAttribute }) }; Ed.fromAxisAlignedBoundingBox = function (e) { return new Ed({ minimum: e.minimum, maximum: e.maximum }) }; Ed.packedLength = 2 * h.packedLength + 1; Ed.pack = function (e, t, n) { return n = y(n, 0), h.pack(e._min, t, n), h.pack(e._max, t, n + h.packedLength), t[n + h.packedLength * 2] = y(e._offsetAttribute, -1), t }; var mX = new h, pX = new h, hX = { minimum: mX, maximum: pX, offsetAttribute: void 0 }; Ed.unpack = function (e, t, n) { t = y(t, 0); let i = h.unpack(e, t, mX), o = h.unpack(e, t + h.packedLength, pX), r = e[t + h.packedLength * 2]; return l(n) ? (n._min = h.clone(i, n._min), n._max = h.clone(o, n._max), n._offsetAttribute = r === -1 ? void 0 : r, n) : (hX.offsetAttribute = r === -1 ? void 0 : r, new Ed(hX)) }; Ed.createGeometry = function (e) { let t = e._min, n = e._max; if (h.equals(t, n)) return; let i = new sn, o = new Uint16Array(12 * 2), r = new Float64Array(8 * 3); r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = n.x, r[4] = t.y, r[5] = t.z, r[6] = n.x, r[7] = n.y, r[8] = t.z, r[9] = t.x, r[10] = n.y, r[11] = t.z, r[12] = t.x, r[13] = t.y, r[14] = n.z, r[15] = n.x, r[16] = t.y, r[17] = n.z, r[18] = n.x, r[19] = n.y, r[20] = n.z, r[21] = t.x, r[22] = n.y, r[23] = n.z, i.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: r }), o[0] = 4, o[1] = 5, o[2] = 5, o[3] = 6, o[4] = 6, o[5] = 7, o[6] = 7, o[7] = 4, o[8] = 0, o[9] = 1, o[10] = 1, o[11] = 2, o[12] = 2, o[13] = 3, o[14] = 3, o[15] = 0, o[16] = 0, o[17] = 4, o[18] = 1, o[19] = 5, o[20] = 2, o[21] = 6, o[22] = 3, o[23] = 7; let s = h.subtract(n, t, _Te), a = h.magnitude(s) * .5; if (l(e._offsetAttribute)) { let c = r.length, u = e._offsetAttribute === Qt.NONE ? 0 : 1, f = new Uint8Array(c / 3).fill(u); i.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: f }) } return new st({ attributes: i, indices: o, primitiveType: Oe.LINES, boundingSphere: new re(h.ZERO, a), offsetAttribute: e._offsetAttribute }) }; var bd = Ed; function iC(e, t, n, i) { e = y(e, 1), t = y(t, 1), n = y(n, 1), i = y(i, 1), this.value = new Uint8Array([U.floatToByte(e), U.floatToByte(t), U.floatToByte(n), U.floatToByte(i)]) } Object.defineProperties(iC.prototype, { componentDatatype: { get: function () { return Y.UNSIGNED_BYTE } }, componentsPerAttribute: { get: function () { return 4 } }, normalize: { get: function () { return !0 } } }); iC.fromColor = function (e) { return new iC(e.red, e.green, e.blue, e.alpha) }; iC.toValue = function (e, t) { return l(t) ? e.toBytes(t) : new Uint8Array(e.toBytes()) }; iC.equals = function (e, t) { return e === t || l(e) && l(t) && e.value[0] === t.value[0] && e.value[1] === t.value[1] && e.value[2] === t.value[2] && e.value[3] === t.value[3] }; var Bt = iC; function hb(e, t) { e = y(e, 0), t = y(t, Number.MAX_VALUE), this.value = new Float32Array([e, t]) } Object.defineProperties(hb.prototype, { componentDatatype: { get: function () { return Y.FLOAT } }, componentsPerAttribute: { get: function () { return 2 } }, normalize: { get: function () { return !1 } } }); hb.fromDistanceDisplayCondition = function (e) { return new hb(e.near, e.far) }; hb.toValue = function (e, t) { return l(t) ? (t[0] = e.near, t[1] = e.far, t) : new Float32Array([e.near, e.far]) }; var Mn = hb; function gTe(e) { e = y(e, y.EMPTY_OBJECT), this.geometry = e.geometry, this.modelMatrix = F.clone(y(e.modelMatrix, F.IDENTITY)), this.id = e.id, this.pickPrimitive = e.pickPrimitive, this.attributes = y(e.attributes, {}), this.westHemisphereGeometry = void 0, this.eastHemisphereGeometry = void 0 } var At = gTe; function Mo(e) { e = y(e, y.EMPTY_OBJECT), this.start = l(e.start) ? $.clone(e.start) : new $, this.stop = l(e.stop) ? $.clone(e.stop) : new $, this.data = e.data, this.isStartIncluded = y(e.isStartIncluded, !0), this.isStopIncluded = y(e.isStopIncluded, !0) } Object.defineProperties(Mo.prototype, { isEmpty: { get: function () { let e = $.compare(this.stop, this.start); return e < 0 || e === 0 && (!this.isStartIncluded || !this.isStopIncluded) } } }); var oC = { start: void 0, stop: void 0, isStartIncluded: void 0, isStopIncluded: void 0, data: void 0 }; Mo.fromIso8601 = function (e, t) { let n = e.iso8601.split("/"); if (n.length !== 2) throw new ye("options.iso8601 is an invalid ISO 8601 interval."); let i = $.fromIso8601(n[0]), o = $.fromIso8601(n[1]), r = y(e.isStartIncluded, !0), s = y(e.isStopIncluded, !0), a = e.data; return l(t) ? (t.start = i, t.stop = o, t.isStartIncluded = r, t.isStopIncluded = s, t.data = a, t) : (oC.start = i, oC.stop = o, oC.isStartIncluded = r, oC.isStopIncluded = s, oC.data = a, new Mo(oC)) }; Mo.toIso8601 = function (e, t) { return `${$.toIso8601(e.start, t)}/${$.toIso8601(e.stop, t)}` }; Mo.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.start = e.start, t.stop = e.stop, t.isStartIncluded = e.isStartIncluded, t.isStopIncluded = e.isStopIncluded, t.data = e.data, t) : new Mo(e) }; Mo.equals = function (e, t, n) { return e === t || l(e) && l(t) && (e.isEmpty && t.isEmpty || e.isStartIncluded === t.isStartIncluded && e.isStopIncluded === t.isStopIncluded && $.equals(e.start, t.start) && $.equals(e.stop, t.stop) && (e.data === t.data || l(n) && n(e.data, t.data))) }; Mo.equalsEpsilon = function (e, t, n, i) { return n = y(n, 0), e === t || l(e) && l(t) && (e.isEmpty && t.isEmpty || e.isStartIncluded === t.isStartIncluded && e.isStopIncluded === t.isStopIncluded && $.equalsEpsilon(e.start, t.start, n) && $.equalsEpsilon(e.stop, t.stop, n) && (e.data === t.data || l(i) && i(e.data, t.data))) }; Mo.intersect = function (e, t, n, i) { if (!l(t)) return Mo.clone(Mo.EMPTY, n); let o = e.start, r = e.stop, s = t.start, a = t.stop, c = $.greaterThanOrEquals(s, o) && $.greaterThanOrEquals(r, s), u = !c && $.lessThanOrEquals(s, o) && $.lessThanOrEquals(o, a); if (!c && !u) return Mo.clone(Mo.EMPTY, n); let f = e.isStartIncluded, d = e.isStopIncluded, p = t.isStartIncluded, g = t.isStopIncluded, m = $.lessThan(r, a); return l(n) || (n = new Mo), n.start = c ? s : o, n.isStartIncluded = f && p || !$.equals(s, o) && (c && p || u && f), n.stop = m ? r : a, n.isStopIncluded = m ? d : d && g || !$.equals(a, r) && g, n.data = l(i) ? i(e.data, t.data) : e.data, n }; Mo.contains = function (e, t) { if (e.isEmpty) return !1; let n = $.compare(e.start, t); if (n === 0) return e.isStartIncluded; let i = $.compare(t, e.stop); return i === 0 ? e.isStopIncluded : n < 0 && i < 0 }; Mo.prototype.clone = function (e) { return Mo.clone(this, e) }; Mo.prototype.equals = function (e, t) { return Mo.equals(this, e, t) }; Mo.prototype.equalsEpsilon = function (e, t, n) { return Mo.equalsEpsilon(this, e, t, n) }; Mo.prototype.toString = function () { return Mo.toIso8601(this) }; Mo.EMPTY = Object.freeze(new Mo({ start: new $, stop: new $, isStartIncluded: !1, isStopIncluded: !1 })); var yn = Mo; var _X = Object.freeze($.fromIso8601("0000-01-01T00:00:00Z")), gX = Object.freeze($.fromIso8601("9999-12-31T24:00:00Z")), yTe = Object.freeze(new yn({ start: _X, stop: gX })), ATe = { MINIMUM_VALUE: _X, MAXIMUM_VALUE: gX, MAXIMUM_INTERVAL: yTe }, ke = ATe; function mb(e, t, n) { e = y(e, 0), t = y(t, 0), n = y(n, 0), this.value = new Float32Array([e, t, n]) } Object.defineProperties(mb.prototype, { componentDatatype: { get: function () { return Y.FLOAT } }, componentsPerAttribute: { get: function () { return 3 } }, normalize: { get: function () { return !1 } } }); mb.fromCartesian3 = function (e) { return new mb(e.x, e.y, e.z) }; mb.toValue = function (e, t) { return l(t) || (t = new Float32Array([e.x, e.y, e.z])), t[0] = e.x, t[1] = e.y, t[2] = e.z, t }; var zi = mb; function VP(e) { e = y(e, !0), this.value = VP.toValue(e) } Object.defineProperties(VP.prototype, { componentDatatype: { get: function () { return Y.UNSIGNED_BYTE } }, componentsPerAttribute: { get: function () { return 1 } }, normalize: { get: function () { return !1 } } }); VP.toValue = function (e, t) { return l(t) ? (t[0] = e, t) : new Uint8Array([e]) }; var fn = VP; var kP = `varying vec3 v_positionEC;
varying vec3 v_normalEC;
varying vec3 v_tangentEC;
varying vec3 v_bitangentEC;
varying vec2 v_st;
void main()
{
vec3 positionToEyeEC = -v_positionEC;
mat3 tangentToEyeMatrix = czm_tangentToEyeSpaceMatrix(v_normalEC, v_tangentEC, v_bitangentEC);
vec3 normalEC = normalize(v_normalEC);
#ifdef FACE_FORWARD
normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);
#endif
czm_materialInput materialInput;
materialInput.normalEC = normalEC;
materialInput.tangentToEyeMatrix = tangentToEyeMatrix;
materialInput.positionToEyeEC = positionToEyeEC;
materialInput.st = v_st;
czm_material material = czm_getMaterial(materialInput);
#ifdef FLAT
gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);
#else
gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);
#endif
}
`; var UP = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;
attribute vec3 normal;
attribute vec3 tangent;
attribute vec3 bitangent;
attribute vec2 st;
attribute float batchId;
varying vec3 v_positionEC;
varying vec3 v_normalEC;
varying vec3 v_tangentEC;
varying vec3 v_bitangentEC;
varying vec2 v_st;
void main()
{
vec4 p = czm_computePosition();
v_positionEC = (czm_modelViewRelativeToEye * p).xyz;
v_normalEC = czm_normal * normal;
v_tangentEC = czm_normal * tangent;
v_bitangentEC = czm_normal * bitangent;
v_st = st;
gl_Position = czm_modelViewProjectionRelativeToEye * p;
}
`; var zP = `varying vec3 v_positionEC;
varying vec3 v_normalEC;
void main()
{
vec3 positionToEyeEC = -v_positionEC;
vec3 normalEC = normalize(v_normalEC);
#ifdef FACE_FORWARD
normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);
#endif
czm_materialInput materialInput;
materialInput.normalEC = normalEC;
materialInput.positionToEyeEC = positionToEyeEC;
czm_material material = czm_getMaterial(materialInput);
#ifdef FLAT
gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);
#else
gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);
#endif
}
`; var HP = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;
attribute vec3 normal;
attribute float batchId;
varying vec3 v_positionEC;
varying vec3 v_normalEC;
void main()
{
vec4 p = czm_computePosition();
v_positionEC = (czm_modelViewRelativeToEye * p).xyz;
v_normalEC = czm_normal * normal;
gl_Position = czm_modelViewProjectionRelativeToEye * p;
}
`; var GP = `varying vec3 v_positionEC;
varying vec3 v_normalEC;
varying vec2 v_st;
void main()
{
vec3 positionToEyeEC = -v_positionEC;
vec3 normalEC = normalize(v_normalEC);
#ifdef FACE_FORWARD
normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);
#endif
czm_materialInput materialInput;
materialInput.normalEC = normalEC;
materialInput.positionToEyeEC = positionToEyeEC;
materialInput.st = v_st;
czm_material material = czm_getMaterial(materialInput);
#ifdef FLAT
gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);
#else
gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);
#endif
}
`; var WP = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;
attribute vec3 normal;
attribute vec2 st;
attribute float batchId;
varying vec3 v_positionEC;
varying vec3 v_normalEC;
varying vec2 v_st;
void main()
{
vec4 p = czm_computePosition();
v_positionEC = (czm_modelViewRelativeToEye * p).xyz;
v_normalEC = czm_normal * normal;
v_st = st;
gl_Position = czm_modelViewProjectionRelativeToEye * p;
}
`; var CTe = { ADD: te.FUNC_ADD, SUBTRACT: te.FUNC_SUBTRACT, REVERSE_SUBTRACT: te.FUNC_REVERSE_SUBTRACT, MIN: te.MIN, MAX: te.MAX }, ma = Object.freeze(CTe); var xTe = { ZERO: te.ZERO, ONE: te.ONE, SOURCE_COLOR: te.SRC_COLOR, ONE_MINUS_SOURCE_COLOR: te.ONE_MINUS_SRC_COLOR, DESTINATION_COLOR: te.DST_COLOR, ONE_MINUS_DESTINATION_COLOR: te.ONE_MINUS_DST_COLOR, SOURCE_ALPHA: te.SRC_ALPHA, ONE_MINUS_SOURCE_ALPHA: te.ONE_MINUS_SRC_ALPHA, DESTINATION_ALPHA: te.DST_ALPHA, ONE_MINUS_DESTINATION_ALPHA: te.ONE_MINUS_DST_ALPHA, CONSTANT_COLOR: te.CONSTANT_COLOR, ONE_MINUS_CONSTANT_COLOR: te.ONE_MINUS_CONSTANT_COLOR, CONSTANT_ALPHA: te.CONSTANT_ALPHA, ONE_MINUS_CONSTANT_ALPHA: te.ONE_MINUS_CONSTANT_ALPHA, SOURCE_ALPHA_SATURATE: te.SRC_ALPHA_SATURATE }, Co = Object.freeze(xTe); var TTe = { DISABLED: Object.freeze({ enabled: !1 }), ALPHA_BLEND: Object.freeze({ enabled: !0, equationRgb: ma.ADD, equationAlpha: ma.ADD, functionSourceRgb: Co.SOURCE_ALPHA, functionSourceAlpha: Co.ONE, functionDestinationRgb: Co.ONE_MINUS_SOURCE_ALPHA, functionDestinationAlpha: Co.ONE_MINUS_SOURCE_ALPHA }), PRE_MULTIPLIED_ALPHA_BLEND: Object.freeze({ enabled: !0, equationRgb: ma.ADD, equationAlpha: ma.ADD, functionSourceRgb: Co.ONE, functionSourceAlpha: Co.ONE, functionDestinationRgb: Co.ONE_MINUS_SOURCE_ALPHA, functionDestinationAlpha: Co.ONE_MINUS_SOURCE_ALPHA }), ADDITIVE_BLEND: Object.freeze({ enabled: !0, equationRgb: ma.ADD, equationAlpha: ma.ADD, functionSourceRgb: Co.SOURCE_ALPHA, functionSourceAlpha: Co.ONE, functionDestinationRgb: Co.ONE, functionDestinationAlpha: Co.ONE }) }, an = Object.freeze(TTe); var ETe = { FRONT: te.FRONT, BACK: te.BACK, FRONT_AND_BACK: te.FRONT_AND_BACK }, gi = Object.freeze(ETe); function rC(e) { e = y(e, y.EMPTY_OBJECT), this.material = e.material, this.translucent = y(e.translucent, !0), this._vertexShaderSource = e.vertexShaderSource, this._fragmentShaderSource = e.fragmentShaderSource, this._renderState = e.renderState, this._closed = y(e.closed, !1) } Object.defineProperties(rC.prototype, { vertexShaderSource: { get: function () { return this._vertexShaderSource } }, fragmentShaderSource: { get: function () { return this._fragmentShaderSource } }, renderState: { get: function () { return this._renderState } }, closed: { get: function () { return this._closed } } }); rC.prototype.getFragmentShaderSource = function () {
        let e = []; return this.flat && e.push("#define FLAT"), this.faceForward && e.push("#define FACE_FORWARD"), l(this.material) && e.push(this.material.shaderSource), e.push(this.fragmentShaderSource), e.join(`
`)
    }; rC.prototype.isTranslucent = function () { return l(this.material) && this.material.isTranslucent() || !l(this.material) && this.translucent }; rC.prototype.getRenderState = function () { let e = this.isTranslucent(), t = tt(this.renderState, !1); return e ? (t.depthMask = !1, t.blending = an.ALPHA_BLEND) : t.depthMask = !0, t }; rC.getDefaultRenderState = function (e, t, n) { let i = { depthTest: { enabled: !0 } }; return e && (i.depthMask = !1, i.blending = an.ALPHA_BLEND), t && (i.cull = { enabled: !0, face: gi.BACK }), l(n) && (i = yt(n, i, !0)), i }; var Yi = rC; function bTe() { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (e) { let t = Math.random() * 16 | 0; return (e === "x" ? t : t & 3 | 8).toString(16) }) } var Nn = bTe; function sC(e, t, n, i, o) { this._format = e, this._datatype = t, this._width = n, this._height = i, this._buffer = o } Object.defineProperties(sC.prototype, { internalFormat: { get: function () { return this._format } }, pixelDatatype: { get: function () { return this._datatype } }, width: { get: function () { return this._width } }, height: { get: function () { return this._height } }, bufferView: { get: function () { return this._buffer } } }); sC.clone = function (e) { if (!!l(e)) return new sC(e._format, e._datatype, e._width, e._height, e._buffer) }; sC.prototype.clone = function () { return sC.clone(this) }; var jP = sC; var yX = po(al(), 1); function AX() { if (!l(qs._canTransferArrayBuffer)) { let e = new Worker(xX("Workers/transferTypedArrayTest.js")); e.postMessage = y(e.webkitPostMessage, e.postMessage); let t = 99, n = new Int8Array([t]); try { e.postMessage({ array: n }, [n.buffer]) } catch { return qs._canTransferArrayBuffer = !1, qs._canTransferArrayBuffer } let i = js(); e.onmessage = function (o) { let r = o.data.array, s = l(r) && r[0] === t; i.resolve(s), e.terminate(), qs._canTransferArrayBuffer = s }, qs._canTransferArrayBuffer = i.promise } return qs._canTransferArrayBuffer } var FH = new _e; function CX(e, t) { --e._activeTasks; let n = t.id; if (!l(n)) return; let i = e._deferreds, o = i[n]; if (l(t.error)) { let r = t.error; r.name === "RuntimeError" ? (r = new fe(t.error.message), r.stack = t.error.stack) : r.name === "DeveloperError" && (r = new ye(t.error.message), r.stack = t.error.stack), FH.raiseEvent(r), o.reject(r) } else FH.raiseEvent(), o.resolve(t.result); delete i[n] } function xX(e) { let t = Jt(e); if (YA(t)) { let n = `importScripts("${t}");`, i; try { i = new Blob([n], { type: "application/javascript" }) } catch { let s = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, a = new s; a.append(n), i = a.getBlob("application/javascript") } t = (window.URL || window.webkitURL).createObjectURL(i) } return t } var LH; function STe() { return l(LH) || (LH = xX("Workers/cesiumWorkerBootstrapper.js")), LH } function TX(e) { let t = new Worker(STe()); t.postMessage = y(t.webkitPostMessage, t.postMessage); let n = { loaderConfig: { paths: { Workers: Jt("Workers") }, baseUrl: Jt.getCesiumBaseUrl().url }, workerModule: e._workerPath }; return t.postMessage(n), t.onmessage = function (i) { CX(e, i.data) }, t } function wTe(e, t) { let n = { modulePath: void 0, wasmBinaryFile: void 0, wasmBinary: void 0 }; if (!Nt.supportsWebAssembly()) { if (!l(t.fallbackModulePath)) throw new fe(`This browser does not support Web Assembly, and no backup module was provided for ${e._workerPath}`); return n.modulePath = Jt(t.fallbackModulePath), Promise.resolve(n) } return n.modulePath = Jt(t.modulePath), n.wasmBinaryFile = Jt(t.wasmBinaryFile), Pe.fetchArrayBuffer({ url: n.wasmBinaryFile }).then(function (i) { return n.wasmBinary = i, n }) } function qs(e, t) { let n = new yX.default(e); this._workerPath = n.scheme().length !== 0 && n.fragment().length === 0 ? e : qs._workerModulePrefix + e, this._maximumActiveTasks = y(t, Number.POSITIVE_INFINITY), this._activeTasks = 0, this._deferreds = {}, this._nextID = 0 } var DTe = []; qs.prototype.scheduleTask = function (e, t) { if (l(this._worker) || (this._worker = TX(this)), this._activeTasks >= this._maximumActiveTasks) return; ++this._activeTasks; let n = this; return Promise.resolve(AX()).then(function (i) { l(t) ? i || (t.length = 0) : t = DTe; let o = n._nextID++, r = js(); return n._deferreds[o] = r, n._worker.postMessage({ id: o, parameters: e, canTransferArrayBuffer: i }, t), r.promise }) }; qs.prototype.initWebAssemblyModule = function (e) { l(this._worker) || (this._worker = TX(this)); let t = js(), n = this, i = this._worker; return wTe(this, e).then(function (o) { return Promise.resolve(AX()).then(function (r) { let s, a = o.wasmBinary; l(a) && r && (s = [a]), i.onmessage = function (c) { i.onmessage = function (u) { CX(n, u.data) }, t.resolve(c.data) }, i.postMessage({ webAssemblyConfig: o }, s) }) }), t.promise }; qs.prototype.isDestroyed = function () { return !1 }; qs.prototype.destroy = function () { return l(this._worker) && this._worker.terminate(), le(this) }; qs.taskCompletedEvent = FH; qs._defaultWorkerModulePrefix = "Workers/"; qs._workerModulePrefix = qs._defaultWorkerModulePrefix; qs._canTransferArrayBuffer = void 0; var yi = qs; function Zh() { } Zh._transcodeTaskProcessor = new yi("transcodeKTX2", Number.POSITIVE_INFINITY); Zh._readyPromise = void 0; function vTe() { let e = Zh._transcodeTaskProcessor.initWebAssemblyModule({ modulePath: "ThirdParty/Workers/basis_transcoder.js", wasmBinaryFile: "ThirdParty/basis_transcoder.wasm" }).then(function () { return Zh._transcodeTaskProcessor }); Zh._readyPromise = e } Zh.transcode = function (e, t) { return l(Zh._readyPromise) || vTe(), Zh._readyPromise.then(function (n) { let i; if (e instanceof ArrayBuffer) { let o = new Uint8Array(e); return i = { supportedTargetFormats: t, ktx2Buffer: o }, n.scheduleTask(i, [e]) } return i = { supportedTargetFormats: t, ktx2Buffer: e }, n.scheduleTask(i, [e.buffer]) }).then(function (n) { let i = n.length, o = Object.keys(n[0]), r = o.length, s; for (s = 0; s < i; s++) { let a = n[s]; for (let c = 0; c < r; c++) { let u = a[o[c]]; a[o[c]] = new jP(u.internalFormat, u.datatype, u.width, u.height, u.levelBuffer) } } if (r === 1) { for (s = 0; s < i; ++s)n[s] = n[s][o[0]]; i === 1 && (n = n[0]) } return n }).catch(function (n) { throw n }) }; var qP = Zh; var EX; bX.setKTX2SupportedFormats = function (e, t, n, i, o, r) { EX = { s3tc: e, pvrtc: t, astc: n, etc: i, etc1: o, bc7: r } }; function bX(e) { let t; return e instanceof ArrayBuffer || ArrayBuffer.isView(e) ? t = Promise.resolve(e) : t = Pe.createIfNeeded(e).fetchArrayBuffer(), t.then(function (n) { return qP.transcode(n, EX) }) } var ul = bX; var fi = { UNSIGNED_BYTE: te.UNSIGNED_BYTE, UNSIGNED_SHORT: te.UNSIGNED_SHORT, UNSIGNED_INT: te.UNSIGNED_INT, FLOAT: te.FLOAT, HALF_FLOAT: te.HALF_FLOAT_OES, UNSIGNED_INT_24_8: te.UNSIGNED_INT_24_8, UNSIGNED_SHORT_4_4_4_4: te.UNSIGNED_SHORT_4_4_4_4, UNSIGNED_SHORT_5_5_5_1: te.UNSIGNED_SHORT_5_5_5_1, UNSIGNED_SHORT_5_6_5: te.UNSIGNED_SHORT_5_6_5 }; fi.toWebGLConstant = function (e, t) { switch (e) { case fi.UNSIGNED_BYTE: return te.UNSIGNED_BYTE; case fi.UNSIGNED_SHORT: return te.UNSIGNED_SHORT; case fi.UNSIGNED_INT: return te.UNSIGNED_INT; case fi.FLOAT: return te.FLOAT; case fi.HALF_FLOAT: return t.webgl2 ? te.HALF_FLOAT : te.HALF_FLOAT_OES; case fi.UNSIGNED_INT_24_8: return te.UNSIGNED_INT_24_8; case fi.UNSIGNED_SHORT_4_4_4_4: return te.UNSIGNED_SHORT_4_4_4_4; case fi.UNSIGNED_SHORT_5_5_5_1: return te.UNSIGNED_SHORT_5_5_5_1; case fi.UNSIGNED_SHORT_5_6_5: return fi.UNSIGNED_SHORT_5_6_5 } }; fi.isPacked = function (e) { return e === fi.UNSIGNED_INT_24_8 || e === fi.UNSIGNED_SHORT_4_4_4_4 || e === fi.UNSIGNED_SHORT_5_5_5_1 || e === fi.UNSIGNED_SHORT_5_6_5 }; fi.sizeInBytes = function (e) { switch (e) { case fi.UNSIGNED_BYTE: return 1; case fi.UNSIGNED_SHORT: case fi.UNSIGNED_SHORT_4_4_4_4: case fi.UNSIGNED_SHORT_5_5_5_1: case fi.UNSIGNED_SHORT_5_6_5: case fi.HALF_FLOAT: return 2; case fi.UNSIGNED_INT: case fi.FLOAT: case fi.UNSIGNED_INT_24_8: return 4 } }; fi.validate = function (e) { return e === fi.UNSIGNED_BYTE || e === fi.UNSIGNED_SHORT || e === fi.UNSIGNED_INT || e === fi.FLOAT || e === fi.HALF_FLOAT || e === fi.UNSIGNED_INT_24_8 || e === fi.UNSIGNED_SHORT_4_4_4_4 || e === fi.UNSIGNED_SHORT_5_5_5_1 || e === fi.UNSIGNED_SHORT_5_6_5 }; var Ye = Object.freeze(fi); var ot = { DEPTH_COMPONENT: te.DEPTH_COMPONENT, DEPTH_STENCIL: te.DEPTH_STENCIL, ALPHA: te.ALPHA, RGB: te.RGB, RGBA: te.RGBA, LUMINANCE: te.LUMINANCE, LUMINANCE_ALPHA: te.LUMINANCE_ALPHA, RGB_DXT1: te.COMPRESSED_RGB_S3TC_DXT1_EXT, RGBA_DXT1: te.COMPRESSED_RGBA_S3TC_DXT1_EXT, RGBA_DXT3: te.COMPRESSED_RGBA_S3TC_DXT3_EXT, RGBA_DXT5: te.COMPRESSED_RGBA_S3TC_DXT5_EXT, RGB_PVRTC_4BPPV1: te.COMPRESSED_RGB_PVRTC_4BPPV1_IMG, RGB_PVRTC_2BPPV1: te.COMPRESSED_RGB_PVRTC_2BPPV1_IMG, RGBA_PVRTC_4BPPV1: te.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG, RGBA_PVRTC_2BPPV1: te.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG, RGBA_ASTC: te.COMPRESSED_RGBA_ASTC_4x4_WEBGL, RGB_ETC1: te.COMPRESSED_RGB_ETC1_WEBGL, RGB8_ETC2: te.COMPRESSED_RGB8_ETC2, RGBA8_ETC2_EAC: te.COMPRESSED_RGBA8_ETC2_EAC, RGBA_BC7: te.COMPRESSED_RGBA_BPTC_UNORM }; ot.componentsLength = function (e) { switch (e) { case ot.RGB: return 3; case ot.RGBA: return 4; case ot.LUMINANCE_ALPHA: return 2; case ot.ALPHA: case ot.LUMINANCE: return 1; default: return 1 } }; ot.validate = function (e) { return e === ot.DEPTH_COMPONENT || e === ot.DEPTH_STENCIL || e === ot.ALPHA || e === ot.RGB || e === ot.RGBA || e === ot.LUMINANCE || e === ot.LUMINANCE_ALPHA || e === ot.RGB_DXT1 || e === ot.RGBA_DXT1 || e === ot.RGBA_DXT3 || e === ot.RGBA_DXT5 || e === ot.RGB_PVRTC_4BPPV1 || e === ot.RGB_PVRTC_2BPPV1 || e === ot.RGBA_PVRTC_4BPPV1 || e === ot.RGBA_PVRTC_2BPPV1 || e === ot.RGBA_ASTC || e === ot.RGB_ETC1 || e === ot.RGB8_ETC2 || e === ot.RGBA8_ETC2_EAC || e === ot.RGBA_BC7 }; ot.isColorFormat = function (e) { return e === ot.ALPHA || e === ot.RGB || e === ot.RGBA || e === ot.LUMINANCE || e === ot.LUMINANCE_ALPHA }; ot.isDepthFormat = function (e) { return e === ot.DEPTH_COMPONENT || e === ot.DEPTH_STENCIL }; ot.isCompressedFormat = function (e) { return e === ot.RGB_DXT1 || e === ot.RGBA_DXT1 || e === ot.RGBA_DXT3 || e === ot.RGBA_DXT5 || e === ot.RGB_PVRTC_4BPPV1 || e === ot.RGB_PVRTC_2BPPV1 || e === ot.RGBA_PVRTC_4BPPV1 || e === ot.RGBA_PVRTC_2BPPV1 || e === ot.RGBA_ASTC || e === ot.RGB_ETC1 || e === ot.RGB8_ETC2 || e === ot.RGBA8_ETC2_EAC || e === ot.RGBA_BC7 }; ot.isDXTFormat = function (e) { return e === ot.RGB_DXT1 || e === ot.RGBA_DXT1 || e === ot.RGBA_DXT3 || e === ot.RGBA_DXT5 }; ot.isPVRTCFormat = function (e) { return e === ot.RGB_PVRTC_4BPPV1 || e === ot.RGB_PVRTC_2BPPV1 || e === ot.RGBA_PVRTC_4BPPV1 || e === ot.RGBA_PVRTC_2BPPV1 }; ot.isASTCFormat = function (e) { return e === ot.RGBA_ASTC }; ot.isETC1Format = function (e) { return e === ot.RGB_ETC1 }; ot.isETC2Format = function (e) { return e === ot.RGB8_ETC2 || e === ot.RGBA8_ETC2_EAC }; ot.isBC7Format = function (e) { return e === ot.RGBA_BC7 }; ot.compressedTextureSizeInBytes = function (e, t, n) { switch (e) { case ot.RGB_DXT1: case ot.RGBA_DXT1: case ot.RGB_ETC1: case ot.RGB8_ETC2: return Math.floor((t + 3) / 4) * Math.floor((n + 3) / 4) * 8; case ot.RGBA_DXT3: case ot.RGBA_DXT5: case ot.RGBA_ASTC: case ot.RGBA8_ETC2_EAC: return Math.floor((t + 3) / 4) * Math.floor((n + 3) / 4) * 16; case ot.RGB_PVRTC_4BPPV1: case ot.RGBA_PVRTC_4BPPV1: return Math.floor((Math.max(t, 8) * Math.max(n, 8) * 4 + 7) / 8); case ot.RGB_PVRTC_2BPPV1: case ot.RGBA_PVRTC_2BPPV1: return Math.floor((Math.max(t, 16) * Math.max(n, 8) * 2 + 7) / 8); case ot.RGBA_BC7: return Math.ceil(t / 4) * Math.ceil(n / 4) * 16; default: return 0 } }; ot.textureSizeInBytes = function (e, t, n, i) { let o = ot.componentsLength(e); return Ye.isPacked(t) && (o = 1), o * Ye.sizeInBytes(t) * n * i }; ot.alignmentInBytes = function (e, t, n) { let i = ot.textureSizeInBytes(e, t, n, 1) % 4; return i === 0 ? 4 : i === 2 ? 2 : 1 }; ot.createTypedArray = function (e, t, n, i) { let o, r = Ye.sizeInBytes(t); r === Uint8Array.BYTES_PER_ELEMENT ? o = Uint8Array : r === Uint16Array.BYTES_PER_ELEMENT ? o = Uint16Array : r === Float32Array.BYTES_PER_ELEMENT && t === Ye.FLOAT ? o = Float32Array : o = Uint32Array; let s = ot.componentsLength(e) * n * i; return new o(s) }; ot.flipY = function (e, t, n, i, o) { if (o === 1) return e; let r = ot.createTypedArray(t, n, i, o), s = ot.componentsLength(t), a = i * s; for (let c = 0; c < o; ++c) { let u = c * i * s, f = (o - c - 1) * i * s; for (let d = 0; d < a; ++d)r[f + d] = e[u + d] } return r }; ot.toInternalFormat = function (e, t, n) { if (!n.webgl2) return e; if (e === ot.DEPTH_STENCIL) return te.DEPTH24_STENCIL8; if (e === ot.DEPTH_COMPONENT) { if (t === Ye.UNSIGNED_SHORT) return te.DEPTH_COMPONENT16; if (t === Ye.UNSIGNED_INT) return te.DEPTH_COMPONENT24 } if (t === Ye.FLOAT) switch (e) { case ot.RGBA: return te.RGBA32F; case ot.RGB: return te.RGB32F; case ot.RG: return te.RG32F; case ot.R: return te.R32F }if (t === Ye.HALF_FLOAT) switch (e) { case ot.RGBA: return te.RGBA16F; case ot.RGB: return te.RGB16F; case ot.RG: return te.RG16F; case ot.R: return te.R16F }return e }; var ht = Object.freeze(ot); var or = { _maximumCombinedTextureImageUnits: 0, _maximumCubeMapSize: 0, _maximumFragmentUniformVectors: 0, _maximumTextureImageUnits: 0, _maximumRenderbufferSize: 0, _maximumTextureSize: 0, _maximumVaryingVectors: 0, _maximumVertexAttributes: 0, _maximumVertexTextureImageUnits: 0, _maximumVertexUniformVectors: 0, _minimumAliasedLineWidth: 0, _maximumAliasedLineWidth: 0, _minimumAliasedPointSize: 0, _maximumAliasedPointSize: 0, _maximumViewportWidth: 0, _maximumViewportHeight: 0, _maximumTextureFilterAnisotropy: 0, _maximumDrawBuffers: 0, _maximumColorAttachments: 0, _maximumSamples: 0, _highpFloatSupported: !1, _highpIntSupported: !1 }; Object.defineProperties(or, { maximumCombinedTextureImageUnits: { get: function () { return or._maximumCombinedTextureImageUnits } }, maximumCubeMapSize: { get: function () { return or._maximumCubeMapSize } }, maximumFragmentUniformVectors: { get: function () { return or._maximumFragmentUniformVectors } }, maximumTextureImageUnits: { get: function () { return or._maximumTextureImageUnits } }, maximumRenderbufferSize: { get: function () { return or._maximumRenderbufferSize } }, maximumTextureSize: { get: function () { return or._maximumTextureSize } }, maximumVaryingVectors: { get: function () { return or._maximumVaryingVectors } }, maximumVertexAttributes: { get: function () { return or._maximumVertexAttributes } }, maximumVertexTextureImageUnits: { get: function () { return or._maximumVertexTextureImageUnits } }, maximumVertexUniformVectors: { get: function () { return or._maximumVertexUniformVectors } }, minimumAliasedLineWidth: { get: function () { return or._minimumAliasedLineWidth } }, maximumAliasedLineWidth: { get: function () { return or._maximumAliasedLineWidth } }, minimumAliasedPointSize: { get: function () { return or._minimumAliasedPointSize } }, maximumAliasedPointSize: { get: function () { return or._maximumAliasedPointSize } }, maximumViewportWidth: { get: function () { return or._maximumViewportWidth } }, maximumViewportHeight: { get: function () { return or._maximumViewportHeight } }, maximumTextureFilterAnisotropy: { get: function () { return or._maximumTextureFilterAnisotropy } }, maximumDrawBuffers: { get: function () { return or._maximumDrawBuffers } }, maximumColorAttachments: { get: function () { return or._maximumColorAttachments } }, maximumSamples: { get: function () { return or._maximumSamples } }, highpFloatSupported: { get: function () { return or._highpFloatSupported } }, highpIntSupported: { get: function () { return or._highpIntSupported } } }); var Ut = or; function YP(e, t, n, i, o, r, s, a, c, u, f) { this._context = e, this._texture = t, this._textureTarget = n, this._targetFace = i, this._pixelDatatype = s, this._internalFormat = o, this._pixelFormat = r, this._size = a, this._preMultiplyAlpha = c, this._flipY = u, this._initialized = f } Object.defineProperties(YP.prototype, { pixelFormat: { get: function () { return this._pixelFormat } }, pixelDatatype: { get: function () { return this._pixelDatatype } }, _target: { get: function () { return this._targetFace } } }); YP.prototype.copyFrom = function (e) { let t = y(e.xOffset, 0), n = y(e.yOffset, 0), i = e.source, o = this._context._gl, r = this._textureTarget, s = this._targetFace; o.activeTexture(o.TEXTURE0), o.bindTexture(r, this._texture); let a = i.width, c = i.height, u = i.arrayBufferView, f = this._size, d = this._pixelFormat, p = this._internalFormat, g = this._pixelDatatype, m = this._preMultiplyAlpha, A = this._flipY, C = y(e.skipColorSpaceConversion, !1), x = 4; l(u) && (x = ht.alignmentInBytes(d, g, a)), o.pixelStorei(o.UNPACK_ALIGNMENT, x), C ? o.pixelStorei(o.UNPACK_COLORSPACE_CONVERSION_WEBGL, o.NONE) : o.pixelStorei(o.UNPACK_COLORSPACE_CONVERSION_WEBGL, o.BROWSER_DEFAULT_WEBGL); let T = !1; if (!this._initialized) { if (t === 0 && n === 0 && a === f && c === f) l(u) ? (o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !1), A && (u = ht.flipY(u, d, g, f, f)), o.texImage2D(s, 0, p, f, f, 0, d, Ye.toWebGLConstant(g, this._context), u)) : (o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, m), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, A), o.texImage2D(s, 0, p, d, Ye.toWebGLConstant(g, this._context), i)), T = !0; else { o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !1); let b = ht.createTypedArray(d, g, f, f); o.texImage2D(s, 0, p, f, f, 0, d, Ye.toWebGLConstant(g, this._context), b) } this._initialized = !0 } T || (l(u) ? (o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !1), A && (u = ht.flipY(u, d, g, a, c)), o.texSubImage2D(s, 0, t, n, a, c, d, Ye.toWebGLConstant(g, this._context), u)) : (o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, m), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, A), o.texSubImage2D(s, 0, t, n, d, Ye.toWebGLConstant(g, this._context), i))), o.bindTexture(r, null) }; YP.prototype.copyFromFramebuffer = function (e, t, n, i, o, r) { e = y(e, 0), t = y(t, 0), n = y(n, 0), i = y(i, 0), o = y(o, this._size), r = y(r, this._size); let s = this._context._gl, a = this._textureTarget; s.activeTexture(s.TEXTURE0), s.bindTexture(a, this._texture), s.copyTexSubImage2D(this._targetFace, 0, e, t, n, i, o, r), s.bindTexture(a, null), this._initialized = !0 }; var Qh = YP; var XP = { DONT_CARE: te.DONT_CARE, FASTEST: te.FASTEST, NICEST: te.NICEST, validate: function (e) { return e === XP.DONT_CARE || e === XP.FASTEST || e === XP.NICEST } }, $h = Object.freeze(XP); var KP = { NEAREST: te.NEAREST, LINEAR: te.LINEAR }; KP.validate = function (e) { return e === KP.NEAREST || e === KP.LINEAR }; var Xi = Object.freeze(KP); var Rp = { NEAREST: te.NEAREST, LINEAR: te.LINEAR, NEAREST_MIPMAP_NEAREST: te.NEAREST_MIPMAP_NEAREST, LINEAR_MIPMAP_NEAREST: te.LINEAR_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR: te.NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_LINEAR: te.LINEAR_MIPMAP_LINEAR }; Rp.validate = function (e) { return e === Rp.NEAREST || e === Rp.LINEAR || e === Rp.NEAREST_MIPMAP_NEAREST || e === Rp.LINEAR_MIPMAP_NEAREST || e === Rp.NEAREST_MIPMAP_LINEAR || e === Rp.LINEAR_MIPMAP_LINEAR }; var ln = Object.freeze(Rp); var JP = { CLAMP_TO_EDGE: te.CLAMP_TO_EDGE, REPEAT: te.REPEAT, MIRRORED_REPEAT: te.MIRRORED_REPEAT, validate: function (e) { return e === JP.CLAMP_TO_EDGE || e === JP.REPEAT || e === JP.MIRRORED_REPEAT } }, In = Object.freeze(JP); function pb(e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.wrapS, In.CLAMP_TO_EDGE), n = y(e.wrapT, In.CLAMP_TO_EDGE), i = y(e.minificationFilter, ln.LINEAR), o = y(e.magnificationFilter, Xi.LINEAR), r = l(e.maximumAnisotropy) ? e.maximumAnisotropy : 1; this._wrapS = t, this._wrapT = n, this._minificationFilter = i, this._magnificationFilter = o, this._maximumAnisotropy = r } Object.defineProperties(pb.prototype, { wrapS: { get: function () { return this._wrapS } }, wrapT: { get: function () { return this._wrapT } }, minificationFilter: { get: function () { return this._minificationFilter } }, magnificationFilter: { get: function () { return this._magnificationFilter } }, maximumAnisotropy: { get: function () { return this._maximumAnisotropy } } }); pb.equals = function (e, t) { return e === t || l(e) && l(t) && e._wrapS === t._wrapS && e._wrapT === t._wrapT && e._minificationFilter === t._minificationFilter && e._magnificationFilter === t._magnificationFilter && e._maximumAnisotropy === t._maximumAnisotropy }; pb.NEAREST = Object.freeze(new pb({ wrapS: In.CLAMP_TO_EDGE, wrapT: In.CLAMP_TO_EDGE, minificationFilter: ln.NEAREST, magnificationFilter: Xi.NEAREST })); var dn = pb; function _b(e) { e = y(e, y.EMPTY_OBJECT); let t = e.context, n = e.source, i, o; if (l(n)) { let T = [n.positiveX, n.negativeX, n.positiveY, n.negativeY, n.positiveZ, n.negativeZ]; i = T[0].width, o = T[0].height } else i = e.width, o = e.height; let r = i, s = y(e.pixelDatatype, Ye.UNSIGNED_BYTE), a = y(e.pixelFormat, ht.RGBA), c = ht.toInternalFormat(a, s, t), u = ht.textureSizeInBytes(a, s, r, r) * 6, f = e.preMultiplyAlpha || a === ht.RGB || a === ht.LUMINANCE, d = y(e.flipY, !0), p = y(e.skipColorSpaceConversion, !1), g = t._gl, m = g.TEXTURE_CUBE_MAP, A = g.createTexture(); g.activeTexture(g.TEXTURE0), g.bindTexture(m, A); function C(T, b, S, D, P) { let B = b.arrayBufferView; l(B) || (B = b.bufferView); let R = 4; l(B) && (R = ht.alignmentInBytes(a, s, i)), g.pixelStorei(g.UNPACK_ALIGNMENT, R), P ? g.pixelStorei(g.UNPACK_COLORSPACE_CONVERSION_WEBGL, g.NONE) : g.pixelStorei(g.UNPACK_COLORSPACE_CONVERSION_WEBGL, g.BROWSER_DEFAULT_WEBGL), l(B) ? (g.pixelStorei(g.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL, !1), D && (B = ht.flipY(B, a, s, r, r)), g.texImage2D(T, 0, c, r, r, 0, a, Ye.toWebGLConstant(s, t), B)) : (g.pixelStorei(g.UNPACK_PREMULTIPLY_ALPHA_WEBGL, S), g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL, D), g.texImage2D(T, 0, c, a, Ye.toWebGLConstant(s, t), b)) } l(n) ? (C(g.TEXTURE_CUBE_MAP_POSITIVE_X, n.positiveX, f, d, p), C(g.TEXTURE_CUBE_MAP_NEGATIVE_X, n.negativeX, f, d, p), C(g.TEXTURE_CUBE_MAP_POSITIVE_Y, n.positiveY, f, d, p), C(g.TEXTURE_CUBE_MAP_NEGATIVE_Y, n.negativeY, f, d, p), C(g.TEXTURE_CUBE_MAP_POSITIVE_Z, n.positiveZ, f, d, p), C(g.TEXTURE_CUBE_MAP_NEGATIVE_Z, n.negativeZ, f, d, p)) : (g.texImage2D(g.TEXTURE_CUBE_MAP_POSITIVE_X, 0, c, r, r, 0, a, Ye.toWebGLConstant(s, t), null), g.texImage2D(g.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, c, r, r, 0, a, Ye.toWebGLConstant(s, t), null), g.texImage2D(g.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, c, r, r, 0, a, Ye.toWebGLConstant(s, t), null), g.texImage2D(g.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, c, r, r, 0, a, Ye.toWebGLConstant(s, t), null), g.texImage2D(g.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, c, r, r, 0, a, Ye.toWebGLConstant(s, t), null), g.texImage2D(g.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, c, r, r, 0, a, Ye.toWebGLConstant(s, t), null)), g.bindTexture(m, null), this._context = t, this._textureFilterAnisotropic = t._textureFilterAnisotropic, this._textureTarget = m, this._texture = A, this._pixelFormat = a, this._pixelDatatype = s, this._size = r, this._hasMipmap = !1, this._sizeInBytes = u, this._preMultiplyAlpha = f, this._flipY = d, this._sampler = void 0; let x = l(n); this._positiveX = new Qh(t, A, m, g.TEXTURE_CUBE_MAP_POSITIVE_X, c, a, s, r, f, d, x), this._negativeX = new Qh(t, A, m, g.TEXTURE_CUBE_MAP_NEGATIVE_X, c, a, s, r, f, d, x), this._positiveY = new Qh(t, A, m, g.TEXTURE_CUBE_MAP_POSITIVE_Y, c, a, s, r, f, d, x), this._negativeY = new Qh(t, A, m, g.TEXTURE_CUBE_MAP_NEGATIVE_Y, c, a, s, r, f, d, x), this._positiveZ = new Qh(t, A, m, g.TEXTURE_CUBE_MAP_POSITIVE_Z, c, a, s, r, f, d, x), this._negativeZ = new Qh(t, A, m, g.TEXTURE_CUBE_MAP_NEGATIVE_Z, c, a, s, r, f, d, x), this.sampler = l(e.sampler) ? e.sampler : new dn } Object.defineProperties(_b.prototype, { positiveX: { get: function () { return this._positiveX } }, negativeX: { get: function () { return this._negativeX } }, positiveY: { get: function () { return this._positiveY } }, negativeY: { get: function () { return this._negativeY } }, positiveZ: { get: function () { return this._positiveZ } }, negativeZ: { get: function () { return this._negativeZ } }, sampler: { get: function () { return this._sampler }, set: function (e) { let t = e.minificationFilter, n = e.magnificationFilter, i = t === ln.NEAREST_MIPMAP_NEAREST || t === ln.NEAREST_MIPMAP_LINEAR || t === ln.LINEAR_MIPMAP_NEAREST || t === ln.LINEAR_MIPMAP_LINEAR, o = this._context, r = this._pixelDatatype; (r === Ye.FLOAT && !o.textureFloatLinear || r === Ye.HALF_FLOAT && !o.textureHalfFloatLinear) && (t = i ? ln.NEAREST_MIPMAP_NEAREST : ln.NEAREST, n = Xi.NEAREST); let s = o._gl, a = this._textureTarget; s.activeTexture(s.TEXTURE0), s.bindTexture(a, this._texture), s.texParameteri(a, s.TEXTURE_MIN_FILTER, t), s.texParameteri(a, s.TEXTURE_MAG_FILTER, n), s.texParameteri(a, s.TEXTURE_WRAP_S, e.wrapS), s.texParameteri(a, s.TEXTURE_WRAP_T, e.wrapT), l(this._textureFilterAnisotropic) && s.texParameteri(a, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e.maximumAnisotropy), s.bindTexture(a, null), this._sampler = e } }, pixelFormat: { get: function () { return this._pixelFormat } }, pixelDatatype: { get: function () { return this._pixelDatatype } }, width: { get: function () { return this._size } }, height: { get: function () { return this._size } }, sizeInBytes: { get: function () { return this._hasMipmap ? Math.floor(this._sizeInBytes * 4 / 3) : this._sizeInBytes } }, preMultiplyAlpha: { get: function () { return this._preMultiplyAlpha } }, flipY: { get: function () { return this._flipY } }, _target: { get: function () { return this._textureTarget } } }); _b.prototype.generateMipmap = function (e) { e = y(e, $h.DONT_CARE), this._hasMipmap = !0; let t = this._context._gl, n = this._textureTarget; t.hint(t.GENERATE_MIPMAP_HINT, e), t.activeTexture(t.TEXTURE0), t.bindTexture(n, this._texture), t.generateMipmap(n), t.bindTexture(n, null) }; _b.prototype.isDestroyed = function () { return !1 }; _b.prototype.destroy = function () { return this._context._gl.deleteTexture(this._texture), this._positiveX = le(this._positiveX), this._negativeX = le(this._negativeX), this._positiveY = le(this._positiveY), this._negativeY = le(this._negativeY), this._positiveZ = le(this._positiveZ), this._negativeZ = le(this._negativeZ), le(this) }; var Xa = _b; function uf(e) { e = y(e, y.EMPTY_OBJECT); let t = e.context, n = e.width, i = e.height, o = e.source; l(o) && (l(n) || (n = y(o.videoWidth, o.width)), l(i) || (i = y(o.videoHeight, o.height))); let r = y(e.pixelFormat, ht.RGBA), s = y(e.pixelDatatype, Ye.UNSIGNED_BYTE), a = ht.toInternalFormat(r, s, t), c = ht.isCompressedFormat(a), u = e.preMultiplyAlpha || r === ht.RGB || r === ht.LUMINANCE, f = y(e.flipY, !0), d = y(e.skipColorSpaceConversion, !1), p = !0, g = t._gl, m = g.TEXTURE_2D, A = g.createTexture(); g.activeTexture(g.TEXTURE0), g.bindTexture(m, A); let C = 4; if (l(o) && l(o.arrayBufferView) && !c && (C = ht.alignmentInBytes(r, s, n)), g.pixelStorei(g.UNPACK_ALIGNMENT, C), d ? g.pixelStorei(g.UNPACK_COLORSPACE_CONVERSION_WEBGL, g.NONE) : g.pixelStorei(g.UNPACK_COLORSPACE_CONVERSION_WEBGL, g.BROWSER_DEFAULT_WEBGL), l(o)) if (l(o.arrayBufferView)) { g.pixelStorei(g.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL, !1); let T = o.arrayBufferView, b, S, D; if (c) { if (g.compressedTexImage2D(m, 0, a, n, i, 0, T), l(o.mipLevels)) for (S = n, D = i, b = 0; b < o.mipLevels.length; ++b)S = Math.floor(S / 2) | 0, S < 1 && (S = 1), D = Math.floor(D / 2) | 0, D < 1 && (D = 1), g.compressedTexImage2D(m, b + 1, a, S, D, 0, o.mipLevels[b]) } else if (f && (T = ht.flipY(T, r, s, n, i)), g.texImage2D(m, 0, a, n, i, 0, r, Ye.toWebGLConstant(s, t), T), l(o.mipLevels)) for (S = n, D = i, b = 0; b < o.mipLevels.length; ++b)S = Math.floor(S / 2) | 0, S < 1 && (S = 1), D = Math.floor(D / 2) | 0, D < 1 && (D = 1), g.texImage2D(m, b + 1, a, S, D, 0, r, Ye.toWebGLConstant(s, t), o.mipLevels[b]) } else l(o.framebuffer) ? (g.pixelStorei(g.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL, !1), o.framebuffer !== t.defaultFramebuffer && o.framebuffer._bind(), g.copyTexImage2D(m, 0, a, o.xOffset, o.yOffset, n, i, 0), o.framebuffer !== t.defaultFramebuffer && o.framebuffer._unBind()) : (g.pixelStorei(g.UNPACK_PREMULTIPLY_ALPHA_WEBGL, u), g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL, f), g.texImage2D(m, 0, a, r, Ye.toWebGLConstant(s, t), o)); else g.texImage2D(m, 0, a, n, i, 0, r, Ye.toWebGLConstant(s, t), null), p = !1; g.bindTexture(m, null); let x; c ? x = ht.compressedTextureSizeInBytes(r, n, i) : x = ht.textureSizeInBytes(r, s, n, i), this._id = Nn(), this._context = t, this._textureFilterAnisotropic = t._textureFilterAnisotropic, this._textureTarget = m, this._texture = A, this._internalFormat = a, this._pixelFormat = r, this._pixelDatatype = s, this._width = n, this._height = i, this._dimensions = new H(n, i), this._hasMipmap = !1, this._sizeInBytes = x, this._preMultiplyAlpha = u, this._flipY = f, this._initialized = p, this._sampler = void 0, this.sampler = l(e.sampler) ? e.sampler : new dn } uf.create = function (e) { return new uf(e) }; uf.fromFramebuffer = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.context, n = t._gl, i = y(e.pixelFormat, ht.RGB), o = y(e.framebufferXOffset, 0), r = y(e.framebufferYOffset, 0), s = y(e.width, n.drawingBufferWidth), a = y(e.height, n.drawingBufferHeight), c = e.framebuffer; return new uf({ context: t, width: s, height: a, pixelFormat: i, source: { framebuffer: l(c) ? c : t.defaultFramebuffer, xOffset: o, yOffset: r, width: s, height: a } }) }; Object.defineProperties(uf.prototype, { id: { get: function () { return this._id } }, sampler: { get: function () { return this._sampler }, set: function (e) { let t = e.minificationFilter, n = e.magnificationFilter, i = this._context, o = this._pixelFormat, r = this._pixelDatatype, s = t === ln.NEAREST_MIPMAP_NEAREST || t === ln.NEAREST_MIPMAP_LINEAR || t === ln.LINEAR_MIPMAP_NEAREST || t === ln.LINEAR_MIPMAP_LINEAR; (r === Ye.FLOAT && !i.textureFloatLinear || r === Ye.HALF_FLOAT && !i.textureHalfFloatLinear) && (t = s ? ln.NEAREST_MIPMAP_NEAREST : ln.NEAREST, n = Xi.NEAREST), i.webgl2 && ht.isDepthFormat(o) && (t = ln.NEAREST, n = Xi.NEAREST); let a = i._gl, c = this._textureTarget; a.activeTexture(a.TEXTURE0), a.bindTexture(c, this._texture), a.texParameteri(c, a.TEXTURE_MIN_FILTER, t), a.texParameteri(c, a.TEXTURE_MAG_FILTER, n), a.texParameteri(c, a.TEXTURE_WRAP_S, e.wrapS), a.texParameteri(c, a.TEXTURE_WRAP_T, e.wrapT), l(this._textureFilterAnisotropic) && a.texParameteri(c, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e.maximumAnisotropy), a.bindTexture(c, null), this._sampler = e } }, pixelFormat: { get: function () { return this._pixelFormat } }, pixelDatatype: { get: function () { return this._pixelDatatype } }, dimensions: { get: function () { return this._dimensions } }, preMultiplyAlpha: { get: function () { return this._preMultiplyAlpha } }, flipY: { get: function () { return this._flipY } }, width: { get: function () { return this._width } }, height: { get: function () { return this._height } }, sizeInBytes: { get: function () { return this._hasMipmap ? Math.floor(this._sizeInBytes * 4 / 3) : this._sizeInBytes } }, _target: { get: function () { return this._textureTarget } } }); uf.prototype.copyFrom = function (e) { let t = y(e.xOffset, 0), n = y(e.yOffset, 0), i = e.source, o = this._context, r = o._gl, s = this._textureTarget; r.activeTexture(r.TEXTURE0), r.bindTexture(s, this._texture); let a = i.width, c = i.height, u = i.arrayBufferView, f = this._width, d = this._height, p = this._internalFormat, g = this._pixelFormat, m = this._pixelDatatype, A = this._preMultiplyAlpha, C = this._flipY, x = y(e.skipColorSpaceConversion, !1), T = 4; l(u) && (T = ht.alignmentInBytes(g, m, a)), r.pixelStorei(r.UNPACK_ALIGNMENT, T), x ? r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, r.NONE) : r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, r.BROWSER_DEFAULT_WEBGL); let b = !1; if (!this._initialized) { if (t === 0 && n === 0 && a === f && c === d) l(u) ? (r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !1), C && (u = ht.flipY(u, g, m, f, d)), r.texImage2D(s, 0, p, f, d, 0, g, Ye.toWebGLConstant(m, o), u)) : (r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, A), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, C), r.texImage2D(s, 0, p, g, Ye.toWebGLConstant(m, o), i)), b = !0; else { r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !1); let S = ht.createTypedArray(g, m, f, d); r.texImage2D(s, 0, p, f, d, 0, g, Ye.toWebGLConstant(m, o), S) } this._initialized = !0 } b || (l(u) ? (r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !1), C && (u = ht.flipY(u, g, m, a, c)), r.texSubImage2D(s, 0, t, n, a, c, g, Ye.toWebGLConstant(m, o), u)) : (r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, A), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, C), r.texSubImage2D(s, 0, t, n, g, Ye.toWebGLConstant(m, o), i))), r.bindTexture(s, null) }; uf.prototype.copyFromFramebuffer = function (e, t, n, i, o, r) { e = y(e, 0), t = y(t, 0), n = y(n, 0), i = y(i, 0), o = y(o, this._width), r = y(r, this._height); let s = this._context._gl, a = this._textureTarget; s.activeTexture(s.TEXTURE0), s.bindTexture(a, this._texture), s.copyTexSubImage2D(a, 0, e, t, n, i, o, r), s.bindTexture(a, null), this._initialized = !0 }; uf.prototype.generateMipmap = function (e) { e = y(e, $h.DONT_CARE), this._hasMipmap = !0; let t = this._context._gl, n = this._textureTarget; t.hint(t.GENERATE_MIPMAP_HINT, e), t.activeTexture(t.TEXTURE0), t.bindTexture(n, this._texture), t.generateMipmap(n), t.bindTexture(n, null) }; uf.prototype.isDestroyed = function () { return !1 }; uf.prototype.destroy = function () { return this._context._gl.deleteTexture(this._texture), le(this) }; var Rt = uf; var ZP = `uniform sampler2D image;
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
vec4 rampColor = texture2D(image, vec2(materialInput.aspect / (2.0 * czm_pi), 0.5));
rampColor = czm_gammaCorrect(rampColor);
material.diffuse = rampColor.rgb;
material.alpha = rampColor.a;
return material;
}
`; var QP = `uniform sampler2D image;
uniform float strength;
uniform vec2 repeat;
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
vec2 st = materialInput.st;
vec2 centerPixel = fract(repeat * st);
float centerBump = texture2D(image, centerPixel).channel;
float imageWidth = float(imageDimensions.x);
vec2 rightPixel = fract(repeat * (st + vec2(1.0 / imageWidth, 0.0)));
float rightBump = texture2D(image, rightPixel).channel;
float imageHeight = float(imageDimensions.y);
vec2 leftPixel = fract(repeat * (st + vec2(0.0, 1.0 / imageHeight)));
float topBump = texture2D(image, leftPixel).channel;
vec3 normalTangentSpace = normalize(vec3(centerBump - rightBump, centerBump - topBump, clamp(1.0 - strength, 0.1, 1.0)));
vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;
material.normal = normalEC;
material.diffuse = vec3(0.01);
return material;
}
`; var $P = `uniform vec4 lightColor;
uniform vec4 darkColor;
uniform vec2 repeat;
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
vec2 st = materialInput.st;
float b = mod(floor(repeat.s * st.s) + floor(repeat.t * st.t), 2.0);
float scaledWidth = fract(repeat.s * st.s);
scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));
float scaledHeight = fract(repeat.t * st.t);
scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));
float value = min(scaledWidth, scaledHeight);
vec4 currentColor = mix(lightColor, darkColor, b);
vec4 color = czm_antialias(lightColor, darkColor, currentColor, value, 0.03);
color = czm_gammaCorrect(color);
material.diffuse = color.rgb;
material.alpha = color.a;
return material;
}
`; var e1 = `uniform vec4 lightColor;
uniform vec4 darkColor;
uniform vec2 repeat;
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
float b = smoothstep(0.3, 0.32, length(fract(repeat * materialInput.st) - 0.5));
vec4 color = mix(lightColor, darkColor, b);
color = czm_gammaCorrect(color);
material.diffuse = color.rgb;
material.alpha = color.a;
return material;
}
`; var t1 = `uniform sampler2D heights;
uniform sampler2D colors;
float getHeight(int idx, float invTexSize)
{
vec2 uv = vec2((float(idx) + 0.5) * invTexSize, 0.5);
#ifdef OES_texture_float
return texture2D(heights, uv).x;
#else
return czm_unpackFloat(texture2D(heights, uv));
#endif
}
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
float height = materialInput.height;
float invTexSize = 1.0 / float(heightsDimensions.x);
float minHeight = getHeight(0, invTexSize);
float maxHeight = getHeight(heightsDimensions.x - 1, invTexSize);
if (height < minHeight || height > maxHeight) {
material.diffuse = vec3(0.0);
material.alpha = 0.0;
return material;
}
int idxBelow = 0;
int idxAbove = heightsDimensions.x;
float heightBelow = minHeight;
float heightAbove = maxHeight;
const int maxIterations = 16;
for (int i = 0; i < maxIterations; i++) {
if (idxBelow >= idxAbove - 1) {
break;
}
int idxMid = (idxBelow + idxAbove) / 2;
float heightTex = getHeight(idxMid, invTexSize);
if (height > heightTex) {
idxBelow = idxMid;
heightBelow = heightTex;
} else {
idxAbove = idxMid;
heightAbove = heightTex;
}
}
float lerper = heightBelow == heightAbove ? 1.0 : (height - heightBelow) / (heightAbove - heightBelow);
vec2 colorUv = vec2(invTexSize * (float(idxBelow) + 0.5 + lerper), 0.5);
vec4 color = texture2D(colors, colorUv);
if (color.a > 0.0)
{
color.rgb /= color.a;
}
color.rgb = czm_gammaCorrect(color.rgb);
material.diffuse = color.rgb;
material.alpha = color.a;
return material;
}
`; var n1 = `#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif
uniform vec4 color;
uniform float spacing;
uniform float width;
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
float distanceToContour = mod(materialInput.height, spacing);
#ifdef GL_OES_standard_derivatives
float dxc = abs(dFdx(materialInput.height));
float dyc = abs(dFdy(materialInput.height));
float dF = max(dxc, dyc) * czm_pixelRatio * width;
float alpha = (distanceToContour < dF) ? 1.0 : 0.0;
#else
float alpha = (distanceToContour < (czm_pixelRatio * width)) ? 1.0 : 0.0;
#endif
vec4 outColor = czm_gammaCorrect(vec4(color.rgb, alpha * color.a));
material.diffuse = outColor.rgb;
material.alpha = outColor.a;
return material;
}
`; var i1 = `uniform sampler2D image;
uniform float minimumHeight;
uniform float maximumHeight;
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
float scaledHeight = clamp((materialInput.height - minimumHeight) / (maximumHeight - minimumHeight), 0.0, 1.0);
vec4 rampColor = texture2D(image, vec2(scaledHeight, 0.5));
rampColor = czm_gammaCorrect(rampColor);
material.diffuse = rampColor.rgb;
material.alpha = rampColor.a;
return material;
}
`; var o1 = `uniform vec4 fadeInColor;
uniform vec4 fadeOutColor;
uniform float maximumDistance;
uniform bool repeat;
uniform vec2 fadeDirection;
uniform vec2 time;
float getTime(float t, float coord)
{
float scalar = 1.0 / maximumDistance;
float q  = distance(t, coord) * scalar;
if (repeat)
{
float r = distance(t, coord + 1.0) * scalar;
float s = distance(t, coord - 1.0) * scalar;
q = min(min(r, s), q);
}
return clamp(q, 0.0, 1.0);
}
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
vec2 st = materialInput.st;
float s = getTime(time.x, st.s) * fadeDirection.s;
float t = getTime(time.y, st.t) * fadeDirection.t;
float u = length(vec2(s, t));
vec4 color = mix(fadeInColor, fadeOutColor, u);
color = czm_gammaCorrect(color);
material.emission = color.rgb;
material.alpha = color.a;
return material;
}
`; var r1 = `#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif
uniform vec4 color;
uniform float cellAlpha;
uniform vec2 lineCount;
uniform vec2 lineThickness;
uniform vec2 lineOffset;
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
vec2 st = materialInput.st;
float scaledWidth = fract(lineCount.s * st.s - lineOffset.s);
scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));
float scaledHeight = fract(lineCount.t * st.t - lineOffset.t);
scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));
float value;
#ifdef GL_OES_standard_derivatives
const float fuzz = 1.2;
vec2 thickness = (lineThickness * czm_pixelRatio) - 1.0;
vec2 dx = abs(dFdx(st));
vec2 dy = abs(dFdy(st));
vec2 dF = vec2(max(dx.s, dy.s), max(dx.t, dy.t)) * lineCount;
value = min(
smoothstep(dF.s * thickness.s, dF.s * (fuzz + thickness.s), scaledWidth),
smoothstep(dF.t * thickness.t, dF.t * (fuzz + thickness.t), scaledHeight));
#else
const float fuzz = 0.05;
vec2 range = 0.5 - (lineThickness * 0.05);
value = min(
1.0 - smoothstep(range.s, range.s + fuzz, scaledWidth),
1.0 - smoothstep(range.t, range.t + fuzz, scaledHeight));
#endif
float dRim = 1.0 - abs(dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC)));
float sRim = smoothstep(0.8, 1.0, dRim);
value *= (1.0 - sRim);
vec4 halfColor;
halfColor.rgb = color.rgb * 0.5;
halfColor.a = color.a * (1.0 - ((1.0 - cellAlpha) * value));
halfColor = czm_gammaCorrect(halfColor);
material.diffuse = halfColor.rgb;
material.emission = halfColor.rgb;
material.alpha = halfColor.a;
return material;
}
`; var s1 = `uniform sampler2D image;
uniform float strength;
uniform vec2 repeat;
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
vec4 textureValue = texture2D(image, fract(repeat * materialInput.st));
vec3 normalTangentSpace = textureValue.channels;
normalTangentSpace.xy = normalTangentSpace.xy * 2.0 - 1.0;
normalTangentSpace.z = clamp(1.0 - strength, 0.1, 1.0);
normalTangentSpace = normalize(normalTangentSpace);
vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;
material.normal = normalEC;
return material;
}
`; var a1 = `#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif
uniform vec4 color;
float getPointOnLine(vec2 p0, vec2 p1, float x)
{
float slope = (p0.y - p1.y) / (p0.x - p1.x);
return slope * (x - p0.x) + p0.y;
}
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
vec2 st = materialInput.st;
#ifdef GL_OES_standard_derivatives
float base = 1.0 - abs(fwidth(st.s)) * 10.0 * czm_pixelRatio;
#else
float base = 0.975;
#endif
vec2 center = vec2(1.0, 0.5);
float ptOnUpperLine = getPointOnLine(vec2(base, 1.0), center, st.s);
float ptOnLowerLine = getPointOnLine(vec2(base, 0.0), center, st.s);
float halfWidth = 0.15;
float s = step(0.5 - halfWidth, st.t);
s *= 1.0 - step(0.5 + halfWidth, st.t);
s *= 1.0 - step(base, st.s);
float t = step(base, materialInput.st.s);
t *= 1.0 - step(ptOnUpperLine, st.t);
t *= step(ptOnLowerLine, st.t);
float dist;
if (st.s < base)
{
float d1 = abs(st.t - (0.5 - halfWidth));
float d2 = abs(st.t - (0.5 + halfWidth));
dist = min(d1, d2);
}
else
{
float d1 = czm_infinity;
if (st.t < 0.5 - halfWidth && st.t > 0.5 + halfWidth)
{
d1 = abs(st.s - base);
}
float d2 = abs(st.t - ptOnUpperLine);
float d3 = abs(st.t - ptOnLowerLine);
dist = min(min(d1, d2), d3);
}
vec4 outsideColor = vec4(0.0);
vec4 currentColor = mix(outsideColor, color, clamp(s + t, 0.0, 1.0));
vec4 outColor = czm_antialias(outsideColor, color, currentColor, dist);
outColor = czm_gammaCorrect(outColor);
material.diffuse = outColor.rgb;
material.alpha = outColor.a;
return material;
}
`; var c1 = `uniform vec4 color;
uniform vec4 gapColor;
uniform float dashLength;
uniform float dashPattern;
varying float v_polylineAngle;
const float maskLength = 16.0;
mat2 rotate(float rad) {
float c = cos(rad);
float s = sin(rad);
return mat2(
c, s,
-s, c
);
}
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
vec2 pos = rotate(v_polylineAngle) * gl_FragCoord.xy;
float dashPosition = fract(pos.x / (dashLength * czm_pixelRatio));
float maskIndex = floor(dashPosition * maskLength);
float maskTest = floor(dashPattern / pow(2.0, maskIndex));
vec4 fragColor = (mod(maskTest, 2.0) < 1.0) ? gapColor : color;
if (fragColor.a < 0.005) {
discard;
}
fragColor = czm_gammaCorrect(fragColor);
material.emission = fragColor.rgb;
material.alpha = fragColor.a;
return material;
}
`; var l1 = `uniform vec4 color;
uniform float glowPower;
uniform float taperPower;
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
vec2 st = materialInput.st;
float glow = glowPower / abs(st.t - 0.5) - (glowPower / 0.5);
if (taperPower <= 0.99999) {
glow *= min(1.0, taperPower / (0.5 - st.s * 0.5) - (taperPower / 0.5));
}
vec4 fragColor;
fragColor.rgb = max(vec3(glow - 1.0 + color.rgb), color.rgb);
fragColor.a = clamp(0.0, 1.0, glow) * color.a;
fragColor = czm_gammaCorrect(fragColor);
material.emission = fragColor.rgb;
material.alpha = fragColor.a;
return material;
}
`; var u1 = `uniform vec4 color;
uniform vec4 outlineColor;
uniform float outlineWidth;
varying float v_width;
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
vec2 st = materialInput.st;
float halfInteriorWidth =  0.5 * (v_width - outlineWidth) / v_width;
float b = step(0.5 - halfInteriorWidth, st.t);
b *= 1.0 - step(0.5 + halfInteriorWidth, st.t);
float d1 = abs(st.t - (0.5 - halfInteriorWidth));
float d2 = abs(st.t - (0.5 + halfInteriorWidth));
float dist = min(d1, d2);
vec4 currentColor = mix(outlineColor, color, b);
vec4 outColor = czm_antialias(outlineColor, color, currentColor, dist);
outColor = czm_gammaCorrect(outColor);
material.diffuse = outColor.rgb;
material.alpha = outColor.a;
return material;
}
`; var f1 = `uniform vec4 color;
uniform vec4 rimColor;
uniform float width;
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
float d = 1.0 - dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC));
float s = smoothstep(1.0 - width, 1.0, d);
vec4 outColor = czm_gammaCorrect(color);
vec4 outRimColor = czm_gammaCorrect(rimColor);
material.diffuse = outColor.rgb;
material.emission = outRimColor.rgb * s;
material.alpha = mix(outColor.a, outRimColor.a, s);
return material;
}
`; var d1 = `uniform sampler2D image;
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
vec4 rampColor = texture2D(image, vec2(materialInput.slope / (czm_pi / 2.0), 0.5));
rampColor = czm_gammaCorrect(rampColor);
material.diffuse = rampColor.rgb;
material.alpha = rampColor.a;
return material;
}
`; var h1 = `uniform vec4 evenColor;
uniform vec4 oddColor;
uniform float offset;
uniform float repeat;
uniform bool horizontal;
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
float coord = mix(materialInput.st.s, materialInput.st.t, float(horizontal));
float value = fract((coord - offset) * (repeat * 0.5));
float dist = min(value, min(abs(value - 0.5), 1.0 - value));
vec4 currentColor = mix(evenColor, oddColor, step(0.5, value));
vec4 color = czm_antialias(evenColor, oddColor, currentColor, dist);
color = czm_gammaCorrect(color);
material.diffuse = color.rgb;
material.alpha = color.a;
return material;
}
`; var m1 = `uniform sampler2D specularMap;
uniform sampler2D normalMap;
uniform vec4 baseWaterColor;
uniform vec4 blendColor;
uniform float frequency;
uniform float animationSpeed;
uniform float amplitude;
uniform float specularIntensity;
uniform float fadeFactor;
czm_material czm_getMaterial(czm_materialInput materialInput)
{
czm_material material = czm_getDefaultMaterial(materialInput);
float time = czm_frameNumber * animationSpeed;
float fade = max(1.0, (length(materialInput.positionToEyeEC) / 10000000000.0) * frequency * fadeFactor);
float specularMapValue = texture2D(specularMap, materialInput.st).r;
vec4 noise = czm_getWaterNoise(normalMap, materialInput.st * frequency, time, 0.0);
vec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / amplitude));
normalTangentSpace.xy /= fade;
normalTangentSpace = mix(vec3(0.0, 0.0, 50.0), normalTangentSpace, specularMapValue);
normalTangentSpace = normalize(normalTangentSpace);
float tsPerturbationRatio = clamp(dot(normalTangentSpace, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);
material.alpha = mix(blendColor.a, baseWaterColor.a, specularMapValue) * specularMapValue;
material.diffuse = mix(blendColor.rgb, baseWaterColor.rgb, specularMapValue);
material.diffuse += (0.1 * tsPerturbationRatio);
material.diffuse = material.diffuse;
material.normal = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);
material.specular = specularIntensity;
material.shininess = 10.0;
return material;
}
`; function He(e) { this.type = void 0, this.shaderSource = void 0, this.materials = void 0, this.uniforms = void 0, this._uniforms = void 0, this.translucent = void 0, this._minificationFilter = y(e.minificationFilter, ln.LINEAR), this._magnificationFilter = y(e.magnificationFilter, Xi.LINEAR), this._strict = void 0, this._template = void 0, this._count = void 0, this._texturePaths = {}, this._loadedImages = [], this._loadedCubeMaps = [], this._textures = {}, this._updateFunctions = [], this._defaultTexture = void 0, PTe(e, this), Object.defineProperties(this, { type: { value: this.type, writable: !1 } }), l(He._uniformList[this.type]) || (He._uniformList[this.type] = Object.keys(this._uniforms)) } He._uniformList = {}; He.fromType = function (e, t) { let n = new He({ fabric: { type: e } }); if (l(t)) for (let i in t) t.hasOwnProperty(i) && (n.uniforms[i] = t[i]); return n }; He.prototype.isTranslucent = function () { if (l(this.translucent)) return typeof this.translucent == "function" ? this.translucent() : this.translucent; let e = !0, t = this._translucentFunctions, n = t.length; for (let i = 0; i < n; ++i) { let o = t[i]; if (typeof o == "function" ? e = e && o() : e = e && o, !e) break } return e }; He.prototype.update = function (e) { this._defaultTexture = e.defaultTexture; let t, n, i = this._loadedImages, o = i.length; for (t = 0; t < o; ++t) { let c = i[t]; n = c.id; let u = c.image, f; Array.isArray(u) && (f = u.slice(1, u.length).map(function (A) { return A.bufferView }), u = u[0]); let d = new dn({ minificationFilter: this._minificationFilter, magnificationFilter: this._magnificationFilter }), p; l(u.internalFormat) ? p = new Rt({ context: e, pixelFormat: u.internalFormat, width: u.width, height: u.height, source: { arrayBufferView: u.bufferView, mipLevels: f }, sampler: d }) : p = new Rt({ context: e, source: u, sampler: d }); let g = this._textures[n]; l(g) && g !== this._defaultTexture && g.destroy(), this._textures[n] = p; let m = `${n}Dimensions`; if (this.uniforms.hasOwnProperty(m)) { let A = this.uniforms[m]; A.x = p._width, A.y = p._height } } i.length = 0; let r = this._loadedCubeMaps; for (o = r.length, t = 0; t < o; ++t) { let c = r[t]; n = c.id; let u = c.images, f = new Xa({ context: e, source: { positiveX: u[0], negativeX: u[1], positiveY: u[2], negativeY: u[3], positiveZ: u[4], negativeZ: u[5] }, sampler: new dn({ minificationFilter: this._minificationFilter, magnificationFilter: this._magnificationFilter }) }); this._textures[n] = f } r.length = 0; let s = this._updateFunctions; for (o = s.length, t = 0; t < o; ++t)s[t](this, e); let a = this.materials; for (let c in a) a.hasOwnProperty(c) && a[c].update(e) }; He.prototype.isDestroyed = function () { return !1 }; He.prototype.destroy = function () { let e = this._textures; for (let n in e) if (e.hasOwnProperty(n)) { let i = e[n]; i !== this._defaultTexture && i.destroy() } let t = this.materials; for (let n in t) t.hasOwnProperty(n) && t[n].destroy(); return le(this) }; function PTe(e, t) { e = y(e, y.EMPTY_OBJECT), t._strict = y(e.strict, !1), t._count = y(e.count, 0), t._template = tt(y(e.fabric, y.EMPTY_OBJECT)), t._template.uniforms = tt(y(t._template.uniforms, y.EMPTY_OBJECT)), t._template.materials = tt(y(t._template.materials, y.EMPTY_OBJECT)), t.type = l(t._template.type) ? t._template.type : Nn(), t.shaderSource = "", t.materials = {}, t.uniforms = {}, t._uniforms = {}, t._translucentFunctions = []; let n, i = He._materialCache.getMaterial(t.type); if (l(i)) { let r = tt(i.fabric, !0); t._template = yt(t._template, r, !0), n = i.translucent } RTe(t), l(i) || He._materialCache.addMaterial(t.type, t), LTe(t), kTe(t), zTe(t); let o = t._translucentFunctions.length === 0 ? !0 : void 0; if (n = y(n, o), n = y(e.translucent, n), l(n)) if (typeof n == "function") { let r = function () { return n(t) }; t._translucentFunctions.push(r) } else t._translucentFunctions.push(n) } function NH(e, t, n, i) { if (l(e)) { for (let o in e) if (e.hasOwnProperty(o)) { let r = t.indexOf(o) !== -1; (i && !r || !i && r) && n(o, t) } } } function SX(e, t) { } function ITe(e, t) { } var OTe = ["type", "materials", "uniforms", "components", "source"], BTe = ["diffuse", "specular", "shininess", "normal", "emission", "alpha"]; function RTe(e) { let t = e._template, n = t.uniforms, i = t.materials, o = t.components; NH(t, OTe, SX, !0), NH(o, BTe, SX, !0); let r = []; for (let s in i) i.hasOwnProperty(s) && r.push(s); NH(n, r, ITe, !1) } function MTe(e, t) { let n = t._template.materials; for (let i in n) if (n.hasOwnProperty(i) && e.indexOf(i) > -1) return !0; return !1 } function LTe(e) {
        let t = e._template.components, n = e._template.source; if (l(n)) e.shaderSource += `${n}
`; else {
            if (e.shaderSource += `czm_material czm_getMaterial(czm_materialInput materialInput)
{
`, e.shaderSource += `czm_material material = czm_getDefaultMaterial(materialInput);
`, l(t)) {
                let i = Object.keys(e._template.materials).length > 0; for (let o in t) if (t.hasOwnProperty(o)) if (o === "diffuse" || o === "emission") {
                    let s = i && MTe(t[o], e) ? t[o] : `czm_gammaCorrect(${t[o]})`; e.shaderSource += `material.${o} = ${s}; 
`} else o === "alpha" ? e.shaderSource += `material.alpha = ${t.alpha}; 
`: e.shaderSource += `material.${o} = ${t[o]};
`} e.shaderSource += `return material;
}
`}
    } var wX = { mat2: qi, mat3: Q, mat4: F }, FTe = /\.ktx2$/i; function NTe(e) { let t; return function (n, i) { let o = n.uniforms, r = o[e], s = t !== r, a = !l(r) || r === He.DefaultImageId; t = r; let c = n._textures[e], u, f; if (r instanceof HTMLVideoElement) { if (r.readyState >= 2) { if (s && l(c) && (c !== i.defaultTexture && c.destroy(), c = void 0), !l(c) || c === i.defaultTexture) { let p = new dn({ minificationFilter: n._minificationFilter, magnificationFilter: n._magnificationFilter }); c = new Rt({ context: i, source: r, sampler: p }), n._textures[e] = c; return } c.copyFrom({ source: r }) } else l(c) || (n._textures[e] = i.defaultTexture); return } if (r instanceof Rt && r !== c) { n._texturePaths[e] = void 0; let p = n._textures[e]; l(p) && p !== n._defaultTexture && p.destroy(), n._textures[e] = r, u = `${e}Dimensions`, o.hasOwnProperty(u) && (f = o[u], f.x = r._width, f.y = r._height); return } if (s && l(c) && a && (c !== n._defaultTexture && c.destroy(), c = void 0), l(c) || (n._texturePaths[e] = void 0, c = n._textures[e] = n._defaultTexture, u = `${e}Dimensions`, o.hasOwnProperty(u) && (f = o[u], f.x = c._width, f.y = c._height)), a) return; let d = r instanceof Pe; if (!l(n._texturePaths[e]) || d && r.url !== n._texturePaths[e].url || !d && r !== n._texturePaths[e]) { if (typeof r == "string" || d) { let p = d ? r : Pe.createIfNeeded(r), g; FTe.test(p.url) ? g = ul(p.url) : g = p.fetchImage(), Promise.resolve(g).then(function (m) { n._loadedImages.push({ id: e, image: m }) }).catch(function () { l(c) && c !== n._defaultTexture && c.destroy(), n._textures[e] = n._defaultTexture }) } else (r instanceof HTMLCanvasElement || r instanceof HTMLImageElement) && n._loadedImages.push({ id: e, image: r }); n._texturePaths[e] = r } } } function VTe(e) { return function (t, n) { let i = t.uniforms[e]; if (i instanceof Xa) { let r = t._textures[e]; r !== t._defaultTexture && r.destroy(), t._texturePaths[e] = void 0, t._textures[e] = i; return } if (l(t._textures[e]) || (t._texturePaths[e] = void 0, t._textures[e] = n.defaultCubeMap), i === He.DefaultCubeMapId) return; let o = i.positiveX + i.negativeX + i.positiveY + i.negativeY + i.positiveZ + i.negativeZ; if (o !== t._texturePaths[e]) { let r = [Pe.createIfNeeded(i.positiveX).fetchImage(), Pe.createIfNeeded(i.negativeX).fetchImage(), Pe.createIfNeeded(i.positiveY).fetchImage(), Pe.createIfNeeded(i.negativeY).fetchImage(), Pe.createIfNeeded(i.positiveZ).fetchImage(), Pe.createIfNeeded(i.negativeZ).fetchImage()]; Promise.all(r).then(function (s) { t._loadedCubeMaps.push({ id: e, images: s }) }), t._texturePaths[e] = o } } } function kTe(e) { let t = e._template.uniforms; for (let n in t) t.hasOwnProperty(n) && DX(e, n) } function DX(e, t) { let n = e._strict, i = e._template.uniforms, o = i[t], r = UTe(o), s; if (r === "channels") s = gb(e, t, o, !1); else { if (r === "sampler2D") { let u = `${t}Dimensions`; HTe(e, u) > 0 && (i[u] = { type: "ivec3", x: 1, y: 1 }, DX(e, u)) } if (!new RegExp(`uniform\\s+${r}\\s+${t}\\s*;`).test(e.shaderSource)) { let u = `uniform ${r} ${t};`; e.shaderSource = u + e.shaderSource } let c = `${t}_${e._count++}`; if (s = gb(e, t, c), e.uniforms[t] = o, r === "sampler2D") e._uniforms[c] = function () { return e._textures[t] }, e._updateFunctions.push(NTe(t)); else if (r === "samplerCube") e._uniforms[c] = function () { return e._textures[t] }, e._updateFunctions.push(VTe(t)); else if (r.indexOf("mat") !== -1) { let u = new wX[r]; e._uniforms[c] = function () { return wX[r].fromColumnMajorArray(e.uniforms[t], u) } } else e._uniforms[c] = function () { return e.uniforms[t] } } } function UTe(e) { let t = e.type; if (!l(t)) { let n = typeof e; if (n === "number") t = "float"; else if (n === "boolean") t = "bool"; else if (n === "string" || e instanceof Pe || e instanceof HTMLCanvasElement || e instanceof HTMLImageElement) /^([rgba]){1,4}$/i.test(e) ? t = "channels" : e === He.DefaultCubeMapId ? t = "samplerCube" : t = "sampler2D"; else if (n === "object") if (Array.isArray(e)) (e.length === 4 || e.length === 9 || e.length === 16) && (t = `mat${Math.sqrt(e.length)}`); else { let i = 0; for (let o in e) e.hasOwnProperty(o) && (i += 1); i >= 2 && i <= 4 ? t = `vec${i}` : i === 6 && (t = "samplerCube") } } return t } function zTe(e) { let t = e._strict, n = e._template.materials; for (let i in n) if (n.hasOwnProperty(i)) { let o = new He({ strict: t, fabric: n[i], count: e._count }); e._count = o._count, e._uniforms = yt(e._uniforms, o._uniforms, !0), e.materials[i] = o, e._translucentFunctions = e._translucentFunctions.concat(o._translucentFunctions); let r = "czm_getMaterial", s = `${r}_${e._count++}`; gb(o, r, s), e.shaderSource = o.shaderSource + e.shaderSource; let a = `${s}(materialInput)`, c = gb(e, i, a) } } function gb(e, t, n, i) { i = y(i, !0); let o = 0, r = "([\\w])?", s = `([\\w${i ? "." : ""}])?`, a = new RegExp(s + t + r, "g"); return e.shaderSource = e.shaderSource.replace(a, function (c, u, f) { return u || f ? c : (o += 1, n) }), o } function HTe(e, t, n) { return gb(e, t, t, n) } He._materialCache = { _materials: {}, addMaterial: function (e, t) { this._materials[e] = t }, getMaterial: function (e) { return this._materials[e] } }; He.DefaultImageId = "czm_defaultImage"; He.DefaultCubeMapId = "czm_defaultCubeMap"; He.ColorType = "Color"; He._materialCache.addMaterial(He.ColorType, { fabric: { type: He.ColorType, uniforms: { color: new U(1, 0, 0, .5) }, components: { diffuse: "color.rgb", alpha: "color.a" } }, translucent: function (e) { return e.uniforms.color.alpha < 1 } }); He.ImageType = "Image"; He._materialCache.addMaterial(He.ImageType, { fabric: { type: He.ImageType, uniforms: { image: He.DefaultImageId, repeat: new H(1, 1), color: new U(1, 1, 1, 1) }, components: { diffuse: "texture2D(image, fract(repeat * materialInput.st)).rgb * color.rgb", alpha: "texture2D(image, fract(repeat * materialInput.st)).a * color.a" } }, translucent: function (e) { return e.uniforms.color.alpha < 1 } }); He.DiffuseMapType = "DiffuseMap"; He._materialCache.addMaterial(He.DiffuseMapType, { fabric: { type: He.DiffuseMapType, uniforms: { image: He.DefaultImageId, channels: "rgb", repeat: new H(1, 1) }, components: { diffuse: "texture2D(image, fract(repeat * materialInput.st)).channels" } }, translucent: !1 }); He.AlphaMapType = "AlphaMap"; He._materialCache.addMaterial(He.AlphaMapType, { fabric: { type: He.AlphaMapType, uniforms: { image: He.DefaultImageId, channel: "a", repeat: new H(1, 1) }, components: { alpha: "texture2D(image, fract(repeat * materialInput.st)).channel" } }, translucent: !0 }); He.SpecularMapType = "SpecularMap"; He._materialCache.addMaterial(He.SpecularMapType, { fabric: { type: He.SpecularMapType, uniforms: { image: He.DefaultImageId, channel: "r", repeat: new H(1, 1) }, components: { specular: "texture2D(image, fract(repeat * materialInput.st)).channel" } }, translucent: !1 }); He.EmissionMapType = "EmissionMap"; He._materialCache.addMaterial(He.EmissionMapType, { fabric: { type: He.EmissionMapType, uniforms: { image: He.DefaultImageId, channels: "rgb", repeat: new H(1, 1) }, components: { emission: "texture2D(image, fract(repeat * materialInput.st)).channels" } }, translucent: !1 }); He.BumpMapType = "BumpMap"; He._materialCache.addMaterial(He.BumpMapType, { fabric: { type: He.BumpMapType, uniforms: { image: He.DefaultImageId, channel: "r", strength: .8, repeat: new H(1, 1) }, source: QP }, translucent: !1 }); He.NormalMapType = "NormalMap"; He._materialCache.addMaterial(He.NormalMapType, { fabric: { type: He.NormalMapType, uniforms: { image: He.DefaultImageId, channels: "rgb", strength: .8, repeat: new H(1, 1) }, source: s1 }, translucent: !1 }); He.GridType = "Grid"; He._materialCache.addMaterial(He.GridType, { fabric: { type: He.GridType, uniforms: { color: new U(0, 1, 0, 1), cellAlpha: .1, lineCount: new H(8, 8), lineThickness: new H(1, 1), lineOffset: new H(0, 0) }, source: r1 }, translucent: function (e) { let t = e.uniforms; return t.color.alpha < 1 || t.cellAlpha < 1 } }); He.StripeType = "Stripe"; He._materialCache.addMaterial(He.StripeType, { fabric: { type: He.StripeType, uniforms: { horizontal: !0, evenColor: new U(1, 1, 1, .5), oddColor: new U(0, 0, 1, .5), offset: 0, repeat: 5 }, source: h1 }, translucent: function (e) { let t = e.uniforms; return t.evenColor.alpha < 1 || t.oddColor.alpha < 1 } }); He.CheckerboardType = "Checkerboard"; He._materialCache.addMaterial(He.CheckerboardType, { fabric: { type: He.CheckerboardType, uniforms: { lightColor: new U(1, 1, 1, .5), darkColor: new U(0, 0, 0, .5), repeat: new H(5, 5) }, source: $P }, translucent: function (e) { let t = e.uniforms; return t.lightColor.alpha < 1 || t.darkColor.alpha < 1 } }); He.DotType = "Dot"; He._materialCache.addMaterial(He.DotType, { fabric: { type: He.DotType, uniforms: { lightColor: new U(1, 1, 0, .75), darkColor: new U(0, 1, 1, .75), repeat: new H(5, 5) }, source: e1 }, translucent: function (e) { let t = e.uniforms; return t.lightColor.alpha < 1 || t.darkColor.alpha < 1 } }); He.WaterType = "Water"; He._materialCache.addMaterial(He.WaterType, { fabric: { type: He.WaterType, uniforms: { baseWaterColor: new U(.2, .3, .6, 1), blendColor: new U(0, 1, .699, 1), specularMap: He.DefaultImageId, normalMap: He.DefaultImageId, frequency: 10, animationSpeed: .01, amplitude: 1, specularIntensity: .5, fadeFactor: 1 }, source: m1 }, translucent: function (e) { let t = e.uniforms; return t.baseWaterColor.alpha < 1 || t.blendColor.alpha < 1 } }); He.RimLightingType = "RimLighting"; He._materialCache.addMaterial(He.RimLightingType, { fabric: { type: He.RimLightingType, uniforms: { color: new U(1, 0, 0, .7), rimColor: new U(1, 1, 1, .4), width: .3 }, source: f1 }, translucent: function (e) { let t = e.uniforms; return t.color.alpha < 1 || t.rimColor.alpha < 1 } }); He.FadeType = "Fade"; He._materialCache.addMaterial(He.FadeType, { fabric: { type: He.FadeType, uniforms: { fadeInColor: new U(1, 0, 0, 1), fadeOutColor: new U(0, 0, 0, 0), maximumDistance: .5, repeat: !0, fadeDirection: { x: !0, y: !0 }, time: new H(.5, .5) }, source: o1 }, translucent: function (e) { let t = e.uniforms; return t.fadeInColor.alpha < 1 || t.fadeOutColor.alpha < 1 } }); He.PolylineArrowType = "PolylineArrow"; He._materialCache.addMaterial(He.PolylineArrowType, { fabric: { type: He.PolylineArrowType, uniforms: { color: new U(1, 1, 1, 1) }, source: a1 }, translucent: !0 }); He.PolylineDashType = "PolylineDash"; He._materialCache.addMaterial(He.PolylineDashType, { fabric: { type: He.PolylineDashType, uniforms: { color: new U(1, 0, 1, 1), gapColor: new U(0, 0, 0, 0), dashLength: 16, dashPattern: 255 }, source: c1 }, translucent: !0 }); He.PolylineGlowType = "PolylineGlow"; He._materialCache.addMaterial(He.PolylineGlowType, { fabric: { type: He.PolylineGlowType, uniforms: { color: new U(0, .5, 1, 1), glowPower: .25, taperPower: 1 }, source: l1 }, translucent: !0 }); He.PolylineOutlineType = "PolylineOutline"; He._materialCache.addMaterial(He.PolylineOutlineType, { fabric: { type: He.PolylineOutlineType, uniforms: { color: new U(1, 1, 1, 1), outlineColor: new U(1, 0, 0, 1), outlineWidth: 1 }, source: u1 }, translucent: function (e) { let t = e.uniforms; return t.color.alpha < 1 || t.outlineColor.alpha < 1 } }); He.ElevationContourType = "ElevationContour"; He._materialCache.addMaterial(He.ElevationContourType, { fabric: { type: He.ElevationContourType, uniforms: { spacing: 100, color: new U(1, 0, 0, 1), width: 1 }, source: n1 }, translucent: !1 }); He.ElevationRampType = "ElevationRamp"; He._materialCache.addMaterial(He.ElevationRampType, { fabric: { type: He.ElevationRampType, uniforms: { image: He.DefaultImageId, minimumHeight: 0, maximumHeight: 1e4 }, source: i1 }, translucent: !1 }); He.SlopeRampMaterialType = "SlopeRamp"; He._materialCache.addMaterial(He.SlopeRampMaterialType, { fabric: { type: He.SlopeRampMaterialType, uniforms: { image: He.DefaultImageId }, source: d1 }, translucent: !1 }); He.AspectRampMaterialType = "AspectRamp"; He._materialCache.addMaterial(He.AspectRampMaterialType, { fabric: { type: He.AspectRampMaterialType, uniforms: { image: He.DefaultImageId }, source: ZP }, translucent: !1 }); He.ElevationBandType = "ElevationBand"; He._materialCache.addMaterial(He.ElevationBandType, { fabric: { type: He.ElevationBandType, uniforms: { heights: He.DefaultImageId, colors: He.DefaultImageId }, source: t1 }, translucent: !0 }); var Ki = He; function d0(e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.translucent, !0), n = y(e.closed, !1), i = y(e.materialSupport, d0.MaterialSupport.TEXTURED); this.material = l(e.material) ? e.material : Ki.fromType(Ki.ColorType), this.translucent = t, this._vertexShaderSource = y(e.vertexShaderSource, i.vertexShaderSource), this._fragmentShaderSource = y(e.fragmentShaderSource, i.fragmentShaderSource), this._renderState = Yi.getDefaultRenderState(t, n, e.renderState), this._closed = n, this._materialSupport = i, this._vertexFormat = i.vertexFormat, this._flat = y(e.flat, !1), this._faceForward = y(e.faceForward, !n) } Object.defineProperties(d0.prototype, { vertexShaderSource: { get: function () { return this._vertexShaderSource } }, fragmentShaderSource: { get: function () { return this._fragmentShaderSource } }, renderState: { get: function () { return this._renderState } }, closed: { get: function () { return this._closed } }, materialSupport: { get: function () { return this._materialSupport } }, vertexFormat: { get: function () { return this._vertexFormat } }, flat: { get: function () { return this._flat } }, faceForward: { get: function () { return this._faceForward } } }); d0.prototype.getFragmentShaderSource = Yi.prototype.getFragmentShaderSource; d0.prototype.isTranslucent = Yi.prototype.isTranslucent; d0.prototype.getRenderState = Yi.prototype.getRenderState; d0.MaterialSupport = { BASIC: Object.freeze({ vertexFormat: we.POSITION_AND_NORMAL, vertexShaderSource: HP, fragmentShaderSource: zP }), TEXTURED: Object.freeze({ vertexFormat: we.POSITION_NORMAL_AND_ST, vertexShaderSource: WP, fragmentShaderSource: GP }), ALL: Object.freeze({ vertexFormat: we.ALL, vertexShaderSource: UP, fragmentShaderSource: kP }) }; var eo = d0; var p1 = `varying vec3 v_positionEC;
varying vec3 v_normalEC;
varying vec4 v_color;
void main()
{
vec3 positionToEyeEC = -v_positionEC;
vec3 normalEC = normalize(v_normalEC);
#ifdef FACE_FORWARD
normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);
#endif
vec4 color = czm_gammaCorrect(v_color);
czm_materialInput materialInput;
materialInput.normalEC = normalEC;
materialInput.positionToEyeEC = positionToEyeEC;
czm_material material = czm_getDefaultMaterial(materialInput);
material.diffuse = color.rgb;
material.alpha = color.a;
gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);
}
`; var _1 = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;
attribute vec3 normal;
attribute vec4 color;
attribute float batchId;
varying vec3 v_positionEC;
varying vec3 v_normalEC;
varying vec4 v_color;
void main()
{
vec4 p = czm_computePosition();
v_positionEC = (czm_modelViewRelativeToEye * p).xyz;
v_normalEC = czm_normal * normal;
v_color = color;
gl_Position = czm_modelViewProjectionRelativeToEye * p;
}
`; var aC = `varying vec4 v_color;
void main()
{
gl_FragColor = czm_gammaCorrect(v_color);
}
`; var g1 = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;
attribute vec4 color;
attribute float batchId;
varying vec4 v_color;
void main()
{
vec4 p = czm_computePosition();
v_color = color;
gl_Position = czm_modelViewProjectionRelativeToEye * p;
}
`; function em(e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.translucent, !0), n = y(e.closed, !1), i = y(e.flat, !1), o = i ? g1 : _1, r = i ? aC : p1, s = i ? em.FLAT_VERTEX_FORMAT : em.VERTEX_FORMAT; this.material = void 0, this.translucent = t, this._vertexShaderSource = y(e.vertexShaderSource, o), this._fragmentShaderSource = y(e.fragmentShaderSource, r), this._renderState = Yi.getDefaultRenderState(t, n, e.renderState), this._closed = n, this._vertexFormat = s, this._flat = i, this._faceForward = y(e.faceForward, !n) } Object.defineProperties(em.prototype, { vertexShaderSource: { get: function () { return this._vertexShaderSource } }, fragmentShaderSource: { get: function () { return this._fragmentShaderSource } }, renderState: { get: function () { return this._renderState } }, closed: { get: function () { return this._closed } }, vertexFormat: { get: function () { return this._vertexFormat } }, flat: { get: function () { return this._flat } }, faceForward: { get: function () { return this._faceForward } } }); em.VERTEX_FORMAT = we.POSITION_AND_NORMAL; em.FLAT_VERTEX_FORMAT = we.POSITION_ONLY; em.prototype.getFragmentShaderSource = Yi.prototype.getFragmentShaderSource; em.prototype.isTranslucent = Yi.prototype.isTranslucent; em.prototype.getRenderState = Yi.prototype.getRenderState; var $t = em; function cC(e) { this._definitionChanged = new _e, this._color = void 0, this._colorSubscription = void 0, this.color = e } Object.defineProperties(cC.prototype, { isConstant: { get: function () { return j.isConstant(this._color) } }, definitionChanged: { get: function () { return this._definitionChanged } }, color: ae("color") }); cC.prototype.getType = function (e) { return "Color" }; cC.prototype.getValue = function (e, t) { return l(t) || (t = {}), t.color = j.getValueOrClonedDefault(this._color, e, U.WHITE, t.color), t }; cC.prototype.equals = function (e) { return this === e || e instanceof cC && j.equals(this._color, e._color) }; var Ot = cC; function Mp(e) { e = y(e, y.EMPTY_OBJECT), this._ellipsoid = y(e.ellipsoid, ie.WGS84), this._rectangle = y(e.rectangle, ce.MAX_VALUE), this._projection = new _i(this._ellipsoid), this._numberOfLevelZeroTilesX = y(e.numberOfLevelZeroTilesX, 2), this._numberOfLevelZeroTilesY = y(e.numberOfLevelZeroTilesY, 1) } Object.defineProperties(Mp.prototype, { ellipsoid: { get: function () { return this._ellipsoid } }, rectangle: { get: function () { return this._rectangle } }, projection: { get: function () { return this._projection } } }); Mp.prototype.getNumberOfXTilesAtLevel = function (e) { return this._numberOfLevelZeroTilesX << e }; Mp.prototype.getNumberOfYTilesAtLevel = function (e) { return this._numberOfLevelZeroTilesY << e }; Mp.prototype.rectangleToNativeRectangle = function (e, t) { let n = I.toDegrees(e.west), i = I.toDegrees(e.south), o = I.toDegrees(e.east), r = I.toDegrees(e.north); return l(t) ? (t.west = n, t.south = i, t.east = o, t.north = r, t) : new ce(n, i, o, r) }; Mp.prototype.tileXYToNativeRectangle = function (e, t, n, i) { let o = this.tileXYToRectangle(e, t, n, i); return o.west = I.toDegrees(o.west), o.south = I.toDegrees(o.south), o.east = I.toDegrees(o.east), o.north = I.toDegrees(o.north), o }; Mp.prototype.tileXYToRectangle = function (e, t, n, i) { let o = this._rectangle, r = this.getNumberOfXTilesAtLevel(n), s = this.getNumberOfYTilesAtLevel(n), a = o.width / r, c = e * a + o.west, u = (e + 1) * a + o.west, f = o.height / s, d = o.north - t * f, p = o.north - (t + 1) * f; return l(i) || (i = new ce(c, p, u, d)), i.west = c, i.south = p, i.east = u, i.north = d, i }; Mp.prototype.positionToTileXY = function (e, t, n) { let i = this._rectangle; if (!ce.contains(i, e)) return; let o = this.getNumberOfXTilesAtLevel(t), r = this.getNumberOfYTilesAtLevel(t), s = i.width / o, a = i.height / r, c = e.longitude; i.east < i.west && (c += I.TWO_PI); let u = (c - i.west) / s | 0; u >= o && (u = o - 1); let f = (i.north - e.latitude) / a | 0; return f >= r && (f = r - 1), l(n) ? (n.x = u, n.y = f, n) : new H(u, f) }; var Hi = Mp; var vX = new h, PX = new h, IX = new he, VH = new h, GTe = new h, OX = new re, WTe = new Hi, yb = [new he, new he, new he, new he], Ab = new H, Sr = {}; Sr.initialize = function () { let e = Sr._initPromise; return l(e) || (e = Pe.fetchJson(Jt("Assets/approximateTerrainHeights.json")).then(function (t) { Sr._terrainHeights = t }), Sr._initPromise = e), e }; Sr.getMinimumMaximumHeights = function (e, t) { t = y(t, ie.WGS84); let n = BX(e), i = Sr._defaultMinTerrainHeight, o = Sr._defaultMaxTerrainHeight; if (l(n)) { let r = `${n.level}-${n.x}-${n.y}`, s = Sr._terrainHeights[r]; l(s) && (i = s[0], o = s[1]), t.cartographicToCartesian(ce.northeast(e, IX), vX), t.cartographicToCartesian(ce.southwest(e, IX), PX), h.midpoint(PX, vX, VH); let a = t.scaleToGeodeticSurface(VH, GTe); if (l(a)) { let c = h.distance(VH, a); i = Math.min(i, -c) } else i = Sr._defaultMinTerrainHeight } return i = Math.max(Sr._defaultMinTerrainHeight, i), { minimumTerrainHeight: i, maximumTerrainHeight: o } }; Sr.getBoundingSphere = function (e, t) { t = y(t, ie.WGS84); let n = BX(e), i = Sr._defaultMaxTerrainHeight; if (l(n)) { let r = `${n.level}-${n.x}-${n.y}`, s = Sr._terrainHeights[r]; l(s) && (i = s[1]) } let o = re.fromRectangle3D(e, t, 0); return re.fromRectangle3D(e, t, i, OX), re.union(o, OX, o) }; function BX(e) { he.fromRadians(e.east, e.north, 0, yb[0]), he.fromRadians(e.west, e.north, 0, yb[1]), he.fromRadians(e.east, e.south, 0, yb[2]), he.fromRadians(e.west, e.south, 0, yb[3]); let t = 0, n = 0, i = 0, o = 0, r = Sr._terrainHeightsMaxLevel, s; for (s = 0; s <= r; ++s) { let a = !1; for (let c = 0; c < 4; ++c) { let u = yb[c]; if (WTe.positionToTileXY(u, s, Ab), c === 0) i = Ab.x, o = Ab.y; else if (i !== Ab.x || o !== Ab.y) { a = !0; break } } if (a) break; t = i, n = o } if (s !== 0) return { x: t, y: n, level: s > r ? r : s - 1 } } Sr._terrainHeightsMaxLevel = 6; Sr._defaultMaxTerrainHeight = 9e3; Sr._defaultMinTerrainHeight = -1e5; Sr._terrainHeights = void 0; Sr._initPromise = void 0; Object.defineProperties(Sr, { initialized: { get: function () { return l(Sr._terrainHeights) } } }); var oi = Sr; function Ka(e, t, n) { this.minimum = h.clone(y(e, h.ZERO)), this.maximum = h.clone(y(t, h.ZERO)), l(n) ? n = h.clone(n) : n = h.midpoint(this.minimum, this.maximum, new h), this.center = n } Ka.fromCorners = function (e, t, n) { return l(n) || (n = new Ka), n.minimum = h.clone(e, n.minimum), n.maximum = h.clone(t, n.maximum), n.center = h.midpoint(e, t, n.center), n }; Ka.fromPoints = function (e, t) { if (l(t) || (t = new Ka), !l(e) || e.length === 0) return t.minimum = h.clone(h.ZERO, t.minimum), t.maximum = h.clone(h.ZERO, t.maximum), t.center = h.clone(h.ZERO, t.center), t; let n = e[0].x, i = e[0].y, o = e[0].z, r = e[0].x, s = e[0].y, a = e[0].z, c = e.length; for (let d = 1; d < c; d++) { let p = e[d], g = p.x, m = p.y, A = p.z; n = Math.min(g, n), r = Math.max(g, r), i = Math.min(m, i), s = Math.max(m, s), o = Math.min(A, o), a = Math.max(A, a) } let u = t.minimum; u.x = n, u.y = i, u.z = o; let f = t.maximum; return f.x = r, f.y = s, f.z = a, t.center = h.midpoint(u, f, t.center), t }; Ka.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.minimum = h.clone(e.minimum, t.minimum), t.maximum = h.clone(e.maximum, t.maximum), t.center = h.clone(e.center, t.center), t) : new Ka(e.minimum, e.maximum, e.center) }; Ka.equals = function (e, t) { return e === t || l(e) && l(t) && h.equals(e.center, t.center) && h.equals(e.minimum, t.minimum) && h.equals(e.maximum, t.maximum) }; var y1 = new h; Ka.intersectPlane = function (e, t) { y1 = h.subtract(e.maximum, e.minimum, y1); let n = h.multiplyByScalar(y1, .5, y1), i = t.normal, o = n.x * Math.abs(i.x) + n.y * Math.abs(i.y) + n.z * Math.abs(i.z), r = h.dot(e.center, i) + t.distance; return r - o > 0 ? Kt.INSIDE : r + o < 0 ? Kt.OUTSIDE : Kt.INTERSECTING }; Ka.prototype.clone = function (e) { return Ka.clone(this, e) }; Ka.prototype.intersectPlane = function (e) { return Ka.intersectPlane(this, e) }; Ka.prototype.equals = function (e) { return Ka.equals(this, e) }; var h0 = Ka; var kH = {}; kH.computeDiscriminant = function (e, t, n) { return t * t - 4 * e * n }; function RX(e, t, n) { let i = e + t; return I.sign(e) !== I.sign(t) && Math.abs(i / Math.max(Math.abs(e), Math.abs(t))) < n ? 0 : i } kH.computeRealRoots = function (e, t, n) { let i; if (e === 0) return t === 0 ? [] : [-n / t]; if (t === 0) { if (n === 0) return [0, 0]; let c = Math.abs(n), u = Math.abs(e); if (c < u && c / u < I.EPSILON14) return [0, 0]; if (c > u && u / c < I.EPSILON14) return []; if (i = -n / e, i < 0) return []; let f = Math.sqrt(i); return [-f, f] } else if (n === 0) return i = -t / e, i < 0 ? [i, 0] : [0, i]; let o = t * t, r = 4 * e * n, s = RX(o, -r, I.EPSILON14); if (s < 0) return []; let a = -.5 * RX(t, I.sign(t) * Math.sqrt(s), I.EPSILON14); return t > 0 ? [a / e, n / a] : [n / a, a / e] }; var Pc = kH; var zH = {}; zH.computeDiscriminant = function (e, t, n, i) { let o = e * e, r = t * t, s = n * n, a = i * i; return 18 * e * t * n * i + r * s - 27 * o * a - 4 * (e * s * n + r * t * i) }; function UH(e, t, n, i) { let o = e, r = t / 3, s = n / 3, a = i, c = o * s, u = r * a, f = r * r, d = s * s, p = o * s - f, g = o * a - r * s, m = r * a - d, A = 4 * p * m - g * g, C, x; if (A < 0) { let X, q, J; f * u >= c * d ? (X = o, q = p, J = -2 * r * p + o * g) : (X = a, q = m, J = -a * g + 2 * s * m); let K = -(J < 0 ? -1 : 1) * Math.abs(X) * Math.sqrt(-A); x = -J + K; let Z = x / 2, de = Z < 0 ? -Math.pow(-Z, 1 / 3) : Math.pow(Z, 1 / 3), pe = x === K ? -de : -q / de; return C = q <= 0 ? de + pe : -J / (de * de + pe * pe + q), f * u >= c * d ? [(C - r) / o] : [-a / (C + s)] } let T = p, b = -2 * r * p + o * g, S = m, D = -a * g + 2 * s * m, P = Math.sqrt(A), B = Math.sqrt(3) / 2, R = Math.abs(Math.atan2(o * P, -b) / 3); C = 2 * Math.sqrt(-T); let M = Math.cos(R); x = C * M; let L = C * (-M / 2 - B * Math.sin(R)), _ = x + L > 2 * r ? x - r : L - r, E = o, w = _ / E; R = Math.abs(Math.atan2(a * P, -D) / 3), C = 2 * Math.sqrt(-S), M = Math.cos(R), x = C * M, L = C * (-M / 2 - B * Math.sin(R)); let v = -a, O = x + L < 2 * s ? x + s : L + s, V = v / O, z = E * O, k = -_ * O - E * v, G = _ * v, N = (s * k - r * G) / (-r * k + s * z); return w <= N ? w <= V ? N <= V ? [w, N, V] : [w, V, N] : [V, w, N] : w <= V ? [N, w, V] : N <= V ? [N, V, w] : [V, N, w] } zH.computeRealRoots = function (e, t, n, i) { let o, r; if (e === 0) return Pc.computeRealRoots(t, n, i); if (t === 0) { if (n === 0) { if (i === 0) return [0, 0, 0]; r = -i / e; let s = r < 0 ? -Math.pow(-r, 1 / 3) : Math.pow(r, 1 / 3); return [s, s, s] } else if (i === 0) return o = Pc.computeRealRoots(e, 0, n), o.Length === 0 ? [0] : [o[0], 0, o[1]]; return UH(e, 0, n, i) } else { if (n === 0) return i === 0 ? (r = -t / e, r < 0 ? [r, 0, 0] : [0, 0, r]) : UH(e, t, 0, i); if (i === 0) return o = Pc.computeRealRoots(e, t, n), o.length === 0 ? [0] : o[1] <= 0 ? [o[0], o[1], 0] : o[0] >= 0 ? [0, o[0], o[1]] : [o[0], 0, o[1]] } return UH(e, t, n, i) }; var lC = zH; var HH = {}; HH.computeDiscriminant = function (e, t, n, i, o) { let r = e * e, s = r * e, a = t * t, c = a * t, u = n * n, f = u * n, d = i * i, p = d * i, g = o * o, m = g * o; return a * u * d - 4 * c * p - 4 * e * f * d + 18 * e * t * n * p - 27 * r * d * d + 256 * s * m + o * (18 * c * n * i - 4 * a * f + 16 * e * u * u - 80 * e * t * u * i - 6 * e * a * d + 144 * r * n * d) + g * (144 * e * a * n - 27 * a * a - 128 * r * u - 192 * r * t * i) }; function ff(e, t, n, i) { let o = e * e, r = t - 3 * o / 8, s = n - t * e / 2 + o * e / 8, a = i - n * e / 4 + t * o / 16 - 3 * o * o / 256, c = lC.computeRealRoots(1, 2 * r, r * r - 4 * a, -s * s); if (c.length > 0) { let u = -e / 4, f = c[c.length - 1]; if (Math.abs(f) < I.EPSILON14) { let d = Pc.computeRealRoots(1, r, a); if (d.length === 2) { let p = d[0], g = d[1], m; if (p >= 0 && g >= 0) { let A = Math.sqrt(p), C = Math.sqrt(g); return [u - C, u - A, u + A, u + C] } else { if (p >= 0 && g < 0) return m = Math.sqrt(p), [u - m, u + m]; if (p < 0 && g >= 0) return m = Math.sqrt(g), [u - m, u + m] } } return [] } else if (f > 0) { let d = Math.sqrt(f), p = (r + f - s / d) / 2, g = (r + f + s / d) / 2, m = Pc.computeRealRoots(1, d, p), A = Pc.computeRealRoots(1, -d, g); return m.length !== 0 ? (m[0] += u, m[1] += u, A.length !== 0 ? (A[0] += u, A[1] += u, m[1] <= A[0] ? [m[0], m[1], A[0], A[1]] : A[1] <= m[0] ? [A[0], A[1], m[0], m[1]] : m[0] >= A[0] && m[1] <= A[1] ? [A[0], m[0], m[1], A[1]] : A[0] >= m[0] && A[1] <= m[1] ? [m[0], A[0], A[1], m[1]] : m[0] > A[0] && m[0] < A[1] ? [A[0], m[0], A[1], m[1]] : [m[0], A[0], m[1], A[1]]) : m) : A.length !== 0 ? (A[0] += u, A[1] += u, A) : [] } } return [] } function Cb(e, t, n, i) { let o = n * n, r = t * t, s = e * e, a = -2 * t, c = n * e + r - 4 * i, u = s * i - n * t * e + o, f = lC.computeRealRoots(1, a, c, u); if (f.length > 0) { let d = f[0], p = t - d, g = p * p, m = e / 2, A = p / 2, C = g - 4 * i, x = g + 4 * Math.abs(i), T = s - 4 * d, b = s + 4 * Math.abs(d), S, D; if (d < 0 || C * b < T * x) { let E = Math.sqrt(T); S = E / 2, D = E === 0 ? 0 : (e * A - n) / E } else { let E = Math.sqrt(C); S = E === 0 ? 0 : (e * A - n) / E, D = E / 2 } let P, B; m === 0 && S === 0 ? (P = 0, B = 0) : I.sign(m) === I.sign(S) ? (P = m + S, B = d / P) : (B = m - S, P = d / B); let R, M; A === 0 && D === 0 ? (R = 0, M = 0) : I.sign(A) === I.sign(D) ? (R = A + D, M = i / R) : (M = A - D, R = i / M); let L = Pc.computeRealRoots(1, P, R), _ = Pc.computeRealRoots(1, B, M); if (L.length !== 0) return _.length !== 0 ? L[1] <= _[0] ? [L[0], L[1], _[0], _[1]] : _[1] <= L[0] ? [_[0], _[1], L[0], L[1]] : L[0] >= _[0] && L[1] <= _[1] ? [_[0], L[0], L[1], _[1]] : _[0] >= L[0] && _[1] <= L[1] ? [L[0], _[0], _[1], L[1]] : L[0] > _[0] && L[0] < _[1] ? [_[0], L[0], _[1], L[1]] : [L[0], _[0], L[1], _[1]] : L; if (_.length !== 0) return _ } return [] } HH.computeRealRoots = function (e, t, n, i, o) { if (Math.abs(e) < I.EPSILON15) return lC.computeRealRoots(t, n, i, o); let r = t / e, s = n / e, a = i / e, c = o / e, u = r < 0 ? 1 : 0; switch (u += s < 0 ? u + 1 : u, u += a < 0 ? u + 1 : u, u += c < 0 ? u + 1 : u, u) { case 0: return ff(r, s, a, c); case 1: return Cb(r, s, a, c); case 2: return Cb(r, s, a, c); case 3: return ff(r, s, a, c); case 4: return ff(r, s, a, c); case 5: return Cb(r, s, a, c); case 6: return ff(r, s, a, c); case 7: return ff(r, s, a, c); case 8: return Cb(r, s, a, c); case 9: return ff(r, s, a, c); case 10: return ff(r, s, a, c); case 11: return Cb(r, s, a, c); case 12: return ff(r, s, a, c); case 13: return ff(r, s, a, c); case 14: return ff(r, s, a, c); case 15: return ff(r, s, a, c); default: return } }; var A1 = HH; function C1(e, t) { t = h.clone(y(t, h.ZERO)), h.equals(t, h.ZERO) || h.normalize(t, t), this.origin = h.clone(y(e, h.ZERO)), this.direction = t } C1.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.origin = h.clone(e.origin), t.direction = h.clone(e.direction), t) : new C1(e.origin, e.direction) }; C1.getPoint = function (e, t, n) { return l(n) || (n = new h), n = h.multiplyByScalar(e.direction, t, n), h.add(e.origin, n, n) }; var En = C1; var qo = {}; qo.rayPlane = function (e, t, n) { l(n) || (n = new h); let i = e.origin, o = e.direction, r = t.normal, s = h.dot(r, o); if (Math.abs(s) < I.EPSILON15) return; let a = (-t.distance - h.dot(r, i)) / s; if (!(a < 0)) return n = h.multiplyByScalar(o, a, n), h.add(i, n, n) }; var jTe = new h, qTe = new h, zX = new h, MX = new h, LX = new h; qo.rayTriangleParametric = function (e, t, n, i, o) { o = y(o, !1); let r = e.origin, s = e.direction, a = h.subtract(n, t, jTe), c = h.subtract(i, t, qTe), u = h.cross(s, c, zX), f = h.dot(a, u), d, p, g, m, A; if (o) { if (f < I.EPSILON6 || (d = h.subtract(r, t, MX), g = h.dot(d, u), g < 0 || g > f) || (p = h.cross(d, a, LX), m = h.dot(s, p), m < 0 || g + m > f)) return; A = h.dot(c, p) / f } else { if (Math.abs(f) < I.EPSILON6) return; let C = 1 / f; if (d = h.subtract(r, t, MX), g = h.dot(d, u) * C, g < 0 || g > 1 || (p = h.cross(d, a, LX), m = h.dot(s, p) * C, m < 0 || g + m > 1)) return; A = h.dot(c, p) * C } return A }; qo.rayTriangle = function (e, t, n, i, o, r) { let s = qo.rayTriangleParametric(e, t, n, i, o); if (!(!l(s) || s < 0)) return l(r) || (r = new h), h.multiplyByScalar(e.direction, s, r), h.add(e.origin, r, r) }; var YTe = new En; qo.lineSegmentTriangle = function (e, t, n, i, o, r, s) { let a = YTe; h.clone(e, a.origin), h.subtract(t, e, a.direction), h.normalize(a.direction, a.direction); let c = qo.rayTriangleParametric(a, n, i, o, r); if (!(!l(c) || c < 0 || c > h.distance(e, t))) return l(s) || (s = new h), h.multiplyByScalar(a.direction, c, s), h.add(a.origin, s, s) }; function XTe(e, t, n, i) { let o = t * t - 4 * e * n; if (o < 0) return; if (o > 0) { let s = 1 / (2 * e), a = Math.sqrt(o), c = (-t + a) * s, u = (-t - a) * s; return c < u ? (i.root0 = c, i.root1 = u) : (i.root0 = u, i.root1 = c), i } let r = -t / (2 * e); if (r !== 0) return i.root0 = i.root1 = r, i } var KTe = { root0: 0, root1: 0 }; function HX(e, t, n) { l(n) || (n = new Dc); let i = e.origin, o = e.direction, r = t.center, s = t.radius * t.radius, a = h.subtract(i, r, zX), c = h.dot(o, o), u = 2 * h.dot(o, a), f = h.magnitudeSquared(a) - s, d = XTe(c, u, f, KTe); if (!!l(d)) return n.start = d.root0, n.stop = d.root1, n } qo.raySphere = function (e, t, n) { if (n = HX(e, t, n), !(!l(n) || n.stop < 0)) return n.start = Math.max(n.start, 0), n }; var JTe = new En; qo.lineSegmentSphere = function (e, t, n, i) { let o = JTe; h.clone(e, o.origin); let r = h.subtract(t, e, o.direction), s = h.magnitude(r); if (h.normalize(r, r), i = HX(o, n, i), !(!l(i) || i.stop < 0 || i.start > s)) return i.start = Math.max(i.start, 0), i.stop = Math.min(i.stop, s), i }; var ZTe = new h, QTe = new h; qo.rayEllipsoid = function (e, t) { let n = t.oneOverRadii, i = h.multiplyComponents(n, e.origin, ZTe), o = h.multiplyComponents(n, e.direction, QTe), r = h.magnitudeSquared(i), s = h.dot(i, o), a, c, u, f, d; if (r > 1) { if (s >= 0) return; let p = s * s; if (a = r - 1, c = h.magnitudeSquared(o), u = c * a, p < u) return; if (p > u) { f = s * s - u, d = -s + Math.sqrt(f); let m = d / c, A = a / d; return m < A ? new Dc(m, A) : { start: A, stop: m } } let g = Math.sqrt(a / c); return new Dc(g, g) } else if (r < 1) return a = r - 1, c = h.magnitudeSquared(o), u = c * a, f = s * s - u, d = -s + Math.sqrt(f), new Dc(0, d / c); if (s < 0) return c = h.magnitudeSquared(o), new Dc(0, -s / c) }; function m0(e, t, n) { let i = e + t; return I.sign(e) !== I.sign(t) && Math.abs(i / Math.max(Math.abs(e), Math.abs(t))) < n ? 0 : i } function $Te(e, t, n, i, o) { let r = i * i, s = o * o, a = (e[Q.COLUMN1ROW1] - e[Q.COLUMN2ROW2]) * s, c = o * (i * m0(e[Q.COLUMN1ROW0], e[Q.COLUMN0ROW1], I.EPSILON15) + t.y), u = e[Q.COLUMN0ROW0] * r + e[Q.COLUMN2ROW2] * s + i * t.x + n, f = s * m0(e[Q.COLUMN2ROW1], e[Q.COLUMN1ROW2], I.EPSILON15), d = o * (i * m0(e[Q.COLUMN2ROW0], e[Q.COLUMN0ROW2]) + t.z), p, g = []; if (d === 0 && f === 0) { if (p = Pc.computeRealRoots(a, c, u), p.length === 0) return g; let R = p[0], M = Math.sqrt(Math.max(1 - R * R, 0)); if (g.push(new h(i, o * R, o * -M)), g.push(new h(i, o * R, o * M)), p.length === 2) { let L = p[1], _ = Math.sqrt(Math.max(1 - L * L, 0)); g.push(new h(i, o * L, o * -_)), g.push(new h(i, o * L, o * _)) } return g } let m = d * d, A = f * f, C = a * a, x = d * f, T = C + A, b = 2 * (c * a + x), S = 2 * u * a + c * c - A + m, D = 2 * (u * c - x), P = u * u - m; if (T === 0 && b === 0 && S === 0 && D === 0) return g; p = A1.computeRealRoots(T, b, S, D, P); let B = p.length; if (B === 0) return g; for (let R = 0; R < B; ++R) { let M = p[R], L = M * M, _ = Math.max(1 - L, 0), E = Math.sqrt(_), w; I.sign(a) === I.sign(u) ? w = m0(a * L + u, c * M, I.EPSILON12) : I.sign(u) === I.sign(c * M) ? w = m0(a * L, c * M + u, I.EPSILON12) : w = m0(a * L + c * M, u, I.EPSILON12); let v = m0(f * M, d, I.EPSILON15), O = w * v; O < 0 ? g.push(new h(i, o * M, o * E)) : O > 0 ? g.push(new h(i, o * M, o * -E)) : E !== 0 ? (g.push(new h(i, o * M, o * -E)), g.push(new h(i, o * M, o * E)), ++R) : g.push(new h(i, o * M, o * E)) } return g } var GH = new h, FX = new h, NX = new h, x1 = new h, eEe = new h, tEe = new Q, nEe = new Q, iEe = new Q, oEe = new Q, rEe = new Q, VX = new Q, kX = new Q, UX = new h, sEe = new h, aEe = new he; qo.grazingAltitudeLocation = function (e, t) { let n = e.origin, i = e.direction; if (!h.equals(n, h.ZERO)) { let P = t.geodeticSurfaceNormal(n, GH); if (h.dot(i, P) >= 0) return n } let o = l(this.rayEllipsoid(e, t)), r = t.transformPositionToScaledSpace(i, GH), s = h.normalize(r, r), a = h.mostOrthogonalAxis(r, x1), c = h.normalize(h.cross(a, s, FX), FX), u = h.normalize(h.cross(s, c, NX), NX), f = tEe; f[0] = s.x, f[1] = s.y, f[2] = s.z, f[3] = c.x, f[4] = c.y, f[5] = c.z, f[6] = u.x, f[7] = u.y, f[8] = u.z; let d = Q.transpose(f, nEe), p = Q.fromScale(t.radii, iEe), g = Q.fromScale(t.oneOverRadii, oEe), m = rEe; m[0] = 0, m[1] = -i.z, m[2] = i.y, m[3] = i.z, m[4] = 0, m[5] = -i.x, m[6] = -i.y, m[7] = i.x, m[8] = 0; let A = Q.multiply(Q.multiply(d, g, VX), m, VX), C = Q.multiply(Q.multiply(A, p, kX), f, kX), x = Q.multiplyByVector(A, n, eEe), T = $Te(C, h.negate(x, GH), 0, 0, 1), b, S, D = T.length; if (D > 0) { let P = h.clone(h.ZERO, sEe), B = Number.NEGATIVE_INFINITY; for (let M = 0; M < D; ++M) { b = Q.multiplyByVector(p, Q.multiplyByVector(f, T[M], UX), UX); let L = h.normalize(h.subtract(b, n, x1), x1), _ = h.dot(L, i); _ > B && (B = _, P = h.clone(b, P)) } let R = t.cartesianToCartographic(P, aEe); return B = I.clamp(B, 0, 1), S = h.magnitude(h.subtract(P, n, x1)) * Math.sqrt(1 - B * B), S = o ? -S : S, R.height = S, t.cartographicToCartesian(R, new h) } }; var cEe = new h; qo.lineSegmentPlane = function (e, t, n, i) { l(i) || (i = new h); let o = h.subtract(t, e, cEe), r = n.normal, s = h.dot(r, o); if (Math.abs(s) < I.EPSILON6) return; let a = h.dot(r, e), c = -(n.distance + a) / s; if (!(c < 0 || c > 1)) return h.multiplyByScalar(o, c, i), h.add(e, i, i), i }; qo.trianglePlaneIntersection = function (e, t, n, i) { let o = i.normal, r = i.distance, s = h.dot(o, e) + r < 0, a = h.dot(o, t) + r < 0, c = h.dot(o, n) + r < 0, u = 0; u += s ? 1 : 0, u += a ? 1 : 0, u += c ? 1 : 0; let f, d; if ((u === 1 || u === 2) && (f = new h, d = new h), u === 1) { if (s) return qo.lineSegmentPlane(e, t, i, f), qo.lineSegmentPlane(e, n, i, d), { positions: [e, t, n, f, d], indices: [0, 3, 4, 1, 2, 4, 1, 4, 3] }; if (a) return qo.lineSegmentPlane(t, n, i, f), qo.lineSegmentPlane(t, e, i, d), { positions: [e, t, n, f, d], indices: [1, 3, 4, 2, 0, 4, 2, 4, 3] }; if (c) return qo.lineSegmentPlane(n, e, i, f), qo.lineSegmentPlane(n, t, i, d), { positions: [e, t, n, f, d], indices: [2, 3, 4, 0, 1, 4, 0, 4, 3] } } else if (u === 2) if (s) if (a) { if (!c) return qo.lineSegmentPlane(e, n, i, f), qo.lineSegmentPlane(t, n, i, d), { positions: [e, t, n, f, d], indices: [0, 1, 4, 0, 4, 3, 2, 3, 4] } } else return qo.lineSegmentPlane(n, t, i, f), qo.lineSegmentPlane(e, t, i, d), { positions: [e, t, n, f, d], indices: [2, 0, 4, 2, 4, 3, 1, 3, 4] }; else return qo.lineSegmentPlane(t, e, i, f), qo.lineSegmentPlane(n, e, i, d), { positions: [e, t, n, f, d], indices: [1, 2, 4, 1, 4, 3, 0, 3, 4] } }; var Gi = qo; function ss(e, t) { this.normal = h.clone(e), this.distance = t } ss.fromPointNormal = function (e, t, n) { let i = -h.dot(t, e); return l(n) ? (h.clone(t, n.normal), n.distance = i, n) : new ss(t, i) }; var lEe = new h; ss.fromCartesian4 = function (e, t) { let n = h.fromCartesian4(e, lEe), i = e.w; return l(t) ? (h.clone(n, t.normal), t.distance = i, t) : new ss(n, i) }; ss.getPointDistance = function (e, t) { return h.dot(e.normal, t) + e.distance }; var uEe = new h; ss.projectPointOntoPlane = function (e, t, n) { l(n) || (n = new h); let i = ss.getPointDistance(e, t), o = h.multiplyByScalar(e.normal, i, uEe); return h.subtract(t, o, n) }; var fEe = new F, dEe = new se, hEe = new h; ss.transform = function (e, t, n) { let i = e.normal, o = e.distance, r = F.inverseTranspose(t, fEe), s = se.fromElements(i.x, i.y, i.z, o, dEe); s = F.multiplyByVector(r, s, s); let a = h.fromCartesian4(s, hEe); return s = se.divideByScalar(s, h.magnitude(a), s), ss.fromCartesian4(s, n) }; ss.clone = function (e, t) { return l(t) ? (h.clone(e.normal, t.normal), t.distance = e.distance, t) : new ss(e.normal, e.distance) }; ss.equals = function (e, t) { return e.distance === t.distance && h.equals(e.normal, t.normal) }; ss.ORIGIN_XY_PLANE = Object.freeze(new ss(h.UNIT_Z, 0)); ss.ORIGIN_YZ_PLANE = Object.freeze(new ss(h.UNIT_X, 0)); ss.ORIGIN_ZX_PLANE = Object.freeze(new ss(h.UNIT_Y, 0)); var nn = ss; var WH = new se; function Sd(e, t) { t = y(t, ie.WGS84), e = t.scaleToGeodeticSurface(e); let n = It.eastNorthUpToFixedFrame(e, t); this._ellipsoid = t, this._origin = e, this._xAxis = h.fromCartesian4(F.getColumn(n, 0, WH)), this._yAxis = h.fromCartesian4(F.getColumn(n, 1, WH)); let i = h.fromCartesian4(F.getColumn(n, 2, WH)); this._plane = nn.fromPointNormal(e, i) } Object.defineProperties(Sd.prototype, { ellipsoid: { get: function () { return this._ellipsoid } }, origin: { get: function () { return this._origin } }, plane: { get: function () { return this._plane } }, xAxis: { get: function () { return this._xAxis } }, yAxis: { get: function () { return this._yAxis } }, zAxis: { get: function () { return this._plane.normal } } }); var mEe = new h0; Sd.fromPoints = function (e, t) { let n = h0.fromPoints(e, mEe); return new Sd(n.center, t) }; var GX = new En, T1 = new h; Sd.prototype.projectPointOntoPlane = function (e, t) { let n = GX; n.origin = e, h.normalize(e, n.direction); let i = Gi.rayPlane(n, this._plane, T1); if (l(i) || (h.negate(n.direction, n.direction), i = Gi.rayPlane(n, this._plane, T1)), l(i)) { let o = h.subtract(i, this._origin, i), r = h.dot(this._xAxis, o), s = h.dot(this._yAxis, o); return l(t) ? (t.x = r, t.y = s, t) : new H(r, s) } }; Sd.prototype.projectPointsOntoPlane = function (e, t) { l(t) || (t = []); let n = 0, i = e.length; for (let o = 0; o < i; o++) { let r = this.projectPointOntoPlane(e[o], t[n]); l(r) && (t[n] = r, n++) } return t.length = n, t }; Sd.prototype.projectPointToNearestOnPlane = function (e, t) { l(t) || (t = new H); let n = GX; n.origin = e, h.clone(this._plane.normal, n.direction); let i = Gi.rayPlane(n, this._plane, T1); l(i) || (h.negate(n.direction, n.direction), i = Gi.rayPlane(n, this._plane, T1)); let o = h.subtract(i, this._origin, i), r = h.dot(this._xAxis, o), s = h.dot(this._yAxis, o); return t.x = r, t.y = s, t }; Sd.prototype.projectPointsToNearestOnPlane = function (e, t) { l(t) || (t = []); let n = e.length; t.length = n; for (let i = 0; i < n; i++)t[i] = this.projectPointToNearestOnPlane(e[i], t[i]); return t }; var pEe = new h; Sd.prototype.projectPointOntoEllipsoid = function (e, t) { l(t) || (t = new h); let n = this._ellipsoid, i = this._origin, o = this._xAxis, r = this._yAxis, s = pEe; return h.multiplyByScalar(o, e.x, s), t = h.add(i, s, t), h.multiplyByScalar(r, e.y, s), h.add(t, s, t), n.scaleToGeocentricSurface(t, t), t }; Sd.prototype.projectPointsOntoEllipsoid = function (e, t) { let n = e.length; l(t) ? t.length = n : t = new Array(n); for (let i = 0; i < n; ++i)t[i] = this.projectPointOntoEllipsoid(e[i], t[i]); return t }; var pa = Sd; function Ai(e, t) { this.center = h.clone(y(e, h.ZERO)), this.halfAxes = Q.clone(y(t, Q.ZERO)) } Ai.packedLength = h.packedLength + Q.packedLength; Ai.pack = function (e, t, n) { return n = y(n, 0), h.pack(e.center, t, n), Q.pack(e.halfAxes, t, n + h.packedLength), t }; Ai.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new Ai), h.unpack(e, t, n.center), Q.unpack(e, t + h.packedLength, n.halfAxes), n }; var _Ee = new h, gEe = new h, yEe = new h, AEe = new h, CEe = new h, xEe = new h, TEe = new Q, EEe = { unitary: new Q, diagonal: new Q }; Ai.fromPoints = function (e, t) { if (l(t) || (t = new Ai), !l(e) || e.length === 0) return t.halfAxes = Q.ZERO, t.center = h.ZERO, t; let n, i = e.length, o = h.clone(e[0], _Ee); for (n = 1; n < i; n++)h.add(o, e[n], o); let r = 1 / i; h.multiplyByScalar(o, r, o); let s = 0, a = 0, c = 0, u = 0, f = 0, d = 0, p; for (n = 0; n < i; n++)p = h.subtract(e[n], o, gEe), s += p.x * p.x, a += p.x * p.y, c += p.x * p.z, u += p.y * p.y, f += p.y * p.z, d += p.z * p.z; s *= r, a *= r, c *= r, u *= r, f *= r, d *= r; let g = TEe; g[0] = s, g[1] = a, g[2] = c, g[3] = a, g[4] = u, g[5] = f, g[6] = c, g[7] = f, g[8] = d; let m = Q.computeEigenDecomposition(g, EEe), A = Q.clone(m.unitary, t.halfAxes), C = Q.getColumn(A, 0, AEe), x = Q.getColumn(A, 1, CEe), T = Q.getColumn(A, 2, xEe), b = -Number.MAX_VALUE, S = -Number.MAX_VALUE, D = -Number.MAX_VALUE, P = Number.MAX_VALUE, B = Number.MAX_VALUE, R = Number.MAX_VALUE; for (n = 0; n < i; n++)p = e[n], b = Math.max(h.dot(C, p), b), S = Math.max(h.dot(x, p), S), D = Math.max(h.dot(T, p), D), P = Math.min(h.dot(C, p), P), B = Math.min(h.dot(x, p), B), R = Math.min(h.dot(T, p), R); C = h.multiplyByScalar(C, .5 * (P + b), C), x = h.multiplyByScalar(x, .5 * (B + S), x), T = h.multiplyByScalar(T, .5 * (R + D), T); let M = h.add(C, x, t.center); h.add(M, T, M); let L = yEe; return L.x = b - P, L.y = S - B, L.z = D - R, h.multiplyByScalar(L, .5, L), Q.multiplyByScale(t.halfAxes, L, t.halfAxes), t }; var KX = new h, bEe = new h; function WX(e, t, n, i, o, r, s, a, c, u, f) { l(f) || (f = new Ai); let d = f.halfAxes; Q.setColumn(d, 0, t, d), Q.setColumn(d, 1, n, d), Q.setColumn(d, 2, i, d); let p = KX; p.x = (o + r) / 2, p.y = (s + a) / 2, p.z = (c + u) / 2; let g = bEe; g.x = (r - o) / 2, g.y = (a - s) / 2, g.z = (u - c) / 2; let m = f.center; return p = Q.multiplyByVector(d, p, p), h.add(e, p, m), Q.multiplyByScale(d, g, d), f } var jX = new he, SEe = new h, wEe = new he, DEe = new he, vEe = new he, PEe = new he, IEe = new he, OEe = new h, qX = new h, BEe = new h, YX = new h, REe = new h, MEe = new H, LEe = new H, FEe = new H, NEe = new H, VEe = new H, kEe = new h, UEe = new h, zEe = new h, HEe = new h, GEe = new H, WEe = new h, jEe = new h, qEe = new h, YEe = new nn(h.UNIT_X, 0); Ai.fromRectangle = function (e, t, n, i, o) { t = y(t, 0), n = y(n, 0), i = y(i, ie.WGS84); let r, s, a, c, u, f, d; if (e.width <= I.PI) { let B = ce.center(e, jX), R = i.cartographicToCartesian(B, SEe), M = new pa(R, i); d = M.plane; let L = B.longitude, _ = e.south < 0 && e.north > 0 ? 0 : B.latitude, E = he.fromRadians(L, e.north, n, wEe), w = he.fromRadians(e.west, e.north, n, DEe), v = he.fromRadians(e.west, _, n, vEe), O = he.fromRadians(e.west, e.south, n, PEe), V = he.fromRadians(L, e.south, n, IEe), z = i.cartographicToCartesian(E, OEe), k = i.cartographicToCartesian(w, qX), G = i.cartographicToCartesian(v, BEe), N = i.cartographicToCartesian(O, YX), X = i.cartographicToCartesian(V, REe), q = M.projectPointToNearestOnPlane(z, MEe), J = M.projectPointToNearestOnPlane(k, LEe), W = M.projectPointToNearestOnPlane(G, FEe), K = M.projectPointToNearestOnPlane(N, NEe), Z = M.projectPointToNearestOnPlane(X, VEe); return r = Math.min(J.x, W.x, K.x), s = -r, c = Math.max(J.y, q.y), a = Math.min(K.y, Z.y), w.height = O.height = t, k = i.cartographicToCartesian(w, qX), N = i.cartographicToCartesian(O, YX), u = Math.min(nn.getPointDistance(d, k), nn.getPointDistance(d, N)), f = n, WX(M.origin, M.xAxis, M.yAxis, M.zAxis, r, s, a, c, u, f, o) } let p = e.south > 0, g = e.north < 0, m = p ? e.south : g ? e.north : 0, A = ce.center(e, jX).longitude, C = h.fromRadians(A, m, n, i, kEe); C.z = 0; let T = Math.abs(C.x) < I.EPSILON10 && Math.abs(C.y) < I.EPSILON10 ? h.UNIT_X : h.normalize(C, UEe), b = h.UNIT_Z, S = h.cross(T, b, zEe); d = nn.fromPointNormal(C, T, YEe); let D = h.fromRadians(A + I.PI_OVER_TWO, m, n, i, HEe); s = h.dot(nn.projectPointOntoPlane(d, D, GEe), S), r = -s, c = h.fromRadians(0, e.north, g ? t : n, i, WEe).z, a = h.fromRadians(0, e.south, p ? t : n, i, jEe).z; let P = h.fromRadians(e.east, m, n, i, qEe); return u = nn.getPointDistance(d, P), f = 0, WX(C, S, b, T, r, s, a, c, u, f, o) }; Ai.fromTransformation = function (e, t) { return l(t) || (t = new Ai), t.center = F.getTranslation(e, t.center), t.halfAxes = F.getMatrix3(e, t.halfAxes), t.halfAxes = Q.multiplyByScalar(t.halfAxes, .5, t.halfAxes), t }; Ai.clone = function (e, t) { if (!!l(e)) return l(t) ? (h.clone(e.center, t.center), Q.clone(e.halfAxes, t.halfAxes), t) : new Ai(e.center, e.halfAxes) }; Ai.intersectPlane = function (e, t) { let n = e.center, i = t.normal, o = e.halfAxes, r = i.x, s = i.y, a = i.z, c = Math.abs(r * o[Q.COLUMN0ROW0] + s * o[Q.COLUMN0ROW1] + a * o[Q.COLUMN0ROW2]) + Math.abs(r * o[Q.COLUMN1ROW0] + s * o[Q.COLUMN1ROW1] + a * o[Q.COLUMN1ROW2]) + Math.abs(r * o[Q.COLUMN2ROW0] + s * o[Q.COLUMN2ROW1] + a * o[Q.COLUMN2ROW2]), u = h.dot(i, n) + t.distance; return u <= -c ? Kt.OUTSIDE : u >= c ? Kt.INSIDE : Kt.INTERSECTING }; var JX = new h, ZX = new h, QX = new h, XEe = new h, XX = new h, KEe = new h; Ai.distanceSquaredTo = function (e, t) { let n = h.subtract(t, e.center, KX), i = e.halfAxes, o = Q.getColumn(i, 0, JX), r = Q.getColumn(i, 1, ZX), s = Q.getColumn(i, 2, QX), a = h.magnitude(o), c = h.magnitude(r), u = h.magnitude(s), f = !0, d = !0, p = !0; a > 0 ? h.divideByScalar(o, a, o) : f = !1, c > 0 ? h.divideByScalar(r, c, r) : d = !1, u > 0 ? h.divideByScalar(s, u, s) : p = !1; let g = !f + !d + !p, m, A, C; if (g === 1) { let S = o; m = r, A = s, d ? p || (S = s, A = o) : (S = r, m = o), C = h.cross(m, A, XX), S === o ? o = C : S === r ? r = C : S === s && (s = C) } else if (g === 2) { m = o, d ? m = r : p && (m = s); let S = h.UNIT_Y; S.equalsEpsilon(m, I.EPSILON3) && (S = h.UNIT_X), A = h.cross(m, S, XEe), h.normalize(A, A), C = h.cross(m, A, XX), h.normalize(C, C), m === o ? (r = A, s = C) : m === r ? (s = A, o = C) : m === s && (o = A, r = C) } else g === 3 && (o = h.UNIT_X, r = h.UNIT_Y, s = h.UNIT_Z); let x = KEe; x.x = h.dot(n, o), x.y = h.dot(n, r), x.z = h.dot(n, s); let T = 0, b; return x.x < -a ? (b = x.x + a, T += b * b) : x.x > a && (b = x.x - a, T += b * b), x.y < -c ? (b = x.y + c, T += b * b) : x.y > c && (b = x.y - c, T += b * b), x.z < -u ? (b = x.z + u, T += b * b) : x.z > u && (b = x.z - u, T += b * b), T }; var JEe = new h, ZEe = new h; Ai.computePlaneDistances = function (e, t, n, i) { l(i) || (i = new Dc); let o = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY, s = e.center, a = e.halfAxes, c = Q.getColumn(a, 0, JX), u = Q.getColumn(a, 1, ZX), f = Q.getColumn(a, 2, QX), d = h.add(c, u, JEe); h.add(d, f, d), h.add(d, s, d); let p = h.subtract(d, t, ZEe), g = h.dot(n, p); return o = Math.min(g, o), r = Math.max(g, r), h.add(s, c, d), h.add(d, u, d), h.subtract(d, f, d), h.subtract(d, t, p), g = h.dot(n, p), o = Math.min(g, o), r = Math.max(g, r), h.add(s, c, d), h.subtract(d, u, d), h.add(d, f, d), h.subtract(d, t, p), g = h.dot(n, p), o = Math.min(g, o), r = Math.max(g, r), h.add(s, c, d), h.subtract(d, u, d), h.subtract(d, f, d), h.subtract(d, t, p), g = h.dot(n, p), o = Math.min(g, o), r = Math.max(g, r), h.subtract(s, c, d), h.add(d, u, d), h.add(d, f, d), h.subtract(d, t, p), g = h.dot(n, p), o = Math.min(g, o), r = Math.max(g, r), h.subtract(s, c, d), h.add(d, u, d), h.subtract(d, f, d), h.subtract(d, t, p), g = h.dot(n, p), o = Math.min(g, o), r = Math.max(g, r), h.subtract(s, c, d), h.subtract(d, u, d), h.add(d, f, d), h.subtract(d, t, p), g = h.dot(n, p), o = Math.min(g, o), r = Math.max(g, r), h.subtract(s, c, d), h.subtract(d, u, d), h.subtract(d, f, d), h.subtract(d, t, p), g = h.dot(n, p), o = Math.min(g, o), r = Math.max(g, r), i.start = o, i.stop = r, i }; var QEe = new h, $Ee = new h, ebe = new h; Ai.computeCorners = function (e, t) { l(t) || (t = [new h, new h, new h, new h, new h, new h, new h, new h]); let n = e.center, i = e.halfAxes, o = Q.getColumn(i, 0, QEe), r = Q.getColumn(i, 1, $Ee), s = Q.getColumn(i, 2, ebe); return h.clone(n, t[0]), h.subtract(t[0], o, t[0]), h.subtract(t[0], r, t[0]), h.subtract(t[0], s, t[0]), h.clone(n, t[1]), h.subtract(t[1], o, t[1]), h.subtract(t[1], r, t[1]), h.add(t[1], s, t[1]), h.clone(n, t[2]), h.subtract(t[2], o, t[2]), h.add(t[2], r, t[2]), h.subtract(t[2], s, t[2]), h.clone(n, t[3]), h.subtract(t[3], o, t[3]), h.add(t[3], r, t[3]), h.add(t[3], s, t[3]), h.clone(n, t[4]), h.add(t[4], o, t[4]), h.subtract(t[4], r, t[4]), h.subtract(t[4], s, t[4]), h.clone(n, t[5]), h.add(t[5], o, t[5]), h.subtract(t[5], r, t[5]), h.add(t[5], s, t[5]), h.clone(n, t[6]), h.add(t[6], o, t[6]), h.add(t[6], r, t[6]), h.subtract(t[6], s, t[6]), h.clone(n, t[7]), h.add(t[7], o, t[7]), h.add(t[7], r, t[7]), h.add(t[7], s, t[7]), t }; var tbe = new Q; Ai.computeTransformation = function (e, t) { l(t) || (t = new F); let n = e.center, i = Q.multiplyByUniformScale(e.halfAxes, 2, tbe); return F.fromRotationTranslation(i, n, t) }; var nbe = new re; Ai.isOccluded = function (e, t) { let n = re.fromOrientedBoundingBox(e, nbe); return !t.isBoundingSphereVisible(n) }; Ai.prototype.intersectPlane = function (e) { return Ai.intersectPlane(this, e) }; Ai.prototype.distanceSquaredTo = function (e) { return Ai.distanceSquaredTo(this, e) }; Ai.prototype.computePlaneDistances = function (e, t, n) { return Ai.computePlaneDistances(this, e, t, n) }; Ai.prototype.computeCorners = function (e) { return Ai.computeCorners(this, e) }; Ai.prototype.computeTransformation = function (e) { return Ai.computeTransformation(this, e) }; Ai.prototype.isOccluded = function (e) { return Ai.isOccluded(this, e) }; Ai.equals = function (e, t) { return e === t || l(e) && l(t) && h.equals(e.center, t.center) && Q.equals(e.halfAxes, t.halfAxes) }; Ai.prototype.clone = function (e) { return Ai.clone(this, e) }; Ai.prototype.equals = function (e) { return Ai.equals(this, e) }; var di = Ai; var E1 = {}; E1.getHeight = function (e, t, n) { return (e - n) * t + n }; var ibe = new h; E1.getPosition = function (e, t, n, i, o) { let r = t.cartesianToCartographic(e, ibe), s = E1.getHeight(r.height, n, i); return h.fromRadians(r.longitude, r.latitude, s, t, o) }; var Ic = E1; var rr = { CULL: 1, OCCLUDE: 2, EXECUTE_IN_CLOSEST_FRUSTUM: 4, DEBUG_SHOW_BOUNDING_VOLUME: 8, CAST_SHADOWS: 16, RECEIVE_SHADOWS: 32, PICK_ONLY: 64, DEPTH_FOR_TRANSLUCENT_CLASSIFICATION: 128 }; function xb(e) { e = y(e, y.EMPTY_OBJECT), this._boundingVolume = e.boundingVolume, this._orientedBoundingBox = e.orientedBoundingBox, this._modelMatrix = e.modelMatrix, this._primitiveType = y(e.primitiveType, Oe.TRIANGLES), this._vertexArray = e.vertexArray, this._count = e.count, this._offset = y(e.offset, 0), this._instanceCount = y(e.instanceCount, 0), this._shaderProgram = e.shaderProgram, this._uniformMap = e.uniformMap, this._renderState = e.renderState, this._framebuffer = e.framebuffer, this._pass = e.pass, this._owner = e.owner, this._debugOverlappingFrustums = 0, this._pickId = e.pickId, this._flags = 0, this.cull = y(e.cull, !0), this.occlude = y(e.occlude, !0), this.executeInClosestFrustum = y(e.executeInClosestFrustum, !1), this.debugShowBoundingVolume = y(e.debugShowBoundingVolume, !1), this.castShadows = y(e.castShadows, !1), this.receiveShadows = y(e.receiveShadows, !1), this.pickOnly = y(e.pickOnly, !1), this.depthForTranslucentClassification = y(e.depthForTranslucentClassification, !1), this.dirty = !0, this.lastDirtyTime = 0, this.derivedCommands = {} } function _a(e, t) { return (e._flags & t) === t } function Lp(e, t, n) { n ? e._flags |= t : e._flags &= ~t } Object.defineProperties(xb.prototype, { boundingVolume: { get: function () { return this._boundingVolume }, set: function (e) { this._boundingVolume !== e && (this._boundingVolume = e, this.dirty = !0) } }, orientedBoundingBox: { get: function () { return this._orientedBoundingBox }, set: function (e) { this._orientedBoundingBox !== e && (this._orientedBoundingBox = e, this.dirty = !0) } }, cull: { get: function () { return _a(this, rr.CULL) }, set: function (e) { _a(this, rr.CULL) !== e && (Lp(this, rr.CULL, e), this.dirty = !0) } }, occlude: { get: function () { return _a(this, rr.OCCLUDE) }, set: function (e) { _a(this, rr.OCCLUDE) !== e && (Lp(this, rr.OCCLUDE, e), this.dirty = !0) } }, modelMatrix: { get: function () { return this._modelMatrix }, set: function (e) { this._modelMatrix !== e && (this._modelMatrix = e, this.dirty = !0) } }, primitiveType: { get: function () { return this._primitiveType }, set: function (e) { this._primitiveType !== e && (this._primitiveType = e, this.dirty = !0) } }, vertexArray: { get: function () { return this._vertexArray }, set: function (e) { this._vertexArray !== e && (this._vertexArray = e, this.dirty = !0) } }, count: { get: function () { return this._count }, set: function (e) { this._count !== e && (this._count = e, this.dirty = !0) } }, offset: { get: function () { return this._offset }, set: function (e) { this._offset !== e && (this._offset = e, this.dirty = !0) } }, instanceCount: { get: function () { return this._instanceCount }, set: function (e) { this._instanceCount !== e && (this._instanceCount = e, this.dirty = !0) } }, shaderProgram: { get: function () { return this._shaderProgram }, set: function (e) { this._shaderProgram !== e && (this._shaderProgram = e, this.dirty = !0) } }, castShadows: { get: function () { return _a(this, rr.CAST_SHADOWS) }, set: function (e) { _a(this, rr.CAST_SHADOWS) !== e && (Lp(this, rr.CAST_SHADOWS, e), this.dirty = !0) } }, receiveShadows: { get: function () { return _a(this, rr.RECEIVE_SHADOWS) }, set: function (e) { _a(this, rr.RECEIVE_SHADOWS) !== e && (Lp(this, rr.RECEIVE_SHADOWS, e), this.dirty = !0) } }, uniformMap: { get: function () { return this._uniformMap }, set: function (e) { this._uniformMap !== e && (this._uniformMap = e, this.dirty = !0) } }, renderState: { get: function () { return this._renderState }, set: function (e) { this._renderState !== e && (this._renderState = e, this.dirty = !0) } }, framebuffer: { get: function () { return this._framebuffer }, set: function (e) { this._framebuffer !== e && (this._framebuffer = e, this.dirty = !0) } }, pass: { get: function () { return this._pass }, set: function (e) { this._pass !== e && (this._pass = e, this.dirty = !0) } }, executeInClosestFrustum: { get: function () { return _a(this, rr.EXECUTE_IN_CLOSEST_FRUSTUM) }, set: function (e) { _a(this, rr.EXECUTE_IN_CLOSEST_FRUSTUM) !== e && (Lp(this, rr.EXECUTE_IN_CLOSEST_FRUSTUM, e), this.dirty = !0) } }, owner: { get: function () { return this._owner }, set: function (e) { this._owner !== e && (this._owner = e, this.dirty = !0) } }, debugShowBoundingVolume: { get: function () { return _a(this, rr.DEBUG_SHOW_BOUNDING_VOLUME) }, set: function (e) { _a(this, rr.DEBUG_SHOW_BOUNDING_VOLUME) !== e && (Lp(this, rr.DEBUG_SHOW_BOUNDING_VOLUME, e), this.dirty = !0) } }, debugOverlappingFrustums: { get: function () { return this._debugOverlappingFrustums }, set: function (e) { this._debugOverlappingFrustums !== e && (this._debugOverlappingFrustums = e, this.dirty = !0) } }, pickId: { get: function () { return this._pickId }, set: function (e) { this._pickId !== e && (this._pickId = e, this.dirty = !0) } }, pickOnly: { get: function () { return _a(this, rr.PICK_ONLY) }, set: function (e) { _a(this, rr.PICK_ONLY) !== e && (Lp(this, rr.PICK_ONLY, e), this.dirty = !0) } }, depthForTranslucentClassification: { get: function () { return _a(this, rr.DEPTH_FOR_TRANSLUCENT_CLASSIFICATION) }, set: function (e) { _a(this, rr.DEPTH_FOR_TRANSLUCENT_CLASSIFICATION) !== e && (Lp(this, rr.DEPTH_FOR_TRANSLUCENT_CLASSIFICATION, e), this.dirty = !0) } } }); xb.shallowClone = function (e, t) { if (!!l(e)) return l(t) || (t = new xb), t._boundingVolume = e._boundingVolume, t._orientedBoundingBox = e._orientedBoundingBox, t._modelMatrix = e._modelMatrix, t._primitiveType = e._primitiveType, t._vertexArray = e._vertexArray, t._count = e._count, t._offset = e._offset, t._instanceCount = e._instanceCount, t._shaderProgram = e._shaderProgram, t._uniformMap = e._uniformMap, t._renderState = e._renderState, t._framebuffer = e._framebuffer, t._pass = e._pass, t._owner = e._owner, t._debugOverlappingFrustums = e._debugOverlappingFrustums, t._pickId = e._pickId, t._flags = e._flags, t.dirty = !0, t.lastDirtyTime = 0, t }; xb.prototype.execute = function (e, t) { e.draw(this, t) }; var $e = xb; var obe = { ENVIRONMENT: 0, COMPUTE: 1, GLOBE: 2, TERRAIN_CLASSIFICATION: 3, CESIUM_3D_TILE: 4, CESIUM_3D_TILE_CLASSIFICATION: 5, CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW: 6, OPAQUE: 7, TRANSLUCENT: 8, OVERLAY: 9, NUMBER_OF_PASSES: 10 }, xe = Object.freeze(obe); var b1 = { CLOCKWISE: te.CW, COUNTER_CLOCKWISE: te.CCW }; b1.validate = function (e) { return e === b1.CLOCKWISE || e === b1.COUNTER_CLOCKWISE }; var Kr = Object.freeze(b1); function $X(e) { if (typeof e != "object" || e === null) return e; let t, n = Object.keys(e); for (let i = 0; i < n.length; i++)t = n[i], e.hasOwnProperty(t) && t !== "_applyFunctions" && (e[t] = $X(e[t])); return Object.freeze(e) } var eK = $X; function Dd(e) { let t = y(e, y.EMPTY_OBJECT), n = y(t.cull, y.EMPTY_OBJECT), i = y(t.polygonOffset, y.EMPTY_OBJECT), o = y(t.scissorTest, y.EMPTY_OBJECT), r = y(o.rectangle, y.EMPTY_OBJECT), s = y(t.depthRange, y.EMPTY_OBJECT), a = y(t.depthTest, y.EMPTY_OBJECT), c = y(t.colorMask, y.EMPTY_OBJECT), u = y(t.blending, y.EMPTY_OBJECT), f = y(u.color, y.EMPTY_OBJECT), d = y(t.stencilTest, y.EMPTY_OBJECT), p = y(d.frontOperation, y.EMPTY_OBJECT), g = y(d.backOperation, y.EMPTY_OBJECT), m = y(t.sampleCoverage, y.EMPTY_OBJECT), A = t.viewport; this.frontFace = y(t.frontFace, Kr.COUNTER_CLOCKWISE), this.cull = { enabled: y(n.enabled, !1), face: y(n.face, te.BACK) }, this.lineWidth = y(t.lineWidth, 1), this.polygonOffset = { enabled: y(i.enabled, !1), factor: y(i.factor, 0), units: y(i.units, 0) }, this.scissorTest = { enabled: y(o.enabled, !1), rectangle: Ge.clone(r) }, this.depthRange = { near: y(s.near, 0), far: y(s.far, 1) }, this.depthTest = { enabled: y(a.enabled, !1), func: y(a.func, te.LESS) }, this.colorMask = { red: y(c.red, !0), green: y(c.green, !0), blue: y(c.blue, !0), alpha: y(c.alpha, !0) }, this.depthMask = y(t.depthMask, !0), this.stencilMask = y(t.stencilMask, -1), this.blending = { enabled: y(u.enabled, !1), color: new U(y(f.red, 0), y(f.green, 0), y(f.blue, 0), y(f.alpha, 0)), equationRgb: y(u.equationRgb, te.FUNC_ADD), equationAlpha: y(u.equationAlpha, te.FUNC_ADD), functionSourceRgb: y(u.functionSourceRgb, te.ONE), functionSourceAlpha: y(u.functionSourceAlpha, te.ONE), functionDestinationRgb: y(u.functionDestinationRgb, te.ZERO), functionDestinationAlpha: y(u.functionDestinationAlpha, te.ZERO) }, this.stencilTest = { enabled: y(d.enabled, !1), frontFunction: y(d.frontFunction, te.ALWAYS), backFunction: y(d.backFunction, te.ALWAYS), reference: y(d.reference, 0), mask: y(d.mask, -1), frontOperation: { fail: y(p.fail, te.KEEP), zFail: y(p.zFail, te.KEEP), zPass: y(p.zPass, te.KEEP) }, backOperation: { fail: y(g.fail, te.KEEP), zFail: y(g.zFail, te.KEEP), zPass: y(g.zPass, te.KEEP) } }, this.sampleCoverage = { enabled: y(m.enabled, !1), value: y(m.value, 1), invert: y(m.invert, !1) }, this.viewport = l(A) ? new Ge(A.x, A.y, A.width, A.height) : void 0, this.id = 0, this._applyFunctions = [] } var rbe = 0, wd = {}; Dd.fromCache = function (e) { let t = JSON.stringify(e), n = wd[t]; if (l(n)) return ++n.referenceCount, n.state; let i = new Dd(e), o = JSON.stringify(i); return n = wd[o], l(n) || (i.id = rbe++, n = { referenceCount: 0, state: i }, wd[o] = n), ++n.referenceCount, wd[t] = { referenceCount: 1, state: n.state }, n.state }; Dd.removeFromCache = function (e) { let t = new Dd(e), n = JSON.stringify(t), i = wd[n], o = JSON.stringify(e), r = wd[o]; l(r) && (--r.referenceCount, r.referenceCount === 0 && (delete wd[o], l(i) && --i.referenceCount)), l(i) && i.referenceCount === 0 && delete wd[n] }; Dd.getCache = function () { return wd }; Dd.clearCache = function () { wd = {} }; function p0(e, t, n) { n ? e.enable(t) : e.disable(t) } function tK(e, t) { e.frontFace(t.frontFace) } function nK(e, t) { let n = t.cull, i = n.enabled; p0(e, e.CULL_FACE, i), i && e.cullFace(n.face) } function iK(e, t) { e.lineWidth(t.lineWidth) } function oK(e, t) { let n = t.polygonOffset, i = n.enabled; p0(e, e.POLYGON_OFFSET_FILL, i), i && e.polygonOffset(n.factor, n.units) } function rK(e, t, n) { let i = t.scissorTest, o = l(n.scissorTest) ? n.scissorTest.enabled : i.enabled; if (p0(e, e.SCISSOR_TEST, o), o) { let r = l(n.scissorTest) ? n.scissorTest.rectangle : i.rectangle; e.scissor(r.x, r.y, r.width, r.height) } } function sK(e, t) { let n = t.depthRange; e.depthRange(n.near, n.far) } function aK(e, t) { let n = t.depthTest, i = n.enabled; p0(e, e.DEPTH_TEST, i), i && e.depthFunc(n.func) } function cK(e, t) { let n = t.colorMask; e.colorMask(n.red, n.green, n.blue, n.alpha) } function lK(e, t) { e.depthMask(t.depthMask) } function uK(e, t) { e.stencilMask(t.stencilMask) } function sbe(e, t) { e.blendColor(t.red, t.green, t.blue, t.alpha) } function fK(e, t, n) { let i = t.blending, o = l(n.blendingEnabled) ? n.blendingEnabled : i.enabled; p0(e, e.BLEND, o), o && (sbe(e, i.color), e.blendEquationSeparate(i.equationRgb, i.equationAlpha), e.blendFuncSeparate(i.functionSourceRgb, i.functionDestinationRgb, i.functionSourceAlpha, i.functionDestinationAlpha)) } function dK(e, t) { let n = t.stencilTest, i = n.enabled; if (p0(e, e.STENCIL_TEST, i), i) { let o = n.frontFunction, r = n.backFunction, s = n.reference, a = n.mask; e.stencilFunc(o, s, a), e.stencilFuncSeparate(e.BACK, r, s, a), e.stencilFuncSeparate(e.FRONT, o, s, a); let c = n.frontOperation, u = c.fail, f = c.zFail, d = c.zPass; e.stencilOpSeparate(e.FRONT, u, f, d); let p = n.backOperation, g = p.fail, m = p.zFail, A = p.zPass; e.stencilOpSeparate(e.BACK, g, m, A) } } function hK(e, t) { let n = t.sampleCoverage, i = n.enabled; p0(e, e.SAMPLE_COVERAGE, i), i && e.sampleCoverage(n.value, n.invert) } var abe = new Ge; function mK(e, t, n) { let i = y(t.viewport, n.viewport); l(i) || (i = abe, i.width = n.context.drawingBufferWidth, i.height = n.context.drawingBufferHeight), n.context.uniformState.viewport = i, e.viewport(i.x, i.y, i.width, i.height) } Dd.apply = function (e, t, n) { tK(e, t), nK(e, t), iK(e, t), oK(e, t), sK(e, t), aK(e, t), cK(e, t), lK(e, t), uK(e, t), dK(e, t), hK(e, t), rK(e, t, n), fK(e, t, n), mK(e, t, n) }; function cbe(e, t) { let n = []; return e.frontFace !== t.frontFace && n.push(tK), (e.cull.enabled !== t.cull.enabled || e.cull.face !== t.cull.face) && n.push(nK), e.lineWidth !== t.lineWidth && n.push(iK), (e.polygonOffset.enabled !== t.polygonOffset.enabled || e.polygonOffset.factor !== t.polygonOffset.factor || e.polygonOffset.units !== t.polygonOffset.units) && n.push(oK), (e.depthRange.near !== t.depthRange.near || e.depthRange.far !== t.depthRange.far) && n.push(sK), (e.depthTest.enabled !== t.depthTest.enabled || e.depthTest.func !== t.depthTest.func) && n.push(aK), (e.colorMask.red !== t.colorMask.red || e.colorMask.green !== t.colorMask.green || e.colorMask.blue !== t.colorMask.blue || e.colorMask.alpha !== t.colorMask.alpha) && n.push(cK), e.depthMask !== t.depthMask && n.push(lK), e.stencilMask !== t.stencilMask && n.push(uK), (e.stencilTest.enabled !== t.stencilTest.enabled || e.stencilTest.frontFunction !== t.stencilTest.frontFunction || e.stencilTest.backFunction !== t.stencilTest.backFunction || e.stencilTest.reference !== t.stencilTest.reference || e.stencilTest.mask !== t.stencilTest.mask || e.stencilTest.frontOperation.fail !== t.stencilTest.frontOperation.fail || e.stencilTest.frontOperation.zFail !== t.stencilTest.frontOperation.zFail || e.stencilTest.backOperation.fail !== t.stencilTest.backOperation.fail || e.stencilTest.backOperation.zFail !== t.stencilTest.backOperation.zFail || e.stencilTest.backOperation.zPass !== t.stencilTest.backOperation.zPass) && n.push(dK), (e.sampleCoverage.enabled !== t.sampleCoverage.enabled || e.sampleCoverage.value !== t.sampleCoverage.value || e.sampleCoverage.invert !== t.sampleCoverage.invert) && n.push(hK), n } Dd.partialApply = function (e, t, n, i, o, r) { if (t !== n) { let f = n._applyFunctions[t.id]; l(f) || (f = cbe(t, n), n._applyFunctions[t.id] = f); let d = f.length; for (let p = 0; p < d; ++p)f[p](e, n) } let s = l(i.scissorTest) ? i.scissorTest : t.scissorTest, a = l(o.scissorTest) ? o.scissorTest : n.scissorTest; (s !== a || r) && rK(e, n, o); let c = l(i.blendingEnabled) ? i.blendingEnabled : t.blending.enabled, u = l(o.blendingEnabled) ? o.blendingEnabled : n.blending.enabled; (c !== u || u && t.blending !== n.blending) && fK(e, n, o), (t !== n || i !== o || i.context !== o.context) && mK(e, n, o) }; Dd.getState = function (e) { return { frontFace: e.frontFace, cull: { enabled: e.cull.enabled, face: e.cull.face }, lineWidth: e.lineWidth, polygonOffset: { enabled: e.polygonOffset.enabled, factor: e.polygonOffset.factor, units: e.polygonOffset.units }, scissorTest: { enabled: e.scissorTest.enabled, rectangle: Ge.clone(e.scissorTest.rectangle) }, depthRange: { near: e.depthRange.near, far: e.depthRange.far }, depthTest: { enabled: e.depthTest.enabled, func: e.depthTest.func }, colorMask: { red: e.colorMask.red, green: e.colorMask.green, blue: e.colorMask.blue, alpha: e.colorMask.alpha }, depthMask: e.depthMask, stencilMask: e.stencilMask, blending: { enabled: e.blending.enabled, color: U.clone(e.blending.color), equationRgb: e.blending.equationRgb, equationAlpha: e.blending.equationAlpha, functionSourceRgb: e.blending.functionSourceRgb, functionSourceAlpha: e.blending.functionSourceAlpha, functionDestinationRgb: e.blending.functionDestinationRgb, functionDestinationAlpha: e.blending.functionDestinationAlpha }, stencilTest: { enabled: e.stencilTest.enabled, frontFunction: e.stencilTest.frontFunction, backFunction: e.stencilTest.backFunction, reference: e.stencilTest.reference, mask: e.stencilTest.mask, frontOperation: { fail: e.stencilTest.frontOperation.fail, zFail: e.stencilTest.frontOperation.zFail, zPass: e.stencilTest.frontOperation.zPass }, backOperation: { fail: e.stencilTest.backOperation.fail, zFail: e.stencilTest.backOperation.zFail, zPass: e.stencilTest.backOperation.zPass } }, sampleCoverage: { enabled: e.sampleCoverage.enabled, value: e.sampleCoverage.value, invert: e.sampleCoverage.invert }, viewport: l(e.viewport) ? Ge.clone(e.viewport) : void 0 } }; var Ve = Dd; var lbe = new h; function Vt(e) { this._size = e.size, this._datatype = e.datatype, this.getValue = e.getValue } var As = {}; As[te.FLOAT] = "float"; As[te.FLOAT_VEC2] = "vec2"; As[te.FLOAT_VEC3] = "vec3"; As[te.FLOAT_VEC4] = "vec4"; As[te.INT] = "int"; As[te.INT_VEC2] = "ivec2"; As[te.INT_VEC3] = "ivec3"; As[te.INT_VEC4] = "ivec4"; As[te.BOOL] = "bool"; As[te.BOOL_VEC2] = "bvec2"; As[te.BOOL_VEC3] = "bvec3"; As[te.BOOL_VEC4] = "bvec4"; As[te.FLOAT_MAT2] = "mat2"; As[te.FLOAT_MAT3] = "mat3"; As[te.FLOAT_MAT4] = "mat4"; As[te.SAMPLER_2D] = "sampler2D"; As[te.SAMPLER_CUBE] = "samplerCube"; Vt.prototype.getDeclaration = function (e) { let t = `uniform ${As[this._datatype]} ${e}`, n = this._size; return n === 1 ? t += ";" : t += `[${n.toString()}];`, t }; var ube = { czm_viewport: new Vt({ size: 1, datatype: te.FLOAT_VEC4, getValue: function (e) { return e.viewportCartesian4 } }), czm_viewportOrthographic: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.viewportOrthographic } }), czm_viewportTransformation: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.viewportTransformation } }), czm_globeDepthTexture: new Vt({ size: 1, datatype: te.SAMPLER_2D, getValue: function (e) { return e.globeDepthTexture } }), czm_model: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.model } }), czm_inverseModel: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.inverseModel } }), czm_view: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.view } }), czm_view3D: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.view3D } }), czm_viewRotation: new Vt({ size: 1, datatype: te.FLOAT_MAT3, getValue: function (e) { return e.viewRotation } }), czm_viewRotation3D: new Vt({ size: 1, datatype: te.FLOAT_MAT3, getValue: function (e) { return e.viewRotation3D } }), czm_inverseView: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.inverseView } }), czm_inverseView3D: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.inverseView3D } }), czm_inverseViewRotation: new Vt({ size: 1, datatype: te.FLOAT_MAT3, getValue: function (e) { return e.inverseViewRotation } }), czm_inverseViewRotation3D: new Vt({ size: 1, datatype: te.FLOAT_MAT3, getValue: function (e) { return e.inverseViewRotation3D } }), czm_projection: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.projection } }), czm_inverseProjection: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.inverseProjection } }), czm_infiniteProjection: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.infiniteProjection } }), czm_modelView: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.modelView } }), czm_modelView3D: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.modelView3D } }), czm_modelViewRelativeToEye: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.modelViewRelativeToEye } }), czm_inverseModelView: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.inverseModelView } }), czm_inverseModelView3D: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.inverseModelView3D } }), czm_viewProjection: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.viewProjection } }), czm_inverseViewProjection: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.inverseViewProjection } }), czm_modelViewProjection: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.modelViewProjection } }), czm_inverseModelViewProjection: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.inverseModelViewProjection } }), czm_modelViewProjectionRelativeToEye: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.modelViewProjectionRelativeToEye } }), czm_modelViewInfiniteProjection: new Vt({ size: 1, datatype: te.FLOAT_MAT4, getValue: function (e) { return e.modelViewInfiniteProjection } }), czm_orthographicIn3D: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.orthographicIn3D ? 1 : 0 } }), czm_normal: new Vt({ size: 1, datatype: te.FLOAT_MAT3, getValue: function (e) { return e.normal } }), czm_normal3D: new Vt({ size: 1, datatype: te.FLOAT_MAT3, getValue: function (e) { return e.normal3D } }), czm_inverseNormal: new Vt({ size: 1, datatype: te.FLOAT_MAT3, getValue: function (e) { return e.inverseNormal } }), czm_inverseNormal3D: new Vt({ size: 1, datatype: te.FLOAT_MAT3, getValue: function (e) { return e.inverseNormal3D } }), czm_eyeHeight: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.eyeHeight } }), czm_eyeHeight2D: new Vt({ size: 1, datatype: te.FLOAT_VEC2, getValue: function (e) { return e.eyeHeight2D } }), czm_entireFrustum: new Vt({ size: 1, datatype: te.FLOAT_VEC2, getValue: function (e) { return e.entireFrustum } }), czm_currentFrustum: new Vt({ size: 1, datatype: te.FLOAT_VEC2, getValue: function (e) { return e.currentFrustum } }), czm_frustumPlanes: new Vt({ size: 1, datatype: te.FLOAT_VEC4, getValue: function (e) { return e.frustumPlanes } }), czm_farDepthFromNearPlusOne: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.farDepthFromNearPlusOne } }), czm_log2FarDepthFromNearPlusOne: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.log2FarDepthFromNearPlusOne } }), czm_oneOverLog2FarDepthFromNearPlusOne: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.oneOverLog2FarDepthFromNearPlusOne } }), czm_sunPositionWC: new Vt({ size: 1, datatype: te.FLOAT_VEC3, getValue: function (e) { return e.sunPositionWC } }), czm_sunPositionColumbusView: new Vt({ size: 1, datatype: te.FLOAT_VEC3, getValue: function (e) { return e.sunPositionColumbusView } }), czm_sunDirectionEC: new Vt({ size: 1, datatype: te.FLOAT_VEC3, getValue: function (e) { return e.sunDirectionEC } }), czm_sunDirectionWC: new Vt({ size: 1, datatype: te.FLOAT_VEC3, getValue: function (e) { return e.sunDirectionWC } }), czm_moonDirectionEC: new Vt({ size: 1, datatype: te.FLOAT_VEC3, getValue: function (e) { return e.moonDirectionEC } }), czm_lightDirectionEC: new Vt({ size: 1, datatype: te.FLOAT_VEC3, getValue: function (e) { return e.lightDirectionEC } }), czm_lightDirectionWC: new Vt({ size: 1, datatype: te.FLOAT_VEC3, getValue: function (e) { return e.lightDirectionWC } }), czm_lightColor: new Vt({ size: 1, datatype: te.FLOAT_VEC3, getValue: function (e) { return e.lightColor } }), czm_lightColorHdr: new Vt({ size: 1, datatype: te.FLOAT_VEC3, getValue: function (e) { return e.lightColorHdr } }), czm_encodedCameraPositionMCHigh: new Vt({ size: 1, datatype: te.FLOAT_VEC3, getValue: function (e) { return e.encodedCameraPositionMCHigh } }), czm_encodedCameraPositionMCLow: new Vt({ size: 1, datatype: te.FLOAT_VEC3, getValue: function (e) { return e.encodedCameraPositionMCLow } }), czm_viewerPositionWC: new Vt({ size: 1, datatype: te.FLOAT_VEC3, getValue: function (e) { return F.getTranslation(e.inverseView, lbe) } }), czm_frameNumber: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.frameState.frameNumber } }), czm_morphTime: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.frameState.morphTime } }), czm_sceneMode: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.frameState.mode } }), czm_pass: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.pass } }), czm_backgroundColor: new Vt({ size: 1, datatype: te.FLOAT_VEC4, getValue: function (e) { return e.backgroundColor } }), czm_brdfLut: new Vt({ size: 1, datatype: te.SAMPLER_2D, getValue: function (e) { return e.brdfLut } }), czm_environmentMap: new Vt({ size: 1, datatype: te.SAMPLER_CUBE, getValue: function (e) { return e.environmentMap } }), czm_specularEnvironmentMaps: new Vt({ size: 1, datatype: te.SAMPLER_2D, getValue: function (e) { return e.specularEnvironmentMaps } }), czm_specularEnvironmentMapSize: new Vt({ size: 1, datatype: te.FLOAT_VEC2, getValue: function (e) { return e.specularEnvironmentMapsDimensions } }), czm_specularEnvironmentMapsMaximumLOD: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.specularEnvironmentMapsMaximumLOD } }), czm_sphericalHarmonicCoefficients: new Vt({ size: 9, datatype: te.FLOAT_VEC3, getValue: function (e) { return e.sphericalHarmonicCoefficients } }), czm_temeToPseudoFixed: new Vt({ size: 1, datatype: te.FLOAT_MAT3, getValue: function (e) { return e.temeToPseudoFixedMatrix } }), czm_pixelRatio: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.pixelRatio } }), czm_fogDensity: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.fogDensity } }), czm_splitPosition: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.splitPosition } }), czm_geometricToleranceOverMeter: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.geometricToleranceOverMeter } }), czm_minimumDisableDepthTestDistance: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.minimumDisableDepthTestDistance } }), czm_invertClassificationColor: new Vt({ size: 1, datatype: te.FLOAT_VEC4, getValue: function (e) { return e.invertClassificationColor } }), czm_gamma: new Vt({ size: 1, datatype: te.FLOAT, getValue: function (e) { return e.gamma } }), czm_ellipsoidRadii: new Vt({ size: 1, datatype: te.FLOAT_VEC3, getValue: function (e) { return e.ellipsoid.radii } }), czm_ellipsoidInverseRadii: new Vt({ size: 1, datatype: te.FLOAT_VEC3, getValue: function (e) { return e.ellipsoid.oneOverRadii } }) }, Fp = ube; function fbe(e, t, n, i) { switch (t.type) { case e.FLOAT: return new pK(e, t, n, i); case e.FLOAT_VEC2: return new _K(e, t, n, i); case e.FLOAT_VEC3: return new gK(e, t, n, i); case e.FLOAT_VEC4: return new yK(e, t, n, i); case e.SAMPLER_2D: case e.SAMPLER_CUBE: return new jH(e, t, n, i); case e.INT: case e.BOOL: return new AK(e, t, n, i); case e.INT_VEC2: case e.BOOL_VEC2: return new CK(e, t, n, i); case e.INT_VEC3: case e.BOOL_VEC3: return new xK(e, t, n, i); case e.INT_VEC4: case e.BOOL_VEC4: return new TK(e, t, n, i); case e.FLOAT_MAT2: return new EK(e, t, n, i); case e.FLOAT_MAT3: return new bK(e, t, n, i); case e.FLOAT_MAT4: return new SK(e, t, n, i); default: throw new fe(`Unrecognized uniform type: ${t.type} for uniform "${n}".`) } } function pK(e, t, n, i) { this.name = n, this.value = void 0, this._value = 0, this._gl = e, this._location = i } pK.prototype.set = function () { this.value !== this._value && (this._value = this.value, this._gl.uniform1f(this._location, this.value)) }; function _K(e, t, n, i) { this.name = n, this.value = void 0, this._value = new H, this._gl = e, this._location = i } _K.prototype.set = function () { let e = this.value; H.equals(e, this._value) || (H.clone(e, this._value), this._gl.uniform2f(this._location, e.x, e.y)) }; function gK(e, t, n, i) { this.name = n, this.value = void 0, this._value = void 0, this._gl = e, this._location = i } gK.prototype.set = function () { let e = this.value; l(e.red) ? U.equals(e, this._value) || (this._value = U.clone(e, this._value), this._gl.uniform3f(this._location, e.red, e.green, e.blue)) : l(e.x) && (h.equals(e, this._value) || (this._value = h.clone(e, this._value), this._gl.uniform3f(this._location, e.x, e.y, e.z))) }; function yK(e, t, n, i) { this.name = n, this.value = void 0, this._value = void 0, this._gl = e, this._location = i } yK.prototype.set = function () { let e = this.value; l(e.red) ? U.equals(e, this._value) || (this._value = U.clone(e, this._value), this._gl.uniform4f(this._location, e.red, e.green, e.blue, e.alpha)) : l(e.x) && (se.equals(e, this._value) || (this._value = se.clone(e, this._value), this._gl.uniform4f(this._location, e.x, e.y, e.z, e.w))) }; function jH(e, t, n, i) { this.name = n, this.value = void 0, this._gl = e, this._location = i, this.textureUnitIndex = void 0 } jH.prototype.set = function () { let e = this._gl; e.activeTexture(e.TEXTURE0 + this.textureUnitIndex); let t = this.value; e.bindTexture(t._target, t._texture) }; jH.prototype._setSampler = function (e) { return this.textureUnitIndex = e, this._gl.uniform1i(this._location, e), e + 1 }; function AK(e, t, n, i) { this.name = n, this.value = void 0, this._value = 0, this._gl = e, this._location = i } AK.prototype.set = function () { this.value !== this._value && (this._value = this.value, this._gl.uniform1i(this._location, this.value)) }; function CK(e, t, n, i) { this.name = n, this.value = void 0, this._value = new H, this._gl = e, this._location = i } CK.prototype.set = function () { let e = this.value; H.equals(e, this._value) || (H.clone(e, this._value), this._gl.uniform2i(this._location, e.x, e.y)) }; function xK(e, t, n, i) { this.name = n, this.value = void 0, this._value = new h, this._gl = e, this._location = i } xK.prototype.set = function () { let e = this.value; h.equals(e, this._value) || (h.clone(e, this._value), this._gl.uniform3i(this._location, e.x, e.y, e.z)) }; function TK(e, t, n, i) { this.name = n, this.value = void 0, this._value = new se, this._gl = e, this._location = i } TK.prototype.set = function () { let e = this.value; se.equals(e, this._value) || (se.clone(e, this._value), this._gl.uniform4i(this._location, e.x, e.y, e.z, e.w)) }; var dbe = new Float32Array(4); function EK(e, t, n, i) { this.name = n, this.value = void 0, this._value = new qi, this._gl = e, this._location = i } EK.prototype.set = function () { if (!qi.equalsArray(this.value, this._value, 0)) { qi.clone(this.value, this._value); let e = qi.toArray(this.value, dbe); this._gl.uniformMatrix2fv(this._location, !1, e) } }; var hbe = new Float32Array(9); function bK(e, t, n, i) { this.name = n, this.value = void 0, this._value = new Q, this._gl = e, this._location = i } bK.prototype.set = function () { if (!Q.equalsArray(this.value, this._value, 0)) { Q.clone(this.value, this._value); let e = Q.toArray(this.value, hbe); this._gl.uniformMatrix3fv(this._location, !1, e) } }; var mbe = new Float32Array(16); function SK(e, t, n, i) { this.name = n, this.value = void 0, this._value = new F, this._gl = e, this._location = i } SK.prototype.set = function () { if (!F.equalsArray(this.value, this._value, 0)) { F.clone(this.value, this._value); let e = F.toArray(this.value, mbe); this._gl.uniformMatrix4fv(this._location, !1, e) } }; var S1 = fbe; function pbe(e, t, n, i) { switch (t.type) { case e.FLOAT: return new wK(e, t, n, i); case e.FLOAT_VEC2: return new DK(e, t, n, i); case e.FLOAT_VEC3: return new vK(e, t, n, i); case e.FLOAT_VEC4: return new PK(e, t, n, i); case e.SAMPLER_2D: case e.SAMPLER_CUBE: return new qH(e, t, n, i); case e.INT: case e.BOOL: return new IK(e, t, n, i); case e.INT_VEC2: case e.BOOL_VEC2: return new OK(e, t, n, i); case e.INT_VEC3: case e.BOOL_VEC3: return new BK(e, t, n, i); case e.INT_VEC4: case e.BOOL_VEC4: return new RK(e, t, n, i); case e.FLOAT_MAT2: return new MK(e, t, n, i); case e.FLOAT_MAT3: return new LK(e, t, n, i); case e.FLOAT_MAT4: return new FK(e, t, n, i); default: throw new fe(`Unrecognized uniform type: ${t.type} for uniform "${n}".`) } } function wK(e, t, n, i) { let o = i.length; this.name = n, this.value = new Array(o), this._value = new Float32Array(o), this._gl = e, this._location = i[0] } wK.prototype.set = function () { let e = this.value, t = e.length, n = this._value, i = !1; for (let o = 0; o < t; ++o) { let r = e[o]; r !== n[o] && (n[o] = r, i = !0) } i && this._gl.uniform1fv(this._location, n) }; function DK(e, t, n, i) { let o = i.length; this.name = n, this.value = new Array(o), this._value = new Float32Array(o * 2), this._gl = e, this._location = i[0] } DK.prototype.set = function () { let e = this.value, t = e.length, n = this._value, i = !1, o = 0; for (let r = 0; r < t; ++r) { let s = e[r]; H.equalsArray(s, n, o) || (H.pack(s, n, o), i = !0), o += 2 } i && this._gl.uniform2fv(this._location, n) }; function vK(e, t, n, i) { let o = i.length; this.name = n, this.value = new Array(o), this._value = new Float32Array(o * 3), this._gl = e, this._location = i[0] } vK.prototype.set = function () { let e = this.value, t = e.length, n = this._value, i = !1, o = 0; for (let r = 0; r < t; ++r) { let s = e[r]; l(s.red) ? (s.red !== n[o] || s.green !== n[o + 1] || s.blue !== n[o + 2]) && (n[o] = s.red, n[o + 1] = s.green, n[o + 2] = s.blue, i = !0) : l(s.x) && (h.equalsArray(s, n, o) || (h.pack(s, n, o), i = !0)), o += 3 } i && this._gl.uniform3fv(this._location, n) }; function PK(e, t, n, i) { let o = i.length; this.name = n, this.value = new Array(o), this._value = new Float32Array(o * 4), this._gl = e, this._location = i[0] } PK.prototype.set = function () { let e = this.value, t = e.length, n = this._value, i = !1, o = 0; for (let r = 0; r < t; ++r) { let s = e[r]; l(s.red) ? U.equalsArray(s, n, o) || (U.pack(s, n, o), i = !0) : l(s.x) && (se.equalsArray(s, n, o) || (se.pack(s, n, o), i = !0)), o += 4 } i && this._gl.uniform4fv(this._location, n) }; function qH(e, t, n, i) { let o = i.length; this.name = n, this.value = new Array(o), this._value = new Float32Array(o), this._gl = e, this._locations = i, this.textureUnitIndex = void 0 } qH.prototype.set = function () { let e = this._gl, t = e.TEXTURE0 + this.textureUnitIndex, n = this.value, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; e.activeTexture(t + o), e.bindTexture(r._target, r._texture) } }; qH.prototype._setSampler = function (e) { this.textureUnitIndex = e; let t = this._locations, n = t.length; for (let i = 0; i < n; ++i) { let o = e + i; this._gl.uniform1i(t[i], o) } return e + n }; function IK(e, t, n, i) { let o = i.length; this.name = n, this.value = new Array(o), this._value = new Int32Array(o), this._gl = e, this._location = i[0] } IK.prototype.set = function () { let e = this.value, t = e.length, n = this._value, i = !1; for (let o = 0; o < t; ++o) { let r = e[o]; r !== n[o] && (n[o] = r, i = !0) } i && this._gl.uniform1iv(this._location, n) }; function OK(e, t, n, i) { let o = i.length; this.name = n, this.value = new Array(o), this._value = new Int32Array(o * 2), this._gl = e, this._location = i[0] } OK.prototype.set = function () { let e = this.value, t = e.length, n = this._value, i = !1, o = 0; for (let r = 0; r < t; ++r) { let s = e[r]; H.equalsArray(s, n, o) || (H.pack(s, n, o), i = !0), o += 2 } i && this._gl.uniform2iv(this._location, n) }; function BK(e, t, n, i) { let o = i.length; this.name = n, this.value = new Array(o), this._value = new Int32Array(o * 3), this._gl = e, this._location = i[0] } BK.prototype.set = function () { let e = this.value, t = e.length, n = this._value, i = !1, o = 0; for (let r = 0; r < t; ++r) { let s = e[r]; h.equalsArray(s, n, o) || (h.pack(s, n, o), i = !0), o += 3 } i && this._gl.uniform3iv(this._location, n) }; function RK(e, t, n, i) { let o = i.length; this.name = n, this.value = new Array(o), this._value = new Int32Array(o * 4), this._gl = e, this._location = i[0] } RK.prototype.set = function () { let e = this.value, t = e.length, n = this._value, i = !1, o = 0; for (let r = 0; r < t; ++r) { let s = e[r]; se.equalsArray(s, n, o) || (se.pack(s, n, o), i = !0), o += 4 } i && this._gl.uniform4iv(this._location, n) }; function MK(e, t, n, i) { let o = i.length; this.name = n, this.value = new Array(o), this._value = new Float32Array(o * 4), this._gl = e, this._location = i[0] } MK.prototype.set = function () { let e = this.value, t = e.length, n = this._value, i = !1, o = 0; for (let r = 0; r < t; ++r) { let s = e[r]; qi.equalsArray(s, n, o) || (qi.pack(s, n, o), i = !0), o += 4 } i && this._gl.uniformMatrix2fv(this._location, !1, n) }; function LK(e, t, n, i) { let o = i.length; this.name = n, this.value = new Array(o), this._value = new Float32Array(o * 9), this._gl = e, this._location = i[0] } LK.prototype.set = function () { let e = this.value, t = e.length, n = this._value, i = !1, o = 0; for (let r = 0; r < t; ++r) { let s = e[r]; Q.equalsArray(s, n, o) || (Q.pack(s, n, o), i = !0), o += 9 } i && this._gl.uniformMatrix3fv(this._location, !1, n) }; function FK(e, t, n, i) { let o = i.length; this.name = n, this.value = new Array(o), this._value = new Float32Array(o * 16), this._gl = e, this._location = i[0] } FK.prototype.set = function () { let e = this.value, t = e.length, n = this._value, i = !1, o = 0; for (let r = 0; r < t; ++r) { let s = e[r]; F.equalsArray(s, n, o) || (F.pack(s, n, o), i = !0), o += 16 } i && this._gl.uniformMatrix4fv(this._location, !1, n) }; var w1 = pbe; var _be = 0; function tm(e) { let t = e.vertexShaderText, n = e.fragmentShaderText; typeof spector < "u" && (t = t.replace(/^#line/gm, "//#line"), n = n.replace(/^#line/gm, "//#line")); let i = gbe(t, n); this._gl = e.gl, this._logShaderCompilation = e.logShaderCompilation, this._debugShaders = e.debugShaders, this._attributeLocations = e.attributeLocations, this._program = void 0, this._numberOfVertexAttributes = void 0, this._vertexAttributes = void 0, this._uniformsByName = void 0, this._uniforms = void 0, this._automaticUniforms = void 0, this._manualUniforms = void 0, this._duplicateUniformNames = i.duplicateUniformNames, this._cachedShader = void 0, this.maximumTextureUnitIndex = void 0, this._vertexShaderSource = e.vertexShaderSource, this._vertexShaderText = e.vertexShaderText, this._fragmentShaderSource = e.fragmentShaderSource, this._fragmentShaderText = i.fragmentShaderText, this.id = _be++ } tm.fromCache = function (e) { return e = y(e, y.EMPTY_OBJECT), e.context.shaderCache.getShaderProgram(e) }; tm.replaceCache = function (e) { return e = y(e, y.EMPTY_OBJECT), e.context.shaderCache.replaceShaderProgram(e) }; Object.defineProperties(tm.prototype, { vertexShaderSource: { get: function () { return this._vertexShaderSource } }, fragmentShaderSource: { get: function () { return this._fragmentShaderSource } }, vertexAttributes: { get: function () { return D1(this), this._vertexAttributes } }, numberOfVertexAttributes: { get: function () { return D1(this), this._numberOfVertexAttributes } }, allUniforms: { get: function () { return D1(this), this._uniformsByName } } }); function NK(e) { let t = [], n = e.match(/uniform.*?(?![^{]*})(?=[=\[;])/g); if (l(n)) { let i = n.length; for (let o = 0; o < i; o++) { let r = n[o].trim(), s = r.slice(r.lastIndexOf(" ") + 1); t.push(s) } } return t } function gbe(e, t) { let n = {}; if (!Ut.highpFloatSupported || !Ut.highpIntSupported) { let i, o, r, s, a = NK(e), c = NK(t), u = a.length, f = c.length; for (i = 0; i < u; i++)for (o = 0; o < f; o++)if (a[i] === c[o]) { r = a[i], s = `czm_mediump_${r}`; let d = new RegExp(`${r}\\b`, "g"); t = t.replace(d, s), n[s] = r } } return { fragmentShaderText: t, duplicateUniformNames: n } } var vd = "[Cesium WebGL] "; function ybe(e, t) {
        let n = t._vertexShaderText, i = t._fragmentShaderText, o = e.createShader(e.VERTEX_SHADER); e.shaderSource(o, n), e.compileShader(o); let r = e.createShader(e.FRAGMENT_SHADER); e.shaderSource(r, i), e.compileShader(r); let s = e.createProgram(); e.attachShader(s, o), e.attachShader(s, r); let a = t._attributeLocations; if (l(a)) for (let p in a) a.hasOwnProperty(p) && e.bindAttribLocation(s, a[p], p); e.linkProgram(s); let c; if (e.getProgramParameter(s, e.LINK_STATUS)) return t._logShaderCompilation && (c = e.getShaderInfoLog(o), l(c) && c.length > 0 && console.log(`${vd}Vertex shader compile log: ${c}`), c = e.getShaderInfoLog(r), l(c) && c.length > 0 && console.log(`${vd}Fragment shader compile log: ${c}`), c = e.getProgramInfoLog(s), l(c) && c.length > 0 && console.log(`${vd}Shader program link log: ${c}`)), e.deleteShader(o), e.deleteShader(r), s; let u, f = t._debugShaders; throw e.getShaderParameter(r, e.COMPILE_STATUS) ? e.getShaderParameter(o, e.COMPILE_STATUS) ? (c = e.getProgramInfoLog(s), console.error(`${vd}Shader program link log: ${c}`), d(o, "vertex"), d(r, "fragment"), u = `Program failed to link.  Link log: ${c}`) : (c = e.getShaderInfoLog(o), console.error(`${vd}Vertex shader compile log: ${c}`), console.error(`${vd} Vertex shader source:
${n}`), u = `Vertex shader failed to compile.  Compile log: ${c}`) : (c = e.getShaderInfoLog(r), console.error(`${vd}Fragment shader compile log: ${c}`), console.error(`${vd} Fragment shader source:
${i}`), u = `Fragment shader failed to compile.  Compile log: ${c}`), e.deleteShader(o), e.deleteShader(r), e.deleteProgram(s), new fe(u); function d(p, g) {
            if (!l(f)) return; let m = f.getTranslatedShaderSource(p); if (m === "") { console.error(`${vd}${g} shader translation failed.`); return } console.error(`${vd}Translated ${g} shaderSource:
${m}`)
        }
    } function Abe(e, t, n) { let i = {}; for (let o = 0; o < n; ++o) { let r = e.getActiveAttrib(t, o), s = e.getAttribLocation(t, r.name); i[r.name] = { name: r.name, type: r.type, index: s } } return i } function Cbe(e, t) { let n = {}, i = [], o = [], r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS); for (let s = 0; s < r; ++s) { let a = e.getActiveUniform(t, s), c = "[0]", u = a.name.indexOf(c, a.name.length - c.length) !== -1 ? a.name.slice(0, a.name.length - 3) : a.name; if (u.indexOf("gl_") !== 0) if (a.name.indexOf("[") < 0) { let f = e.getUniformLocation(t, u); if (f !== null) { let d = S1(e, a, u, f); n[u] = d, i.push(d), d._setSampler && o.push(d) } } else { let f, d, p, g, m = u.indexOf("["); if (m >= 0) { if (f = n[u.slice(0, m)], !l(f)) continue; d = f._locations, d.length <= 1 && (p = f.value, g = e.getUniformLocation(t, u), g !== null && (d.push(g), p.push(e.getUniform(t, g)))) } else { d = []; for (let A = 0; A < a.size; ++A)g = e.getUniformLocation(t, `${u}[${A}]`), g !== null && d.push(g); f = w1(e, a, u, d), n[u] = f, i.push(f), f._setSampler && o.push(f) } } } return { uniformsByName: n, uniforms: i, samplerUniforms: o } } function xbe(e, t) { let n = [], i = []; for (let o in t) if (t.hasOwnProperty(o)) { let r = t[o], s = o, a = e._duplicateUniformNames[s]; l(a) && (r.name = a, s = a); let c = Fp[s]; l(c) ? n.push({ uniform: r, automaticUniform: c }) : i.push(r) } return { automaticUniforms: n, manualUniforms: i } } function Tbe(e, t, n) { e.useProgram(t); let i = 0, o = n.length; for (let r = 0; r < o; ++r)i = n[r]._setSampler(i); return e.useProgram(null), i } function D1(e) { l(e._program) || VK(e) } function VK(e) { let t = e._program, n = e._gl, i = ybe(n, e, e._debugShaders), o = n.getProgramParameter(i, n.ACTIVE_ATTRIBUTES), r = Cbe(n, i), s = xbe(e, r.uniformsByName); e._program = i, e._numberOfVertexAttributes = o, e._vertexAttributes = Abe(n, i, o), e._uniformsByName = r.uniformsByName, e._uniforms = r.uniforms, e._automaticUniforms = s.automaticUniforms, e._manualUniforms = s.manualUniforms, e.maximumTextureUnitIndex = Tbe(n, i, r.samplerUniforms), t && e._gl.deleteProgram(t), typeof spector < "u" && (e._program.__SPECTOR_rebuildProgram = function (a, c, u, f) { let d = e._vertexShaderText, p = e._fragmentShaderText, g = / ! = /g; e._vertexShaderText = a.replace(g, " != "), e._fragmentShaderText = c.replace(g, " != "); try { VK(e), u(e._program) } catch (m) { e._vertexShaderText = d, e._fragmentShaderText = p; let C = /(?:Compile|Link) error: ([^]*)/.exec(m.message); f(C ? C[1] : m.message) } }) } tm.prototype._bind = function () { D1(this), this._gl.useProgram(this._program) }; tm.prototype._setUniforms = function (e, t, n) { let i, o; if (l(e)) { let a = this._manualUniforms; for (i = a.length, o = 0; o < i; ++o) { let c = a[o]; c.value = e[c.name]() } } let r = this._automaticUniforms; for (i = r.length, o = 0; o < i; ++o) { let a = r[o]; a.uniform.value = a.automaticUniform.getValue(t) } let s = this._uniforms; for (i = s.length, o = 0; o < i; ++o)s[o].set(); if (n) { let a = this._gl, c = this._program; a.validateProgram(c) } }; tm.prototype.isDestroyed = function () { return !1 }; tm.prototype.destroy = function () { this._cachedShader.cache.releaseShaderProgram(this) }; tm.prototype.finalDestroy = function () { return this._gl.deleteProgram(this._program), le(this) }; var qt = tm; function Ebe(e, t) {
        let n = /#define OUTPUT_DECLARATION/, i = e.split(`
`); if (/#version 300 es/g.test(e)) return e; let o = -1, r, s; for (r = 0; r < i.length; ++r)if (s = i[r], n.test(s)) { o = r; break } if (o === -1) throw new ye("Could not find a #define OUTPUT_DECLARATION!"); let a = []; for (r = 0; r < 10; r++) { let A = `gl_FragData\\[${r}\\]`, C = `czm_out${r}`; new RegExp(A, "g").test(e) && (kK(C, a), Pd(A, C, i), i.splice(o, 0, `layout(location = ${r}) out vec4 ${C};`), o += 1) } let c = "czm_fragColor"; Sbe("gl_FragColor", i) && (kK(c, a), Pd("gl_FragColor", c, i), i.splice(o, 0, "layout(location = 0) out vec4 czm_fragColor;"), o += 1); let u = Dbe(a, i), f = {}; for (r = 0; r < i.length; r++) { s = i[r]; for (let A in u) u.hasOwnProperty(A) && new RegExp(`(layout)[^]+(out)[^]+(${A})[^]+`, "g").test(s) && (f[s] = A) } for (let A in f) if (f.hasOwnProperty(A)) { let C = f[A], x = i.indexOf(A), T = u[C], b = T.length; for (let S = 0; S < b; S++)i.splice(x, 0, T[S]); x += b + 1; for (let S = b - 1; S >= 0; S--)i.splice(x, 0, `#endif //${T[S]}`) } let d = "WEBGL_2", p = `#define ${d}`, g = "#version 300 es", m = !1; for (r = 0; r < i.length; r++)if (/#version/.test(i[r])) { i[r] = g, m = !0; break } return m || i.splice(0, 0, g), i.splice(1, 0, p), YH("EXT_draw_buffers", d, i), YH("EXT_frag_depth", d, i), YH("OES_standard_derivatives", d, i), Pd("texture2D", "texture", i), Pd("texture3D", "texture", i), Pd("textureCube", "texture", i), Pd("gl_FragDepthEXT", "gl_FragDepth", i), t ? Pd("varying", "in", i) : (Pd("attribute", "in", i), Pd("varying", "out", i)), wbe(i)
    } function Pd(e, t, n) { let i = `(^|[^\\w])(${e})($|[^\\w])`, o = new RegExp(i, "g"), r = n.length; for (let s = 0; s < r; ++s) { let a = n[s]; n[s] = a.replace(o, `$1${t}$3`) } } function bbe(e, t, n) { let i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; n[o] = r.replace(e, t) } } function Sbe(e, t) { let n = `(^|[^\\w])(${e})($|[^\\w])`, i = new RegExp(n, "g"), o = t.length; for (let r = 0; r < o; ++r) { let s = t[r]; if (i.test(s)) return !0 } return !1 } function wbe(e) {
        let t = "", n = e.length; for (let i = 0; i < n; ++i)t += `${e[i]}
`; return t
    } function kK(e, t) { t.indexOf(e) === -1 && t.push(e) } function Dbe(e, t) { let n = {}, i = e.length, o = []; for (let r = 0; r < t.length; ++r) { let s = t[r], a = /(#ifdef|#if)/g.test(s), c = /#else/g.test(s), u = /#endif/g.test(s); if (a) o.push(s); else if (c) { let d = o[o.length - 1].replace("ifdef", "ifndef"); /if/g.test(d) && (d = d.replace(/(#if\s+)(\S*)([^]*)/, "$1!($2)$3")), o.pop(), o.push(d) } else if (u) o.pop(); else if (!/layout/g.test(s)) for (let f = 0; f < i; ++f) { let d = e[f]; s.indexOf(d) !== -1 && (l(n[d]) ? n[d] = n[d].filter(function (p) { return o.indexOf(p) >= 0 }) : n[d] = o.slice()) } } return n } function YH(e, t, n) { let i = `#extension\\s+GL_${e}\\s+:\\s+[a-zA-Z0-9]+\\s*$`; bbe(new RegExp(i, "g"), "", n), Pd(`GL_${e}`, t, n) } var v1 = Ebe; var P1 = `const float czm_degreesPerRadian = 57.29577951308232;
`; var I1 = `const czm_depthRangeStruct czm_depthRange = czm_depthRangeStruct(0.0, 1.0);
`; var O1 = `const float czm_epsilon1 = 0.1;
`; var B1 = `const float czm_epsilon2 = 0.01;
`; var R1 = `const float czm_epsilon3 = 0.001;
`; var M1 = `const float czm_epsilon4 = 0.0001;
`; var L1 = `const float czm_epsilon5 = 0.00001;
`; var F1 = `const float czm_epsilon6 = 0.000001;
`; var N1 = `const float czm_epsilon7 = 0.0000001;
`; var V1 = `const float czm_infinity = 5906376272000.0;
`; var k1 = `const float czm_oneOverPi = 0.3183098861837907;
`; var U1 = `const float czm_oneOverTwoPi = 0.15915494309189535;
`; var z1 = `const float czm_passCesium3DTile = 4.0;
`; var H1 = `const float czm_passCesium3DTileClassification = 5.0;
`; var G1 = `const float czm_passCesium3DTileClassificationIgnoreShow = 6.0;
`; var W1 = `const float czm_passClassification = 7.0;
`; var j1 = `const float czm_passCompute = 1.0;
`; var q1 = `const float czm_passEnvironment = 0.0;
`; var Y1 = `const float czm_passGlobe = 2.0;
`; var X1 = `const float czm_passOpaque = 7.0;
`; var K1 = `const float czm_passOverlay = 9.0;
`; var J1 = `const float czm_passTerrainClassification = 3.0;
`; var Z1 = `const float czm_passTranslucent = 8.0;
`; var Q1 = `const float czm_pi = 3.141592653589793;
`; var $1 = `const float czm_piOverFour = 0.7853981633974483;
`; var eI = `const float czm_piOverSix = 0.5235987755982988;
`; var tI = `const float czm_piOverThree = 1.0471975511965976;
`; var nI = `const float czm_piOverTwo = 1.5707963267948966;
`; var iI = `const float czm_radiansPerDegree = 0.017453292519943295;
`; var oI = `const float czm_sceneMode2D = 2.0;
`; var rI = `const float czm_sceneMode3D = 3.0;
`; var sI = `const float czm_sceneModeColumbusView = 1.0;
`; var aI = `const float czm_sceneModeMorphing = 0.0;
`; var cI = `const float czm_solarRadius = 695500000.0;
`; var lI = `const float czm_threePiOver2 = 4.71238898038469;
`; var uI = `const float czm_twoPi = 6.283185307179586;
`; var fI = `const float czm_webMercatorMaxLatitude = 1.4844222297453324;
`; var dI = `struct czm_depthRangeStruct
{
float near;
float far;
};
`; var hI = `struct czm_material
{
vec3 diffuse;
float specular;
float shininess;
vec3 normal;
vec3 emission;
float alpha;
};
`; var mI = `struct czm_materialInput
{
float s;
vec2 st;
vec3 str;
vec3 normalEC;
mat3 tangentToEyeMatrix;
vec3 positionToEyeEC;
float height;
float slope;
float aspect;
};
`; var pI = `struct czm_modelMaterial {
vec3 diffuse;
float alpha;
vec3 specular;
float roughness;
vec3 normalEC;
float occlusion;
vec3 emissive;
};
`; var _I = `struct czm_modelVertexOutput {
vec3 positionMC;
float pointSize;
};
`; var gI = `struct czm_pbrParameters
{
vec3 diffuseColor;
float roughness;
vec3 f0;
};
`; var yI = `struct czm_ray
{
vec3 origin;
vec3 direction;
};
`; var AI = `struct czm_raySegment
{
float start;
float stop;
};
const czm_raySegment czm_emptyRaySegment = czm_raySegment(-czm_infinity, -czm_infinity);
const czm_raySegment czm_fullRaySegment = czm_raySegment(0.0, czm_infinity);
`; var CI = `struct czm_shadowParameters
{
#ifdef USE_CUBE_MAP_SHADOW
vec3 texCoords;
#else
vec2 texCoords;
#endif
float depthBias;
float depth;
float nDotL;
vec2 texelStepSize;
float normalShadingSmooth;
float darkness;
};
`; var xI = `vec3 czm_acesTonemapping(vec3 color) {
float g = 0.985;
float a = 0.065;
float b = 0.0001;
float c = 0.433;
float d = 0.238;
color = (color * (color + a) - b) / (color * (g * color + c) + d);
color = clamp(color, 0.0, 1.0);
return color;
}
`; var TI = `float czm_alphaWeight(float a)
{
float z = (gl_FragCoord.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];
return pow(a + 0.01, 4.0) + max(1e-2, min(3.0 * 1e3, 0.003 / (1e-5 + pow(abs(z) / 200.0, 4.0))));
}
`; var EI = `vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor)
{
float val1 = clamp(dist / fuzzFactor, 0.0, 1.0);
float val2 = clamp((dist - 0.5) / fuzzFactor, 0.0, 1.0);
val1 = val1 * (1.0 - val2);
val1 = val1 * val1 * (3.0 - (2.0 * val1));
val1 = pow(val1, 0.5);
vec4 midColor = (color1 + color2) * 0.5;
return mix(midColor, currentColor, val1);
}
vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist)
{
return czm_antialias(color1, color2, currentColor, dist, 0.1);
}
`; var bI = `vec2 czm_approximateSphericalCoordinates(vec3 normal) {
float latitudeApproximation = czm_fastApproximateAtan(sqrt(normal.x * normal.x + normal.y * normal.y), normal.z);
float longitudeApproximation = czm_fastApproximateAtan(normal.x, normal.y);
return vec2(latitudeApproximation, longitudeApproximation);
}
`; var SI = `bool czm_backFacing()
{
return gl_FrontFacing == false;
}
`; var wI = `float czm_branchFreeTernary(bool comparison, float a, float b) {
float useA = float(comparison);
return a * useA + b * (1.0 - useA);
}
vec2 czm_branchFreeTernary(bool comparison, vec2 a, vec2 b) {
float useA = float(comparison);
return a * useA + b * (1.0 - useA);
}
vec3 czm_branchFreeTernary(bool comparison, vec3 a, vec3 b) {
float useA = float(comparison);
return a * useA + b * (1.0 - useA);
}
vec4 czm_branchFreeTernary(bool comparison, vec4 a, vec4 b) {
float useA = float(comparison);
return a * useA + b * (1.0 - useA);
}
`; var DI = `vec4 czm_cascadeColor(vec4 weights)
{
return vec4(1.0, 0.0, 0.0, 1.0) * weights.x +
vec4(0.0, 1.0, 0.0, 1.0) * weights.y +
vec4(0.0, 0.0, 1.0, 1.0) * weights.z +
vec4(1.0, 0.0, 1.0, 1.0) * weights.w;
}
`; var vI = `uniform vec4 shadowMap_cascadeDistances;
float czm_cascadeDistance(vec4 weights)
{
return dot(shadowMap_cascadeDistances, weights);
}
`; var PI = `uniform mat4 shadowMap_cascadeMatrices[4];
mat4 czm_cascadeMatrix(vec4 weights)
{
return shadowMap_cascadeMatrices[0] * weights.x +
shadowMap_cascadeMatrices[1] * weights.y +
shadowMap_cascadeMatrices[2] * weights.z +
shadowMap_cascadeMatrices[3] * weights.w;
}
`; var II = `uniform vec4 shadowMap_cascadeSplits[2];
vec4 czm_cascadeWeights(float depthEye)
{
vec4 near = step(shadowMap_cascadeSplits[0], vec4(depthEye));
vec4 far = step(depthEye, shadowMap_cascadeSplits[1]);
return near * far;
}
`; var OI = `vec4 czm_columbusViewMorph(vec4 position2D, vec4 position3D, float time)
{
vec3 p = mix(position2D.xyz, position3D.xyz, time);
return vec4(p, 1.0);
}
`; var BI = `vec4 czm_computePosition();
`; var RI = `vec2 cordic(float angle)
{
vec2 vector = vec2(6.0725293500888267e-1, 0.0);
float sense = (angle < 0.0) ? -1.0 : 1.0;
mat2 rotation = mat2(1.0, sense, -sense, 1.0);
vector = rotation * vector;
angle -= sense * 7.8539816339744828e-1;
sense = (angle < 0.0) ? -1.0 : 1.0;
float factor = sense * 5.0e-1;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 4.6364760900080609e-1;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 2.5e-1;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 2.4497866312686414e-1;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 1.25e-1;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 1.2435499454676144e-1;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 6.25e-2;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 6.2418809995957350e-2;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 3.125e-2;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 3.1239833430268277e-2;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 1.5625e-2;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 1.5623728620476831e-2;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 7.8125e-3;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 7.8123410601011111e-3;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 3.90625e-3;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 3.9062301319669718e-3;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 1.953125e-3;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 1.9531225164788188e-3;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 9.765625e-4;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 9.7656218955931946e-4;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 4.8828125e-4;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 4.8828121119489829e-4;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 2.44140625e-4;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 2.4414062014936177e-4;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 1.220703125e-4;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 1.2207031189367021e-4;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 6.103515625e-5;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 6.1035156174208773e-5;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 3.0517578125e-5;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 3.0517578115526096e-5;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 1.52587890625e-5;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 1.5258789061315762e-5;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 7.62939453125e-6;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 7.6293945311019700e-6;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 3.814697265625e-6;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 3.8146972656064961e-6;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 1.9073486328125e-6;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 1.9073486328101870e-6;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 9.5367431640625e-7;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 9.5367431640596084e-7;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 4.76837158203125e-7;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 4.7683715820308884e-7;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 2.384185791015625e-7;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 2.3841857910155797e-7;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 1.1920928955078125e-7;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
return vector;
}
vec2 czm_cosineAndSine(float angle)
{
if (angle < -czm_piOverTwo || angle > czm_piOverTwo)
{
if (angle < 0.0)
{
return -cordic(angle + czm_pi);
}
else
{
return -cordic(angle - czm_pi);
}
}
else
{
return cordic(angle);
}
}
`; var MI = `vec2 czm_decompressTextureCoordinates(float encoded)
{
float temp = encoded / 4096.0;
float xZeroTo4095 = floor(temp);
float stx = xZeroTo4095 / 4095.0;
float sty = (encoded - xZeroTo4095 * 4096.0) / 4095.0;
return vec2(stx, sty);
}
`; var LI = `czm_pbrParameters czm_defaultPbrMaterial()
{
czm_pbrParameters results;
results.diffuseColor = vec3(1.0);
results.roughness = 1.0;
const vec3 REFLECTANCE_DIELECTRIC = vec3(0.04);
results.f0 = REFLECTANCE_DIELECTRIC;
return results;
}
`; var FI = `#if defined(GL_EXT_frag_depth) && !defined(LOG_DEPTH)
varying float v_WindowZ;
#endif
vec4 czm_depthClamp(vec4 coords)
{
#ifndef LOG_DEPTH
#ifdef GL_EXT_frag_depth
v_WindowZ = (0.5 * (coords.z / coords.w) + 0.5) * coords.w;
coords.z = 0.0;
#else
coords.z = min(coords.z, coords.w);
#endif
#endif
return coords;
}
`; var NI = `mat3 czm_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC)
{
vec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0));
vec3 tangentEC = normalize(czm_normal3D * tangentMC);
vec3 bitangentEC = normalize(cross(normalEC, tangentEC));
return mat3(
tangentEC.x,   tangentEC.y,   tangentEC.z,
bitangentEC.x, bitangentEC.y, bitangentEC.z,
normalEC.x,    normalEC.y,    normalEC.z);
}
`; var VI = `bool czm_ellipsoidContainsPoint(vec3 ellipsoid_inverseRadii, vec3 point)
{
vec3 scaled = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(point, 1.0)).xyz;
return (dot(scaled, scaled) <= 1.0);
}
`; var kI = `vec2 czm_ellipsoidWgs84TextureCoordinates(vec3 normal)
{
return vec2(atan(normal.y, normal.x) * czm_oneOverTwoPi + 0.5, asin(normal.z) * czm_oneOverPi + 0.5);
}
`; var UI = `bool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon) {
return all(lessThanEqual(abs(left - right), vec4(epsilon)));
}
bool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon) {
return all(lessThanEqual(abs(left - right), vec3(epsilon)));
}
bool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon) {
return all(lessThanEqual(abs(left - right), vec2(epsilon)));
}
bool czm_equalsEpsilon(float left, float right, float epsilon) {
return (abs(left - right) <= epsilon);
}
`; var zI = `vec4 czm_eyeOffset(vec4 positionEC, vec3 eyeOffset)
{
vec4 p = positionEC;
vec4 zEyeOffset = normalize(p) * eyeOffset.z;
p.xy += eyeOffset.xy + zEyeOffset.xy;
p.z += zEyeOffset.z;
return p;
}
`; var HI = `vec4 czm_eyeToWindowCoordinates(vec4 positionEC)
{
vec4 q = czm_projection * positionEC;
q.xyz /= q.w;
q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz;
return q;
}
`; var GI = `float czm_fastApproximateAtan(float x) {
return x * (-0.1784 * x - 0.0663 * x * x + 1.0301);
}
float czm_fastApproximateAtan(float x, float y) {
float t = abs(x);
float opposite = abs(y);
float adjacent = max(t, opposite);
opposite = min(t, opposite);
t = czm_fastApproximateAtan(opposite / adjacent);
t = czm_branchFreeTernary(abs(y) > abs(x), czm_piOverTwo - t, t);
t = czm_branchFreeTernary(x < 0.0, czm_pi - t, t);
t = czm_branchFreeTernary(y < 0.0, -t, t);
return t;
}
`; var WI = `vec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor)
{
float scalar = distanceToCamera * czm_fogDensity;
float fog = 1.0 - exp(-(scalar * scalar));
return mix(color, fogColor, fog);
}
vec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant)
{
float scalar = distanceToCamera * czm_fogDensity;
float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));
return mix(color, fogColor, fog);
}
`; var jI = `vec3 czm_gammaCorrect(vec3 color) {
#ifdef HDR
color = pow(color, vec3(czm_gamma));
#endif
return color;
}
vec4 czm_gammaCorrect(vec4 color) {
#ifdef HDR
color.rgb = pow(color.rgb, vec3(czm_gamma));
#endif
return color;
}
`; var qI = `vec3 czm_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared)
{
return normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared);
}
`; var YI = `czm_material czm_getDefaultMaterial(czm_materialInput materialInput)
{
czm_material material;
material.diffuse = vec3(0.0);
material.specular = 0.0;
material.shininess = 1.0;
material.normal = materialInput.normalEC;
material.emission = vec3(0.0);
material.alpha = 1.0;
return material;
}
`; var XI = `float czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)
{
return max(dot(lightDirectionEC, normalEC), 0.0);
}
`; var KI = `float czm_getSpecular(vec3 lightDirectionEC, vec3 toEyeEC, vec3 normalEC, float shininess)
{
vec3 toReflectedLight = reflect(-lightDirectionEC, normalEC);
float specular = max(dot(toReflectedLight, toEyeEC), 0.0);
return pow(specular, max(shininess, czm_epsilon2));
}
`; var JI = `vec4 czm_getWaterNoise(sampler2D normalMap, vec2 uv, float time, float angleInRadians)
{
float cosAngle = cos(angleInRadians);
float sinAngle = sin(angleInRadians);
vec2 s0 = vec2(1.0/17.0, 0.0);
vec2 s1 = vec2(-1.0/29.0, 0.0);
vec2 s2 = vec2(1.0/101.0, 1.0/59.0);
vec2 s3 = vec2(-1.0/109.0, -1.0/57.0);
s0 = vec2((cosAngle * s0.x) - (sinAngle * s0.y), (sinAngle * s0.x) + (cosAngle * s0.y));
s1 = vec2((cosAngle * s1.x) - (sinAngle * s1.y), (sinAngle * s1.x) + (cosAngle * s1.y));
s2 = vec2((cosAngle * s2.x) - (sinAngle * s2.y), (sinAngle * s2.x) + (cosAngle * s2.y));
s3 = vec2((cosAngle * s3.x) - (sinAngle * s3.y), (sinAngle * s3.x) + (cosAngle * s3.y));
vec2 uv0 = (uv/103.0) + (time * s0);
vec2 uv1 = uv/107.0 + (time * s1) + vec2(0.23);
vec2 uv2 = uv/vec2(897.0, 983.0) + (time * s2) + vec2(0.51);
vec2 uv3 = uv/vec2(991.0, 877.0) + (time * s3) + vec2(0.71);
uv0 = fract(uv0);
uv1 = fract(uv1);
uv2 = fract(uv2);
uv3 = fract(uv3);
vec4 noise = (texture2D(normalMap, uv0)) +
(texture2D(normalMap, uv1)) +
(texture2D(normalMap, uv2)) +
(texture2D(normalMap, uv3));
return ((noise / 4.0) - 0.5) * 2.0;
}
`; var ZI = `const vec4 K_HSB2RGB = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
vec3 czm_HSBToRGB(vec3 hsb)
{
vec3 p = abs(fract(hsb.xxx + K_HSB2RGB.xyz) * 6.0 - K_HSB2RGB.www);
return hsb.z * mix(K_HSB2RGB.xxx, clamp(p - K_HSB2RGB.xxx, 0.0, 1.0), hsb.y);
}
`; var QI = `vec3 hueToRGB(float hue)
{
float r = abs(hue * 6.0 - 3.0) - 1.0;
float g = 2.0 - abs(hue * 6.0 - 2.0);
float b = 2.0 - abs(hue * 6.0 - 4.0);
return clamp(vec3(r, g, b), 0.0, 1.0);
}
vec3 czm_HSLToRGB(vec3 hsl)
{
vec3 rgb = hueToRGB(hsl.x);
float c = (1.0 - abs(2.0 * hsl.z - 1.0)) * hsl.y;
return (rgb - 0.5) * c + hsl.z;
}
`; var $I = `vec3 czm_hue(vec3 rgb, float adjustment)
{
const mat3 toYIQ = mat3(0.299,     0.587,     0.114,
0.595716, -0.274453, -0.321263,
0.211456, -0.522591,  0.311135);
const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,
1.0, -0.2721, -0.6474,
1.0, -1.107,   1.7046);
vec3 yiq = toYIQ * rgb;
float hue = atan(yiq.z, yiq.y) + adjustment;
float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);
vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));
return toRGB * color;
}
`; var eO = `vec3 czm_inverseGamma(vec3 color) {
return pow(color, vec3(1.0 / czm_gamma));
}
`; var tO = `bool czm_isEmpty(czm_raySegment interval)
{
return (interval.stop < 0.0);
}
`; var nO = `bool czm_isFull(czm_raySegment interval)
{
return (interval.start == 0.0 && interval.stop == czm_infinity);
}
`; var iO = `float czm_latitudeToWebMercatorFraction(float latitude, float southMercatorY, float oneOverMercatorHeight)
{
float sinLatitude = sin(latitude);
float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));
return (mercatorY - southMercatorY) * oneOverMercatorHeight;
}
`; var oO = `vec3 czm_linearToSrgb(vec3 linearIn)
{
return pow(linearIn, vec3(1.0/2.2));
}
vec4 czm_linearToSrgb(vec4 linearIn)
{
vec3 srgbOut = pow(linearIn.rgb, vec3(1.0/2.2));
return vec4(srgbOut, linearIn.a);
}
`; var rO = `float czm_lineDistance(vec2 point1, vec2 point2, vec2 point) {
return abs((point2.y - point1.y) * point.x - (point2.x - point1.x) * point.y + point2.x * point1.y - point2.y * point1.x) / distance(point2, point1);
}
`; var sO = `float czm_luminance(vec3 rgb)
{
const vec3 W = vec3(0.2125, 0.7154, 0.0721);
return dot(rgb, W);
}
`; var aO = `float czm_metersPerPixel(vec4 positionEC, float pixelRatio)
{
float width = czm_viewport.z;
float height = czm_viewport.w;
float pixelWidth;
float pixelHeight;
float top = czm_frustumPlanes.x;
float bottom = czm_frustumPlanes.y;
float left = czm_frustumPlanes.z;
float right = czm_frustumPlanes.w;
if (czm_sceneMode == czm_sceneMode2D || czm_orthographicIn3D == 1.0)
{
float frustumWidth = right - left;
float frustumHeight = top - bottom;
pixelWidth = frustumWidth / width;
pixelHeight = frustumHeight / height;
}
else
{
float distanceToPixel = -positionEC.z;
float inverseNear = 1.0 / czm_currentFrustum.x;
float tanTheta = top * inverseNear;
pixelHeight = 2.0 * distanceToPixel * tanTheta / height;
tanTheta = right * inverseNear;
pixelWidth = 2.0 * distanceToPixel * tanTheta / width;
}
return max(pixelWidth, pixelHeight) * pixelRatio;
}
float czm_metersPerPixel(vec4 positionEC)
{
return czm_metersPerPixel(positionEC, czm_pixelRatio);
}
`; var cO = `vec4 czm_modelToWindowCoordinates(vec4 position)
{
vec4 q = czm_modelViewProjection * position;
q.xyz /= q.w;
q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz;
return q;
}
`; var lO = `vec3 czm_multiplyWithColorBalance(vec3 left, vec3 right)
{
const vec3 W = vec3(0.2125, 0.7154, 0.0721);
vec3 target = left * right;
float leftLuminance = dot(left, W);
float rightLuminance = dot(right, W);
float targetLuminance = dot(target, W);
return ((leftLuminance + rightLuminance) / (2.0 * targetLuminance)) * target;
}
`; var uO = `float czm_nearFarScalar(vec4 nearFarScalar, float cameraDistSq)
{
float valueAtMin = nearFarScalar.y;
float valueAtMax = nearFarScalar.w;
float nearDistanceSq = nearFarScalar.x * nearFarScalar.x;
float farDistanceSq = nearFarScalar.z * nearFarScalar.z;
float t = (cameraDistSq - nearDistanceSq) / (farDistanceSq - nearDistanceSq);
t = pow(clamp(t, 0.0, 1.0), 0.2);
return mix(valueAtMin, valueAtMax, t);
}
`; var fO = `vec3 czm_octDecode(vec2 encoded, float range)
{
if (encoded.x == 0.0 && encoded.y == 0.0) {
return vec3(0.0, 0.0, 0.0);
}
encoded = encoded / range * 2.0 - 1.0;
vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));
if (v.z < 0.0)
{
v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);
}
return normalize(v);
}
vec3 czm_octDecode(vec2 encoded)
{
return czm_octDecode(encoded, 255.0);
}
vec3 czm_octDecode(float encoded)
{
float temp = encoded / 256.0;
float x = floor(temp);
float y = (temp - x) * 256.0;
return czm_octDecode(vec2(x, y));
}
void czm_octDecode(vec2 encoded, out vec3 vector1, out vec3 vector2, out vec3 vector3)
{
float temp = encoded.x / 65536.0;
float x = floor(temp);
float encodedFloat1 = (temp - x) * 65536.0;
temp = encoded.y / 65536.0;
float y = floor(temp);
float encodedFloat2 = (temp - y) * 65536.0;
vector1 = czm_octDecode(encodedFloat1);
vector2 = czm_octDecode(encodedFloat2);
vector3 = czm_octDecode(vec2(x, y));
}
`; var dO = `vec4 czm_packDepth(float depth)
{
vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;
enc = fract(enc);
enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);
return enc;
}
`; var hO = `vec3 lambertianDiffuse(vec3 diffuseColor)
{
return diffuseColor / czm_pi;
}
vec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH)
{
return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);
}
float smithVisibilityG1(float NdotV, float roughness)
{
float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
return NdotV / (NdotV * (1.0 - k) + k);
}
float smithVisibilityGGX(float roughness, float NdotL, float NdotV)
{
return (
smithVisibilityG1(NdotL, roughness) *
smithVisibilityG1(NdotV, roughness)
);
}
float GGX(float roughness, float NdotH)
{
float roughnessSquared = roughness * roughness;
float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;
return roughnessSquared / (czm_pi * f * f);
}
vec3 czm_pbrLighting(
vec3 positionEC,
vec3 normalEC,
vec3 lightDirectionEC,
vec3 lightColorHdr,
czm_pbrParameters pbrParameters
)
{
vec3 v = -normalize(positionEC);
vec3 l = normalize(lightDirectionEC);
vec3 h = normalize(v + l);
vec3 n = normalEC;
float NdotL = clamp(dot(n, l), 0.001, 1.0);
float NdotV = abs(dot(n, v)) + 0.001;
float NdotH = clamp(dot(n, h), 0.0, 1.0);
float LdotH = clamp(dot(l, h), 0.0, 1.0);
float VdotH = clamp(dot(v, h), 0.0, 1.0);
vec3 f0 = pbrParameters.f0;
float reflectance = max(max(f0.r, f0.g), f0.b);
vec3 f90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));
vec3 F = fresnelSchlick2(f0, f90, VdotH);
float alpha = pbrParameters.roughness;
float G = smithVisibilityGGX(alpha, NdotL, NdotV);
float D = GGX(alpha, NdotH);
vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV);
vec3 diffuseColor = pbrParameters.diffuseColor;
vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);
return (diffuseContribution + specularContribution) * NdotL * lightColorHdr;
}
`; var mO = `czm_pbrParameters czm_pbrMetallicRoughnessMaterial(
vec3 baseColor,
float metallic,
float roughness
)
{
czm_pbrParameters results;
roughness = clamp(roughness, 0.0, 1.0);
results.roughness = roughness * roughness;
metallic = clamp(metallic, 0.0, 1.0);
const vec3 REFLECTANCE_DIELECTRIC = vec3(0.04);
vec3 f0 = mix(REFLECTANCE_DIELECTRIC, baseColor, metallic);
results.f0 = f0;
results.diffuseColor = baseColor * (1.0 - f0) * (1.0 - metallic);
return results;
}
`; var pO = `czm_pbrParameters czm_pbrSpecularGlossinessMaterial(
vec3 diffuse,
vec3 specular,
float glossiness
)
{
czm_pbrParameters results;
float roughness = 1.0 - glossiness;
results.roughness = roughness * roughness;
results.diffuseColor = diffuse * (1.0 - max(max(specular.r, specular.g), specular.b));
results.f0 = specular;
return results;
}
`; var _O = `float czm_private_getLambertDiffuseOfMaterial(vec3 lightDirectionEC, czm_material material)
{
return czm_getLambertDiffuse(lightDirectionEC, material.normal);
}
float czm_private_getSpecularOfMaterial(vec3 lightDirectionEC, vec3 toEyeEC, czm_material material)
{
return czm_getSpecular(lightDirectionEC, toEyeEC, material.normal, material.shininess);
}
vec4 czm_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)
{
float diffuse = czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 0.0, 1.0), material);
if (czm_sceneMode == czm_sceneMode3D) {
diffuse += czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 1.0, 0.0), material);
}
float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);
vec3 materialDiffuse = material.diffuse * 0.5;
vec3 ambient = materialDiffuse;
vec3 color = ambient + material.emission;
color += materialDiffuse * diffuse * czm_lightColor;
color += material.specular * specular * czm_lightColor;
return vec4(color, material.alpha);
}
vec4 czm_private_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)
{
float diffuse = czm_private_getLambertDiffuseOfMaterial(lightDirectionEC, material);
float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);
vec3 ambient = vec3(0.0);
vec3 color = ambient + material.emission;
color += material.diffuse * diffuse * czm_lightColor;
color += material.specular * specular * czm_lightColor;
return vec4(color, material.alpha);
}
`; var gO = `float czm_planeDistance(vec4 plane, vec3 point) {
return (dot(plane.xyz, point) + plane.w);
}
float czm_planeDistance(vec3 planeNormal, float planeDistance, vec3 point) {
return (dot(planeNormal, point) + planeDistance);
}
`; var yO = `vec3 czm_pointAlongRay(czm_ray ray, float time)
{
return ray.origin + (time * ray.direction);
}
`; var AO = `czm_raySegment czm_rayEllipsoidIntersectionInterval(czm_ray ray, vec3 ellipsoid_center, vec3 ellipsoid_inverseRadii)
{
vec3 q = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.origin, 1.0)).xyz;
vec3 w = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.direction, 0.0)).xyz;
q = q - ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ellipsoid_center, 1.0)).xyz;
float q2 = dot(q, q);
float qw = dot(q, w);
if (q2 > 1.0)
{
if (qw >= 0.0)
{
return czm_emptyRaySegment;
}
else
{
float qw2 = qw * qw;
float difference = q2 - 1.0;
float w2 = dot(w, w);
float product = w2 * difference;
if (qw2 < product)
{
return czm_emptyRaySegment;
}
else if (qw2 > product)
{
float discriminant = qw * qw - product;
float temp = -qw + sqrt(discriminant);
float root0 = temp / w2;
float root1 = difference / temp;
if (root0 < root1)
{
czm_raySegment i = czm_raySegment(root0, root1);
return i;
}
else
{
czm_raySegment i = czm_raySegment(root1, root0);
return i;
}
}
else
{
float root = sqrt(difference / w2);
czm_raySegment i = czm_raySegment(root, root);
return i;
}
}
}
else if (q2 < 1.0)
{
float difference = q2 - 1.0;
float w2 = dot(w, w);
float product = w2 * difference;
float discriminant = qw * qw - product;
float temp = -qw + sqrt(discriminant);
czm_raySegment i = czm_raySegment(0.0, temp / w2);
return i;
}
else
{
if (qw < 0.0)
{
float w2 = dot(w, w);
czm_raySegment i = czm_raySegment(0.0, -qw / w2);
return i;
}
else
{
return czm_emptyRaySegment;
}
}
}
`; var CO = `czm_raySegment czm_raySphereIntersectionInterval(czm_ray ray, vec3 center, float radius)
{
vec3 o = ray.origin;
vec3 d = ray.direction;
vec3 oc = o - center;
float a = dot(d, d);
float b = 2.0 * dot(d, oc);
float c = dot(oc, oc) - (radius * radius);
float det = (b * b) - (4.0 * a * c);
if (det < 0.0) {
return czm_emptyRaySegment;
}
float sqrtDet = sqrt(det);
float t0 = (-b - sqrtDet) / (2.0 * a);
float t1 = (-b + sqrtDet) / (2.0 * a);
czm_raySegment result = czm_raySegment(t0, t1);
return result;
}
`; var xO = `float czm_readDepth(sampler2D depthTexture, vec2 texCoords)
{
return czm_reverseLogDepth(texture2D(depthTexture, texCoords).r);
}
`; var TO = `float czm_readNonPerspective(float value, float oneOverW) {
return value * oneOverW;
}
vec2 czm_readNonPerspective(vec2 value, float oneOverW) {
return value * oneOverW;
}
vec3 czm_readNonPerspective(vec3 value, float oneOverW) {
return value * oneOverW;
}
vec4 czm_readNonPerspective(vec4 value, float oneOverW) {
return value * oneOverW;
}
`; var EO = `float czm_reverseLogDepth(float logZ)
{
#ifdef LOG_DEPTH
float near = czm_currentFrustum.x;
float far = czm_currentFrustum.y;
float log2Depth = logZ * czm_log2FarDepthFromNearPlusOne;
float depthFromNear = pow(2.0, log2Depth) - 1.0;
return far * (1.0 - near / (depthFromNear + near)) / (far - near);
#endif
return logZ;
}
`; var bO = `const vec4 K_RGB2HSB = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
vec3 czm_RGBToHSB(vec3 rgb)
{
vec4 p = mix(vec4(rgb.bg, K_RGB2HSB.wz), vec4(rgb.gb, K_RGB2HSB.xy), step(rgb.b, rgb.g));
vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));
float d = q.x - min(q.w, q.y);
return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + czm_epsilon7)), d / (q.x + czm_epsilon7), q.x);
}
`; var SO = `vec3 RGBtoHCV(vec3 rgb)
{
vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0 / 3.0) : vec4(rgb.gb, 0.0, -1.0 / 3.0);
vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);
float c = q.x - min(q.w, q.y);
float h = abs((q.w - q.y) / (6.0 * c + czm_epsilon7) + q.z);
return vec3(h, c, q.x);
}
vec3 czm_RGBToHSL(vec3 rgb)
{
vec3 hcv = RGBtoHCV(rgb);
float l = hcv.z - hcv.y * 0.5;
float s = hcv.y / (1.0 - abs(l * 2.0 - 1.0) + czm_epsilon7);
return vec3(hcv.x, s, l);
}
`; var wO = `vec3 czm_RGBToXYZ(vec3 rgb)
{
const mat3 RGB2XYZ = mat3(0.4124, 0.2126, 0.0193,
0.3576, 0.7152, 0.1192,
0.1805, 0.0722, 0.9505);
vec3 xyz = RGB2XYZ * rgb;
vec3 Yxy;
Yxy.r = xyz.g;
float temp = dot(vec3(1.0), xyz);
Yxy.gb = xyz.rg / temp;
return Yxy;
}
`; var DO = `float czm_round(float value) {
return floor(value + 0.5);
}
vec2 czm_round(vec2 value) {
return floor(value + 0.5);
}
vec3 czm_round(vec3 value) {
return floor(value + 0.5);
}
vec4 czm_round(vec4 value) {
return floor(value + 0.5);
}
`; var vO = `vec3 czm_sampleOctahedralProjectionWithFiltering(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod)
{
direction /= dot(vec3(1.0), abs(direction));
vec2 rev = abs(direction.zx) - vec2(1.0);
vec2 neg = vec2(direction.x < 0.0 ? rev.x : -rev.x,
direction.z < 0.0 ? rev.y : -rev.y);
vec2 uv = direction.y < 0.0 ? neg : direction.xz;
vec2 coord = 0.5 * uv + vec2(0.5);
vec2 pixel = 1.0 / textureSize;
if (lod > 0.0)
{
float scale = 1.0 / pow(2.0, lod);
float offset = ((textureSize.y + 1.0) / textureSize.x);
coord.x *= offset;
coord *= scale;
coord.x += offset + pixel.x;
coord.y += (1.0 - (1.0 / pow(2.0, lod - 1.0))) + pixel.y * (lod - 1.0) * 2.0;
}
else
{
coord.x *= (textureSize.y / textureSize.x);
}
#ifndef OES_texture_float_linear
vec3 color1 = texture2D(projectedMap, coord + vec2(0.0, pixel.y)).rgb;
vec3 color2 = texture2D(projectedMap, coord + vec2(pixel.x, 0.0)).rgb;
vec3 color3 = texture2D(projectedMap, coord + pixel).rgb;
vec3 color4 = texture2D(projectedMap, coord).rgb;
vec2 texturePosition = coord * textureSize;
float fu = fract(texturePosition.x);
float fv = fract(texturePosition.y);
vec3 average1 = mix(color4, color2, fu);
vec3 average2 = mix(color1, color3, fu);
vec3 color = mix(average1, average2, fv);
#else
vec3 color = texture2D(projectedMap, coord).rgb;
#endif
return color;
}
vec3 czm_sampleOctahedralProjection(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod, float maxLod) {
float currentLod = floor(lod + 0.5);
float nextLod = min(currentLod + 1.0, maxLod);
vec3 colorCurrentLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, currentLod);
vec3 colorNextLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, nextLod);
return mix(colorNextLod, colorCurrentLod, nextLod - lod);
}
`; var PO = `vec3 czm_saturation(vec3 rgb, float adjustment)
{
const vec3 W = vec3(0.2125, 0.7154, 0.0721);
vec3 intensity = vec3(dot(rgb, W));
return mix(intensity, rgb, adjustment);
}
`; var IO = `float czm_sampleShadowMap(highp samplerCube shadowMap, vec3 d)
{
return czm_unpackDepth(textureCube(shadowMap, d));
}
float czm_sampleShadowMap(highp sampler2D shadowMap, vec2 uv)
{
#ifdef USE_SHADOW_DEPTH_TEXTURE
return texture2D(shadowMap, uv).r;
#else
return czm_unpackDepth(texture2D(shadowMap, uv));
#endif
}
float czm_shadowDepthCompare(samplerCube shadowMap, vec3 uv, float depth)
{
return step(depth, czm_sampleShadowMap(shadowMap, uv));
}
float czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth)
{
return step(depth, czm_sampleShadowMap(shadowMap, uv));
}
`; var OO = `float czm_private_shadowVisibility(float visibility, float nDotL, float normalShadingSmooth, float darkness)
{
#ifdef USE_NORMAL_SHADING
#ifdef USE_NORMAL_SHADING_SMOOTH
float strength = clamp(nDotL / normalShadingSmooth, 0.0, 1.0);
#else
float strength = step(0.0, nDotL);
#endif
visibility *= strength;
#endif
visibility = max(visibility, darkness);
return visibility;
}
#ifdef USE_CUBE_MAP_SHADOW
float czm_shadowVisibility(samplerCube shadowMap, czm_shadowParameters shadowParameters)
{
float depthBias = shadowParameters.depthBias;
float depth = shadowParameters.depth;
float nDotL = shadowParameters.nDotL;
float normalShadingSmooth = shadowParameters.normalShadingSmooth;
float darkness = shadowParameters.darkness;
vec3 uvw = shadowParameters.texCoords;
depth -= depthBias;
float visibility = czm_shadowDepthCompare(shadowMap, uvw, depth);
return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);
}
#else
float czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters)
{
float depthBias = shadowParameters.depthBias;
float depth = shadowParameters.depth;
float nDotL = shadowParameters.nDotL;
float normalShadingSmooth = shadowParameters.normalShadingSmooth;
float darkness = shadowParameters.darkness;
vec2 uv = shadowParameters.texCoords;
depth -= depthBias;
#ifdef USE_SOFT_SHADOWS
vec2 texelStepSize = shadowParameters.texelStepSize;
float radius = 1.0;
float dx0 = -texelStepSize.x * radius;
float dy0 = -texelStepSize.y * radius;
float dx1 = texelStepSize.x * radius;
float dy1 = texelStepSize.y * radius;
float visibility = (
czm_shadowDepthCompare(shadowMap, uv, depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)
) * (1.0 / 9.0);
#else
float visibility = czm_shadowDepthCompare(shadowMap, uv, depth);
#endif
return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);
}
#endif
`; var BO = `float czm_signNotZero(float value)
{
return value >= 0.0 ? 1.0 : -1.0;
}
vec2 czm_signNotZero(vec2 value)
{
return vec2(czm_signNotZero(value.x), czm_signNotZero(value.y));
}
vec3 czm_signNotZero(vec3 value)
{
return vec3(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z));
}
vec4 czm_signNotZero(vec4 value)
{
return vec4(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z), czm_signNotZero(value.w));
}
`; var RO = `vec3 czm_sphericalHarmonics(vec3 normal, vec3 coefficients[9])
{
vec3 L00 = coefficients[0];
vec3 L1_1 = coefficients[1];
vec3 L10 = coefficients[2];
vec3 L11 = coefficients[3];
vec3 L2_2 = coefficients[4];
vec3 L2_1 = coefficients[5];
vec3 L20 = coefficients[6];
vec3 L21 = coefficients[7];
vec3 L22 = coefficients[8];
float x = normal.x;
float y = normal.y;
float z = normal.z;
return
L00
+ L1_1 * y
+ L10 * z
+ L11 * x
+ L2_2 * (y * x)
+ L2_1 * (y * z)
+ L20 * (3.0 * z * z - 1.0)
+ L21 * (z * x)
+ L22 * (x * x - y * y);
}
`; var MO = `vec3 czm_srgbToLinear(vec3 srgbIn)
{
return pow(srgbIn, vec3(2.2));
}
vec4 czm_srgbToLinear(vec4 srgbIn)
{
vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));
return vec4(linearOut, srgbIn.a);
}
`; var LO = `mat3 czm_tangentToEyeSpaceMatrix(vec3 normalEC, vec3 tangentEC, vec3 bitangentEC)
{
vec3 normal = normalize(normalEC);
vec3 tangent = normalize(tangentEC);
vec3 bitangent = normalize(bitangentEC);
return mat3(tangent.x  , tangent.y  , tangent.z,
bitangent.x, bitangent.y, bitangent.z,
normal.x   , normal.y   , normal.z);
}
`; var FO = `vec4 czm_transformPlane(vec4 plane, mat4 transform) {
vec4 transformedPlane = transform * plane;
float normalMagnitude = length(transformedPlane.xyz);
return transformedPlane / normalMagnitude;
}
`; var NO = `vec4 czm_translateRelativeToEye(vec3 high, vec3 low)
{
vec3 highDifference = high - czm_encodedCameraPositionMCHigh;
vec3 lowDifference = low - czm_encodedCameraPositionMCLow;
return vec4(highDifference + lowDifference, 1.0);
}
`; var VO = `vec4 czm_translucentPhong(vec3 toEye, czm_material material, vec3 lightDirectionEC)
{
float diffuse = czm_getLambertDiffuse(vec3(0.0, 0.0, 1.0), material.normal);
if (czm_sceneMode == czm_sceneMode3D) {
diffuse += czm_getLambertDiffuse(vec3(0.0, 1.0, 0.0), material.normal);
}
diffuse = clamp(diffuse, 0.0, 1.0);
float specular = czm_getSpecular(lightDirectionEC, toEye, material.normal, material.shininess);
vec3 materialDiffuse = material.diffuse * 0.5;
vec3 ambient = materialDiffuse;
vec3 color = ambient + material.emission;
color += materialDiffuse * diffuse * czm_lightColor;
color += material.specular * specular * czm_lightColor;
return vec4(color, material.alpha);
}
`; var kO = `mat2 czm_transpose(mat2 matrix)
{
return mat2(
matrix[0][0], matrix[1][0],
matrix[0][1], matrix[1][1]);
}
mat3 czm_transpose(mat3 matrix)
{
return mat3(
matrix[0][0], matrix[1][0], matrix[2][0],
matrix[0][1], matrix[1][1], matrix[2][1],
matrix[0][2], matrix[1][2], matrix[2][2]);
}
mat4 czm_transpose(mat4 matrix)
{
return mat4(
matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0],
matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1],
matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2],
matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);
}
`; var UO = `float czm_unpackDepth(vec4 packedDepth)
{
return dot(packedDepth, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
}
`; var zO = `float czm_unpackFloat(vec4 packedFloat)
{
packedFloat = floor(packedFloat * 255.0 + 0.5);
float sign = 1.0 - step(128.0, packedFloat[3]) * 2.0;
float exponent = 2.0 * mod(packedFloat[3], 128.0) + step(128.0, packedFloat[2]) - 127.0;
if (exponent == -127.0)
{
return 0.0;
}
float mantissa = mod(packedFloat[2], 128.0) * 65536.0 + packedFloat[1] * 256.0 + packedFloat[0] + float(0x800000);
float result = sign * exp2(exponent - 23.0) * mantissa;
return result;
}
`; var HO = `int czm_unpackUint(float packedValue) {
float rounded = czm_round(packedValue * 255.0);
return int(rounded);
}
int czm_unpackUint(vec2 packedValue) {
vec2 rounded = czm_round(packedValue * 255.0);
return int(dot(rounded, vec2(1.0, 256.0)));
}
int czm_unpackUint(vec3 packedValue) {
vec3 rounded = czm_round(packedValue * 255.0);
return int(dot(rounded, vec3(1.0, 256.0, 65536.0)));
}
int czm_unpackUint(vec4 packedValue) {
vec4 rounded = czm_round(packedValue * 255.0);
return int(dot(rounded, vec4(1.0, 256.0, 65536.0, 16777216.0)));
}
`; var GO = `float czm_valueTransform(float offset, float scale, float value) {
return scale * value + offset;
}
vec2 czm_valueTransform(vec2 offset, vec2 scale, vec2 value) {
return scale * value + offset;
}
vec3 czm_valueTransform(vec3 offset, vec3 scale, vec3 value) {
return scale * value + offset;
}
vec4 czm_valueTransform(vec4 offset, vec4 scale, vec4 value) {
return scale * value + offset;
}
mat2 czm_valueTransform(mat2 offset, mat2 scale, mat2 value) {
return matrixCompMult(scale, value) + offset;
}
mat3 czm_valueTransform(mat3 offset, mat3 scale, mat3 value) {
return matrixCompMult(scale, value) + offset;
}
mat4 czm_valueTransform(mat4 offset, mat4 scale, mat4 value) {
return matrixCompMult(scale, value) + offset;
}
`; var WO = `#ifdef LOG_DEPTH
varying float v_depthFromNearPlusOne;
#ifdef SHADOW_MAP
varying vec3 v_logPositionEC;
#endif
#endif
vec4 czm_updatePositionDepth(vec4 coords) {
#if defined(LOG_DEPTH)
#ifdef SHADOW_MAP
vec3 logPositionEC = (czm_inverseProjection * coords).xyz;
v_logPositionEC = logPositionEC;
#endif
coords.z = clamp(coords.z / coords.w, -1.0, 1.0) * coords.w;
#endif
return coords;
}
void czm_vertexLogDepth()
{
#ifdef LOG_DEPTH
v_depthFromNearPlusOne = (gl_Position.w - czm_currentFrustum.x) + 1.0;
gl_Position = czm_updatePositionDepth(gl_Position);
#endif
}
void czm_vertexLogDepth(vec4 clipCoords)
{
#ifdef LOG_DEPTH
v_depthFromNearPlusOne = (clipCoords.w - czm_currentFrustum.x) + 1.0;
czm_updatePositionDepth(clipCoords);
#endif
}
`; var jO = `vec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate)
{
float x = 2.0 * (fragmentCoordinate.x - czm_viewport.x) / czm_viewport.z - 1.0;
float y = 2.0 * (fragmentCoordinate.y - czm_viewport.y) / czm_viewport.w - 1.0;
float z = (fragmentCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];
vec4 q = vec4(x, y, z, 1.0);
q /= fragmentCoordinate.w;
if (!(czm_inverseProjection == mat4(0.0)))
{
q = czm_inverseProjection * q;
}
else
{
float top = czm_frustumPlanes.x;
float bottom = czm_frustumPlanes.y;
float left = czm_frustumPlanes.z;
float right = czm_frustumPlanes.w;
float near = czm_currentFrustum.x;
float far = czm_currentFrustum.y;
q.x = (q.x * (right - left) + left + right) * 0.5;
q.y = (q.y * (top - bottom) + bottom + top) * 0.5;
q.z = (q.z * (near - far) - near - far) * 0.5;
q.w = 1.0;
}
return q;
}
vec4 czm_windowToEyeCoordinates(vec2 fragmentCoordinateXY, float depthOrLogDepth)
{
#ifdef LOG_DEPTH
float near = czm_currentFrustum.x;
float far = czm_currentFrustum.y;
float log2Depth = depthOrLogDepth * czm_log2FarDepthFromNearPlusOne;
float depthFromNear = pow(2.0, log2Depth) - 1.0;
float depthFromCamera = depthFromNear + near;
vec4 windowCoord = vec4(fragmentCoordinateXY, far * (1.0 - near / depthFromCamera) / (far - near), 1.0);
vec4 eyeCoordinate = czm_windowToEyeCoordinates(windowCoord);
eyeCoordinate.w = 1.0 / depthFromCamera;
return eyeCoordinate;
#else
vec4 windowCoord = vec4(fragmentCoordinateXY, depthOrLogDepth, 1.0);
vec4 eyeCoordinate = czm_windowToEyeCoordinates(windowCoord);
#endif
return eyeCoordinate;
}
`; var qO = `#if defined(GL_EXT_frag_depth) && !defined(LOG_DEPTH)
varying float v_WindowZ;
#endif
void czm_writeDepthClamp()
{
#if defined(GL_EXT_frag_depth) && !defined(LOG_DEPTH)
gl_FragDepthEXT = clamp(v_WindowZ * gl_FragCoord.w, 0.0, 1.0);
#endif
}
`; var YO = `#ifdef LOG_DEPTH
varying float v_depthFromNearPlusOne;
#ifdef POLYGON_OFFSET
uniform vec2 u_polygonOffset;
#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif
#endif
#endif
void czm_writeLogDepth(float depth)
{
#if defined(GL_EXT_frag_depth) && defined(LOG_DEPTH)
if (depth <= 0.9999999 || depth > czm_farDepthFromNearPlusOne) {
discard;
}
#ifdef POLYGON_OFFSET
float factor = u_polygonOffset[0];
float units = u_polygonOffset[1];
#ifdef GL_OES_standard_derivatives
if (factor != 0.0) {
float x = dFdx(depth);
float y = dFdy(depth);
float m = sqrt(x * x + y * y);
depth += m * factor;
}
#endif
#endif
gl_FragDepthEXT = log2(depth) * czm_oneOverLog2FarDepthFromNearPlusOne;
#ifdef POLYGON_OFFSET
gl_FragDepthEXT += czm_epsilon7 * units;
#endif
#endif
}
void czm_writeLogDepth() {
#ifdef LOG_DEPTH
czm_writeLogDepth(v_depthFromNearPlusOne);
#endif
}
`; var XO = `float czm_writeNonPerspective(float value, float w) {
return value * w;
}
vec2 czm_writeNonPerspective(vec2 value, float w) {
return value * w;
}
vec3 czm_writeNonPerspective(vec3 value, float w) {
return value * w;
}
vec4 czm_writeNonPerspective(vec4 value, float w) {
return value * w;
}
`; var KO = `vec3 czm_XYZToRGB(vec3 Yxy)
{
const mat3 XYZ2RGB = mat3( 3.2405, -0.9693,  0.0556,
-1.5371,  1.8760, -0.2040,
-0.4985,  0.0416,  1.0572);
vec3 xyz;
xyz.r = Yxy.r * Yxy.g / Yxy.b;
xyz.g = Yxy.r;
xyz.b = Yxy.r * (1.0 - Yxy.g - Yxy.b) / Yxy.b;
return XYZ2RGB * xyz;
}
`; var uC = { czm_degreesPerRadian: P1, czm_depthRange: I1, czm_epsilon1: O1, czm_epsilon2: B1, czm_epsilon3: R1, czm_epsilon4: M1, czm_epsilon5: L1, czm_epsilon6: F1, czm_epsilon7: N1, czm_infinity: V1, czm_oneOverPi: k1, czm_oneOverTwoPi: U1, czm_passCesium3DTile: z1, czm_passCesium3DTileClassification: H1, czm_passCesium3DTileClassificationIgnoreShow: G1, czm_passClassification: W1, czm_passCompute: j1, czm_passEnvironment: q1, czm_passGlobe: Y1, czm_passOpaque: X1, czm_passOverlay: K1, czm_passTerrainClassification: J1, czm_passTranslucent: Z1, czm_pi: Q1, czm_piOverFour: $1, czm_piOverSix: eI, czm_piOverThree: tI, czm_piOverTwo: nI, czm_radiansPerDegree: iI, czm_sceneMode2D: oI, czm_sceneMode3D: rI, czm_sceneModeColumbusView: sI, czm_sceneModeMorphing: aI, czm_solarRadius: cI, czm_threePiOver2: lI, czm_twoPi: uI, czm_webMercatorMaxLatitude: fI, czm_depthRangeStruct: dI, czm_material: hI, czm_materialInput: mI, czm_modelMaterial: pI, czm_modelVertexOutput: _I, czm_pbrParameters: gI, czm_ray: yI, czm_raySegment: AI, czm_shadowParameters: CI, czm_acesTonemapping: xI, czm_alphaWeight: TI, czm_antialias: EI, czm_approximateSphericalCoordinates: bI, czm_backFacing: SI, czm_branchFreeTernary: wI, czm_cascadeColor: DI, czm_cascadeDistance: vI, czm_cascadeMatrix: PI, czm_cascadeWeights: II, czm_columbusViewMorph: OI, czm_computePosition: BI, czm_cosineAndSine: RI, czm_decompressTextureCoordinates: MI, czm_defaultPbrMaterial: LI, czm_depthClamp: FI, czm_eastNorthUpToEyeCoordinates: NI, czm_ellipsoidContainsPoint: VI, czm_ellipsoidWgs84TextureCoordinates: kI, czm_equalsEpsilon: UI, czm_eyeOffset: zI, czm_eyeToWindowCoordinates: HI, czm_fastApproximateAtan: GI, czm_fog: WI, czm_gammaCorrect: jI, czm_geodeticSurfaceNormal: qI, czm_getDefaultMaterial: YI, czm_getLambertDiffuse: XI, czm_getSpecular: KI, czm_getWaterNoise: JI, czm_HSBToRGB: ZI, czm_HSLToRGB: QI, czm_hue: $I, czm_inverseGamma: eO, czm_isEmpty: tO, czm_isFull: nO, czm_latitudeToWebMercatorFraction: iO, czm_linearToSrgb: oO, czm_lineDistance: rO, czm_luminance: sO, czm_metersPerPixel: aO, czm_modelToWindowCoordinates: cO, czm_multiplyWithColorBalance: lO, czm_nearFarScalar: uO, czm_octDecode: fO, czm_packDepth: dO, czm_pbrLighting: hO, czm_pbrMetallicRoughnessMaterial: mO, czm_pbrSpecularGlossinessMaterial: pO, czm_phong: _O, czm_planeDistance: gO, czm_pointAlongRay: yO, czm_rayEllipsoidIntersectionInterval: AO, czm_raySphereIntersectionInterval: CO, czm_readDepth: xO, czm_readNonPerspective: TO, czm_reverseLogDepth: EO, czm_RGBToHSB: bO, czm_RGBToHSL: SO, czm_RGBToXYZ: wO, czm_round: DO, czm_sampleOctahedralProjection: vO, czm_saturation: PO, czm_shadowDepthCompare: IO, czm_shadowVisibility: OO, czm_signNotZero: BO, czm_sphericalHarmonics: RO, czm_srgbToLinear: MO, czm_tangentToEyeSpaceMatrix: LO, czm_transformPlane: FO, czm_translateRelativeToEye: NO, czm_translucentPhong: VO, czm_transpose: kO, czm_unpackDepth: UO, czm_unpackFloat: zO, czm_unpackUint: HO, czm_valueTransform: GO, czm_vertexLogDepth: WO, czm_windowToEyeCoordinates: jO, czm_writeDepthClamp: qO, czm_writeLogDepth: YO, czm_writeNonPerspective: XO, czm_XYZToRGB: KO }; function UK(e) {
        return e = e.replace(/\/\/.*/g, ""), e.replace(/\/\*\*[\s\S]*?\*\//gm, function (t) {
            let n = t.match(/\n/gm).length, i = ""; for (let o = 0; o < n; ++o)i += `
`; return i
        })
    } function zK(e, t, n) { let i; for (let o = 0; o < n.length; ++o)n[o].name === e && (i = n[o]); return l(i) || (t = UK(t), i = { name: e, glslSource: t, dependsOn: [], requiredBy: [], evaluated: !1 }, n.push(i)), i } function HK(e, t) { if (e.evaluated) return; e.evaluated = !0; let n = e.glslSource.match(/\bczm_[a-zA-Z0-9_]*/g); l(n) && n !== null && (n = n.filter(function (i, o) { return n.indexOf(i) === o }), n.forEach(function (i) { if (i !== e.name && as._czmBuiltinsAndUniforms.hasOwnProperty(i)) { let o = zK(i, as._czmBuiltinsAndUniforms[i], t); e.dependsOn.push(o), o.requiredBy.push(e), HK(o, t) } })) } function vbe(e) { let t = [], n = []; for (; e.length > 0;) { let o = e.pop(); n.push(o), o.requiredBy.length === 0 && t.push(o) } for (; t.length > 0;) { let o = t.shift(); e.push(o); for (let r = 0; r < o.dependsOn.length; ++r) { let s = o.dependsOn[r], a = s.requiredBy.indexOf(o); s.requiredBy.splice(a, 1), s.requiredBy.length === 0 && t.push(s) } } let i = []; for (let o = 0; o < n.length; ++o)n[o].requiredBy.length !== 0 && i.push(n[o]) } function Pbe(e) {
        let t = [], n = zK("main", e, t); HK(n, t), vbe(t); let i = ""; for (let o = t.length - 1; o >= 0; --o)i = `${i + t[o].glslSource}
`; return i.replace(n.glslSource, "")
    } function GK(e, t, n) {
        let i, o, r = "", s = e.sources; if (l(s)) for (i = 0, o = s.length; i < o; ++i)r += `
#line 0
${s[i]}`; r = UK(r); let a; r = r.replace(/#version\s+(.*?)\n/gm, function (g, m) {
            return a = m, `
`}); let c = []; r = r.replace(/#extension.*\n/gm, function (g) {
                return c.push(g), `
`}), r = r.replace(/precision\s(lowp|mediump|highp)\s(float|int);/, ""); let u = e.pickColorQualifier; l(u) && (r = as.createPickFragmentShaderSource(r, u)); let f = ""; l(a) && (f = `#version ${a}
`); let d = c.length; for (i = 0; i < d; i++)f += c[i]; t && (f += `#ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    precision highp int;
#else
    precision mediump float;
    precision mediump int;
    #define highp mediump
#endif

`); let p = e.defines; if (l(p)) for (i = 0, o = p.length; i < o; ++i) {
            let g = p[i]; g.length !== 0 && (f += `#define ${g}
`)
        } return n.webgl2 && (f += `#define OUTPUT_DECLARATION

`), n.textureFloatLinear && (f += `#define OES_texture_float_linear

`), n.floatingPointTexture && (f += `#define OES_texture_float

`), e.includeBuiltIns && (f += Pbe(r)), f += `
#line 0
`, f += r, n.webgl2 && (f = v1(f, t, !0)), f
    } function as(e) { e = y(e, y.EMPTY_OBJECT); let t = e.pickColorQualifier; this.defines = l(e.defines) ? e.defines.slice(0) : [], this.sources = l(e.sources) ? e.sources.slice(0) : [], this.pickColorQualifier = t, this.includeBuiltIns = y(e.includeBuiltIns, !0) } as.prototype.clone = function () { return new as({ sources: this.sources, defines: this.defines, pickColorQualifier: this.pickColorQualifier, includeBuiltIns: this.includeBuiltIns }) }; as.replaceMain = function (e, t) { return t = `void ${t}()`, e.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, t) }; as.prototype.getCacheKey = function () {
        let t = this.defines.slice().sort().join(","), n = this.pickColorQualifier, i = this.includeBuiltIns, o = this.sources.join(`
`); return `${t}:${n}:${i}:${o}`
    }; as.prototype.createCombinedVertexShader = function (e) { return GK(this, !1, e) }; as.prototype.createCombinedFragmentShader = function (e) { return GK(this, !0, e) }; as._czmBuiltinsAndUniforms = {}; for (let e in uC) uC.hasOwnProperty(e) && (as._czmBuiltinsAndUniforms[e] = uC[e]); for (let e in Fp) if (Fp.hasOwnProperty(e)) { let t = Fp[e]; typeof t.getDeclaration == "function" && (as._czmBuiltinsAndUniforms[e] = t.getDeclaration(e)) } as.createPickVertexShaderSource = function (e) {
        return `${as.replaceMain(e, "czm_old_main")}
attribute vec4 pickColor; 
varying vec4 czm_pickColor; 
void main() 
{ 
    czm_old_main(); 
    czm_pickColor = pickColor; 
}`}; as.createPickFragmentShaderSource = function (e, t) {
        let n = as.replaceMain(e, "czm_old_main"), i = `${t} vec4 czm_pickColor; 
void main() 
{ 
    czm_old_main(); 
    if (gl_FragColor.a == 0.0) { 
       discard; 
    } 
    gl_FragColor = czm_pickColor; 
}`; return `${n}
${i}`
    }; function Ibe(e, t) { let n = e.defines, i = n.length; for (let o = 0; o < i; ++o)if (n[o] === t) return !0; return !1 } function WK(e, t) { let n = e.sources, i = n.length; for (let o = 0; o < i; ++o)if (n[o].indexOf(t) !== -1) return !0; return !1 } function jK(e, t) { let n = t.length; for (let i = 0; i < n; ++i) { let o = t[i]; if (WK(e, o)) return o } } var Obe = ["v_normalEC", "v_normal"]; as.findNormalVarying = function (e) { return WK(e, "#ifdef HAS_NORMALS") ? Ibe(e, "HAS_NORMALS") ? "v_normalEC" : void 0 : jK(e, Obe) }; var Bbe = ["v_positionEC"]; as.findPositionVarying = function (e) { return jK(e, Bbe) }; var Ue = as; var JO = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;
attribute float batchId;
#ifdef EXTRUDED_GEOMETRY
attribute vec3 extrudeDirection;
uniform float u_globeMinimumAltitude;
#endif // EXTRUDED_GEOMETRY
#ifdef PER_INSTANCE_COLOR
varying vec4 v_color;
#endif // PER_INSTANCE_COLOR
#ifdef TEXTURE_COORDINATES
#ifdef SPHERICAL
varying vec4 v_sphericalExtents;
#else // SPHERICAL
varying vec2 v_inversePlaneExtents;
varying vec4 v_westPlane;
varying vec4 v_southPlane;
#endif // SPHERICAL
varying vec3 v_uvMinAndSphericalLongitudeRotation;
varying vec3 v_uMaxAndInverseDistance;
varying vec3 v_vMaxAndInverseDistance;
#endif // TEXTURE_COORDINATES
void main()
{
vec4 position = czm_computePosition();
#ifdef EXTRUDED_GEOMETRY
float delta = min(u_globeMinimumAltitude, czm_geometricToleranceOverMeter * length(position.xyz));
delta *= czm_sceneMode == czm_sceneMode3D ? 1.0 : 0.0;
position = position + vec4(extrudeDirection * delta, 0.0);
#endif
#ifdef TEXTURE_COORDINATES
#ifdef SPHERICAL
v_sphericalExtents = czm_batchTable_sphericalExtents(batchId);
v_uvMinAndSphericalLongitudeRotation.z = czm_batchTable_longitudeRotation(batchId);
#else // SPHERICAL
#ifdef COLUMBUS_VIEW_2D
vec4 planes2D_high = czm_batchTable_planes2D_HIGH(batchId);
vec4 planes2D_low = czm_batchTable_planes2D_LOW(batchId);
vec2 idlSplitNewPlaneHiLow = vec2(EAST_MOST_X_HIGH - (WEST_MOST_X_HIGH - planes2D_high.w), EAST_MOST_X_LOW - (WEST_MOST_X_LOW - planes2D_low.w));
bool idlSplit = planes2D_high.x > planes2D_high.w && position3DLow.y > 0.0;
planes2D_high.w = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.x, planes2D_high.w);
planes2D_low.w = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.y, planes2D_low.w);
idlSplit = planes2D_high.x > planes2D_high.w && position3DLow.y < 0.0;
idlSplitNewPlaneHiLow = vec2(WEST_MOST_X_HIGH - (EAST_MOST_X_HIGH - planes2D_high.x), WEST_MOST_X_LOW - (EAST_MOST_X_LOW - planes2D_low.x));
planes2D_high.x = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.x, planes2D_high.x);
planes2D_low.x = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.y, planes2D_low.x);
vec3 southWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.xy), vec3(0.0, planes2D_low.xy))).xyz;
vec3 northWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.x, planes2D_high.z), vec3(0.0, planes2D_low.x, planes2D_low.z))).xyz;
vec3 southEastCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.w, planes2D_high.y), vec3(0.0, planes2D_low.w, planes2D_low.y))).xyz;
#else // COLUMBUS_VIEW_2D
vec3 southWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(czm_batchTable_southWest_HIGH(batchId), czm_batchTable_southWest_LOW(batchId))).xyz;
vec3 northWestCorner = czm_normal * czm_batchTable_northward(batchId) + southWestCorner;
vec3 southEastCorner = czm_normal * czm_batchTable_eastward(batchId) + southWestCorner;
#endif // COLUMBUS_VIEW_2D
vec3 eastWard = southEastCorner - southWestCorner;
float eastExtent = length(eastWard);
eastWard /= eastExtent;
vec3 northWard = northWestCorner - southWestCorner;
float northExtent = length(northWard);
northWard /= northExtent;
v_westPlane = vec4(eastWard, -dot(eastWard, southWestCorner));
v_southPlane = vec4(northWard, -dot(northWard, southWestCorner));
v_inversePlaneExtents = vec2(1.0 / eastExtent, 1.0 / northExtent);
#endif // SPHERICAL
vec4 uvMinAndExtents = czm_batchTable_uvMinAndExtents(batchId);
vec4 uMaxVmax = czm_batchTable_uMaxVmax(batchId);
v_uMaxAndInverseDistance = vec3(uMaxVmax.xy, uvMinAndExtents.z);
v_vMaxAndInverseDistance = vec3(uMaxVmax.zw, uvMinAndExtents.w);
v_uvMinAndSphericalLongitudeRotation.xy = uvMinAndExtents.xy;
#endif // TEXTURE_COORDINATES
#ifdef PER_INSTANCE_COLOR
v_color = czm_batchTable_color(batchId);
#endif
gl_Position = czm_depthClamp(czm_modelViewProjectionRelativeToEye * position);
}
`; var _0 = `#ifdef GL_EXT_frag_depth
#extension GL_EXT_frag_depth : enable
#endif
#ifdef VECTOR_TILE
uniform vec4 u_highlightColor;
#endif
void main(void)
{
#ifdef VECTOR_TILE
gl_FragColor = czm_gammaCorrect(u_highlightColor);
#else
gl_FragColor = vec4(1.0);
#endif
czm_writeDepthClamp();
}
`; var qK = { TERRAIN: 0, CESIUM_3D_TILE: 1, BOTH: 2 }; qK.NUMBER_OF_CLASSIFICATION_TYPES = 3; var Ln = Object.freeze(qK); var Rbe = { NEVER: te.NEVER, LESS: te.LESS, EQUAL: te.EQUAL, LESS_OR_EQUAL: te.LEQUAL, GREATER: te.GREATER, NOT_EQUAL: te.NOTEQUAL, GREATER_OR_EQUAL: te.GEQUAL, ALWAYS: te.ALWAYS }, Ja = Object.freeze(Rbe); function Id() { this.high = h.clone(h.ZERO), this.low = h.clone(h.ZERO) } Id.encode = function (e, t) { l(t) || (t = { high: 0, low: 0 }); let n; return e >= 0 ? (n = Math.floor(e / 65536) * 65536, t.high = n, t.low = e - n) : (n = Math.floor(-e / 65536) * 65536, t.high = -n, t.low = e + n), t }; var nm = { high: 0, low: 0 }; Id.fromCartesian = function (e, t) { l(t) || (t = new Id); let n = t.high, i = t.low; return Id.encode(e.x, nm), n.x = nm.high, i.x = nm.low, Id.encode(e.y, nm), n.y = nm.high, i.y = nm.low, Id.encode(e.z, nm), n.z = nm.high, i.z = nm.low, t }; var XH = new Id; Id.writeElements = function (e, t, n) { Id.fromCartesian(e, XH); let i = XH.high, o = XH.low; t[n] = i.x, t[n + 1] = i.y, t[n + 2] = i.z, t[n + 3] = o.x, t[n + 4] = o.y, t[n + 5] = o.z }; var Vn = Id; function Mbe(e, t) { let n = [], i = e.length, o = 0; for (; o < i;) { let r = Math.ceil((i - o) / t--); n.push(e.slice(o, o + r)), o += r } return n } var ZO = Mbe; var QO = { STREAM_DRAW: te.STREAM_DRAW, STATIC_DRAW: te.STATIC_DRAW, DYNAMIC_DRAW: te.DYNAMIC_DRAW, validate: function (e) { return e === QO.STREAM_DRAW || e === QO.STATIC_DRAW || e === QO.DYNAMIC_DRAW } }, Re = Object.freeze(QO); var cs = { UNSIGNED_BYTE: te.UNSIGNED_BYTE, UNSIGNED_SHORT: te.UNSIGNED_SHORT, UNSIGNED_INT: te.UNSIGNED_INT }; cs.getSizeInBytes = function (e) { switch (e) { case cs.UNSIGNED_BYTE: return Uint8Array.BYTES_PER_ELEMENT; case cs.UNSIGNED_SHORT: return Uint16Array.BYTES_PER_ELEMENT; case cs.UNSIGNED_INT: return Uint32Array.BYTES_PER_ELEMENT } }; cs.fromSizeInBytes = function (e) { switch (e) { case 2: return cs.UNSIGNED_SHORT; case 4: return cs.UNSIGNED_INT; case 1: return cs.UNSIGNED_BYTE } }; cs.validate = function (e) { return l(e) && (e === cs.UNSIGNED_BYTE || e === cs.UNSIGNED_SHORT || e === cs.UNSIGNED_INT) }; cs.createTypedArray = function (e, t) { return e >= I.SIXTY_FOUR_KILOBYTES ? new Uint32Array(t) : new Uint16Array(t) }; cs.createTypedArrayFromArrayBuffer = function (e, t, n, i) { return e >= I.SIXTY_FOUR_KILOBYTES ? new Uint32Array(t, n, i) : new Uint16Array(t, n, i) }; cs.fromTypedArray = function (e) { if (e instanceof Uint8Array) return cs.UNSIGNED_BYTE; if (e instanceof Uint16Array) return cs.UNSIGNED_SHORT; if (e instanceof Uint32Array) return cs.UNSIGNED_INT }; var Me = Object.freeze(cs); function eu(e) { e = y(e, y.EMPTY_OBJECT); let t = e.context._gl, n = e.bufferTarget, i = e.typedArray, o = e.sizeInBytes, r = e.usage, s = l(i); s && (o = i.byteLength); let a = t.createBuffer(); t.bindBuffer(n, a), t.bufferData(n, s ? i : o, r), t.bindBuffer(n, null), this._id = Nn(), this._gl = t, this._webgl2 = e.context._webgl2, this._bufferTarget = n, this._sizeInBytes = o, this._usage = r, this._buffer = a, this.vertexArrayDestroyable = !0 } eu.createVertexBuffer = function (e) { return new eu({ context: e.context, bufferTarget: te.ARRAY_BUFFER, typedArray: e.typedArray, sizeInBytes: e.sizeInBytes, usage: e.usage }) }; eu.createIndexBuffer = function (e) { let t = e.context, n = e.indexDatatype, i = Me.getSizeInBytes(n), o = new eu({ context: t, bufferTarget: te.ELEMENT_ARRAY_BUFFER, typedArray: e.typedArray, sizeInBytes: e.sizeInBytes, usage: e.usage }), r = o.sizeInBytes / i; return Object.defineProperties(o, { indexDatatype: { get: function () { return n } }, bytesPerIndex: { get: function () { return i } }, numberOfIndices: { get: function () { return r } } }), o }; Object.defineProperties(eu.prototype, { sizeInBytes: { get: function () { return this._sizeInBytes } }, usage: { get: function () { return this._usage } } }); eu.prototype._getBuffer = function () { return this._buffer }; eu.prototype.copyFromArrayView = function (e, t) { t = y(t, 0); let n = this._gl, i = this._bufferTarget; n.bindBuffer(i, this._buffer), n.bufferSubData(i, t, e), n.bindBuffer(i, null) }; eu.prototype.copyFromBuffer = function (e, t, n, i) { let o = te.COPY_READ_BUFFER, r = te.COPY_WRITE_BUFFER, s = this._gl; s.bindBuffer(r, this._buffer), s.bindBuffer(o, e._buffer), s.copyBufferSubData(o, r, t, n, i), s.bindBuffer(r, null), s.bindBuffer(o, null) }; eu.prototype.getBufferData = function (e, t, n, i) { t = y(t, 0), n = y(n, 0); let o = this._gl, r = te.COPY_READ_BUFFER; o.bindBuffer(r, this._buffer), o.getBufferSubData(r, t, e, n, i), o.bindBuffer(r, null) }; eu.prototype.isDestroyed = function () { return !1 }; eu.prototype.destroy = function () { return this._gl.deleteBuffer(this._buffer), le(this) }; var ct = eu; function Lbe(e, t, n, i) { let o = l(t.vertexBuffer), r = l(t.value), s = t.value ? t.value.length : t.componentsPerAttribute, a = { index: y(t.index, n), enabled: y(t.enabled, !0), vertexBuffer: t.vertexBuffer, value: r ? t.value.slice(0) : void 0, componentsPerAttribute: s, componentDatatype: y(t.componentDatatype, Y.FLOAT), normalize: y(t.normalize, !1), offsetInBytes: y(t.offsetInBytes, 0), strideInBytes: y(t.strideInBytes, 0), instanceDivisor: y(t.instanceDivisor, 0) }; if (o) a.vertexAttrib = function (c) { let u = this.index; c.bindBuffer(c.ARRAY_BUFFER, this.vertexBuffer._getBuffer()), c.vertexAttribPointer(u, this.componentsPerAttribute, this.componentDatatype, this.normalize, this.strideInBytes, this.offsetInBytes), c.enableVertexAttribArray(u), this.instanceDivisor > 0 && (i.glVertexAttribDivisor(u, this.instanceDivisor), i._vertexAttribDivisors[u] = this.instanceDivisor, i._previousDrawInstanced = !0) }, a.disableVertexAttribArray = function (c) { c.disableVertexAttribArray(this.index), this.instanceDivisor > 0 && i.glVertexAttribDivisor(n, 0) }; else { switch (a.componentsPerAttribute) { case 1: a.vertexAttrib = function (c) { c.vertexAttrib1fv(this.index, this.value) }; break; case 2: a.vertexAttrib = function (c) { c.vertexAttrib2fv(this.index, this.value) }; break; case 3: a.vertexAttrib = function (c) { c.vertexAttrib3fv(this.index, this.value) }; break; case 4: a.vertexAttrib = function (c) { c.vertexAttrib4fv(this.index, this.value) }; break }a.disableVertexAttribArray = function (c) { } } e.push(a) } function XK(e, t, n) { for (let i = 0; i < t.length; ++i) { let o = t[i]; o.enabled && o.vertexAttrib(e) } l(n) && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n._getBuffer()) } function im(e) { e = y(e, y.EMPTY_OBJECT); let t = e.context, n = t._gl, i = e.attributes, o = e.indexBuffer, r, s = [], a = 1, c = !1, u = !1, f = i.length; for (r = 0; r < f; ++r)Lbe(s, i[r], r, t); for (f = s.length, r = 0; r < f; ++r) { let p = s[r]; if (l(p.vertexBuffer) && p.instanceDivisor === 0) { let g = p.strideInBytes || p.componentsPerAttribute * Y.getSizeInBytes(p.componentDatatype); a = p.vertexBuffer.sizeInBytes / g; break } } for (r = 0; r < f; ++r)s[r].instanceDivisor > 0 && (c = !0), l(s[r].value) && (u = !0); let d; t.vertexArrayObject && (d = t.glCreateVertexArray(), t.glBindVertexArray(d), XK(n, s, o), t.glBindVertexArray(null)), this._numberOfVertices = a, this._hasInstancedAttributes = c, this._hasConstantAttributes = u, this._context = t, this._gl = n, this._vao = d, this._attributes = s, this._indexBuffer = o } function YK(e) { return e.values.length / e.componentsPerAttribute } function Fbe(e) { return Y.getSizeInBytes(e.componentDatatype) * e.componentsPerAttribute } function Nbe(e) { let t, n, i, o = []; for (n in e) e.hasOwnProperty(n) && l(e[n]) && l(e[n].values) && (o.push(n), e[n].componentDatatype === Y.DOUBLE && (e[n].componentDatatype = Y.FLOAT, e[n].values = Y.createTypedArray(Y.FLOAT, e[n].values))); let r, s = o.length; if (s > 0) for (r = YK(e[o[0]]), t = 1; t < s; ++t) { let u = YK(e[o[t]]); if (u !== r) throw new fe(`Each attribute list must have the same number of vertices.  Attribute ${o[t]} has a different number of vertices (${u.toString()}) than attribute ${o[0]} (${r.toString()}).`) } o.sort(function (u, f) { return Y.getSizeInBytes(e[f].componentDatatype) - Y.getSizeInBytes(e[u].componentDatatype) }); let a = 0, c = {}; for (t = 0; t < s; ++t)n = o[t], i = e[n], c[n] = a, a += Fbe(i); if (a > 0) { let u = Y.getSizeInBytes(e[o[0]].componentDatatype), f = a % u; f !== 0 && (a += u - f); let d = r * a, p = new ArrayBuffer(d), g = {}; for (t = 0; t < s; ++t) { n = o[t]; let m = Y.getSizeInBytes(e[n].componentDatatype); g[n] = { pointer: Y.createTypedArray(e[n].componentDatatype, p), index: c[n] / m, strideInComponentType: a / m } } for (t = 0; t < r; ++t)for (let m = 0; m < s; ++m) { n = o[m], i = e[n]; let A = i.values, C = g[n], x = C.pointer, T = i.componentsPerAttribute; for (let b = 0; b < T; ++b)x[C.index + b] = A[t * T + b]; C.index += C.strideInComponentType } return { buffer: p, offsetsInBytes: c, vertexSizeInBytes: a } } } im.fromGeometry = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.context, n = y(e.geometry, y.EMPTY_OBJECT), i = y(e.bufferUsage, Re.DYNAMIC_DRAW), o = y(e.attributeLocations, y.EMPTY_OBJECT), r = y(e.interleave, !1), s = e.vertexArrayAttributes, a, c, u, f = l(s) ? s : [], d = n.attributes; if (r) { let m = Nbe(d); if (l(m)) { u = ct.createVertexBuffer({ context: t, typedArray: m.buffer, usage: i }); let A = m.offsetsInBytes, C = m.vertexSizeInBytes; for (a in d) d.hasOwnProperty(a) && l(d[a]) && (c = d[a], l(c.values) ? f.push({ index: o[a], vertexBuffer: u, componentDatatype: c.componentDatatype, componentsPerAttribute: c.componentsPerAttribute, normalize: c.normalize, offsetInBytes: A[a], strideInBytes: C }) : f.push({ index: o[a], value: c.value, componentDatatype: c.componentDatatype, normalize: c.normalize })) } } else for (a in d) if (d.hasOwnProperty(a) && l(d[a])) { c = d[a]; let m = c.componentDatatype; m === Y.DOUBLE && (m = Y.FLOAT), u = void 0, l(c.values) && (u = ct.createVertexBuffer({ context: t, typedArray: Y.createTypedArray(m, c.values), usage: i })), f.push({ index: o[a], vertexBuffer: u, value: c.value, componentDatatype: m, componentsPerAttribute: c.componentsPerAttribute, normalize: c.normalize }) } let p, g = n.indices; return l(g) && (st.computeNumberOfVertices(n) >= I.SIXTY_FOUR_KILOBYTES && t.elementIndexUint ? p = ct.createIndexBuffer({ context: t, typedArray: new Uint32Array(g), usage: i, indexDatatype: Me.UNSIGNED_INT }) : p = ct.createIndexBuffer({ context: t, typedArray: new Uint16Array(g), usage: i, indexDatatype: Me.UNSIGNED_SHORT })), new im({ context: t, attributes: f, indexBuffer: p }) }; Object.defineProperties(im.prototype, { numberOfAttributes: { get: function () { return this._attributes.length } }, numberOfVertices: { get: function () { return this._numberOfVertices } }, indexBuffer: { get: function () { return this._indexBuffer } } }); im.prototype.getAttribute = function (e) { return this._attributes[e] }; function Vbe(e) { let t = e._context, n = e._hasInstancedAttributes; if (!n && !t._previousDrawInstanced) return; t._previousDrawInstanced = n; let i = t._vertexAttribDivisors, o = e._attributes, r = Ut.maximumVertexAttributes, s; if (n) { let a = o.length; for (s = 0; s < a; ++s) { let c = o[s]; if (c.enabled) { let u = c.instanceDivisor, f = c.index; u !== i[f] && (t.glVertexAttribDivisor(f, u), i[f] = u) } } } else for (s = 0; s < r; ++s)i[s] > 0 && (t.glVertexAttribDivisor(s, 0), i[s] = 0) } function kbe(e, t) { let n = e._attributes, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; r.enabled && l(r.value) && r.vertexAttrib(t) } } im.prototype._bind = function () { l(this._vao) ? (this._context.glBindVertexArray(this._vao), this._context.instancedArrays && Vbe(this), this._hasConstantAttributes && kbe(this, this._gl)) : XK(this._gl, this._attributes, this._indexBuffer) }; im.prototype._unBind = function () { if (l(this._vao)) this._context.glBindVertexArray(null); else { let e = this._attributes, t = this._gl; for (let n = 0; n < e.length; ++n) { let i = e[n]; i.enabled && i.disableVertexAttribArray(t) } this._indexBuffer && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null) } }; im.prototype.isDestroyed = function () { return !1 }; im.prototype.destroy = function () { let e = this._attributes; for (let n = 0; n < e.length; ++n) { let i = e[n].vertexBuffer; l(i) && !i.isDestroyed() && i.vertexArrayDestroyable && i.destroy() } let t = this._indexBuffer; return l(t) && !t.isDestroyed() && t.vertexArrayDestroyable && t.destroy(), l(this._vao) && this._context.glDeleteVertexArray(this._vao), le(this) }; var Qn = im; function om(e, t, n) { if (this._attributes = t, this._numberOfInstances = n, t.length === 0) return; let i = Ube(t), o = e.floatingPointTexture, r = i === Ye.FLOAT && !o, s = zbe(t, r), a = Hbe(s, t, r), c = Math.floor(Ut.maximumTextureSize / a), u = Math.min(n, c), f = a * u, d = Math.ceil(n / u), p = 1 / f, g = p * .5, m = 1 / d, A = m * .5; this._textureDimensions = new H(f, d), this._textureStep = new se(p, g, m, A), this._pixelDatatype = r ? Ye.UNSIGNED_BYTE : i, this._packFloats = r, this._offsets = s, this._stride = a, this._texture = void 0; let C = 4 * f * d; this._batchValues = i === Ye.FLOAT && !r ? new Float32Array(C) : new Uint8Array(C), this._batchValuesDirty = !1 } Object.defineProperties(om.prototype, { attributes: { get: function () { return this._attributes } }, numberOfInstances: { get: function () { return this._numberOfInstances } } }); function Ube(e) { let t = !1, n = e.length; for (let i = 0; i < n; ++i)if (e[i].componentDatatype !== Y.UNSIGNED_BYTE) { t = !0; break } return t ? Ye.FLOAT : Ye.UNSIGNED_BYTE } function JK(e, t) { let n = e[t].componentsPerAttribute; return n === 2 ? H : n === 3 ? h : n === 4 ? se : Number } function zbe(e, t) { let n = new Array(e.length), i = 0, o = e.length; for (let r = 0; r < o; ++r) { let a = e[r].componentDatatype; n[r] = i, a !== Y.UNSIGNED_BYTE && t ? i += 4 : ++i } return n } function Hbe(e, t, n) { let i = e.length, o = e[i - 1]; return t[i - 1].componentDatatype !== Y.UNSIGNED_BYTE && n ? o + 4 : o + 1 } var Tb = new se; function Gbe(e, t, n) { let i = se.unpack(e, t, Tb), o = se.unpackFloat(i); i = se.unpack(e, t + 4, Tb); let r = se.unpackFloat(i); i = se.unpack(e, t + 8, Tb); let s = se.unpackFloat(i); i = se.unpack(e, t + 12, Tb); let a = se.unpackFloat(i); return se.fromElements(o, r, s, a, n) } function Wbe(e, t, n) { let i = se.packFloat(e.x, Tb); se.pack(i, t, n), i = se.packFloat(e.y, i), se.pack(i, t, n + 4), i = se.packFloat(e.z, i), se.pack(i, t, n + 8), i = se.packFloat(e.w, i), se.pack(i, t, n + 12) } var KK = new se; om.prototype.getBatchedAttribute = function (e, t, n) { let i = this._attributes, o = this._offsets[t], r = this._stride, s = 4 * r * e + 4 * o, a; this._packFloats && i[t].componentDatatype !== Ye.UNSIGNED_BYTE ? a = Gbe(this._batchValues, s, KK) : a = se.unpack(this._batchValues, s, KK); let c = JK(i, t); return l(c.fromCartesian4) ? c.fromCartesian4(a, n) : l(c.clone) ? c.clone(a, n) : a.x }; var jbe = [void 0, void 0, new H, new h, new se], qbe = new se; om.prototype.setBatchedAttribute = function (e, t, n) { let i = this._attributes, o = jbe[i[t].componentsPerAttribute], r = this.getBatchedAttribute(e, t, o), s = JK(this._attributes, t); if (l(s.equals) ? s.equals(r, n) : r === n) return; let c = qbe; c.x = l(n.x) ? n.x : n, c.y = l(n.y) ? n.y : 0, c.z = l(n.z) ? n.z : 0, c.w = l(n.w) ? n.w : 0; let u = this._offsets[t], f = this._stride, d = 4 * f * e + 4 * u; this._packFloats && i[t].componentDatatype !== Ye.UNSIGNED_BYTE ? Wbe(c, this._batchValues, d) : se.pack(c, this._batchValues, d), this._batchValuesDirty = !0 }; function Ybe(e, t) { let n = e._textureDimensions; e._texture = new Rt({ context: t, pixelFormat: ht.RGBA, pixelDatatype: e._pixelDatatype, width: n.x, height: n.y, sampler: dn.NEAREST, flipY: !1 }) } function Xbe(e) { let t = e._textureDimensions; e._texture.copyFrom({ source: { width: t.x, height: t.y, arrayBufferView: e._batchValues } }) } om.prototype.update = function (e) { l(this._texture) && !this._batchValuesDirty || this._attributes.length === 0 || (this._batchValuesDirty = !1, l(this._texture) || Ybe(this, e.context), Xbe(this)) }; om.prototype.getUniformMapCallback = function () { let e = this; return function (t) { return e._attributes.length === 0 ? t : yt(t, { batchTexture: function () { return e._texture }, batchTextureDimensions: function () { return e._textureDimensions }, batchTextureStep: function () { return e._textureStep } }) } }; function Kbe(e) {
        let t = e._stride; return e._textureDimensions.y === 1 ? `uniform vec4 batchTextureStep; 
vec2 computeSt(float batchId) 
{ 
    float stepX = batchTextureStep.x; 
    float centerX = batchTextureStep.y; 
    float numberOfAttributes = float(${t}); 
    return vec2(centerX + (batchId * numberOfAttributes * stepX), 0.5); 
} 
`: `uniform vec4 batchTextureStep; 
uniform vec2 batchTextureDimensions; 
vec2 computeSt(float batchId) 
{ 
    float stepX = batchTextureStep.x; 
    float centerX = batchTextureStep.y; 
    float stepY = batchTextureStep.z; 
    float centerY = batchTextureStep.w; 
    float numberOfAttributes = float(${t}); 
    float xId = mod(batchId * numberOfAttributes, batchTextureDimensions.x); 
    float yId = floor(batchId * numberOfAttributes / batchTextureDimensions.x); 
    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); 
} 
`} function Jbe(e) { return e === 1 ? "float" : `vec${e}` } function Zbe(e) { return e === 1 ? ".x" : e === 2 ? ".xy" : e === 3 ? ".xyz" : "" } function Qbe(e, t) {
        let i = e._attributes[t], o = i.componentsPerAttribute, r = i.functionName, s = Jbe(o), a = Zbe(o), c = e._offsets[t], u = `${s} ${r}(float batchId) 
{ 
    vec2 st = computeSt(batchId); 
    st.x += batchTextureStep.x * float(${c}); 
`; return e._packFloats && i.componentDatatype !== Ye.UNSIGNED_BYTE ? u += `vec4 textureValue; 
textureValue.x = czm_unpackFloat(texture2D(batchTexture, st)); 
textureValue.y = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x, 0.0))); 
textureValue.z = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x * 2.0, 0.0))); 
textureValue.w = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x * 3.0, 0.0))); 
`: u += `    vec4 textureValue = texture2D(batchTexture, st); 
`, u += `    ${s} value = textureValue${a}; 
`, e._pixelDatatype === Ye.UNSIGNED_BYTE && i.componentDatatype === Y.UNSIGNED_BYTE && !i.normalize ? u += `value *= 255.0; 
`: e._pixelDatatype === Ye.FLOAT && i.componentDatatype === Y.UNSIGNED_BYTE && i.normalize && (u += `value /= 255.0; 
`), u += `    return value; 
} 
`, u
    } om.prototype.getVertexShaderCallback = function () {
        let e = this._attributes; if (e.length === 0) return function (i) { return i }; let t = `uniform highp sampler2D batchTexture; 
`; t += `${Kbe(this)}
`; let n = e.length; for (let i = 0; i < n; ++i)t += Qbe(this, i); return function (i) {
            let o = i.indexOf("void main"), r = i.substring(0, o), s = i.substring(o); return `${r}
${t}
${s}`
        }
    }; om.prototype.isDestroyed = function () { return !1 }; om.prototype.destroy = function () { return this._texture = this._texture && this._texture.destroy(), le(this) }; var fC = om; var Wi = { SCALAR: "SCALAR", VEC2: "VEC2", VEC3: "VEC3", VEC4: "VEC4", MAT2: "MAT2", MAT3: "MAT3", MAT4: "MAT4" }; Wi.getMathType = function (e) { switch (e) { case Wi.SCALAR: return Number; case Wi.VEC2: return H; case Wi.VEC3: return h; case Wi.VEC4: return se; case Wi.MAT2: return qi; case Wi.MAT3: return Q; case Wi.MAT4: return F } }; Wi.getNumberOfComponents = function (e) { switch (e) { case Wi.SCALAR: return 1; case Wi.VEC2: return 2; case Wi.VEC3: return 3; case Wi.VEC4: case Wi.MAT2: return 4; case Wi.MAT3: return 9; case Wi.MAT4: return 16 } }; Wi.getAttributeLocationCount = function (e) { switch (e) { case Wi.SCALAR: case Wi.VEC2: case Wi.VEC3: case Wi.VEC4: return 1; case Wi.MAT2: return 2; case Wi.MAT3: return 3; case Wi.MAT4: return 4 } }; Wi.getGlslType = function (e) { switch (e) { case Wi.SCALAR: return "float"; case Wi.VEC2: return "vec2"; case Wi.VEC3: return "vec3"; case Wi.VEC4: return "vec4"; case Wi.MAT2: return "mat2"; case Wi.MAT3: return "mat3"; case Wi.MAT4: return "mat4" } }; var en = Object.freeze(Wi); var ZK = 1 / 256, QK = 256, so = {}; so.octEncodeInRange = function (e, t, n) { if (n.x = e.x / (Math.abs(e.x) + Math.abs(e.y) + Math.abs(e.z)), n.y = e.y / (Math.abs(e.x) + Math.abs(e.y) + Math.abs(e.z)), e.z < 0) { let i = n.x, o = n.y; n.x = (1 - Math.abs(o)) * I.signNotZero(i), n.y = (1 - Math.abs(i)) * I.signNotZero(o) } return n.x = I.toSNorm(n.x, t), n.y = I.toSNorm(n.y, t), n }; so.octEncode = function (e, t) { return so.octEncodeInRange(e, 255, t) }; var Eb = new H, $K = new Uint8Array(1); function $O(e) { return $K[0] = e, $K[0] } so.octEncodeToCartesian4 = function (e, t) { return so.octEncodeInRange(e, 65535, Eb), t.x = $O(Eb.x * ZK), t.y = $O(Eb.x), t.z = $O(Eb.y * ZK), t.w = $O(Eb.y), t }; so.octDecodeInRange = function (e, t, n, i) { if (i.x = I.fromSNorm(e, n), i.y = I.fromSNorm(t, n), i.z = 1 - (Math.abs(i.x) + Math.abs(i.y)), i.z < 0) { let o = i.x; i.x = (1 - Math.abs(i.y)) * I.signNotZero(o), i.y = (1 - Math.abs(o)) * I.signNotZero(i.y) } return h.normalize(i, i) }; so.octDecode = function (e, t, n) { return so.octDecodeInRange(e, t, 255, n) }; so.octDecodeFromCartesian4 = function (e, t) { let n = e.x, i = e.y, o = e.z, r = e.w, s = n * QK + i, a = o * QK + r; return so.octDecodeInRange(s, a, 65535, t) }; so.octPackFloat = function (e) { return 256 * e.x + e.y }; var JH = new H; so.octEncodeFloat = function (e) { return so.octEncode(e, JH), so.octPackFloat(JH) }; so.octDecodeFloat = function (e, t) { let n = e / 256, i = Math.floor(n), o = (n - i) * 256; return so.octDecode(i, o, t) }; so.octPack = function (e, t, n, i) { let o = so.octEncodeFloat(e), r = so.octEncodeFloat(t), s = so.octEncode(n, JH); return i.x = 65536 * s.x + o, i.y = 65536 * s.y + r, i }; so.octUnpack = function (e, t, n, i) { let o = e.x / 65536, r = Math.floor(o), s = (o - r) * 65536; o = e.y / 65536; let a = Math.floor(o), c = (o - a) * 65536; so.octDecodeFloat(s, t), so.octDecodeFloat(c, n), so.octDecode(r, a, i) }; so.compressTextureCoordinates = function (e) { let t = e.x * 4095 | 0, n = e.y * 4095 | 0; return 4096 * t + n }; so.decompressTextureCoordinates = function (e, t) { let n = e / 4096, i = Math.floor(n); return t.x = i / 4095, t.y = (e - i * 4096) / 4095, t }; function KH(e) { return e >> 1 ^ -(e & 1) } so.zigZagDeltaDecode = function (e, t, n) { let i = e.length, o = 0, r = 0, s = 0; for (let a = 0; a < i; ++a)o += KH(e[a]), r += KH(t[a]), e[a] = o, t[a] = r, l(n) && (s += KH(n[a]), n[a] = s) }; so.dequantize = function (e, t, n, i) { let o = en.getNumberOfComponents(n), r; switch (t) { case Y.BYTE: r = 127; break; case Y.UNSIGNED_BYTE: r = 255; break; case Y.SHORT: r = 32767; break; case Y.UNSIGNED_SHORT: r = 65535; break; case Y.INT: r = 2147483647; break; case Y.UNSIGNED_INT: r = 4294967295; break }let s = new Float32Array(i * o); for (let a = 0; a < i; a++)for (let c = 0; c < o; c++) { let u = a * o + c; s[u] = Math.max(e[u] / r, -1) } return s }; so.decodeRGB565 = function (e, t) { let n = e.length; l(t) || (t = new Float32Array(n * 3)); let i = (1 << 5) - 1, o = (1 << 6) - 1, r = 1 / 31, s = 1 / 63; for (let a = 0; a < n; a++) { let c = e[a], u = c >> 11, f = c >> 5 & o, d = c & i, p = 3 * a; t[p] = u * r, t[p + 1] = f * s, t[p + 2] = d * r } return t }; var kn = so; var eJ = new h, tJ = new h, nJ = new h; function $be(e, t, n, i, o) { l(o) || (o = new h); let r, s, a, c, u, f, d, p; if (l(t.z)) { if (h.equalsEpsilon(e, t, I.EPSILON14)) return h.clone(h.UNIT_X, o); if (h.equalsEpsilon(e, n, I.EPSILON14)) return h.clone(h.UNIT_Y, o); if (h.equalsEpsilon(e, i, I.EPSILON14)) return h.clone(h.UNIT_Z, o); r = h.subtract(n, t, eJ), s = h.subtract(i, t, tJ), a = h.subtract(e, t, nJ), c = h.dot(r, r), u = h.dot(r, s), f = h.dot(r, a), d = h.dot(s, s), p = h.dot(s, a) } else { if (H.equalsEpsilon(e, t, I.EPSILON14)) return h.clone(h.UNIT_X, o); if (H.equalsEpsilon(e, n, I.EPSILON14)) return h.clone(h.UNIT_Y, o); if (H.equalsEpsilon(e, i, I.EPSILON14)) return h.clone(h.UNIT_Z, o); r = H.subtract(n, t, eJ), s = H.subtract(i, t, tJ), a = H.subtract(e, t, nJ), c = H.dot(r, r), u = H.dot(r, s), f = H.dot(r, a), d = H.dot(s, s), p = H.dot(s, a) } o.y = d * f - u * p, o.z = c * p - u * f; let g = c * d - u * u; if (g !== 0) return o.y /= g, o.z /= g, o.x = 1 - o.y - o.z, o } var dC = $be; var ZH = {}; ZH.calculateACMR = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.indices, n = e.maximumIndex, i = y(e.cacheSize, 24), o = t.length; if (!l(n)) { n = 0; let a = 0, c = t[a]; for (; a < o;)c > n && (n = c), ++a, c = t[a] } let r = []; for (let a = 0; a < n + 1; a++)r[a] = 0; let s = i + 1; for (let a = 0; a < o; ++a)s - r[t[a]] > i && (r[t[a]] = s, ++s); return (s - i + 1) / (o / 3) }; ZH.tipsify = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.indices, n = e.maximumIndex, i = y(e.cacheSize, 24), o; function r(_, E, w, v) { for (; E.length >= 1;) { let O = E[E.length - 1]; if (E.splice(E.length - 1, 1), _[O].numLiveTriangles > 0) return O } for (; o < v;) { if (_[o].numLiveTriangles > 0) return ++o, o - 1; ++o } return -1 } function s(_, E, w, v, O, V, z) { let k = -1, G, N = -1, X = 0; for (; X < w.length;) { let q = w[X]; v[q].numLiveTriangles && (G = 0, O - v[q].timeStamp + 2 * v[q].numLiveTriangles <= E && (G = O - v[q].timeStamp), (G > N || N === -1) && (N = G, k = q)), ++X } return k === -1 ? r(v, V, _, z) : k } let a = t.length, c = 0, u = 0, f = t[u], d = a; if (l(n)) c = n + 1; else { for (; u < d;)f > c && (c = f), ++u, f = t[u]; if (c === -1) return 0; ++c } let p = [], g; for (g = 0; g < c; g++)p[g] = { numLiveTriangles: 0, timeStamp: 0, vertexTriangles: [] }; u = 0; let m = 0; for (; u < d;)p[t[u]].vertexTriangles.push(m), ++p[t[u]].numLiveTriangles, p[t[u + 1]].vertexTriangles.push(m), ++p[t[u + 1]].numLiveTriangles, p[t[u + 2]].vertexTriangles.push(m), ++p[t[u + 2]].numLiveTriangles, ++m, u += 3; let A = 0, C = i + 1; o = 1; let x = [], T = [], b, S, D = 0, P = [], B = a / 3, R = []; for (g = 0; g < B; g++)R[g] = !1; let M, L; for (; A !== -1;) { x = [], S = p[A], L = S.vertexTriangles.length; for (let _ = 0; _ < L; ++_)if (m = S.vertexTriangles[_], !R[m]) { R[m] = !0, u = m + m + m; for (let E = 0; E < 3; ++E)M = t[u], x.push(M), T.push(M), P[D] = M, ++D, b = p[M], --b.numLiveTriangles, C - b.timeStamp > i && (b.timeStamp = C, ++C), ++u } A = s(t, i, x, p, C, T, c) } return P }; var eB = ZH; var Za = {}; function aB(e, t, n, i, o) { e[t++] = n, e[t++] = i, e[t++] = i, e[t++] = o, e[t++] = o, e[t] = n } function eSe(e) { let t = e.length, n = t / 3 * 6, i = Me.createTypedArray(t, n), o = 0; for (let r = 0; r < t; r += 3, o += 6)aB(i, o, e[r], e[r + 1], e[r + 2]); return i } function tSe(e) { let t = e.length; if (t >= 3) { let n = (t - 2) * 6, i = Me.createTypedArray(t, n); aB(i, 0, e[0], e[1], e[2]); let o = 6; for (let r = 3; r < t; ++r, o += 6)aB(i, o, e[r - 1], e[r], e[r - 2]); return i } return new Uint16Array } function nSe(e) { if (e.length > 0) { let t = e.length - 1, n = (t - 1) * 6, i = Me.createTypedArray(t, n), o = e[0], r = 0; for (let s = 1; s < t; ++s, r += 6)aB(i, r, o, e[s], e[s + 1]); return i } return new Uint16Array } Za.toWireframe = function (e) { let t = e.indices; if (l(t)) { switch (e.primitiveType) { case Oe.TRIANGLES: e.indices = eSe(t); break; case Oe.TRIANGLE_STRIP: e.indices = tSe(t); break; case Oe.TRIANGLE_FAN: e.indices = nSe(t); break }e.primitiveType = Oe.LINES } return e }; Za.createLineSegmentsForVectors = function (e, t, n) { t = y(t, "normal"), n = y(n, 1e4); let i = e.attributes.position.values, o = e.attributes[t].values, r = i.length, s = new Float64Array(2 * r), a = 0; for (let f = 0; f < r; f += 3)s[a++] = i[f], s[a++] = i[f + 1], s[a++] = i[f + 2], s[a++] = i[f] + o[f] * n, s[a++] = i[f + 1] + o[f + 1] * n, s[a++] = i[f + 2] + o[f + 2] * n; let c, u = e.boundingSphere; return l(u) && (c = new re(u.center, u.radius + n)), new st({ attributes: { position: new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: s }) }, primitiveType: Oe.LINES, boundingSphere: c }) }; Za.createAttributeLocations = function (e) { let t = ["position", "positionHigh", "positionLow", "position3DHigh", "position3DLow", "position2DHigh", "position2DLow", "pickColor", "normal", "st", "tangent", "bitangent", "extrudeDirection", "compressedAttributes"], n = e.attributes, i = {}, o = 0, r, s = t.length; for (r = 0; r < s; ++r) { let a = t[r]; l(n[a]) && (i[a] = o++) } for (let a in n) n.hasOwnProperty(a) && !l(i[a]) && (i[a] = o++); return i }; Za.reorderForPreVertexCache = function (e) { let t = st.computeNumberOfVertices(e), n = e.indices; if (l(n)) { let i = new Int32Array(t); for (let p = 0; p < t; p++)i[p] = -1; let o = n, r = o.length, s = Me.createTypedArray(t, r), a = 0, c = 0, u = 0, f; for (; a < r;)f = i[o[a]], f !== -1 ? s[c] = f : (f = o[a], i[f] = u, s[c] = u, ++u), ++a, ++c; e.indices = s; let d = e.attributes; for (let p in d) if (d.hasOwnProperty(p) && l(d[p]) && l(d[p].values)) { let g = d[p], m = g.values, A = 0, C = g.componentsPerAttribute, x = Y.createTypedArray(g.componentDatatype, u * C); for (; A < t;) { let T = i[A]; if (T !== -1) for (let b = 0; b < C; b++)x[C * T + b] = m[C * A + b]; ++A } g.values = x } } return e }; Za.reorderForPostVertexCache = function (e, t) { let n = e.indices; if (e.primitiveType === Oe.TRIANGLES && l(n)) { let i = n.length, o = 0; for (let r = 0; r < i; r++)n[r] > o && (o = n[r]); e.indices = eB.tipsify({ indices: n, maximumIndex: o, cacheSize: t }) } return e }; function iJ(e) { let t = {}; for (let n in e) if (e.hasOwnProperty(n) && l(e[n]) && l(e[n].values)) { let i = e[n]; t[n] = new be({ componentDatatype: i.componentDatatype, componentsPerAttribute: i.componentsPerAttribute, normalize: i.normalize, values: [] }) } return t } function iSe(e, t, n) { for (let i in t) if (t.hasOwnProperty(i) && l(t[i]) && l(t[i].values)) { let o = t[i]; for (let r = 0; r < o.componentsPerAttribute; ++r)e[i].values.push(o.values[n * o.componentsPerAttribute + r]) } } Za.fitToUnsignedShortIndices = function (e) { let t = [], n = st.computeNumberOfVertices(e); if (l(e.indices) && n >= I.SIXTY_FOUR_KILOBYTES) { let i = [], o = [], r = 0, s = iJ(e.attributes), a = e.indices, c = a.length, u; e.primitiveType === Oe.TRIANGLES ? u = 3 : e.primitiveType === Oe.LINES ? u = 2 : e.primitiveType === Oe.POINTS && (u = 1); for (let f = 0; f < c; f += u) { for (let d = 0; d < u; ++d) { let p = a[f + d], g = i[p]; l(g) || (g = r++, i[p] = g, iSe(s, e.attributes, p)), o.push(g) } r + u >= I.SIXTY_FOUR_KILOBYTES && (t.push(new st({ attributes: s, indices: o, primitiveType: e.primitiveType, boundingSphere: e.boundingSphere, boundingSphereCV: e.boundingSphereCV })), i = [], o = [], r = 0, s = iJ(e.attributes)) } o.length !== 0 && t.push(new st({ attributes: s, indices: o, primitiveType: e.primitiveType, boundingSphere: e.boundingSphere, boundingSphereCV: e.boundingSphereCV })) } else t.push(e); return t }; var oJ = new h, oSe = new he; Za.projectTo2D = function (e, t, n, i, o) { let r = e.attributes[t]; o = l(o) ? o : new _i; let s = o.ellipsoid, a = r.values, c = new Float64Array(a.length), u = 0; for (let f = 0; f < a.length; f += 3) { let d = h.fromArray(a, f, oJ), p = s.cartesianToCartographic(d, oSe), g = o.project(p, oJ); c[u++] = g.x, c[u++] = g.y, c[u++] = g.z } return e.attributes[n] = r, e.attributes[i] = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: c }), delete e.attributes[t], e }; var QH = { high: 0, low: 0 }; Za.encodeAttribute = function (e, t, n, i) { let o = e.attributes[t], r = o.values, s = r.length, a = new Float32Array(s), c = new Float32Array(s); for (let f = 0; f < s; ++f)Vn.encode(r[f], QH), a[f] = QH.high, c[f] = QH.low; let u = o.componentsPerAttribute; return e.attributes[n] = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: u, values: a }), e.attributes[i] = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: u, values: c }), delete e.attributes[t], e }; var hf = new h; function $H(e, t) { if (l(t)) { let n = t.values, i = n.length; for (let o = 0; o < i; o += 3)h.unpack(n, o, hf), F.multiplyByPoint(e, hf, hf), h.pack(hf, n, o) } } function eG(e, t) { if (l(t)) { let n = t.values, i = n.length; for (let o = 0; o < i; o += 3)h.unpack(n, o, hf), Q.multiplyByVector(e, hf, hf), hf = h.normalize(hf, hf), h.pack(hf, n, o) } } var tB = new F, nB = new Q; Za.transformToWorldCoordinates = function (e) { let t = e.modelMatrix; if (F.equals(t, F.IDENTITY)) return e; let n = e.geometry.attributes; $H(t, n.position), $H(t, n.prevPosition), $H(t, n.nextPosition), (l(n.normal) || l(n.tangent) || l(n.bitangent)) && (F.inverse(t, tB), F.transpose(tB, tB), F.getMatrix3(tB, nB), eG(nB, n.normal), eG(nB, n.tangent), eG(nB, n.bitangent)); let i = e.geometry.boundingSphere; return l(i) && (e.geometry.boundingSphere = re.transform(i, t, i)), e.modelMatrix = F.clone(F.IDENTITY), e }; function rSe(e, t) { let n = e.length, i = {}, o = e[0][t].attributes, r; for (r in o) if (o.hasOwnProperty(r) && l(o[r]) && l(o[r].values)) { let s = o[r], a = s.values.length, c = !0; for (let u = 1; u < n; ++u) { let f = e[u][t].attributes[r]; if (!l(f) || s.componentDatatype !== f.componentDatatype || s.componentsPerAttribute !== f.componentsPerAttribute || s.normalize !== f.normalize) { c = !1; break } a += f.values.length } c && (i[r] = new be({ componentDatatype: s.componentDatatype, componentsPerAttribute: s.componentsPerAttribute, normalize: s.normalize, values: Y.createTypedArray(s.componentDatatype, a) })) } return i } var sSe = new h; function tG(e, t) { let n = e.length, i, o, r, s, a = e[0].modelMatrix, c = l(e[0][t].indices), u = e[0][t].primitiveType, f = rSe(e, t), d, p, g; for (i in f) if (f.hasOwnProperty(i)) for (d = f[i].values, s = 0, o = 0; o < n; ++o)for (p = e[o][t].attributes[i].values, g = p.length, r = 0; r < g; ++r)d[s++] = p[r]; let m; if (c) { let T = 0; for (o = 0; o < n; ++o)T += e[o][t].indices.length; let b = st.computeNumberOfVertices(new st({ attributes: f, primitiveType: Oe.POINTS })), S = Me.createTypedArray(b, T), D = 0, P = 0; for (o = 0; o < n; ++o) { let B = e[o][t].indices, R = B.length; for (s = 0; s < R; ++s)S[D++] = P + B[s]; P += st.computeNumberOfVertices(e[o][t]) } m = S } let A = new h, C = 0, x; for (o = 0; o < n; ++o) { if (x = e[o][t].boundingSphere, !l(x)) { A = void 0; break } h.add(x.center, A, A) } if (l(A)) for (h.divideByScalar(A, n, A), o = 0; o < n; ++o) { x = e[o][t].boundingSphere; let T = h.magnitude(h.subtract(x.center, A, sSe)) + x.radius; T > C && (C = T) } return new st({ attributes: f, indices: m, primitiveType: u, boundingSphere: l(A) ? new re(A, C) : void 0 }) } Za.combineInstances = function (e) { let t = [], n = [], i = e.length; for (let r = 0; r < i; ++r) { let s = e[r]; l(s.geometry) ? t.push(s) : l(s.westHemisphereGeometry) && l(s.eastHemisphereGeometry) && n.push(s) } let o = []; return t.length > 0 && o.push(tG(t, "geometry")), n.length > 0 && (o.push(tG(n, "westHemisphereGeometry")), o.push(tG(n, "eastHemisphereGeometry"))), o }; var tu = new h, bb = new h, hC = new h, mC = new h; Za.computeNormal = function (e) { let t = e.indices, n = e.attributes, i = n.position.values, o = n.position.values.length / 3, r = t.length, s = new Array(o), a = new Array(r / 3), c = new Array(r), u; for (u = 0; u < o; u++)s[u] = { indexOffset: 0, count: 0, currentCount: 0 }; let f = 0; for (u = 0; u < r; u += 3) { let m = t[u], A = t[u + 1], C = t[u + 2], x = m * 3, T = A * 3, b = C * 3; bb.x = i[x], bb.y = i[x + 1], bb.z = i[x + 2], hC.x = i[T], hC.y = i[T + 1], hC.z = i[T + 2], mC.x = i[b], mC.y = i[b + 1], mC.z = i[b + 2], s[m].count++, s[A].count++, s[C].count++, h.subtract(hC, bb, hC), h.subtract(mC, bb, mC), a[f] = h.cross(hC, mC, new h), f++ } let d = 0; for (u = 0; u < o; u++)s[u].indexOffset += d, d += s[u].count; f = 0; let p; for (u = 0; u < r; u += 3) { p = s[t[u]]; let m = p.indexOffset + p.currentCount; c[m] = f, p.currentCount++, p = s[t[u + 1]], m = p.indexOffset + p.currentCount, c[m] = f, p.currentCount++, p = s[t[u + 2]], m = p.indexOffset + p.currentCount, c[m] = f, p.currentCount++, f++ } let g = new Float32Array(o * 3); for (u = 0; u < o; u++) { let m = u * 3; if (p = s[u], h.clone(h.ZERO, tu), p.count > 0) { for (f = 0; f < p.count; f++)h.add(tu, a[c[p.indexOffset + f]], tu); h.equalsEpsilon(h.ZERO, tu, I.EPSILON10) && h.clone(a[c[p.indexOffset]], tu) } h.equalsEpsilon(h.ZERO, tu, I.EPSILON10) && (tu.z = 1), h.normalize(tu, tu), g[m] = tu.x, g[m + 1] = tu.y, g[m + 2] = tu.z } return e.attributes.normal = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: g }), e }; var aSe = new h, rJ = new h, cSe = new h; Za.computeTangentAndBitangent = function (e) { let t = e.attributes, n = e.indices, i = e.attributes.position.values, o = e.attributes.normal.values, r = e.attributes.st.values, s = e.attributes.position.values.length / 3, a = n.length, c = new Array(s * 3), u; for (u = 0; u < c.length; u++)c[u] = 0; let f, d, p; for (u = 0; u < a; u += 3) { let A = n[u], C = n[u + 1], x = n[u + 2]; f = A * 3, d = C * 3, p = x * 3; let T = A * 2, b = C * 2, S = x * 2, D = i[f], P = i[f + 1], B = i[f + 2], R = r[T], M = r[T + 1], L = r[b + 1] - M, _ = r[S + 1] - M, E = 1 / ((r[b] - R) * _ - (r[S] - R) * L), w = (_ * (i[d] - D) - L * (i[p] - D)) * E, v = (_ * (i[d + 1] - P) - L * (i[p + 1] - P)) * E, O = (_ * (i[d + 2] - B) - L * (i[p + 2] - B)) * E; c[f] += w, c[f + 1] += v, c[f + 2] += O, c[d] += w, c[d + 1] += v, c[d + 2] += O, c[p] += w, c[p + 1] += v, c[p + 2] += O } let g = new Float32Array(s * 3), m = new Float32Array(s * 3); for (u = 0; u < s; u++) { f = u * 3, d = f + 1, p = f + 2; let A = h.fromArray(o, f, aSe), C = h.fromArray(c, f, cSe), x = h.dot(A, C); h.multiplyByScalar(A, x, rJ), h.normalize(h.subtract(C, rJ, C), C), g[f] = C.x, g[d] = C.y, g[p] = C.z, h.normalize(h.cross(A, C, C), C), m[f] = C.x, m[d] = C.y, m[p] = C.z } return e.attributes.tangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: g }), e.attributes.bitangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: m }), e }; var Sb = new H, df = new h, sJ = new h, aJ = new h, iB = new H; Za.compressVertices = function (e) { let t = e.attributes.extrudeDirection, n, i; if (l(t)) { let P = t.values; i = P.length / 3; let B = new Float32Array(i * 2), R = 0; for (n = 0; n < i; ++n) { if (h.fromArray(P, n * 3, df), h.equals(df, h.ZERO)) { R += 2; continue } iB = kn.octEncodeInRange(df, 65535, iB), B[R++] = iB.x, B[R++] = iB.y } return e.attributes.compressedAttributes = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: B }), delete e.attributes.extrudeDirection, e } let o = e.attributes.normal, r = e.attributes.st, s = l(o), a = l(r); if (!s && !a) return e; let c = e.attributes.tangent, u = e.attributes.bitangent, f = l(c), d = l(u), p, g, m, A; s && (p = o.values), a && (g = r.values), f && (m = c.values), d && (A = u.values), i = (s ? p.length : g.length) / (s ? 3 : 2); let T = i, b = a && s ? 2 : 1; b += f || d ? 1 : 0, T *= b; let S = new Float32Array(T), D = 0; for (n = 0; n < i; ++n) { a && (H.fromArray(g, n * 2, Sb), S[D++] = kn.compressTextureCoordinates(Sb)); let P = n * 3; s && l(m) && l(A) ? (h.fromArray(p, P, df), h.fromArray(m, P, sJ), h.fromArray(A, P, aJ), kn.octPack(df, sJ, aJ, Sb), S[D++] = Sb.x, S[D++] = Sb.y) : (s && (h.fromArray(p, P, df), S[D++] = kn.octEncodeFloat(df)), f && (h.fromArray(m, P, df), S[D++] = kn.octEncodeFloat(df)), d && (h.fromArray(A, P, df), S[D++] = kn.octEncodeFloat(df))) } return e.attributes.compressedAttributes = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: b, values: S }), s && delete e.attributes.normal, a && delete e.attributes.st, d && delete e.attributes.bitangent, f && delete e.attributes.tangent, e }; function lSe(e) { if (l(e.indices)) return e; let t = st.computeNumberOfVertices(e), n = Me.createTypedArray(t, t); for (let i = 0; i < t; ++i)n[i] = i; return e.indices = n, e } function uSe(e) { let t = st.computeNumberOfVertices(e), n = Me.createTypedArray(t, (t - 2) * 3); n[0] = 1, n[1] = 0, n[2] = 2; let i = 3; for (let o = 3; o < t; ++o)n[i++] = o - 1, n[i++] = 0, n[i++] = o; return e.indices = n, e.primitiveType = Oe.TRIANGLES, e } function fSe(e) { let t = st.computeNumberOfVertices(e), n = Me.createTypedArray(t, (t - 2) * 3); n[0] = 0, n[1] = 1, n[2] = 2, t > 3 && (n[3] = 0, n[4] = 2, n[5] = 3); let i = 6; for (let o = 3; o < t - 1; o += 2)n[i++] = o, n[i++] = o - 1, n[i++] = o + 1, o + 2 < t && (n[i++] = o, n[i++] = o + 1, n[i++] = o + 2); return e.indices = n, e.primitiveType = Oe.TRIANGLES, e } function dSe(e) { if (l(e.indices)) return e; let t = st.computeNumberOfVertices(e), n = Me.createTypedArray(t, t); for (let i = 0; i < t; ++i)n[i] = i; return e.indices = n, e } function hSe(e) { let t = st.computeNumberOfVertices(e), n = Me.createTypedArray(t, (t - 1) * 2); n[0] = 0, n[1] = 1; let i = 2; for (let o = 2; o < t; ++o)n[i++] = o - 1, n[i++] = o; return e.indices = n, e.primitiveType = Oe.LINES, e } function mSe(e) { let t = st.computeNumberOfVertices(e), n = Me.createTypedArray(t, t * 2); n[0] = 0, n[1] = 1; let i = 2; for (let o = 2; o < t; ++o)n[i++] = o - 1, n[i++] = o; return n[i++] = t - 1, n[i] = 0, e.indices = n, e.primitiveType = Oe.LINES, e } function pSe(e) { switch (e.primitiveType) { case Oe.TRIANGLE_FAN: return uSe(e); case Oe.TRIANGLE_STRIP: return fSe(e); case Oe.TRIANGLES: return lSe(e); case Oe.LINE_STRIP: return hSe(e); case Oe.LINE_LOOP: return mSe(e); case Oe.LINES: return dSe(e) }return e } function Np(e, t) { Math.abs(e.y) < I.EPSILON6 && (t ? e.y = -I.EPSILON6 : e.y = I.EPSILON6) } function _Se(e, t, n) { if (e.y !== 0 && t.y !== 0 && n.y !== 0) { Np(e, e.y < 0), Np(t, t.y < 0), Np(n, n.y < 0); return } let i = Math.abs(e.y), o = Math.abs(t.y), r = Math.abs(n.y), s; i > o ? i > r ? s = I.sign(e.y) : s = I.sign(n.y) : o > r ? s = I.sign(t.y) : s = I.sign(n.y); let a = s < 0; Np(e, a), Np(t, a), Np(n, a) } var cJ = new h; function nu(e, t, n, i) { h.add(e, h.multiplyByScalar(h.subtract(t, e, cJ), e.y / (e.y - t.y), cJ), n), h.clone(n, i), Np(n, !0), Np(i, !1) } var g0 = new h, y0 = new h, A0 = new h, C0 = new h, nG = { positions: new Array(7), indices: new Array(3 * 3) }; function gSe(e, t, n) { if (e.x >= 0 || t.x >= 0 || n.x >= 0) return; _Se(e, t, n); let i = e.y < 0, o = t.y < 0, r = n.y < 0, s = 0; s += i ? 1 : 0, s += o ? 1 : 0, s += r ? 1 : 0; let a = nG.indices; s === 1 ? (a[1] = 3, a[2] = 4, a[5] = 6, a[7] = 6, a[8] = 5, i ? (nu(e, t, g0, A0), nu(e, n, y0, C0), a[0] = 0, a[3] = 1, a[4] = 2, a[6] = 1) : o ? (nu(t, n, g0, A0), nu(t, e, y0, C0), a[0] = 1, a[3] = 2, a[4] = 0, a[6] = 2) : r && (nu(n, e, g0, A0), nu(n, t, y0, C0), a[0] = 2, a[3] = 0, a[4] = 1, a[6] = 0)) : s === 2 && (a[2] = 4, a[4] = 4, a[5] = 3, a[7] = 5, a[8] = 6, i ? o ? r || (nu(n, e, g0, A0), nu(n, t, y0, C0), a[0] = 0, a[1] = 1, a[3] = 0, a[6] = 2) : (nu(t, n, g0, A0), nu(t, e, y0, C0), a[0] = 2, a[1] = 0, a[3] = 2, a[6] = 1) : (nu(e, t, g0, A0), nu(e, n, y0, C0), a[0] = 1, a[1] = 2, a[3] = 1, a[6] = 0)); let c = nG.positions; return c[0] = e, c[1] = t, c[2] = n, c.length = 3, (s === 1 || s === 2) && (c[3] = g0, c[4] = y0, c[5] = A0, c[6] = C0, c.length = 7), nG } function lJ(e, t) { let n = e.attributes; if (n.position.values.length === 0) return; for (let o in n) if (n.hasOwnProperty(o) && l(n[o]) && l(n[o].values)) { let r = n[o]; r.values = Y.createTypedArray(r.componentDatatype, r.values) } let i = st.computeNumberOfVertices(e); return e.indices = Me.createTypedArray(i, e.indices), t && (e.boundingSphere = re.fromVertices(n.position.values)), e } function _C(e) { let t = e.attributes, n = {}; for (let i in t) if (t.hasOwnProperty(i) && l(t[i]) && l(t[i].values)) { let o = t[i]; n[i] = new be({ componentDatatype: o.componentDatatype, componentsPerAttribute: o.componentsPerAttribute, normalize: o.normalize, values: [] }) } return new st({ attributes: n, indices: [], primitiveType: e.primitiveType }) } function sG(e, t, n) { let i = l(e.geometry.boundingSphere); t = lJ(t, i), n = lJ(n, i), l(n) && !l(t) ? e.geometry = n : !l(n) && l(t) ? e.geometry = t : (e.westHemisphereGeometry = t, e.eastHemisphereGeometry = n, e.geometry = void 0) } function aG(e, t) { let n = new e, i = new e, o = new e; return function (r, s, a, c, u, f, d, p) { let g = e.fromArray(u, r * t, n), m = e.fromArray(u, s * t, i), A = e.fromArray(u, a * t, o); e.multiplyByScalar(g, c.x, g), e.multiplyByScalar(m, c.y, m), e.multiplyByScalar(A, c.z, A); let C = e.add(g, m, g); e.add(C, A, C), p && e.normalize(C, C), e.pack(C, f, d * t) } } var ySe = aG(se, 4), sB = aG(h, 3), pJ = aG(H, 2), ASe = function (e, t, n, i, o, r, s) { let a = o[e] * i.x, c = o[t] * i.y, u = o[n] * i.z; r[s] = a + c + u > I.EPSILON6 ? 1 : 0 }, wb = new h, iG = new h, oG = new h, CSe = new h; function oB(e, t, n, i, o, r, s, a, c, u, f, d, p, g, m, A) { if (!l(r) && !l(s) && !l(a) && !l(c) && !l(u) && g === 0) return; let C = h.fromArray(o, e * 3, wb), x = h.fromArray(o, t * 3, iG), T = h.fromArray(o, n * 3, oG), b = dC(i, C, x, T, CSe); if (!!l(b)) { if (l(r) && sB(e, t, n, b, r, d.normal.values, A, !0), l(u)) { let S = h.fromArray(u, e * 3, wb), D = h.fromArray(u, t * 3, iG), P = h.fromArray(u, n * 3, oG); h.multiplyByScalar(S, b.x, S), h.multiplyByScalar(D, b.y, D), h.multiplyByScalar(P, b.z, P); let B; !h.equals(S, h.ZERO) || !h.equals(D, h.ZERO) || !h.equals(P, h.ZERO) ? (B = h.add(S, D, S), h.add(B, P, B), h.normalize(B, B)) : (B = wb, B.x = 0, B.y = 0, B.z = 0), h.pack(B, d.extrudeDirection.values, A * 3) } if (l(f) && ASe(e, t, n, b, f, d.applyOffset.values, A), l(s) && sB(e, t, n, b, s, d.tangent.values, A, !0), l(a) && sB(e, t, n, b, a, d.bitangent.values, A, !0), l(c) && pJ(e, t, n, b, c, d.st.values, A), g > 0) for (let S = 0; S < g; S++) { let D = p[S]; xSe(e, t, n, b, A, m[D], d[D]) } } } function xSe(e, t, n, i, o, r, s) { let a = r.componentsPerAttribute, c = r.values, u = s.values; switch (a) { case 4: ySe(e, t, n, i, c, u, o, !1); break; case 3: sB(e, t, n, i, c, u, o, !1); break; case 2: pJ(e, t, n, i, c, u, o, !1); break; default: u[o] = c[e] * i.x + c[t] * i.y + c[n] * i.z } } function Od(e, t, n, i, o, r) { let s = e.position.values.length / 3; if (o !== -1) { let a = i[o], c = n[a]; return c === -1 ? (n[a] = s, e.position.values.push(r.x, r.y, r.z), t.push(s), s) : (t.push(c), c) } return e.position.values.push(r.x, r.y, r.z), t.push(s), s } var TSe = { position: !0, normal: !0, bitangent: !0, tangent: !0, st: !0, extrudeDirection: !0, applyOffset: !0 }; function uJ(e) { let t = e.geometry, n = t.attributes, i = n.position.values, o = l(n.normal) ? n.normal.values : void 0, r = l(n.bitangent) ? n.bitangent.values : void 0, s = l(n.tangent) ? n.tangent.values : void 0, a = l(n.st) ? n.st.values : void 0, c = l(n.extrudeDirection) ? n.extrudeDirection.values : void 0, u = l(n.applyOffset) ? n.applyOffset.values : void 0, f = t.indices, d = []; for (let B in n) n.hasOwnProperty(B) && !TSe[B] && l(n[B]) && d.push(B); let p = d.length, g = _C(t), m = _C(t), A, C, x, T, b, S = []; S.length = i.length / 3; let D = []; for (D.length = i.length / 3, b = 0; b < S.length; ++b)S[b] = -1, D[b] = -1; let P = f.length; for (b = 0; b < P; b += 3) { let B = f[b], R = f[b + 1], M = f[b + 2], L = h.fromArray(i, B * 3), _ = h.fromArray(i, R * 3), E = h.fromArray(i, M * 3), w = gSe(L, _, E); if (l(w) && w.positions.length > 3) { let v = w.positions, O = w.indices, V = O.length; for (let z = 0; z < V; ++z) { let k = O[z], G = v[k]; G.y < 0 ? (A = m.attributes, C = m.indices, x = S) : (A = g.attributes, C = g.indices, x = D), T = Od(A, C, x, f, k < 3 ? b + k : -1, G), oB(B, R, M, G, i, o, s, r, a, c, u, A, d, p, n, T) } } else l(w) && (L = w.positions[0], _ = w.positions[1], E = w.positions[2]), L.y < 0 ? (A = m.attributes, C = m.indices, x = S) : (A = g.attributes, C = g.indices, x = D), T = Od(A, C, x, f, b, L), oB(B, R, M, L, i, o, s, r, a, c, u, A, d, p, n, T), T = Od(A, C, x, f, b + 1, _), oB(B, R, M, _, i, o, s, r, a, c, u, A, d, p, n, T), T = Od(A, C, x, f, b + 2, E), oB(B, R, M, E, i, o, s, r, a, c, u, A, d, p, n, T) } sG(e, m, g) } var _J = nn.fromPointNormal(h.ZERO, h.UNIT_Y), ESe = new h, bSe = new h; function pC(e, t, n, i, o, r, s) { if (!l(s)) return; let a = h.fromArray(i, e * 3, wb); h.equalsEpsilon(a, n, I.EPSILON10) ? r.applyOffset.values[o] = s[e] : r.applyOffset.values[o] = s[t] } function fJ(e) { let t = e.geometry, n = t.attributes, i = n.position.values, o = l(n.applyOffset) ? n.applyOffset.values : void 0, r = t.indices, s = _C(t), a = _C(t), c, u = r.length, f = []; f.length = i.length / 3; let d = []; for (d.length = i.length / 3, c = 0; c < f.length; ++c)f[c] = -1, d[c] = -1; for (c = 0; c < u; c += 2) { let p = r[c], g = r[c + 1], m = h.fromArray(i, p * 3, wb), A = h.fromArray(i, g * 3, iG), C; Math.abs(m.y) < I.EPSILON6 && (m.y < 0 ? m.y = -I.EPSILON6 : m.y = I.EPSILON6), Math.abs(A.y) < I.EPSILON6 && (A.y < 0 ? A.y = -I.EPSILON6 : A.y = I.EPSILON6); let x = s.attributes, T = s.indices, b = d, S = a.attributes, D = a.indices, P = f, B = Gi.lineSegmentPlane(m, A, _J, oG); if (l(B)) { let R = h.multiplyByScalar(h.UNIT_Y, 5 * I.EPSILON9, ESe); m.y < 0 && (h.negate(R, R), x = a.attributes, T = a.indices, b = f, S = s.attributes, D = s.indices, P = d); let M = h.add(B, R, bSe); C = Od(x, T, b, r, c, m), pC(p, g, m, i, C, x, o), C = Od(x, T, b, r, -1, M), pC(p, g, M, i, C, x, o), h.negate(R, R), h.add(B, R, M), C = Od(S, D, P, r, -1, M), pC(p, g, M, i, C, S, o), C = Od(S, D, P, r, c + 1, A), pC(p, g, A, i, C, S, o) } else { let R, M, L; m.y < 0 ? (R = a.attributes, M = a.indices, L = f) : (R = s.attributes, M = s.indices, L = d), C = Od(R, M, L, r, c, m), pC(p, g, m, i, C, R, o), C = Od(R, M, L, r, c + 1, A), pC(p, g, A, i, C, R, o) } } sG(e, a, s) } var dJ = new H, SSe = new H, gJ = new h, yJ = new h, rG = new h, wSe = new h, DSe = new h, vSe = new h, hJ = new se; function mJ(e) { let t = e.attributes, n = t.position.values, i = t.prevPosition.values, o = t.nextPosition.values, r = n.length; for (let s = 0; s < r; s += 3) { let a = h.unpack(n, s, gJ); if (a.x > 0) continue; let c = h.unpack(i, s, yJ); (a.y < 0 && c.y > 0 || a.y > 0 && c.y < 0) && (s - 3 > 0 ? (i[s] = n[s - 3], i[s + 1] = n[s - 2], i[s + 2] = n[s - 1]) : h.pack(a, i, s)); let u = h.unpack(o, s, rG); (a.y < 0 && u.y > 0 || a.y > 0 && u.y < 0) && (s + 3 < r ? (o[s] = n[s + 3], o[s + 1] = n[s + 4], o[s + 2] = n[s + 5]) : h.pack(a, o, s)) } } var PSe = 5 * I.EPSILON9, rB = I.EPSILON6; function ISe(e) { let t = e.geometry, n = t.attributes, i = n.position.values, o = n.prevPosition.values, r = n.nextPosition.values, s = n.expandAndWidth.values, a = l(n.st) ? n.st.values : void 0, c = l(n.color) ? n.color.values : void 0, u = _C(t), f = _C(t), d, p, g, m = !1, A = i.length / 3; for (d = 0; d < A; d += 4) { let C = d, x = d + 2, T = h.fromArray(i, C * 3, gJ), b = h.fromArray(i, x * 3, yJ); if (Math.abs(T.y) < rB) for (T.y = rB * (b.y < 0 ? -1 : 1), i[d * 3 + 1] = T.y, i[(d + 1) * 3 + 1] = T.y, p = C * 3; p < C * 3 + 4 * 3; p += 3)o[p] = i[d * 3], o[p + 1] = i[d * 3 + 1], o[p + 2] = i[d * 3 + 2]; if (Math.abs(b.y) < rB) for (b.y = rB * (T.y < 0 ? -1 : 1), i[(d + 2) * 3 + 1] = b.y, i[(d + 3) * 3 + 1] = b.y, p = C * 3; p < C * 3 + 4 * 3; p += 3)r[p] = i[(d + 2) * 3], r[p + 1] = i[(d + 2) * 3 + 1], r[p + 2] = i[(d + 2) * 3 + 2]; let S = u.attributes, D = u.indices, P = f.attributes, B = f.indices, R = Gi.lineSegmentPlane(T, b, _J, wSe); if (l(R)) { m = !0; let M = h.multiplyByScalar(h.UNIT_Y, PSe, DSe); T.y < 0 && (h.negate(M, M), S = f.attributes, D = f.indices, P = u.attributes, B = u.indices); let L = h.add(R, M, vSe); S.position.values.push(T.x, T.y, T.z, T.x, T.y, T.z), S.position.values.push(L.x, L.y, L.z), S.position.values.push(L.x, L.y, L.z), S.prevPosition.values.push(o[C * 3], o[C * 3 + 1], o[C * 3 + 2]), S.prevPosition.values.push(o[C * 3 + 3], o[C * 3 + 4], o[C * 3 + 5]), S.prevPosition.values.push(T.x, T.y, T.z, T.x, T.y, T.z), S.nextPosition.values.push(L.x, L.y, L.z), S.nextPosition.values.push(L.x, L.y, L.z), S.nextPosition.values.push(L.x, L.y, L.z), S.nextPosition.values.push(L.x, L.y, L.z), h.negate(M, M), h.add(R, M, L), P.position.values.push(L.x, L.y, L.z), P.position.values.push(L.x, L.y, L.z), P.position.values.push(b.x, b.y, b.z, b.x, b.y, b.z), P.prevPosition.values.push(L.x, L.y, L.z), P.prevPosition.values.push(L.x, L.y, L.z), P.prevPosition.values.push(L.x, L.y, L.z), P.prevPosition.values.push(L.x, L.y, L.z), P.nextPosition.values.push(b.x, b.y, b.z, b.x, b.y, b.z), P.nextPosition.values.push(r[x * 3], r[x * 3 + 1], r[x * 3 + 2]), P.nextPosition.values.push(r[x * 3 + 3], r[x * 3 + 4], r[x * 3 + 5]); let _ = H.fromArray(s, C * 2, dJ), E = Math.abs(_.y); S.expandAndWidth.values.push(-1, E, 1, E), S.expandAndWidth.values.push(-1, -E, 1, -E), P.expandAndWidth.values.push(-1, E, 1, E), P.expandAndWidth.values.push(-1, -E, 1, -E); let w = h.magnitudeSquared(h.subtract(R, T, rG)); if (w /= h.magnitudeSquared(h.subtract(b, T, rG)), l(c)) { let v = se.fromArray(c, C * 4, hJ), O = se.fromArray(c, x * 4, hJ), V = I.lerp(v.x, O.x, w), z = I.lerp(v.y, O.y, w), k = I.lerp(v.z, O.z, w), G = I.lerp(v.w, O.w, w); for (p = C * 4; p < C * 4 + 2 * 4; ++p)S.color.values.push(c[p]); for (S.color.values.push(V, z, k, G), S.color.values.push(V, z, k, G), P.color.values.push(V, z, k, G), P.color.values.push(V, z, k, G), p = x * 4; p < x * 4 + 2 * 4; ++p)P.color.values.push(c[p]) } if (l(a)) { let v = H.fromArray(a, C * 2, dJ), O = H.fromArray(a, (d + 3) * 2, SSe), V = I.lerp(v.x, O.x, w); for (p = C * 2; p < C * 2 + 2 * 2; ++p)S.st.values.push(a[p]); for (S.st.values.push(V, v.y), S.st.values.push(V, O.y), P.st.values.push(V, v.y), P.st.values.push(V, O.y), p = x * 2; p < x * 2 + 2 * 2; ++p)P.st.values.push(a[p]) } g = S.position.values.length / 3 - 4, D.push(g, g + 2, g + 1), D.push(g + 1, g + 2, g + 3), g = P.position.values.length / 3 - 4, B.push(g, g + 2, g + 1), B.push(g + 1, g + 2, g + 3) } else { let M, L; for (T.y < 0 ? (M = f.attributes, L = f.indices) : (M = u.attributes, L = u.indices), M.position.values.push(T.x, T.y, T.z), M.position.values.push(T.x, T.y, T.z), M.position.values.push(b.x, b.y, b.z), M.position.values.push(b.x, b.y, b.z), p = d * 3; p < d * 3 + 4 * 3; ++p)M.prevPosition.values.push(o[p]), M.nextPosition.values.push(r[p]); for (p = d * 2; p < d * 2 + 4 * 2; ++p)M.expandAndWidth.values.push(s[p]), l(a) && M.st.values.push(a[p]); if (l(c)) for (p = d * 4; p < d * 4 + 4 * 4; ++p)M.color.values.push(c[p]); g = M.position.values.length / 3 - 4, L.push(g, g + 2, g + 1), L.push(g + 1, g + 2, g + 3) } } m && (mJ(f), mJ(u)), sG(e, f, u) } Za.splitLongitude = function (e) { let t = e.geometry, n = t.boundingSphere; if (l(n) && (n.center.x - n.radius > 0 || re.intersectPlane(n, nn.ORIGIN_ZX_PLANE) !== Kt.INTERSECTING)) return e; if (t.geometryType !== af.NONE) switch (t.geometryType) { case af.POLYLINES: ISe(e); break; case af.TRIANGLES: uJ(e); break; case af.LINES: fJ(e); break } else pSe(t), t.primitiveType === Oe.TRIANGLES ? uJ(e) : t.primitiveType === Oe.LINES && fJ(e); return e }; var Bn = Za; function Oc(e) { this._ellipsoid = y(e, ie.WGS84), this._semimajorAxis = this._ellipsoid.maximumRadius, this._oneOverSemimajorAxis = 1 / this._semimajorAxis } Object.defineProperties(Oc.prototype, { ellipsoid: { get: function () { return this._ellipsoid } } }); Oc.mercatorAngleToGeodeticLatitude = function (e) { return I.PI_OVER_TWO - 2 * Math.atan(Math.exp(-e)) }; Oc.geodeticLatitudeToMercatorAngle = function (e) { e > Oc.MaximumLatitude ? e = Oc.MaximumLatitude : e < -Oc.MaximumLatitude && (e = -Oc.MaximumLatitude); let t = Math.sin(e); return .5 * Math.log((1 + t) / (1 - t)) }; Oc.MaximumLatitude = Oc.mercatorAngleToGeodeticLatitude(Math.PI); Oc.prototype.project = function (e, t) { let n = this._semimajorAxis, i = e.longitude * n, o = Oc.geodeticLatitudeToMercatorAngle(e.latitude) * n, r = e.height; return l(t) ? (t.x = i, t.y = o, t.z = r, t) : new h(i, o, r) }; Oc.prototype.unproject = function (e, t) { let n = this._oneOverSemimajorAxis, i = e.x * n, o = Oc.mercatorAngleToGeodeticLatitude(e.y * n), r = e.z; return l(t) ? (t.longitude = i, t.latitude = o, t.height = r, t) : new he(i, o, r) }; var Ri = Oc; function OSe(e, t, n) { let i = !n, o = e.length, r; if (!i && o > 1) { let s = e[0].modelMatrix; for (r = 1; r < o; ++r)if (!F.equals(s, e[r].modelMatrix)) { i = !0; break } } if (i) for (r = 0; r < o; ++r)l(e[r].geometry) && Bn.transformToWorldCoordinates(e[r]); else F.multiplyTransformation(t, e[0].modelMatrix, t) } function cG(e, t) { let n = e.attributes, i = n.position, o = i.values.length / i.componentsPerAttribute; n.batchId = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 1, values: new Float32Array(o) }); let r = n.batchId.values; for (let s = 0; s < o; ++s)r[s] = t } function BSe(e) { let t = e.length; for (let n = 0; n < t; ++n) { let i = e[n]; l(i.geometry) ? cG(i.geometry, n) : l(i.westHemisphereGeometry) && l(i.eastHemisphereGeometry) && (cG(i.westHemisphereGeometry, n), cG(i.eastHemisphereGeometry, n)) } } function RSe(e) { let t = e.instances, n = e.projection, i = e.elementIndexUintSupported, o = e.scene3DOnly, r = e.vertexCacheOptimize, s = e.compressVertices, a = e.modelMatrix, c, u, f, d = t.length; for (c = 0; c < d; ++c)if (l(t[c].geometry)) { f = t[c].geometry.primitiveType; break } if (OSe(t, a, o), !o) for (c = 0; c < d; ++c)l(t[c].geometry) && Bn.splitLongitude(t[c]); if (BSe(t), r) for (c = 0; c < d; ++c) { let g = t[c]; l(g.geometry) ? (Bn.reorderForPostVertexCache(g.geometry), Bn.reorderForPreVertexCache(g.geometry)) : l(g.westHemisphereGeometry) && l(g.eastHemisphereGeometry) && (Bn.reorderForPostVertexCache(g.westHemisphereGeometry), Bn.reorderForPreVertexCache(g.westHemisphereGeometry), Bn.reorderForPostVertexCache(g.eastHemisphereGeometry), Bn.reorderForPreVertexCache(g.eastHemisphereGeometry)) } let p = Bn.combineInstances(t); for (d = p.length, c = 0; c < d; ++c) { u = p[c]; let g = u.attributes; if (o) for (let m in g) g.hasOwnProperty(m) && g[m].componentDatatype === Y.DOUBLE && Bn.encodeAttribute(u, m, `${m}3DHigh`, `${m}3DLow`); else for (let m in g) if (g.hasOwnProperty(m) && g[m].componentDatatype === Y.DOUBLE) { let A = `${m}3D`, C = `${m}2D`; Bn.projectTo2D(u, m, A, C, n), l(u.boundingSphere) && m === "position" && (u.boundingSphereCV = re.fromVertices(u.attributes.position2D.values)), Bn.encodeAttribute(u, A, `${A}High`, `${A}Low`), Bn.encodeAttribute(u, C, `${C}High`, `${C}Low`) } s && Bn.compressVertices(u) } if (!i) { let g = []; for (d = p.length, c = 0; c < d; ++c)u = p[c], g = g.concat(Bn.fitToUnsignedShortIndices(u)); p = g } return p } function lG(e, t, n, i) { let o, r, s, a = i.length - 1; if (a >= 0) { let u = i[a]; o = u.offset + u.count, s = u.index, r = n[s].indices.length } else o = 0, s = 0, r = n[s].indices.length; let c = e.length; for (let u = 0; u < c; ++u) { let d = e[u][t]; if (!l(d)) continue; let p = d.indices.length; o + p > r && (o = 0, r = n[++s].indices.length), i.push({ index: s, offset: o, count: p }), o += p } } function MSe(e, t) { let n = []; return lG(e, "geometry", t, n), lG(e, "westHemisphereGeometry", t, n), lG(e, "eastHemisphereGeometry", t, n), n } var rm = {}; rm.combineGeometry = function (e) { let t, n, i = e.instances, o = i.length, r, s, a = !1; o > 0 && (t = RSe(e), t.length > 0 && (n = Bn.createAttributeLocations(t[0]), e.createPickOffsets && (r = MSe(i, t))), l(i[0].attributes) && l(i[0].attributes.offset) && (s = new Array(o), a = !0)); let c = new Array(o), u = new Array(o); for (let f = 0; f < o; ++f) { let d = i[f], p = d.geometry; l(p) && (c[f] = p.boundingSphere, u[f] = p.boundingSphereCV, a && (s[f] = d.geometry.offsetAttribute)); let g = d.eastHemisphereGeometry, m = d.westHemisphereGeometry; l(g) && l(m) && (l(g.boundingSphere) && l(m.boundingSphere) && (c[f] = re.union(g.boundingSphere, m.boundingSphere)), l(g.boundingSphereCV) && l(m.boundingSphereCV) && (u[f] = re.union(g.boundingSphereCV, m.boundingSphereCV))) } return { geometries: t, modelMatrix: e.modelMatrix, attributeLocations: n, pickOffsets: r, offsetInstanceExtend: s, boundingSpheres: c, boundingSpheresCV: u } }; function LSe(e, t) { let n = e.attributes; for (let i in n) if (n.hasOwnProperty(i)) { let o = n[i]; l(o) && l(o.values) && t.push(o.values.buffer) } l(e.indices) && t.push(e.indices.buffer) } function FSe(e, t) { let n = e.length; for (let i = 0; i < n; ++i)LSe(e[i], t) } function NSe(e) { let t = 1, n = e.length; for (let i = 0; i < n; i++) { let o = e[i]; if (++t, !l(o)) continue; let r = o.attributes; t += 7 + 2 * re.packedLength + (l(o.indices) ? o.indices.length : 0); for (let s in r) if (r.hasOwnProperty(s) && l(r[s])) { let a = r[s]; t += 5 + a.values.length } } return t } rm.packCreateGeometryResults = function (e, t) { let n = new Float64Array(NSe(e)), i = [], o = {}, r = e.length, s = 0; n[s++] = r; for (let a = 0; a < r; a++) { let c = e[a], u = l(c); if (n[s++] = u ? 1 : 0, !u) continue; n[s++] = c.primitiveType, n[s++] = c.geometryType, n[s++] = y(c.offsetAttribute, -1); let f = l(c.boundingSphere) ? 1 : 0; n[s++] = f, f && re.pack(c.boundingSphere, n, s), s += re.packedLength; let d = l(c.boundingSphereCV) ? 1 : 0; n[s++] = d, d && re.pack(c.boundingSphereCV, n, s), s += re.packedLength; let p = c.attributes, g = []; for (let A in p) p.hasOwnProperty(A) && l(p[A]) && (g.push(A), l(o[A]) || (o[A] = i.length, i.push(A))); n[s++] = g.length; for (let A = 0; A < g.length; A++) { let C = g[A], x = p[C]; n[s++] = o[C], n[s++] = x.componentDatatype, n[s++] = x.componentsPerAttribute, n[s++] = x.normalize ? 1 : 0, n[s++] = x.values.length, n.set(x.values, s), s += x.values.length } let m = l(c.indices) ? c.indices.length : 0; n[s++] = m, m > 0 && (n.set(c.indices, s), s += m) } return t.push(n.buffer), { stringTable: i, packedData: n } }; rm.unpackCreateGeometryResults = function (e) { let t = e.stringTable, n = e.packedData, i, o = new Array(n[0]), r = 0, s = 1; for (; s < n.length;) { if (!(n[s++] === 1)) { o[r++] = void 0; continue } let c = n[s++], u = n[s++], f = n[s++]; f === -1 && (f = void 0); let d, p; n[s++] === 1 && (d = re.unpack(n, s)), s += re.packedLength, n[s++] === 1 && (p = re.unpack(n, s)), s += re.packedLength; let A, C, x, T = new sn, b = n[s++]; for (i = 0; i < b; i++) { let D = t[n[s++]], P = n[s++]; x = n[s++]; let B = n[s++] !== 0; A = n[s++], C = Y.createTypedArray(P, A); for (let R = 0; R < A; R++)C[R] = n[s++]; T[D] = new be({ componentDatatype: P, componentsPerAttribute: x, normalize: B, values: C }) } let S; if (A = n[s++], A > 0) { let D = C.length / x; for (S = Me.createTypedArray(D, A), i = 0; i < A; i++)S[i] = n[s++] } o[r++] = new st({ primitiveType: c, geometryType: u, boundingSphere: d, boundingSphereCV: p, indices: S, attributes: T, offsetAttribute: f }) } return o }; function VSe(e, t) { let n = e.length, i = new Float64Array(1 + n * 19), o = 0; i[o++] = n; for (let r = 0; r < n; r++) { let s = e[r]; if (F.pack(s.modelMatrix, i, o), o += F.packedLength, l(s.attributes) && l(s.attributes.offset)) { let a = s.attributes.offset.value; i[o] = a[0], i[o + 1] = a[1], i[o + 2] = a[2] } o += 3 } return t.push(i.buffer), i } function kSe(e) { let t = e, n = new Array(t[0]), i = 0, o = 1; for (; o < t.length;) { let r = F.unpack(t, o), s; o += F.packedLength, l(t[o]) && (s = { offset: new zi(t[o], t[o + 1], t[o + 2]) }), o += 3, n[i++] = { modelMatrix: r, attributes: s } } return n } rm.packCombineGeometryParameters = function (e, t) { let n = e.createGeometryResults, i = n.length; for (let o = 0; o < i; o++)t.push(n[o].packedData.buffer); return { createGeometryResults: e.createGeometryResults, packedInstances: VSe(e.instances, t), ellipsoid: e.ellipsoid, isGeographic: e.projection instanceof _i, elementIndexUintSupported: e.elementIndexUintSupported, scene3DOnly: e.scene3DOnly, vertexCacheOptimize: e.vertexCacheOptimize, compressVertices: e.compressVertices, modelMatrix: e.modelMatrix, createPickOffsets: e.createPickOffsets } }; rm.unpackCombineGeometryParameters = function (e) { let t = kSe(e.packedInstances), n = e.createGeometryResults, i = n.length, o = 0; for (let a = 0; a < i; a++) { let c = rm.unpackCreateGeometryResults(n[a]), u = c.length; for (let f = 0; f < u; f++) { let d = c[f], p = t[o]; p.geometry = d, ++o } } let r = ie.clone(e.ellipsoid), s = e.isGeographic ? new _i(r) : new Ri(r); return { instances: t, ellipsoid: r, projection: s, elementIndexUintSupported: e.elementIndexUintSupported, scene3DOnly: e.scene3DOnly, vertexCacheOptimize: e.vertexCacheOptimize, compressVertices: e.compressVertices, modelMatrix: F.clone(e.modelMatrix), createPickOffsets: e.createPickOffsets } }; function AJ(e) { let t = e.length, n = 1 + (re.packedLength + 1) * t, i = new Float32Array(n), o = 0; i[o++] = t; for (let r = 0; r < t; ++r) { let s = e[r]; l(s) ? (i[o++] = 1, re.pack(e[r], i, o)) : i[o++] = 0, o += re.packedLength } return i } function CJ(e) { let t = new Array(e[0]), n = 0, i = 1; for (; i < e.length;)e[i++] === 1 && (t[n] = re.unpack(e, i)), ++n, i += re.packedLength; return t } rm.packCombineGeometryResults = function (e, t) { l(e.geometries) && FSe(e.geometries, t); let n = AJ(e.boundingSpheres), i = AJ(e.boundingSpheresCV); return t.push(n.buffer, i.buffer), { geometries: e.geometries, attributeLocations: e.attributeLocations, modelMatrix: e.modelMatrix, pickOffsets: e.pickOffsets, offsetInstanceExtend: e.offsetInstanceExtend, boundingSpheres: n, boundingSpheresCV: i } }; rm.unpackCombineGeometryResults = function (e) { return { geometries: e.geometries, attributeLocations: e.attributeLocations, modelMatrix: e.modelMatrix, pickOffsets: e.pickOffsets, offsetInstanceExtend: e.offsetInstanceExtend, boundingSpheres: CJ(e.boundingSpheres), boundingSpheresCV: CJ(e.boundingSpheresCV) } }; var gC = rm; var USe = { READY: 0, CREATING: 1, CREATED: 2, COMBINING: 3, COMBINED: 4, COMPLETE: 5, FAILED: 6 }, mr = Object.freeze(USe); var cB = { MORPHING: 0, COLUMBUS_VIEW: 1, SCENE2D: 2, SCENE3D: 3 }; cB.getMorphTime = function (e) { return e === cB.SCENE3D ? 1 : e === cB.MORPHING ? void 0 : 0 }; var ee = Object.freeze(cB); var fl = { DISABLED: 0, ENABLED: 1, CAST_ONLY: 2, RECEIVE_ONLY: 3 }; fl.NUMBER_OF_SHADOW_MODES = 4; fl.castShadows = function (e) { return e === fl.ENABLED || e === fl.CAST_ONLY }; fl.receiveShadows = function (e) { return e === fl.ENABLED || e === fl.RECEIVE_ONLY }; fl.fromCastReceive = function (e, t) { return e && t ? fl.ENABLED : e ? fl.CAST_ONLY : t ? fl.RECEIVE_ONLY : fl.DISABLED }; var hn = Object.freeze(fl); function sr(e) { e = y(e, y.EMPTY_OBJECT), this.geometryInstances = e.geometryInstances, this.appearance = e.appearance, this._appearance = void 0, this._material = void 0, this.depthFailAppearance = e.depthFailAppearance, this._depthFailAppearance = void 0, this._depthFailMaterial = void 0, this.modelMatrix = F.clone(y(e.modelMatrix, F.IDENTITY)), this._modelMatrix = new F, this.show = y(e.show, !0), this._vertexCacheOptimize = y(e.vertexCacheOptimize, !1), this._interleave = y(e.interleave, !1), this._releaseGeometryInstances = y(e.releaseGeometryInstances, !0), this._allowPicking = y(e.allowPicking, !0), this._asynchronous = y(e.asynchronous, !0), this._compressVertices = y(e.compressVertices, !0), this.cull = y(e.cull, !0), this.debugShowBoundingVolume = y(e.debugShowBoundingVolume, !1), this.rtcCenter = e.rtcCenter, this.shadows = y(e.shadows, hn.DISABLED), this._translucent = void 0, this._state = mr.READY, this._geometries = [], this._error = void 0, this._numberOfInstances = 0, this._boundingSpheres = [], this._boundingSphereWC = [], this._boundingSphereCV = [], this._boundingSphere2D = [], this._boundingSphereMorph = [], this._perInstanceAttributeCache = [], this._instanceIds = [], this._lastPerInstanceAttributeIndex = 0, this._va = [], this._attributeLocations = void 0, this._primitiveType = void 0, this._frontFaceRS = void 0, this._backFaceRS = void 0, this._sp = void 0, this._depthFailAppearance = void 0, this._spDepthFail = void 0, this._frontFaceDepthFailRS = void 0, this._backFaceDepthFailRS = void 0, this._pickIds = [], this._colorCommands = [], this._pickCommands = [], this._createBoundingVolumeFunction = e._createBoundingVolumeFunction, this._createRenderStatesFunction = e._createRenderStatesFunction, this._createShaderProgramFunction = e._createShaderProgramFunction, this._createCommandsFunction = e._createCommandsFunction, this._updateAndQueueCommandsFunction = e._updateAndQueueCommandsFunction, this._createPickOffsets = e._createPickOffsets, this._pickOffsets = void 0, this._createGeometryResults = void 0, this._ready = !1; let t = this; this._readyPromise = new Promise((n, i) => { t._completeLoad = (o, r, s) => { this._error = s, this._state = r, o.afterRender.push(function () { t._ready = t._state === mr.COMPLETE || t._state === mr.FAILED, l(s) ? i(s) : n(t) }) } }), this._batchTable = void 0, this._batchTableAttributeIndices = void 0, this._offsetInstanceExtend = void 0, this._batchTableOffsetAttribute2DIndex = void 0, this._batchTableOffsetsUpdated = !1, this._instanceBoundingSpheres = void 0, this._instanceBoundingSpheresCV = void 0, this._tempBoundingSpheres = void 0, this._recomputeBoundingSpheres = !1, this._batchTableBoundingSpheresUpdated = !1, this._batchTableBoundingSphereAttributeIndices = void 0 } Object.defineProperties(sr.prototype, { vertexCacheOptimize: { get: function () { return this._vertexCacheOptimize } }, interleave: { get: function () { return this._interleave } }, releaseGeometryInstances: { get: function () { return this._releaseGeometryInstances } }, allowPicking: { get: function () { return this._allowPicking } }, asynchronous: { get: function () { return this._asynchronous } }, compressVertices: { get: function () { return this._compressVertices } }, ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } } }); function zSe(e) { let t = e.length, n = [], i = e[0].attributes, o; for (o in i) if (i.hasOwnProperty(o) && l(i[o])) { let r = i[o], s = !0; for (let a = 1; a < t; ++a) { let c = e[a].attributes[o]; if (!l(c) || r.componentDatatype !== c.componentDatatype || r.componentsPerAttribute !== c.componentsPerAttribute || r.normalize !== c.normalize) { s = !1; break } } s && n.push(o) } return n } var HSe = new H, GSe = new h, PJ = new se; function IJ(e) { let t = e.length; if (t === 1) return e[0]; if (t === 2) return H.unpack(e, 0, HSe); if (t === 3) return h.unpack(e, 0, GSe); if (t === 4) return se.unpack(e, 0, PJ) } function WSe(e, t) { let n = e.geometryInstances, i = Array.isArray(n) ? n : [n], o = i.length; if (o === 0) return; let r = zSe(i), s = r.length, a = [], c = {}, u = {}, f, p = i[0].attributes, g, m, A; for (g = 0; g < s; ++g)m = r[g], A = p[m], c[m] = g, a.push({ functionName: `czm_batchTable_${m}`, componentDatatype: A.componentDatatype, componentsPerAttribute: A.componentsPerAttribute, normalize: A.normalize }); r.indexOf("distanceDisplayCondition") !== -1 && (a.push({ functionName: "czm_batchTable_boundingSphereCenter3DHigh", componentDatatype: Y.FLOAT, componentsPerAttribute: 3 }, { functionName: "czm_batchTable_boundingSphereCenter3DLow", componentDatatype: Y.FLOAT, componentsPerAttribute: 3 }, { functionName: "czm_batchTable_boundingSphereCenter2DHigh", componentDatatype: Y.FLOAT, componentsPerAttribute: 3 }, { functionName: "czm_batchTable_boundingSphereCenter2DLow", componentDatatype: Y.FLOAT, componentsPerAttribute: 3 }, { functionName: "czm_batchTable_boundingSphereRadius", componentDatatype: Y.FLOAT, componentsPerAttribute: 1 }), u.center3DHigh = a.length - 5, u.center3DLow = a.length - 4, u.center2DHigh = a.length - 3, u.center2DLow = a.length - 2, u.radius = a.length - 1), r.indexOf("offset") !== -1 && (a.push({ functionName: "czm_batchTable_offset2D", componentDatatype: Y.FLOAT, componentsPerAttribute: 3 }), f = a.length - 1), a.push({ functionName: "czm_batchTable_pickColor", componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 4, normalize: !0 }); let C = a.length, x = new fC(t, a, o); for (g = 0; g < o; ++g) { let T = i[g]; p = T.attributes; for (let B = 0; B < s; ++B) { m = r[B], A = p[m]; let R = IJ(A.value), M = c[m]; x.setBatchedAttribute(g, M, R) } let b = { primitive: y(T.pickPrimitive, e) }; l(T.id) && (b.id = T.id); let S = t.createPickId(b); e._pickIds.push(S); let D = S.color, P = PJ; P.x = U.floatToByte(D.red), P.y = U.floatToByte(D.green), P.z = U.floatToByte(D.blue), P.w = U.floatToByte(D.alpha), x.setBatchedAttribute(g, C - 1, P) } e._batchTable = x, e._batchTableAttributeIndices = c, e._batchTableBoundingSphereAttributeIndices = u, e._batchTableOffsetAttribute2DIndex = f } function jSe(e) { let t; return Array.isArray(e.values) ? t = e.values.slice(0) : t = new e.values.constructor(e.values), new be({ componentDatatype: e.componentDatatype, componentsPerAttribute: e.componentsPerAttribute, normalize: e.normalize, values: t }) } function qSe(e) { let t = e.attributes, n = new sn; for (let o in t) t.hasOwnProperty(o) && l(t[o]) && (n[o] = jSe(t[o])); let i; if (l(e.indices)) { let o = e.indices; Array.isArray(o) ? i = o.slice(0) : i = new o.constructor(o) } return new st({ attributes: n, indices: i, primitiveType: e.primitiveType, boundingSphere: re.clone(e.boundingSphere) }) } function YSe(e, t) { return { geometry: t, attributes: e.attributes, modelMatrix: F.clone(e.modelMatrix), pickPrimitive: e.pickPrimitive, id: e.id } } var XSe = /attribute\s+vec(?:3|4)\s+(.*)3DHigh;/g; sr._modifyShaderPosition = function (e, t, n) {
        let i, o = "", r = "", s = ""; for (; (i = XSe.exec(t)) !== null;) {
            let a = i[1], c = `vec4 czm_compute${a[0].toUpperCase()}${a.substr(1)}()`; c !== "vec4 czm_computePosition()" && (o += `${c};
`), l(e.rtcCenter) ? (t = t.replace(/attribute\s+vec(?:3|4)\s+position3DHigh;/g, ""), t = t.replace(/attribute\s+vec(?:3|4)\s+position3DLow;/g, ""), o += `uniform mat4 u_modifiedModelView;
`, r += `attribute vec4 position;
`, s += `${c}
{
    return u_modifiedModelView * position;
}

`, t = t.replace(/czm_modelViewRelativeToEye\s+\*\s+/g, ""), t = t.replace(/czm_modelViewProjectionRelativeToEye/g, "czm_projection")) : n ? s += `${c}
{
    return czm_translateRelativeToEye(${a}3DHigh, ${a}3DLow);
}

`: (r += `attribute vec3 ${a}2DHigh;
attribute vec3 ${a}2DLow;
`, s += `${c}
{
    vec4 p;
    if (czm_morphTime == 1.0)
    {
        p = czm_translateRelativeToEye(${a}3DHigh, ${a}3DLow);
    }
    else if (czm_morphTime == 0.0)
    {
        p = czm_translateRelativeToEye(${a}2DHigh.zxy, ${a}2DLow.zxy);
    }
    else
    {
        p = czm_columbusViewMorph(
                czm_translateRelativeToEye(${a}2DHigh.zxy, ${a}2DLow.zxy),
                czm_translateRelativeToEye(${a}3DHigh, ${a}3DLow),
                czm_morphTime);
    }
    return p;
}

`)
        } return [o, r, t, s].join(`
`)
    }; sr._appendShowToShader = function (e, t) {
        return l(e._batchTableAttributeIndices.show) ? `${Ue.replaceMain(t, "czm_non_show_main")}
void main() 
{ 
    czm_non_show_main(); 
    gl_Position *= czm_batchTable_show(batchId); 
}`: t
    }; sr._updateColorAttribute = function (e, t, n) { if (!l(e._batchTableAttributeIndices.color) && !l(e._batchTableAttributeIndices.depthFailColor) || t.search(/attribute\s+vec4\s+color;/g) === -1) return t; let i = t; return i = i.replace(/attribute\s+vec4\s+color;/g, ""), n ? i = i.replace(/(\b)color(\b)/g, "$1czm_batchTable_depthFailColor(batchId)$2") : i = i.replace(/(\b)color(\b)/g, "$1czm_batchTable_color(batchId)$2"), i }; function xJ(e) {
        return `${Ue.replaceMain(e, "czm_non_pick_main")}
varying vec4 v_pickColor; 
void main() 
{ 
    czm_non_pick_main(); 
    v_pickColor = czm_batchTable_pickColor(batchId); 
}`} function TJ(e) {
        return `varying vec4 v_pickColor;
${e}`
    } sr._updatePickColorAttribute = function (e) { let t = e.replace(/attribute\s+vec4\s+pickColor;/g, ""); return t = t.replace(/(\b)pickColor(\b)/g, "$1czm_batchTable_pickColor(batchId)$2"), t }; sr._appendOffsetToShader = function (e, t) {
        if (!l(e._batchTableAttributeIndices.offset)) return t; let n = `attribute float batchId;
`; n += "attribute float applyOffset;"; let i = t.replace(/attribute\s+float\s+batchId;/g, n), o = `vec4 $1 = czm_computePosition();
`; return o += `    if (czm_sceneMode == czm_sceneMode3D)
`, o += `    {
`, o += "        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);", o += `    }
`, o += `    else
`, o += `    {
`, o += "        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);", o += `    }
`, i = i.replace(/vec4\s+([A-Za-z0-9_]+)\s+=\s+czm_computePosition\(\);/g, o), i
    }; sr._appendDistanceDisplayConditionToShader = function (e, t, n) {
        if (!l(e._batchTableAttributeIndices.distanceDisplayCondition)) return t; let i = Ue.replaceMain(t, "czm_non_distanceDisplayCondition_main"), o = `void main() 
{ 
    czm_non_distanceDisplayCondition_main(); 
    vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId);
    vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId);
    vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId);
    float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId);
`; return n ? o += `    vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);
`: o += `    vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId);
    vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId);
    vec4 centerRTE;
    if (czm_morphTime == 1.0)
    {
        centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);
    }
    else if (czm_morphTime == 0.0)
    {
        centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy);
    }
    else
    {
        centerRTE = czm_columbusViewMorph(
                czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy),
                czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow),
                czm_morphTime);
    }
`, o += `    float radiusSq = boundingSphereRadius * boundingSphereRadius; 
    float distanceSq; 
    if (czm_sceneMode == czm_sceneMode2D) 
    { 
        distanceSq = czm_eyeHeight2D.y - radiusSq; 
    } 
    else 
    { 
        distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; 
    } 
    distanceSq = max(distanceSq, 0.0); 
    float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; 
    float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; 
    float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; 
    gl_Position *= show; 
}`, `${i}
${o}`
    }; function EJ(e, t) {
        if (!e.compressVertices) return t; let n = t.search(/attribute\s+vec3\s+normal;/g) !== -1, i = t.search(/attribute\s+vec2\s+st;/g) !== -1; if (!n && !i) return t; let o = t.search(/attribute\s+vec3\s+tangent;/g) !== -1, r = t.search(/attribute\s+vec3\s+bitangent;/g) !== -1, s = i && n ? 2 : 1; s += o || r ? 1 : 0; let a = s > 1 ? `vec${s}` : "float", c = "compressedAttributes", u = `attribute ${a} ${c};`, f = "", d = ""; i && (f += `vec2 st;
`, d += `    st = czm_decompressTextureCoordinates(${s > 1 ? `${c}.x` : c});
`), n && o && r ? (f += `vec3 normal;
vec3 tangent;
vec3 bitangent;
`, d += `    czm_octDecode(${c}.${i ? "yz" : "xy"}, normal, tangent, bitangent);
`) : (n && (f += `vec3 normal;
`, d += `    normal = czm_octDecode(${c}${s > 1 ? `.${i ? "y" : "x"}` : ""});
`), o && (f += `vec3 tangent;
`, d += `    tangent = czm_octDecode(${c}.${i && n ? "z" : "y"});
`), r && (f += `vec3 bitangent;
`, d += `    bitangent = czm_octDecode(${c}.${i && n ? "z" : "y"});
`)); let p = t; p = p.replace(/attribute\s+vec3\s+normal;/g, ""), p = p.replace(/attribute\s+vec2\s+st;/g, ""), p = p.replace(/attribute\s+vec3\s+tangent;/g, ""), p = p.replace(/attribute\s+vec3\s+bitangent;/g, ""), p = Ue.replaceMain(p, "czm_non_compressed_main"); let g = `void main() 
{ 
${d}    czm_non_compressed_main(); 
}`; return [u, f, p, g].join(`
`)
    } function KSe(e) {
        let t = Ue.replaceMain(e, "czm_non_depth_clamp_main"); return t += `void main() {
    czm_non_depth_clamp_main();
    gl_Position = czm_depthClamp(gl_Position);}
`, t
    } function JSe(e) {
        let t = Ue.replaceMain(e, "czm_non_depth_clamp_main"); return t += `void main() {
    czm_non_depth_clamp_main();
#if defined(GL_EXT_frag_depth)
    #if defined(LOG_DEPTH)
        czm_writeLogDepth();
    #else
        czm_writeDepthClamp();
    #endif
#endif
}
`, t = `#ifdef GL_EXT_frag_depth
#extension GL_EXT_frag_depth : enable
#endif
${t}`, t
    } function bJ(e, t) { let n = e.vertexAttributes } function ZSe(e, t) { return function () { return e[t] } } var uG = Math.max(Nt.hardwareConcurrency - 1, 1), lB, QSe = new yi("combineGeometry"); function $Se(e, t) { let n, i, o, r, s = e._instanceIds; if (e._state === mr.READY) { n = Array.isArray(e.geometryInstances) ? e.geometryInstances : [e.geometryInstances]; let a = e._numberOfInstances = n.length, c = [], u = []; for (o = 0; o < a; ++o)i = n[o].geometry, s.push(n[o].id), u.push({ moduleName: i._workerName, geometry: i }); if (!l(lB)) for (lB = new Array(uG), o = 0; o < uG; o++)lB[o] = new yi("createGeometry"); let f; for (u = ZO(u, uG), o = 0; o < u.length; o++) { let d = 0, p = u[o], g = p.length; for (r = 0; r < g; ++r)f = p[r], i = f.geometry, l(i.constructor.pack) && (f.offset = d, d += y(i.constructor.packedLength, i.packedLength)); let m; if (d > 0) { let A = new Float64Array(d); for (m = [A.buffer], r = 0; r < g; ++r)f = p[r], i = f.geometry, l(i.constructor.pack) && (i.constructor.pack(i, A, f.offset), f.geometry = A) } c.push(lB[o].scheduleTask({ subTasks: u[o] }, m)) } e._state = mr.CREATING, Promise.all(c).then(function (d) { e._createGeometryResults = d, e._state = mr.CREATED }).catch(function (d) { vb(e, t, mr.FAILED, d) }) } else if (e._state === mr.CREATED) { let a = []; n = Array.isArray(e.geometryInstances) ? e.geometryInstances : [e.geometryInstances]; let c = t.scene3DOnly, u = t.mapProjection, f = QSe.scheduleTask(gC.packCombineGeometryParameters({ createGeometryResults: e._createGeometryResults, instances: n, ellipsoid: u.ellipsoid, projection: u, elementIndexUintSupported: t.context.elementIndexUint, scene3DOnly: c, vertexCacheOptimize: e.vertexCacheOptimize, compressVertices: e.compressVertices, modelMatrix: e.modelMatrix, createPickOffsets: e._createPickOffsets }, a), a); e._createGeometryResults = void 0, e._state = mr.COMBINING, Promise.resolve(f).then(function (d) { let p = gC.unpackCombineGeometryResults(d); e._geometries = p.geometries, e._attributeLocations = p.attributeLocations, e.modelMatrix = F.clone(p.modelMatrix, e.modelMatrix), e._pickOffsets = p.pickOffsets, e._offsetInstanceExtend = p.offsetInstanceExtend, e._instanceBoundingSpheres = p.boundingSpheres, e._instanceBoundingSpheresCV = p.boundingSpheresCV, l(e._geometries) && e._geometries.length > 0 ? (e._recomputeBoundingSpheres = !0, e._state = mr.COMBINED) : vb(e, t, mr.FAILED, void 0) }).catch(function (d) { vb(e, t, mr.FAILED, d) }) } } function ewe(e, t) { let n = Array.isArray(e.geometryInstances) ? e.geometryInstances : [e.geometryInstances], i = e._numberOfInstances = n.length, o = new Array(i), r = e._instanceIds, s, a, c = 0; for (a = 0; a < i; a++) { s = n[a]; let p = s.geometry, g; l(p.attributes) && l(p.primitiveType) ? g = qSe(p) : g = p.constructor.createGeometry(p), o[c++] = YSe(s, g), r.push(s.id) } o.length = c; let u = t.scene3DOnly, f = t.mapProjection, d = gC.combineGeometry({ instances: o, ellipsoid: f.ellipsoid, projection: f, elementIndexUintSupported: t.context.elementIndexUint, scene3DOnly: u, vertexCacheOptimize: e.vertexCacheOptimize, compressVertices: e.compressVertices, modelMatrix: e.modelMatrix, createPickOffsets: e._createPickOffsets }); e._geometries = d.geometries, e._attributeLocations = d.attributeLocations, e.modelMatrix = F.clone(d.modelMatrix, e.modelMatrix), e._pickOffsets = d.pickOffsets, e._offsetInstanceExtend = d.offsetInstanceExtend, e._instanceBoundingSpheres = d.boundingSpheres, e._instanceBoundingSpheresCV = d.boundingSpheresCV, l(e._geometries) && e._geometries.length > 0 ? (e._recomputeBoundingSpheres = !0, e._state = mr.COMBINED) : vb(e, t, mr.FAILED, void 0) } function twe(e, t) { let n = e._batchTableAttributeIndices.offset; if (!e._recomputeBoundingSpheres || !l(n)) { e._recomputeBoundingSpheres = !1; return } let i, o = e._offsetInstanceExtend, r = e._instanceBoundingSpheres, s = r.length, a = e._tempBoundingSpheres; if (!l(a)) { for (a = new Array(s), i = 0; i < s; i++)a[i] = new re; e._tempBoundingSpheres = a } for (i = 0; i < s; ++i) { let A = a[i], C = e._batchTable.getBatchedAttribute(i, n, new h); A = r[i].clone(A), MJ(A, C, o[i]) } let c = [], u = [], f = []; for (i = 0; i < s; ++i) { let A = a[i]; A.center.x - A.radius > 0 || re.intersectPlane(A, nn.ORIGIN_ZX_PLANE) !== Kt.INTERSECTING ? c.push(A) : (u.push(A), f.push(A)) } let d = c[0], p = f[0], g = u[0]; for (i = 1; i < c.length; i++)d = re.union(d, c[i]); for (i = 1; i < f.length; i++)p = re.union(p, f[i]); for (i = 1; i < u.length; i++)g = re.union(g, u[i]); let m = []; for (l(d) && m.push(d), l(p) && m.push(p), l(g) && m.push(g), i = 0; i < m.length; i++) { let A = m[i].clone(e._boundingSpheres[i]); e._boundingSpheres[i] = A, e._boundingSphereCV[i] = re.projectTo2D(A, t.mapProjection, e._boundingSphereCV[i]) } sr._updateBoundingVolumes(e, t, e.modelMatrix, !0), e._recomputeBoundingSpheres = !1 } var SJ = new Vn, OJ = new he, BJ = new h, RJ = new re; function nwe(e, t) { if (!l(e._batchTableAttributeIndices.distanceDisplayCondition) || e._batchTableBoundingSpheresUpdated) return; let i = e._batchTableBoundingSphereAttributeIndices, o = i.center3DHigh, r = i.center3DLow, s = i.center2DHigh, a = i.center2DLow, c = i.radius, u = t.mapProjection, f = u.ellipsoid, d = e._batchTable, p = e._instanceBoundingSpheres, g = p.length; for (let m = 0; m < g; ++m) { let A = p[m]; if (!l(A)) continue; let C = e.modelMatrix; l(C) && (A = re.transform(A, C, RJ)); let x = A.center, T = A.radius, b = Vn.fromCartesian(x, SJ); if (d.setBatchedAttribute(m, o, b.high), d.setBatchedAttribute(m, r, b.low), !t.scene3DOnly) { let S = f.cartesianToCartographic(x, OJ), D = u.project(S, BJ); b = Vn.fromCartesian(D, SJ), d.setBatchedAttribute(m, s, b.high), d.setBatchedAttribute(m, a, b.low) } d.setBatchedAttribute(m, c, T) } e._batchTableBoundingSpheresUpdated = !0 } var fG = new h, iwe = new h; function wJ(e, t) { if (!l(e._batchTableAttributeIndices.offset) || e._batchTableOffsetsUpdated || t.scene3DOnly) return; let i = e._batchTableOffsetAttribute2DIndex, o = t.mapProjection, r = o.ellipsoid, s = e._batchTable, a = e._instanceBoundingSpheres, c = a.length; for (let u = 0; u < c; ++u) { let f = a[u]; if (!l(f)) continue; let d = s.getBatchedAttribute(u, e._batchTableAttributeIndices.offset); if (h.equals(d, h.ZERO)) { s.setBatchedAttribute(u, i, h.ZERO); continue } let p = e.modelMatrix; l(p) && (f = re.transform(f, p, RJ)); let g = f.center; g = r.scaleToGeodeticSurface(g, iwe); let m = r.cartesianToCartographic(g, OJ), A = o.project(m, BJ), C = h.add(d, g, fG); m = r.cartesianToCartographic(C, m); let x = o.project(m, fG), T = h.subtract(x, A, fG), b = T.x; T.x = T.z, T.z = T.y, T.y = b, s.setBatchedAttribute(u, i, T) } e._batchTableOffsetsUpdated = !0 } function owe(e, t) { let n = e._attributeLocations, i = e._geometries, o = t.scene3DOnly, r = t.context, s = [], a = i.length; for (let c = 0; c < a; ++c) { let u = i[c]; if (s.push(Qn.fromGeometry({ context: r, geometry: u, attributeLocations: n, bufferUsage: Re.STATIC_DRAW, interleave: e._interleave })), l(e._createBoundingVolumeFunction)) e._createBoundingVolumeFunction(t, u); else if (e._boundingSpheres.push(re.clone(u.boundingSphere)), e._boundingSphereWC.push(new re), !o) { let f = u.boundingSphereCV.center, d = f.x, p = f.y, g = f.z; f.x = g, f.y = d, f.z = p, e._boundingSphereCV.push(re.clone(u.boundingSphereCV)), e._boundingSphere2D.push(new re), e._boundingSphereMorph.push(new re) } } e._va = s, e._primitiveType = i[0].primitiveType, e.releaseGeometryInstances && (e.geometryInstances = void 0), e._geometries = void 0, vb(e, t, mr.COMPLETE, void 0) } function rwe(e, t, n, i) { let o = n.getRenderState(), r; i ? (r = tt(o, !1), r.cull = { enabled: !0, face: gi.BACK }, e._frontFaceRS = Ve.fromCache(r), r.cull.face = gi.FRONT, e._backFaceRS = Ve.fromCache(r)) : (e._frontFaceRS = Ve.fromCache(o), e._backFaceRS = e._frontFaceRS), r = tt(o, !1), l(e._depthFailAppearance) && (r.depthTest.enabled = !1), l(e._depthFailAppearance) && (o = e._depthFailAppearance.getRenderState(), r = tt(o, !1), r.depthTest.func = Ja.GREATER, i ? (r.cull = { enabled: !0, face: gi.BACK }, e._frontFaceDepthFailRS = Ve.fromCache(r), r.cull.face = gi.FRONT, e._backFaceDepthFailRS = Ve.fromCache(r)) : (e._frontFaceDepthFailRS = Ve.fromCache(r), e._backFaceDepthFailRS = e._frontFaceRS)) } function swe(e, t, n) { let i = t.context, o = e._attributeLocations, r = e._batchTable.getVertexShaderCallback()(n.vertexShaderSource); r = sr._appendOffsetToShader(e, r), r = sr._appendShowToShader(e, r), r = sr._appendDistanceDisplayConditionToShader(e, r, t.scene3DOnly), r = xJ(r), r = sr._updateColorAttribute(e, r, !1), r = EJ(e, r), r = sr._modifyShaderPosition(e, r, t.scene3DOnly); let s = n.getFragmentShaderSource(); s = TJ(s), e._sp = qt.replaceCache({ context: i, shaderProgram: e._sp, vertexShaderSource: r, fragmentShaderSource: s, attributeLocations: o }), bJ(e._sp, o), l(e._depthFailAppearance) && (r = e._batchTable.getVertexShaderCallback()(e._depthFailAppearance.vertexShaderSource), r = sr._appendShowToShader(e, r), r = sr._appendDistanceDisplayConditionToShader(e, r, t.scene3DOnly), r = xJ(r), r = sr._updateColorAttribute(e, r, !0), r = EJ(e, r), r = sr._modifyShaderPosition(e, r, t.scene3DOnly), r = KSe(r), s = e._depthFailAppearance.getFragmentShaderSource(), s = TJ(s), s = JSe(s), e._spDepthFail = qt.replaceCache({ context: i, shaderProgram: e._spDepthFail, vertexShaderSource: r, fragmentShaderSource: s, attributeLocations: o }), bJ(e._spDepthFail, o)) } var Db = new F, DJ = new h; function vJ(e, t, n, i) { let o = l(n) ? n._uniforms : void 0, r = {}, s = t.uniforms; if (l(s)) for (let c in s) s.hasOwnProperty(c) && (r[c] = ZSe(s, c)); let a = yt(r, o); return a = e._batchTable.getUniformMapCallback()(a), l(e.rtcCenter) && (a.u_modifiedModelView = function () { let c = i.context.uniformState.view; return F.multiply(c, e._modelMatrix, Db), F.multiplyByPoint(Db, e.rtcCenter, DJ), F.setTranslation(Db, DJ, Db), Db }), a } function awe(e, t, n, i, o, r, s, a) { let c = vJ(e, t, n, a), u; l(e._depthFailAppearance) && (u = vJ(e, e._depthFailAppearance, e._depthFailAppearance.material, a)); let f = i ? xe.TRANSLUCENT : xe.OPAQUE, d = o ? 2 : 1; d *= l(e._depthFailAppearance) ? 2 : 1, r.length = e._va.length * d; let p = r.length, g = 0; for (let m = 0; m < p; ++m) { let A; o && (A = r[m], l(A) || (A = r[m] = new $e({ owner: e, primitiveType: e._primitiveType })), A.vertexArray = e._va[g], A.renderState = e._backFaceRS, A.shaderProgram = e._sp, A.uniformMap = c, A.pass = f, ++m), A = r[m], l(A) || (A = r[m] = new $e({ owner: e, primitiveType: e._primitiveType })), A.vertexArray = e._va[g], A.renderState = e._frontFaceRS, A.shaderProgram = e._sp, A.uniformMap = c, A.pass = f, l(e._depthFailAppearance) && (o && (++m, A = r[m], l(A) || (A = r[m] = new $e({ owner: e, primitiveType: e._primitiveType })), A.vertexArray = e._va[g], A.renderState = e._backFaceDepthFailRS, A.shaderProgram = e._spDepthFail, A.uniformMap = u, A.pass = f), ++m, A = r[m], l(A) || (A = r[m] = new $e({ owner: e, primitiveType: e._primitiveType })), A.vertexArray = e._va[g], A.renderState = e._frontFaceDepthFailRS, A.shaderProgram = e._spDepthFail, A.uniformMap = u, A.pass = f), ++g } } sr._updateBoundingVolumes = function (e, t, n, i) { let o, r, s; if (i || !F.equals(n, e._modelMatrix)) for (F.clone(n, e._modelMatrix), r = e._boundingSpheres.length, o = 0; o < r; ++o)s = e._boundingSpheres[o], l(s) && (e._boundingSphereWC[o] = re.transform(s, n, e._boundingSphereWC[o]), t.scene3DOnly || (e._boundingSphere2D[o] = re.clone(e._boundingSphereCV[o], e._boundingSphere2D[o]), e._boundingSphere2D[o].center.x = 0, e._boundingSphereMorph[o] = re.union(e._boundingSphereWC[o], e._boundingSphereCV[o]))); let a = e.appearance.pixelSize; if (l(a)) for (r = e._boundingSpheres.length, o = 0; o < r; ++o) { s = e._boundingSpheres[o]; let c = e._boundingSphereWC[o], f = t.camera.getPixelSize(s, t.context.drawingBufferWidth, t.context.drawingBufferHeight) * a; c.radius = s.radius + f } }; function cwe(e, t, n, i, o, r, s, a) { sr._updateBoundingVolumes(e, t, o); let c; t.mode === ee.SCENE3D ? c = e._boundingSphereWC : t.mode === ee.COLUMBUS_VIEW ? c = e._boundingSphereCV : t.mode === ee.SCENE2D && l(e._boundingSphere2D) ? c = e._boundingSphere2D : l(e._boundingSphereMorph) && (c = e._boundingSphereMorph); let u = t.commandList, f = t.passes; if (f.render || f.pick) { let d = e.allowPicking, p = hn.castShadows(e.shadows), g = hn.receiveShadows(e.shadows), m = n.length, A = a ? 2 : 1; A *= l(e._depthFailAppearance) ? 2 : 1; for (let C = 0; C < m; ++C) { let x = Math.floor(C / A), T = n[C]; T.modelMatrix = o, T.boundingVolume = c[x], T.cull = r, T.debugShowBoundingVolume = s, T.castShadows = p, T.receiveShadows = g, d ? T.pickId = "v_pickColor" : T.pickId = void 0, u.push(T) } } } sr.prototype.update = function (e) { if (!l(this.geometryInstances) && this._va.length === 0 || l(this.geometryInstances) && Array.isArray(this.geometryInstances) && this.geometryInstances.length === 0 || !l(this.appearance) || e.mode !== ee.SCENE3D && e.scene3DOnly || !e.passes.render && !e.passes.pick) return; if (l(this._error)) throw this._error; if (this._state === mr.FAILED) return; let t = e.context; if (l(this._batchTable) || WSe(this, t), this._batchTable.attributes.length > 0) { if (Ut.maximumVertexTextureImageUnits === 0) throw new fe("Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero."); this._batchTable.update(e) } if (this._state !== mr.COMPLETE && this._state !== mr.COMBINED && (this.asynchronous ? $Se(this, e) : ewe(this, e)), this._state === mr.COMBINED && (nwe(this, e), wJ(this, e), owe(this, e)), !this.show || this._state !== mr.COMPLETE) return; this._batchTableOffsetsUpdated || wJ(this, e), this._recomputeBoundingSpheres && twe(this, e); let n = this.appearance, i = n.material, o = !1, r = !1; this._appearance !== n ? (this._appearance = n, this._material = i, o = !0, r = !0) : this._material !== i && (this._material = i, r = !0); let s = this.depthFailAppearance, a = l(s) ? s.material : void 0; this._depthFailAppearance !== s ? (this._depthFailAppearance = s, this._depthFailMaterial = a, o = !0, r = !0) : this._depthFailMaterial !== a && (this._depthFailMaterial = a, r = !0); let c = this._appearance.isTranslucent(); this._translucent !== c && (this._translucent = c, o = !0), l(this._material) && this._material.update(t); let u = n.closed && c; o && y(this._createRenderStatesFunction, rwe)(this, t, n, u), r && y(this._createShaderProgramFunction, swe)(this, e, n), (o || r) && y(this._createCommandsFunction, awe)(this, n, i, c, u, this._colorCommands, this._pickCommands, e), y(this._updateAndQueueCommandsFunction, cwe)(this, e, this._colorCommands, this._pickCommands, this.modelMatrix, this.cull, this.debugShowBoundingVolume, u) }; var lwe = new re, uwe = new re; function MJ(e, t, n) { if (n === Qt.TOP) { let i = re.clone(e, lwe), o = re.clone(e, uwe); o.center = h.add(o.center, t, o.center), e = re.union(i, o, e) } else n === Qt.ALL && (e.center = h.add(e.center, t, e.center)); return e } function fwe(e, t, n) { return function () { let i = e.getBatchedAttribute(t, n), o = e.attributes[n], r = o.componentsPerAttribute, s = Y.createTypedArray(o.componentDatatype, r); return l(i.constructor.pack) ? i.constructor.pack(i, s, 0) : s[0] = i, s } } function dwe(e, t, n, i, o) { return function (r) { let s = IJ(r); e.setBatchedAttribute(t, n, s), o === "offset" && (i._recomputeBoundingSpheres = !0, i._batchTableOffsetsUpdated = !1) } } var hwe = new h; function mwe(e, t, n) { t.boundingSphere = { get: function () { let i = e._instanceBoundingSpheres[n]; if (l(i)) { i = i.clone(); let o = e.modelMatrix, r = t.offset; l(r) && MJ(i, h.fromArray(r.get(), 0, hwe), e._offsetInstanceExtend[n]), l(o) && (i = re.transform(i, o)) } return i } }, t.boundingSphereCV = { get: function () { return e._instanceBoundingSpheresCV[n] } } } function pwe(e, t, n) { t.pickId = { get: function () { return e._pickIds[n] } } } sr.prototype.getGeometryInstanceAttributes = function (e) { let t = -1, n = this._lastPerInstanceAttributeIndex, i = this._instanceIds, o = i.length; for (let u = 0; u < o; ++u) { let f = (n + u) % o; if (e === i[f]) { t = f; break } } if (t === -1) return; let r = this._perInstanceAttributeCache[t]; if (l(r)) return r; let s = this._batchTable, a = this._batchTableAttributeIndices; r = {}; let c = {}; for (let u in a) if (a.hasOwnProperty(u)) { let f = a[u]; c[u] = { get: fwe(s, t, f), set: dwe(s, t, f, this, u) } } return mwe(this, c, t), pwe(this, c, t), Object.defineProperties(r, c), this._lastPerInstanceAttributeIndex = t, this._perInstanceAttributeCache[t] = r, r }; sr.prototype.isDestroyed = function () { return !1 }; sr.prototype.destroy = function () { let e, t; this._sp = this._sp && this._sp.destroy(), this._spDepthFail = this._spDepthFail && this._spDepthFail.destroy(); let n = this._va; for (e = n.length, t = 0; t < e; ++t)n[t].destroy(); this._va = void 0; let i = this._pickIds; for (e = i.length, t = 0; t < e; ++t)i[t].destroy(); return this._pickIds = void 0, this._batchTable = this._batchTable && this._batchTable.destroy(), this._instanceIds = void 0, this._perInstanceAttributeCache = void 0, this._attributeLocations = void 0, le(this) }; function vb(e, t, n, i) { e._completeLoad(t, n, i) } var xn = sr; function _we(e) { e = y(e, y.EMPTY_OBJECT), this.componentDatatype = e.componentDatatype, this.componentsPerAttribute = e.componentsPerAttribute, this.normalize = y(e.normalize, !1), this.value = e.value } var Qa = _we; var Pb = `#ifdef GL_EXT_frag_depth
#extension GL_EXT_frag_depth : enable
#endif
#ifdef TEXTURE_COORDINATES
#ifdef SPHERICAL
varying vec4 v_sphericalExtents;
#else // SPHERICAL
varying vec2 v_inversePlaneExtents;
varying vec4 v_westPlane;
varying vec4 v_southPlane;
#endif // SPHERICAL
varying vec3 v_uvMinAndSphericalLongitudeRotation;
varying vec3 v_uMaxAndInverseDistance;
varying vec3 v_vMaxAndInverseDistance;
#endif // TEXTURE_COORDINATES
#ifdef PER_INSTANCE_COLOR
varying vec4 v_color;
#endif
#ifdef NORMAL_EC
vec3 getEyeCoordinate3FromWindowCoordinate(vec2 fragCoord, float logDepthOrDepth) {
vec4 eyeCoordinate = czm_windowToEyeCoordinates(fragCoord, logDepthOrDepth);
return eyeCoordinate.xyz / eyeCoordinate.w;
}
vec3 vectorFromOffset(vec4 eyeCoordinate, vec2 positiveOffset) {
vec2 glFragCoordXY = gl_FragCoord.xy;
float upOrRightLogDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, (glFragCoordXY + positiveOffset) / czm_viewport.zw));
float downOrLeftLogDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, (glFragCoordXY - positiveOffset) / czm_viewport.zw));
bvec2 upOrRightInBounds = lessThan(glFragCoordXY + positiveOffset, czm_viewport.zw);
float useUpOrRight = float(upOrRightLogDepth > 0.0 && upOrRightInBounds.x && upOrRightInBounds.y);
float useDownOrLeft = float(useUpOrRight == 0.0);
vec3 upOrRightEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY + positiveOffset, upOrRightLogDepth);
vec3 downOrLeftEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY - positiveOffset, downOrLeftLogDepth);
return (upOrRightEC - (eyeCoordinate.xyz / eyeCoordinate.w)) * useUpOrRight + ((eyeCoordinate.xyz / eyeCoordinate.w) - downOrLeftEC) * useDownOrLeft;
}
#endif // NORMAL_EC
void main(void)
{
#ifdef REQUIRES_EC
float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw));
vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);
#endif
#ifdef REQUIRES_WC
vec4 worldCoordinate4 = czm_inverseView * eyeCoordinate;
vec3 worldCoordinate = worldCoordinate4.xyz / worldCoordinate4.w;
#endif
#ifdef TEXTURE_COORDINATES
vec2 uv;
#ifdef SPHERICAL
vec2 sphericalLatLong = czm_approximateSphericalCoordinates(worldCoordinate);
sphericalLatLong.y += v_uvMinAndSphericalLongitudeRotation.z;
sphericalLatLong.y = czm_branchFreeTernary(sphericalLatLong.y < czm_pi, sphericalLatLong.y, sphericalLatLong.y - czm_twoPi);
uv.x = (sphericalLatLong.y - v_sphericalExtents.y) * v_sphericalExtents.w;
uv.y = (sphericalLatLong.x - v_sphericalExtents.x) * v_sphericalExtents.z;
#else // SPHERICAL
uv.x = czm_planeDistance(v_westPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.x;
uv.y = czm_planeDistance(v_southPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.y;
#endif // SPHERICAL
#endif // TEXTURE_COORDINATES
#ifdef PICK
#ifdef CULL_FRAGMENTS
if (0.0 <= uv.x && uv.x <= 1.0 && 0.0 <= uv.y && uv.y <= 1.0 || logDepthOrDepth != 0.0) {
gl_FragColor.a = 1.0;
czm_writeDepthClamp();
}
#else // CULL_FRAGMENTS
gl_FragColor.a = 1.0;
#endif // CULL_FRAGMENTS
#else // PICK
#ifdef CULL_FRAGMENTS
if (uv.x <= 0.0 || 1.0 <= uv.x || uv.y <= 0.0 || 1.0 <= uv.y || logDepthOrDepth == 0.0) {
discard;
}
#endif
#ifdef NORMAL_EC
vec3 downUp = vectorFromOffset(eyeCoordinate, vec2(0.0, 1.0));
vec3 leftRight = vectorFromOffset(eyeCoordinate, vec2(1.0, 0.0));
vec3 normalEC = normalize(cross(leftRight, downUp));
#endif
#ifdef PER_INSTANCE_COLOR
vec4 color = czm_gammaCorrect(v_color);
#ifdef FLAT
gl_FragColor = color;
#else // FLAT
czm_materialInput materialInput;
materialInput.normalEC = normalEC;
materialInput.positionToEyeEC = -eyeCoordinate.xyz;
czm_material material = czm_getDefaultMaterial(materialInput);
material.diffuse = color.rgb;
material.alpha = color.a;
gl_FragColor = czm_phong(normalize(-eyeCoordinate.xyz), material, czm_lightDirectionEC);
#endif // FLAT
gl_FragColor.rgb *= gl_FragColor.a;
#else // PER_INSTANCE_COLOR
czm_materialInput materialInput;
#ifdef USES_NORMAL_EC
materialInput.normalEC = normalEC;
#endif
#ifdef USES_POSITION_TO_EYE_EC
materialInput.positionToEyeEC = -eyeCoordinate.xyz;
#endif
#ifdef USES_TANGENT_TO_EYE
materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(worldCoordinate, normalEC);
#endif
#ifdef USES_ST
materialInput.st.x = czm_lineDistance(v_uvMinAndSphericalLongitudeRotation.xy, v_uMaxAndInverseDistance.xy, uv) * v_uMaxAndInverseDistance.z;
materialInput.st.y = czm_lineDistance(v_uvMinAndSphericalLongitudeRotation.xy, v_vMaxAndInverseDistance.xy, uv) * v_vMaxAndInverseDistance.z;
#endif
czm_material material = czm_getMaterial(materialInput);
#ifdef FLAT
gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);
#else // FLAT
gl_FragColor = czm_phong(normalize(-eyeCoordinate.xyz), material, czm_lightDirectionEC);
#endif // FLAT
gl_FragColor.rgb *= gl_FragColor.a;
#endif // PER_INSTANCE_COLOR
czm_writeDepthClamp();
#endif // PICK
}
`; function iu(e, t, n) {
        this._projectionExtentDefines = { eastMostYhighDefine: "", eastMostYlowDefine: "", westMostYhighDefine: "", westMostYlowDefine: "" }; let i = new dG; i.requiresTextureCoordinates = e, i.requiresEC = !n.flat; let o = new dG; if (o.requiresTextureCoordinates = e, n instanceof $t) i.requiresNormalEC = !n.flat; else {
            let r = `${n.material.shaderSource}
${n.fragmentShaderSource}`; i.normalEC = r.indexOf("materialInput.normalEC") !== -1 || r.indexOf("czm_getDefaultMaterial") !== -1, i.positionToEyeEC = r.indexOf("materialInput.positionToEyeEC") !== -1, i.tangentToEyeMatrix = r.indexOf("materialInput.tangentToEyeMatrix") !== -1, i.st = r.indexOf("materialInput.st") !== -1
        } this._colorShaderDependencies = i, this._pickShaderDependencies = o, this._appearance = n, this._extentsCulling = e, this._planarExtents = t
    } iu.prototype.createFragmentShader = function (e) { let t = this._appearance, n = this._colorShaderDependencies, i = []; !e && !this._planarExtents && i.push("SPHERICAL"), n.requiresEC && i.push("REQUIRES_EC"), n.requiresWC && i.push("REQUIRES_WC"), n.requiresTextureCoordinates && i.push("TEXTURE_COORDINATES"), this._extentsCulling && i.push("CULL_FRAGMENTS"), n.requiresNormalEC && i.push("NORMAL_EC"), t instanceof $t && i.push("PER_INSTANCE_COLOR"), n.normalEC && i.push("USES_NORMAL_EC"), n.positionToEyeEC && i.push("USES_POSITION_TO_EYE_EC"), n.tangentToEyeMatrix && i.push("USES_TANGENT_TO_EYE"), n.st && i.push("USES_ST"), t.flat && i.push("FLAT"); let o = ""; return t instanceof $t || (o = t.material.shaderSource), new Ue({ defines: i, sources: [o, Pb] }) }; iu.prototype.createPickFragmentShader = function (e) { let t = this._pickShaderDependencies, n = ["PICK"]; return !e && !this._planarExtents && n.push("SPHERICAL"), t.requiresEC && n.push("REQUIRES_EC"), t.requiresWC && n.push("REQUIRES_WC"), t.requiresTextureCoordinates && n.push("TEXTURE_COORDINATES"), this._extentsCulling && n.push("CULL_FRAGMENTS"), new Ue({ defines: n, sources: [Pb], pickColorQualifier: "varying" }) }; iu.prototype.createVertexShader = function (e, t, n, i) { return HJ(this._colorShaderDependencies, this._planarExtents, n, e, t, this._appearance, i, this._projectionExtentDefines) }; iu.prototype.createPickVertexShader = function (e, t, n, i) { return HJ(this._pickShaderDependencies, this._planarExtents, n, e, t, void 0, i, this._projectionExtentDefines) }; var LJ = new h, FJ = new he, NJ = { high: 0, low: 0 }; function HJ(e, t, n, i, o, r, s, a) { let c = i.slice(); if (a.eastMostYhighDefine === "") { let u = FJ; u.longitude = I.PI, u.latitude = 0, u.height = 0; let f = s.project(u, LJ), d = Vn.encode(f.x, NJ); a.eastMostYhighDefine = `EAST_MOST_X_HIGH ${d.high.toFixed(`${d.high}`.length + 1)}`, a.eastMostYlowDefine = `EAST_MOST_X_LOW ${d.low.toFixed(`${d.low}`.length + 1)}`; let p = FJ; p.longitude = -I.PI, p.latitude = 0, p.height = 0; let g = s.project(p, LJ); d = Vn.encode(g.x, NJ), a.westMostYhighDefine = `WEST_MOST_X_HIGH ${d.high.toFixed(`${d.high}`.length + 1)}`, a.westMostYlowDefine = `WEST_MOST_X_LOW ${d.low.toFixed(`${d.low}`.length + 1)}` } return n && (c.push(a.eastMostYhighDefine), c.push(a.eastMostYlowDefine), c.push(a.westMostYhighDefine), c.push(a.westMostYlowDefine)), l(r) && r instanceof $t && c.push("PER_INSTANCE_COLOR"), e.requiresTextureCoordinates && (c.push("TEXTURE_COORDINATES"), t || n || c.push("SPHERICAL"), n && c.push("COLUMBUS_VIEW_2D")), new Ue({ defines: c, sources: [o] }) } function dG() { this._requiresEC = !1, this._requiresWC = !1, this._requiresNormalEC = !1, this._requiresTextureCoordinates = !1, this._usesNormalEC = !1, this._usesPositionToEyeEC = !1, this._usesTangentToEyeMat = !1, this._usesSt = !1 } Object.defineProperties(dG.prototype, { requiresEC: { get: function () { return this._requiresEC }, set: function (e) { this._requiresEC = e || this._requiresEC } }, requiresWC: { get: function () { return this._requiresWC }, set: function (e) { this._requiresWC = e || this._requiresWC, this.requiresEC = this._requiresWC } }, requiresNormalEC: { get: function () { return this._requiresNormalEC }, set: function (e) { this._requiresNormalEC = e || this._requiresNormalEC, this.requiresEC = this._requiresNormalEC } }, requiresTextureCoordinates: { get: function () { return this._requiresTextureCoordinates }, set: function (e) { this._requiresTextureCoordinates = e || this._requiresTextureCoordinates, this.requiresWC = this._requiresTextureCoordinates } }, normalEC: { set: function (e) { this.requiresNormalEC = e, this._usesNormalEC = e }, get: function () { return this._usesNormalEC } }, tangentToEyeMatrix: { set: function (e) { this.requiresWC = e, this.requiresNormalEC = e, this._usesTangentToEyeMat = e }, get: function () { return this._usesTangentToEyeMat } }, positionToEyeEC: { set: function (e) { this.requiresEC = e, this._usesPositionToEyeEC = e }, get: function () { return this._usesPositionToEyeEC } }, st: { set: function (e) { this.requiresTextureCoordinates = e, this._usesSt = e }, get: function () { return this._usesSt } } }); function VJ(e, t, n) { return Math.abs((t.y - e.y) * n.x - (t.x - e.x) * n.y + t.x * e.y - t.y * e.x) / H.distance(t, e) } var gwe = [new H, new H, new H, new H]; function GJ(e, t) { let n = gwe, i = H.unpack(t, 0, n[0]), o = H.unpack(t, 2, n[1]), r = H.unpack(t, 4, n[2]); e.uMaxVmax = new Qa({ componentDatatype: Y.FLOAT, componentsPerAttribute: 4, normalize: !1, value: [o.x, o.y, r.x, r.y] }); let s = 1 / VJ(i, o, r), a = 1 / VJ(i, r, o); e.uvMinAndExtents = new Qa({ componentDatatype: Y.FLOAT, componentsPerAttribute: 4, normalize: !1, value: [i.x, i.y, s, a] }) } var WJ = new he, jJ = new h, ywe = new h, Awe = new h, uB = { high: 0, low: 0 }; function qJ(e, t, n) { let i = WJ; i.height = 0, i.longitude = e.west, i.latitude = e.south; let o = t.project(i, jJ); i.latitude = e.north; let r = t.project(i, ywe); i.longitude = e.east, i.latitude = e.south; let s = t.project(i, Awe), a = [0, 0, 0, 0], c = [0, 0, 0, 0], u = Vn.encode(o.x, uB); a[0] = u.high, c[0] = u.low, u = Vn.encode(o.y, uB), a[1] = u.high, c[1] = u.low, u = Vn.encode(r.y, uB), a[2] = u.high, c[2] = u.low, u = Vn.encode(s.x, uB), a[3] = u.high, c[3] = u.low, n.planes2D_HIGH = new Qa({ componentDatatype: Y.FLOAT, componentsPerAttribute: 4, normalize: !1, value: a }), n.planes2D_LOW = new Qa({ componentDatatype: Y.FLOAT, componentsPerAttribute: 4, normalize: !1, value: c }) } var Cwe = new F, xwe = new F, kJ = new h, Twe = new he, Ewe = [new he, new he, new he, new he, new he, new he, new he, new he]; function bwe(e, t, n, i, o, r) { let s = ce.center(e, Twe); s.height = n; let a = he.toCartesian(s, t, kJ), c = It.eastNorthUpToFixedFrame(a, t, Cwe), u = F.inverse(c, xwe), f = e.west, d = e.east, p = e.north, g = e.south, m = Ewe; m[0].latitude = g, m[0].longitude = f, m[1].latitude = p, m[1].longitude = f, m[2].latitude = p, m[2].longitude = d, m[3].latitude = g, m[3].longitude = d; let A = (f + d) * .5, C = (p + g) * .5; m[4].latitude = g, m[4].longitude = A, m[5].latitude = p, m[5].longitude = A, m[6].latitude = C, m[6].longitude = f, m[7].latitude = C, m[7].longitude = d; let x = Number.POSITIVE_INFINITY, T = Number.NEGATIVE_INFINITY, b = Number.POSITIVE_INFINITY, S = Number.NEGATIVE_INFINITY; for (let R = 0; R < 8; R++) { m[R].height = n; let M = he.toCartesian(m[R], t, kJ); F.multiplyByPoint(u, M, M), M.z = 0, x = Math.min(x, M.x), T = Math.max(T, M.x), b = Math.min(b, M.y), S = Math.max(S, M.y) } let D = i; D.x = x, D.y = b, D.z = 0, F.multiplyByPoint(c, D, D); let P = o; P.x = T, P.y = b, P.z = 0, F.multiplyByPoint(c, P, P), h.subtract(P, D, o); let B = r; B.x = x, B.y = S, B.z = 0, F.multiplyByPoint(c, B, B), h.subtract(B, D, r) } var Swe = new h, wwe = new h, Dwe = new Vn; iu.getPlanarTextureCoordinateAttributes = function (e, t, n, i, o) { let r = jJ, s = Swe, a = wwe; bwe(e, n, y(o, 0), r, s, a); let c = {}; GJ(c, t); let u = Vn.fromCartesian(r, Dwe); return c.southWest_HIGH = new Qa({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, normalize: !1, value: h.pack(u.high, [0, 0, 0]) }), c.southWest_LOW = new Qa({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, normalize: !1, value: h.pack(u.low, [0, 0, 0]) }), c.eastward = new Qa({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, normalize: !1, value: h.pack(s, [0, 0, 0]) }), c.northward = new Qa({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, normalize: !1, value: h.pack(a, [0, 0, 0]) }), qJ(e, i, c), c }; var vwe = new h; function UJ(e, t, n, i) { let o = WJ; o.latitude = e, o.longitude = t, o.height = 0; let r = he.toCartesian(o, n, vwe), s = Math.sqrt(r.x * r.x + r.y * r.y), a = I.fastApproximateAtan2(s, r.z), c = I.fastApproximateAtan2(r.x, r.y); return i.x = a, i.y = c, i } var zJ = new H; iu.getSphericalExtentGeometryInstanceAttributes = function (e, t, n, i) { let o = UJ(e.south, e.west, n, zJ), r = o.x, s = o.y, a = UJ(e.north, e.east, n, zJ), c = a.x, u = a.y, f = 0; s > u && (f = I.PI - s, s = -I.PI, u += f), r -= I.EPSILON5, s -= I.EPSILON5, c += I.EPSILON5, u += I.EPSILON5; let d = 1 / (u - s), p = 1 / (c - r), g = { sphericalExtents: new Qa({ componentDatatype: Y.FLOAT, componentsPerAttribute: 4, normalize: !1, value: [r, s, p, d] }), longitudeRotation: new Qa({ componentDatatype: Y.FLOAT, componentsPerAttribute: 1, normalize: !1, value: [f] }) }; return GJ(g, t), qJ(e, i, g), g }; iu.hasAttributesForTextureCoordinatePlanes = function (e) { return l(e.southWest_HIGH) && l(e.southWest_LOW) && l(e.northward) && l(e.eastward) && l(e.planes2D_HIGH) && l(e.planes2D_LOW) && l(e.uMaxVmax) && l(e.uvMinAndExtents) }; iu.hasAttributesForSphericalExtents = function (e) { return l(e.sphericalExtents) && l(e.longitudeRotation) && l(e.planes2D_HIGH) && l(e.planes2D_LOW) && l(e.uMaxVmax) && l(e.uvMinAndExtents) }; function Pwe(e) { return Math.max(e.width, e.height) > iu.MAX_WIDTH_FOR_PLANAR_EXTENTS } iu.shouldUseSphericalCoordinates = function (e) { return Pwe(e) }; iu.MAX_WIDTH_FOR_PLANAR_EXTENTS = I.toRadians(1); var ou = iu; var Iwe = { NEVER: te.NEVER, LESS: te.LESS, EQUAL: te.EQUAL, LESS_OR_EQUAL: te.LEQUAL, GREATER: te.GREATER, NOT_EQUAL: te.NOTEQUAL, GREATER_OR_EQUAL: te.GEQUAL, ALWAYS: te.ALWAYS }, Fn = Object.freeze(Iwe); var Owe = { ZERO: te.ZERO, KEEP: te.KEEP, REPLACE: te.REPLACE, INCREMENT: te.INCR, DECREMENT: te.DECR, INVERT: te.INVERT, INCREMENT_WRAP: te.INCR_WRAP, DECREMENT_WRAP: te.DECR_WRAP }, lt = Object.freeze(Owe); var fB = { CESIUM_3D_TILE_MASK: 128, SKIP_LOD_MASK: 112, SKIP_LOD_BIT_SHIFT: 4, CLASSIFICATION_MASK: 15 }; fB.setCesium3DTileBit = function () { return { enabled: !0, frontFunction: Fn.ALWAYS, frontOperation: { fail: lt.KEEP, zFail: lt.KEEP, zPass: lt.REPLACE }, backFunction: Fn.ALWAYS, backOperation: { fail: lt.KEEP, zFail: lt.KEEP, zPass: lt.REPLACE }, reference: fB.CESIUM_3D_TILE_MASK, mask: fB.CESIUM_3D_TILE_MASK } }; var vt = Object.freeze(fB); function x0(e) { e = y(e, y.EMPTY_OBJECT); let t = e.geometryInstances; this.geometryInstances = t, this.show = y(e.show, !0), this.classificationType = y(e.classificationType, Ln.BOTH), this.debugShowBoundingVolume = y(e.debugShowBoundingVolume, !1), this.debugShowShadowVolume = y(e.debugShowShadowVolume, !1), this._debugShowShadowVolume = !1, this._extruded = y(e._extruded, !1), this._uniformMap = e._uniformMap, this._sp = void 0, this._spStencil = void 0, this._spPick = void 0, this._spColor = void 0, this._spPick2D = void 0, this._spColor2D = void 0, this._rsStencilDepthPass = void 0, this._rsStencilDepthPass3DTiles = void 0, this._rsColorPass = void 0, this._rsPickPass = void 0, this._commandsIgnoreShow = [], this._ready = !1; let n = this; this._readyPromise = new Promise((i, o) => { n._completeLoad = () => { if (this._ready) return; this._ready = !0, this.releaseGeometryInstances && (this.geometryInstances = void 0); let r = this._error; l(r) ? o(r) : i(this) } }), this._primitive = void 0, this._pickPrimitive = e._pickPrimitive, this._hasSphericalExtentsAttribute = !1, this._hasPlanarExtentsAttributes = !1, this._hasPerColorAttribute = !1, this.appearance = e.appearance, this._createBoundingVolumeFunction = e._createBoundingVolumeFunction, this._updateAndQueueCommandsFunction = e._updateAndQueueCommandsFunction, this._usePickOffsets = !1, this._primitiveOptions = { geometryInstances: void 0, appearance: void 0, vertexCacheOptimize: y(e.vertexCacheOptimize, !1), interleave: y(e.interleave, !1), releaseGeometryInstances: y(e.releaseGeometryInstances, !0), allowPicking: y(e.allowPicking, !0), asynchronous: y(e.asynchronous, !0), compressVertices: y(e.compressVertices, !0), _createBoundingVolumeFunction: void 0, _createRenderStatesFunction: void 0, _createShaderProgramFunction: void 0, _createCommandsFunction: void 0, _updateAndQueueCommandsFunction: void 0, _createPickOffsets: !0 } } Object.defineProperties(x0.prototype, { vertexCacheOptimize: { get: function () { return this._primitiveOptions.vertexCacheOptimize } }, interleave: { get: function () { return this._primitiveOptions.interleave } }, releaseGeometryInstances: { get: function () { return this._primitiveOptions.releaseGeometryInstances } }, allowPicking: { get: function () { return this._primitiveOptions.allowPicking } }, asynchronous: { get: function () { return this._primitiveOptions.asynchronous } }, compressVertices: { get: function () { return this._primitiveOptions.compressVertices } }, ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } }, _needs2DShader: { get: function () { return this._hasPlanarExtentsAttributes || this._hasSphericalExtentsAttribute } } }); x0.isSupported = function (e) { return e.context.stencilBuffer }; function yC(e, t) { let n = t ? Fn.EQUAL : Fn.ALWAYS; return { colorMask: { red: !1, green: !1, blue: !1, alpha: !1 }, stencilTest: { enabled: e, frontFunction: n, frontOperation: { fail: lt.KEEP, zFail: lt.DECREMENT_WRAP, zPass: lt.KEEP }, backFunction: n, backOperation: { fail: lt.KEEP, zFail: lt.INCREMENT_WRAP, zPass: lt.KEEP }, reference: vt.CESIUM_3D_TILE_MASK, mask: vt.CESIUM_3D_TILE_MASK }, stencilMask: vt.CLASSIFICATION_MASK, depthTest: { enabled: !0, func: Ja.LESS_OR_EQUAL }, depthMask: !1 } } function mG(e) { return { stencilTest: { enabled: e, frontFunction: Fn.NOT_EQUAL, frontOperation: { fail: lt.ZERO, zFail: lt.ZERO, zPass: lt.ZERO }, backFunction: Fn.NOT_EQUAL, backOperation: { fail: lt.ZERO, zFail: lt.ZERO, zPass: lt.ZERO }, reference: 0, mask: vt.CLASSIFICATION_MASK }, stencilMask: vt.CLASSIFICATION_MASK, depthTest: { enabled: !1 }, depthMask: !1, blending: an.PRE_MULTIPLIED_ALPHA_BLEND } } var Bwe = { stencilTest: { enabled: !0, frontFunction: Fn.NOT_EQUAL, frontOperation: { fail: lt.ZERO, zFail: lt.ZERO, zPass: lt.ZERO }, backFunction: Fn.NOT_EQUAL, backOperation: { fail: lt.ZERO, zFail: lt.ZERO, zPass: lt.ZERO }, reference: 0, mask: vt.CLASSIFICATION_MASK }, stencilMask: vt.CLASSIFICATION_MASK, depthTest: { enabled: !1 }, depthMask: !1 }; function Rwe(e, t, n, i) { if (l(e._rsStencilDepthPass)) return; let o = !e.debugShowShadowVolume; e._rsStencilDepthPass = Ve.fromCache(yC(o, !1)), e._rsStencilDepthPass3DTiles = Ve.fromCache(yC(o, !0)), e._rsColorPass = Ve.fromCache(mG(o, !1)), e._rsPickPass = Ve.fromCache(Bwe) } function Mwe(e, t) {
        if (!e.compressVertices) return t; if (t.search(/attribute\s+vec3\s+extrudeDirection;/g) !== -1) {
            let n = "compressedAttributes", i = `attribute vec2 ${n};`, o = `vec3 extrudeDirection;
`, r = `    extrudeDirection = czm_octDecode(${n}, 65535.0);
`, s = t; s = s.replace(/attribute\s+vec3\s+extrudeDirection;/g, ""), s = Ue.replaceMain(s, "czm_non_compressed_main"); let a = `void main() 
{ 
${r}    czm_non_compressed_main(); 
}`; return [i, o, s, a].join(`
`)
        }
    } function Lwe(e, t) { let n = t.context, i = e._primitive, o = JO; o = e._primitive._batchTable.getVertexShaderCallback()(o), o = xn._appendDistanceDisplayConditionToShader(i, o), o = xn._modifyShaderPosition(e, o, t.scene3DOnly), o = xn._updateColorAttribute(i, o); let r = e._hasPlanarExtentsAttributes, s = r || e._hasSphericalExtentsAttribute; e._extruded && (o = Mwe(i, o)); let a = e._extruded ? "EXTRUDED_GEOMETRY" : "", c = new Ue({ defines: [a], sources: [o] }), u = new Ue({ sources: [_0] }), f = e._primitive._attributeLocations, d = new ou(s, r, e.appearance); if (e._spStencil = qt.replaceCache({ context: n, shaderProgram: e._spStencil, vertexShaderSource: c, fragmentShaderSource: u, attributeLocations: f }), e._primitive.allowPicking) { let m = Ue.createPickVertexShaderSource(o); m = xn._appendShowToShader(i, m), m = xn._updatePickColorAttribute(m); let A = d.createPickFragmentShader(!1), C = d.createPickVertexShader([a], m, !1, t.mapProjection); if (e._spPick = qt.replaceCache({ context: n, shaderProgram: e._spPick, vertexShaderSource: C, fragmentShaderSource: A, attributeLocations: f }), s) { let x = n.shaderCache.getDerivedShaderProgram(e._spPick, "2dPick"); if (!l(x)) { let T = d.createPickFragmentShader(!0), b = d.createPickVertexShader([a], m, !0, t.mapProjection); x = n.shaderCache.createDerivedShaderProgram(e._spPick, "2dPick", { vertexShaderSource: b, fragmentShaderSource: T, attributeLocations: f }) } e._spPick2D = x } } else e._spPick = qt.fromCache({ context: n, vertexShaderSource: c, fragmentShaderSource: u, attributeLocations: f }); o = xn._appendShowToShader(i, o), c = new Ue({ defines: [a], sources: [o] }), e._sp = qt.replaceCache({ context: n, shaderProgram: e._sp, vertexShaderSource: c, fragmentShaderSource: u, attributeLocations: f }); let p = d.createFragmentShader(!1), g = d.createVertexShader([a], o, !1, t.mapProjection); if (e._spColor = qt.replaceCache({ context: n, shaderProgram: e._spColor, vertexShaderSource: g, fragmentShaderSource: p, attributeLocations: f }), s) { let m = n.shaderCache.getDerivedShaderProgram(e._spColor, "2dColor"); if (!l(m)) { let A = d.createFragmentShader(!0), C = d.createVertexShader([a], o, !0, t.mapProjection); m = n.shaderCache.createDerivedShaderProgram(e._spColor, "2dColor", { vertexShaderSource: C, fragmentShaderSource: A, attributeLocations: f }) } e._spColor2D = m } } function Fwe(e, t) { let n = e._primitive, i = n._va.length * 2; t.length = i; let o, r, s, a = 0, c = n._batchTable.getUniformMapCallback()(e._uniformMap), u = e._needs2DShader; for (o = 0; o < i; o += 2) { let g = n._va[a++]; r = t[o], l(r) || (r = t[o] = new $e({ owner: e, primitiveType: n._primitiveType })), r.vertexArray = g, r.renderState = e._rsStencilDepthPass, r.shaderProgram = e._sp, r.uniformMap = c, r.pass = xe.TERRAIN_CLASSIFICATION, s = $e.shallowClone(r, r.derivedCommands.tileset), s.renderState = e._rsStencilDepthPass3DTiles, s.pass = xe.CESIUM_3D_TILE_CLASSIFICATION, r.derivedCommands.tileset = s, r = t[o + 1], l(r) || (r = t[o + 1] = new $e({ owner: e, primitiveType: n._primitiveType })), r.vertexArray = g, r.renderState = e._rsColorPass, r.shaderProgram = e._spColor, r.pass = xe.TERRAIN_CLASSIFICATION; let A = e.appearance.material; if (l(A) && (c = yt(c, A._uniforms)), r.uniformMap = c, s = $e.shallowClone(r, r.derivedCommands.tileset), s.pass = xe.CESIUM_3D_TILE_CLASSIFICATION, r.derivedCommands.tileset = s, u) { let C = $e.shallowClone(r, r.derivedCommands.appearance2D); C.shaderProgram = e._spColor2D, r.derivedCommands.appearance2D = C, C = $e.shallowClone(s, s.derivedCommands.appearance2D), C.shaderProgram = e._spColor2D, s.derivedCommands.appearance2D = C } } let f = e._commandsIgnoreShow, d = e._spStencil, p = 0; i = f.length = i / 2; for (let g = 0; g < i; ++g) { let m = f[g] = $e.shallowClone(t[p], f[g]); m.shaderProgram = d, m.pass = xe.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW, p += 2 } } function Nwe(e, t) { let n = e._usePickOffsets, i = e._primitive, o = i._va.length * 2, r, s = 0, a; n && (r = i._pickOffsets, o = r.length * 2), t.length = o; let c, u, f, d = 0, p = i._batchTable.getUniformMapCallback()(e._uniformMap), g = e._needs2DShader; for (c = 0; c < o; c += 2) { let m = i._va[d++]; if (n && (a = r[s++], m = i._va[a.index]), u = t[c], l(u) || (u = t[c] = new $e({ owner: e, primitiveType: i._primitiveType, pickOnly: !0 })), u.vertexArray = m, u.renderState = e._rsStencilDepthPass, u.shaderProgram = e._sp, u.uniformMap = p, u.pass = xe.TERRAIN_CLASSIFICATION, n && (u.offset = a.offset, u.count = a.count), f = $e.shallowClone(u, u.derivedCommands.tileset), f.renderState = e._rsStencilDepthPass3DTiles, f.pass = xe.CESIUM_3D_TILE_CLASSIFICATION, u.derivedCommands.tileset = f, u = t[c + 1], l(u) || (u = t[c + 1] = new $e({ owner: e, primitiveType: i._primitiveType, pickOnly: !0 })), u.vertexArray = m, u.renderState = e._rsPickPass, u.shaderProgram = e._spPick, u.uniformMap = p, u.pass = xe.TERRAIN_CLASSIFICATION, n && (u.offset = a.offset, u.count = a.count), f = $e.shallowClone(u, u.derivedCommands.tileset), f.pass = xe.CESIUM_3D_TILE_CLASSIFICATION, u.derivedCommands.tileset = f, g) { let A = $e.shallowClone(u, u.derivedCommands.pick2D); A.shaderProgram = e._spPick2D, u.derivedCommands.pick2D = A, A = $e.shallowClone(f, f.derivedCommands.pick2D), A.shaderProgram = e._spPick2D, f.derivedCommands.pick2D = A } } } function Vwe(e, t, n, i, o, r, s) { Fwe(e, r), Nwe(e, s) } function YJ(e, t) { return Math.floor(e % t / 2) } function hG(e, t, n, i, o, r) { e.modelMatrix = n, e.boundingVolume = o, e.cull = i, e.debugShowBoundingVolume = r, t.commandList.push(e) } function XJ(e, t, n, i, o) { e.modelMatrix = n, e.boundingVolume = o, e.cull = i, t.commandList.push(e) } function kwe(e, t, n, i, o, r, s, a) { let c = e._primitive; xn._updateBoundingVolumes(c, t, o); let u; t.mode === ee.SCENE3D ? u = c._boundingSphereWC : t.mode === ee.COLUMBUS_VIEW ? u = c._boundingSphereCV : t.mode === ee.SCENE2D && l(c._boundingSphere2D) ? u = c._boundingSphere2D : l(c._boundingSphereMorph) && (u = c._boundingSphereMorph); let f = e.classificationType, d = f !== Ln.CESIUM_3D_TILE, p = f !== Ln.TERRAIN, g = t.passes, m, A, C; if (g.render) { let x = n.length; for (m = 0; m < x; ++m)A = u[YJ(m, x)], d && (C = n[m], hG(C, t, o, r, A, s)), p && (C = n[m].derivedCommands.tileset, hG(C, t, o, r, A, s)); if (t.invertClassification) { let T = e._commandsIgnoreShow, b = T.length; for (m = 0; m < b; ++m)A = u[m], C = T[m], hG(C, t, o, r, A, s) } } if (g.pick) { let x = i.length, T = c._pickOffsets; for (m = 0; m < x; ++m) { let b = T[YJ(m, x)]; A = u[b.index], d && (C = i[m], XJ(C, t, o, r, A)), p && (C = i[m].derivedCommands.tileset, XJ(C, t, o, r, A)) } } } x0.prototype.update = function (e) { if (!l(this._primitive) && !l(this.geometryInstances)) return; let t = this.appearance; l(t) && l(t.material) && t.material.update(e.context); let n = this, i = this._primitiveOptions; if (!l(this._primitive)) { let o = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances], r = o.length, s, a, c, u = !1, f = !0, d, p = !1, g = !1; for (r > 0 && (c = o[0].attributes, p = ou.hasAttributesForSphericalExtents(c), g = ou.hasAttributesForTextureCoordinatePlanes(c), d = c.color), s = 0; s < r; s++) { a = o[s]; let A = a.attributes.color; l(A) && (u = !0), f = f && l(A) && Bt.equals(d, A) } if (!f && !p && !g) throw new ye("All GeometryInstances must have the same color attribute except via GroundPrimitives"); u && !l(t) && (t = new $t({ flat: !0 }), this.appearance = t), this._usePickOffsets = !p && !g, this._hasSphericalExtentsAttribute = p, this._hasPlanarExtentsAttributes = g, this._hasPerColorAttribute = u; let m = new Array(r); for (s = 0; s < r; ++s)a = o[s], m[s] = new At({ geometry: a.geometry, attributes: a.attributes, modelMatrix: a.modelMatrix, id: a.id, pickPrimitive: y(this._pickPrimitive, n) }); i.appearance = t, i.geometryInstances = m, l(this._createBoundingVolumeFunction) && (i._createBoundingVolumeFunction = function (A, C) { n._createBoundingVolumeFunction(A, C) }), i._createRenderStatesFunction = function (A, C, x, T) { Rwe(n, C) }, i._createShaderProgramFunction = function (A, C, x) { Lwe(n, C) }, i._createCommandsFunction = function (A, C, x, T, b, S, D) { Vwe(n, void 0, void 0, !0, !1, S, D) }, l(this._updateAndQueueCommandsFunction) ? i._updateAndQueueCommandsFunction = function (A, C, x, T, b, S, D, P) { n._updateAndQueueCommandsFunction(A, C, x, T, b, S, D, P) } : i._updateAndQueueCommandsFunction = function (A, C, x, T, b, S, D, P) { kwe(n, C, x, T, b, S, D, P) }, this._primitive = new xn(i) } this.debugShowShadowVolume && !this._debugShowShadowVolume && this._ready ? (this._debugShowShadowVolume = !0, this._rsStencilDepthPass = Ve.fromCache(yC(!1, !1)), this._rsStencilDepthPass3DTiles = Ve.fromCache(yC(!1, !0)), this._rsColorPass = Ve.fromCache(mG(!1))) : !this.debugShowShadowVolume && this._debugShowShadowVolume && (this._debugShowShadowVolume = !1, this._rsStencilDepthPass = Ve.fromCache(yC(!0, !1)), this._rsStencilDepthPass3DTiles = Ve.fromCache(yC(!0, !0)), this._rsColorPass = Ve.fromCache(mG(!0))), this._primitive.appearance !== t && (this._primitive.appearance = t), this._primitive.show = this.show, this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume, this._primitive.update(e), e.afterRender.push(() => { l(this._primitive) && this._primitive.ready && this._completeLoad() }) }; x0.prototype.getGeometryInstanceAttributes = function (e) { return this._primitive.getGeometryInstanceAttributes(e) }; x0.prototype.isDestroyed = function () { return !1 }; x0.prototype.destroy = function () { return this._primitive = this._primitive && this._primitive.destroy(), this._sp = this._sp && this._sp.destroy(), this._spPick = this._spPick && this._spPick.destroy(), this._spColor = this._spColor && this._spColor.destroy(), this._spPick2D = void 0, this._spColor2D = void 0, le(this) }; var Ib = x0; var Uwe = { u_globeMinimumAltitude: function () { return 55e3 } }; function Bc(e) { e = y(e, y.EMPTY_OBJECT); let t = e.appearance, n = e.geometryInstances; if (!l(t) && l(n)) { let r = Array.isArray(n) ? n : [n], s = r.length; for (let a = 0; a < s; a++) { let c = r[a].attributes; if (l(c) && l(c.color)) { t = new $t({ flat: !0 }); break } } } this.appearance = t, this.geometryInstances = e.geometryInstances, this.show = y(e.show, !0), this.classificationType = y(e.classificationType, Ln.BOTH), this.debugShowBoundingVolume = y(e.debugShowBoundingVolume, !1), this.debugShowShadowVolume = y(e.debugShowShadowVolume, !1), this._boundingVolumes = [], this._boundingVolumes2D = [], this._ready = !1; let i = this; this._readyPromise = new Promise((r, s) => { i._completeLoad = () => { if (this._ready) return; this._ready = !0, this.releaseGeometryInstances && (this.geometryInstances = void 0); let a = this._error; l(a) ? s(a) : r(this) } }), this._primitive = void 0, this._maxHeight = void 0, this._minHeight = void 0, this._maxTerrainHeight = oi._defaultMaxTerrainHeight, this._minTerrainHeight = oi._defaultMinTerrainHeight, this._boundingSpheresKeys = [], this._boundingSpheres = [], this._useFragmentCulling = !1, this._zIndex = void 0; let o = this; this._classificationPrimitiveOptions = { geometryInstances: void 0, appearance: void 0, vertexCacheOptimize: y(e.vertexCacheOptimize, !1), interleave: y(e.interleave, !1), releaseGeometryInstances: y(e.releaseGeometryInstances, !0), allowPicking: y(e.allowPicking, !0), asynchronous: y(e.asynchronous, !0), compressVertices: y(e.compressVertices, !0), _createBoundingVolumeFunction: void 0, _updateAndQueueCommandsFunction: void 0, _pickPrimitive: o, _extruded: !0, _uniformMap: Uwe } } Object.defineProperties(Bc.prototype, { vertexCacheOptimize: { get: function () { return this._classificationPrimitiveOptions.vertexCacheOptimize } }, interleave: { get: function () { return this._classificationPrimitiveOptions.interleave } }, releaseGeometryInstances: { get: function () { return this._classificationPrimitiveOptions.releaseGeometryInstances } }, allowPicking: { get: function () { return this._classificationPrimitiveOptions.allowPicking } }, asynchronous: { get: function () { return this._classificationPrimitiveOptions.asynchronous } }, compressVertices: { get: function () { return this._classificationPrimitiveOptions.compressVertices } }, ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } } }); Bc.isSupported = Ib.isSupported; function KJ(e) { return function (t, n) { let i = n.maximumRadius, o = i / Math.cos(t * .5) - i; return e._maxHeight + o } } function JJ(e) { return function (t, n) { return e._minHeight } } var zwe = new h, Hwe = new h, Gwe = new h, Wwe = new he, jwe = new ce; function dB(e, t) { let n = e.mapProjection.ellipsoid; if (!l(t.attributes) || !l(t.attributes.position3DHigh)) return l(t.rectangle) ? t.rectangle : void 0; let i = t.attributes.position3DHigh.values, o = t.attributes.position3DLow.values, r = i.length, s = Number.POSITIVE_INFINITY, a = Number.POSITIVE_INFINITY, c = Number.NEGATIVE_INFINITY, u = Number.NEGATIVE_INFINITY; for (let d = 0; d < r; d += 3) { let p = h.unpack(i, d, zwe), g = h.unpack(o, d, Hwe), m = h.add(p, g, Gwe), A = n.cartesianToCartographic(m, Wwe), C = A.latitude, x = A.longitude; s = Math.min(s, C), a = Math.min(a, x), c = Math.max(c, C), u = Math.max(u, x) } let f = jwe; return f.north = c, f.south = s, f.east = u, f.west = a, f } function qwe(e, t, n) { let i = oi.getMinimumMaximumHeights(t, n); e._minTerrainHeight = i.minimumTerrainHeight, e._maxTerrainHeight = i.maximumTerrainHeight } function Ywe(e, t, n) { let i = t.mapProjection.ellipsoid, o = dB(t, n), r = di.fromRectangle(o, e._minHeight, e._maxHeight, i); if (e._boundingVolumes.push(r), !t.scene3DOnly) { let s = t.mapProjection, a = re.fromRectangleWithHeights2D(o, s, e._maxHeight, e._minHeight); h.fromElements(a.center.z, a.center.x, a.center.y, a.center), e._boundingVolumes2D.push(a) } } function pG(e, t) { return Math.floor(e % t / 2) } function _G(e, t, n, i, o, r, s) { let a = e._primitive; n.mode !== ee.SCENE3D && t.shaderProgram === a._spColor && a._needs2DShader && (t = t.derivedCommands.appearance2D), t.owner = e, t.modelMatrix = i, t.boundingVolume = r, t.cull = o, t.debugShowBoundingVolume = s, n.commandList.push(t) } function ZJ(e, t, n, i, o, r) { let s = e._primitive; n.mode !== ee.SCENE3D && t.shaderProgram === s._spPick && s._needs2DShader && (t = t.derivedCommands.pick2D), t.owner = e, t.modelMatrix = i, t.boundingVolume = r, t.cull = o, n.commandList.push(t) } function Xwe(e, t, n, i, o, r, s, a) { let c; t.mode === ee.SCENE3D ? c = e._boundingVolumes : c = e._boundingVolumes2D; let u = e.classificationType, f = u !== Ln.CESIUM_3D_TILE, d = u !== Ln.TERRAIN, p = t.passes, g = e._primitive, m, A, C; if (p.render) { let x = n.length; for (m = 0; m < x; ++m)A = c[pG(m, x)], f && (C = n[m], _G(e, C, t, o, r, A, s)), d && (C = n[m].derivedCommands.tileset, _G(e, C, t, o, r, A, s)); if (t.invertClassification) { let T = g._commandsIgnoreShow, b = T.length; for (m = 0; m < b; ++m)A = c[m], C = T[m], _G(e, C, t, o, r, A, s) } } if (p.pick) { let x = i.length, T; for (e._useFragmentCulling || (T = g._primitive._pickOffsets), m = 0; m < x; ++m) { if (A = c[pG(m, x)], !e._useFragmentCulling) { let b = T[pG(m, x)]; A = c[b.index] } f && (C = i[m], ZJ(e, C, t, o, r, A)), d && (C = i[m].derivedCommands.tileset, ZJ(e, C, t, o, r, A)) } } } Bc.initializeTerrainHeights = function () { return oi.initialize() }; Bc.prototype.update = function (e) { if (!l(this._primitive) && !l(this.geometryInstances)) return; if (!oi.initialized) { Bc.initializeTerrainHeights(); return } let t = this, n = this._classificationPrimitiveOptions; if (!l(this._primitive)) { let i = e.mapProjection.ellipsoid, o, r, s, a = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances], c = a.length, u = new Array(c), f, d; for (f = 0; f < c; ++f) { o = a[f], r = o.geometry; let A = dB(e, r); l(d) ? l(A) && ce.union(d, A, d) : d = ce.clone(A); let C = o.id; if (l(C) && l(A)) { let x = oi.getBoundingSphere(A, i); this._boundingSpheresKeys.push(C), this._boundingSpheres.push(x) } s = r.constructor, !l(s) || l(s.createShadowVolume) } qwe(this, d, i); let p = e.terrainExaggeration, g = e.terrainExaggerationRelativeHeight; this._minHeight = Ic.getHeight(this._minTerrainHeight, p, g), this._maxHeight = Ic.getHeight(this._maxTerrainHeight, p, g); let m = Bc._supportsMaterials(e.context); if (this._useFragmentCulling = m, m) { let A, C = !0; for (f = 0; f < c; ++f)if (o = a[f], r = o.geometry, d = dB(e, r), ou.shouldUseSphericalCoordinates(d)) { C = !1; break } for (f = 0; f < c; ++f) { o = a[f], r = o.geometry, s = r.constructor; let x = dB(e, r), T = r.textureCoordinateRotationPoints; C ? A = ou.getPlanarTextureCoordinateAttributes(x, T, i, e.mapProjection, this._maxHeight) : A = ou.getSphericalExtentGeometryInstanceAttributes(x, T, i, e.mapProjection); let b = o.attributes; for (let S in b) b.hasOwnProperty(S) && (A[S] = b[S]); u[f] = new At({ geometry: s.createShadowVolume(r, JJ(this), KJ(this)), attributes: A, id: o.id }) } } else for (f = 0; f < c; ++f)o = a[f], r = o.geometry, s = r.constructor, u[f] = new At({ geometry: s.createShadowVolume(r, JJ(this), KJ(this)), attributes: o.attributes, id: o.id }); n.geometryInstances = u, n.appearance = this.appearance, n._createBoundingVolumeFunction = function (A, C) { Ywe(t, A, C) }, n._updateAndQueueCommandsFunction = function (A, C, x, T, b, S, D, P) { Xwe(t, C, x, T, b, S, D, P) }, this._primitive = new Ib(n) } this._primitive.appearance = this.appearance, this._primitive.show = this.show, this._primitive.debugShowShadowVolume = this.debugShowShadowVolume, this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume, this._primitive.update(e), e.afterRender.push(() => { l(this._primitive) && this._primitive.ready && this._completeLoad() }) }; Bc.prototype.getBoundingSphere = function (e) { let t = this._boundingSpheresKeys.indexOf(e); if (t !== -1) return this._boundingSpheres[t] }; Bc.prototype.getGeometryInstanceAttributes = function (e) { return this._primitive.getGeometryInstanceAttributes(e) }; Bc.prototype.isDestroyed = function () { return !1 }; Bc.prototype.destroy = function () { return this._primitive = this._primitive && this._primitive.destroy(), le(this) }; Bc._supportsMaterials = function (e) { return e.depthTexture }; Bc.supportsMaterials = function (e) { return Bc._supportsMaterials(e.frameState.context) }; var Rc = Bc; function AC() { ye.throwInstantiationError() } Object.defineProperties(AC.prototype, { isConstant: { get: ye.throwInstantiationError }, definitionChanged: { get: ye.throwInstantiationError } }); AC.prototype.getType = ye.throwInstantiationError; AC.prototype.getValue = ye.throwInstantiationError; AC.prototype.equals = ye.throwInstantiationError; AC.getValue = function (e, t, n) { let i; return l(t) && (i = t.getType(e), l(i)) ? ((!l(n) || n.type !== i) && (n = Ki.fromType(i)), t.getValue(e, n.uniforms), n) : ((!l(n) || n.type !== Ki.ColorType) && (n = Ki.fromType(Ki.ColorType)), U.clone(U.WHITE, n.uniforms.color), n) }; var Yo = AC; function T0(e, t, n) { this._primitives = t, this._orderedGroundPrimitives = n, this._primitive = void 0, this._outlinePrimitive = void 0, this._geometryUpdater = e, this._options = e._options, this._entity = e._entity, this._material = void 0 } T0.prototype._isHidden = function (e, t, n) { return !e.isShowing || !e.isAvailable(n) || !j.getValueOrDefault(t.show, n, !0) }; T0.prototype._setOptions = ye.throwInstantiationError; T0.prototype.update = function (e) { let t = this._geometryUpdater, n = t._onTerrain, i = this._primitives, o = this._orderedGroundPrimitives; n ? o.remove(this._primitive) : (i.removeAndDestroy(this._primitive), i.removeAndDestroy(this._outlinePrimitive), this._outlinePrimitive = void 0), this._primitive = void 0; let r = this._entity, s = r[this._geometryUpdater._geometryPropertyName]; if (this._setOptions(r, s, e), this._isHidden(r, s, e)) return; let a = this._geometryUpdater.shadowsProperty.getValue(e), c = this._options; if (!l(s.fill) || s.fill.getValue(e)) { let u = t.fillMaterialProperty, f = u instanceof Ot, d, p = t._getIsClosed(c); if (f) d = new $t({ closed: p, flat: n && !t._supportsMaterialsforEntitiesOnTerrain }); else { let g = Yo.getValue(e, u, this._material); this._material = g, d = new eo({ material: g, translucent: g.isTranslucent(), closed: p }) } if (n) c.vertexFormat = $t.VERTEX_FORMAT, this._primitive = o.add(new Rc({ geometryInstances: this._geometryUpdater.createFillGeometryInstance(e), appearance: d, asynchronous: !1, shadows: a, classificationType: this._geometryUpdater.classificationTypeProperty.getValue(e) }), j.getValueOrUndefined(this._geometryUpdater.zIndex, e)); else { c.vertexFormat = d.vertexFormat; let g = this._geometryUpdater.createFillGeometryInstance(e); f && (d.translucent = g.attributes.color.value[3] !== 255), this._primitive = i.add(new xn({ geometryInstances: g, appearance: d, asynchronous: !1, shadows: a })) } } if (!n && l(s.outline) && s.outline.getValue(e)) { let u = this._geometryUpdater.createOutlineGeometryInstance(e), f = j.getValueOrDefault(s.outlineWidth, e, 1); this._outlinePrimitive = i.add(new xn({ geometryInstances: u, appearance: new $t({ flat: !0, translucent: u.attributes.color.value[3] !== 255, renderState: { lineWidth: t._scene.clampLineWidth(f) } }), asynchronous: !1, shadows: a })) } }; T0.prototype.getBoundingSphere = function (e) { let t = this._entity, n = this._primitive, i = this._outlinePrimitive, o; return l(n) && n.show && n.ready && (o = n.getGeometryInstanceAttributes(t), l(o) && l(o.boundingSphere)) ? (re.clone(o.boundingSphere, e), rt.DONE) : l(i) && i.show && i.ready && (o = i.getGeometryInstanceAttributes(t), l(o) && l(o.boundingSphere)) ? (re.clone(o.boundingSphere, e), rt.DONE) : l(n) && !n.ready || l(i) && !i.ready ? rt.PENDING : rt.FAILED }; T0.prototype.isDestroyed = function () { return !1 }; T0.prototype.destroy = function () { let e = this._primitives, t = this._orderedGroundPrimitives; this._geometryUpdater._onTerrain ? t.remove(this._primitive) : e.removeAndDestroy(this._primitive), e.removeAndDestroy(this._outlinePrimitive), le(this) }; var $n = T0; var QJ = {}; function Ob(e, t) { l(QJ[e]) || (QJ[e] = !0, console.warn(y(t, e))) } Ob.geometryOutlines = "Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0."; Ob.geometryZIndex = "Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored"; Ob.geometryHeightReference = "Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored"; Ob.geometryExtrudedHeightReference = "Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored"; var Pt = Ob; var Kwe = { NONE: 0, GEODESIC: 1, RHUMB: 2 }, Yt = Object.freeze(Kwe); var $J = I.EPSILON10; function Jwe(e, t, n, i) { if (!l(e)) return; n = y(n, !1); let o = l(i), r = e.length; if (r < 2) return e; let s, a = e[0], c, u, f = 0, d = -1; for (s = 1; s < r; ++s)c = e[s], t(a, c, $J) ? (l(u) || (u = e.slice(0, s), f = s - 1, d = 0), o && i.push(s)) : (l(u) && (u.push(c), f = s, o && (d = i.length)), a = c); return n && t(e[0], e[r - 1], $J) && (o && (l(u) ? i.splice(d, 0, f) : i.push(r - 1)), l(u) ? u.length -= 1 : u = e.slice(0, -1)), l(u) ? u : e } var _o = Jwe; function Zwe(e) { let t = e._uSquared, n = e._ellipsoid.maximumRadius, i = e._ellipsoid.minimumRadius, o = (n - i) / n, r = Math.cos(e._startHeading), s = Math.sin(e._startHeading), a = (1 - o) * Math.tan(e._start.latitude), c = 1 / Math.sqrt(1 + a * a), u = c * a, f = Math.atan2(a, r), d = c * s, p = d * d, g = 1 - p, m = Math.sqrt(g), A = t / 4, C = A * A, x = C * A, T = C * C, b = 1 + A - 3 * C / 4 + 5 * x / 4 - 175 * T / 64, S = 1 - A + 15 * C / 8 - 35 * x / 8, D = 1 - 3 * A + 35 * C / 4, P = 1 - 5 * A, B = b * f - S * Math.sin(2 * f) * A / 2 - D * Math.sin(4 * f) * C / 16 - P * Math.sin(6 * f) * x / 48 - Math.sin(8 * f) * 5 * T / 512, R = e._constants; R.a = n, R.b = i, R.f = o, R.cosineHeading = r, R.sineHeading = s, R.tanU = a, R.cosineU = c, R.sineU = u, R.sigma = f, R.sineAlpha = d, R.sineSquaredAlpha = p, R.cosineSquaredAlpha = g, R.cosineAlpha = m, R.u2Over4 = A, R.u4Over16 = C, R.u6Over64 = x, R.u8Over256 = T, R.a0 = b, R.a1 = S, R.a2 = D, R.a3 = P, R.distanceRatio = B } function Qwe(e, t) { return e * t * (4 + e * (4 - 3 * t)) / 16 } function eZ(e, t, n, i, o, r, s) { let a = Qwe(e, n); return (1 - a) * e * t * (i + a * o * (s + a * r * (2 * s * s - 1))) } function $we(e, t, n, i, o, r, s) { let a = (t - n) / t, c = r - i, u = Math.atan((1 - a) * Math.tan(o)), f = Math.atan((1 - a) * Math.tan(s)), d = Math.cos(u), p = Math.sin(u), g = Math.cos(f), m = Math.sin(f), A = d * g, C = d * m, x = p * m, T = p * g, b = c, S = I.TWO_PI, D = Math.cos(b), P = Math.sin(b), B, R, M, L, _; do { D = Math.cos(b), P = Math.sin(b); let N = C - T * D; M = Math.sqrt(g * g * P * P + N * N), R = x + A * D, B = Math.atan2(M, R); let X; M === 0 ? (X = 0, L = 1) : (X = A * P / M, L = 1 - X * X), S = b, _ = R - 2 * x / L, isFinite(_) || (_ = 0), b = c + eZ(a, X, L, B, M, R, _) } while (Math.abs(b - S) > I.EPSILON12); let E = L * (t * t - n * n) / (n * n), w = 1 + E * (4096 + E * (E * (320 - 175 * E) - 768)) / 16384, v = E * (256 + E * (E * (74 - 47 * E) - 128)) / 1024, O = _ * _, V = v * M * (_ + v * (R * (2 * O - 1) - v * _ * (4 * M * M - 3) * (4 * O - 3) / 6) / 4), z = n * w * (B - V), k = Math.atan2(g * P, C - T * D), G = Math.atan2(d * P, C * D - T); e._distance = z, e._startHeading = k, e._endHeading = G, e._uSquared = E } var eDe = new h, gG = new h; function tZ(e, t, n, i) { let o = h.normalize(i.cartographicToCartesian(t, gG), eDe), r = h.normalize(i.cartographicToCartesian(n, gG), gG); $we(e, i.maximumRadius, i.minimumRadius, t.longitude, t.latitude, n.longitude, n.latitude), e._start = he.clone(t, e._start), e._end = he.clone(n, e._end), e._start.height = 0, e._end.height = 0, Zwe(e) } function Bb(e, t, n) { let i = y(n, ie.WGS84); this._ellipsoid = i, this._start = new he, this._end = new he, this._constants = {}, this._startHeading = void 0, this._endHeading = void 0, this._distance = void 0, this._uSquared = void 0, l(e) && l(t) && tZ(this, e, t, i) } Object.defineProperties(Bb.prototype, { ellipsoid: { get: function () { return this._ellipsoid } }, surfaceDistance: { get: function () { return this._distance } }, start: { get: function () { return this._start } }, end: { get: function () { return this._end } }, startHeading: { get: function () { return this._startHeading } }, endHeading: { get: function () { return this._endHeading } } }); Bb.prototype.setEndPoints = function (e, t) { tZ(this, e, t, this._ellipsoid) }; Bb.prototype.interpolateUsingFraction = function (e, t) { return this.interpolateUsingSurfaceDistance(this._distance * e, t) }; Bb.prototype.interpolateUsingSurfaceDistance = function (e, t) { let n = this._constants, i = n.distanceRatio + e / n.b, o = Math.cos(2 * i), r = Math.cos(4 * i), s = Math.cos(6 * i), a = Math.sin(2 * i), c = Math.sin(4 * i), u = Math.sin(6 * i), f = Math.sin(8 * i), d = i * i, p = i * d, g = n.u8Over256, m = n.u2Over4, A = n.u6Over64, C = n.u4Over16, x = 2 * p * g * o / 3 + i * (1 - m + 7 * C / 4 - 15 * A / 4 + 579 * g / 64 - (C - 15 * A / 4 + 187 * g / 16) * o - (5 * A / 4 - 115 * g / 16) * r - 29 * g * s / 16) + (m / 2 - C + 71 * A / 32 - 85 * g / 16) * a + (5 * C / 16 - 5 * A / 4 + 383 * g / 96) * c - d * ((A - 11 * g / 2) * a + 5 * g * c / 2) + (29 * A / 96 - 29 * g / 16) * u + 539 * g * f / 1536, T = Math.asin(Math.sin(x) * n.cosineAlpha), b = Math.atan(n.a / n.b * Math.tan(T)); x = x - n.sigma; let S = Math.cos(2 * n.sigma + x), D = Math.sin(x), P = Math.cos(x), B = n.cosineU * P, R = n.sineU * D, L = Math.atan2(D * n.sineHeading, B - R * n.cosineHeading) - eZ(n.f, n.sineAlpha, n.cosineSquaredAlpha, x, D, P, S); return l(t) ? (t.longitude = this._start.longitude + L, t.latitude = b, t.height = 0, t) : new he(this._start.longitude + L, b, 0) }; var mf = Bb; function AG(e, t, n) { if (e === 0) return t * n; let i = e * e, o = i * i, r = o * i, s = r * i, a = s * i, c = a * i, u = n, f = Math.sin(2 * u), d = Math.sin(4 * u), p = Math.sin(6 * u), g = Math.sin(8 * u), m = Math.sin(10 * u), A = Math.sin(12 * u); return t * ((1 - i / 4 - 3 * o / 64 - 5 * r / 256 - 175 * s / 16384 - 441 * a / 65536 - 4851 * c / 1048576) * u - (3 * i / 8 + 3 * o / 32 + 45 * r / 1024 + 105 * s / 4096 + 2205 * a / 131072 + 6237 * c / 524288) * f + (15 * o / 256 + 45 * r / 1024 + 525 * s / 16384 + 1575 * a / 65536 + 155925 * c / 8388608) * d - (35 * r / 3072 + 175 * s / 12288 + 3675 * a / 262144 + 13475 * c / 1048576) * p + (315 * s / 131072 + 2205 * a / 524288 + 43659 * c / 8388608) * g - (693 * a / 1310720 + 6237 * c / 5242880) * m + 1001 * c / 8388608 * A) } function tDe(e, t, n) { let i = e / n; if (t === 0) return i; let o = i * i, r = o * i, s = r * i, a = t, c = a * a, u = c * c, f = u * c, d = f * c, p = d * c, g = p * c, m = Math.sin(2 * i), A = Math.cos(2 * i), C = Math.sin(4 * i), x = Math.cos(4 * i), T = Math.sin(6 * i), b = Math.cos(6 * i), S = Math.sin(8 * i), D = Math.cos(8 * i), P = Math.sin(10 * i), B = Math.cos(10 * i), R = Math.sin(12 * i); return i + i * c / 4 + 7 * i * u / 64 + 15 * i * f / 256 + 579 * i * d / 16384 + 1515 * i * p / 65536 + 16837 * i * g / 1048576 + (3 * i * u / 16 + 45 * i * f / 256 - i * (32 * o - 561) * d / 4096 - i * (232 * o - 1677) * p / 16384 + i * (399985 - 90560 * o + 512 * s) * g / 5242880) * A + (21 * i * f / 256 + 483 * i * d / 4096 - i * (224 * o - 1969) * p / 16384 - i * (33152 * o - 112599) * g / 1048576) * x + (151 * i * d / 4096 + 4681 * i * p / 65536 + 1479 * i * g / 16384 - 453 * r * g / 32768) * b + (1097 * i * p / 65536 + 42783 * i * g / 1048576) * D + 8011 * i * g / 1048576 * B + (3 * c / 8 + 3 * u / 16 + 213 * f / 2048 - 3 * o * f / 64 + 255 * d / 4096 - 33 * o * d / 512 + 20861 * p / 524288 - 33 * o * p / 512 + s * p / 1024 + 28273 * g / 1048576 - 471 * o * g / 8192 + 9 * s * g / 4096) * m + (21 * u / 256 + 21 * f / 256 + 533 * d / 8192 - 21 * o * d / 512 + 197 * p / 4096 - 315 * o * p / 4096 + 584039 * g / 16777216 - 12517 * o * g / 131072 + 7 * s * g / 2048) * C + (151 * f / 6144 + 151 * d / 4096 + 5019 * p / 131072 - 453 * o * p / 16384 + 26965 * g / 786432 - 8607 * o * g / 131072) * T + (1097 * d / 131072 + 1097 * p / 65536 + 225797 * g / 10485760 - 1097 * o * g / 65536) * S + (8011 * p / 2621440 + 8011 * g / 1048576) * P + 293393 * g / 251658240 * R } function CC(e, t) { if (e === 0) return Math.log(Math.tan(.5 * (I.PI_OVER_TWO + t))); let n = e * Math.sin(t); return Math.log(Math.tan(.5 * (I.PI_OVER_TWO + t))) - e / 2 * Math.log((1 + n) / (1 - n)) } function nDe(e, t, n, i, o) { let r = CC(e._ellipticity, n), s = CC(e._ellipticity, o); return Math.atan2(I.negativePiToPi(i - t), s - r) } function iDe(e, t, n, i, o, r, s) { let a = e._heading, c = r - i, u = 0; if (I.equalsEpsilon(Math.abs(a), I.PI_OVER_TWO, I.EPSILON8)) if (t === n) u = t * Math.cos(o) * I.negativePiToPi(c); else { let f = Math.sin(o); u = t * Math.cos(o) * I.negativePiToPi(c) / Math.sqrt(1 - e._ellipticitySquared * f * f) } else { let f = AG(e._ellipticity, t, o); u = (AG(e._ellipticity, t, s) - f) / Math.cos(a) } return Math.abs(u) } var oDe = new h, yG = new h; function nZ(e, t, n, i) { let o = h.normalize(i.cartographicToCartesian(t, yG), oDe), r = h.normalize(i.cartographicToCartesian(n, yG), yG), s = i.maximumRadius, a = i.minimumRadius, c = s * s, u = a * a; e._ellipticitySquared = (c - u) / c, e._ellipticity = Math.sqrt(e._ellipticitySquared), e._start = he.clone(t, e._start), e._start.height = 0, e._end = he.clone(n, e._end), e._end.height = 0, e._heading = nDe(e, t.longitude, t.latitude, n.longitude, n.latitude), e._distance = iDe(e, i.maximumRadius, i.minimumRadius, t.longitude, t.latitude, n.longitude, n.latitude) } function iZ(e, t, n, i, o, r) { if (n === 0) return he.clone(e, r); let s = o * o, a, c, u; if (Math.abs(I.PI_OVER_TWO - Math.abs(t)) > I.EPSILON8) { let f = AG(o, i, e.latitude), d = n * Math.cos(t), p = f + d; c = tDe(p, o, i); let g = CC(o, e.latitude), m = CC(o, c); u = Math.tan(t) * (m - g), a = I.negativePiToPi(e.longitude + u) } else { c = e.latitude; let f; if (o === 0) f = i * Math.cos(e.latitude); else { let d = Math.sin(e.latitude); f = i * Math.cos(e.latitude) / Math.sqrt(1 - s * d * d) } u = n / f, t > 0 ? a = I.negativePiToPi(e.longitude + u) : a = I.negativePiToPi(e.longitude - u) } return l(r) ? (r.longitude = a, r.latitude = c, r.height = 0, r) : new he(a, c, 0) } function sm(e, t, n) { let i = y(n, ie.WGS84); this._ellipsoid = i, this._start = new he, this._end = new he, this._heading = void 0, this._distance = void 0, this._ellipticity = void 0, this._ellipticitySquared = void 0, l(e) && l(t) && nZ(this, e, t, i) } Object.defineProperties(sm.prototype, { ellipsoid: { get: function () { return this._ellipsoid } }, surfaceDistance: { get: function () { return this._distance } }, start: { get: function () { return this._start } }, end: { get: function () { return this._end } }, heading: { get: function () { return this._heading } } }); sm.fromStartHeadingDistance = function (e, t, n, i, o) { let r = y(i, ie.WGS84), s = r.maximumRadius, a = r.minimumRadius, c = s * s, u = a * a, f = Math.sqrt((c - u) / c); t = I.negativePiToPi(t); let d = iZ(e, t, n, r.maximumRadius, f); return !l(o) || l(i) && !i.equals(o.ellipsoid) ? new sm(e, d, r) : (o.setEndPoints(e, d), o) }; sm.prototype.setEndPoints = function (e, t) { nZ(this, e, t, this._ellipsoid) }; sm.prototype.interpolateUsingFraction = function (e, t) { return this.interpolateUsingSurfaceDistance(e * this._distance, t) }; sm.prototype.interpolateUsingSurfaceDistance = function (e, t) { return iZ(this._start, this._heading, e, this._ellipsoid.maximumRadius, this._ellipticity, t) }; sm.prototype.findIntersectionWithLongitude = function (e, t) { let n = this._ellipticity, i = this._heading, o = Math.abs(i), r = this._start; if (e = I.negativePiToPi(e), I.equalsEpsilon(Math.abs(e), Math.PI, I.EPSILON14) && (e = I.sign(r.longitude) * Math.PI), l(t) || (t = new he), Math.abs(I.PI_OVER_TWO - o) <= I.EPSILON8) return t.longitude = e, t.latitude = r.latitude, t.height = 0, t; if (I.equalsEpsilon(Math.abs(I.PI_OVER_TWO - o), I.PI_OVER_TWO, I.EPSILON8)) return I.equalsEpsilon(e, r.longitude, I.EPSILON12) ? void 0 : (t.longitude = e, t.latitude = I.PI_OVER_TWO * I.sign(I.PI_OVER_TWO - i), t.height = 0, t); let s = r.latitude, a = n * Math.sin(s), c = Math.tan(.5 * (I.PI_OVER_TWO + s)) * Math.exp((e - r.longitude) / Math.tan(i)), u = (1 + a) / (1 - a), f = r.latitude, d; do { d = f; let p = n * Math.sin(d), g = (1 + p) / (1 - p); f = 2 * Math.atan(c * Math.pow(g / u, n / 2)) - I.PI_OVER_TWO } while (!I.equalsEpsilon(f, d, I.EPSILON12)); return t.longitude = e, t.latitude = f, t.height = 0, t }; sm.prototype.findIntersectionWithLatitude = function (e, t) { let n = this._ellipticity, i = this._heading, o = this._start; if (I.equalsEpsilon(Math.abs(i), I.PI_OVER_TWO, I.EPSILON8)) return; let r = CC(n, o.latitude), s = CC(n, e), a = Math.tan(i) * (s - r), c = I.negativePiToPi(o.longitude + a); return l(t) ? (t.longitude = c, t.latitude = e, t.height = 0, t) : new he(c, e, 0) }; var ga = sm; var DG = [_i, Ri], rDe = DG.length, EZ = Math.cos(I.toRadians(30)), oZ = Math.cos(I.toRadians(150)), bZ = 0, SZ = 1e3; function kp(e) { e = y(e, y.EMPTY_OBJECT); let t = e.positions; this.width = y(e.width, 1), this._positions = t, this.granularity = y(e.granularity, 9999), this.loop = y(e.loop, !1), this.arcType = y(e.arcType, Yt.GEODESIC), this._ellipsoid = ie.WGS84, this._projectionIndex = 0, this._workerName = "createGroundPolylineGeometry", this._scene3DOnly = !1 } Object.defineProperties(kp.prototype, { packedLength: { get: function () { return 1 + this._positions.length * 3 + 1 + 1 + 1 + ie.packedLength + 1 + 1 } } }); kp.setProjectionAndEllipsoid = function (e, t) { let n = 0; for (let i = 0; i < rDe; i++)if (t instanceof DG[i]) { n = i; break } e._projectionIndex = n, e._ellipsoid = t.ellipsoid }; var sDe = new h, rZ = new h, sZ = new h; function wG(e, t, n, i, o) { let r = $a(i, e, 0, sDe), s = $a(i, e, n, rZ), a = $a(i, t, 0, sZ), c = am(s, r, rZ), u = am(a, r, sZ); return h.cross(u, c, o), h.normalize(o, o) } var aDe = new he, cDe = new h, lDe = new h, uDe = new h; function CG(e, t, n, i, o, r, s, a, c, u, f) { if (o === 0) return; let d; r === Yt.GEODESIC ? d = new mf(e, t, s) : r === Yt.RHUMB && (d = new ga(e, t, s)); let p = d.surfaceDistance; if (p < o) return; let g = wG(e, t, i, s, uDe), m = Math.ceil(p / o), A = p / m, C = A, x = m - 1, T = a.length; for (let b = 0; b < x; b++) { let S = d.interpolateUsingSurfaceDistance(C, aDe), D = $a(s, S, n, cDe), P = $a(s, S, i, lDe); h.pack(g, a, T), h.pack(D, c, T), h.pack(P, u, T), f.push(S.latitude), f.push(S.longitude), T += 3, C += A } } var xG = new he; function $a(e, t, n, i) { return he.clone(t, xG), xG.height = n, he.toCartesian(xG, e, i) } kp.pack = function (e, t, n) { let i = y(n, 0), o = e._positions, r = o.length; t[i++] = r; for (let s = 0; s < r; ++s) { let a = o[s]; h.pack(a, t, i), i += 3 } return t[i++] = e.granularity, t[i++] = e.loop ? 1 : 0, t[i++] = e.arcType, ie.pack(e._ellipsoid, t, i), i += ie.packedLength, t[i++] = e._projectionIndex, t[i++] = e._scene3DOnly ? 1 : 0, t }; kp.unpack = function (e, t, n) { let i = y(t, 0), o = e[i++], r = new Array(o); for (let p = 0; p < o; p++)r[p] = h.unpack(e, i), i += 3; let s = e[i++], a = e[i++] === 1, c = e[i++], u = ie.unpack(e, i); i += ie.packedLength; let f = e[i++], d = e[i++] === 1; return l(n) || (n = new kp({ positions: r })), n._positions = r, n.granularity = s, n.loop = a, n.arcType = c, n._ellipsoid = u, n._projectionIndex = f, n._scene3DOnly = d, n }; function am(e, t, n) { return h.subtract(e, t, n), h.normalize(n, n), n } function aZ(e, t, n, i) { return i = am(e, t, i), i = h.cross(i, n, i), i = h.normalize(i, i), i = h.cross(n, i, i), i } var fDe = new h, dDe = new h, hDe = new h, wZ = new h, mDe = 0, pDe = -1; function TG(e, t, n, i, o) { let r = am(n, t, wZ), s = aZ(e, t, r, fDe), a = aZ(i, t, r, dDe); if (I.equalsEpsilon(h.dot(s, a), pDe, I.EPSILON5)) return o = h.cross(r, s, o), o = h.normalize(o, o), o; o = h.add(a, s, o), o = h.normalize(o, o); let c = h.cross(r, o, hDe); return h.dot(a, c) < mDe && (o = h.negate(o, o)), o } var _B = nn.fromPointNormal(h.ZERO, h.UNIT_Y), _De = new h, gDe = new h, yDe = new h, ADe = new h, CDe = new h, hB = new h, mB = new he, cZ = new he, lZ = new he; kp.createGeometry = function (e) { let t = !e._scene3DOnly, n = e.loop, i = e._ellipsoid, o = e.granularity, r = e.arcType, s = new DG[e._projectionIndex](i), a = bZ, c = SZ, u, f, d = e._positions, p = d.length; p === 2 && (n = !1); let g, m, A, C, x = new ga(void 0, void 0, i), T, b, S, D = [d[0]]; for (f = 0; f < p - 1; f++)g = d[f], m = d[f + 1], T = Gi.lineSegmentPlane(g, m, _B, hB), l(T) && !h.equalsEpsilon(T, g, I.EPSILON7) && !h.equalsEpsilon(T, m, I.EPSILON7) && (e.arcType === Yt.GEODESIC ? D.push(h.clone(T)) : e.arcType === Yt.RHUMB && (S = i.cartesianToCartographic(T, mB).longitude, A = i.cartesianToCartographic(g, mB), C = i.cartesianToCartographic(m, cZ), x.setEndPoints(A, C), b = x.findIntersectionWithLongitude(S, lZ), T = i.cartographicToCartesian(b, hB), l(T) && !h.equalsEpsilon(T, g, I.EPSILON7) && !h.equalsEpsilon(T, m, I.EPSILON7) && D.push(h.clone(T)))), D.push(m); n && (g = d[p - 1], m = d[0], T = Gi.lineSegmentPlane(g, m, _B, hB), l(T) && !h.equalsEpsilon(T, g, I.EPSILON7) && !h.equalsEpsilon(T, m, I.EPSILON7) && (e.arcType === Yt.GEODESIC ? D.push(h.clone(T)) : e.arcType === Yt.RHUMB && (S = i.cartesianToCartographic(T, mB).longitude, A = i.cartesianToCartographic(g, mB), C = i.cartesianToCartographic(m, cZ), x.setEndPoints(A, C), b = x.findIntersectionWithLongitude(S, lZ), T = i.cartographicToCartesian(b, hB), l(T) && !h.equalsEpsilon(T, g, I.EPSILON7) && !h.equalsEpsilon(T, m, I.EPSILON7) && D.push(h.clone(T))))); let P = D.length, B = new Array(P); for (f = 0; f < P; f++) { let q = he.fromCartesian(D[f], i); q.height = 0, B[f] = q } if (B = _o(B, he.equalsEpsilon), P = B.length, P < 2) return; let R = [], M = [], L = [], _ = [], E = _De, w = gDe, v = yDe, O = ADe, V = CDe, z = B[0], k = B[1], G = B[P - 1]; for (E = $a(i, G, a, E), O = $a(i, k, a, O), w = $a(i, z, a, w), v = $a(i, z, c, v), n ? V = TG(E, w, v, O, V) : V = wG(z, k, c, i, V), h.pack(V, M, 0), h.pack(w, L, 0), h.pack(v, _, 0), R.push(z.latitude), R.push(z.longitude), CG(z, k, a, c, o, r, i, M, L, _, R), f = 1; f < P - 1; ++f) { E = h.clone(w, E), w = h.clone(O, w); let q = B[f]; $a(i, q, c, v), $a(i, B[f + 1], a, O), TG(E, w, v, O, V), u = M.length, h.pack(V, M, u), h.pack(w, L, u), h.pack(v, _, u), R.push(q.latitude), R.push(q.longitude), CG(B[f], B[f + 1], a, c, o, r, i, M, L, _, R) } let N = B[P - 1], X = B[P - 2]; if (w = $a(i, N, a, w), v = $a(i, N, c, v), n) { let q = B[0]; E = $a(i, X, a, E), O = $a(i, q, a, O), V = TG(E, w, v, O, V) } else V = wG(X, N, c, i, V); if (u = M.length, h.pack(V, M, u), h.pack(w, L, u), h.pack(v, _, u), R.push(N.latitude), R.push(N.longitude), n) { for (CG(N, z, a, c, o, r, i, M, L, _, R), u = M.length, f = 0; f < 3; ++f)M[u + f] = M[f], L[u + f] = L[f], _[u + f] = _[f]; R.push(z.latitude), R.push(z.longitude) } return qDe(n, s, L, _, M, R, t) }; var xDe = new h, TDe = new Q, EDe = new Be; function uZ(e, t, n, i) { let o = am(n, t, xDe), r = h.dot(o, e); if (r > EZ || r < oZ) { let s = am(i, n, wZ), a = r < oZ ? I.PI_OVER_TWO : -I.PI_OVER_TWO, c = Be.fromAxisAngle(s, a, EDe), u = Q.fromQuaternion(c, TDe); return Q.multiplyByVector(u, e, e), !0 } return !1 } var fZ = new he, bDe = new h, dZ = new h; function Rb(e, t, n, i, o) { let r = he.toCartesian(t, e._ellipsoid, bDe), s = h.add(r, n, dZ), a = !1, c = e._ellipsoid, u = c.cartesianToCartographic(s, fZ); Math.abs(t.longitude - u.longitude) > I.PI_OVER_TWO && (a = !0, s = h.subtract(r, n, dZ), u = c.cartesianToCartographic(s, fZ)), u.height = 0; let f = e.project(u, o); return o = h.subtract(f, i, o), o.z = 0, o = h.normalize(o, o), a && h.negate(o, o), o } var SDe = new h, hZ = new h; function mZ(e, t, n, i, o, r) { let s = h.subtract(t, e, SDe); h.normalize(s, s); let a = n - bZ, c = h.multiplyByScalar(s, a, hZ); h.add(e, c, o); let u = i - SZ; c = h.multiplyByScalar(s, u, hZ), h.add(t, c, r) } var wDe = new h; function pB(e, t) { let n = nn.getPointDistance(_B, e), i = nn.getPointDistance(_B, t), o = wDe; I.equalsEpsilon(n, 0, I.EPSILON2) ? (o = am(t, e, o), h.multiplyByScalar(o, I.EPSILON2, o), h.add(e, o, e)) : I.equalsEpsilon(i, 0, I.EPSILON2) && (o = am(e, t, o), h.multiplyByScalar(o, I.EPSILON2, o), h.add(t, o, t)) } function DDe(e, t) { let n = Math.abs(e.longitude), i = Math.abs(t.longitude); if (I.equalsEpsilon(n, I.PI, I.EPSILON11)) { let o = I.sign(t.longitude); return e.longitude = o * (n - I.EPSILON11), 1 } else if (I.equalsEpsilon(i, I.PI, I.EPSILON11)) { let o = I.sign(e.longitude); return t.longitude = o * (i - I.EPSILON11), 2 } return 0 } var DZ = new he, vZ = new he, pZ = new h, EG = new h, _Z = new h, gZ = new h, vDe = new h, yZ = new h, PDe = [DZ, vZ], IDe = new ce, ODe = new h, BDe = new h, RDe = new h, MDe = new h, LDe = new h, FDe = new h, bG = new h, SG = new h, NDe = new h, VDe = new h, kDe = new h, AZ = new h, UDe = new h, zDe = new h, HDe = new Vn, GDe = new Vn, CZ = new h, WDe = new h, xZ = new h, jDe = [new re, new re], PZ = [0, 2, 1, 0, 3, 2, 0, 7, 3, 0, 4, 7, 0, 5, 4, 0, 1, 5, 5, 7, 4, 5, 6, 7, 5, 2, 6, 5, 1, 2, 3, 6, 2, 3, 7, 6], TZ = PZ.length; function qDe(e, t, n, i, o, r, s) { let a, c, u = t._ellipsoid, f = n.length / 3 - 1, d = f * 8, p = d * 4, g = f * 36, m = d > 65535 ? new Uint32Array(g) : new Uint16Array(g), A = new Float64Array(d * 3), C = new Float32Array(p), x = new Float32Array(p), T = new Float32Array(p), b = new Float32Array(p), S = new Float32Array(p), D, P, B, R; s && (D = new Float32Array(p), P = new Float32Array(p), B = new Float32Array(p), R = new Float32Array(d * 2)); let M = r.length / 2, L = 0, _ = DZ; _.height = 0; let E = vZ; E.height = 0; let w = pZ, v = EG; if (s) for (c = 0, a = 1; a < M; a++)_.latitude = r[c], _.longitude = r[c + 1], E.latitude = r[c + 2], E.longitude = r[c + 3], w = t.project(_, w), v = t.project(E, v), L += h.distance(w, v), c += 2; let O = i.length / 3; v = h.unpack(i, 0, v); let V = 0; for (c = 3, a = 1; a < O; a++)w = h.clone(v, w), v = h.unpack(i, c, v), V += h.distance(w, v), c += 3; let z; c = 3; let k = 0, G = 0, N = 0, X = 0, q = !1, J = h.unpack(n, 0, gZ), W = h.unpack(i, 0, EG), K = h.unpack(o, 0, yZ); if (e) { let Ie = h.unpack(n, n.length - 6, _Z); uZ(K, Ie, J, W) && (K = h.negate(K, K)) } let Z = 0, de = 0, pe = 0; for (a = 0; a < f; a++) { let Ie = h.clone(J, _Z), Fe = h.clone(W, pZ), We = h.clone(K, vDe); q && (We = h.negate(We, We)), J = h.unpack(n, c, gZ), W = h.unpack(i, c, EG), K = h.unpack(o, c, yZ), q = uZ(K, Ie, J, W), _.latitude = r[k], _.longitude = r[k + 1], E.latitude = r[k + 2], E.longitude = r[k + 3]; let Lt, Gt, cn, _t; if (s) { let Oi = DDe(_, E); Lt = t.project(_, LDe), Gt = t.project(E, FDe); let Wr = am(Gt, Lt, CZ); Wr.y = Math.abs(Wr.y), cn = bG, _t = SG, Oi === 0 || h.dot(Wr, h.UNIT_Y) > EZ ? (cn = Rb(t, _, We, Lt, bG), _t = Rb(t, E, K, Gt, SG)) : Oi === 1 ? (_t = Rb(t, E, K, Gt, SG), cn.x = 0, cn.y = I.sign(_.longitude - Math.abs(E.longitude)), cn.z = 0) : (cn = Rb(t, _, We, Lt, bG), _t.x = 0, _t.y = I.sign(_.longitude - E.longitude), _t.z = 0) } let Pn = h.distance(Fe, W), Jn = Vn.fromCartesian(Ie, HDe), at = h.subtract(J, Ie, NDe), Ne = h.normalize(at, AZ), nt = h.subtract(Fe, Ie, VDe); nt = h.normalize(nt, nt); let Ce = h.cross(Ne, nt, AZ); Ce = h.normalize(Ce, Ce); let je = h.cross(nt, We, UDe); je = h.normalize(je, je); let ut = h.subtract(W, J, kDe); ut = h.normalize(ut, ut); let Wn = h.cross(K, ut, zDe); Wn = h.normalize(Wn, Wn); let Zn = Pn / V, Fi = Z / V, mo = 0, bo, Ii, Le, et = 0, Ke = 0; if (s) { mo = h.distance(Lt, Gt), bo = Vn.fromCartesian(Lt, GDe), Ii = h.subtract(Gt, Lt, CZ), Le = h.normalize(Ii, WDe); let Oi = Le.x; Le.x = Le.y, Le.y = -Oi, et = mo / L, Ke = de / L } for (z = 0; z < 8; z++) { let Oi = X + z * 4, Wr = G + z * 2, jr = Oi + 3, Xl = z < 4 ? 1 : -1, Ni = z === 2 || z === 3 || z === 6 || z === 7 ? 1 : -1; h.pack(Jn.high, C, Oi), C[jr] = at.x, h.pack(Jn.low, x, Oi), x[jr] = at.y, h.pack(je, T, Oi), T[jr] = at.z, h.pack(Wn, b, Oi), b[jr] = Zn * Xl, h.pack(Ce, S, Oi); let Er = Fi * Ni; Er === 0 && Ni < 0 && (Er = 9), S[jr] = Er, s && (D[Oi] = bo.high.x, D[Oi + 1] = bo.high.y, D[Oi + 2] = bo.low.x, D[Oi + 3] = bo.low.y, B[Oi] = -cn.y, B[Oi + 1] = cn.x, B[Oi + 2] = _t.y, B[Oi + 3] = -_t.x, P[Oi] = Ii.x, P[Oi + 1] = Ii.y, P[Oi + 2] = Le.x, P[Oi + 3] = Le.y, R[Wr] = et * Xl, Er = Ke * Ni, Er === 0 && Ni < 0 && (Er = 9), R[Wr + 1] = Er) } let qe = RDe, mt = MDe, Ft = ODe, Cn = BDe, ro = ce.fromCartographicArray(PDe, IDe), So = oi.getMinimumMaximumHeights(ro, u), Ao = So.minimumTerrainHeight, Hs = So.maximumTerrainHeight; pe += Ao, pe += Hs, mZ(Ie, Fe, Ao, Hs, qe, Ft), mZ(J, W, Ao, Hs, mt, Cn); let nr = h.multiplyByScalar(Ce, I.EPSILON5, xZ); h.add(qe, nr, qe), h.add(mt, nr, mt), h.add(Ft, nr, Ft), h.add(Cn, nr, Cn), pB(qe, mt), pB(Ft, Cn), h.pack(qe, A, N), h.pack(mt, A, N + 3), h.pack(Cn, A, N + 6), h.pack(Ft, A, N + 9), nr = h.multiplyByScalar(Ce, -2 * I.EPSILON5, xZ), h.add(qe, nr, qe), h.add(mt, nr, mt), h.add(Ft, nr, Ft), h.add(Cn, nr, Cn), pB(qe, mt), pB(Ft, Cn), h.pack(qe, A, N + 12), h.pack(mt, A, N + 15), h.pack(Cn, A, N + 18), h.pack(Ft, A, N + 21), k += 2, c += 3, G += 16, N += 24, X += 32, Z += Pn, de += mo } c = 0; let oe = 0; for (a = 0; a < f; a++) { for (z = 0; z < TZ; z++)m[c + z] = PZ[z] + oe; oe += 8, c += TZ } let ue = jDe; re.fromVertices(n, h.ZERO, 3, ue[0]), re.fromVertices(i, h.ZERO, 3, ue[1]); let ge = re.fromBoundingSpheres(ue); ge.radius += pe / (f * 2); let Ee = { position: new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, normalize: !1, values: A }), startHiAndForwardOffsetX: Vp(C), startLoAndForwardOffsetY: Vp(x), startNormalAndForwardOffsetZ: Vp(T), endNormalAndTextureCoordinateNormalizationX: Vp(b), rightNormalAndTextureCoordinateNormalizationY: Vp(S) }; return s && (Ee.startHiLo2D = Vp(D), Ee.offsetAndRight2D = Vp(P), Ee.startEndNormals2D = Vp(B), Ee.texcoordNormalization2D = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, normalize: !1, values: R })), new st({ attributes: Ee, indices: m, boundingSphere: ge }) } function Vp(e) { return new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 4, normalize: !1, values: e }) } kp._projectNormal = Rb; var xC = kp; var gB = `#ifdef GL_EXT_frag_depth
#extension GL_EXT_frag_depth : enable
#endif
varying vec4 v_startPlaneNormalEcAndHalfWidth;
varying vec4 v_endPlaneNormalEcAndBatchId;
varying vec4 v_rightPlaneEC;
varying vec4 v_endEcAndStartEcX;
varying vec4 v_texcoordNormalizationAndStartEcYZ;
#ifdef PER_INSTANCE_COLOR
varying vec4 v_color;
#endif
void main(void)
{
float logDepthOrDepth = czm_branchFreeTernary(czm_sceneMode == czm_sceneMode2D, gl_FragCoord.z, czm_unpackDepth(texture2D(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw)));
vec3 ecStart = vec3(v_endEcAndStartEcX.w, v_texcoordNormalizationAndStartEcYZ.zw);
if (logDepthOrDepth == 0.0) {
#ifdef DEBUG_SHOW_VOLUME
gl_FragColor = vec4(1.0, 0.0, 0.0, 0.5);
return;
#else // DEBUG_SHOW_VOLUME
discard;
#endif // DEBUG_SHOW_VOLUME
}
vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);
eyeCoordinate /= eyeCoordinate.w;
float halfMaxWidth = v_startPlaneNormalEcAndHalfWidth.w * czm_metersPerPixel(eyeCoordinate);
float widthwiseDistance = czm_planeDistance(v_rightPlaneEC, eyeCoordinate.xyz);
float distanceFromStart = czm_planeDistance(v_startPlaneNormalEcAndHalfWidth.xyz, -dot(ecStart, v_startPlaneNormalEcAndHalfWidth.xyz), eyeCoordinate.xyz);
float distanceFromEnd = czm_planeDistance(v_endPlaneNormalEcAndBatchId.xyz, -dot(v_endEcAndStartEcX.xyz, v_endPlaneNormalEcAndBatchId.xyz), eyeCoordinate.xyz);
if (abs(widthwiseDistance) > halfMaxWidth || distanceFromStart < 0.0 || distanceFromEnd < 0.0) {
#ifdef DEBUG_SHOW_VOLUME
gl_FragColor = vec4(1.0, 0.0, 0.0, 0.5);
return;
#else // DEBUG_SHOW_VOLUME
discard;
#endif // DEBUG_SHOW_VOLUME
}
vec3 alignedPlaneNormal;
alignedPlaneNormal = cross(v_rightPlaneEC.xyz, v_startPlaneNormalEcAndHalfWidth.xyz);
alignedPlaneNormal = normalize(cross(alignedPlaneNormal, v_rightPlaneEC.xyz));
distanceFromStart = czm_planeDistance(alignedPlaneNormal, -dot(alignedPlaneNormal, ecStart), eyeCoordinate.xyz);
alignedPlaneNormal = cross(v_rightPlaneEC.xyz, v_endPlaneNormalEcAndBatchId.xyz);
alignedPlaneNormal = normalize(cross(alignedPlaneNormal, v_rightPlaneEC.xyz));
distanceFromEnd = czm_planeDistance(alignedPlaneNormal, -dot(alignedPlaneNormal, v_endEcAndStartEcX.xyz), eyeCoordinate.xyz);
#ifdef PER_INSTANCE_COLOR
gl_FragColor = czm_gammaCorrect(v_color);
#else // PER_INSTANCE_COLOR
float s = clamp(distanceFromStart / (distanceFromStart + distanceFromEnd), 0.0, 1.0);
s = (s * v_texcoordNormalizationAndStartEcYZ.x) + v_texcoordNormalizationAndStartEcYZ.y;
float t = (widthwiseDistance + halfMaxWidth) / (2.0 * halfMaxWidth);
czm_materialInput materialInput;
materialInput.s = s;
materialInput.st = vec2(s, t);
materialInput.str = vec3(s, t, 0.0);
czm_material material = czm_getMaterial(materialInput);
gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);
#endif // PER_INSTANCE_COLOR
gl_FragColor.rgb *= gl_FragColor.a;
czm_writeDepthClamp();
}
`; var yB = `varying vec3 v_forwardDirectionEC;
varying vec3 v_texcoordNormalizationAndHalfWidth;
varying float v_batchId;
#ifdef PER_INSTANCE_COLOR
varying vec4 v_color;
#else
varying vec2 v_alignedPlaneDistances;
varying float v_texcoordT;
#endif
float rayPlaneDistanceUnsafe(vec3 origin, vec3 direction, vec3 planeNormal, float planeDistance) {
return (-planeDistance - dot(planeNormal, origin)) / dot(planeNormal, direction);
}
void main(void)
{
vec4 eyeCoordinate = gl_FragCoord;
eyeCoordinate /= eyeCoordinate.w;
#ifdef PER_INSTANCE_COLOR
gl_FragColor = czm_gammaCorrect(v_color);
#else // PER_INSTANCE_COLOR
float distanceFromStart = rayPlaneDistanceUnsafe(eyeCoordinate.xyz, -v_forwardDirectionEC, v_forwardDirectionEC.xyz, v_alignedPlaneDistances.x);
float distanceFromEnd = rayPlaneDistanceUnsafe(eyeCoordinate.xyz, v_forwardDirectionEC, -v_forwardDirectionEC.xyz, v_alignedPlaneDistances.y);
distanceFromStart = max(0.0, distanceFromStart);
distanceFromEnd = max(0.0, distanceFromEnd);
float s = distanceFromStart / (distanceFromStart + distanceFromEnd);
s = (s * v_texcoordNormalizationAndHalfWidth.x) + v_texcoordNormalizationAndHalfWidth.y;
czm_materialInput materialInput;
materialInput.s = s;
materialInput.st = vec2(s, v_texcoordT);
materialInput.str = vec3(s, v_texcoordT, 0.0);
czm_material material = czm_getMaterial(materialInput);
gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);
#endif // PER_INSTANCE_COLOR
}
`; var AB = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;
attribute vec4 startHiAndForwardOffsetX;
attribute vec4 startLoAndForwardOffsetY;
attribute vec4 startNormalAndForwardOffsetZ;
attribute vec4 endNormalAndTextureCoordinateNormalizationX;
attribute vec4 rightNormalAndTextureCoordinateNormalizationY;
attribute vec4 startHiLo2D;
attribute vec4 offsetAndRight2D;
attribute vec4 startEndNormals2D;
attribute vec2 texcoordNormalization2D;
attribute float batchId;
varying vec3 v_forwardDirectionEC;
varying vec3 v_texcoordNormalizationAndHalfWidth;
varying float v_batchId;
#ifdef WIDTH_VARYING
varying float v_width;
#endif
#ifdef ANGLE_VARYING
varying float v_polylineAngle;
#endif
#ifdef PER_INSTANCE_COLOR
varying vec4 v_color;
#else
varying vec2 v_alignedPlaneDistances;
varying float v_texcoordT;
#endif
void main()
{
v_batchId = batchId;
vec4 posRelativeToEye2D = czm_translateRelativeToEye(vec3(0.0, startHiLo2D.xy), vec3(0.0, startHiLo2D.zw));
vec4 posRelativeToEye3D = czm_translateRelativeToEye(startHiAndForwardOffsetX.xyz, startLoAndForwardOffsetY.xyz);
vec4 posRelativeToEye = czm_columbusViewMorph(posRelativeToEye2D, posRelativeToEye3D, czm_morphTime);
vec3 posEc2D = (czm_modelViewRelativeToEye * posRelativeToEye2D).xyz;
vec3 posEc3D = (czm_modelViewRelativeToEye * posRelativeToEye3D).xyz;
vec3 startEC = (czm_modelViewRelativeToEye * posRelativeToEye).xyz;
vec4 startPlane2D;
vec4 startPlane3D;
startPlane2D.xyz = czm_normal * vec3(0.0, startEndNormals2D.xy);
startPlane3D.xyz = czm_normal * startNormalAndForwardOffsetZ.xyz;
startPlane2D.w = -dot(startPlane2D.xyz, posEc2D);
startPlane3D.w = -dot(startPlane3D.xyz, posEc3D);
vec4 rightPlane2D;
vec4 rightPlane3D;
rightPlane2D.xyz = czm_normal * vec3(0.0, offsetAndRight2D.zw);
rightPlane3D.xyz = czm_normal * rightNormalAndTextureCoordinateNormalizationY.xyz;
rightPlane2D.w = -dot(rightPlane2D.xyz, posEc2D);
rightPlane3D.w = -dot(rightPlane3D.xyz, posEc3D);
posRelativeToEye2D = posRelativeToEye2D + vec4(0.0, offsetAndRight2D.xy, 0.0);
posRelativeToEye3D = posRelativeToEye3D + vec4(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w, 0.0);
posRelativeToEye = czm_columbusViewMorph(posRelativeToEye2D, posRelativeToEye3D, czm_morphTime);
posEc2D = (czm_modelViewRelativeToEye * posRelativeToEye2D).xyz;
posEc3D = (czm_modelViewRelativeToEye * posRelativeToEye3D).xyz;
vec3 endEC = (czm_modelViewRelativeToEye * posRelativeToEye).xyz;
vec3 forwardEc3D = czm_normal * normalize(vec3(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w));
vec3 forwardEc2D = czm_normal * normalize(vec3(0.0, offsetAndRight2D.xy));
vec4 endPlane2D;
vec4 endPlane3D;
endPlane2D.xyz = czm_normal * vec3(0.0, startEndNormals2D.zw);
endPlane3D.xyz = czm_normal * endNormalAndTextureCoordinateNormalizationX.xyz;
endPlane2D.w = -dot(endPlane2D.xyz, posEc2D);
endPlane3D.w = -dot(endPlane3D.xyz, posEc3D);
v_forwardDirectionEC = normalize(endEC - startEC);
vec2 cleanTexcoordNormalization2D;
cleanTexcoordNormalization2D.x = abs(texcoordNormalization2D.x);
cleanTexcoordNormalization2D.y = czm_branchFreeTernary(texcoordNormalization2D.y > 1.0, 0.0, abs(texcoordNormalization2D.y));
vec2 cleanTexcoordNormalization3D;
cleanTexcoordNormalization3D.x = abs(endNormalAndTextureCoordinateNormalizationX.w);
cleanTexcoordNormalization3D.y = rightNormalAndTextureCoordinateNormalizationY.w;
cleanTexcoordNormalization3D.y = czm_branchFreeTernary(cleanTexcoordNormalization3D.y > 1.0, 0.0, abs(cleanTexcoordNormalization3D.y));
v_texcoordNormalizationAndHalfWidth.xy = mix(cleanTexcoordNormalization2D, cleanTexcoordNormalization3D, czm_morphTime);
#ifdef PER_INSTANCE_COLOR
v_color = czm_batchTable_color(batchId);
#else // PER_INSTANCE_COLOR
v_alignedPlaneDistances.x = -dot(v_forwardDirectionEC, startEC);
v_alignedPlaneDistances.y = -dot(-v_forwardDirectionEC, endEC);
#endif // PER_INSTANCE_COLOR
#ifdef WIDTH_VARYING
float width = czm_batchTable_width(batchId);
float halfWidth = width * 0.5;
v_width = width;
v_texcoordNormalizationAndHalfWidth.z = halfWidth;
#else
float halfWidth = 0.5 * czm_batchTable_width(batchId);
v_texcoordNormalizationAndHalfWidth.z = halfWidth;
#endif
vec4 positionEc3D = czm_modelViewRelativeToEye * czm_translateRelativeToEye(position3DHigh, position3DLow);
float absStartPlaneDistance = abs(czm_planeDistance(startPlane3D, positionEc3D.xyz));
float absEndPlaneDistance = abs(czm_planeDistance(endPlane3D, positionEc3D.xyz));
vec3 planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlane3D.xyz, endPlane3D.xyz);
vec3 upOrDown = normalize(cross(rightPlane3D.xyz, planeDirection));
vec3 normalEC = normalize(cross(planeDirection, upOrDown));
vec3 geodeticSurfaceNormal = normalize(cross(normalEC, forwardEc3D));
geodeticSurfaceNormal *= float(0.0 <= rightNormalAndTextureCoordinateNormalizationY.w && rightNormalAndTextureCoordinateNormalizationY.w <= 1.0);
geodeticSurfaceNormal *= MAX_TERRAIN_HEIGHT;
positionEc3D.xyz += geodeticSurfaceNormal;
normalEC *= sign(endNormalAndTextureCoordinateNormalizationX.w);
positionEc3D.xyz += halfWidth * max(0.0, czm_metersPerPixel(positionEc3D)) * normalEC;
vec4 positionEc2D = czm_modelViewRelativeToEye * czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy);
absStartPlaneDistance = abs(czm_planeDistance(startPlane2D, positionEc2D.xyz));
absEndPlaneDistance = abs(czm_planeDistance(endPlane2D, positionEc2D.xyz));
planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlane2D.xyz, endPlane2D.xyz);
upOrDown = normalize(cross(rightPlane2D.xyz, planeDirection));
normalEC = normalize(cross(planeDirection, upOrDown));
geodeticSurfaceNormal = normalize(cross(normalEC, forwardEc2D));
geodeticSurfaceNormal *= float(0.0 <= texcoordNormalization2D.y && texcoordNormalization2D.y <= 1.0);
geodeticSurfaceNormal *= MAX_TERRAIN_HEIGHT;
positionEc2D.xyz += geodeticSurfaceNormal;
normalEC *= sign(texcoordNormalization2D.x);
#ifndef PER_INSTANCE_COLOR
v_texcoordT = clamp(sign(texcoordNormalization2D.x), 0.0, 1.0);
#endif
positionEc2D.xyz += halfWidth * max(0.0, czm_metersPerPixel(positionEc2D)) * normalEC;
gl_Position = czm_projection * mix(positionEc2D, positionEc3D, czm_morphTime);
#ifdef ANGLE_VARYING
vec2 approxLineDirection = normalize(vec2(v_forwardDirectionEC.x, -v_forwardDirectionEC.y));
approxLineDirection.y = czm_branchFreeTernary(approxLineDirection.x == 0.0 && approxLineDirection.y == 0.0, -1.0, approxLineDirection.y);
v_polylineAngle = czm_fastApproximateAtan(approxLineDirection.x, approxLineDirection.y);
#endif
}
`; var CB = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;
#ifndef COLUMBUS_VIEW_2D
attribute vec4 startHiAndForwardOffsetX;
attribute vec4 startLoAndForwardOffsetY;
attribute vec4 startNormalAndForwardOffsetZ;
attribute vec4 endNormalAndTextureCoordinateNormalizationX;
attribute vec4 rightNormalAndTextureCoordinateNormalizationY;
#else
attribute vec4 startHiLo2D;
attribute vec4 offsetAndRight2D;
attribute vec4 startEndNormals2D;
attribute vec2 texcoordNormalization2D;
#endif
attribute float batchId;
varying vec4 v_startPlaneNormalEcAndHalfWidth;
varying vec4 v_endPlaneNormalEcAndBatchId;
varying vec4 v_rightPlaneEC;
varying vec4 v_endEcAndStartEcX;
varying vec4 v_texcoordNormalizationAndStartEcYZ;
#ifdef WIDTH_VARYING
varying float v_width;
#endif
#ifdef ANGLE_VARYING
varying float v_polylineAngle;
#endif
#ifdef PER_INSTANCE_COLOR
varying vec4 v_color;
#endif
void main()
{
#ifdef COLUMBUS_VIEW_2D
vec3 ecStart = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, startHiLo2D.xy), vec3(0.0, startHiLo2D.zw))).xyz;
vec3 forwardDirectionEC = czm_normal * vec3(0.0, offsetAndRight2D.xy);
vec3 ecEnd = forwardDirectionEC + ecStart;
forwardDirectionEC = normalize(forwardDirectionEC);
v_rightPlaneEC.xyz = czm_normal * vec3(0.0, offsetAndRight2D.zw);
v_rightPlaneEC.w = -dot(v_rightPlaneEC.xyz, ecStart);
vec4 startPlaneEC;
startPlaneEC.xyz =  czm_normal * vec3(0.0, startEndNormals2D.xy);
startPlaneEC.w = -dot(startPlaneEC.xyz, ecStart);
vec4 endPlaneEC;
endPlaneEC.xyz =  czm_normal * vec3(0.0, startEndNormals2D.zw);
endPlaneEC.w = -dot(endPlaneEC.xyz, ecEnd);
v_texcoordNormalizationAndStartEcYZ.x = abs(texcoordNormalization2D.x);
v_texcoordNormalizationAndStartEcYZ.y = texcoordNormalization2D.y;
#else // COLUMBUS_VIEW_2D
vec3 ecStart = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(startHiAndForwardOffsetX.xyz, startLoAndForwardOffsetY.xyz)).xyz;
vec3 offset = czm_normal * vec3(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w);
vec3 ecEnd = ecStart + offset;
vec3 forwardDirectionEC = normalize(offset);
vec4 startPlaneEC;
startPlaneEC.xyz = czm_normal * startNormalAndForwardOffsetZ.xyz;
startPlaneEC.w = -dot(startPlaneEC.xyz, ecStart);
vec4 endPlaneEC;
endPlaneEC.xyz = czm_normal * endNormalAndTextureCoordinateNormalizationX.xyz;
endPlaneEC.w = -dot(endPlaneEC.xyz, ecEnd);
v_rightPlaneEC.xyz = czm_normal * rightNormalAndTextureCoordinateNormalizationY.xyz;
v_rightPlaneEC.w = -dot(v_rightPlaneEC.xyz, ecStart);
v_texcoordNormalizationAndStartEcYZ.x = abs(endNormalAndTextureCoordinateNormalizationX.w);
v_texcoordNormalizationAndStartEcYZ.y = rightNormalAndTextureCoordinateNormalizationY.w;
#endif // COLUMBUS_VIEW_2D
v_endEcAndStartEcX.xyz = ecEnd;
v_endEcAndStartEcX.w = ecStart.x;
v_texcoordNormalizationAndStartEcYZ.zw = ecStart.yz;
#ifdef PER_INSTANCE_COLOR
v_color = czm_batchTable_color(batchId);
#endif // PER_INSTANCE_COLOR
vec4 positionRelativeToEye = czm_computePosition();
vec4 positionEC = czm_modelViewRelativeToEye * positionRelativeToEye;
float absStartPlaneDistance = abs(czm_planeDistance(startPlaneEC, positionEC.xyz));
float absEndPlaneDistance = abs(czm_planeDistance(endPlaneEC, positionEC.xyz));
vec3 planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlaneEC.xyz, endPlaneEC.xyz);
vec3 upOrDown = normalize(cross(v_rightPlaneEC.xyz, planeDirection));
vec3 normalEC = normalize(cross(planeDirection, upOrDown));
upOrDown = cross(forwardDirectionEC, normalEC);
upOrDown = float(czm_sceneMode == czm_sceneMode3D) * upOrDown;
upOrDown = float(v_texcoordNormalizationAndStartEcYZ.y > 1.0 || v_texcoordNormalizationAndStartEcYZ.y < 0.0) * upOrDown;
upOrDown = min(GLOBE_MINIMUM_ALTITUDE, czm_geometricToleranceOverMeter * length(positionRelativeToEye.xyz)) * upOrDown;
positionEC.xyz += upOrDown;
v_texcoordNormalizationAndStartEcYZ.y = czm_branchFreeTernary(v_texcoordNormalizationAndStartEcYZ.y > 1.0, 0.0, abs(v_texcoordNormalizationAndStartEcYZ.y));
float width = czm_batchTable_width(batchId);
#ifdef WIDTH_VARYING
v_width = width;
#endif
v_startPlaneNormalEcAndHalfWidth.xyz = startPlaneEC.xyz;
v_startPlaneNormalEcAndHalfWidth.w = width * 0.5;
v_endPlaneNormalEcAndBatchId.xyz = endPlaneEC.xyz;
v_endPlaneNormalEcAndBatchId.w = batchId;
width = width * max(0.0, czm_metersPerPixel(positionEC));
width = width / dot(normalEC, v_rightPlaneEC.xyz);
#ifdef COLUMBUS_VIEW_2D
normalEC *= sign(texcoordNormalization2D.x);
#else
normalEC *= sign(endNormalAndTextureCoordinateNormalizationX.w);
#endif
positionEC.xyz += width * normalEC;
gl_Position = czm_depthClamp(czm_projection * positionEC);
#ifdef ANGLE_VARYING
vec2 approxLineDirection = normalize(vec2(forwardDirectionEC.x, -forwardDirectionEC.y));
approxLineDirection.y = czm_branchFreeTernary(approxLineDirection.x == 0.0 && approxLineDirection.y == 0.0, -1.0, approxLineDirection.y);
v_polylineAngle = czm_fastApproximateAtan(approxLineDirection.x, approxLineDirection.y);
#endif
}
`; var xB = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;
attribute vec3 prevPosition3DHigh;
attribute vec3 prevPosition3DLow;
attribute vec3 nextPosition3DHigh;
attribute vec3 nextPosition3DLow;
attribute vec2 expandAndWidth;
attribute vec4 color;
attribute float batchId;
varying vec4 v_color;
void main()
{
float expandDir = expandAndWidth.x;
float width = abs(expandAndWidth.y) + 0.5;
bool usePrev = expandAndWidth.y < 0.0;
vec4 p = czm_computePosition();
vec4 prev = czm_computePrevPosition();
vec4 next = czm_computeNextPosition();
float angle;
vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);
gl_Position = czm_viewportOrthographic * positionWC;
v_color = color;
}
`; var ru = `void clipLineSegmentToNearPlane(
vec3 p0,
vec3 p1,
out vec4 positionWC,
out bool clipped,
out bool culledByNearPlane,
out vec4 clippedPositionEC)
{
culledByNearPlane = false;
clipped = false;
vec3 p0ToP1 = p1 - p0;
float magnitude = length(p0ToP1);
vec3 direction = normalize(p0ToP1);
float endPoint0Distance =  czm_currentFrustum.x + p0.z;
float denominator = -direction.z;
if (endPoint0Distance > 0.0 && abs(denominator) < czm_epsilon7)
{
culledByNearPlane = true;
}
else if (endPoint0Distance > 0.0)
{
float t = endPoint0Distance / denominator;
if (t < 0.0 || t > magnitude)
{
culledByNearPlane = true;
}
else
{
p0 = p0 + t * direction;
p0.z = min(p0.z, -czm_currentFrustum.x);
clipped = true;
}
}
clippedPositionEC = vec4(p0, 1.0);
positionWC = czm_eyeToWindowCoordinates(clippedPositionEC);
}
vec4 getPolylineWindowCoordinatesEC(vec4 positionEC, vec4 prevEC, vec4 nextEC, float expandDirection, float width, bool usePrevious, out float angle)
{
#ifdef POLYLINE_DASH
vec4 positionWindow = czm_eyeToWindowCoordinates(positionEC);
vec4 previousWindow = czm_eyeToWindowCoordinates(prevEC);
vec4 nextWindow = czm_eyeToWindowCoordinates(nextEC);
vec2 lineDir;
if (usePrevious) {
lineDir = normalize(positionWindow.xy - previousWindow.xy);
}
else {
lineDir = normalize(nextWindow.xy - positionWindow.xy);
}
angle = atan(lineDir.x, lineDir.y) - 1.570796327;
angle = floor(angle / czm_piOverFour + 0.5) * czm_piOverFour;
#endif
vec4 clippedPrevWC, clippedPrevEC;
bool prevSegmentClipped, prevSegmentCulled;
clipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, clippedPrevWC, prevSegmentClipped, prevSegmentCulled, clippedPrevEC);
vec4 clippedNextWC, clippedNextEC;
bool nextSegmentClipped, nextSegmentCulled;
clipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, clippedNextWC, nextSegmentClipped, nextSegmentCulled, clippedNextEC);
bool segmentClipped, segmentCulled;
vec4 clippedPositionWC, clippedPositionEC;
clipLineSegmentToNearPlane(positionEC.xyz, usePrevious ? prevEC.xyz : nextEC.xyz, clippedPositionWC, segmentClipped, segmentCulled, clippedPositionEC);
if (segmentCulled)
{
return vec4(0.0, 0.0, 0.0, 1.0);
}
vec2 directionToPrevWC = normalize(clippedPrevWC.xy - clippedPositionWC.xy);
vec2 directionToNextWC = normalize(clippedNextWC.xy - clippedPositionWC.xy);
if (prevSegmentCulled)
{
directionToPrevWC = -directionToNextWC;
}
else if (nextSegmentCulled)
{
directionToNextWC = -directionToPrevWC;
}
vec2 thisSegmentForwardWC, otherSegmentForwardWC;
if (usePrevious)
{
thisSegmentForwardWC = -directionToPrevWC;
otherSegmentForwardWC = directionToNextWC;
}
else
{
thisSegmentForwardWC = directionToNextWC;
otherSegmentForwardWC =  -directionToPrevWC;
}
vec2 thisSegmentLeftWC = vec2(-thisSegmentForwardWC.y, thisSegmentForwardWC.x);
vec2 leftWC = thisSegmentLeftWC;
float expandWidth = width * 0.5;
if (!czm_equalsEpsilon(prevEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1) && !czm_equalsEpsilon(nextEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1))
{
vec2 otherSegmentLeftWC = vec2(-otherSegmentForwardWC.y, otherSegmentForwardWC.x);
vec2 leftSumWC = thisSegmentLeftWC + otherSegmentLeftWC;
float leftSumLength = length(leftSumWC);
leftWC = leftSumLength < czm_epsilon6 ? thisSegmentLeftWC : (leftSumWC / leftSumLength);
vec2 u = -thisSegmentForwardWC;
vec2 v = leftWC;
float sinAngle = abs(u.x * v.y - u.y * v.x);
expandWidth = clamp(expandWidth / sinAngle, 0.0, width * 2.0);
}
vec2 offset = leftWC * expandDirection * expandWidth * czm_pixelRatio;
return vec4(clippedPositionWC.xy + offset, -clippedPositionWC.z, 1.0) * (czm_projection * clippedPositionEC).w;
}
vec4 getPolylineWindowCoordinates(vec4 position, vec4 previous, vec4 next, float expandDirection, float width, bool usePrevious, out float angle)
{
vec4 positionEC = czm_modelViewRelativeToEye * position;
vec4 prevEC = czm_modelViewRelativeToEye * previous;
vec4 nextEC = czm_modelViewRelativeToEye * next;
return getPolylineWindowCoordinatesEC(positionEC, prevEC, nextEC, expandDirection, width, usePrevious, angle);
}
`; var vG = `${ru}
${xB}`, YDe = aC; Nt.isInternetExplorer() || (vG = `#define CLIP_POLYLINE 
${vG}`); function E0(e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.translucent, !0), n = !1, i = E0.VERTEX_FORMAT; this.material = void 0, this.translucent = t, this._vertexShaderSource = y(e.vertexShaderSource, vG), this._fragmentShaderSource = y(e.fragmentShaderSource, YDe), this._renderState = Yi.getDefaultRenderState(t, n, e.renderState), this._closed = n, this._vertexFormat = i } Object.defineProperties(E0.prototype, { vertexShaderSource: { get: function () { return this._vertexShaderSource } }, fragmentShaderSource: { get: function () { return this._fragmentShaderSource } }, renderState: { get: function () { return this._renderState } }, closed: { get: function () { return this._closed } }, vertexFormat: { get: function () { return this._vertexFormat } } }); E0.VERTEX_FORMAT = we.POSITION_ONLY; E0.prototype.getFragmentShaderSource = Yi.prototype.getFragmentShaderSource; E0.prototype.isTranslucent = Yi.prototype.isTranslucent; E0.prototype.getRenderState = Yi.prototype.getRenderState; var Vr = E0; var TB = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;
attribute vec3 prevPosition3DHigh;
attribute vec3 prevPosition3DLow;
attribute vec3 nextPosition3DHigh;
attribute vec3 nextPosition3DLow;
attribute vec2 expandAndWidth;
attribute vec2 st;
attribute float batchId;
varying float v_width;
varying vec2 v_st;
varying float v_polylineAngle;
void main()
{
float expandDir = expandAndWidth.x;
float width = abs(expandAndWidth.y) + 0.5;
bool usePrev = expandAndWidth.y < 0.0;
vec4 p = czm_computePosition();
vec4 prev = czm_computePrevPosition();
vec4 next = czm_computeNextPosition();
float angle;
vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);
gl_Position = czm_viewportOrthographic * positionWC;
v_width = width;
v_st.s = st.s;
v_st.t = czm_writeNonPerspective(st.t, gl_Position.w);
v_polylineAngle = angle;
}
`; var TC = `#ifdef VECTOR_TILE
uniform vec4 u_highlightColor;
#endif
varying vec2 v_st;
void main()
{
czm_materialInput materialInput;
vec2 st = v_st;
st.t = czm_readNonPerspective(st.t, gl_FragCoord.w);
materialInput.s = st.s;
materialInput.st = st;
materialInput.str = vec3(st, 0.0);
czm_material material = czm_getMaterial(materialInput);
gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);
#ifdef VECTOR_TILE
gl_FragColor *= u_highlightColor;
#endif
czm_writeLogDepth();
}
`; var PG = `${ru}
${TB}`, XDe = TC; Nt.isInternetExplorer() || (PG = `#define CLIP_POLYLINE 
${PG}`); function b0(e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.translucent, !0), n = !1, i = b0.VERTEX_FORMAT; this.material = l(e.material) ? e.material : Ki.fromType(Ki.ColorType), this.translucent = t, this._vertexShaderSource = y(e.vertexShaderSource, PG), this._fragmentShaderSource = y(e.fragmentShaderSource, XDe), this._renderState = Yi.getDefaultRenderState(t, n, e.renderState), this._closed = n, this._vertexFormat = i } Object.defineProperties(b0.prototype, {
        vertexShaderSource: {
            get: function () {
                let e = this._vertexShaderSource; return this.material.shaderSource.search(/varying\s+float\s+v_polylineAngle;/g) !== -1 && (e = `#define POLYLINE_DASH
${e}`), e
            }
        }, fragmentShaderSource: { get: function () { return this._fragmentShaderSource } }, renderState: { get: function () { return this._renderState } }, closed: { get: function () { return this._closed } }, vertexFormat: { get: function () { return this._vertexFormat } }
    }); b0.VERTEX_FORMAT = we.POSITION_AND_ST; b0.prototype.getFragmentShaderSource = Yi.prototype.getFragmentShaderSource; b0.prototype.isTranslucent = Yi.prototype.isTranslucent; b0.prototype.getRenderState = Yi.prototype.getRenderState; var Ys = b0; function cm(e) { e = y(e, y.EMPTY_OBJECT), this.geometryInstances = e.geometryInstances, this._hasPerInstanceColors = !0; let t = e.appearance; l(t) || (t = new Ys), this.appearance = t, this.show = y(e.show, !0), this.classificationType = y(e.classificationType, Ln.BOTH), this.debugShowBoundingVolume = y(e.debugShowBoundingVolume, !1), this._debugShowShadowVolume = y(e.debugShowShadowVolume, !1), this._primitiveOptions = { geometryInstances: void 0, appearance: void 0, vertexCacheOptimize: !1, interleave: y(e.interleave, !1), releaseGeometryInstances: y(e.releaseGeometryInstances, !0), allowPicking: y(e.allowPicking, !0), asynchronous: y(e.asynchronous, !0), compressVertices: !1, _createShaderProgramFunction: void 0, _createCommandsFunction: void 0, _updateAndQueueCommandsFunction: void 0 }, this._zIndex = void 0, this._ready = !1; let n = this; this._readyPromise = new Promise((i, o) => { n._completeLoad = () => { this._ready = !0, this.releaseGeometryInstances && (this.geometryInstances = void 0); let r = this._error; l(r) ? o(r) : i(this) } }), this._primitive = void 0, this._sp = void 0, this._sp2D = void 0, this._spMorph = void 0, this._renderState = IZ(!1), this._renderState3DTiles = IZ(!0), this._renderStateMorph = Ve.fromCache({ cull: { enabled: !0, face: gi.FRONT }, depthTest: { enabled: !0 }, blending: an.PRE_MULTIPLIED_ALPHA_BLEND, depthMask: !1 }) } Object.defineProperties(cm.prototype, { interleave: { get: function () { return this._primitiveOptions.interleave } }, releaseGeometryInstances: { get: function () { return this._primitiveOptions.releaseGeometryInstances } }, allowPicking: { get: function () { return this._primitiveOptions.allowPicking } }, asynchronous: { get: function () { return this._primitiveOptions.asynchronous } }, ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } }, debugShowShadowVolume: { get: function () { return this._debugShowShadowVolume } } }); cm.initializeTerrainHeights = function () { return oi.initialize() }; function KDe(e, t, n) { let i = t.context, o = e._primitive, r = o._attributeLocations, s = o._batchTable.getVertexShaderCallback()(CB); s = xn._appendShowToShader(o, s), s = xn._appendDistanceDisplayConditionToShader(o, s), s = xn._modifyShaderPosition(e, s, t.scene3DOnly); let a = o._batchTable.getVertexShaderCallback()(AB); a = xn._appendShowToShader(o, a), a = xn._appendDistanceDisplayConditionToShader(o, a), a = xn._modifyShaderPosition(e, a, t.scene3DOnly); let c = o._batchTable.getVertexShaderCallback()(gB), u = [`GLOBE_MINIMUM_ALTITUDE ${t.mapProjection.ellipsoid.minimumRadius.toFixed(1)}`], f = "", d = ""; l(n.material) ? (d = l(n.material) ? n.material.shaderSource : "", d.search(/varying\s+float\s+v_polylineAngle;/g) !== -1 && u.push("ANGLE_VARYING"), d.search(/varying\s+float\s+v_width;/g) !== -1 && u.push("WIDTH_VARYING")) : f = "PER_INSTANCE_COLOR", u.push(f); let p = e.debugShowShadowVolume ? ["DEBUG_SHOW_VOLUME", f] : [f], g = new Ue({ defines: u, sources: [s] }), m = new Ue({ defines: p, sources: [d, c] }); e._sp = qt.replaceCache({ context: i, shaderProgram: o._sp, vertexShaderSource: g, fragmentShaderSource: m, attributeLocations: r }); let A = i.shaderCache.getDerivedShaderProgram(e._sp, "2dColor"); if (!l(A)) { let x = new Ue({ defines: u.concat(["COLUMBUS_VIEW_2D"]), sources: [s] }); A = i.shaderCache.createDerivedShaderProgram(e._sp, "2dColor", { context: i, shaderProgram: e._sp2D, vertexShaderSource: x, fragmentShaderSource: m, attributeLocations: r }) } e._sp2D = A; let C = i.shaderCache.getDerivedShaderProgram(e._sp, "MorphColor"); if (!l(C)) { let x = new Ue({ defines: u.concat([`MAX_TERRAIN_HEIGHT ${oi._defaultMaxTerrainHeight.toFixed(1)}`]), sources: [a] }); c = o._batchTable.getVertexShaderCallback()(yB); let T = new Ue({ defines: p, sources: [d, c] }); C = i.shaderCache.createDerivedShaderProgram(e._sp, "MorphColor", { context: i, shaderProgram: e._spMorph, vertexShaderSource: x, fragmentShaderSource: T, attributeLocations: r }) } e._spMorph = C } function IZ(e) { return Ve.fromCache({ cull: { enabled: !0 }, blending: an.PRE_MULTIPLIED_ALPHA_BLEND, depthMask: !1, stencilTest: { enabled: e, frontFunction: Fn.EQUAL, frontOperation: { fail: lt.KEEP, zFail: lt.KEEP, zPass: lt.KEEP }, backFunction: Fn.EQUAL, backOperation: { fail: lt.KEEP, zFail: lt.KEEP, zPass: lt.KEEP }, reference: vt.CESIUM_3D_TILE_MASK, mask: vt.CESIUM_3D_TILE_MASK } }) } function JDe(e, t, n, i, o, r) { let s = e._primitive, a = s._va.length; o.length = a, r.length = a; let u = t instanceof Vr ? {} : n._uniforms, f = s._batchTable.getUniformMapCallback()(u); for (let d = 0; d < a; d++) { let p = s._va[d], g = o[d]; l(g) || (g = o[d] = new $e({ owner: e, primitiveType: s._primitiveType })), g.vertexArray = p, g.renderState = e._renderState, g.shaderProgram = e._sp, g.uniformMap = f, g.pass = xe.TERRAIN_CLASSIFICATION, g.pickId = "czm_batchTable_pickColor(v_endPlaneNormalEcAndBatchId.w)"; let m = $e.shallowClone(g, g.derivedCommands.tileset); m.renderState = e._renderState3DTiles, m.pass = xe.CESIUM_3D_TILE_CLASSIFICATION, g.derivedCommands.tileset = m; let A = $e.shallowClone(g, g.derivedCommands.color2D); A.shaderProgram = e._sp2D, g.derivedCommands.color2D = A; let C = $e.shallowClone(m, m.derivedCommands.color2D); C.shaderProgram = e._sp2D, m.derivedCommands.color2D = C; let x = $e.shallowClone(g, g.derivedCommands.colorMorph); x.renderState = e._renderStateMorph, x.shaderProgram = e._spMorph, x.pickId = "czm_batchTable_pickColor(v_batchId)", g.derivedCommands.colorMorph = x } } function OZ(e, t, n, i, o, r, s) { n.mode === ee.MORPHING ? t = t.derivedCommands.colorMorph : n.mode !== ee.SCENE3D && (t = t.derivedCommands.color2D), t.modelMatrix = i, t.boundingVolume = r, t.cull = o, t.debugShowBoundingVolume = s, n.commandList.push(t) } function ZDe(e, t, n, i, o, r, s) { let a = e._primitive; xn._updateBoundingVolumes(a, t, o); let c; t.mode === ee.SCENE3D ? c = a._boundingSphereWC : t.mode === ee.COLUMBUS_VIEW ? c = a._boundingSphereCV : t.mode === ee.SCENE2D && l(a._boundingSphere2D) ? c = a._boundingSphere2D : l(a._boundingSphereMorph) && (c = a._boundingSphereMorph); let u = t.mode === ee.MORPHING, f = e.classificationType, d = f !== Ln.CESIUM_3D_TILE, p = f !== Ln.TERRAIN && !u, g, m = t.passes; if (m.render || m.pick && a.allowPicking) { let A = n.length; for (let C = 0; C < A; ++C) { let x = c[C]; d && (g = n[C], OZ(e, g, t, o, r, x, s)), p && (g = n[C].derivedCommands.tileset, OZ(e, g, t, o, r, x, s)) } } } cm.prototype.update = function (e) { if (!l(this._primitive) && !l(this.geometryInstances)) return; if (!oi.initialized) { cm.initializeTerrainHeights(); return } let t, n = this, i = this._primitiveOptions; if (!l(this._primitive)) { let o = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances], r = o.length, s = new Array(r), a; for (t = 0; t < r; ++t)if (a = o[t].attributes, !l(a) || !l(a.color)) { this._hasPerInstanceColors = !1; break } for (t = 0; t < r; ++t) { let c = o[t]; a = {}; let u = c.attributes; for (let f in u) u.hasOwnProperty(f) && (a[f] = u[f]); l(a.width) || (a.width = new Qa({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, value: [c.geometry.width] })), c.geometry._scene3DOnly = e.scene3DOnly, xC.setProjectionAndEllipsoid(c.geometry, e.mapProjection), s[t] = new At({ geometry: c.geometry, attributes: a, id: c.id, pickPrimitive: n }) } i.geometryInstances = s, i.appearance = this.appearance, i._createShaderProgramFunction = function (c, u, f) { KDe(n, u, f) }, i._createCommandsFunction = function (c, u, f, d, p, g, m) { JDe(n, u, f, d, g, m) }, i._updateAndQueueCommandsFunction = function (c, u, f, d, p, g, m, A) { ZDe(n, u, f, d, p, g, m) }, this._primitive = new xn(i), this._primitive.readyPromise.then(this._completeLoad) } if (this.appearance instanceof Vr && !this._hasPerInstanceColors) throw new ye("All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive."); this._primitive.appearance = this.appearance, this._primitive.show = this.show, this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume, this._primitive.update(e) }; cm.prototype.getGeometryInstanceAttributes = function (e) { return this._primitive.getGeometryInstanceAttributes(e) }; cm.isSupported = function (e) { return e.frameState.context.depthTexture }; cm.prototype.isDestroyed = function () { return !1 }; cm.prototype.destroy = function () { return this._primitive = this._primitive && this._primitive.destroy(), this._sp = this._sp && this._sp.destroy(), this._sp2D = void 0, this._spMorph = void 0, le(this) }; var Bd = cm; var QDe = new H(1, 1), $De = !1, eve = U.WHITE; function EC(e) { e = y(e, y.EMPTY_OBJECT), this._definitionChanged = new _e, this._image = void 0, this._imageSubscription = void 0, this._repeat = void 0, this._repeatSubscription = void 0, this._color = void 0, this._colorSubscription = void 0, this._transparent = void 0, this._transparentSubscription = void 0, this.image = e.image, this.repeat = e.repeat, this.color = e.color, this.transparent = e.transparent } Object.defineProperties(EC.prototype, { isConstant: { get: function () { return j.isConstant(this._image) && j.isConstant(this._repeat) } }, definitionChanged: { get: function () { return this._definitionChanged } }, image: ae("image"), repeat: ae("repeat"), color: ae("color"), transparent: ae("transparent") }); EC.prototype.getType = function (e) { return "Image" }; EC.prototype.getValue = function (e, t) { return l(t) || (t = {}), t.image = j.getValueOrUndefined(this._image, e), t.repeat = j.getValueOrClonedDefault(this._repeat, e, QDe, t.repeat), t.color = j.getValueOrClonedDefault(this._color, e, eve, t.color), j.getValueOrDefault(this._transparent, e, $De) && (t.color.alpha = Math.min(.99, t.color.alpha)), t }; EC.prototype.equals = function (e) { return this === e || e instanceof EC && j.equals(this._image, e._image) && j.equals(this._repeat, e._repeat) && j.equals(this._color, e._color) && j.equals(this._transparent, e._transparent) }; var S0 = EC; function tve(e) { if (e instanceof U) return new Ot(e); if (typeof e == "string" || e instanceof Pe || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement) { let t = new S0; return t.image = e, t } } function nve(e, t) { return ae(e, t, tve) } var wo = nve; function Mb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._dimensions = void 0, this._dimensionsSubscription = void 0, this._heightReference = void 0, this._heightReferenceSubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._shadows = void 0, this._shadowsSubscription = void 0, this._distanceDisplayCondition = void 0, this._distanceDisplayConditionSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(Mb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), dimensions: ae("dimensions"), heightReference: ae("heightReference"), fill: ae("fill"), material: wo("material"), outline: ae("outline"), outlineColor: ae("outlineColor"), outlineWidth: ae("outlineWidth"), shadows: ae("shadows"), distanceDisplayCondition: ae("distanceDisplayCondition") }); Mb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.dimensions = this.dimensions, e.heightReference = this.heightReference, e.fill = this.fill, e.material = this.material, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.shadows = this.shadows, e.distanceDisplayCondition = this.distanceDisplayCondition, e) : new Mb(this) }; Mb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.dimensions = y(this.dimensions, e.dimensions), this.heightReference = y(this.heightReference, e.heightReference), this.fill = y(this.fill, e.fill), this.material = y(this.material, e.material), this.outline = y(this.outline, e.outline), this.outlineColor = y(this.outlineColor, e.outlineColor), this.outlineWidth = y(this.outlineWidth, e.outlineWidth), this.shadows = y(this.shadows, e.shadows), this.distanceDisplayCondition = y(this.distanceDisplayCondition, e.distanceDisplayCondition) }; var bC = Mb; var ive = { FIXED: 0, INERTIAL: 1 }, Ji = Object.freeze(ive); function SC() { ye.throwInstantiationError() } Object.defineProperties(SC.prototype, { isConstant: { get: ye.throwInstantiationError }, definitionChanged: { get: ye.throwInstantiationError }, referenceFrame: { get: ye.throwInstantiationError } }); SC.prototype.getValue = ye.throwInstantiationError; SC.prototype.getValueInReferenceFrame = ye.throwInstantiationError; SC.prototype.equals = ye.throwInstantiationError; var IG = new Q; SC.convertToReferenceFrame = function (e, t, n, i, o) { if (!l(t)) return t; if (l(o) || (o = new h), n === i) return h.clone(t, o); let r = It.computeIcrfToFixedMatrix(e, IG); if (l(r) || (r = It.computeTemeToPseudoFixedMatrix(e, IG)), n === Ji.INERTIAL) return Q.multiplyByVector(r, t, o); if (n === Ji.FIXED) return Q.multiplyByVector(Q.transpose(r, IG), t, o) }; var Up = SC; function w0(e, t) { this._definitionChanged = new _e, this._value = h.clone(e), this._referenceFrame = y(t, Ji.FIXED) } Object.defineProperties(w0.prototype, { isConstant: { get: function () { return !l(this._value) || this._referenceFrame === Ji.FIXED } }, definitionChanged: { get: function () { return this._definitionChanged } }, referenceFrame: { get: function () { return this._referenceFrame } } }); w0.prototype.getValue = function (e, t) { return this.getValueInReferenceFrame(e, Ji.FIXED, t) }; w0.prototype.setValue = function (e, t) { let n = !1; h.equals(this._value, e) || (n = !0, this._value = h.clone(e)), l(t) && this._referenceFrame !== t && (n = !0, this._referenceFrame = t), n && this._definitionChanged.raiseEvent(this) }; w0.prototype.getValueInReferenceFrame = function (e, t, n) { return Up.convertToReferenceFrame(e, this._value, this._referenceFrame, t, n) }; w0.prototype.equals = function (e) { return this === e || e instanceof w0 && h.equals(this._value, e._value) && this._referenceFrame === e._referenceFrame }; var Mc = w0; function Lb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._positions = void 0, this._positionsSubscription = void 0, this._width = void 0, this._widthSubscription = void 0, this._height = void 0, this._heightSubscription = void 0, this._heightReference = void 0, this._heightReferenceSubscription = void 0, this._extrudedHeight = void 0, this._extrudedHeightSubscription = void 0, this._extrudedHeightReference = void 0, this._extrudedHeightReferenceSubscription = void 0, this._cornerType = void 0, this._cornerTypeSubscription = void 0, this._granularity = void 0, this._granularitySubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._shadows = void 0, this._shadowsSubscription = void 0, this._distanceDisplayCondition = void 0, this._distanceDisplayConditionSubscription = void 0, this._classificationType = void 0, this._classificationTypeSubscription = void 0, this._zIndex = void 0, this._zIndexSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(Lb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), positions: ae("positions"), width: ae("width"), height: ae("height"), heightReference: ae("heightReference"), extrudedHeight: ae("extrudedHeight"), extrudedHeightReference: ae("extrudedHeightReference"), cornerType: ae("cornerType"), granularity: ae("granularity"), fill: ae("fill"), material: wo("material"), outline: ae("outline"), outlineColor: ae("outlineColor"), outlineWidth: ae("outlineWidth"), shadows: ae("shadows"), distanceDisplayCondition: ae("distanceDisplayCondition"), classificationType: ae("classificationType"), zIndex: ae("zIndex") }); Lb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.positions = this.positions, e.width = this.width, e.height = this.height, e.heightReference = this.heightReference, e.extrudedHeight = this.extrudedHeight, e.extrudedHeightReference = this.extrudedHeightReference, e.cornerType = this.cornerType, e.granularity = this.granularity, e.fill = this.fill, e.material = this.material, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.shadows = this.shadows, e.distanceDisplayCondition = this.distanceDisplayCondition, e.classificationType = this.classificationType, e.zIndex = this.zIndex, e) : new Lb(this) }; Lb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.positions = y(this.positions, e.positions), this.width = y(this.width, e.width), this.height = y(this.height, e.height), this.heightReference = y(this.heightReference, e.heightReference), this.extrudedHeight = y(this.extrudedHeight, e.extrudedHeight), this.extrudedHeightReference = y(this.extrudedHeightReference, e.extrudedHeightReference), this.cornerType = y(this.cornerType, e.cornerType), this.granularity = y(this.granularity, e.granularity), this.fill = y(this.fill, e.fill), this.material = y(this.material, e.material), this.outline = y(this.outline, e.outline), this.outlineColor = y(this.outlineColor, e.outlineColor), this.outlineWidth = y(this.outlineWidth, e.outlineWidth), this.shadows = y(this.shadows, e.shadows), this.distanceDisplayCondition = y(this.distanceDisplayCondition, e.distanceDisplayCondition), this.classificationType = y(this.classificationType, e.classificationType), this.zIndex = y(this.zIndex, e.zIndex) }; var wC = Lb; function ove(e) { return e } function rve(e, t) { return ae(e, t, ove) } var dl = rve; function Fb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._length = void 0, this._lengthSubscription = void 0, this._topRadius = void 0, this._topRadiusSubscription = void 0, this._bottomRadius = void 0, this._bottomRadiusSubscription = void 0, this._heightReference = void 0, this._heightReferenceSubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._numberOfVerticalLines = void 0, this._numberOfVerticalLinesSubscription = void 0, this._slices = void 0, this._slicesSubscription = void 0, this._shadows = void 0, this._shadowsSubscription = void 0, this._distanceDisplayCondition = void 0, this._distanceDisplayConditionSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(Fb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), length: ae("length"), topRadius: ae("topRadius"), bottomRadius: ae("bottomRadius"), heightReference: ae("heightReference"), fill: ae("fill"), material: wo("material"), outline: ae("outline"), outlineColor: ae("outlineColor"), outlineWidth: ae("outlineWidth"), numberOfVerticalLines: ae("numberOfVerticalLines"), slices: ae("slices"), shadows: ae("shadows"), distanceDisplayCondition: ae("distanceDisplayCondition") }); Fb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.length = this.length, e.topRadius = this.topRadius, e.bottomRadius = this.bottomRadius, e.heightReference = this.heightReference, e.fill = this.fill, e.material = this.material, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.numberOfVerticalLines = this.numberOfVerticalLines, e.slices = this.slices, e.shadows = this.shadows, e.distanceDisplayCondition = this.distanceDisplayCondition, e) : new Fb(this) }; Fb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.length = y(this.length, e.length), this.topRadius = y(this.topRadius, e.topRadius), this.bottomRadius = y(this.bottomRadius, e.bottomRadius), this.heightReference = y(this.heightReference, e.heightReference), this.fill = y(this.fill, e.fill), this.material = y(this.material, e.material), this.outline = y(this.outline, e.outline), this.outlineColor = y(this.outlineColor, e.outlineColor), this.outlineWidth = y(this.outlineWidth, e.outlineWidth), this.numberOfVerticalLines = y(this.numberOfVerticalLines, e.numberOfVerticalLines), this.slices = y(this.slices, e.slices), this.shadows = y(this.shadows, e.shadows), this.distanceDisplayCondition = y(this.distanceDisplayCondition, e.distanceDisplayCondition) }; var DC = Fb; function Nb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._semiMajorAxis = void 0, this._semiMajorAxisSubscription = void 0, this._semiMinorAxis = void 0, this._semiMinorAxisSubscription = void 0, this._height = void 0, this._heightSubscription = void 0, this._heightReference = void 0, this._heightReferenceSubscription = void 0, this._extrudedHeight = void 0, this._extrudedHeightSubscription = void 0, this._extrudedHeightReference = void 0, this._extrudedHeightReferenceSubscription = void 0, this._rotation = void 0, this._rotationSubscription = void 0, this._stRotation = void 0, this._stRotationSubscription = void 0, this._granularity = void 0, this._granularitySubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._numberOfVerticalLines = void 0, this._numberOfVerticalLinesSubscription = void 0, this._shadows = void 0, this._shadowsSubscription = void 0, this._distanceDisplayCondition = void 0, this._distanceDisplayConditionSubscription = void 0, this._classificationType = void 0, this._classificationTypeSubscription = void 0, this._zIndex = void 0, this._zIndexSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(Nb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), semiMajorAxis: ae("semiMajorAxis"), semiMinorAxis: ae("semiMinorAxis"), height: ae("height"), heightReference: ae("heightReference"), extrudedHeight: ae("extrudedHeight"), extrudedHeightReference: ae("extrudedHeightReference"), rotation: ae("rotation"), stRotation: ae("stRotation"), granularity: ae("granularity"), fill: ae("fill"), material: wo("material"), outline: ae("outline"), outlineColor: ae("outlineColor"), outlineWidth: ae("outlineWidth"), numberOfVerticalLines: ae("numberOfVerticalLines"), shadows: ae("shadows"), distanceDisplayCondition: ae("distanceDisplayCondition"), classificationType: ae("classificationType"), zIndex: ae("zIndex") }); Nb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.semiMajorAxis = this.semiMajorAxis, e.semiMinorAxis = this.semiMinorAxis, e.height = this.height, e.heightReference = this.heightReference, e.extrudedHeight = this.extrudedHeight, e.extrudedHeightReference = this.extrudedHeightReference, e.rotation = this.rotation, e.stRotation = this.stRotation, e.granularity = this.granularity, e.fill = this.fill, e.material = this.material, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.numberOfVerticalLines = this.numberOfVerticalLines, e.shadows = this.shadows, e.distanceDisplayCondition = this.distanceDisplayCondition, e.classificationType = this.classificationType, e.zIndex = this.zIndex, e) : new Nb(this) }; Nb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.semiMajorAxis = y(this.semiMajorAxis, e.semiMajorAxis), this.semiMinorAxis = y(this.semiMinorAxis, e.semiMinorAxis), this.height = y(this.height, e.height), this.heightReference = y(this.heightReference, e.heightReference), this.extrudedHeight = y(this.extrudedHeight, e.extrudedHeight), this.extrudedHeightReference = y(this.extrudedHeightReference, e.extrudedHeightReference), this.rotation = y(this.rotation, e.rotation), this.stRotation = y(this.stRotation, e.stRotation), this.granularity = y(this.granularity, e.granularity), this.fill = y(this.fill, e.fill), this.material = y(this.material, e.material), this.outline = y(this.outline, e.outline), this.outlineColor = y(this.outlineColor, e.outlineColor), this.outlineWidth = y(this.outlineWidth, e.outlineWidth), this.numberOfVerticalLines = y(this.numberOfVerticalLines, e.numberOfVerticalLines), this.shadows = y(this.shadows, e.shadows), this.distanceDisplayCondition = y(this.distanceDisplayCondition, e.distanceDisplayCondition), this.classificationType = y(this.classificationType, e.classificationType), this.zIndex = y(this.zIndex, e.zIndex) }; var vC = Nb; function Vb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._radii = void 0, this._radiiSubscription = void 0, this._innerRadii = void 0, this._innerRadiiSubscription = void 0, this._minimumClock = void 0, this._minimumClockSubscription = void 0, this._maximumClock = void 0, this._maximumClockSubscription = void 0, this._minimumCone = void 0, this._minimumConeSubscription = void 0, this._maximumCone = void 0, this._maximumConeSubscription = void 0, this._heightReference = void 0, this._heightReferenceSubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._stackPartitions = void 0, this._stackPartitionsSubscription = void 0, this._slicePartitions = void 0, this._slicePartitionsSubscription = void 0, this._subdivisions = void 0, this._subdivisionsSubscription = void 0, this._shadows = void 0, this._shadowsSubscription = void 0, this._distanceDisplayCondition = void 0, this._distanceDisplayConditionSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(Vb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), radii: ae("radii"), innerRadii: ae("innerRadii"), minimumClock: ae("minimumClock"), maximumClock: ae("maximumClock"), minimumCone: ae("minimumCone"), maximumCone: ae("maximumCone"), heightReference: ae("heightReference"), fill: ae("fill"), material: wo("material"), outline: ae("outline"), outlineColor: ae("outlineColor"), outlineWidth: ae("outlineWidth"), stackPartitions: ae("stackPartitions"), slicePartitions: ae("slicePartitions"), subdivisions: ae("subdivisions"), shadows: ae("shadows"), distanceDisplayCondition: ae("distanceDisplayCondition") }); Vb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.radii = this.radii, e.innerRadii = this.innerRadii, e.minimumClock = this.minimumClock, e.maximumClock = this.maximumClock, e.minimumCone = this.minimumCone, e.maximumCone = this.maximumCone, e.heightReference = this.heightReference, e.fill = this.fill, e.material = this.material, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.stackPartitions = this.stackPartitions, e.slicePartitions = this.slicePartitions, e.subdivisions = this.subdivisions, e.shadows = this.shadows, e.distanceDisplayCondition = this.distanceDisplayCondition, e) : new Vb(this) }; Vb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.radii = y(this.radii, e.radii), this.innerRadii = y(this.innerRadii, e.innerRadii), this.minimumClock = y(this.minimumClock, e.minimumClock), this.maximumClock = y(this.maximumClock, e.maximumClock), this.minimumCone = y(this.minimumCone, e.minimumCone), this.maximumCone = y(this.maximumCone, e.maximumCone), this.heightReference = y(this.heightReference, e.heightReference), this.fill = y(this.fill, e.fill), this.material = y(this.material, e.material), this.outline = y(this.outline, e.outline), this.outlineColor = y(this.outlineColor, e.outlineColor), this.outlineWidth = y(this.outlineWidth, e.outlineWidth), this.stackPartitions = y(this.stackPartitions, e.stackPartitions), this.slicePartitions = y(this.slicePartitions, e.slicePartitions), this.subdivisions = y(this.subdivisions, e.subdivisions), this.shadows = y(this.shadows, e.shadows), this.distanceDisplayCondition = y(this.distanceDisplayCondition, e.distanceDisplayCondition) }; var PC = Vb; function kb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._text = void 0, this._textSubscription = void 0, this._font = void 0, this._fontSubscription = void 0, this._style = void 0, this._styleSubscription = void 0, this._scale = void 0, this._scaleSubscription = void 0, this._showBackground = void 0, this._showBackgroundSubscription = void 0, this._backgroundColor = void 0, this._backgroundColorSubscription = void 0, this._backgroundPadding = void 0, this._backgroundPaddingSubscription = void 0, this._pixelOffset = void 0, this._pixelOffsetSubscription = void 0, this._eyeOffset = void 0, this._eyeOffsetSubscription = void 0, this._horizontalOrigin = void 0, this._horizontalOriginSubscription = void 0, this._verticalOrigin = void 0, this._verticalOriginSubscription = void 0, this._heightReference = void 0, this._heightReferenceSubscription = void 0, this._fillColor = void 0, this._fillColorSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._translucencyByDistance = void 0, this._translucencyByDistanceSubscription = void 0, this._pixelOffsetScaleByDistance = void 0, this._pixelOffsetScaleByDistanceSubscription = void 0, this._scaleByDistance = void 0, this._scaleByDistanceSubscription = void 0, this._distanceDisplayCondition = void 0, this._distanceDisplayConditionSubscription = void 0, this._disableDepthTestDistance = void 0, this._disableDepthTestDistanceSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(kb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), text: ae("text"), font: ae("font"), style: ae("style"), scale: ae("scale"), showBackground: ae("showBackground"), backgroundColor: ae("backgroundColor"), backgroundPadding: ae("backgroundPadding"), pixelOffset: ae("pixelOffset"), eyeOffset: ae("eyeOffset"), horizontalOrigin: ae("horizontalOrigin"), verticalOrigin: ae("verticalOrigin"), heightReference: ae("heightReference"), fillColor: ae("fillColor"), outlineColor: ae("outlineColor"), outlineWidth: ae("outlineWidth"), translucencyByDistance: ae("translucencyByDistance"), pixelOffsetScaleByDistance: ae("pixelOffsetScaleByDistance"), scaleByDistance: ae("scaleByDistance"), distanceDisplayCondition: ae("distanceDisplayCondition"), disableDepthTestDistance: ae("disableDepthTestDistance") }); kb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.text = this.text, e.font = this.font, e.style = this.style, e.scale = this.scale, e.showBackground = this.showBackground, e.backgroundColor = this.backgroundColor, e.backgroundPadding = this.backgroundPadding, e.pixelOffset = this.pixelOffset, e.eyeOffset = this.eyeOffset, e.horizontalOrigin = this.horizontalOrigin, e.verticalOrigin = this.verticalOrigin, e.heightReference = this.heightReference, e.fillColor = this.fillColor, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.translucencyByDistance = this.translucencyByDistance, e.pixelOffsetScaleByDistance = this.pixelOffsetScaleByDistance, e.scaleByDistance = this.scaleByDistance, e.distanceDisplayCondition = this.distanceDisplayCondition, e.disableDepthTestDistance = this.disableDepthTestDistance, e) : new kb(this) }; kb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.text = y(this.text, e.text), this.font = y(this.font, e.font), this.style = y(this.style, e.style), this.scale = y(this.scale, e.scale), this.showBackground = y(this.showBackground, e.showBackground), this.backgroundColor = y(this.backgroundColor, e.backgroundColor), this.backgroundPadding = y(this.backgroundPadding, e.backgroundPadding), this.pixelOffset = y(this.pixelOffset, e.pixelOffset), this.eyeOffset = y(this.eyeOffset, e.eyeOffset), this.horizontalOrigin = y(this.horizontalOrigin, e.horizontalOrigin), this.verticalOrigin = y(this.verticalOrigin, e.verticalOrigin), this.heightReference = y(this.heightReference, e.heightReference), this.fillColor = y(this.fillColor, e.fillColor), this.outlineColor = y(this.outlineColor, e.outlineColor), this.outlineWidth = y(this.outlineWidth, e.outlineWidth), this.translucencyByDistance = y(this.translucencyByDistance, e.translucencyByDistance), this.pixelOffsetScaleByDistance = y(this.pixelOffsetScaleByDistance, e.pixelOffsetScaleByDistance), this.scaleByDistance = y(this.scaleByDistance, e.scaleByDistance), this.distanceDisplayCondition = y(this.distanceDisplayCondition, e.distanceDisplayCondition), this.disableDepthTestDistance = y(this.disableDepthTestDistance, e.disableDepthTestDistance) }; var Rd = kb; var sve = new h(1, 1, 1), ave = h.ZERO, cve = Be.IDENTITY; function BZ(e, t, n) { this.translation = h.clone(y(e, ave)), this.rotation = Be.clone(y(t, cve)), this.scale = h.clone(y(n, sve)) } BZ.prototype.equals = function (e) { return this === e || l(e) && h.equals(this.translation, e.translation) && Be.equals(this.rotation, e.rotation) && h.equals(this.scale, e.scale) }; var D0 = BZ; var OG = new D0; function Ub(e) { e = y(e, y.EMPTY_OBJECT), this._definitionChanged = new _e, this._translation = void 0, this._translationSubscription = void 0, this._rotation = void 0, this._rotationSubscription = void 0, this._scale = void 0, this._scaleSubscription = void 0, this.translation = e.translation, this.rotation = e.rotation, this.scale = e.scale } Object.defineProperties(Ub.prototype, { isConstant: { get: function () { return j.isConstant(this._translation) && j.isConstant(this._rotation) && j.isConstant(this._scale) } }, definitionChanged: { get: function () { return this._definitionChanged } }, translation: ae("translation"), rotation: ae("rotation"), scale: ae("scale") }); Ub.prototype.getValue = function (e, t) { return l(t) || (t = new D0), t.translation = j.getValueOrClonedDefault(this._translation, e, OG.translation, t.translation), t.rotation = j.getValueOrClonedDefault(this._rotation, e, OG.rotation, t.rotation), t.scale = j.getValueOrClonedDefault(this._scale, e, OG.scale, t.scale), t }; Ub.prototype.equals = function (e) { return this === e || e instanceof Ub && j.equals(this._translation, e._translation) && j.equals(this._rotation, e._rotation) && j.equals(this._scale, e._scale) }; var IC = Ub; function lm(e, t) { this._propertyNames = [], this._definitionChanged = new _e, l(e) && this.merge(e, t) } Object.defineProperties(lm.prototype, { propertyNames: { get: function () { return this._propertyNames } }, isConstant: { get: function () { let e = this._propertyNames; for (let t = 0, n = e.length; t < n; t++)if (!j.isConstant(this[e[t]])) return !1; return !0 } }, definitionChanged: { get: function () { return this._definitionChanged } } }); lm.prototype.hasProperty = function (e) { return this._propertyNames.indexOf(e) !== -1 }; function lve(e) { return new Yn(e) } lm.prototype.addProperty = function (e, t, n) { this._propertyNames.push(e), Object.defineProperty(this, e, ae(e, !0, y(n, lve))), l(t) && (this[e] = t), this._definitionChanged.raiseEvent(this) }; lm.prototype.removeProperty = function (e) { let n = this._propertyNames.indexOf(e); this._propertyNames.splice(n, 1), delete this[e], this._definitionChanged.raiseEvent(this) }; lm.prototype.getValue = function (e, t) { l(t) || (t = {}); let n = this._propertyNames; for (let i = 0, o = n.length; i < o; i++) { let r = n[i]; t[r] = j.getValueOrUndefined(this[r], e, t[r]) } return t }; lm.prototype.merge = function (e, t) { let n = this._propertyNames, i = l(e._propertyNames) ? e._propertyNames : Object.keys(e); for (let o = 0, r = i.length; o < r; o++) { let s = i[o], a = this[s], c = e[s]; a === void 0 && n.indexOf(s) === -1 && this.addProperty(s, void 0, t), c !== void 0 && (a !== void 0 ? l(a) && l(a.merge) && a.merge(c) : l(c) && l(c.merge) && l(c.clone) ? this[s] = c.clone() : this[s] = c) } }; function uve(e, t) { let n = e._propertyNames, i = t._propertyNames, o = n.length; if (o !== i.length) return !1; for (let r = 0; r < o; ++r) { let s = n[r]; if (i.indexOf(s) === -1 || !j.equals(e[s], t[s])) return !1 } return !0 } lm.prototype.equals = function (e) { return this === e || e instanceof lm && uve(this, e) }; var hl = lm; function RZ(e) { return new IC(e) } function fve(e) { return new hl(e, RZ) } function dve(e) { return new hl(e) } function zb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._uri = void 0, this._uriSubscription = void 0, this._scale = void 0, this._scaleSubscription = void 0, this._minimumPixelSize = void 0, this._minimumPixelSizeSubscription = void 0, this._maximumScale = void 0, this._maximumScaleSubscription = void 0, this._incrementallyLoadTextures = void 0, this._incrementallyLoadTexturesSubscription = void 0, this._runAnimations = void 0, this._runAnimationsSubscription = void 0, this._clampAnimations = void 0, this._clampAnimationsSubscription = void 0, this._shadows = void 0, this._shadowsSubscription = void 0, this._heightReference = void 0, this._heightReferenceSubscription = void 0, this._silhouetteColor = void 0, this._silhouetteColorSubscription = void 0, this._silhouetteSize = void 0, this._silhouetteSizeSubscription = void 0, this._color = void 0, this._colorSubscription = void 0, this._colorBlendMode = void 0, this._colorBlendModeSubscription = void 0, this._colorBlendAmount = void 0, this._colorBlendAmountSubscription = void 0, this._imageBasedLightingFactor = void 0, this._imageBasedLightingFactorSubscription = void 0, this._lightColor = void 0, this._lightColorSubscription = void 0, this._distanceDisplayCondition = void 0, this._distanceDisplayConditionSubscription = void 0, this._nodeTransformations = void 0, this._nodeTransformationsSubscription = void 0, this._articulations = void 0, this._articulationsSubscription = void 0, this._clippingPlanes = void 0, this._clippingPlanesSubscription = void 0, this._customShader = void 0, this._customShaderSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(zb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), uri: ae("uri"), scale: ae("scale"), minimumPixelSize: ae("minimumPixelSize"), maximumScale: ae("maximumScale"), incrementallyLoadTextures: ae("incrementallyLoadTextures"), runAnimations: ae("runAnimations"), clampAnimations: ae("clampAnimations"), shadows: ae("shadows"), heightReference: ae("heightReference"), silhouetteColor: ae("silhouetteColor"), silhouetteSize: ae("silhouetteSize"), color: ae("color"), colorBlendMode: ae("colorBlendMode"), colorBlendAmount: ae("colorBlendAmount"), imageBasedLightingFactor: ae("imageBasedLightingFactor"), lightColor: ae("lightColor"), distanceDisplayCondition: ae("distanceDisplayCondition"), nodeTransformations: ae("nodeTransformations", void 0, fve), articulations: ae("articulations", void 0, dve), clippingPlanes: ae("clippingPlanes"), customShader: ae("customShader") }); zb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.uri = this.uri, e.scale = this.scale, e.minimumPixelSize = this.minimumPixelSize, e.maximumScale = this.maximumScale, e.incrementallyLoadTextures = this.incrementallyLoadTextures, e.runAnimations = this.runAnimations, e.clampAnimations = this.clampAnimations, e.heightReference = this._heightReference, e.silhouetteColor = this.silhouetteColor, e.silhouetteSize = this.silhouetteSize, e.color = this.color, e.colorBlendMode = this.colorBlendMode, e.colorBlendAmount = this.colorBlendAmount, e.imageBasedLightingFactor = this.imageBasedLightingFactor, e.lightColor = this.lightColor, e.distanceDisplayCondition = this.distanceDisplayCondition, e.nodeTransformations = this.nodeTransformations, e.articulations = this.articulations, e.clippingPlanes = this.clippingPlanes, e.customShader = this.customShader, e) : new zb(this) }; zb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.uri = y(this.uri, e.uri), this.scale = y(this.scale, e.scale), this.minimumPixelSize = y(this.minimumPixelSize, e.minimumPixelSize), this.maximumScale = y(this.maximumScale, e.maximumScale), this.incrementallyLoadTextures = y(this.incrementallyLoadTextures, e.incrementallyLoadTextures), this.runAnimations = y(this.runAnimations, e.runAnimations), this.clampAnimations = y(this.clampAnimations, e.clampAnimations), this.shadows = y(this.shadows, e.shadows), this.heightReference = y(this.heightReference, e.heightReference), this.silhouetteColor = y(this.silhouetteColor, e.silhouetteColor), this.silhouetteSize = y(this.silhouetteSize, e.silhouetteSize), this.color = y(this.color, e.color), this.colorBlendMode = y(this.colorBlendMode, e.colorBlendMode), this.colorBlendAmount = y(this.colorBlendAmount, e.colorBlendAmount), this.imageBasedLightingFactor = y(this.imageBasedLightingFactor, e.imageBasedLightingFactor), this.lightColor = y(this.lightColor, e.lightColor), this.distanceDisplayCondition = y(this.distanceDisplayCondition, e.distanceDisplayCondition), this.clippingPlanes = y(this.clippingPlanes, e.clippingPlanes), this.customShader = y(this.customShader, e.customShader); let t = e.nodeTransformations; if (l(t)) { let i = this.nodeTransformations; l(i) ? i.merge(t) : this.nodeTransformations = new hl(t, RZ) } let n = e.articulations; if (l(n)) { let i = this.articulations; l(i) ? i.merge(n) : this.articulations = new hl(n) } }; var zp = zb; function Hb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._uri = void 0, this._uriSubscription = void 0, this._maximumScreenSpaceError = void 0, this._maximumScreenSpaceErrorSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(Hb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), uri: ae("uri"), maximumScreenSpaceError: ae("maximumScreenSpaceError") }); Hb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.uri = this.uri, e.maximumScreenSpaceError = this.maximumScreenSpaceError, e) : new Hb(this) }; Hb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.uri = y(this.uri, e.uri), this.maximumScreenSpaceError = y(this.maximumScreenSpaceError, e.maximumScreenSpaceError) }; var OC = Hb; function Gb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._leadTime = void 0, this._leadTimeSubscription = void 0, this._trailTime = void 0, this._trailTimeSubscription = void 0, this._width = void 0, this._widthSubscription = void 0, this._resolution = void 0, this._resolutionSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._distanceDisplayCondition = void 0, this._distanceDisplayConditionSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(Gb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), leadTime: ae("leadTime"), trailTime: ae("trailTime"), width: ae("width"), resolution: ae("resolution"), material: wo("material"), distanceDisplayCondition: ae("distanceDisplayCondition") }); Gb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.leadTime = this.leadTime, e.trailTime = this.trailTime, e.width = this.width, e.resolution = this.resolution, e.material = this.material, e.distanceDisplayCondition = this.distanceDisplayCondition, e) : new Gb(this) }; Gb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.leadTime = y(this.leadTime, e.leadTime), this.trailTime = y(this.trailTime, e.trailTime), this.width = y(this.width, e.width), this.resolution = y(this.resolution, e.resolution), this.material = y(this.material, e.material), this.distanceDisplayCondition = y(this.distanceDisplayCondition, e.distanceDisplayCondition) }; var Hp = Gb; function Wb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._plane = void 0, this._planeSubscription = void 0, this._dimensions = void 0, this._dimensionsSubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._shadows = void 0, this._shadowsSubscription = void 0, this._distanceDisplayCondition = void 0, this._distanceDisplayConditionSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(Wb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), plane: ae("plane"), dimensions: ae("dimensions"), fill: ae("fill"), material: wo("material"), outline: ae("outline"), outlineColor: ae("outlineColor"), outlineWidth: ae("outlineWidth"), shadows: ae("shadows"), distanceDisplayCondition: ae("distanceDisplayCondition") }); Wb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.plane = this.plane, e.dimensions = this.dimensions, e.fill = this.fill, e.material = this.material, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.shadows = this.shadows, e.distanceDisplayCondition = this.distanceDisplayCondition, e) : new Wb(this) }; Wb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.plane = y(this.plane, e.plane), this.dimensions = y(this.dimensions, e.dimensions), this.fill = y(this.fill, e.fill), this.material = y(this.material, e.material), this.outline = y(this.outline, e.outline), this.outlineColor = y(this.outlineColor, e.outlineColor), this.outlineWidth = y(this.outlineWidth, e.outlineWidth), this.shadows = y(this.shadows, e.shadows), this.distanceDisplayCondition = y(this.distanceDisplayCondition, e.distanceDisplayCondition) }; var EB = Wb; function jb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._pixelSize = void 0, this._pixelSizeSubscription = void 0, this._heightReference = void 0, this._heightReferenceSubscription = void 0, this._color = void 0, this._colorSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._scaleByDistance = void 0, this._scaleByDistanceSubscription = void 0, this._translucencyByDistance = void 0, this._translucencyByDistanceSubscription = void 0, this._distanceDisplayCondition = void 0, this._distanceDisplayConditionSubscription = void 0, this._disableDepthTestDistance = void 0, this._disableDepthTestDistanceSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(jb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), pixelSize: ae("pixelSize"), heightReference: ae("heightReference"), color: ae("color"), outlineColor: ae("outlineColor"), outlineWidth: ae("outlineWidth"), scaleByDistance: ae("scaleByDistance"), translucencyByDistance: ae("translucencyByDistance"), distanceDisplayCondition: ae("distanceDisplayCondition"), disableDepthTestDistance: ae("disableDepthTestDistance") }); jb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.pixelSize = this.pixelSize, e.heightReference = this.heightReference, e.color = this.color, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.scaleByDistance = this.scaleByDistance, e.translucencyByDistance = this._translucencyByDistance, e.distanceDisplayCondition = this.distanceDisplayCondition, e.disableDepthTestDistance = this.disableDepthTestDistance, e) : new jb(this) }; jb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.pixelSize = y(this.pixelSize, e.pixelSize), this.heightReference = y(this.heightReference, e.heightReference), this.color = y(this.color, e.color), this.outlineColor = y(this.outlineColor, e.outlineColor), this.outlineWidth = y(this.outlineWidth, e.outlineWidth), this.scaleByDistance = y(this.scaleByDistance, e.scaleByDistance), this.translucencyByDistance = y(this._translucencyByDistance, e.translucencyByDistance), this.distanceDisplayCondition = y(this.distanceDisplayCondition, e.distanceDisplayCondition), this.disableDepthTestDistance = y(this.disableDepthTestDistance, e.disableDepthTestDistance) }; var BC = jb; function hve(e, t) { this.positions = l(e) ? e : [], this.holes = l(t) ? t : [] } var Lc = hve; function mve(e) { return Array.isArray(e) && (e = new Lc(e)), new Yn(e) } function qb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._hierarchy = void 0, this._hierarchySubscription = void 0, this._height = void 0, this._heightSubscription = void 0, this._heightReference = void 0, this._heightReferenceSubscription = void 0, this._extrudedHeight = void 0, this._extrudedHeightSubscription = void 0, this._extrudedHeightReference = void 0, this._extrudedHeightReferenceSubscription = void 0, this._stRotation = void 0, this._stRotationSubscription = void 0, this._granularity = void 0, this._granularitySubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._perPositionHeight = void 0, this._perPositionHeightSubscription = void 0, this._closeTop = void 0, this._closeTopSubscription = void 0, this._closeBottom = void 0, this._closeBottomSubscription = void 0, this._arcType = void 0, this._arcTypeSubscription = void 0, this._shadows = void 0, this._shadowsSubscription = void 0, this._distanceDisplayCondition = void 0, this._distanceDisplayConditionSubscription = void 0, this._classificationType = void 0, this._classificationTypeSubscription = void 0, this._zIndex = void 0, this._zIndexSubscription = void 0, this._textureCoordinates = void 0, this._textureCoordinatesSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(qb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), hierarchy: ae("hierarchy", void 0, mve), height: ae("height"), heightReference: ae("heightReference"), extrudedHeight: ae("extrudedHeight"), extrudedHeightReference: ae("extrudedHeightReference"), stRotation: ae("stRotation"), granularity: ae("granularity"), fill: ae("fill"), material: wo("material"), outline: ae("outline"), outlineColor: ae("outlineColor"), outlineWidth: ae("outlineWidth"), perPositionHeight: ae("perPositionHeight"), closeTop: ae("closeTop"), closeBottom: ae("closeBottom"), arcType: ae("arcType"), shadows: ae("shadows"), distanceDisplayCondition: ae("distanceDisplayCondition"), classificationType: ae("classificationType"), zIndex: ae("zIndex"), textureCoordinates: ae("textureCoordinates") }); qb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.hierarchy = this.hierarchy, e.height = this.height, e.heightReference = this.heightReference, e.extrudedHeight = this.extrudedHeight, e.extrudedHeightReference = this.extrudedHeightReference, e.stRotation = this.stRotation, e.granularity = this.granularity, e.fill = this.fill, e.material = this.material, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.perPositionHeight = this.perPositionHeight, e.closeTop = this.closeTop, e.closeBottom = this.closeBottom, e.arcType = this.arcType, e.shadows = this.shadows, e.distanceDisplayCondition = this.distanceDisplayCondition, e.classificationType = this.classificationType, e.zIndex = this.zIndex, e.textureCoordinates = this.textureCoordinates, e) : new qb(this) }; qb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.hierarchy = y(this.hierarchy, e.hierarchy), this.height = y(this.height, e.height), this.heightReference = y(this.heightReference, e.heightReference), this.extrudedHeight = y(this.extrudedHeight, e.extrudedHeight), this.extrudedHeightReference = y(this.extrudedHeightReference, e.extrudedHeightReference), this.stRotation = y(this.stRotation, e.stRotation), this.granularity = y(this.granularity, e.granularity), this.fill = y(this.fill, e.fill), this.material = y(this.material, e.material), this.outline = y(this.outline, e.outline), this.outlineColor = y(this.outlineColor, e.outlineColor), this.outlineWidth = y(this.outlineWidth, e.outlineWidth), this.perPositionHeight = y(this.perPositionHeight, e.perPositionHeight), this.closeTop = y(this.closeTop, e.closeTop), this.closeBottom = y(this.closeBottom, e.closeBottom), this.arcType = y(this.arcType, e.arcType), this.shadows = y(this.shadows, e.shadows), this.distanceDisplayCondition = y(this.distanceDisplayCondition, e.distanceDisplayCondition), this.classificationType = y(this.classificationType, e.classificationType), this.zIndex = y(this.zIndex, e.zIndex), this.textureCoordinates = y(this.textureCoordinates, e.textureCoordinates) }; var Md = qb; function Yb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._positions = void 0, this._positionsSubscription = void 0, this._width = void 0, this._widthSubscription = void 0, this._granularity = void 0, this._granularitySubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._depthFailMaterial = void 0, this._depthFailMaterialSubscription = void 0, this._arcType = void 0, this._arcTypeSubscription = void 0, this._clampToGround = void 0, this._clampToGroundSubscription = void 0, this._shadows = void 0, this._shadowsSubscription = void 0, this._distanceDisplayCondition = void 0, this._distanceDisplayConditionSubscription = void 0, this._classificationType = void 0, this._classificationTypeSubscription = void 0, this._zIndex = void 0, this._zIndexSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(Yb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), positions: ae("positions"), width: ae("width"), granularity: ae("granularity"), material: wo("material"), depthFailMaterial: wo("depthFailMaterial"), arcType: ae("arcType"), clampToGround: ae("clampToGround"), shadows: ae("shadows"), distanceDisplayCondition: ae("distanceDisplayCondition"), classificationType: ae("classificationType"), zIndex: ae("zIndex") }); Yb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.positions = this.positions, e.width = this.width, e.granularity = this.granularity, e.material = this.material, e.depthFailMaterial = this.depthFailMaterial, e.arcType = this.arcType, e.clampToGround = this.clampToGround, e.shadows = this.shadows, e.distanceDisplayCondition = this.distanceDisplayCondition, e.classificationType = this.classificationType, e.zIndex = this.zIndex, e) : new Yb(this) }; Yb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.positions = y(this.positions, e.positions), this.width = y(this.width, e.width), this.granularity = y(this.granularity, e.granularity), this.material = y(this.material, e.material), this.depthFailMaterial = y(this.depthFailMaterial, e.depthFailMaterial), this.arcType = y(this.arcType, e.arcType), this.clampToGround = y(this.clampToGround, e.clampToGround), this.shadows = y(this.shadows, e.shadows), this.distanceDisplayCondition = y(this.distanceDisplayCondition, e.distanceDisplayCondition), this.classificationType = y(this.classificationType, e.classificationType), this.zIndex = y(this.zIndex, e.zIndex) }; var ec = Yb; function Xb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._positions = void 0, this._positionsSubscription = void 0, this._shape = void 0, this._shapeSubscription = void 0, this._cornerType = void 0, this._cornerTypeSubscription = void 0, this._granularity = void 0, this._granularitySubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._shadows = void 0, this._shadowsSubscription = void 0, this._distanceDisplayCondition = void 0, this._distanceDisplayConditionSubsription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(Xb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), positions: ae("positions"), shape: ae("shape"), cornerType: ae("cornerType"), granularity: ae("granularity"), fill: ae("fill"), material: wo("material"), outline: ae("outline"), outlineColor: ae("outlineColor"), outlineWidth: ae("outlineWidth"), shadows: ae("shadows"), distanceDisplayCondition: ae("distanceDisplayCondition") }); Xb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.positions = this.positions, e.shape = this.shape, e.cornerType = this.cornerType, e.granularity = this.granularity, e.fill = this.fill, e.material = this.material, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.shadows = this.shadows, e.distanceDisplayCondition = this.distanceDisplayCondition, e) : new Xb(this) }; Xb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.positions = y(this.positions, e.positions), this.shape = y(this.shape, e.shape), this.cornerType = y(this.cornerType, e.cornerType), this.granularity = y(this.granularity, e.granularity), this.fill = y(this.fill, e.fill), this.material = y(this.material, e.material), this.outline = y(this.outline, e.outline), this.outlineColor = y(this.outlineColor, e.outlineColor), this.outlineWidth = y(this.outlineWidth, e.outlineWidth), this.shadows = y(this.shadows, e.shadows), this.distanceDisplayCondition = y(this.distanceDisplayCondition, e.distanceDisplayCondition) }; var RC = Xb; function Kb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._coordinates = void 0, this._coordinatesSubscription = void 0, this._height = void 0, this._heightSubscription = void 0, this._heightReference = void 0, this._heightReferenceSubscription = void 0, this._extrudedHeight = void 0, this._extrudedHeightSubscription = void 0, this._extrudedHeightReference = void 0, this._extrudedHeightReferenceSubscription = void 0, this._rotation = void 0, this._rotationSubscription = void 0, this._stRotation = void 0, this._stRotationSubscription = void 0, this._granularity = void 0, this._granularitySubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._shadows = void 0, this._shadowsSubscription = void 0, this._distanceDisplayCondition = void 0, this._distancedisplayConditionSubscription = void 0, this._classificationType = void 0, this._classificationTypeSubscription = void 0, this._zIndex = void 0, this._zIndexSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(Kb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), coordinates: ae("coordinates"), height: ae("height"), heightReference: ae("heightReference"), extrudedHeight: ae("extrudedHeight"), extrudedHeightReference: ae("extrudedHeightReference"), rotation: ae("rotation"), stRotation: ae("stRotation"), granularity: ae("granularity"), fill: ae("fill"), material: wo("material"), outline: ae("outline"), outlineColor: ae("outlineColor"), outlineWidth: ae("outlineWidth"), shadows: ae("shadows"), distanceDisplayCondition: ae("distanceDisplayCondition"), classificationType: ae("classificationType"), zIndex: ae("zIndex") }); Kb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.coordinates = this.coordinates, e.height = this.height, e.heightReference = this.heightReference, e.extrudedHeight = this.extrudedHeight, e.extrudedHeightReference = this.extrudedHeightReference, e.rotation = this.rotation, e.stRotation = this.stRotation, e.granularity = this.granularity, e.fill = this.fill, e.material = this.material, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.shadows = this.shadows, e.distanceDisplayCondition = this.distanceDisplayCondition, e.classificationType = this.classificationType, e.zIndex = this.zIndex, e) : new Kb(this) }; Kb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.coordinates = y(this.coordinates, e.coordinates), this.height = y(this.height, e.height), this.heightReference = y(this.heightReference, e.heightReference), this.extrudedHeight = y(this.extrudedHeight, e.extrudedHeight), this.extrudedHeightReference = y(this.extrudedHeightReference, e.extrudedHeightReference), this.rotation = y(this.rotation, e.rotation), this.stRotation = y(this.stRotation, e.stRotation), this.granularity = y(this.granularity, e.granularity), this.fill = y(this.fill, e.fill), this.material = y(this.material, e.material), this.outline = y(this.outline, e.outline), this.outlineColor = y(this.outlineColor, e.outlineColor), this.outlineWidth = y(this.outlineWidth, e.outlineWidth), this.shadows = y(this.shadows, e.shadows), this.distanceDisplayCondition = y(this.distanceDisplayCondition, e.distanceDisplayCondition), this.classificationType = y(this.classificationType, e.classificationType), this.zIndex = y(this.zIndex, e.zIndex) }; var Ld = Kb; function Jb(e) { this._definitionChanged = new _e, this._show = void 0, this._showSubscription = void 0, this._positions = void 0, this._positionsSubscription = void 0, this._minimumHeights = void 0, this._minimumHeightsSubscription = void 0, this._maximumHeights = void 0, this._maximumHeightsSubscription = void 0, this._granularity = void 0, this._granularitySubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._shadows = void 0, this._shadowsSubscription = void 0, this._distanceDisplayCondition = void 0, this._distanceDisplayConditionSubscription = void 0, this.merge(y(e, y.EMPTY_OBJECT)) } Object.defineProperties(Jb.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, show: ae("show"), positions: ae("positions"), minimumHeights: ae("minimumHeights"), maximumHeights: ae("maximumHeights"), granularity: ae("granularity"), fill: ae("fill"), material: wo("material"), outline: ae("outline"), outlineColor: ae("outlineColor"), outlineWidth: ae("outlineWidth"), shadows: ae("shadows"), distanceDisplayCondition: ae("distanceDisplayCondition") }); Jb.prototype.clone = function (e) { return l(e) ? (e.show = this.show, e.positions = this.positions, e.minimumHeights = this.minimumHeights, e.maximumHeights = this.maximumHeights, e.granularity = this.granularity, e.fill = this.fill, e.material = this.material, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.shadows = this.shadows, e.distanceDisplayCondition = this.distanceDisplayCondition, e) : new Jb(this) }; Jb.prototype.merge = function (e) { this.show = y(this.show, e.show), this.positions = y(this.positions, e.positions), this.minimumHeights = y(this.minimumHeights, e.minimumHeights), this.maximumHeights = y(this.maximumHeights, e.maximumHeights), this.granularity = y(this.granularity, e.granularity), this.fill = y(this.fill, e.fill), this.material = y(this.material, e.material), this.outline = y(this.outline, e.outline), this.outlineColor = y(this.outlineColor, e.outlineColor), this.outlineWidth = y(this.outlineWidth, e.outlineWidth), this.shadows = y(this.shadows, e.shadows), this.distanceDisplayCondition = y(this.distanceDisplayCondition, e.distanceDisplayCondition) }; var Gp = Jb; var pve = new he; function _ve(e) { return new Mc(e) } function gve(e) { return ae(e, void 0, _ve) } function Cs(e, t) { return ae(e, void 0, function (n) { return n instanceof t ? n : new t(n) }) } function Fd(e) { e = y(e, y.EMPTY_OBJECT); let t = e.id; l(t) || (t = Nn()), this._availability = void 0, this._id = t, this._definitionChanged = new _e, this._name = e.name, this._show = y(e.show, !0), this._parent = void 0, this._propertyNames = ["billboard", "box", "corridor", "cylinder", "description", "ellipse", "ellipsoid", "label", "model", "tileset", "orientation", "path", "plane", "point", "polygon", "polyline", "polylineVolume", "position", "properties", "rectangle", "viewFrom", "wall"], this._billboard = void 0, this._billboardSubscription = void 0, this._box = void 0, this._boxSubscription = void 0, this._corridor = void 0, this._corridorSubscription = void 0, this._cylinder = void 0, this._cylinderSubscription = void 0, this._description = void 0, this._descriptionSubscription = void 0, this._ellipse = void 0, this._ellipseSubscription = void 0, this._ellipsoid = void 0, this._ellipsoidSubscription = void 0, this._label = void 0, this._labelSubscription = void 0, this._model = void 0, this._modelSubscription = void 0, this._tileset = void 0, this._tilesetSubscription = void 0, this._orientation = void 0, this._orientationSubscription = void 0, this._path = void 0, this._pathSubscription = void 0, this._plane = void 0, this._planeSubscription = void 0, this._point = void 0, this._pointSubscription = void 0, this._polygon = void 0, this._polygonSubscription = void 0, this._polyline = void 0, this._polylineSubscription = void 0, this._polylineVolume = void 0, this._polylineVolumeSubscription = void 0, this._position = void 0, this._positionSubscription = void 0, this._properties = void 0, this._propertiesSubscription = void 0, this._rectangle = void 0, this._rectangleSubscription = void 0, this._viewFrom = void 0, this._viewFromSubscription = void 0, this._wall = void 0, this._wallSubscription = void 0, this._children = [], this.entityCollection = void 0, this.parent = e.parent, this.merge(e) } function BG(e, t, n) { let i = t.length; for (let o = 0; o < i; o++) { let r = t[o], s = r._show; (!n && s) !== (n && s) && BG(r, r._children, n) } e._definitionChanged.raiseEvent(e, "isShowing", n, !n) } Object.defineProperties(Fd.prototype, { availability: dl("availability"), id: { get: function () { return this._id } }, definitionChanged: { get: function () { return this._definitionChanged } }, name: dl("name"), show: { get: function () { return this._show }, set: function (e) { if (e === this._show) return; let t = this.isShowing; this._show = e; let n = this.isShowing; t !== n && BG(this, this._children, n), this._definitionChanged.raiseEvent(this, "show", e, !e) } }, isShowing: { get: function () { return this._show && (!l(this.entityCollection) || this.entityCollection.show) && (!l(this._parent) || this._parent.isShowing) } }, parent: { get: function () { return this._parent }, set: function (e) { let t = this._parent; if (t === e) return; let n = this.isShowing; if (l(t)) { let o = t._children.indexOf(this); t._children.splice(o, 1) } this._parent = e, l(e) && e._children.push(this); let i = this.isShowing; n !== i && BG(this, this._children, i), this._definitionChanged.raiseEvent(this, "parent", e, t) } }, propertyNames: { get: function () { return this._propertyNames } }, billboard: Cs("billboard", ja), box: Cs("box", bC), corridor: Cs("corridor", wC), cylinder: Cs("cylinder", DC), description: ae("description"), ellipse: Cs("ellipse", vC), ellipsoid: Cs("ellipsoid", PC), label: Cs("label", Rd), model: Cs("model", zp), tileset: Cs("tileset", OC), orientation: ae("orientation"), path: Cs("path", Hp), plane: Cs("plane", EB), point: Cs("point", BC), polygon: Cs("polygon", Md), polyline: Cs("polyline", ec), polylineVolume: Cs("polylineVolume", RC), properties: Cs("properties", hl), position: gve("position"), rectangle: Cs("rectangle", Ld), viewFrom: ae("viewFrom"), wall: Cs("wall", Gp) }); Fd.prototype.isAvailable = function (e) { let t = this._availability; return !l(t) || t.contains(e) }; Fd.prototype.addProperty = function (e) { this._propertyNames.push(e), Object.defineProperty(this, e, dl(e, !0)) }; Fd.prototype.removeProperty = function (e) { let n = this._propertyNames.indexOf(e); this._propertyNames.splice(n, 1), delete this[e] }; Fd.prototype.merge = function (e) { this.name = y(this.name, e.name), this.availability = y(this.availability, e.availability); let t = this._propertyNames, n = l(e._propertyNames) ? e._propertyNames : Object.keys(e), i = n.length; for (let o = 0; o < i; o++) { let r = n[o]; if (r === "parent" || r === "name" || r === "availability") continue; let s = this[r], a = e[r]; !l(s) && t.indexOf(r) === -1 && this.addProperty(r), l(a) && (l(s) ? l(s.merge) && s.merge(a) : l(a.merge) && l(a.clone) ? this[r] = a.clone() : this[r] = a) } }; var MZ = new Q, LZ = new h, FZ = new Be; Fd.prototype.computeModelMatrix = function (e, t) { let n = j.getValueOrUndefined(this._position, e, LZ); if (!l(n)) return; let i = j.getValueOrUndefined(this._orientation, e, FZ); return l(i) ? t = F.fromRotationTranslation(Q.fromQuaternion(i, MZ), n, t) : t = It.eastNorthUpToFixedFrame(n, void 0, t), t }; Fd.prototype.computeModelMatrixForHeightReference = function (e, t, n, i, o) { let r = j.getValueOrDefault(t, e, ze.NONE), s = j.getValueOrUndefined(this._position, e, LZ); if (r === ze.NONE || !l(s) || h.equalsEpsilon(s, h.ZERO, I.EPSILON8)) return this.computeModelMatrix(e, o); let a = i.cartesianToCartographic(s, pve); r === ze.CLAMP_TO_GROUND ? a.height = n : a.height += n, s = i.cartographicToCartesian(a, s); let c = j.getValueOrUndefined(this._orientation, e, FZ); return l(c) ? o = F.fromRotationTranslation(Q.fromQuaternion(c, MZ), s, o) : o = It.eastNorthUpToFixedFrame(s, void 0, o), o }; Fd.supportsMaterialsforEntitiesOnTerrain = function (e) { return Rc.supportsMaterials(e) }; Fd.supportsPolylinesOnTerrain = function (e) { return Bd.isSupported(e) }; var Xo = Fd; var yve = new Ot(U.WHITE), Ave = new Yn(!0), Cve = new Yn(!0), xve = new Yn(!1), Tve = new Yn(U.BLACK), Eve = new Yn(hn.DISABLED), bve = new Yn(new bt), Sve = new Yn(Ln.BOTH); function tc(e) { let t = e.entity, n = e.geometryPropertyName; this._entity = t, this._scene = e.scene, this._fillEnabled = !1, this._isClosed = !1, this._onTerrain = !1, this._dynamic = !1, this._outlineEnabled = !1, this._geometryChanged = new _e, this._showProperty = void 0, this._materialProperty = void 0, this._showOutlineProperty = void 0, this._outlineColorProperty = void 0, this._outlineWidth = 1, this._shadowsProperty = void 0, this._distanceDisplayConditionProperty = void 0, this._classificationTypeProperty = void 0, this._options = e.geometryOptions, this._geometryPropertyName = n, this._id = `${n}-${t.id}`, this._observedPropertyNames = e.observedPropertyNames, this._supportsMaterialsforEntitiesOnTerrain = Xo.supportsMaterialsforEntitiesOnTerrain(e.scene) } Object.defineProperties(tc.prototype, { id: { get: function () { return this._id } }, entity: { get: function () { return this._entity } }, fillEnabled: { get: function () { return this._fillEnabled } }, hasConstantFill: { get: function () { return !this._fillEnabled || !l(this._entity.availability) && j.isConstant(this._showProperty) && j.isConstant(this._fillProperty) } }, fillMaterialProperty: { get: function () { return this._materialProperty } }, outlineEnabled: { get: function () { return this._outlineEnabled } }, hasConstantOutline: { get: function () { return !this._outlineEnabled || !l(this._entity.availability) && j.isConstant(this._showProperty) && j.isConstant(this._showOutlineProperty) } }, outlineColorProperty: { get: function () { return this._outlineColorProperty } }, outlineWidth: { get: function () { return this._outlineWidth } }, shadowsProperty: { get: function () { return this._shadowsProperty } }, distanceDisplayConditionProperty: { get: function () { return this._distanceDisplayConditionProperty } }, classificationTypeProperty: { get: function () { return this._classificationTypeProperty } }, isDynamic: { get: function () { return this._dynamic } }, isClosed: { get: function () { return this._isClosed } }, onTerrain: { get: function () { return this._onTerrain } }, geometryChanged: { get: function () { return this._geometryChanged } } }); tc.prototype.isOutlineVisible = function (e) { let t = this._entity, n = this._outlineEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e); return y(n, !1) }; tc.prototype.isFilled = function (e) { let t = this._entity, n = this._fillEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._fillProperty.getValue(e); return y(n, !1) }; tc.prototype.createFillGeometryInstance = ye.throwInstantiationError; tc.prototype.createOutlineGeometryInstance = ye.throwInstantiationError; tc.prototype.isDestroyed = function () { return !1 }; tc.prototype.destroy = function () { le(this) }; tc.prototype._isHidden = function (e, t) { let n = t.show; return l(n) && n.isConstant && !n.getValue(ke.MINIMUM_VALUE) }; tc.prototype._isOnTerrain = function (e, t) { return !1 }; tc.prototype._getIsClosed = function (e) { return !0 }; tc.prototype._isDynamic = ye.throwInstantiationError; tc.prototype._setStaticOptions = ye.throwInstantiationError; tc.prototype._onEntityPropertyChanged = function (e, t, n, i) { if (this._observedPropertyNames.indexOf(t) === -1) return; let o = this._entity[this._geometryPropertyName]; if (!l(o)) { (this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)); return } let r = o.fill, s = l(r) && r.isConstant ? r.getValue(ke.MINIMUM_VALUE) : !0, a = o.outline, c = l(a); if (c && a.isConstant && (c = a.getValue(ke.MINIMUM_VALUE)), !s && !c) { (this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)); return } let u = o.show; if (this._isHidden(e, o)) { (this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)); return } this._materialProperty = y(o.material, yve), this._fillProperty = y(r, Cve), this._showProperty = y(u, Ave), this._showOutlineProperty = y(o.outline, xve), this._outlineColorProperty = c ? y(o.outlineColor, Tve) : void 0, this._shadowsProperty = y(o.shadows, Eve), this._distanceDisplayConditionProperty = y(o.distanceDisplayCondition, bve), this._classificationTypeProperty = y(o.classificationType, Sve), this._fillEnabled = s; let f = this._isOnTerrain(e, o) && (this._supportsMaterialsforEntitiesOnTerrain || this._materialProperty instanceof Ot); if (c && f && (Pt(Pt.geometryOutlines), c = !1), this._onTerrain = f, this._outlineEnabled = c, this._isDynamic(e, o)) this._dynamic || (this._dynamic = !0, this._geometryChanged.raiseEvent(this)); else { this._setStaticOptions(e, o), this._isClosed = this._getIsClosed(this._options); let d = o.outlineWidth; this._outlineWidth = l(d) ? d.getValue(ke.MINIMUM_VALUE) : 1, this._dynamic = !1, this._geometryChanged.raiseEvent(this) } }; tc.prototype.createDynamicUpdater = function (e, t) { return new this.constructor.DynamicGeometryUpdater(this, e, t) }; var ei = tc; function MC(e, t) { this._callback = void 0, this._isConstant = void 0, this._definitionChanged = new _e, this.setCallback(e, t) } Object.defineProperties(MC.prototype, { isConstant: { get: function () { return this._isConstant } }, definitionChanged: { get: function () { return this._definitionChanged } } }); MC.prototype.getValue = function (e, t) { return this._callback(e, t) }; MC.prototype.setCallback = function (e, t) { let n = this._callback !== e || this._isConstant !== t; this._callback = e, this._isConstant = t, n && this._definitionChanged.raiseEvent(this) }; MC.prototype.equals = function (e) { return this === e || e instanceof MC && this._callback === e._callback && this._isConstant === e._isConstant }; var Nd = MC; var NZ = new h, wve = new he; function LC(e, t, n, i) { this._scene = e, this._heightReference = n, this._extrudedHeightReference = i, this._positionProperty = t, this._position = new h, this._cartographicPosition = new he, this._normal = new h, this._definitionChanged = new _e, this._terrainHeight = 0, this._removeCallbackFunc = void 0, this._removeEventListener = void 0, this._removeModeListener = void 0; let o = this; if (l(e.globe) && (this._removeEventListener = e.terrainProviderChanged.addEventListener(function () { o._updateClamping() }), this._removeModeListener = e.morphComplete.addEventListener(function () { o._updateClamping() })), t.isConstant) { let r = t.getValue(ke.MINIMUM_VALUE, NZ); if (!l(r) || h.equals(r, h.ZERO) || !l(e.globe)) return; this._position = h.clone(r, this._position), this._updateClamping(), this._normal = e.globe.ellipsoid.geodeticSurfaceNormal(r, this._normal) } } Object.defineProperties(LC.prototype, { isConstant: { get: function () { return !1 } }, definitionChanged: { get: function () { return this._definitionChanged } } }); LC.prototype._updateClamping = function () { l(this._removeCallbackFunc) && this._removeCallbackFunc(); let e = this._scene, t = e.globe, n = this._position; if (!l(t) || h.equals(n, h.ZERO)) { this._terrainHeight = 0; return } let i = t.ellipsoid, o = t._surface, r = this, s = i.cartesianToCartographic(n, this._cartographicPosition), a = t.getHeight(s); l(a) ? this._terrainHeight = a : this._terrainHeight = 0; function c(u) { if (e.mode === ee.SCENE3D) { let f = i.cartesianToCartographic(u, wve); r._terrainHeight = f.height } else r._terrainHeight = u.x; r.definitionChanged.raiseEvent() } this._removeCallbackFunc = o.updateHeight(s, c) }; LC.prototype.getValue = function (e, t) { let n = j.getValueOrDefault(this._heightReference, e, ze.NONE), i = j.getValueOrDefault(this._extrudedHeightReference, e, ze.NONE); if (n === ze.NONE && i !== ze.RELATIVE_TO_GROUND) return this._position = h.clone(h.ZERO, this._position), h.clone(h.ZERO, t); if (this._positionProperty.isConstant) return h.multiplyByScalar(this._normal, this._terrainHeight, t); let o = this._scene, r = this._positionProperty.getValue(e, NZ); if (!l(r) || h.equals(r, h.ZERO) || !l(o.globe)) return h.clone(h.ZERO, t); if (h.equalsEpsilon(this._position, r, I.EPSILON10)) return h.multiplyByScalar(this._normal, this._terrainHeight, t); this._position = h.clone(r, this._position), this._updateClamping(); let s = o.globe.ellipsoid.geodeticSurfaceNormal(r, this._normal); return h.multiplyByScalar(s, this._terrainHeight, t) }; LC.prototype.isDestroyed = function () { return !1 }; LC.prototype.destroy = function () { return l(this._removeEventListener) && this._removeEventListener(), l(this._removeModeListener) && this._removeModeListener(), l(this._removeCallbackFunc) && this._removeCallbackFunc(), le(this) }; var FC = LC; function Dve(e, t, n, i) { if (ei.prototype._onEntityPropertyChanged.call(this, e, t, n, i), this._observedPropertyNames.indexOf(t) === -1) return; let o = this._entity[this._geometryPropertyName]; if (!l(o)) return; l(this._terrainOffsetProperty) && (this._terrainOffsetProperty.destroy(), this._terrainOffsetProperty = void 0); let r = o.heightReference; if (l(r)) { let s = new Nd(this._computeCenter.bind(this), !this._dynamic); this._terrainOffsetProperty = new FC(this._scene, s, r) } } var Wp = Dve; var VZ = h.ZERO, kZ = new h, vve = new h, UZ = new U; function Pve(e) { this.id = e, this.vertexFormat = void 0, this.dimensions = void 0, this.offsetAttribute = void 0 } function ml(e, t) { ei.call(this, { entity: e, scene: t, geometryOptions: new Pve(e), geometryPropertyName: "box", observedPropertyNames: ["availability", "position", "orientation", "box"] }), this._onEntityPropertyChanged(e, "box", e.box, void 0) } l(Object.create) && (ml.prototype = Object.create(ei.prototype), ml.prototype.constructor = ml); Object.defineProperties(ml.prototype, { terrainOffsetProperty: { get: function () { return this._terrainOffsetProperty } } }); ml.prototype.createFillGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = new fn(n && t.isShowing && this._showProperty.getValue(e) && this._fillProperty.getValue(e)), o = this._distanceDisplayConditionProperty.getValue(e), r = Mn.fromDistanceDisplayCondition(o), s = { show: i, distanceDisplayCondition: r, color: void 0, offset: void 0 }; if (this._materialProperty instanceof Ot) { let a; l(this._materialProperty.color) && (this._materialProperty.color.isConstant || n) && (a = this._materialProperty.color.getValue(e, UZ)), l(a) || (a = U.WHITE), s.color = Bt.fromColor(a) } return l(this._options.offsetAttribute) && (s.offset = zi.fromCartesian3(j.getValueOrDefault(this._terrainOffsetProperty, e, VZ, kZ))), new At({ id: t, geometry: ll.fromDimensions(this._options), modelMatrix: t.computeModelMatrixForHeightReference(e, t.box.heightReference, this._options.dimensions.z * .5, this._scene.mapProjection.ellipsoid), attributes: s }) }; ml.prototype.createOutlineGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = j.getValueOrDefault(this._outlineColorProperty, e, U.BLACK, UZ), o = this._distanceDisplayConditionProperty.getValue(e), r = { show: new fn(n && t.isShowing && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)), color: Bt.fromColor(i), distanceDisplayCondition: Mn.fromDistanceDisplayCondition(o), offset: void 0 }; return l(this._options.offsetAttribute) && (r.offset = zi.fromCartesian3(j.getValueOrDefault(this._terrainOffsetProperty, e, VZ, kZ))), new At({ id: t, geometry: bd.fromDimensions(this._options), modelMatrix: t.computeModelMatrixForHeightReference(e, t.box.heightReference, this._options.dimensions.z * .5, this._scene.mapProjection.ellipsoid), attributes: r }) }; ml.prototype._computeCenter = function (e, t) { return j.getValueOrUndefined(this._entity.position, e, t) }; ml.prototype._isHidden = function (e, t) { return !l(t.dimensions) || !l(e.position) || ei.prototype._isHidden.call(this, e, t) }; ml.prototype._isDynamic = function (e, t) { return !e.position.isConstant || !j.isConstant(e.orientation) || !t.dimensions.isConstant || !j.isConstant(t.outlineWidth) }; ml.prototype._setStaticOptions = function (e, t) { let n = j.getValueOrDefault(t.heightReference, ke.MINIMUM_VALUE, ze.NONE), i = this._options; i.vertexFormat = this._materialProperty instanceof Ot ? $t.VERTEX_FORMAT : eo.MaterialSupport.TEXTURED.vertexFormat, i.dimensions = t.dimensions.getValue(ke.MINIMUM_VALUE, i.dimensions), i.offsetAttribute = n !== ze.NONE ? Qt.ALL : void 0 }; ml.prototype._onEntityPropertyChanged = Wp; ml.DynamicGeometryUpdater = NC; function NC(e, t, n) { $n.call(this, e, t, n) } l(Object.create) && (NC.prototype = Object.create($n.prototype), NC.prototype.constructor = NC); NC.prototype._isHidden = function (e, t, n) { let i = j.getValueOrUndefined(e.position, n, vve), o = this._options.dimensions; return !l(i) || !l(o) || $n.prototype._isHidden.call(this, e, t, n) }; NC.prototype._setOptions = function (e, t, n) { let i = j.getValueOrDefault(t.heightReference, n, ze.NONE), o = this._options; o.dimensions = j.getValueOrUndefined(t.dimensions, n, o.dimensions), o.offsetAttribute = i !== ze.NONE ? Qt.ALL : void 0 }; var bB = ml; var HZ = po(zZ(), 1); var Ive = 0, LG = {}; function um(e, t) { let n, i = e; l(LG[i]) ? n = LG[i] : (n = Ive++, LG[i] = n), t = y(t, !1), this._id = n, this._html = e, this._showOnScreen = t, this._element = void 0 } Object.defineProperties(um.prototype, { html: { get: function () { return this._html } }, id: { get: function () { return this._id } }, showOnScreen: { get: function () { return this._showOnScreen }, set: function (e) { this._showOnScreen = e } }, element: { get: function () { if (!l(this._element)) { let e = HZ.default.sanitize(this._html), t = document.createElement("div"); t._creditId = this._id, t.style.display = "inline", t.innerHTML = e; let n = t.querySelectorAll("a"); for (let i = 0; i < n.length; i++)n[i].setAttribute("target", "_blank"); this._element = t } return this._element } } }); um.equals = function (e, t) { return e === t || l(e) && l(t) && e._id === t._id && e._showOnScreen === t._showOnScreen }; um.prototype.equals = function (e) { return um.equals(this, e) }; um.getIonCredit = function (e) { let t = l(e.collapsible) && !e.collapsible, n = new um(e.html, t); return n._isIon = n.html.indexOf("ion-credit.png") !== -1, n }; um.clone = function (e) { if (l(e)) return new um(e.html, e.showOnScreen) }; var Xt = um; function Ove(e, t) { Pt(e, t) } var Jr = Ove; function GZ(e) { e = y(e, y.EMPTY_OBJECT), this.vertexArray = e.vertexArray, this.fragmentShaderSource = e.fragmentShaderSource, this.shaderProgram = e.shaderProgram, this.uniformMap = e.uniformMap, this.outputTexture = e.outputTexture, this.preExecute = e.preExecute, this.postExecute = e.postExecute, this.canceled = e.canceled, this.persists = y(e.persists, !1), this.pass = xe.COMPUTE, this.owner = e.owner } GZ.prototype.execute = function (e) { e.execute(this) }; var pf = GZ; var SB = `varying vec2 v_textureCoordinates;
uniform float originalSize;
uniform sampler2D texture0;
uniform sampler2D texture1;
uniform sampler2D texture2;
uniform sampler2D texture3;
uniform sampler2D texture4;
uniform sampler2D texture5;
const float yMipLevel1 = 1.0 - (1.0 / pow(2.0, 1.0));
const float yMipLevel2 = 1.0 - (1.0 / pow(2.0, 2.0));
const float yMipLevel3 = 1.0 - (1.0 / pow(2.0, 3.0));
const float yMipLevel4 = 1.0 - (1.0 / pow(2.0, 4.0));
void main()
{
vec2 uv = v_textureCoordinates;
vec2 textureSize = vec2(originalSize * 1.5 + 2.0, originalSize);
vec2 pixel = 1.0 / textureSize;
float mipLevel = 0.0;
if (uv.x - pixel.x > (textureSize.y / textureSize.x))
{
mipLevel = 1.0;
if (uv.y - pixel.y > yMipLevel1)
{
mipLevel = 2.0;
if (uv.y - pixel.y * 3.0 > yMipLevel2)
{
mipLevel = 3.0;
if (uv.y - pixel.y * 5.0 > yMipLevel3)
{
mipLevel = 4.0;
if (uv.y - pixel.y * 7.0 > yMipLevel4)
{
mipLevel = 5.0;
}
}
}
}
}
if (mipLevel > 0.0)
{
float scale = pow(2.0, mipLevel);
uv.y -= (pixel.y * (mipLevel - 1.0) * 2.0);
uv.x *= ((textureSize.x - 2.0) / textureSize.y);
uv.x -= 1.0 + pixel.x;
uv.y -= (1.0 - (1.0 / pow(2.0, mipLevel - 1.0)));
uv *= scale;
}
else
{
uv.x *= (textureSize.x / textureSize.y);
}
if(mipLevel == 0.0)
{
gl_FragColor = texture2D(texture0, uv);
}
else if(mipLevel == 1.0)
{
gl_FragColor = texture2D(texture1, uv);
}
else if(mipLevel == 2.0)
{
gl_FragColor = texture2D(texture2, uv);
}
else if(mipLevel == 3.0)
{
gl_FragColor = texture2D(texture3, uv);
}
else if(mipLevel == 4.0)
{
gl_FragColor = texture2D(texture4, uv);
}
else if(mipLevel == 5.0)
{
gl_FragColor = texture2D(texture5, uv);
}
else
{
gl_FragColor = vec4(0.0);
}
}
`; var wB = `varying vec3 v_cubeMapCoordinates;
uniform samplerCube cubeMap;
void main()
{
vec4 rgba = textureCube(cubeMap, v_cubeMapCoordinates);
#ifdef RGBA_NORMALIZED
gl_FragColor = vec4(rgba.rgb, 1.0);
#else
float m = rgba.a * 16.0;
vec3 r = rgba.rgb * m;
gl_FragColor = vec4(r * r, 1.0);
#endif
}
`; var DB = `attribute vec4 position;
attribute vec3 cubeMapCoordinates;
varying vec3 v_cubeMapCoordinates;
void main()
{
gl_Position = position;
v_cubeMapCoordinates = cubeMapCoordinates;
}
`; function v0(e) { this._url = e, this._cubeMapBuffers = void 0, this._cubeMaps = void 0, this._texture = void 0, this._mipTextures = void 0, this._va = void 0, this._sp = void 0, this._maximumMipmapLevel = void 0, this._loading = !1, this._ready = !1; let t = this; this._readyPromise = new Promise((n, i) => { t._completeLoadFromCache = o => { FG(this), this._texture = o, this._maximumMipmapLevel = this._texture.maximumMipmapLevel, this._ready = !0, n() }, t._failLoad = o => { i(o) }, t._completeLoad = () => { this._ready = !0, n() } }) } Object.defineProperties(v0.prototype, { url: { get: function () { return this._url } }, texture: { get: function () { return this._texture } }, maximumMipmapLevel: { get: function () { return this._maximumMipmapLevel } }, ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } } }); v0.isSupported = function (e) { return e.colorBufferHalfFloat && e.halfFloatingPointTexture || e.floatingPointTexture && e.colorBufferFloat }; var Bve = new h(1, 0, 0), Rve = new h(0, 0, 1), Mve = new h(-1, 0, 0), Lve = new h(0, 0, -1), vB = new h(0, 1, 0), Fve = new h(0, -1, 0), qZ = [vB, Mve, Rve, Fve, Bve, vB, Lve, vB, vB], YZ = qZ.length, XZ = new Float32Array(YZ * 3), WZ = 0; for (let e = 0; e < YZ; ++e, WZ += 3)h.pack(qZ[e], XZ, WZ); var Nve = new Float32Array([-1, 1, -1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, -1, -1, -1, 1, -1]), Vve = new Uint16Array([0, 1, 2, 2, 3, 1, 7, 6, 1, 3, 6, 1, 2, 5, 4, 3, 4, 2, 4, 8, 6, 3, 4, 6]); function kve(e) { let t = ct.createVertexBuffer({ context: e, typedArray: Nve, usage: Re.STATIC_DRAW }), n = ct.createVertexBuffer({ context: e, typedArray: XZ, usage: Re.STATIC_DRAW }), i = ct.createIndexBuffer({ context: e, typedArray: Vve, usage: Re.STATIC_DRAW, indexDatatype: Me.UNSIGNED_SHORT }), o = [{ index: 0, vertexBuffer: t, componentsPerAttribute: 2, componentDatatype: Y.FLOAT }, { index: 1, vertexBuffer: n, componentsPerAttribute: 3, componentDatatype: Y.FLOAT }]; return new Qn({ context: e, attributes: o, indexBuffer: i }) } function jZ(e) { return function () { return e } } function FG(e) { e._va = e._va && e._va.destroy(), e._sp = e._sp && e._sp.destroy(); let t, n, i = e._cubeMaps; if (l(i)) for (n = i.length, t = 0; t < n; ++t)i[t].destroy(); let o = e._mipTextures; if (l(o)) for (n = o.length, t = 0; t < n; ++t)o[t].destroy(); e._va = void 0, e._sp = void 0, e._cubeMaps = void 0, e._cubeMapBuffers = void 0, e._mipTextures = void 0 } v0.prototype.update = function (e) { let t = e.context; if (!v0.isSupported(t) || (l(this._texture) && l(this._va) && FG(this), l(this._texture))) return; if (!l(this._texture) && !this._loading) { let g = e.context.textureCache.getTexture(this._url); l(g) && this._completeLoadFromCache(g) } let n = this._cubeMapBuffers; if (!l(n) && !this._loading) { let g = this; ul(this._url).then(function (m) { g._cubeMapBuffers = m, g._loading = !1 }).catch(function (m) { g._failLoad(m) }), this._loading = !0 } if (!l(this._cubeMapBuffers)) return; let i = [], o = n[0].positiveX.pixelDatatype; l(o) ? i.push("RGBA_NORMALIZED") : o = t.halfFloatingPointTexture ? Ye.HALF_FLOAT : Ye.FLOAT; let r = ht.RGBA, s = new Ue({ defines: i, sources: [wB] }); this._va = kve(t), this._sp = qt.fromCache({ context: t, vertexShaderSource: DB, fragmentShaderSource: s, attributeLocations: { position: 0, cubeMapCoordinates: 1 } }); let a = Math.min(n.length, 6); this._maximumMipmapLevel = a - 1; let c = this._cubeMaps = new Array(a), u = this._mipTextures = new Array(a), f = n[0].positiveX.width * 2, d = { originalSize: function () { return f } }; for (let g = 0; g < a; ++g) { let m = n[g].positiveY; n[g].positiveY = n[g].negativeY, n[g].negativeY = m; let A = c[g] = new Xa({ context: t, source: n[g], pixelDatatype: o }), C = c[g].width * 2, x = u[g] = new Rt({ context: t, width: C, height: C, pixelDatatype: o, pixelFormat: r }), T = new pf({ vertexArray: this._va, shaderProgram: this._sp, uniformMap: { cubeMap: jZ(A) }, outputTexture: x, persists: !0, owner: this }); e.commandList.push(T), d[`texture${g}`] = jZ(x) } this._texture = new Rt({ context: t, width: f * 1.5 + 2, height: f, pixelDatatype: o, pixelFormat: r }), this._texture.maximumMipmapLevel = this._maximumMipmapLevel, t.textureCache.addTexture(this._url, this._texture); let p = new pf({ fragmentShaderSource: SB, uniformMap: d, outputTexture: this._texture, persists: !1, owner: this }); e.commandList.push(p), this._completeLoad() }; v0.prototype.isDestroyed = function () { return !1 }; v0.prototype.destroy = function () { return FG(this), this._texture = this._texture && this._texture.destroy(), le(this) }; var Vd = v0; function Zb(e) { e = y(e, y.EMPTY_OBJECT); let t = l(e.imageBasedLightingFactor) ? H.clone(e.imageBasedLightingFactor) : new H(1, 1); this._imageBasedLightingFactor = t; let n = y(e.luminanceAtZenith, .2); this._luminanceAtZenith = n; let i = e.sphericalHarmonicCoefficients; this._sphericalHarmonicCoefficients = i, this._specularEnvironmentMaps = e.specularEnvironmentMaps, this._specularEnvironmentMapAtlas = void 0, this._specularEnvironmentMapAtlasDirty = !0, this._specularEnvironmentMapLoaded = !1, this._previousSpecularEnvironmentMapLoaded = !1, this._useDefaultSpecularMaps = !1, this._useDefaultSphericalHarmonics = !1, this._shouldRegenerateShaders = !1, this._previousFrameNumber = void 0, this._previousImageBasedLightingFactor = H.clone(t), this._previousLuminanceAtZenith = n, this._previousSphericalHarmonicCoefficients = i } Object.defineProperties(Zb.prototype, { imageBasedLightingFactor: { get: function () { return this._imageBasedLightingFactor }, set: function (e) { this._previousImageBasedLightingFactor = H.clone(this._imageBasedLightingFactor, this._previousImageBasedLightingFactor), this._imageBasedLightingFactor = H.clone(e, this._imageBasedLightingFactor) } }, luminanceAtZenith: { get: function () { return this._luminanceAtZenith }, set: function (e) { this._previousLuminanceAtZenith = this._luminanceAtZenith, this._luminanceAtZenith = e } }, sphericalHarmonicCoefficients: { get: function () { return this._sphericalHarmonicCoefficients }, set: function (e) { this._previousSphericalHarmonicCoefficients = this._sphericalHarmonicCoefficients, this._sphericalHarmonicCoefficients = e } }, specularEnvironmentMaps: { get: function () { return this._specularEnvironmentMaps }, set: function (e) { e !== this._specularEnvironmentMaps && (this._specularEnvironmentMapAtlasDirty = this._specularEnvironmentMapAtlasDirty || e !== this._specularEnvironmentMaps, this._specularEnvironmentMapLoaded = !1), this._specularEnvironmentMaps = e } }, enabled: { get: function () { return this._imageBasedLightingFactor.x > 0 || this._imageBasedLightingFactor.y > 0 } }, shouldRegenerateShaders: { get: function () { return this._shouldRegenerateShaders } }, useDefaultSphericalHarmonics: { get: function () { return this._useDefaultSphericalHarmonics } }, useSphericalHarmonicCoefficients: { get: function () { return l(this._sphericalHarmonicCoefficients) || this._useDefaultSphericalHarmonics } }, specularEnvironmentMapAtlas: { get: function () { return this._specularEnvironmentMapAtlas } }, useDefaultSpecularMaps: { get: function () { return this._useDefaultSpecularMaps } }, useSpecularEnvironmentMaps: { get: function () { return l(this._specularEnvironmentMapAtlas) && this._specularEnvironmentMapAtlas.ready || this._useDefaultSpecularMaps } } }); function Uve(e, t) { if (!!Vd.isSupported(t)) { if (e._specularEnvironmentMapAtlas = e._specularEnvironmentMapAtlas && e._specularEnvironmentMapAtlas.destroy(), l(e._specularEnvironmentMaps)) { let n = new Vd(e._specularEnvironmentMaps); e._specularEnvironmentMapAtlas = n, n.readyPromise.then(function () { e._specularEnvironmentMapLoaded = !0 }).catch(function (i) { console.error(`Error loading specularEnvironmentMaps: ${i}`) }) } e._shouldRegenerateShaders = !0 } } Zb.prototype.update = function (e) { if (e.frameNumber === this._previousFrameNumber) return; this._previousFrameNumber = e.frameNumber; let t = e.context; e.brdfLutGenerator.update(e), this._shouldRegenerateShaders = !1; let n = this._imageBasedLightingFactor, i = this._previousImageBasedLightingFactor; H.equals(n, i) || (this._shouldRegenerateShaders = n.x > 0 && i.x === 0 || n.x === 0 && i.x > 0, this._shouldRegenerateShaders = this._shouldRegenerateShaders || n.y > 0 && i.y === 0 || n.y === 0 && i.y > 0, this._previousImageBasedLightingFactor = H.clone(this._imageBasedLightingFactor, this._previousImageBasedLightingFactor)), this._luminanceAtZenith !== this._previousLuminanceAtZenith && (this._shouldRegenerateShaders = this._shouldRegenerateShaders || l(this._luminanceAtZenith) !== l(this._previousLuminanceAtZenith), this._previousLuminanceAtZenith = this._luminanceAtZenith), this._previousSphericalHarmonicCoefficients !== this._sphericalHarmonicCoefficients && (this._shouldRegenerateShaders = this._shouldRegenerateShaders || l(this._previousSphericalHarmonicCoefficients) !== l(this._sphericalHarmonicCoefficients), this._previousSphericalHarmonicCoefficients = this._sphericalHarmonicCoefficients), this._shouldRegenerateShaders = this._shouldRegenerateShaders || this._previousSpecularEnvironmentMapLoaded !== this._specularEnvironmentMapLoaded, this._previousSpecularEnvironmentMapLoaded = this._specularEnvironmentMapLoaded, this._specularEnvironmentMapAtlasDirty && (Uve(this, t), this._specularEnvironmentMapAtlasDirty = !1), l(this._specularEnvironmentMapAtlas) && this._specularEnvironmentMapAtlas.update(e); let o = !l(this._specularEnvironmentMapAtlas) && l(e.specularEnvironmentMaps) && !this._useDefaultSpecularMaps, r = !l(e.specularEnvironmentMaps) && this._useDefaultSpecularMaps, s = !l(this._sphericalHarmonicCoefficients) && l(e.sphericalHarmonicCoefficients) && !this._useDefaultSphericalHarmonics, a = !l(e.sphericalHarmonicCoefficients) && this._useDefaultSphericalHarmonics; this._shouldRegenerateShaders = this._shouldRegenerateShaders || o || r || s || a, this._useDefaultSpecularMaps = !l(this._specularEnvironmentMapAtlas) && l(e.specularEnvironmentMaps), this._useDefaultSphericalHarmonics = !l(this._sphericalHarmonicCoefficients) && l(e.sphericalHarmonicCoefficients) }; Zb.prototype.isDestroyed = function () { return !1 }; Zb.prototype.destroy = function () { return this._specularEnvironmentMapAtlas = this._specularEnvironmentMapAtlas && this._specularEnvironmentMapAtlas.destroy(), le(this) }; var VC = Zb; function kd(e) { e = y(e, 0), this._array = new Array(e), this._length = e } Object.defineProperties(kd.prototype, { length: { get: function () { return this._length }, set: function (e) { let t = this._array, n = this._length; if (e < n) for (let i = e; i < n; ++i)t[i] = void 0; else e > t.length && (t.length = e); this._length = e } }, values: { get: function () { return this._array } } }); kd.prototype.get = function (e) { return this._array[e] }; kd.prototype.set = function (e, t) { e >= this._length && (this.length = e + 1), this._array[e] = t }; kd.prototype.peek = function () { return this._array[this._length - 1] }; kd.prototype.push = function (e) { let t = this.length++; this._array[t] = e }; kd.prototype.pop = function () { if (this._length === 0) return; let e = this._array[this._length - 1]; return --this.length, e }; kd.prototype.reserve = function (e) { e > this._array.length && (this._array.length = e) }; kd.prototype.resize = function (e) { this.length = e }; kd.prototype.trim = function (e) { e = y(e, this._length), this._array.length = e }; var su = kd; function PB(e) { e = y(e, y.EMPTY_OBJECT), this.color = e.color, this.depth = e.depth, this.stencil = e.stencil, this.renderState = e.renderState, this.framebuffer = e.framebuffer, this.owner = e.owner, this.pass = e.pass } PB.ALL = Object.freeze(new PB({ color: new U(0, 0, 0, 0), depth: 1, stencil: 0 })); PB.prototype.execute = function (e, t) { e.clear(this, t) }; var ti = PB; var fm = { X: 0, Y: 1, Z: 2 }; fm.Y_UP_TO_Z_UP = F.fromRotationTranslation(Q.fromRotationX(I.PI_OVER_TWO)); fm.Z_UP_TO_Y_UP = F.fromRotationTranslation(Q.fromRotationX(-I.PI_OVER_TWO)); fm.X_UP_TO_Z_UP = F.fromRotationTranslation(Q.fromRotationY(-I.PI_OVER_TWO)); fm.Z_UP_TO_X_UP = F.fromRotationTranslation(Q.fromRotationY(I.PI_OVER_TWO)); fm.X_UP_TO_Y_UP = F.fromRotationTranslation(Q.fromRotationZ(I.PI_OVER_TWO)); fm.Y_UP_TO_X_UP = F.fromRotationTranslation(Q.fromRotationZ(-I.PI_OVER_TWO)); fm.fromName = function (e) { return fm[e] }; var Do = Object.freeze(fm); function au(e) { this.planes = y(e, []) } var Qb = [new h, new h, new h]; h.clone(h.UNIT_X, Qb[0]); h.clone(h.UNIT_Y, Qb[1]); h.clone(h.UNIT_Z, Qb[2]); var jp = new h, zve = new h, KZ = new nn(new h(1, 0, 0), 0); au.fromBoundingSphere = function (e, t) { l(t) || (t = new au); let n = Qb.length, i = t.planes; i.length = 2 * n; let o = e.center, r = e.radius, s = 0; for (let a = 0; a < n; ++a) { let c = Qb[a], u = i[s], f = i[s + 1]; l(u) || (u = i[s] = new se), l(f) || (f = i[s + 1] = new se), h.multiplyByScalar(c, -r, jp), h.add(o, jp, jp), u.x = c.x, u.y = c.y, u.z = c.z, u.w = -h.dot(c, jp), h.multiplyByScalar(c, r, jp), h.add(o, jp, jp), f.x = -c.x, f.y = -c.y, f.z = -c.z, f.w = -h.dot(h.negate(c, zve), jp), s += 2 } return t }; au.prototype.computeVisibility = function (e) { let t = this.planes, n = !1; for (let i = 0, o = t.length; i < o; ++i) { let r = e.intersectPlane(nn.fromCartesian4(t[i], KZ)); if (r === Kt.OUTSIDE) return Kt.OUTSIDE; r === Kt.INTERSECTING && (n = !0) } return n ? Kt.INTERSECTING : Kt.INSIDE }; au.prototype.computeVisibilityWithPlaneMask = function (e, t) { if (t === au.MASK_OUTSIDE || t === au.MASK_INSIDE) return t; let n = au.MASK_INSIDE, i = this.planes; for (let o = 0, r = i.length; o < r; ++o) { let s = o < 31 ? 1 << o : 0; if (o < 31 && (t & s) === 0) continue; let a = e.intersectPlane(nn.fromCartesian4(i[o], KZ)); if (a === Kt.OUTSIDE) return au.MASK_OUTSIDE; a === Kt.INTERSECTING && (n |= s) } return n }; au.MASK_OUTSIDE = 4294967295; au.MASK_INSIDE = 0; au.MASK_INDETERMINATE = 2147483647; var Xs = au; function Ud(e) { e = y(e, y.EMPTY_OBJECT), this.left = e.left, this._left = void 0, this.right = e.right, this._right = void 0, this.top = e.top, this._top = void 0, this.bottom = e.bottom, this._bottom = void 0, this.near = y(e.near, 1), this._near = this.near, this.far = y(e.far, 5e8), this._far = this.far, this._cullingVolume = new Xs, this._orthographicMatrix = new F } function JZ(e) { (e.top !== e._top || e.bottom !== e._bottom || e.left !== e._left || e.right !== e._right || e.near !== e._near || e.far !== e._far) && (e._left = e.left, e._right = e.right, e._top = e.top, e._bottom = e.bottom, e._near = e.near, e._far = e.far, e._orthographicMatrix = F.computeOrthographicOffCenter(e.left, e.right, e.bottom, e.top, e.near, e.far, e._orthographicMatrix)) } Object.defineProperties(Ud.prototype, { projectionMatrix: { get: function () { return JZ(this), this._orthographicMatrix } } }); var Hve = new h, Gve = new h, Wve = new h, NG = new h; Ud.prototype.computeCullingVolume = function (e, t, n) { let i = this._cullingVolume.planes, o = this.top, r = this.bottom, s = this.right, a = this.left, c = this.near, u = this.far, f = h.cross(t, n, Hve); h.normalize(f, f); let d = Gve; h.multiplyByScalar(t, c, d), h.add(e, d, d); let p = Wve; h.multiplyByScalar(f, a, p), h.add(d, p, p); let g = i[0]; return l(g) || (g = i[0] = new se), g.x = f.x, g.y = f.y, g.z = f.z, g.w = -h.dot(f, p), h.multiplyByScalar(f, s, p), h.add(d, p, p), g = i[1], l(g) || (g = i[1] = new se), g.x = -f.x, g.y = -f.y, g.z = -f.z, g.w = -h.dot(h.negate(f, NG), p), h.multiplyByScalar(n, r, p), h.add(d, p, p), g = i[2], l(g) || (g = i[2] = new se), g.x = n.x, g.y = n.y, g.z = n.z, g.w = -h.dot(n, p), h.multiplyByScalar(n, o, p), h.add(d, p, p), g = i[3], l(g) || (g = i[3] = new se), g.x = -n.x, g.y = -n.y, g.z = -n.z, g.w = -h.dot(h.negate(n, NG), p), g = i[4], l(g) || (g = i[4] = new se), g.x = t.x, g.y = t.y, g.z = t.z, g.w = -h.dot(t, d), h.multiplyByScalar(t, u, p), h.add(e, p, p), g = i[5], l(g) || (g = i[5] = new se), g.x = -t.x, g.y = -t.y, g.z = -t.z, g.w = -h.dot(h.negate(t, NG), p), this._cullingVolume }; Ud.prototype.getPixelDimensions = function (e, t, n, i, o) { JZ(this); let r = this.right - this.left, s = this.top - this.bottom, a = i * r / e, c = i * s / t; return o.x = a, o.y = c, o }; Ud.prototype.clone = function (e) { return l(e) || (e = new Ud), e.left = this.left, e.right = this.right, e.top = this.top, e.bottom = this.bottom, e.near = this.near, e.far = this.far, e._left = void 0, e._right = void 0, e._top = void 0, e._bottom = void 0, e._near = void 0, e._far = void 0, e }; Ud.prototype.equals = function (e) { return l(e) && e instanceof Ud && this.right === e.right && this.left === e.left && this.top === e.top && this.bottom === e.bottom && this.near === e.near && this.far === e.far }; Ud.prototype.equalsEpsilon = function (e, t, n) { return e === this || l(e) && e instanceof Ud && I.equalsEpsilon(this.right, e.right, t, n) && I.equalsEpsilon(this.left, e.left, t, n) && I.equalsEpsilon(this.top, e.top, t, n) && I.equalsEpsilon(this.bottom, e.bottom, t, n) && I.equalsEpsilon(this.near, e.near, t, n) && I.equalsEpsilon(this.far, e.far, t, n) }; var wr = Ud; function Fc(e) { e = y(e, y.EMPTY_OBJECT), this._offCenterFrustum = new wr, this.width = e.width, this._width = void 0, this.aspectRatio = e.aspectRatio, this._aspectRatio = void 0, this.near = y(e.near, 1), this._near = this.near, this.far = y(e.far, 5e8), this._far = this.far } Fc.packedLength = 4; Fc.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e.width, t[n++] = e.aspectRatio, t[n++] = e.near, t[n] = e.far, t }; Fc.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new Fc), n.width = e[t++], n.aspectRatio = e[t++], n.near = e[t++], n.far = e[t], n }; function P0(e) { let t = e._offCenterFrustum; if (e.width !== e._width || e.aspectRatio !== e._aspectRatio || e.near !== e._near || e.far !== e._far) { e._aspectRatio = e.aspectRatio, e._width = e.width, e._near = e.near, e._far = e.far; let n = 1 / e.aspectRatio; t.right = e.width * .5, t.left = -t.right, t.top = n * t.right, t.bottom = -t.top, t.near = e.near, t.far = e.far } } Object.defineProperties(Fc.prototype, { projectionMatrix: { get: function () { return P0(this), this._offCenterFrustum.projectionMatrix } } }); Fc.prototype.computeCullingVolume = function (e, t, n) { return P0(this), this._offCenterFrustum.computeCullingVolume(e, t, n) }; Fc.prototype.getPixelDimensions = function (e, t, n, i, o) { return P0(this), this._offCenterFrustum.getPixelDimensions(e, t, n, i, o) }; Fc.prototype.clone = function (e) { return l(e) || (e = new Fc), e.aspectRatio = this.aspectRatio, e.width = this.width, e.near = this.near, e.far = this.far, e._aspectRatio = void 0, e._width = void 0, e._near = void 0, e._far = void 0, this._offCenterFrustum.clone(e._offCenterFrustum), e }; Fc.prototype.equals = function (e) { return !l(e) || !(e instanceof Fc) ? !1 : (P0(this), P0(e), this.width === e.width && this.aspectRatio === e.aspectRatio && this._offCenterFrustum.equals(e._offCenterFrustum)) }; Fc.prototype.equalsEpsilon = function (e, t, n) { return !l(e) || !(e instanceof Fc) ? !1 : (P0(this), P0(e), I.equalsEpsilon(this.width, e.width, t, n) && I.equalsEpsilon(this.aspectRatio, e.aspectRatio, t, n) && this._offCenterFrustum.equalsEpsilon(e._offCenterFrustum, t, n)) }; var Zt = Fc; function ZZ(e) { e = y(e, y.EMPTY_OBJECT), this._metadata = e.metadata } Object.defineProperties(ZZ.prototype, { metadata: { get: function () { return this._metadata } } }); var kC = ZZ; function qp(e, t, n) { return t = y(t, 0), n = y(n, e.byteLength - t), e = e.subarray(t, t + n), qp.decode(e) } qp.decodeWithTextDecoder = function (e) { return new TextDecoder("utf-8").decode(e) }; qp.decodeWithFromCharCode = function (e) { let t = "", n = jve(e), i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; r <= 65535 ? t += String.fromCharCode(r) : (r -= 65536, t += String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320)) } return t }; function $b(e, t, n) { return t <= e && e <= n } function jve(e) { let t = 0, n = 0, i = 0, o = 128, r = 191, s = [], a = e.length; for (let c = 0; c < a; ++c) { let u = e[c]; if (i === 0) { if ($b(u, 0, 127)) { s.push(u); continue } if ($b(u, 194, 223)) { i = 1, t = u & 31; continue } if ($b(u, 224, 239)) { u === 224 && (o = 160), u === 237 && (r = 159), i = 2, t = u & 15; continue } if ($b(u, 240, 244)) { u === 240 && (o = 144), u === 244 && (r = 143), i = 3, t = u & 7; continue } throw new fe("String decoding failed.") } if (!$b(u, o, r)) { t = i = n = 0, o = 128, r = 191, --c; continue } o = 128, r = 191, t = t << 6 | u & 63, ++n, n === i && (s.push(t), t = i = n = 0) } return s } typeof TextDecoder < "u" ? qp.decode = qp.decodeWithTextDecoder : qp.decode = qp.decodeWithFromCharCode; var pl = qp; function qve(e, t) { return t = y(t, 0), pl(e, t, Math.min(4, e.length)) } var zd = qve; function dm(e, t, n, i, o, r) { this._tileset = e, this._tile = t, this._resource = n, this._contents = [], this._metadata = void 0, this._group = void 0, this._readyPromise = Yve(this, i, o, r) } Object.defineProperties(dm.prototype, { featurePropertiesDirty: { get: function () { let e = this._contents, t = e.length; for (let n = 0; n < t; ++n)if (e[n].featurePropertiesDirty) return !0; return !1 }, set: function (e) { let t = this._contents, n = t.length; for (let i = 0; i < n; ++i)t[i].featurePropertiesDirty = e } }, featuresLength: { get: function () { return 0 } }, pointsLength: { get: function () { return 0 } }, trianglesLength: { get: function () { return 0 } }, geometryByteLength: { get: function () { return 0 } }, texturesByteLength: { get: function () { return 0 } }, batchTableByteLength: { get: function () { return 0 } }, innerContents: { get: function () { return this._contents } }, readyPromise: { get: function () { return this._readyPromise } }, tileset: { get: function () { return this._tileset } }, tile: { get: function () { return this._tile } }, url: { get: function () { return this._resource.getUrlComponent(!0) } }, metadata: { get: function () { return this._metadata }, set: function (e) { this._metadata = e; let t = this._contents, n = t.length; for (let i = 0; i < n; ++i)t[i].metadata = e } }, batchTable: { get: function () { } }, group: { get: function () { return this._group }, set: function (e) { this._group = e; let t = this._contents, n = t.length; for (let i = 0; i < n; ++i)t[i].group = e } } }); var eS = Uint32Array.BYTES_PER_ELEMENT; function Yve(e, t, n, i) { n = y(n, 0); let o = new Uint8Array(t), r = new DataView(t); n += eS; let s = r.getUint32(n, !0); if (s !== 1) throw new fe(`Only Composite Tile version 1 is supported. Version ${s} is not.`); n += eS, n += eS; let a = r.getUint32(n, !0); n += eS; let c = [], u = e._resource, f = u.queryParameters.compositeIndex; l(f) ? f = `${f}_` : f = ""; for (let d = 0; d < a; ++d) { let p = zd(o, n), g = r.getUint32(n + eS * 2, !0), m = i[p], A = `${f}${d}`, C = u.getDerivedResource({ queryParameters: { compositeIndex: A } }); if (l(m)) { let x = m(e._tileset, e._tile, C, t, n); e._contents.push(x), c.push(x.readyPromise) } else throw new fe(`Unknown tile content type, ${p}, inside Composite tile`); n += g } return Promise.all(c).then(function () { return e }) } dm.prototype.hasProperty = function (e, t) { return !1 }; dm.prototype.getFeature = function (e) { }; dm.prototype.applyDebugSettings = function (e, t) { let n = this._contents, i = n.length; for (let o = 0; o < i; ++o)n[o].applyDebugSettings(e, t) }; dm.prototype.applyStyle = function (e) { let t = this._contents, n = t.length; for (let i = 0; i < n; ++i)t[i].applyStyle(e) }; dm.prototype.update = function (e, t) { let n = this._contents, i = n.length; for (let o = 0; o < i; ++o)n[o].update(e, t) }; dm.prototype.isDestroyed = function () { return !1 }; dm.prototype.destroy = function () { let e = this._contents, t = e.length; for (let n = 0; n < t; ++n)e[n].destroy(); return le(this) }; var IB = dm; function Xve(e, t, n) { return JSON.parse(pl(e, t, n)) } var Ko = Xve; function ya(e) { this._id = Nn(); let t = e.featuresLength; this._showAlphaProperties = void 0, this._batchValues = void 0, this._batchValuesDirty = !1, this._batchTexture = void 0, this._defaultTexture = void 0, this._pickTexture = void 0, this._pickIds = []; let n, i; if (t > 0) { let o = Math.min(t, Ut.maximumTextureSize), r = Math.ceil(t / Ut.maximumTextureSize), s = 1 / o, a = s * .5, c = 1 / r, u = c * .5; n = new H(o, r), i = new se(s, a, c, u) } this._translucentFeaturesLength = 0, this._featuresLength = t, this._textureDimensions = n, this._textureStep = i, this._owner = e.owner, this._statistics = e.statistics, this._colorChangedCallback = e.colorChangedCallback } Object.defineProperties(ya.prototype, { translucentFeaturesLength: { get: function () { return this._translucentFeaturesLength } }, byteLength: { get: function () { let e = 0; return l(this._pickTexture) && (e += this._pickTexture.sizeInBytes), l(this._batchTexture) && (e += this._batchTexture.sizeInBytes), e } }, textureDimensions: { get: function () { return this._textureDimensions } }, textureStep: { get: function () { return this._textureStep } }, batchTexture: { get: function () { return this._batchTexture } }, defaultTexture: { get: function () { return this._defaultTexture } }, pickTexture: { get: function () { return this._pickTexture } } }); ya.DEFAULT_COLOR_VALUE = U.WHITE; ya.DEFAULT_SHOW_VALUE = !0; function QZ(e) { let t = e._textureDimensions; return t.x * t.y * 4 } function $Z(e) { if (!l(e._batchValues)) { let t = QZ(e), n = new Uint8Array(t).fill(255); e._batchValues = n } return e._batchValues } function eQ(e) { if (!l(e._showAlphaProperties)) { let t = 2 * e._featuresLength, n = new Uint8Array(t).fill(255); e._showAlphaProperties = n } return e._showAlphaProperties } ya.prototype.setShow = function (e, t) { if (t && !l(this._showAlphaProperties)) return; let n = eQ(this), i = e * 2, o = t ? 255 : 0; if (n[i] !== o) { n[i] = o; let r = $Z(this), s = e * 4 + 3; r[s] = t ? n[i + 1] : 0, this._batchValuesDirty = !0 } }; ya.prototype.setAllShow = function (e) { let t = this._featuresLength; for (let n = 0; n < t; ++n)this.setShow(n, e) }; ya.prototype.getShow = function (e) { if (!l(this._showAlphaProperties)) return !0; let t = e * 2; return this._showAlphaProperties[t] === 255 }; var Kve = new Array(4); ya.prototype.setColor = function (e, t) { if (U.equals(t, ya.DEFAULT_COLOR_VALUE) && !l(this._batchValues)) return; let n = t.toBytes(Kve), i = n[3], o = $Z(this), r = e * 4, s = eQ(this), a = e * 2; if (o[r] !== n[0] || o[r + 1] !== n[1] || o[r + 2] !== n[2] || s[a + 1] !== i) { o[r] = n[0], o[r + 1] = n[1], o[r + 2] = n[2]; let c = s[a + 1] !== 255, u = s[a] !== 0; o[r + 3] = u ? i : 0, s[a + 1] = i; let f = i !== 255; f && !c ? ++this._translucentFeaturesLength : !f && c && --this._translucentFeaturesLength, this._batchValuesDirty = !0, l(this._colorChangedCallback) && this._colorChangedCallback(e, t) } }; ya.prototype.setAllColor = function (e) { let t = this._featuresLength; for (let n = 0; n < t; ++n)this.setColor(n, e) }; ya.prototype.getColor = function (e, t) { if (!l(this._batchValues)) return U.clone(ya.DEFAULT_COLOR_VALUE, t); let n = this._batchValues, i = e * 4, o = this._showAlphaProperties, r = e * 2; return U.fromBytes(n[i], n[i + 1], n[i + 2], o[r + 1], t) }; ya.prototype.getPickColor = function (e) { return this._pickIds[e] }; function tQ(e, t, n) { let i = e._textureDimensions; return new Rt({ context: t, pixelFormat: ht.RGBA, pixelDatatype: Ye.UNSIGNED_BYTE, source: { width: i.x, height: i.y, arrayBufferView: n }, flipY: !1, sampler: dn.NEAREST }) } function Jve(e, t) { let n = e._featuresLength; if (!l(e._pickTexture) && n > 0) { let i = e._pickIds, o = QZ(e), r = new Uint8Array(o), s = e._owner, a = e._statistics; for (let c = 0; c < n; ++c) { let u = t.createPickId(s.getFeature(c)); i.push(u); let f = u.color, d = c * 4; r[d] = U.floatToByte(f.red), r[d + 1] = U.floatToByte(f.green), r[d + 2] = U.floatToByte(f.blue), r[d + 3] = U.floatToByte(f.alpha) } e._pickTexture = tQ(e, t, r), l(a) && (a.batchTableByteLength += e._pickTexture.sizeInBytes) } } function Zve(e) { let t = e._textureDimensions; e._batchTexture.copyFrom({ source: { width: t.x, height: t.y, arrayBufferView: e._batchValues } }) } ya.prototype.update = function (e, t) { let n = t.context; this._defaultTexture = n.defaultTexture; let i = t.passes; (i.pick || i.postProcess) && Jve(this, n), this._batchValuesDirty && (this._batchValuesDirty = !1, l(this._batchTexture) || (this._batchTexture = tQ(this, n, this._batchValues), l(this._statistics) && (this._statistics.batchTableByteLength += this._batchTexture.sizeInBytes)), Zve(this)) }; ya.prototype.isDestroyed = function () { return !1 }; ya.prototype.destroy = function () { this._batchTexture = this._batchTexture && this._batchTexture.destroy(), this._pickTexture = this._pickTexture && this._pickTexture.destroy(); let e = this._pickIds, t = e.length; for (let n = 0; n < t; ++n)e[n].destroy(); return le(this) }; var Nc = ya; var Qve = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, $ve = { SCALAR: void 0, VEC2: H, VEC3: h, VEC4: se, MAT2: qi, MAT3: Q, MAT4: F }; function ePe(e) { let t = e.componentType, n; typeof t == "string" ? n = Y.fromName(t) : n = t; let i = Qve[e.type], o = $ve[e.type]; return { componentsPerAttribute: i, classType: o, createArrayBufferView: function (r, s, a) { return Y.createArrayBufferView(n, r, s, i * a) } } } var cu = ePe; function hm(e) { this._classes = void 0, this._classIds = void 0, this._classIndexes = void 0, this._parentCounts = void 0, this._parentIndexes = void 0, this._parentIds = void 0, this._byteLength = 0, tPe(this, e.extension, e.binaryBody) } Object.defineProperties(hm.prototype, { byteLength: { get: function () { return this._byteLength } } }); function tPe(e, t, n) { let i, o, r, s = t.instancesLength, a = t.classes, c = t.classIds, u = t.parentCounts, f = t.parentIds, d = s, p = 0; l(c.byteOffset) && (c.componentType = y(c.componentType, Y.UNSIGNED_SHORT), c.type = en.SCALAR, r = cu(c), c = r.createArrayBufferView(n.buffer, n.byteOffset + c.byteOffset, s), p += c.byteLength); let g; if (l(u)) { for (l(u.byteOffset) && (u.componentType = y(u.componentType, Y.UNSIGNED_SHORT), u.type = en.SCALAR, r = cu(u), u = r.createArrayBufferView(n.buffer, n.byteOffset + u.byteOffset, s), p += u.byteLength), g = new Uint16Array(s), d = 0, i = 0; i < s; ++i)g[i] = d, d += u[i]; p += g.byteLength } l(f) && l(f.byteOffset) && (f.componentType = y(f.componentType, Y.UNSIGNED_SHORT), f.type = en.SCALAR, r = cu(f), f = r.createArrayBufferView(n.buffer, n.byteOffset + f.byteOffset, d), p += f.byteLength); let m = a.length; for (i = 0; i < m; ++i) { let x = a[i].length, T = a[i].instances, b = nPe(x, T, n); p += iPe(b), a[i].instances = yt(b, T) } let A = new Array(m).fill(0), C = new Uint16Array(s); for (i = 0; i < s; ++i)o = c[i], C[i] = A[o], ++A[o]; p += C.byteLength, e._classes = a, e._classIds = c, e._classIndexes = C, e._parentCounts = u, e._parentIndexes = g, e._parentIds = f, e._byteLength = p } function nPe(e, t, n) { let i; for (let o in t) if (t.hasOwnProperty(o)) { let r = t[o], s = r.byteOffset; if (l(s)) { let a = r.componentType, c = r.type; if (!l(a)) throw new fe("componentType is required."); if (!l(c)) throw new fe("type is required."); if (!l(n)) throw new fe(`Property ${o} requires a batch table binary.`); let u = cu(r), f = u.componentsPerAttribute, d = u.classType, p = u.createArrayBufferView(n.buffer, n.byteOffset + s, e); l(i) || (i = {}), i[o] = { typedArray: p, componentCount: f, type: d } } } return i } function iPe(e) { let t = 0; for (let n in e) e.hasOwnProperty(n) && (t += e[n].typedArray.byteLength); return t } var oPe = [], rPe = [], sPe = 0; function aPe(e, t, n) { let i = e._classIds, o = e._parentCounts, r = e._parentIds, s = e._parentIndexes, a = i.length, c = oPe; c.length = Math.max(c.length, a); let u = ++sPe, f = rPe; for (f.length = 0, f.push(t); f.length > 0;) { if (t = f.pop(), c[t] === u) continue; c[t] = u; let d = n(e, t); if (l(d)) return d; let p = o[t], g = s[t]; for (let m = 0; m < p; ++m) { let A = r[g + m]; A !== t && f.push(A) } } } function cPe(e, t, n) { let i = !0; for (; i;) { let o = n(e, t); if (l(o)) return o; let r = e._parentIds[t]; i = r !== t, t = r } } function tS(e, t, n) { let i = e._parentCounts, o = e._parentIds; if (l(o)) { if (l(i)) return aPe(e, t, n) } else return n(e, t); return cPe(e, t, n) } hm.prototype.hasProperty = function (e, t) { let n = tS(this, e, function (i, o) { let r = i._classIds[o], s = i._classes[r].instances; if (l(s[t])) return !0 }); return l(n) }; hm.prototype.propertyExists = function (e) { let t = this._classes, n = t.length; for (let i = 0; i < n; ++i) { let o = t[i].instances; if (l(o[e])) return !0 } return !1 }; hm.prototype.getPropertyIds = function (e, t) { return t = l(t) ? t : [], t.length = 0, tS(this, e, function (n, i) { let o = n._classIds[i], r = n._classes[o].instances; for (let s in r) r.hasOwnProperty(s) && t.indexOf(s) === -1 && t.push(s) }), t }; hm.prototype.getProperty = function (e, t) { return tS(this, e, function (n, i) { let o = n._classIds[i], r = n._classes[o], s = n._classIndexes[i], a = r.instances[t]; if (l(a)) return l(a.typedArray) ? lPe(a, s) : tt(a[s], !0) }) }; function lPe(e, t) { let n = e.typedArray, i = e.componentCount; return i === 1 ? n[t] : e.type.unpack(n, t * i) } hm.prototype.setProperty = function (e, t, n) { let i = tS(this, e, function (o, r) { let s = o._classIds[r], a = o._classes[s], c = o._classIndexes[r], u = a.instances[t]; if (l(u)) return l(u.typedArray) ? uPe(u, c, n) : u[c] = tt(n, !0), !0 }); return l(i) }; function uPe(e, t, n) { let i = e.typedArray, o = e.componentCount; o === 1 ? i[t] = n : e.type.pack(n, i, t * o) } hm.prototype.isClass = function (e, t) { let n = tS(this, e, function (i, o) { let r = i._classIds[o]; if (i._classes[r].name === t) return !0 }); return l(n) }; hm.prototype.getClassName = function (e) { let t = this._classIds[e]; return this._classes[t].name }; var UC = hm; var fPe = { HIGHLIGHT: 0, REPLACE: 1, MIX: 2 }, _l = Object.freeze(fPe); var VG = Nc.DEFAULT_COLOR_VALUE, kG = Nc.DEFAULT_SHOW_VALUE; function to(e, t, n, i, o) { this.featuresLength = t; let r; l(n) && (r = n.extensions), this._extensions = y(r, {}); let s = dPe(n); this._properties = s, this._batchTableHierarchy = hPe(this, n, i); let a = iQ(t, s, i); this._binaryPropertiesByteLength = mPe(a), this._batchTableBinaryProperties = a, this._content = e, this._batchTexture = new Nc({ featuresLength: t, colorChangedCallback: o, owner: e, statistics: e.tileset.statistics }) } to._deprecationWarning = Jr; Object.defineProperties(to.prototype, { batchTableByteLength: { get: function () { let e = this._binaryPropertiesByteLength; return l(this._batchTableHierarchy) && (e += this._batchTableHierarchy.byteLength), e += this._batchTexture.byteLength, e } } }); function dPe(e) { let t = {}; if (!l(e)) return t; for (let n in e) e.hasOwnProperty(n) && n !== "HIERARCHY" && n !== "extensions" && n !== "extras" && (t[n] = tt(e[n], !0)); return t } function hPe(e, t, n) { if (!l(t)) return; let i = e._extensions["3DTILES_batch_table_hierarchy"], o = t.HIERARCHY; if (l(o) && (to._deprecationWarning("batchTableHierarchyExtension", "The batch table HIERARCHY property has been moved to an extension. Use extensions.3DTILES_batch_table_hierarchy instead."), e._extensions["3DTILES_batch_table_hierarchy"] = o, i = o), !!l(i)) return new UC({ extension: i, binaryBody: n }) } function iQ(e, t, n) { let i; for (let o in t) if (t.hasOwnProperty(o)) { let r = t[o], s = r.byteOffset; if (l(s)) { let a = r.componentType, c = r.type; if (!l(a)) throw new fe("componentType is required."); if (!l(c)) throw new fe("type is required."); if (!l(n)) throw new fe(`Property ${o} requires a batch table binary.`); let u = cu(r), f = u.componentsPerAttribute, d = u.classType, p = u.createArrayBufferView(n.buffer, n.byteOffset + s, e); l(i) || (i = {}), i[o] = { typedArray: p, componentCount: f, type: d } } } return i } function mPe(e) { if (!l(e)) return 0; let t = 0; for (let n in e) e.hasOwnProperty(n) && (t += e[n].typedArray.byteLength); return t } to.getBinaryProperties = function (e, t, n) { return iQ(e, t, n) }; to.prototype.setShow = function (e, t) { this._batchTexture.setShow(e, t) }; to.prototype.setAllShow = function (e) { this._batchTexture.setAllShow(e) }; to.prototype.getShow = function (e) { return this._batchTexture.getShow(e) }; to.prototype.setColor = function (e, t) { this._batchTexture.setColor(e, t) }; to.prototype.setAllColor = function (e) { this._batchTexture.setAllColor(e) }; to.prototype.getColor = function (e, t) { return this._batchTexture.getColor(e, t) }; to.prototype.getPickColor = function (e) { return this._batchTexture.getPickColor(e) }; var pPe = new U; to.prototype.applyStyle = function (e) { if (!l(e)) { this.setAllColor(VG), this.setAllShow(kG); return } let t = this._content, n = this.featuresLength; for (let i = 0; i < n; ++i) { let o = t.getFeature(i), r = l(e.color) ? y(e.color.evaluateColor(o, pPe), VG) : VG, s = l(e.show) ? y(e.show.evaluate(o), kG) : kG; this.setColor(i, r), this.setShow(i, s) } }; function _Pe(e, t) { let n = e.typedArray, i = e.componentCount; return i === 1 ? n[t] : e.type.unpack(n, t * i) } function gPe(e, t, n) { let i = e.typedArray, o = e.componentCount; o === 1 ? i[t] = n : e.type.pack(n, i, t * o) } to.prototype.isClass = function (e, t) { let n = this._batchTableHierarchy; return l(n) ? n.isClass(e, t) : !1 }; to.prototype.isExactClass = function (e, t) { return this.getExactClassName(e) === t }; to.prototype.getExactClassName = function (e) { let t = this._batchTableHierarchy; if (!!l(t)) return t.getClassName(e) }; to.prototype.hasProperty = function (e, t) { return l(this._properties[t]) || l(this._batchTableHierarchy) && this._batchTableHierarchy.hasProperty(e, t) }; to.prototype.hasPropertyBySemantic = function () { return !1 }; to.prototype.getPropertyIds = function (e, t) { t = l(t) ? t : [], t.length = 0; let n = Object.keys(this._properties); return t.push.apply(t, n), l(this._batchTableHierarchy) && t.push.apply(t, this._batchTableHierarchy.getPropertyIds(e, n)), t }; to.prototype.getPropertyBySemantic = function (e, t) { }; to.prototype.getProperty = function (e, t) { if (l(this._batchTableBinaryProperties)) { let i = this._batchTableBinaryProperties[t]; if (l(i)) return _Pe(i, e) } let n = this._properties[t]; if (l(n)) return tt(n[e], !0); if (l(this._batchTableHierarchy)) { let i = this._batchTableHierarchy.getProperty(e, t); if (l(i)) return i } }; to.prototype.setProperty = function (e, t, n) { let i = this.featuresLength; if (l(this._batchTableBinaryProperties)) { let r = this._batchTableBinaryProperties[t]; if (l(r)) { gPe(r, e, n); return } } if (l(this._batchTableHierarchy) && this._batchTableHierarchy.setProperty(e, t, n)) return; let o = this._properties[t]; l(o) || (this._properties[t] = new Array(i), o = this._properties[t]), o[e] = tt(n, !0) }; function yPe(e) {
        return e._batchTexture.textureDimensions.y === 1 ? `uniform vec4 tile_textureStep; 
vec2 computeSt(float batchId) 
{ 
    float stepX = tile_textureStep.x; 
    float centerX = tile_textureStep.y; 
    return vec2(centerX + (batchId * stepX), 0.5); 
} 
`: `uniform vec4 tile_textureStep; 
uniform vec2 tile_textureDimensions; 
vec2 computeSt(float batchId) 
{ 
    float stepX = tile_textureStep.x; 
    float centerX = tile_textureStep.y; 
    float stepY = tile_textureStep.z; 
    float centerY = tile_textureStep.w; 
    float xId = mod(batchId, tile_textureDimensions.x); 
    float yId = floor(batchId / tile_textureDimensions.x); 
    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); 
} 
`} to.prototype.getVertexShaderCallback = function (e, t, n) {
        if (this.featuresLength === 0) return; let i = this; return function (o) {
            let r = oQ(o, n, !1), s; return Ut.maximumVertexTextureImageUnits > 0 ? (s = "", e && (s += `uniform bool tile_translucentCommand; 
`), s += `uniform sampler2D tile_batchTexture; 
varying vec4 tile_featureColor; 
varying vec2 tile_featureSt; 
void main() 
{ 
    vec2 st = computeSt(${t}); 
    vec4 featureProperties = texture2D(tile_batchTexture, st); 
    tile_color(featureProperties); 
    float show = ceil(featureProperties.a); 
    gl_Position *= show; 
`, e && (s += `    bool isStyleTranslucent = (featureProperties.a != 1.0); 
    if (czm_pass == czm_passTranslucent) 
    { 
        if (!isStyleTranslucent && !tile_translucentCommand) 
        { 
            gl_Position *= 0.0; 
        } 
    } 
    else 
    { 
        if (isStyleTranslucent) 
        { 
            gl_Position *= 0.0; 
        } 
    } 
`), s += `    tile_featureColor = featureProperties; 
    tile_featureSt = st; 
}`) : s = `varying vec2 tile_featureSt; 
void main() 
{ 
    tile_color(vec4(1.0)); 
    tile_featureSt = computeSt(${t}); 
}`, `${r}
${yPe(i)}${s}`
        }
    }; function nQ(e, t) {
        return e = Ue.replaceMain(e, "tile_main"), t ? `${e}uniform float tile_colorBlend; 
void tile_color(vec4 tile_featureColor) 
{ 
    tile_main(); 
    tile_featureColor = czm_gammaCorrect(tile_featureColor); 
    gl_FragColor.a *= tile_featureColor.a; 
    float highlight = ceil(tile_colorBlend); 
    gl_FragColor.rgb *= mix(tile_featureColor.rgb, vec3(1.0), highlight); 
} 
`: `${e}void tile_color(vec4 tile_featureColor) 
{ 
    tile_main(); 
} 
`} function APe(e, t) { let n = `texture2D(${t}`, i = 0, o = e.indexOf(n, i), r; for (; o > -1;) { let s = 0; for (let u = o; u < e.length; ++u) { let f = e.charAt(u); if (f === "(") ++s; else if (f === ")" && (--s, s === 0)) { r = u + 1; break } } let c = `tile_diffuse_final(${e.slice(o, r)}, tile_diffuse)`; e = e.slice(0, o) + c + e.slice(r), i = o + c.length, o = e.indexOf(n, i) } return e } function oQ(e, t, n) {
        if (!l(t)) return nQ(e, n); let i = new RegExp(`(uniform|attribute|in)\\s+(vec[34]|sampler2D)\\s+${t};`), o = e.match(i); if (!l(o)) return nQ(e, n); let r = o[0], s = o[2]; e = Ue.replaceMain(e, "tile_main"), e = e.replace(r, ""); let a = `bool isWhite(vec3 color) 
{ 
    return all(greaterThan(color, vec3(1.0 - czm_epsilon3))); 
} 
vec4 tile_diffuse_final(vec4 sourceDiffuse, vec4 tileDiffuse) 
{ 
    vec4 blendDiffuse = mix(sourceDiffuse, tileDiffuse, tile_colorBlend); 
    vec4 diffuse = isWhite(tileDiffuse.rgb) ? sourceDiffuse : blendDiffuse; 
    return vec4(diffuse.rgb, sourceDiffuse.a); 
} 
`, c = `    tile_featureColor = czm_gammaCorrect(tile_featureColor); 
    gl_FragColor.a *= tile_featureColor.a; 
    float highlight = ceil(tile_colorBlend); 
    gl_FragColor.rgb *= mix(tile_featureColor.rgb, vec3(1.0), highlight); 
`, u; if (s === "vec3" || s === "vec4") {
            let f = s === "vec3" ? `vec4(${t}, 1.0)` : t, d = s === "vec3" ? "tile_diffuse.xyz" : "tile_diffuse"; i = new RegExp(t, "g"), e = e.replace(i, d), u = `    vec4 source = ${f}; 
    tile_diffuse = tile_diffuse_final(source, tile_featureColor); 
    tile_main(); 
`} else s === "sampler2D" && (e = APe(e, t), u = `    tile_diffuse = tile_featureColor; 
    tile_main(); 
`); return e = `uniform float tile_colorBlend; 
vec4 tile_diffuse = vec4(1.0); 
${a}${r}
${e}
void tile_color(vec4 tile_featureColor) 
{ 
${u}`, n && (e += c), e += `} 
`, e
    } to.prototype.getFragmentShaderCallback = function (e, t, n) {
        if (this.featuresLength !== 0) return function (i) {
            return i = oQ(i, t, !0), Ut.maximumVertexTextureImageUnits > 0 ? (i += `uniform sampler2D tile_pickTexture; 
varying vec2 tile_featureSt; 
varying vec4 tile_featureColor; 
void main() 
{ 
    tile_color(tile_featureColor); 
`, n && (i += `    gl_FragColor.rgb *= gl_FragColor.a; 
`), i += "}") : (e && (i += `uniform bool tile_translucentCommand; 
`), i += `uniform sampler2D tile_pickTexture; 
uniform sampler2D tile_batchTexture; 
varying vec2 tile_featureSt; 
void main() 
{ 
    vec4 featureProperties = texture2D(tile_batchTexture, tile_featureSt); 
    if (featureProperties.a == 0.0) { 
        discard; 
    } 
`, e && (i += `    bool isStyleTranslucent = (featureProperties.a != 1.0); 
    if (czm_pass == czm_passTranslucent) 
    { 
        if (!isStyleTranslucent && !tile_translucentCommand) 
        { 
            discard; 
        } 
    } 
    else 
    { 
        if (isStyleTranslucent) 
        { 
            discard; 
        } 
    } 
`), i += `    tile_color(featureProperties); 
`, n && (i += `    gl_FragColor.rgb *= gl_FragColor.a; 
`), i += `} 
`), i
        }
    }; to.prototype.getClassificationFragmentShaderCallback = function () {
        if (this.featuresLength !== 0) return function (e) {
            return e = Ue.replaceMain(e, "tile_main"), Ut.maximumVertexTextureImageUnits > 0 ? e += `uniform sampler2D tile_pickTexture;
varying vec2 tile_featureSt; 
varying vec4 tile_featureColor; 
void main() 
{ 
    tile_main(); 
    gl_FragColor = tile_featureColor; 
    gl_FragColor.rgb *= gl_FragColor.a; 
}`: e += `uniform sampler2D tile_batchTexture; 
uniform sampler2D tile_pickTexture;
varying vec2 tile_featureSt; 
void main() 
{ 
    tile_main(); 
    vec4 featureProperties = texture2D(tile_batchTexture, tile_featureSt); 
    if (featureProperties.a == 0.0) { 
        discard; 
    } 
    gl_FragColor = featureProperties; 
    gl_FragColor.rgb *= gl_FragColor.a; 
} 
`, e
        }
    }; function CPe(e) { let t = e._content.tileset, n = t.colorBlendMode, i = t.colorBlendAmount; if (n === _l.HIGHLIGHT) return 0; if (n === _l.REPLACE) return 1; if (n === _l.MIX) return I.clamp(i, I.EPSILON4, 1) } to.prototype.getUniformMapCallback = function () { if (this.featuresLength === 0) return; let e = this; return function (t) { return yt(t, { tile_batchTexture: function () { return y(e._batchTexture.batchTexture, e._batchTexture.defaultTexture) }, tile_textureDimensions: function () { return e._batchTexture.textureDimensions }, tile_textureStep: function () { return e._batchTexture.textureStep }, tile_colorBlend: function () { return CPe(e) }, tile_pickTexture: function () { return e._batchTexture.pickTexture } }) } }; to.prototype.getPickId = function () { return "texture2D(tile_pickTexture, tile_featureSt)" }; var Yp = { ALL_OPAQUE: 0, ALL_TRANSLUCENT: 1, OPAQUE_AND_TRANSLUCENT: 2 }; to.prototype.addDerivedCommands = function (e, t) { let n = e.commandList, i = n.length, o = this._content._tile, r = o._finalResolution, s = o.tileset, a = s._skipLevelOfDetail && s._hasMixedContent && e.context.stencilBuffer, c = xPe(this); for (let u = t; u < i; ++u) { let f = n[u]; if (f.pass === xe.COMPUTE) continue; let d = f.derivedCommands.tileset; (!l(d) || f.dirty) && (d = {}, f.derivedCommands.tileset = d, d.originalCommand = TPe(f), f.dirty = !1); let p = d.originalCommand; c !== Yp.ALL_OPAQUE && f.pass !== xe.TRANSLUCENT && (l(d.translucent) || (d.translucent = EPe(p))), c !== Yp.ALL_TRANSLUCENT && f.pass !== xe.TRANSLUCENT && (l(d.opaque) || (d.opaque = bPe(p)), a && (r || (l(d.zback) || (d.zback = wPe(e.context, p)), s._backfaceCommands.push(d.zback)), (!l(d.stencil) || o._selectionDepth !== vPe(d.stencil)) && (f.renderState.depthMask ? d.stencil = DPe(p, o._selectionDepth) : d.stencil = d.opaque))); let g = a ? d.stencil : d.opaque, m = d.translucent; f.pass !== xe.TRANSLUCENT ? (c === Yp.ALL_OPAQUE && (n[u] = g), c === Yp.ALL_TRANSLUCENT && (n[u] = m), c === Yp.OPAQUE_AND_TRANSLUCENT && (n[u] = g, n.push(m))) : n[u] = p } }; function xPe(e) { let t = e._batchTexture.translucentFeaturesLength; return t === 0 ? Yp.ALL_OPAQUE : t === e.featuresLength ? Yp.ALL_TRANSLUCENT : Yp.OPAQUE_AND_TRANSLUCENT } function TPe(e) { let t = $e.shallowClone(e), n = t.pass === xe.TRANSLUCENT; return t.uniformMap = l(t.uniformMap) ? t.uniformMap : {}, t.uniformMap.tile_translucentCommand = function () { return n }, t } function EPe(e) { let t = $e.shallowClone(e); return t.pass = xe.TRANSLUCENT, t.renderState = PPe(e.renderState), t } function bPe(e) { let t = $e.shallowClone(e); return t.renderState = IPe(e.renderState), t } function SPe(e, t) {
        let n = e.shaderCache.getDerivedShaderProgram(t, "zBackfaceLogDepth"); if (!l(n)) {
            let i = t.fragmentShaderSource.clone(); i.defines = l(i.defines) ? i.defines.slice(0) : [], i.defines.push("POLYGON_OFFSET"), i.sources.unshift(`#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif
`), n = e.shaderCache.createDerivedShaderProgram(t, "zBackfaceLogDepth", { vertexShaderSource: t.vertexShaderSource, fragmentShaderSource: i, attributeLocations: t._attributeLocations })
        } return n
    } function wPe(e, t) { let n = $e.shallowClone(t), i = tt(n.renderState, !0); i.cull.enabled = !0, i.cull.face = gi.FRONT, i.colorMask = { red: !1, green: !1, blue: !1, alpha: !1 }, i.polygonOffset = { enabled: !0, factor: 5, units: 5 }, i.stencilTest = vt.setCesium3DTileBit(), i.stencilMask = vt.CESIUM_3D_TILE_MASK, n.renderState = Ve.fromCache(i), n.castShadows = !1, n.receiveShadows = !1, n.uniformMap = tt(t.uniformMap); let o = new H(5, 5); return n.uniformMap.u_polygonOffset = function () { return o }, n.shaderProgram = SPe(e, t.shaderProgram), n } function DPe(e, t) { let n = $e.shallowClone(e), i = tt(n.renderState, !0); return i.stencilTest.enabled = !0, i.stencilTest.mask = vt.SKIP_LOD_MASK, i.stencilTest.reference = vt.CESIUM_3D_TILE_MASK | t << vt.SKIP_LOD_BIT_SHIFT, i.stencilTest.frontFunction = Fn.GREATER_OR_EQUAL, i.stencilTest.frontOperation.zPass = lt.REPLACE, i.stencilTest.backFunction = Fn.GREATER_OR_EQUAL, i.stencilTest.backOperation.zPass = lt.REPLACE, i.stencilMask = vt.CESIUM_3D_TILE_MASK | vt.SKIP_LOD_MASK, n.renderState = Ve.fromCache(i), n } function vPe(e) { return (e.renderState.stencilTest.reference & vt.SKIP_LOD_MASK) >>> vt.SKIP_LOD_BIT_SHIFT } function PPe(e) { let t = tt(e, !0); return t.cull.enabled = !1, t.depthTest.enabled = !0, t.depthMask = !1, t.blending = an.ALPHA_BLEND, t.stencilTest = vt.setCesium3DTileBit(), t.stencilMask = vt.CESIUM_3D_TILE_MASK, Ve.fromCache(t) } function IPe(e) { let t = tt(e, !0); return t.stencilTest = vt.setCesium3DTileBit(), t.stencilMask = vt.CESIUM_3D_TILE_MASK, Ve.fromCache(t) } to.prototype.update = function (e, t) { this._batchTexture.update(e, t) }; to.prototype.isDestroyed = function () { return !1 }; to.prototype.destroy = function () { return this._batchTexture = this._batchTexture && this._batchTexture.destroy(), le(this) }; var Xp = to; function OPe(e) { this.offset = e.offset, this.count = e.count, this.color = e.color, this.batchIds = e.batchIds } var mm = OPe; var nS = `attribute vec3 position;
attribute float a_batchId;
uniform mat4 u_modifiedModelViewProjection;
void main()
{
gl_Position = czm_depthClamp(u_modifiedModelViewProjection * vec4(position, 1.0));
}
`; function lu(e, t) { this._content = e, this._batchId = t, this._color = void 0 } Object.defineProperties(lu.prototype, { show: { get: function () { return this._content.batchTable.getShow(this._batchId) }, set: function (e) { this._content.batchTable.setShow(this._batchId, e) } }, color: { get: function () { return l(this._color) || (this._color = new U), this._content.batchTable.getColor(this._batchId, this._color) }, set: function (e) { this._content.batchTable.setColor(this._batchId, e) } }, polylinePositions: { get: function () { if (!!l(this._content.getPolylinePositions)) return this._content.getPolylinePositions(this._batchId) } }, content: { get: function () { return this._content } }, tileset: { get: function () { return this._content.tileset } }, primitive: { get: function () { return this._content.tileset } }, featureId: { get: function () { return this._batchId } }, pickId: { get: function () { return this._content.batchTable.getPickColor(this._batchId) } } }); lu.prototype.hasProperty = function (e) { return this._content.batchTable.hasProperty(this._batchId, e) }; lu.prototype.getPropertyIds = function (e) { return this._content.batchTable.getPropertyIds(this._batchId, e) }; lu.prototype.getProperty = function (e) { return this._content.batchTable.getProperty(this._batchId, e) }; lu.getPropertyInherited = function (e, t, n) { let i = e.batchTable; if (l(i)) { if (i.hasPropertyBySemantic(t, n)) return i.getPropertyBySemantic(t, n); if (i.hasProperty(t, n)) return i.getProperty(t, n) } let o = e.metadata; if (l(o)) { if (o.hasPropertyBySemantic(n)) return o.getPropertyBySemantic(n); if (o.hasProperty(n)) return o.getProperty(n) } let r = e.tile, s = r.metadata; if (l(s)) { if (s.hasPropertyBySemantic(n)) return s.getPropertyBySemantic(n); if (s.hasProperty(n)) return s.getProperty(n) } let a; if (l(r.implicitSubtree) && (a = r.implicitSubtree.metadata), l(a)) { if (a.hasPropertyBySemantic(n)) return a.getPropertyBySemantic(n); if (a.hasProperty(n)) return a.getProperty(n) } let c = l(e.group) ? e.group.metadata : void 0; if (l(c)) { if (c.hasPropertyBySemantic(n)) return c.getPropertyBySemantic(n); if (c.hasProperty(n)) return c.getProperty(n) } let u = e.tileset.metadata; if (l(u)) { if (u.hasPropertyBySemantic(n)) return u.getPropertyBySemantic(n); if (u.hasProperty(n)) return u.getProperty(n) } }; lu.prototype.getPropertyInherited = function (e) { return lu.getPropertyInherited(this._content, this._batchId, e) }; lu.prototype.setProperty = function (e, t) { this._content.batchTable.setProperty(this._batchId, e, t), this._content.featurePropertiesDirty = !0 }; lu.prototype.isExactClass = function (e) { return this._content.batchTable.isExactClass(this._batchId, e) }; lu.prototype.isClass = function (e) { return this._content.batchTable.isClass(this._batchId, e) }; lu.prototype.getExactClassName = function () { return this._content.batchTable.getExactClassName(this._batchId) }; var xs = lu; var MB = po(rQ(), 1); var BPe = { VARIABLE: 0, UNARY: 1, BINARY: 2, TERNARY: 3, CONDITIONAL: 4, MEMBER: 5, FUNCTION_CALL: 6, ARRAY: 7, REGEX: 8, VARIABLE_IN_STRING: 9, LITERAL_NULL: 10, LITERAL_BOOLEAN: 11, LITERAL_NUMBER: 12, LITERAL_STRING: 13, LITERAL_COLOR: 14, LITERAL_VECTOR: 15, LITERAL_REGEX: 16, LITERAL_UNDEFINED: 17, BUILTIN_VARIABLE: 18 }, ft = Object.freeze(BPe); function _f(e, t) { this._expression = e, e = jPe(e, t), e = YPe(qPe(e)), MB.default.addBinaryOp("=~", 0), MB.default.addBinaryOp("!~", 0); let n; try { n = (0, MB.default)(e) } catch (i) { throw new fe(i) } this._runtimeAst = ci(this, n) } Object.defineProperties(_f.prototype, { expression: { get: function () { return this._expression } } }); var bn = { arrayIndex: 0, arrayArray: [[]], cartesian2Index: 0, cartesian3Index: 0, cartesian4Index: 0, cartesian2Array: [new H], cartesian3Array: [new h], cartesian4Array: [new se], reset: function () { this.arrayIndex = 0, this.cartesian2Index = 0, this.cartesian3Index = 0, this.cartesian4Index = 0 }, getArray: function () { this.arrayIndex >= this.arrayArray.length && this.arrayArray.push([]); let e = this.arrayArray[this.arrayIndex++]; return e.length = 0, e }, getCartesian2: function () { return this.cartesian2Index >= this.cartesian2Array.length && this.cartesian2Array.push(new H), this.cartesian2Array[this.cartesian2Index++] }, getCartesian3: function () { return this.cartesian3Index >= this.cartesian3Array.length && this.cartesian3Array.push(new h), this.cartesian3Array[this.cartesian3Index++] }, getCartesian4: function () { return this.cartesian4Index >= this.cartesian4Array.length && this.cartesian4Array.push(new se), this.cartesian4Array[this.cartesian4Index++] } }; _f.prototype.evaluate = function (e, t) { bn.reset(); let n = this._runtimeAst.evaluate(e); return t instanceof U && n instanceof se ? U.fromCartesian4(n, t) : n instanceof H || n instanceof h || n instanceof se ? n.clone(t) : n }; _f.prototype.evaluateColor = function (e, t) { bn.reset(); let n = this._runtimeAst.evaluate(e); return U.fromCartesian4(n, t) }; _f.prototype.getShaderFunction = function (e, t, n, i) {
        let o = this.getShaderExpression(t, n); return o = `${i} ${e}
{
    return ${o};
}
`, o
    }; _f.prototype.getShaderExpression = function (e, t) { return this._runtimeAst.getShaderExpression(e, t) }; _f.prototype.getVariables = function () { let e = []; return this._runtimeAst.getVariables(e), e = e.filter(function (t, n, i) { return i.indexOf(t) === n }), e }; var RPe = ["!", "-", "+"], sQ = ["+", "-", "*", "/", "%", "===", "!==", ">", ">=", "<", "<=", "&&", "||", "!~", "=~"], LB = /\${(.*?)}/g, MPe = /\\/g, LPe = "@#%", FPe = /@#%/g, FB = new U, NB = { abs: ls(Math.abs), sqrt: ls(Math.sqrt), cos: ls(Math.cos), sin: ls(Math.sin), tan: ls(Math.tan), acos: ls(Math.acos), asin: ls(Math.asin), atan: ls(Math.atan), radians: ls(I.toRadians), degrees: ls(I.toDegrees), sign: ls(I.sign), floor: ls(Math.floor), ceil: ls(Math.ceil), round: ls(Math.round), exp: ls(Math.exp), exp2: ls(VPe), log: ls(Math.log), log2: ls(kPe), fract: ls(NPe), length: UPe, normalize: zPe }, VB = { atan2: BB(Math.atan2, !1), pow: BB(Math.pow, !1), min: BB(Math.min, !0), max: BB(Math.max, !0), distance: HPe, dot: GPe, cross: WPe }, HG = { clamp: aQ(I.clamp, !0), mix: aQ(I.lerp, !0) }; function NPe(e) { return e - Math.floor(e) } function VPe(e) { return Math.pow(2, e) } function kPe(e) { return I.log2(e) } function ls(e) { return function (t, n) { if (typeof n == "number") return e(n); if (n instanceof H) return H.fromElements(e(n.x), e(n.y), bn.getCartesian2()); if (n instanceof h) return h.fromElements(e(n.x), e(n.y), e(n.z), bn.getCartesian3()); if (n instanceof se) return se.fromElements(e(n.x), e(n.y), e(n.z), e(n.w), bn.getCartesian4()); throw new fe(`Function "${t}" requires a vector or number argument. Argument is ${n}.`) } } function BB(e, t) { return function (n, i, o) { if (t && typeof o == "number") { if (typeof i == "number") return e(i, o); if (i instanceof H) return H.fromElements(e(i.x, o), e(i.y, o), bn.getCartesian2()); if (i instanceof h) return h.fromElements(e(i.x, o), e(i.y, o), e(i.z, o), bn.getCartesian3()); if (i instanceof se) return se.fromElements(e(i.x, o), e(i.y, o), e(i.z, o), e(i.w, o), bn.getCartesian4()) } if (typeof i == "number" && typeof o == "number") return e(i, o); if (i instanceof H && o instanceof H) return H.fromElements(e(i.x, o.x), e(i.y, o.y), bn.getCartesian2()); if (i instanceof h && o instanceof h) return h.fromElements(e(i.x, o.x), e(i.y, o.y), e(i.z, o.z), bn.getCartesian3()); if (i instanceof se && o instanceof se) return se.fromElements(e(i.x, o.x), e(i.y, o.y), e(i.z, o.z), e(i.w, o.w), bn.getCartesian4()); throw new fe(`Function "${n}" requires vector or number arguments of matching types. Arguments are ${i} and ${o}.`) } } function aQ(e, t) { return function (n, i, o, r) { if (t && typeof r == "number") { if (typeof i == "number" && typeof o == "number") return e(i, o, r); if (i instanceof H && o instanceof H) return H.fromElements(e(i.x, o.x, r), e(i.y, o.y, r), bn.getCartesian2()); if (i instanceof h && o instanceof h) return h.fromElements(e(i.x, o.x, r), e(i.y, o.y, r), e(i.z, o.z, r), bn.getCartesian3()); if (i instanceof se && o instanceof se) return se.fromElements(e(i.x, o.x, r), e(i.y, o.y, r), e(i.z, o.z, r), e(i.w, o.w, r), bn.getCartesian4()) } if (typeof i == "number" && typeof o == "number" && typeof r == "number") return e(i, o, r); if (i instanceof H && o instanceof H && r instanceof H) return H.fromElements(e(i.x, o.x, r.x), e(i.y, o.y, r.y), bn.getCartesian2()); if (i instanceof h && o instanceof h && r instanceof h) return h.fromElements(e(i.x, o.x, r.x), e(i.y, o.y, r.y), e(i.z, o.z, r.z), bn.getCartesian3()); if (i instanceof se && o instanceof se && r instanceof se) return se.fromElements(e(i.x, o.x, r.x), e(i.y, o.y, r.y), e(i.z, o.z, r.z), e(i.w, o.w, r.w), bn.getCartesian4()); throw new fe(`Function "${n}" requires vector or number arguments of matching types. Arguments are ${i}, ${o}, and ${r}.`) } } function UPe(e, t) { if (typeof t == "number") return Math.abs(t); if (t instanceof H) return H.magnitude(t); if (t instanceof h) return h.magnitude(t); if (t instanceof se) return se.magnitude(t); throw new fe(`Function "${e}" requires a vector or number argument. Argument is ${t}.`) } function zPe(e, t) { if (typeof t == "number") return 1; if (t instanceof H) return H.normalize(t, bn.getCartesian2()); if (t instanceof h) return h.normalize(t, bn.getCartesian3()); if (t instanceof se) return se.normalize(t, bn.getCartesian4()); throw new fe(`Function "${e}" requires a vector or number argument. Argument is ${t}.`) } function HPe(e, t, n) { if (typeof t == "number" && typeof n == "number") return Math.abs(t - n); if (t instanceof H && n instanceof H) return H.distance(t, n); if (t instanceof h && n instanceof h) return h.distance(t, n); if (t instanceof se && n instanceof se) return se.distance(t, n); throw new fe(`Function "${e}" requires vector or number arguments of matching types. Arguments are ${t} and ${n}.`) } function GPe(e, t, n) { if (typeof t == "number" && typeof n == "number") return t * n; if (t instanceof H && n instanceof H) return H.dot(t, n); if (t instanceof h && n instanceof h) return h.dot(t, n); if (t instanceof se && n instanceof se) return se.dot(t, n); throw new fe(`Function "${e}" requires vector or number arguments of matching types. Arguments are ${t} and ${n}.`) } function WPe(e, t, n) { if (t instanceof h && n instanceof h) return h.cross(t, n, bn.getCartesian3()); throw new fe(`Function "${e}" requires vec3 arguments. Arguments are ${t} and ${n}.`) } function pt(e, t, n, i, o) { this._type = e, this._value = t, this._left = n, this._right = i, this._test = o, this.evaluate = void 0, i1e(this) } function jPe(e, t) { if (!l(t)) return e; for (let n in t) if (t.hasOwnProperty(n)) { let i = new RegExp(`\\$\\{${n}\\}`, "g"), o = `(${t[n]})`; l(o) && (e = e.replace(i, o)) } return e } function qPe(e) { return e.replace(MPe, LPe) } function zG(e) { return e.replace(FPe, "\\") } function YPe(e) { let t = e, n = "", i = t.indexOf("${"); for (; i >= 0;) { let o = t.indexOf("'"), r = t.indexOf('"'), s; if (o >= 0 && o < i) s = t.indexOf("'", o + 1), n += t.substr(0, s + 1), t = t.substr(s + 1), i = t.indexOf("${"); else if (r >= 0 && r < i) s = t.indexOf('"', r + 1), n += t.substr(0, s + 1), t = t.substr(s + 1), i = t.indexOf("${"); else { n += t.substr(0, i); let a = t.indexOf("}"); if (a < 0) throw new fe("Unmatched {."); n += `czm_${t.substr(i + 2, a - (i + 2))}`, t = t.substr(a + 1), i = t.indexOf("${") } } return n += t, n } function XPe(e) { let t = typeof e.value; if (e.value === null) return new pt(ft.LITERAL_NULL, null); if (t === "boolean") return new pt(ft.LITERAL_BOOLEAN, e.value); if (t === "number") return new pt(ft.LITERAL_NUMBER, e.value); if (t === "string") return e.value.indexOf("${") >= 0 ? new pt(ft.VARIABLE_IN_STRING, e.value) : new pt(ft.LITERAL_STRING, zG(e.value)) } function KPe(e, t) { let n = t.arguments, i = n.length, o, r, s, a; if (t.callee.type === "MemberExpression") { o = t.callee.property.name; let c = t.callee.object; if (o === "test" || o === "exec") { if (c.callee.name !== "regExp") throw new fe(`${o} is not a function.`); return i === 0 ? o === "test" ? new pt(ft.LITERAL_BOOLEAN, !1) : new pt(ft.LITERAL_NULL, null) : (s = ci(e, c), a = ci(e, n[0]), new pt(ft.FUNCTION_CALL, o, s, a)) } else if (o === "toString") return r = ci(e, c), new pt(ft.FUNCTION_CALL, o, r); throw new fe(`Unexpected function call "${o}".`) } if (o = t.callee.name, o === "color") { if (i === 0) return new pt(ft.LITERAL_COLOR, o); if (r = ci(e, n[0]), l(n[1])) { let c = ci(e, n[1]); return new pt(ft.LITERAL_COLOR, o, [r, c]) } return new pt(ft.LITERAL_COLOR, o, [r]) } else if (o === "rgb" || o === "hsl") { if (i < 3) throw new fe(`${o} requires three arguments.`); return r = [ci(e, n[0]), ci(e, n[1]), ci(e, n[2])], new pt(ft.LITERAL_COLOR, o, r) } else if (o === "rgba" || o === "hsla") { if (i < 4) throw new fe(`${o} requires four arguments.`); return r = [ci(e, n[0]), ci(e, n[1]), ci(e, n[2]), ci(e, n[3])], new pt(ft.LITERAL_COLOR, o, r) } else if (o === "vec2" || o === "vec3" || o === "vec4") { r = new Array(i); for (let c = 0; c < i; ++c)r[c] = ci(e, n[c]); return new pt(ft.LITERAL_VECTOR, o, r) } else { if (o === "isNaN" || o === "isFinite") return i === 0 ? o === "isNaN" ? new pt(ft.LITERAL_BOOLEAN, !0) : new pt(ft.LITERAL_BOOLEAN, !1) : (r = ci(e, n[0]), new pt(ft.UNARY, o, r)); if (o === "isExactClass" || o === "isClass") { if (i < 1 || i > 1) throw new fe(`${o} requires exactly one argument.`); return r = ci(e, n[0]), new pt(ft.UNARY, o, r) } else if (o === "getExactClassName") { if (i > 0) throw new fe(`${o} does not take any argument.`); return new pt(ft.UNARY, o) } else if (l(NB[o])) { if (i !== 1) throw new fe(`${o} requires exactly one argument.`); return r = ci(e, n[0]), new pt(ft.UNARY, o, r) } else if (l(VB[o])) { if (i !== 2) throw new fe(`${o} requires exactly two arguments.`); return s = ci(e, n[0]), a = ci(e, n[1]), new pt(ft.BINARY, o, s, a) } else if (l(HG[o])) { if (i !== 3) throw new fe(`${o} requires exactly three arguments.`); s = ci(e, n[0]), a = ci(e, n[1]); let c = ci(e, n[2]); return new pt(ft.TERNARY, o, s, a, c) } else { if (o === "Boolean") return i === 0 ? new pt(ft.LITERAL_BOOLEAN, !1) : (r = ci(e, n[0]), new pt(ft.UNARY, o, r)); if (o === "Number") return i === 0 ? new pt(ft.LITERAL_NUMBER, 0) : (r = ci(e, n[0]), new pt(ft.UNARY, o, r)); if (o === "String") return i === 0 ? new pt(ft.LITERAL_STRING, "") : (r = ci(e, n[0]), new pt(ft.UNARY, o, r)); if (o === "regExp") return JPe(e, t) } } throw new fe(`Unexpected function call "${o}".`) } function JPe(e, t) { let n = t.arguments; if (n.length === 0) return new pt(ft.LITERAL_REGEX, new RegExp); let i = ci(e, n[0]), o; if (n.length > 1) { let r = ci(e, n[1]); if (UG(i) && UG(r)) { try { o = new RegExp(zG(String(i._value)), r._value) } catch (s) { throw new fe(s) } return new pt(ft.LITERAL_REGEX, o) } return new pt(ft.REGEX, i, r) } if (UG(i)) { try { o = new RegExp(zG(String(i._value))) } catch (r) { throw new fe(r) } return new pt(ft.LITERAL_REGEX, o) } return new pt(ft.REGEX, i) } function ZPe(e) { if (t1e(e.name)) { let t = n1e(e.name); return t.substr(0, 8) === "tiles3d_" ? new pt(ft.BUILTIN_VARIABLE, t) : new pt(ft.VARIABLE, t) } else { if (e.name === "NaN") return new pt(ft.LITERAL_NUMBER, NaN); if (e.name === "Infinity") return new pt(ft.LITERAL_NUMBER, 1 / 0); if (e.name === "undefined") return new pt(ft.LITERAL_UNDEFINED, void 0) } throw new fe(`${e.name} is not defined.`) } function QPe(e) { let t = e.property.name; if (t === "PI") return new pt(ft.LITERAL_NUMBER, Math.PI); if (t === "E") return new pt(ft.LITERAL_NUMBER, Math.E) } function $Pe(e) { if (e.property.name === "POSITIVE_INFINITY") return new pt(ft.LITERAL_NUMBER, Number.POSITIVE_INFINITY) } function e1e(e, t) { if (t.object.name === "Math") return QPe(t); if (t.object.name === "Number") return $Pe(t); let n, i = ci(e, t.object); return t.computed ? (n = ci(e, t.property), new pt(ft.MEMBER, "brackets", i, n)) : (n = new pt(ft.LITERAL_STRING, t.property.name), new pt(ft.MEMBER, "dot", i, n)) } function UG(e) { return e._type >= ft.LITERAL_NULL } function t1e(e) { return e.substr(0, 4) === "czm_" } function n1e(e) { return e.substr(4) } function ci(e, t) { let n, i, o, r; if (t.type === "Literal") n = XPe(t); else if (t.type === "CallExpression") n = KPe(e, t); else if (t.type === "Identifier") n = ZPe(t); else if (t.type === "UnaryExpression") { i = t.operator; let s = ci(e, t.argument); if (RPe.indexOf(i) > -1) n = new pt(ft.UNARY, i, s); else throw new fe(`Unexpected operator "${i}".`) } else if (t.type === "BinaryExpression") if (i = t.operator, o = ci(e, t.left), r = ci(e, t.right), sQ.indexOf(i) > -1) n = new pt(ft.BINARY, i, o, r); else throw new fe(`Unexpected operator "${i}".`); else if (t.type === "LogicalExpression") i = t.operator, o = ci(e, t.left), r = ci(e, t.right), sQ.indexOf(i) > -1 && (n = new pt(ft.BINARY, i, o, r)); else if (t.type === "ConditionalExpression") { let s = ci(e, t.test); o = ci(e, t.consequent), r = ci(e, t.alternate), n = new pt(ft.CONDITIONAL, "?", o, r, s) } else if (t.type === "MemberExpression") n = e1e(e, t); else if (t.type === "ArrayExpression") { let s = []; for (let a = 0; a < t.elements.length; a++)s[a] = ci(e, t.elements[a]); n = new pt(ft.ARRAY, s) } else throw t.type === "Compound" ? new fe("Provide exactly one expression.") : new fe("Cannot parse expression."); return n } function i1e(e) { e._type === ft.CONDITIONAL ? e.evaluate = e._evaluateConditional : e._type === ft.FUNCTION_CALL ? e._value === "test" ? e.evaluate = e._evaluateRegExpTest : e._value === "exec" ? e.evaluate = e._evaluateRegExpExec : e._value === "toString" && (e.evaluate = e._evaluateToString) : e._type === ft.UNARY ? e._value === "!" ? e.evaluate = e._evaluateNot : e._value === "-" ? e.evaluate = e._evaluateNegative : e._value === "+" ? e.evaluate = e._evaluatePositive : e._value === "isNaN" ? e.evaluate = e._evaluateNaN : e._value === "isFinite" ? e.evaluate = e._evaluateIsFinite : e._value === "isExactClass" ? e.evaluate = e._evaluateIsExactClass : e._value === "isClass" ? e.evaluate = e._evaluateIsClass : e._value === "getExactClassName" ? e.evaluate = e._evaluateGetExactClassName : e._value === "Boolean" ? e.evaluate = e._evaluateBooleanConversion : e._value === "Number" ? e.evaluate = e._evaluateNumberConversion : e._value === "String" ? e.evaluate = e._evaluateStringConversion : l(NB[e._value]) && (e.evaluate = r1e(e._value)) : e._type === ft.BINARY ? e._value === "+" ? e.evaluate = e._evaluatePlus : e._value === "-" ? e.evaluate = e._evaluateMinus : e._value === "*" ? e.evaluate = e._evaluateTimes : e._value === "/" ? e.evaluate = e._evaluateDivide : e._value === "%" ? e.evaluate = e._evaluateMod : e._value === "===" ? e.evaluate = e._evaluateEqualsStrict : e._value === "!==" ? e.evaluate = e._evaluateNotEqualsStrict : e._value === "<" ? e.evaluate = e._evaluateLessThan : e._value === "<=" ? e.evaluate = e._evaluateLessThanOrEquals : e._value === ">" ? e.evaluate = e._evaluateGreaterThan : e._value === ">=" ? e.evaluate = e._evaluateGreaterThanOrEquals : e._value === "&&" ? e.evaluate = e._evaluateAnd : e._value === "||" ? e.evaluate = e._evaluateOr : e._value === "=~" ? e.evaluate = e._evaluateRegExpMatch : e._value === "!~" ? e.evaluate = e._evaluateRegExpNotMatch : l(VB[e._value]) && (e.evaluate = s1e(e._value)) : e._type === ft.TERNARY ? e.evaluate = a1e(e._value) : e._type === ft.MEMBER ? e._value === "brackets" ? e.evaluate = e._evaluateMemberBrackets : e.evaluate = e._evaluateMemberDot : e._type === ft.ARRAY ? e.evaluate = e._evaluateArray : e._type === ft.VARIABLE ? e.evaluate = e._evaluateVariable : e._type === ft.VARIABLE_IN_STRING ? e.evaluate = e._evaluateVariableString : e._type === ft.LITERAL_COLOR ? e.evaluate = e._evaluateLiteralColor : e._type === ft.LITERAL_VECTOR ? e.evaluate = e._evaluateLiteralVector : e._type === ft.LITERAL_STRING ? e.evaluate = e._evaluateLiteralString : e._type === ft.REGEX ? e.evaluate = e._evaluateRegExp : e._type === ft.BUILTIN_VARIABLE ? e._value === "tiles3d_tileset_time" && (e.evaluate = o1e) : e.evaluate = e._evaluateLiteral } function o1e(e) { return l(e) ? e.content.tileset.timeSinceLoad : 0 } function r1e(e) { let t = NB[e]; return function (n) { let i = this._left.evaluate(n); return t(e, i) } } function s1e(e) { let t = VB[e]; return function (n) { let i = this._left.evaluate(n), o = this._right.evaluate(n); return t(e, i, o) } } function a1e(e) { let t = HG[e]; return function (n) { let i = this._left.evaluate(n), o = this._right.evaluate(n), r = this._test.evaluate(n); return t(e, i, o, r) } } function kB(e, t) { if (l(e)) return e.getPropertyInherited(t) } pt.prototype._evaluateLiteral = function () { return this._value }; pt.prototype._evaluateLiteralColor = function (e) { let t = FB, n = this._left; if (this._value === "color") l(n) ? n.length > 1 ? (U.fromCssColorString(n[0].evaluate(e), t), t.alpha = n[1].evaluate(e)) : U.fromCssColorString(n[0].evaluate(e), t) : U.fromBytes(255, 255, 255, 255, t); else if (this._value === "rgb") U.fromBytes(n[0].evaluate(e), n[1].evaluate(e), n[2].evaluate(e), 255, t); else if (this._value === "rgba") { let i = n[3].evaluate(e) * 255; U.fromBytes(n[0].evaluate(e), n[1].evaluate(e), n[2].evaluate(e), i, t) } else this._value === "hsl" ? U.fromHsl(n[0].evaluate(e), n[1].evaluate(e), n[2].evaluate(e), 1, t) : this._value === "hsla" && U.fromHsl(n[0].evaluate(e), n[1].evaluate(e), n[2].evaluate(e), n[3].evaluate(e), t); return se.fromColor(t, bn.getCartesian4()) }; pt.prototype._evaluateLiteralVector = function (e) { let t = bn.getArray(), n = this._value, i = this._left, o = i.length; for (let a = 0; a < o; ++a) { let c = i[a].evaluate(e); if (typeof c == "number") t.push(c); else if (c instanceof H) t.push(c.x, c.y); else if (c instanceof h) t.push(c.x, c.y, c.z); else if (c instanceof se) t.push(c.x, c.y, c.z, c.w); else throw new fe(`${n} argument must be a vector or number. Argument is ${c}.`) } let r = t.length, s = parseInt(n.charAt(3)); if (r === 0) throw new fe(`Invalid ${n} constructor. No valid arguments.`); if (r < s && r > 1) throw new fe(`Invalid ${n} constructor. Not enough arguments.`); if (r > s && o > 1) throw new fe(`Invalid ${n} constructor. Too many arguments.`); if (r === 1) { let a = t[0]; t.push(a, a, a) } if (n === "vec2") return H.fromArray(t, 0, bn.getCartesian2()); if (n === "vec3") return h.fromArray(t, 0, bn.getCartesian3()); if (n === "vec4") return se.fromArray(t, 0, bn.getCartesian4()) }; pt.prototype._evaluateLiteralString = function () { return this._value }; pt.prototype._evaluateVariableString = function (e) { let t = this._value, n = LB.exec(t); for (; n !== null;) { let i = n[0], o = n[1], r = kB(e, o); l(r) || (r = ""), t = t.replace(i, r), n = LB.exec(t) } return t }; pt.prototype._evaluateVariable = function (e) { return kB(e, this._value) }; function I0(e) { return e._value === "feature" } pt.prototype._evaluateMemberDot = function (e) { if (I0(this._left)) return kB(e, this._right.evaluate(e)); let t = this._left.evaluate(e); if (!l(t)) return; let n = this._right.evaluate(e); if (t instanceof H || t instanceof h || t instanceof se) { if (n === "r") return t.x; if (n === "g") return t.y; if (n === "b") return t.z; if (n === "a") return t.w } return t[n] }; pt.prototype._evaluateMemberBrackets = function (e) { if (I0(this._left)) return kB(e, this._right.evaluate(e)); let t = this._left.evaluate(e); if (!l(t)) return; let n = this._right.evaluate(e); if (t instanceof H || t instanceof h || t instanceof se) { if (n === 0 || n === "r") return t.x; if (n === 1 || n === "g") return t.y; if (n === 2 || n === "b") return t.z; if (n === 3 || n === "a") return t.w } return t[n] }; pt.prototype._evaluateArray = function (e) { let t = []; for (let n = 0; n < this._value.length; n++)t[n] = this._value[n].evaluate(e); return t }; pt.prototype._evaluateNot = function (e) { let t = this._left.evaluate(e); if (typeof t != "boolean") throw new fe(`Operator "!" requires a boolean argument. Argument is ${t}.`); return !t }; pt.prototype._evaluateNegative = function (e) { let t = this._left.evaluate(e); if (t instanceof H) return H.negate(t, bn.getCartesian2()); if (t instanceof h) return h.negate(t, bn.getCartesian3()); if (t instanceof se) return se.negate(t, bn.getCartesian4()); if (typeof t == "number") return -t; throw new fe(`Operator "-" requires a vector or number argument. Argument is ${t}.`) }; pt.prototype._evaluatePositive = function (e) { let t = this._left.evaluate(e); if (!(t instanceof H || t instanceof h || t instanceof se || typeof t == "number")) throw new fe(`Operator "+" requires a vector or number argument. Argument is ${t}.`); return t }; pt.prototype._evaluateLessThan = function (e) { let t = this._left.evaluate(e), n = this._right.evaluate(e); if (typeof t != "number" || typeof n != "number") throw new fe(`Operator "<" requires number arguments. Arguments are ${t} and ${n}.`); return t < n }; pt.prototype._evaluateLessThanOrEquals = function (e) { let t = this._left.evaluate(e), n = this._right.evaluate(e); if (typeof t != "number" || typeof n != "number") throw new fe(`Operator "<=" requires number arguments. Arguments are ${t} and ${n}.`); return t <= n }; pt.prototype._evaluateGreaterThan = function (e) { let t = this._left.evaluate(e), n = this._right.evaluate(e); if (typeof t != "number" || typeof n != "number") throw new fe(`Operator ">" requires number arguments. Arguments are ${t} and ${n}.`); return t > n }; pt.prototype._evaluateGreaterThanOrEquals = function (e) { let t = this._left.evaluate(e), n = this._right.evaluate(e); if (typeof t != "number" || typeof n != "number") throw new fe(`Operator ">=" requires number arguments. Arguments are ${t} and ${n}.`); return t >= n }; pt.prototype._evaluateOr = function (e) { let t = this._left.evaluate(e); if (typeof t != "boolean") throw new fe(`Operator "||" requires boolean arguments. First argument is ${t}.`); if (t) return !0; let n = this._right.evaluate(e); if (typeof n != "boolean") throw new fe(`Operator "||" requires boolean arguments. Second argument is ${n}.`); return t || n }; pt.prototype._evaluateAnd = function (e) { let t = this._left.evaluate(e); if (typeof t != "boolean") throw new fe(`Operator "&&" requires boolean arguments. First argument is ${t}.`); if (!t) return !1; let n = this._right.evaluate(e); if (typeof n != "boolean") throw new fe(`Operator "&&" requires boolean arguments. Second argument is ${n}.`); return t && n }; pt.prototype._evaluatePlus = function (e) { let t = this._left.evaluate(e), n = this._right.evaluate(e); if (n instanceof H && t instanceof H) return H.add(t, n, bn.getCartesian2()); if (n instanceof h && t instanceof h) return h.add(t, n, bn.getCartesian3()); if (n instanceof se && t instanceof se) return se.add(t, n, bn.getCartesian4()); if (typeof t == "string" || typeof n == "string") return t + n; if (typeof t == "number" && typeof n == "number") return t + n; throw new fe(`Operator "+" requires vector or number arguments of matching types, or at least one string argument. Arguments are ${t} and ${n}.`) }; pt.prototype._evaluateMinus = function (e) { let t = this._left.evaluate(e), n = this._right.evaluate(e); if (n instanceof H && t instanceof H) return H.subtract(t, n, bn.getCartesian2()); if (n instanceof h && t instanceof h) return h.subtract(t, n, bn.getCartesian3()); if (n instanceof se && t instanceof se) return se.subtract(t, n, bn.getCartesian4()); if (typeof t == "number" && typeof n == "number") return t - n; throw new fe(`Operator "-" requires vector or number arguments of matching types. Arguments are ${t} and ${n}.`) }; pt.prototype._evaluateTimes = function (e) { let t = this._left.evaluate(e), n = this._right.evaluate(e); if (n instanceof H && t instanceof H) return H.multiplyComponents(t, n, bn.getCartesian2()); if (n instanceof H && typeof t == "number") return H.multiplyByScalar(n, t, bn.getCartesian2()); if (t instanceof H && typeof n == "number") return H.multiplyByScalar(t, n, bn.getCartesian2()); if (n instanceof h && t instanceof h) return h.multiplyComponents(t, n, bn.getCartesian3()); if (n instanceof h && typeof t == "number") return h.multiplyByScalar(n, t, bn.getCartesian3()); if (t instanceof h && typeof n == "number") return h.multiplyByScalar(t, n, bn.getCartesian3()); if (n instanceof se && t instanceof se) return se.multiplyComponents(t, n, bn.getCartesian4()); if (n instanceof se && typeof t == "number") return se.multiplyByScalar(n, t, bn.getCartesian4()); if (t instanceof se && typeof n == "number") return se.multiplyByScalar(t, n, bn.getCartesian4()); if (typeof t == "number" && typeof n == "number") return t * n; throw new fe(`Operator "*" requires vector or number arguments. If both arguments are vectors they must be matching types. Arguments are ${t} and ${n}.`) }; pt.prototype._evaluateDivide = function (e) { let t = this._left.evaluate(e), n = this._right.evaluate(e); if (n instanceof H && t instanceof H) return H.divideComponents(t, n, bn.getCartesian2()); if (t instanceof H && typeof n == "number") return H.divideByScalar(t, n, bn.getCartesian2()); if (n instanceof h && t instanceof h) return h.divideComponents(t, n, bn.getCartesian3()); if (t instanceof h && typeof n == "number") return h.divideByScalar(t, n, bn.getCartesian3()); if (n instanceof se && t instanceof se) return se.divideComponents(t, n, bn.getCartesian4()); if (t instanceof se && typeof n == "number") return se.divideByScalar(t, n, bn.getCartesian4()); if (typeof t == "number" && typeof n == "number") return t / n; throw new fe(`Operator "/" requires vector or number arguments of matching types, or a number as the second argument. Arguments are ${t} and ${n}.`) }; pt.prototype._evaluateMod = function (e) { let t = this._left.evaluate(e), n = this._right.evaluate(e); if (n instanceof H && t instanceof H) return H.fromElements(t.x % n.x, t.y % n.y, bn.getCartesian2()); if (n instanceof h && t instanceof h) return h.fromElements(t.x % n.x, t.y % n.y, t.z % n.z, bn.getCartesian3()); if (n instanceof se && t instanceof se) return se.fromElements(t.x % n.x, t.y % n.y, t.z % n.z, t.w % n.w, bn.getCartesian4()); if (typeof t == "number" && typeof n == "number") return t % n; throw new fe(`Operator "%" requires vector or number arguments of matching types. Arguments are ${t} and ${n}.`) }; pt.prototype._evaluateEqualsStrict = function (e) { let t = this._left.evaluate(e), n = this._right.evaluate(e); return n instanceof H && t instanceof H || n instanceof h && t instanceof h || n instanceof se && t instanceof se ? t.equals(n) : t === n }; pt.prototype._evaluateNotEqualsStrict = function (e) { let t = this._left.evaluate(e), n = this._right.evaluate(e); return n instanceof H && t instanceof H || n instanceof h && t instanceof h || n instanceof se && t instanceof se ? !t.equals(n) : t !== n }; pt.prototype._evaluateConditional = function (e) { let t = this._test.evaluate(e); if (typeof t != "boolean") throw new fe(`Conditional argument of conditional expression must be a boolean. Argument is ${t}.`); return t ? this._left.evaluate(e) : this._right.evaluate(e) }; pt.prototype._evaluateNaN = function (e) { return isNaN(this._left.evaluate(e)) }; pt.prototype._evaluateIsFinite = function (e) { return isFinite(this._left.evaluate(e)) }; pt.prototype._evaluateIsExactClass = function (e) { return l(e) ? e.isExactClass(this._left.evaluate(e)) : !1 }; pt.prototype._evaluateIsClass = function (e) { return l(e) ? e.isClass(this._left.evaluate(e)) : !1 }; pt.prototype._evaluateGetExactClassName = function (e) { if (l(e)) return e.getExactClassName() }; pt.prototype._evaluateBooleanConversion = function (e) { return Boolean(this._left.evaluate(e)) }; pt.prototype._evaluateNumberConversion = function (e) { return Number(this._left.evaluate(e)) }; pt.prototype._evaluateStringConversion = function (e) { return String(this._left.evaluate(e)) }; pt.prototype._evaluateRegExp = function (e) { let t = this._value.evaluate(e), n = ""; l(this._left) && (n = this._left.evaluate(e)); let i; try { i = new RegExp(t, n) } catch (o) { throw new fe(o) } return i }; pt.prototype._evaluateRegExpTest = function (e) { let t = this._left.evaluate(e), n = this._right.evaluate(e); if (!(t instanceof RegExp && typeof n == "string")) throw new fe(`RegExp.test requires the first argument to be a RegExp and the second argument to be a string. Arguments are ${t} and ${n}.`); return t.test(n) }; pt.prototype._evaluateRegExpMatch = function (e) { let t = this._left.evaluate(e), n = this._right.evaluate(e); if (t instanceof RegExp && typeof n == "string") return t.test(n); if (n instanceof RegExp && typeof t == "string") return n.test(t); throw new fe(`Operator "=~" requires one RegExp argument and one string argument. Arguments are ${t} and ${n}.`) }; pt.prototype._evaluateRegExpNotMatch = function (e) { let t = this._left.evaluate(e), n = this._right.evaluate(e); if (t instanceof RegExp && typeof n == "string") return !t.test(n); if (n instanceof RegExp && typeof t == "string") return !n.test(t); throw new fe(`Operator "!~" requires one RegExp argument and one string argument. Arguments are ${t} and ${n}.`) }; pt.prototype._evaluateRegExpExec = function (e) { let t = this._left.evaluate(e), n = this._right.evaluate(e); if (!(t instanceof RegExp && typeof n == "string")) throw new fe(`RegExp.exec requires the first argument to be a RegExp and the second argument to be a string. Arguments are ${t} and ${n}.`); let i = t.exec(n); return l(i) ? i[1] : null }; pt.prototype._evaluateToString = function (e) { let t = this._left.evaluate(e); if (t instanceof RegExp || t instanceof H || t instanceof h || t instanceof se) return String(t); throw new fe(`Unexpected function call "${this._value}".`) }; function cQ(e) { let t = e._left, n = t.length; for (let a = 0; a < n; ++a)if (t[a]._type !== ft.LITERAL_NUMBER) return; let i = t[0]._value, o = t[1]._value, r = t[2]._value, s = n === 4 ? t[3]._value : 1; return U.fromHsl(i, o, r, s, FB) } function lQ(e) { let t = e._left, n = t.length; for (let o = 0; o < n; ++o)if (t[o]._type !== ft.LITERAL_NUMBER) return; let i = FB; return i.red = t[0]._value / 255, i.green = t[1]._value / 255, i.blue = t[2]._value / 255, i.alpha = n === 4 ? t[3]._value : 1, i } function Kp(e) { return e % 1 === 0 ? e.toFixed(1) : e.toString() } function c1e(e) { let t = Kp(e.red), n = Kp(e.green), i = Kp(e.blue); return `vec3(${t}, ${n}, ${i})` } function RB(e) { let t = Kp(e.red), n = Kp(e.green), i = Kp(e.blue), o = Kp(e.alpha); return `vec4(${t}, ${n}, ${i}, ${o})` } function uQ(e, t, n, i) { let o = e.length, r = new Array(o); for (let s = 0; s < o; ++s)r[s] = e[s].getShaderExpression(t, n, i); return r } function fQ(e, t) { return l(t[e]) ? t[e] : _f.NULL_SENTINEL } _f.NULL_SENTINEL = "czm_infinity"; pt.prototype.getShaderExpression = function (e, t, n) { let i, o, r, s, a = this._type, c = this._value; l(this._left) && (Array.isArray(this._left) ? o = uQ(this._left, e, t, this) : o = this._left.getShaderExpression(e, t, this)), l(this._right) && (r = this._right.getShaderExpression(e, t, this)), l(this._test) && (s = this._test.getShaderExpression(e, t, this)), Array.isArray(this._value) && (c = uQ(this._value, e, t, this)); let u, f, d; switch (a) { case ft.VARIABLE: return I0(this) ? void 0 : fQ(c, e); case ft.UNARY: if (c === "Boolean") return `bool(${o})`; if (c === "Number") return `float(${o})`; if (c === "round") return `floor(${o} + 0.5)`; if (l(NB[c])) return `${c}(${o})`; if (c === "isNaN") return `(${o} != ${o})`; if (c === "isFinite") return `(abs(${o}) < czm_infinity)`; if (c === "String" || c === "isExactClass" || c === "isClass" || c === "getExactClassName") throw new fe(`Error generating style shader: "${c}" is not supported.`); return c + o; case ft.BINARY: return c === "%" ? `mod(${o}, ${r})` : c === "===" ? `(${o} == ${r})` : c === "!==" ? `(${o} != ${r})` : c === "atan2" ? `atan(${o}, ${r})` : l(VB[c]) ? `${c}(${o}, ${r})` : `(${o} ${c} ${r})`; case ft.TERNARY: if (l(HG[c])) return `${c}(${o}, ${r}, ${s})`; break; case ft.CONDITIONAL: return `(${s} ? ${o} : ${r})`; case ft.MEMBER: return I0(this._left) ? fQ(r, e) : r === "r" || r === "x" || r === "0.0" ? `${o}[0]` : r === "g" || r === "y" || r === "1.0" ? `${o}[1]` : r === "b" || r === "z" || r === "2.0" ? `${o}[2]` : r === "a" || r === "w" || r === "3.0" ? `${o}[3]` : `${o}[int(${r})]`; case ft.FUNCTION_CALL: throw new fe(`Error generating style shader: "${c}" is not supported.`); case ft.ARRAY: if (c.length === 4) return `vec4(${c[0]}, ${c[1]}, ${c[2]}, ${c[3]})`; if (c.length === 3) return `vec3(${c[0]}, ${c[1]}, ${c[2]})`; if (c.length === 2) return `vec2(${c[0]}, ${c[1]})`; throw new fe("Error generating style shader: Invalid array length. Array length should be 2, 3, or 4."); case ft.REGEX: throw new fe("Error generating style shader: Regular expressions are not supported."); case ft.VARIABLE_IN_STRING: throw new fe("Error generating style shader: Converting a variable to a string is not supported."); case ft.LITERAL_NULL: return _f.NULL_SENTINEL; case ft.LITERAL_BOOLEAN: return c ? "true" : "false"; case ft.LITERAL_NUMBER: return Kp(c); case ft.LITERAL_STRING: if (l(n) && n._type === ft.MEMBER && (c === "r" || c === "g" || c === "b" || c === "a" || c === "x" || c === "y" || c === "z" || c === "w" || I0(n._left))) return c; if (i = U.fromCssColorString(c, FB), l(i)) return c1e(i); throw new fe("Error generating style shader: String literals are not supported."); case ft.LITERAL_COLOR: if (u = o, c === "color") { if (l(u)) { if (u.length > 1) { let p = u[0], g = u[1]; return g !== "1.0" && (t.translucent = !0), `vec4(${p}, ${g})` } } else return "vec4(1.0)"; return `vec4(${u[0]}, 1.0)` } else { if (c === "rgb") return i = lQ(this), l(i) ? RB(i) : `vec4(${u[0]} / 255.0, ${u[1]} / 255.0, ${u[2]} / 255.0, 1.0)`; if (c === "rgba") return u[3] !== "1.0" && (t.translucent = !0), i = lQ(this), l(i) ? RB(i) : `vec4(${u[0]} / 255.0, ${u[1]} / 255.0, ${u[2]} / 255.0, ${u[3]})`; if (c === "hsl") return i = cQ(this), l(i) ? RB(i) : `vec4(czm_HSLToRGB(vec3(${u[0]}, ${u[1]}, ${u[2]})), 1.0)`; if (c === "hsla") return i = cQ(this), l(i) ? (i.alpha !== 1 && (t.translucent = !0), RB(i)) : (u[3] !== "1.0" && (t.translucent = !0), `vec4(czm_HSLToRGB(vec3(${u[0]}, ${u[1]}, ${u[2]})), ${u[3]})`) } break; case ft.LITERAL_VECTOR: f = o.length, d = `${c}(`; for (let p = 0; p < f; ++p)d += o[p], p < f - 1 && (d += ", "); return d += ")", d; case ft.LITERAL_REGEX: throw new fe("Error generating style shader: Regular expressions are not supported."); case ft.LITERAL_UNDEFINED: return _f.NULL_SENTINEL; case ft.BUILTIN_VARIABLE: if (c === "tiles3d_tileset_time") return c } }; pt.prototype.getVariables = function (e, t) { let n, i, o, r = this._type, s = this._value; if (l(this._left)) if (Array.isArray(this._left)) for (n = this._left, i = n.length, o = 0; o < i; ++o)n[o].getVariables(e, this); else this._left.getVariables(e, this); if (l(this._right) && this._right.getVariables(e, this), l(this._test) && this._test.getVariables(e, this), Array.isArray(this._value)) for (n = this._value, i = n.length, o = 0; o < i; ++o)n[o].getVariables(e, this); let a; switch (r) { case ft.VARIABLE: I0(this) || e.push(s); break; case ft.VARIABLE_IN_STRING: for (a = LB.exec(s); a !== null;)e.push(a[1]), a = LB.exec(s); break; case ft.LITERAL_STRING: l(t) && t._type === ft.MEMBER && I0(t._left) && e.push(s); break } }; var gf = _f; function pm(e) { e = y(e, y.EMPTY_OBJECT), this._batchTable = e.batchTable, this._batchIds = e.batchIds, this._positions = e.positions, this._vertexBatchIds = e.vertexBatchIds, this._indices = e.indices, this._indexCounts = e.indexCounts, this._indexOffsets = e.indexOffsets, this._batchedIndices = e.batchedIndices, this._boundingVolume = e.boundingVolume, this._boundingVolumes = e.boundingVolumes, this._center = y(e.center, h.ZERO), this._va = void 0, this._sp = void 0, this._spStencil = void 0, this._spPick = void 0, this._uniformMap = void 0, this._vaSwap = void 0, this._rsStencilDepthPass = void 0, this._rsStencilDepthPass3DTiles = void 0, this._rsColorPass = void 0, this._rsPickPass = void 0, this._rsWireframe = void 0, this._commands = [], this._commandsIgnoreShow = [], this._pickCommands = [], this._constantColor = U.clone(U.WHITE), this._highlightColor = this._constantColor, this._batchDirty = !0, this._pickCommandsDirty = !0, this._framesSinceLastRebatch = 0, this._updatingAllCommands = !1, this._trianglesLength = this._indices.length / 3, this._geometryByteLength = this._indices.byteLength + this._positions.byteLength + this._vertexBatchIds.byteLength, this.debugWireframe = !1, this._debugWireframe = this.debugWireframe, this._wireframeDirty = !1, this.forceRebatch = !1, this.classificationType = y(e.classificationType, Ln.BOTH), this._vertexShaderSource = e._vertexShaderSource, this._fragmentShaderSource = e._fragmentShaderSource, this._attributeLocations = e._attributeLocations, this._uniformMap = e._uniformMap, this._pickId = e._pickId, this._modelMatrix = e._modelMatrix, this._boundingSphere = e._boundingSphere, this._batchIdLookUp = {}; let t = this._batchIds.length; for (let n = 0; n < t; ++n) { let i = this._batchIds[n]; this._batchIdLookUp[i] = n } } Object.defineProperties(pm.prototype, { trianglesLength: { get: function () { return this._trianglesLength } }, geometryByteLength: { get: function () { return this._geometryByteLength } } }); var l1e = { position: 0, a_batchId: 1 }; function u1e(e, t) { if (l(e._va)) return; let n = ct.createVertexBuffer({ context: t, typedArray: e._positions, usage: Re.STATIC_DRAW }), i = ct.createVertexBuffer({ context: t, typedArray: e._vertexBatchIds, usage: Re.STATIC_DRAW }), o = ct.createIndexBuffer({ context: t, typedArray: e._indices, usage: Re.DYNAMIC_DRAW, indexDatatype: e._indices.BYTES_PER_ELEMENT === 2 ? Me.UNSIGNED_SHORT : Me.UNSIGNED_INT }), r = [{ index: 0, vertexBuffer: n, componentDatatype: Y.fromTypedArray(e._positions), componentsPerAttribute: 3 }, { index: 1, vertexBuffer: i, componentDatatype: Y.fromTypedArray(e._vertexBatchIds), componentsPerAttribute: 1 }]; e._va = new Qn({ context: t, attributes: r, indexBuffer: o }), t.webgl2 && (e._vaSwap = new Qn({ context: t, attributes: r, indexBuffer: ct.createIndexBuffer({ context: t, sizeInBytes: o.sizeInBytes, usage: Re.DYNAMIC_DRAW, indexDatatype: o.indexDatatype }) })), e._batchedPositions = void 0, e._transferrableBatchIds = void 0, e._vertexBatchIds = void 0, e._verticesPromise = void 0 } function f1e(e, t) {
        if (l(e._sp)) return; let n = e._batchTable, i = y(e._attributeLocations, l1e), o = e._pickId, r = e._vertexShaderSource, s = e._fragmentShaderSource; if (l(r)) {
            e._sp = qt.fromCache({ context: t, vertexShaderSource: r, fragmentShaderSource: s, attributeLocations: i }), e._spStencil = e._sp, s = Ue.replaceMain(s, "czm_non_pick_main"), s = `${s}void main() 
{ 
    czm_non_pick_main(); 
    gl_FragColor = ${o}; 
} 
`, e._spPick = qt.fromCache({ context: t, vertexShaderSource: r, fragmentShaderSource: s, attributeLocations: i }); return
        } let a = n.getVertexShaderCallback(!1, "a_batchId", void 0)(nS), c = n.getFragmentShaderCallback(!1, void 0, !0)(_0); o = n.getPickId(); let u = new Ue({ sources: [a] }), f = new Ue({ defines: ["VECTOR_TILE"], sources: [c] }); e._sp = qt.fromCache({ context: t, vertexShaderSource: u, fragmentShaderSource: f, attributeLocations: i }), u = new Ue({ sources: [nS] }), f = new Ue({ defines: ["VECTOR_TILE"], sources: [_0] }), e._spStencil = qt.fromCache({ context: t, vertexShaderSource: u, fragmentShaderSource: f, attributeLocations: i }), c = Ue.replaceMain(c, "czm_non_pick_main"), c = `${c}
void main() 
{ 
    czm_non_pick_main(); 
    gl_FragColor = ${o}; 
} 
`; let d = new Ue({ sources: [a] }), p = new Ue({ defines: ["VECTOR_TILE"], sources: [c] }); e._spPick = qt.fromCache({ context: t, vertexShaderSource: d, fragmentShaderSource: p, attributeLocations: i })
    } function dQ(e) { let t = e ? Fn.EQUAL : Fn.ALWAYS; return { colorMask: { red: !1, green: !1, blue: !1, alpha: !1 }, stencilTest: { enabled: !0, frontFunction: t, frontOperation: { fail: lt.KEEP, zFail: lt.DECREMENT_WRAP, zPass: lt.KEEP }, backFunction: t, backOperation: { fail: lt.KEEP, zFail: lt.INCREMENT_WRAP, zPass: lt.KEEP }, reference: vt.CESIUM_3D_TILE_MASK, mask: vt.CESIUM_3D_TILE_MASK }, stencilMask: vt.CLASSIFICATION_MASK, depthTest: { enabled: !0, func: Ja.LESS_OR_EQUAL }, depthMask: !1 } } var d1e = { stencilTest: { enabled: !0, frontFunction: Fn.NOT_EQUAL, frontOperation: { fail: lt.ZERO, zFail: lt.ZERO, zPass: lt.ZERO }, backFunction: Fn.NOT_EQUAL, backOperation: { fail: lt.ZERO, zFail: lt.ZERO, zPass: lt.ZERO }, reference: 0, mask: vt.CLASSIFICATION_MASK }, stencilMask: vt.CLASSIFICATION_MASK, depthTest: { enabled: !1 }, depthMask: !1, blending: an.PRE_MULTIPLIED_ALPHA_BLEND }, h1e = { stencilTest: { enabled: !0, frontFunction: Fn.NOT_EQUAL, frontOperation: { fail: lt.ZERO, zFail: lt.ZERO, zPass: lt.ZERO }, backFunction: Fn.NOT_EQUAL, backOperation: { fail: lt.ZERO, zFail: lt.ZERO, zPass: lt.ZERO }, reference: 0, mask: vt.CLASSIFICATION_MASK }, stencilMask: vt.CLASSIFICATION_MASK, depthTest: { enabled: !1 }, depthMask: !1 }; function m1e(e) { l(e._rsStencilDepthPass) || (e._rsStencilDepthPass = Ve.fromCache(dQ(!1)), e._rsStencilDepthPass3DTiles = Ve.fromCache(dQ(!0)), e._rsColorPass = Ve.fromCache(d1e), e._rsPickPass = Ve.fromCache(h1e)) } var O0 = new F, hQ = new h; function p1e(e, t) { if (l(e._uniformMap)) return; let n = { u_modifiedModelViewProjection: function () { let i = t.uniformState.view, o = t.uniformState.projection; return F.clone(i, O0), F.multiplyByPoint(O0, e._center, hQ), F.setTranslation(O0, hQ, O0), F.multiply(o, O0, O0), O0 }, u_highlightColor: function () { return e._highlightColor } }; e._uniformMap = e._batchTable.getUniformMapCallback()(n) } function GG(e, t, n, i, o, r, s) { let a = e.constructor.BYTES_PER_ELEMENT, c = r.length; for (let u = 0; u < c; ++u) { let f = r[u], d = s[f], p = i[d], g = o[d], m = new e.constructor(e.buffer, a * p, g); t.set(m, n), i[d] = n, n += g } return n } function _1e(e, t) { let n = e._indices, i = e._indexOffsets, o = e._indexCounts, r = e._batchIdLookUp, s = new n.constructor(n.length), a = t.pop(), c = [a], u = GG(n, s, 0, i, o, a.batchIds, r); for (a.offset = 0, a.count = u; t.length > 0;) { let f = t.pop(); if (U.equals(f.color, a.color)) u = GG(n, s, u, i, o, f.batchIds, r), a.batchIds = a.batchIds.concat(f.batchIds), a.count = u - a.offset; else { let d = u; u = GG(n, s, u, i, o, f.batchIds, r), f.offset = d, f.count = u - d, c.push(f), a = f } } e._va.indexBuffer.copyFromArrayView(s), e._indices = s, e._batchedIndices = c } function WG(e, t, n, i, o, r, s) { let a = e.bytesPerIndex, c = r.length; for (let u = 0; u < c; ++u) { let f = r[u], d = s[f], p = i[d], g = o[d]; t.copyFromBuffer(e, p * a, n * a, g * a), i[d] = n, n += g } return n } function g1e(e, t) { let n = e._indexOffsets, i = e._indexCounts, o = e._batchIdLookUp, r = t.pop(), s = [r], a = e._va.indexBuffer, c = e._vaSwap.indexBuffer, u = WG(a, c, 0, n, i, r.batchIds, o); for (r.offset = 0, r.count = u; t.length > 0;) { let d = t.pop(); if (U.equals(d.color, r.color)) u = WG(a, c, u, n, i, d.batchIds, o), r.batchIds = r.batchIds.concat(d.batchIds), r.count = u - r.offset; else { let p = u; u = WG(a, c, u, n, i, d.batchIds, o), d.offset = p, d.count = u - p, s.push(d), r = d } } let f = e._va; e._va = e._vaSwap, e._vaSwap = f, e._batchedIndices = s } function y1e(e, t) { return t.color.toRgba() - e.color.toRgba() } function A1e(e, t) { if (!e._batchDirty) return !1; let n = e._batchedIndices, i = n.length, o = !1, r = {}; for (let s = 0; s < i; ++s) { let c = n[s].color.toRgba(); if (l(r[c])) { o = !0; break } else r[c] = !0 } if (!o) return e._batchDirty = !1, !1; if (o && !e.forceRebatch && e._framesSinceLastRebatch < 120) { ++e._framesSinceLastRebatch; return } return n.sort(y1e), t.webgl2 ? g1e(e, n) : _1e(e, n), e._framesSinceLastRebatch = 0, e._batchDirty = !1, e._pickCommandsDirty = !0, e._wireframeDirty = !0, !0 } function C1e(e, t) { let n = A1e(e, t), i = e._commands, o = e._batchedIndices, r = o.length, s = r * 2; if (l(i) && !n && i.length === s) return; i.length = s; let a = e._va, c = e._sp, u = y(e._modelMatrix, F.IDENTITY), f = e._uniformMap, d = e._boundingVolume; for (let p = 0; p < r; ++p) { let g = o[p].offset, m = o[p].count, A = i[p * 2]; l(A) || (A = i[p * 2] = new $e({ owner: e })), A.vertexArray = a, A.modelMatrix = u, A.offset = g, A.count = m, A.renderState = e._rsStencilDepthPass, A.shaderProgram = c, A.uniformMap = f, A.boundingVolume = d, A.cull = !1, A.pass = xe.TERRAIN_CLASSIFICATION; let C = $e.shallowClone(A, A.derivedCommands.tileset); C.renderState = e._rsStencilDepthPass3DTiles, C.pass = xe.CESIUM_3D_TILE_CLASSIFICATION, A.derivedCommands.tileset = C; let x = i[p * 2 + 1]; l(x) || (x = i[p * 2 + 1] = new $e({ owner: e })), x.vertexArray = a, x.modelMatrix = u, x.offset = g, x.count = m, x.renderState = e._rsColorPass, x.shaderProgram = c, x.uniformMap = f, x.boundingVolume = d, x.cull = !1, x.pass = xe.TERRAIN_CLASSIFICATION; let T = $e.shallowClone(x, x.derivedCommands.tileset); T.pass = xe.CESIUM_3D_TILE_CLASSIFICATION, x.derivedCommands.tileset = T } e._commandsDirty = !0 } function x1e(e, t) { if (e.classificationType === Ln.TERRAIN || !t.invertClassification || l(e._commandsIgnoreShow) && !e._commandsDirty) return; let n = e._commands, i = e._commandsIgnoreShow, o = e._spStencil, r = n.length, s = i.length = r / 2, a = 0; for (let c = 0; c < s; ++c) { let u = i[c] = $e.shallowClone(n[a], i[c]); u.shaderProgram = o, u.pass = xe.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW, a += 2 } e._commandsDirty = !1 } function T1e(e) { if (!e._pickCommandsDirty) return; let t = e._indexOffsets.length, n = e._pickCommands; n.length = t * 2; let i = e._va, o = e._spStencil, r = e._spPick, s = y(e._modelMatrix, F.IDENTITY), a = e._uniformMap; for (let c = 0; c < t; ++c) { let u = e._indexOffsets[c], f = e._indexCounts[c], d = l(e._boundingVolumes) ? e._boundingVolumes[c] : e.boundingVolume, p = n[c * 2]; l(p) || (p = n[c * 2] = new $e({ owner: e, pickOnly: !0 })), p.vertexArray = i, p.modelMatrix = s, p.offset = u, p.count = f, p.renderState = e._rsStencilDepthPass, p.shaderProgram = o, p.uniformMap = a, p.boundingVolume = d, p.pass = xe.TERRAIN_CLASSIFICATION; let g = $e.shallowClone(p, p.derivedCommands.tileset); g.renderState = e._rsStencilDepthPass3DTiles, g.pass = xe.CESIUM_3D_TILE_CLASSIFICATION, p.derivedCommands.tileset = g; let m = n[c * 2 + 1]; l(m) || (m = n[c * 2 + 1] = new $e({ owner: e, pickOnly: !0 })), m.vertexArray = i, m.modelMatrix = s, m.offset = u, m.count = f, m.renderState = e._rsPickPass, m.shaderProgram = r, m.uniformMap = a, m.boundingVolume = d, m.pass = xe.TERRAIN_CLASSIFICATION; let A = $e.shallowClone(m, m.derivedCommands.tileset); A.pass = xe.CESIUM_3D_TILE_CLASSIFICATION, m.derivedCommands.tileset = A } e._pickCommandsDirty = !1 } pm.prototype.createFeatures = function (e, t) { let n = this._batchIds, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; t[r] = new xs(e, r) } }; pm.prototype.applyDebugSettings = function (e, t) { this._highlightColor = e ? t : this._constantColor }; function E1e(e, t) { e._updatingAllCommands = !0; let n = e._batchIds, i = n.length, o; for (o = 0; o < i; ++o) { let s = n[o], a = t[s]; a.show = !0, a.color = U.WHITE } let r = e._batchedIndices; for (i = r.length, o = 0; o < i; ++o)r[o].color = U.clone(U.WHITE); e._updatingAllCommands = !1, e._batchDirty = !0 } var b1e = new U, S1e = U.WHITE, w1e = !0, D1e = /\$/; pm.prototype.applyStyle = function (e, t) { if (!l(e)) { E1e(this, t); return } let n = e.color, i = n instanceof gf && !D1e.test(n.expression); this._updatingAllCommands = i; let o = this._batchIds, r = o.length, s; for (s = 0; s < r; ++s) { let a = o[s], c = t[a]; c.color = l(e.color) ? e.color.evaluateColor(c, b1e) : S1e, c.show = l(e.show) ? e.show.evaluate(c) : w1e } if (i) { let a = this._batchedIndices; for (r = a.length, s = 0; s < r; ++s)a[s].color = U.clone(U.WHITE); this._updatingAllCommands = !1, this._batchDirty = !0 } }; pm.prototype.updateCommands = function (e, t) { if (this._updatingAllCommands) return; let n = this._batchIdLookUp, i = n[e]; if (!l(i)) return; let o = this._indexOffsets, r = this._indexCounts, s = o[i], a = r[i], c = this._batchedIndices, u = c.length, f; for (f = 0; f < u; ++f) { let A = c[f].offset, C = c[f].count; if (s >= A && s < A + C) break } c.push(new mm({ color: U.clone(t), offset: s, count: a, batchIds: [e] })); let d = [], p = [], g = c[f].batchIds, m = g.length; for (let A = 0; A < m; ++A) { let C = g[A]; if (C === e) continue; let x = n[C]; o[x] < s ? d.push(C) : p.push(C) } p.length !== 0 && c.push(new mm({ color: U.clone(c[f].color), offset: s + a, count: c[f].offset + c[f].count - (s + a), batchIds: p })), d.length !== 0 ? (c[f].count = s - c[f].offset, c[f].batchIds = d) : c.splice(f, 1), this._batchDirty = !0 }; function mQ(e, t, n, i) { let o = e.classificationType, r = o !== Ln.CESIUM_3D_TILE, s = o !== Ln.TERRAIN, a = t.commandList, c = n.length, u, f; for (f = 0; f < c; ++f)r && (u = n[f], u.pass = xe.TERRAIN_CLASSIFICATION, a.push(u)), s && (u = n[f].derivedCommands.tileset, u.pass = xe.CESIUM_3D_TILE_CLASSIFICATION, a.push(u)); if (!(!t.invertClassification || !l(i))) for (c = i.length, f = 0; f < c; ++f)a.push(i[f]) } function v1e(e, t) { let n = e.commandList, i = t.length; for (let o = 0; o < i; o += 2) { let r = t[o + 1]; r.pass = xe.OPAQUE, n.push(r) } } function P1e(e) { let t = e.debugWireframe === e._debugWireframe; if (t = t && !(e.debugWireframe && e._wireframeDirty), t) return; l(e._rsWireframe) || (e._rsWireframe = Ve.fromCache({})); let n, i; e.debugWireframe ? (n = e._rsWireframe, i = Oe.LINES) : (n = e._rsColorPass, i = Oe.TRIANGLES); let o = e._commands, r = o.length; for (let s = 0; s < r; s += 2) { let a = o[s + 1]; a.renderState = n, a.primitiveType = i } e._debugWireframe = e.debugWireframe, e._wireframeDirty = !1 } pm.prototype.update = function (e) { let t = e.context; u1e(this, t), f1e(this, t), m1e(this), p1e(this, t); let n = e.passes; n.render && (C1e(this, t), x1e(this, e), P1e(this), this._debugWireframe ? v1e(e, this._commands) : mQ(this, e, this._commands, this._commandsIgnoreShow)), n.pick && (T1e(this), mQ(this, e, this._pickCommands)) }; pm.prototype.isDestroyed = function () { return !1 }; pm.prototype.destroy = function () { return this._va = this._va && this._va.destroy(), this._sp = this._sp && this._sp.destroy(), this._spPick = this._spPick && this._spPick.destroy(), this._vaSwap = this._vaSwap && this._vaSwap.destroy(), le(this) }; var zC = pm; function gl(e) { this._boxes = e.boxes, this._boxBatchIds = e.boxBatchIds, this._cylinders = e.cylinders, this._cylinderBatchIds = e.cylinderBatchIds, this._ellipsoids = e.ellipsoids, this._ellipsoidBatchIds = e.ellipsoidBatchIds, this._spheres = e.spheres, this._sphereBatchIds = e.sphereBatchIds, this._modelMatrix = e.modelMatrix, this._batchTable = e.batchTable, this._boundingVolume = e.boundingVolume, this._center = e.center, l(this._center) || (l(this._boundingVolume) ? this._center = h.clone(this._boundingVolume.center) : this._center = h.clone(h.ZERO)), this._boundingVolumes = void 0, this._batchedIndices = void 0, this._indices = void 0, this._indexOffsets = void 0, this._indexCounts = void 0, this._positions = void 0, this._vertexBatchIds = void 0, this._batchIds = void 0, this._batchTableColors = void 0, this._packedBuffer = void 0, this._ready = !1, this._update = function (t, n) { }, this._readyPromise = F1e(this), this._verticesPromise = void 0, this._primitive = void 0, this.debugWireframe = !1, this.forceRebatch = !1, this.classificationType = Ln.BOTH } Object.defineProperties(gl.prototype, { trianglesLength: { get: function () { return l(this._primitive) ? this._primitive.trianglesLength : 0 } }, geometryByteLength: { get: function () { return l(this._primitive) ? this._primitive.geometryByteLength : 0 } }, readyPromise: { get: function () { return this._readyPromise } } }); gl.packedBoxLength = F.packedLength + h.packedLength; gl.packedCylinderLength = F.packedLength + 2; gl.packedEllipsoidLength = F.packedLength + h.packedLength; gl.packedSphereLength = h.packedLength + 1; function I1e(e) { let t = new Float64Array(F.packedLength + h.packedLength), n = 0; return h.pack(e._center, t, n), n += h.packedLength, F.pack(e._modelMatrix, t, n), t } function O1e(e, t) { let n = 0, i = t[n++], o = t[n++], r = e._boundingVolumes = new Array(o); for (let c = 0; c < o; ++c)r[c] = re.unpack(t, n), n += re.packedLength; let s = t[n++], a = e._batchedIndices = new Array(s); for (let c = 0; c < s; ++c) { let u = U.unpack(t, n); n += U.packedLength; let f = t[n++], d = t[n++], p = t[n++], g = new Array(p); for (let m = 0; m < p; ++m)g[m] = t[n++]; a[c] = new mm({ color: u, offset: f, count: d, batchIds: g }) } return i } var B1e = new yi("createVectorTileGeometries", 5), R1e = new U; function M1e(e) { if (!l(e._primitive) && !l(e._verticesPromise)) { let t = e._boxes, n = e._boxBatchIds, i = e._cylinders, o = e._cylinderBatchIds, r = e._ellipsoids, s = e._ellipsoidBatchIds, a = e._spheres, c = e._sphereBatchIds, u = e._batchTableColors, f = e._packedBuffer; if (!l(u)) { let m = 0; l(e._boxes) && (t = e._boxes = t.slice(), n = e._boxBatchIds = n.slice(), m += n.length), l(e._cylinders) && (i = e._cylinders = i.slice(), o = e._cylinderBatchIds = o.slice(), m += o.length), l(e._ellipsoids) && (r = e._ellipsoids = r.slice(), s = e._ellipsoidBatchIds = s.slice(), m += s.length), l(e._spheres) && (a = e._sphere = a.slice(), c = e._sphereBatchIds = c.slice(), m += c.length), u = e._batchTableColors = new Uint32Array(m); let A = e._batchTable; for (let C = 0; C < m; ++C) { let x = A.getColor(C, R1e); u[C] = x.toRgba() } f = e._packedBuffer = I1e(e) } let d = []; l(t) && d.push(t.buffer, n.buffer), l(i) && d.push(i.buffer, o.buffer), l(r) && d.push(r.buffer, s.buffer), l(a) && d.push(a.buffer, c.buffer), d.push(u.buffer, f.buffer); let p = { boxes: l(t) ? t.buffer : void 0, boxBatchIds: l(t) ? n.buffer : void 0, cylinders: l(i) ? i.buffer : void 0, cylinderBatchIds: l(i) ? o.buffer : void 0, ellipsoids: l(r) ? r.buffer : void 0, ellipsoidBatchIds: l(r) ? s.buffer : void 0, spheres: l(a) ? a.buffer : void 0, sphereBatchIds: l(a) ? c.buffer : void 0, batchTableColors: u.buffer, packedBuffer: f.buffer }, g = e._verticesPromise = B1e.scheduleTask(p, d); return l(g) ? g.then(function (m) { let A = new Float64Array(m.packedBuffer); O1e(e, A) === 2 ? e._indices = new Uint16Array(m.indices) : e._indices = new Uint32Array(m.indices), e._indexOffsets = new Uint32Array(m.indexOffsets), e._indexCounts = new Uint32Array(m.indexCounts), e._positions = new Float32Array(m.positions), e._vertexBatchIds = new Uint16Array(m.vertexBatchIds), e._batchIds = new Uint16Array(m.batchIds), e._ready = !0 }) : void 0 } } function L1e(e) { e._ready && !l(e._primitive) && (e._primitive = new zC({ batchTable: e._batchTable, positions: e._positions, batchIds: e._batchIds, vertexBatchIds: e._vertexBatchIds, indices: e._indices, indexOffsets: e._indexOffsets, indexCounts: e._indexCounts, batchedIndices: e._batchedIndices, boundingVolume: e._boundingVolume, boundingVolumes: e._boundingVolumes, center: e._center, pickObject: y(e._pickObject, e) }), e._boxes = void 0, e._boxBatchIds = void 0, e._cylinders = void 0, e._cylinderBatchIds = void 0, e._ellipsoids = void 0, e._ellipsoidBatchIds = void 0, e._spheres = void 0, e._sphereBatchIds = void 0, e._center = void 0, e._modelMatrix = void 0, e._batchTable = void 0, e._boundingVolume = void 0, e._boundingVolumes = void 0, e._batchedIndices = void 0, e._indices = void 0, e._indexOffsets = void 0, e._indexCounts = void 0, e._positions = void 0, e._vertexBatchIds = void 0, e._batchIds = void 0, e._batchTableColors = void 0, e._packedBuffer = void 0, e._verticesPromise = void 0) } gl.prototype.createFeatures = function (e, t) { this._primitive.createFeatures(e, t) }; gl.prototype.applyDebugSettings = function (e, t) { this._primitive.applyDebugSettings(e, t) }; gl.prototype.applyStyle = function (e, t) { this._primitive.applyStyle(e, t) }; gl.prototype.updateCommands = function (e, t) { this._primitive.updateCommands(e, t) }; function F1e(e) { return new Promise(function (t, n) { e._update = function (i, o) { let r = M1e(i); i._ready && (i._primitive.debugWireframe = i.debugWireframe, i._primitive.forceRebatch = i.forceRebatch, i._primitive.classificationType = i.classificationType, i._primitive.update(o)), l(r) && r.then(function () { L1e(i), t(i) }).catch(function (s) { n(s) }) } }) } gl.prototype.update = function (e) { this._update(this, e) }; gl.prototype.isDestroyed = function () { return !1 }; gl.prototype.destroy = function () { return this._primitive = this._primitive && this._primitive.destroy(), le(this) }; var Jp = gl; function _m(e, t, n, i, o) { this._tileset = e, this._tile = t, this._resource = n, this._geometries = void 0, this._metadata = void 0, this._batchTable = void 0, this._features = void 0, this.featurePropertiesDirty = !1, this._group = void 0, this._readyPromise = k1e(this, i, o) } Object.defineProperties(_m.prototype, { featuresLength: { get: function () { return l(this._batchTable) ? this._batchTable.featuresLength : 0 } }, pointsLength: { get: function () { return 0 } }, trianglesLength: { get: function () { return l(this._geometries) ? this._geometries.trianglesLength : 0 } }, geometryByteLength: { get: function () { return l(this._geometries) ? this._geometries.geometryByteLength : 0 } }, texturesByteLength: { get: function () { return 0 } }, batchTableByteLength: { get: function () { return l(this._batchTable) ? this._batchTable.batchTableByteLength : 0 } }, innerContents: { get: function () { } }, readyPromise: { get: function () { return this._readyPromise } }, tileset: { get: function () { return this._tileset } }, tile: { get: function () { return this._tile } }, url: { get: function () { return this._resource.getUrlComponent(!0) } }, metadata: { get: function () { return this._metadata }, set: function (e) { this._metadata = e } }, batchTable: { get: function () { return this._batchTable } }, group: { get: function () { return this._group }, set: function (e) { this._group = e } } }); function N1e(e) { return function (t, n) { l(e._geometries) && e._geometries.updateCommands(t, n) } } function V1e(e, t) { let n, i, o, r, s, a = y(e.BOXES_LENGTH, 0), c = y(e.CYLINDERS_LENGTH, 0), u = y(e.ELLIPSOIDS_LENGTH, 0), f = y(e.SPHERES_LENGTH, 0); if (a > 0 && l(e.BOX_BATCH_IDS)) { let m = t.byteOffset + e.BOX_BATCH_IDS.byteOffset; n = new Uint16Array(t.buffer, m, a) } if (c > 0 && l(e.CYLINDER_BATCH_IDS)) { let m = t.byteOffset + e.CYLINDER_BATCH_IDS.byteOffset; i = new Uint16Array(t.buffer, m, c) } if (u > 0 && l(e.ELLIPSOID_BATCH_IDS)) { let m = t.byteOffset + e.ELLIPSOID_BATCH_IDS.byteOffset; o = new Uint16Array(t.buffer, m, u) } if (f > 0 && l(e.SPHERE_BATCH_IDS)) { let m = t.byteOffset + e.SPHERE_BATCH_IDS.byteOffset; r = new Uint16Array(t.buffer, m, f) } let d = l(n) || l(i) || l(o) || l(r), p = a > 0 && !l(n) || c > 0 && !l(i) || u > 0 && !l(o) || f > 0 && !l(r); if (d && p) throw new fe("If one group of batch ids is defined, then all batch ids must be defined."); if (!l(n) && !l(i) && !l(o) && !l(r)) { let m = 0; if (!l(n) && a > 0) for (n = new Uint16Array(a), s = 0; s < a; ++s)n[s] = m++; if (!l(i) && c > 0) for (i = new Uint16Array(c), s = 0; s < c; ++s)i[s] = m++; if (!l(o) && u > 0) for (o = new Uint16Array(u), s = 0; s < u; ++s)o[s] = m++; if (!l(r) && f > 0) for (r = new Uint16Array(f), s = 0; s < f; ++s)r[s] = m++ } return { boxes: n, cylinders: i, ellipsoids: o, spheres: r } } var B0 = Uint32Array.BYTES_PER_ELEMENT; function k1e(e, t, n) { n = y(n, 0); let i = new Uint8Array(t), o = new DataView(t); n += B0; let r = o.getUint32(n, !0); if (r !== 1) throw new fe(`Only Geometry tile version 1 is supported.  Version ${r} is not.`); n += B0; let s = o.getUint32(n, !0); if (n += B0, s === 0) { e._readyPromise.resolve(e); return } let a = o.getUint32(n, !0); if (n += B0, a === 0) throw new fe("Feature table must have a byte length greater than zero"); let c = o.getUint32(n, !0); n += B0; let u = o.getUint32(n, !0); n += B0; let f = o.getUint32(n, !0); n += B0; let d = Ko(i, n, a); n += a; let p = new Uint8Array(t, n, c); n += c; let g, m; u > 0 && (g = Ko(i, n, u), n += u, f > 0 && (m = new Uint8Array(t, n, f), m = new Uint8Array(m))); let A = y(d.BOXES_LENGTH, 0), C = y(d.CYLINDERS_LENGTH, 0), x = y(d.ELLIPSOIDS_LENGTH, 0), T = y(d.SPHERES_LENGTH, 0), b = A + C + x + T, S = new Xp(e, b, g, m, N1e(e)); if (e._batchTable = S, b === 0) return; let D = e.tile.computedTransform, P; l(d.RTC_CENTER) && (P = h.unpack(d.RTC_CENTER), F.multiplyByPoint(D, P, P)); let B = V1e(d, p); if (A > 0 || C > 0 || x > 0 || T > 0) { let R, M, L, _; if (A > 0) { let E = p.byteOffset + d.BOXES.byteOffset; R = new Float32Array(p.buffer, E, Jp.packedBoxLength * A) } if (C > 0) { let E = p.byteOffset + d.CYLINDERS.byteOffset; M = new Float32Array(p.buffer, E, Jp.packedCylinderLength * C) } if (x > 0) { let E = p.byteOffset + d.ELLIPSOIDS.byteOffset; L = new Float32Array(p.buffer, E, Jp.packedEllipsoidLength * x) } if (T > 0) { let E = p.byteOffset + d.SPHERES.byteOffset; _ = new Float32Array(p.buffer, E, Jp.packedSphereLength * T) } return e._geometries = new Jp({ boxes: R, boxBatchIds: B.boxes, cylinders: M, cylinderBatchIds: B.cylinders, ellipsoids: L, ellipsoidBatchIds: B.ellipsoids, spheres: _, sphereBatchIds: B.spheres, center: P, modelMatrix: D, batchTable: S, boundingVolume: e.tile.boundingVolume.boundingVolume }), e._geometries.readyPromise.then(function () { return e }) } return Promise.resolve(e) } function pQ(e) { let t = e.featuresLength; if (!l(e._features) && t > 0) { let n = new Array(t); l(e._geometries) && e._geometries.createFeatures(e, n), e._features = n } } _m.prototype.hasProperty = function (e, t) { return this._batchTable.hasProperty(e, t) }; _m.prototype.getFeature = function (e) { return pQ(this), this._features[e] }; _m.prototype.applyDebugSettings = function (e, t) { l(this._geometries) && this._geometries.applyDebugSettings(e, t) }; _m.prototype.applyStyle = function (e) { pQ(this), l(this._geometries) && this._geometries.applyStyle(e, this._features) }; _m.prototype.update = function (e, t) { l(this._geometries) && (this._geometries.classificationType = this._tileset.classificationType, this._geometries.debugWireframe = this._tileset.debugWireframe, this._geometries.update(t)), l(this._batchTable) && this._geometries._ready && this._batchTable.update(e, t) }; _m.prototype.isDestroyed = function () { return !1 }; _m.prototype.destroy = function () { return this._geometries = this._geometries && this._geometries.destroy(), this._batchTable = this._batchTable && this._batchTable.destroy(), le(this) }; var UB = _m; var jG = {}; jG.encode2D = function (e, t, n) { let i = Math.pow(2, e), o = { x: t, y: n }, r, s, a, c = BigInt(0); for (a = i / 2; a > 0; a /= 2)r = (o.x & a) > 0 ? 1 : 0, s = (o.y & a) > 0 ? 1 : 0, c += BigInt((3 * r ^ s) * a * a), _Q(i, o, r, s); return c }; jG.decode2D = function (e, t) { let n = Math.pow(2, e), i = { x: 0, y: 0 }, o, r, s, a; for (s = 1, a = t; s < n; s *= 2)o = 1 & Number(a / BigInt(2)), r = 1 & Number(a ^ BigInt(o)), _Q(s, i, o, r), i.x += s * o, i.y += s * r, a /= BigInt(4); return [i.x, i.y] }; function _Q(e, t, n, i) { if (i !== 0) return; n === 1 && (t.x = e - 1 - t.x, t.y = e - 1 - t.y); let o = t.x; t.x = t.y, t.y = o } var oS = jG; var R0 = 30, U1e = 1 << R0, z1e = 1 << R0 + 1 >>> 0, qG = 2 * R0 + 1, Zp = 4, AQ = [], CQ = [], H1e = [[0, 1, 3, 2], [0, 2, 3, 1], [3, 2, 0, 1], [3, 1, 0, 2]], Qp = 1, HC = 2, zB = [Qp, 0, 0, Qp | HC]; function Dr(e) { if (!Nt.supportsBigInt()) throw new fe("S2 required BigInt support"); this._cellId = e, this._level = Dr.getLevel(e) } Dr.fromToken = function (e) { return new Dr(Dr.getIdFromToken(e)) }; Dr.isValidId = function (e) { return !(e <= 0 || e >> BigInt(qG) > 5 || !(e & ~e + BigInt(1) & BigInt("0x1555555555555555"))) }; Dr.isValidToken = function (e) { return /^[0-9a-fA-F]{1,16}$/.test(e) ? Dr.isValidId(Dr.getIdFromToken(e)) : !1 }; Dr.getIdFromToken = function (e) { return BigInt("0x" + e + "0".repeat(16 - e.length)) }; Dr.getTokenFromId = function (e) { let t = Math.floor(Q1e(e) / 4), n = e.toString(16).replace(/0*$/, ""); return Array(17 - t - n.length).join("0") + n }; Dr.getLevel = function (e) { let t = 0; for (; e !== BigInt(0) && !(e & BigInt(1));)t++, e = e >> BigInt(1); return R0 - (t >> 1) }; Dr.prototype.getChild = function (e) { let t = EQ(this._cellId) >> BigInt(2), n = this._cellId + BigInt(2 * e + 1 - 4) * t; return new Dr(n) }; Dr.prototype.getParent = function () { let e = EQ(this._cellId) << BigInt(2); return new Dr(this._cellId & ~e + BigInt(1) | e) }; Dr.prototype.getParentAtLevel = function (e) { let t = J1e(e); return new Dr(this._cellId & -t | t) }; Dr.prototype.getCenter = function (e) { e = y(e, ie.WGS84); let t = G1e(this._cellId, this._level); t = h.normalize(t, t); let n = new he.fromCartesian(t, ie.UNIT_SPHERE); return he.toCartesian(n, e, new h) }; Dr.prototype.getVertex = function (e, t) { t = y(t, ie.WGS84); let n = W1e(this._cellId, this._level, e); n = h.normalize(n, n); let i = new he.fromCartesian(n, ie.UNIT_SPHERE); return he.toCartesian(i, t, new h) }; Dr.fromFacePositionLevel = function (e, t, n) { let i = (e < 4 ? "0" : "") + (e < 2 ? "0" : "") + e.toString(2), o = t.toString(2), r = Array(2 * n - o.length + 1).join("0"), s = Array(qG - 2 * n).join("0"), a = BigInt(`0b${i}${r}${o}1${s}`); return new Dr(a) }; function G1e(e, t) { let n = j1e(e, t); return q1e(n[0], n[1], n[2]) } function W1e(e, t, n) { let i = xQ(e, t), o = Y1e([i[1], i[2]], t), r = n >> 1 & 1; return TQ(i[0], o[0][r ^ n & 1], o[1][r]) } function j1e(e, t) { let n = xQ(e), i = n[0], o = n[1], r = n[2], s = t === 30, a = !s && (BigInt(o) ^ e >> BigInt(2)) & BigInt(1), c = s ? 1 : a ? 2 : 0, u = (o << 1) + c, f = (r << 1) + c; return [i, u, f] } function xQ(e) { AQ.length === 0 && K1e(); let t = Number(e >> BigInt(qG)), n = t & Qp, i = (1 << Zp) - 1, o = 0, r = 0; for (let s = 7; s >= 0; s--) { let a = s === 7 ? R0 - 7 * Zp : Zp, c = (1 << 2 * a) - 1; n += Number(e >> BigInt(s * 2 * Zp + 1) & BigInt(c)) << 2, n = CQ[n]; let u = s * Zp; o += n >> Zp + 2 << u, r += (n >> 2 & i) << u, n &= Qp | HC } return [t, o, r] } function q1e(e, t, n) { let i = gQ(t), o = gQ(n), r = HB(i), s = HB(o); return TQ(e, r, s) } function TQ(e, t, n) { switch (e) { case 0: return new h(1, t, n); case 1: return new h(-t, 1, n); case 2: return new h(-t, -n, 1); case 3: return new h(-1, -n, -t); case 4: return new h(n, -1, -t); default: return new h(n, t, -1) } } function HB(e) { return e >= .5 ? 1 / 3 * (4 * e * e - 1) : 1 / 3 * (1 - 4 * (1 - e) * (1 - e)) } function gQ(e) { return 1 / z1e * e } function Y1e(e, t) { let n = [[], []], i = X1e(t); for (let o = 0; o < 2; ++o) { let r = e[o] & -i, s = r + i; n[o][0] = HB(yQ(r)), n[o][1] = HB(yQ(s)) } return n } function X1e(e) { return 1 << R0 - e >>> 0 } function yQ(e) { return 1 / U1e * e } function $p(e, t, n, i, o, r) { if (e === Zp) { let s = (t << Zp) + n; AQ[(s << 2) + i] = (o << 2) + r, CQ[(o << 2) + i] = (s << 2) + r } else { e++, t <<= 1, n <<= 1, o <<= 2; let s = H1e[r]; $p(e, t + (s[0] >> 1), n + (s[0] & 1), i, o, r ^ zB[0]), $p(e, t + (s[1] >> 1), n + (s[1] & 1), i, o + 1, r ^ zB[1]), $p(e, t + (s[2] >> 1), n + (s[2] & 1), i, o + 2, r ^ zB[2]), $p(e, t + (s[3] >> 1), n + (s[3] & 1), i, o + 3, r ^ zB[3]) } } function K1e() { $p(0, 0, 0, 0, 0, 0), $p(0, 0, 0, Qp, 0, Qp), $p(0, 0, 0, HC, 0, HC), $p(0, 0, 0, Qp | HC, 0, Qp | HC) } function EQ(e) { return e & ~e + BigInt(1) } function J1e(e) { return BigInt(1) << BigInt(2 * (R0 - e)) } var Z1e = [64, 0, 1, 39, 2, 15, 40, 23, 3, 12, 16, 59, 41, 19, 24, 54, 4, 64, 13, 10, 17, 62, 60, 28, 42, 30, 20, 51, 25, 44, 55, 47, 5, 32, 65, 38, 14, 22, 11, 58, 18, 53, 63, 9, 61, 27, 29, 50, 43, 46, 31, 37, 21, 57, 52, 8, 26, 49, 45, 36, 56, 7, 48, 35, 6, 34, 33, 0]; function Q1e(e) { return Z1e[(-e & e) % BigInt(67)] } var e_ = Dr; function $1e(e, t) { return l(e) && l(e.extensions) && l(e.extensions[t]) } var Mi = $1e; function YG(e) { let t = e.lengthBits, n = e.availableCount, i = e.constant, o = e.bitstream; if (l(i)) n = t; else { let r = Math.ceil(t / 8); if (o.length !== r) throw new fe(`Availability bitstream must be exactly ${r} bytes long to store ${t} bits. Actual bitstream was ${o.length} bytes long.`); let s = y(e.computeAvailableCountEnabled, !1); !l(n) && s && (n = eIe(o, t)) } this._lengthBits = t, this._availableCount = n, this._constant = i, this._bitstream = o } function eIe(e, t) { let n = 0; for (let i = 0; i < t; i++) { let o = i >> 3, r = i % 8; n += e[o] >> r & 1 } return n } Object.defineProperties(YG.prototype, { lengthBits: { get: function () { return this._lengthBits } }, availableCount: { get: function () { return this._availableCount } } }); YG.prototype.getBit = function (e) { if (l(this._constant)) return this._constant; let t = e >> 3, n = e % 8; return (this._bitstream[t] >> n & 1) === 1 }; var rS = YG; function gm(e) { e = y(e, y.EMPTY_OBJECT); let t = e.metadataTable, n = e.class, i = e.entityId, o = e.propertyTableJson; this._class = n, this._metadataTable = t, this._entityId = i, this._extensions = o.extensions, this._extras = o.extras } Object.defineProperties(gm.prototype, { class: { get: function () { return this._class } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); gm.prototype.hasProperty = function (e) { return this._metadataTable.hasProperty(e) }; gm.prototype.hasPropertyBySemantic = function (e) { return this._metadataTable.hasPropertyBySemantic(e) }; gm.prototype.getPropertyIds = function (e) { return this._metadataTable.getPropertyIds(e) }; gm.prototype.getProperty = function (e) { return this._metadataTable.getProperty(this._entityId, e) }; gm.prototype.setProperty = function (e, t) { return this._metadataTable.setProperty(this._entityId, e, t) }; gm.prototype.getPropertyBySemantic = function (e) { return this._metadataTable.getPropertyBySemantic(this._entityId, e) }; gm.prototype.setPropertyBySemantic = function (e, t) { return this._metadataTable.setPropertyBySemantic(this._entityId, e, t) }; var sS = gm; var GB = { QUADTREE: "QUADTREE", OCTREE: "OCTREE" }; GB.getBranchingFactor = function (e) { switch (e) { case GB.OCTREE: return 8; case GB.QUADTREE: return 4 } }; var kr = Object.freeze(GB); function Ts() { } Object.defineProperties(Ts.prototype, { class: { get: function () { ye.throwInstantiationError() } } }); Ts.prototype.hasProperty = function (e) { ye.throwInstantiationError() }; Ts.prototype.hasPropertyBySemantic = function (e) { ye.throwInstantiationError() }; Ts.prototype.getPropertyIds = function (e) { ye.throwInstantiationError() }; Ts.prototype.getProperty = function (e) { ye.throwInstantiationError() }; Ts.prototype.setProperty = function (e, t) { ye.throwInstantiationError() }; Ts.prototype.getPropertyBySemantic = function (e) { ye.throwInstantiationError() }; Ts.prototype.setPropertyBySemantic = function (e, t) { ye.throwInstantiationError() }; Ts.hasProperty = function (e, t, n) { if (l(t[e])) return !0; let i = n.properties; if (!l(i)) return !1; let o = i[e]; return !!(l(o) && l(o.default)) }; Ts.hasPropertyBySemantic = function (e, t, n) { let i = n.propertiesBySemantic; if (!l(i)) return !1; let o = i[e]; return l(o) }; Ts.getPropertyIds = function (e, t, n) { n = l(n) ? n : [], n.length = 0; for (let o in e) e.hasOwnProperty(o) && l(e[o]) && n.push(o); let i = t.properties; if (l(i)) for (let o in i) i.hasOwnProperty(o) && !l(e[o]) && l(i[o].default) && n.push(o); return n }; Ts.getProperty = function (e, t, n) { let i = n.properties[e], o = t[e]; Array.isArray(o) && (o = o.slice()); let r = !0; if (o = i.handleNoData(o), !l(o) && l(i.default)) return o = tt(i.default, !0), i.unpackVectorAndMatrixTypes(o, r); if (!!l(o)) return o = i.normalize(o), o = i.applyValueTransform(o), i.unpackVectorAndMatrixTypes(o, r) }; Ts.setProperty = function (e, t, n, i) { if (!l(n[e])) return !1; Array.isArray(t) && (t = t.slice()); let o, r = i.properties; l(r) && (o = r[e]); let s = !0; return l(o) && (t = o.packVectorAndMatrixTypes(t, s), t = o.unapplyValueTransform(t), t = o.unnormalize(t)), n[e] = t, !0 }; Ts.getPropertyBySemantic = function (e, t, n) { let i = n.propertiesBySemantic; if (!l(i)) return; let o = i[e]; if (l(o)) return Ts.getProperty(o.id, t, n) }; Ts.setPropertyBySemantic = function (e, t, n, i) { let o = i.propertiesBySemantic; if (!l(o)) return !1; let r = i.propertiesBySemantic[e]; return l(r) ? Ts.setProperty(r.id, t, n, i) : !1 }; var Rn = Ts; function ym(e) { e = y(e, y.EMPTY_OBJECT); let t = e.subtreeMetadata, n = e.class, i = l(t.properties) ? t.properties : {}; this._class = n, this._properties = i, this._extras = t.extras, this._extensions = t.extensions } Object.defineProperties(ym.prototype, { class: { get: function () { return this._class } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); ym.prototype.hasProperty = function (e) { return Rn.hasProperty(e, this._properties, this._class) }; ym.prototype.hasPropertyBySemantic = function (e) { return Rn.hasPropertyBySemantic(e, this._properties, this._class) }; ym.prototype.getPropertyIds = function (e) { return Rn.getPropertyIds(this._properties, this._class, e) }; ym.prototype.getProperty = function (e) { return Rn.getProperty(e, this._properties, this._class) }; ym.prototype.setProperty = function (e, t) { return Rn.setProperty(e, t, this._properties, this._class) }; ym.prototype.getPropertyBySemantic = function (e) { return Rn.getPropertyBySemantic(e, this._properties, this._class) }; ym.prototype.setPropertyBySemantic = function (e, t) { return Rn.setPropertyBySemantic(e, t, this._properties, this._class) }; var WB = ym; var Mt = { INT8: "INT8", UINT8: "UINT8", INT16: "INT16", UINT16: "UINT16", INT32: "INT32", UINT32: "UINT32", INT64: "INT64", UINT64: "UINT64", FLOAT32: "FLOAT32", FLOAT64: "FLOAT64" }; Mt.getMinimum = function (e) { switch (e) { case Mt.INT8: return -128; case Mt.UINT8: return 0; case Mt.INT16: return -32768; case Mt.UINT16: return 0; case Mt.INT32: return -2147483648; case Mt.UINT32: return 0; case Mt.INT64: return Nt.supportsBigInt() ? BigInt("-9223372036854775808") : -Math.pow(2, 63); case Mt.UINT64: return Nt.supportsBigInt() ? BigInt(0) : 0; case Mt.FLOAT32: return -34028234663852886e22; case Mt.FLOAT64: return -Number.MAX_VALUE } }; Mt.getMaximum = function (e) { switch (e) { case Mt.INT8: return 127; case Mt.UINT8: return 255; case Mt.INT16: return 32767; case Mt.UINT16: return 65535; case Mt.INT32: return 2147483647; case Mt.UINT32: return 4294967295; case Mt.INT64: return Nt.supportsBigInt() ? BigInt("9223372036854775807") : Math.pow(2, 63) - 1; case Mt.UINT64: return Nt.supportsBigInt() ? BigInt("18446744073709551615") : Math.pow(2, 64) - 1; case Mt.FLOAT32: return 34028234663852886e22; case Mt.FLOAT64: return Number.MAX_VALUE } }; Mt.isNumericType = function (e) { switch (e) { case Mt.INT8: case Mt.UINT8: case Mt.INT16: case Mt.UINT16: case Mt.INT32: case Mt.UINT32: case Mt.INT64: case Mt.UINT64: case Mt.FLOAT32: case Mt.FLOAT64: return !0; default: return !1 } }; Mt.isIntegerType = function (e) { switch (e) { case Mt.INT8: case Mt.UINT8: case Mt.INT16: case Mt.UINT16: case Mt.INT32: case Mt.UINT32: case Mt.INT64: case Mt.UINT64: return !0; default: return !1 } }; Mt.isUnsignedIntegerType = function (e) { switch (e) { case Mt.UINT8: case Mt.UINT16: case Mt.UINT32: case Mt.UINT64: return !0; default: return !1 } }; Mt.isVectorCompatible = function (e) { switch (e) { case Mt.INT8: case Mt.UINT8: case Mt.INT16: case Mt.UINT16: case Mt.INT32: case Mt.UINT32: case Mt.FLOAT32: case Mt.FLOAT64: return !0; default: return !1 } }; Mt.normalize = function (e, t) { return Math.max(Number(e) / Number(Mt.getMaximum(t)), -1) }; Mt.unnormalize = function (e, t) { let n = Mt.getMaximum(t), i = Mt.isUnsignedIntegerType(t) ? 0 : -n; return e = I.sign(e) * Math.round(Math.abs(e) * Number(n)), (t === Mt.INT64 || t === Mt.UINT64) && Nt.supportsBigInt() && (e = BigInt(e)), e > n ? n : e < i ? i : e }; Mt.applyValueTransform = function (e, t, n) { return n * e + t }; Mt.unapplyValueTransform = function (e, t, n) { return n === 0 ? 0 : (e - t) / n }; Mt.getSizeInBytes = function (e) { switch (e) { case Mt.INT8: case Mt.UINT8: return 1; case Mt.INT16: case Mt.UINT16: return 2; case Mt.INT32: case Mt.UINT32: return 4; case Mt.INT64: case Mt.UINT64: return 8; case Mt.FLOAT32: return 4; case Mt.FLOAT64: return 8 } }; var wn = Object.freeze(Mt); var vo = { SCALAR: "SCALAR", VEC2: "VEC2", VEC3: "VEC3", VEC4: "VEC4", MAT2: "MAT2", MAT3: "MAT3", MAT4: "MAT4", BOOLEAN: "BOOLEAN", STRING: "STRING", ENUM: "ENUM" }; vo.isVectorType = function (e) { switch (e) { case vo.VEC2: case vo.VEC3: case vo.VEC4: return !0; default: return !1 } }; vo.isMatrixType = function (e) { switch (e) { case vo.MAT2: case vo.MAT3: case vo.MAT4: return !0; default: return !1 } }; vo.getComponentCount = function (e) { switch (e) { case vo.SCALAR: case vo.STRING: case vo.ENUM: case vo.BOOLEAN: return 1; case vo.VEC2: return 2; case vo.VEC3: return 3; case vo.VEC4: return 4; case vo.MAT2: return 4; case vo.MAT3: return 9; case vo.MAT4: return 16 } }; vo.getMathType = function (e) { switch (e) { case vo.VEC2: return H; case vo.VEC3: return h; case vo.VEC4: return se; case vo.MAT2: return qi; case vo.MAT3: return Q; case vo.MAT4: return F; default: return } }; var Dn = Object.freeze(vo); function nc(e) { e = y(e, y.EMPTY_OBJECT); let t = e.id, n = e.property, i = tIe(n), o = nIe(n, e.enums), r = o.componentType, s = l(r) && wn.isIntegerType(r) && y(n.normalized, !1); this._id = t, this._name = n.name, this._description = n.description, this._semantic = n.semantic, this._isLegacyExtension = i, this._type = o.type, this._componentType = r, this._enumType = o.enumType, this._valueType = o.valueType, this._isArray = o.isArray, this._isVariableLengthArray = o.isVariableLengthArray, this._arrayLength = o.arrayLength, this._min = n.min, this._max = n.max, this._normalized = s; let a = n.offset, c = n.scale, u = l(a) || l(c), f = !0; l(a) || (a = this.expandConstant(0, f)), l(c) || (c = this.expandConstant(1, f)), this._offset = a, this._scale = c, this._hasValueTransform = u, this._noData = n.noData, this._default = n.default; let d; l(i) ? i ? d = l(n.optional) ? !n.optional : !0 : d = y(n.required, !1) : d = !1, this._required = d, this._extras = n.extras, this._extensions = n.extensions } Object.defineProperties(nc.prototype, { id: { get: function () { return this._id } }, name: { get: function () { return this._name } }, description: { get: function () { return this._description } }, type: { get: function () { return this._type } }, enumType: { get: function () { return this._enumType } }, componentType: { get: function () { return this._componentType } }, valueType: { get: function () { return this._valueType } }, isArray: { get: function () { return this._isArray } }, isVariableLengthArray: { get: function () { return this._isVariableLengthArray } }, arrayLength: { get: function () { return this._arrayLength } }, normalized: { get: function () { return this._normalized } }, max: { get: function () { return this._max } }, min: { get: function () { return this._min } }, noData: { get: function () { return this._noData } }, default: { get: function () { return this._default } }, required: { get: function () { return this._required } }, semantic: { get: function () { return this._semantic } }, hasValueTransform: { get: function () { return this._hasValueTransform } }, offset: { get: function () { return this._offset } }, scale: { get: function () { return this._scale } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); function tIe(e) { if (e.type === "ARRAY") return !0; let t = e.type; if (t === Dn.SCALAR || Dn.isMatrixType(t) || Dn.isVectorType(t)) return !1; if (wn.isNumericType(t)) return !0; if (l(e.noData) || l(e.scale) || l(e.offset) || l(e.required) || l(e.count) || l(e.array) || l(e.optional)) return !1 } function nIe(e, t) { let n = e.type, i = e.componentType, o = n === "ARRAY", r, s, a; o ? (r = !0, s = e.componentCount, a = !l(s)) : e.array ? (r = !0, s = e.count, a = !l(e.count)) : (r = !1, s = void 0, a = !1); let c; if (l(e.enumType) && (c = t[e.enumType]), n === Dn.ENUM) return { type: n, componentType: void 0, enumType: c, valueType: c.valueType, isArray: r, isVariableLengthArray: a, arrayLength: s }; if (o && i === Dn.ENUM) return { type: i, componentType: void 0, enumType: c, valueType: c.valueType, isArray: r, isVariableLengthArray: a, arrayLength: s }; if (n === Dn.SCALAR || Dn.isMatrixType(n) || Dn.isVectorType(n)) return { type: n, componentType: i, enumType: void 0, valueType: i, isArray: r, isVariableLengthArray: a, arrayLength: s }; if (n === Dn.BOOLEAN || n === Dn.STRING) return { type: n, componentType: void 0, enumType: void 0, valueType: void 0, isArray: r, isVariableLengthArray: a, arrayLength: s }; if (o && (i === Dn.BOOLEAN || i === Dn.STRING)) return { type: i, componentType: void 0, enumType: void 0, valueType: void 0, isArray: r, isVariableLengthArray: a, arrayLength: s }; if (l(i) && wn.isNumericType(i)) return { type: Dn.SCALAR, componentType: i, enumType: void 0, valueType: i, isArray: r, isVariableLengthArray: a, arrayLength: s }; if (wn.isNumericType(n)) return { type: Dn.SCALAR, componentType: n, enumType: void 0, valueType: n, isArray: r, isVariableLengthArray: a, arrayLength: s } } nc.prototype.normalize = function (e) { return this._normalized ? XG(e, this._valueType, wn.normalize) : e }; nc.prototype.unnormalize = function (e) { return this._normalized ? XG(e, this._valueType, wn.unnormalize) : e }; nc.prototype.applyValueTransform = function (e) { return !this._hasValueTransform || this._isVariableLengthArray ? e : nc.valueTransformInPlace(e, this._offset, this._scale, wn.applyValueTransform) }; nc.prototype.unapplyValueTransform = function (e) { return !this._hasValueTransform || this._isVariableLengthArray ? e : nc.valueTransformInPlace(e, this._offset, this._scale, wn.unapplyValueTransform) }; nc.prototype.expandConstant = function (e, t) { t = y(t, !1); let n = this._isArray, i = this._arrayLength, o = Dn.getComponentCount(this._type), r = n && o > 1; if (!n && o === 1) return e; if (!n) return new Array(o).fill(e); if (!r) return new Array(i).fill(e); if (!t) return new Array(this._arrayLength * o).fill(e); let s = new Array(o).fill(e); return new Array(this._arrayLength).fill(s) }; nc.prototype.handleNoData = function (e) { let t = this._noData; if (!l(t)) return e; if (!DQ(e, t)) return e }; function DQ(e, t) { if (!Array.isArray(e)) return e === t; if (!Array.isArray(t) || e.length !== t.length) return !1; for (let n = 0; n < e.length; n++)if (!DQ(e[n], t[n])) return !1; return !0 } nc.prototype.unpackVectorAndMatrixTypes = function (e, t) { t = y(t, !1); let n = Dn.getMathType(this._type), i = this._isArray, o = Dn.getComponentCount(this._type), r = i && o > 1; return l(n) ? t && r ? e.map(function (s) { return n.unpack(s) }) : i ? n.unpackArray(e) : n.unpack(e) : e }; nc.prototype.packVectorAndMatrixTypes = function (e, t) { t = y(t, !1); let n = Dn.getMathType(this._type), i = this._isArray, o = Dn.getComponentCount(this._type), r = i && o > 1; return l(n) ? t && r ? e.map(function (s) { return n.pack(s, []) }) : i ? n.packArray(e, []) : n.pack(e, []) : e }; nc.prototype.validate = function (e) { if (!(!l(e) && l(this._default))) return this._required && !l(e) ? "required property must have a value" : this._isArray ? iIe(this, e) : vQ(this, e) }; function iIe(e, t) { if (!Array.isArray(t)) return `value ${t} must be an array`; let n = t.length; if (!e._isVariableLengthArray && n !== e._arrayLength) return "Array length does not match property.arrayLength"; for (let i = 0; i < n; i++) { let o = vQ(e, t[i]); if (l(o)) return o } } function vQ(e, t) { let n = e._type, i = e._componentType, o = e._enumType, r = e._normalized; return Dn.isVectorType(n) ? oIe(t, n, i) : Dn.isMatrixType(n) ? rIe(t, n, i) : n === Dn.STRING ? sIe(t) : n === Dn.BOOLEAN ? aIe(t) : n === Dn.ENUM ? cIe(t, o) : lIe(t, i, r) } function oIe(e, t, n) { if (!wn.isVectorCompatible(n)) return `componentType ${n} is incompatible with vector type ${t}`; if (t === Dn.VEC2 && !(e instanceof H)) return `vector value ${e} must be a Cartesian2`; if (t === Dn.VEC3 && !(e instanceof h)) return `vector value ${e} must be a Cartesian3`; if (t === Dn.VEC4 && !(e instanceof se)) return `vector value ${e} must be a Cartesian4` } function rIe(e, t, n) { if (!wn.isVectorCompatible(n)) return `componentType ${n} is incompatible with matrix type ${t}`; if (t === Dn.MAT2 && !(e instanceof qi)) return `matrix value ${e} must be a Matrix2`; if (t === Dn.MAT3 && !(e instanceof Q)) return `matrix value ${e} must be a Matrix3`; if (t === Dn.MAT4 && !(e instanceof F)) return `matrix value ${e} must be a Matrix4` } function sIe(e) { if (typeof e != "string") return jB(e, Dn.STRING) } function aIe(e) { if (typeof e != "boolean") return jB(e, Dn.BOOLEAN) } function cIe(e, t) { let n = typeof e; if (l(t)) return n !== "string" || !l(t.valuesByName[e]) ? `value ${e} is not a valid enum name for ${t.id}` : void 0 } function lIe(e, t, n) { let i = typeof e; switch (t) { case wn.INT8: case wn.UINT8: case wn.INT16: case wn.UINT16: case wn.INT32: case wn.UINT32: case wn.FLOAT32: case wn.FLOAT64: return i !== "number" ? jB(e, t) : isFinite(e) ? SQ(e, t, n) : wQ(e, t); case wn.INT64: case wn.UINT64: return i !== "number" && i !== "bigint" ? jB(e, t) : i === "number" && !isFinite(e) ? wQ(e, t) : SQ(e, t, n) } } function jB(e, t) { return `value ${e} does not match type ${t}` } function bQ(e, t, n) { let i = `value ${e} is out of range for type ${t}`; return n && (i += " (normalized)"), i } function SQ(e, t, n) { if (n) { let i = wn.isUnsignedIntegerType(t) ? 0 : -1, o = 1; return e < i || e > o ? bQ(e, t, n) : void 0 } if (e < wn.getMinimum(t) || e > wn.getMaximum(t)) return bQ(e, t, n) } function wQ(e, t) { return `value ${e} of type ${t} must be finite` } function XG(e, t, n) { if (!Array.isArray(e)) return n(e, t); for (let i = 0; i < e.length; i++)e[i] = XG(e[i], t, n); return e } nc.valueTransformInPlace = function (e, t, n, i) { if (!Array.isArray(e)) return i(e, t, n); for (let o = 0; o < e.length; o++)e[o] = nc.valueTransformInPlace(e[o], t[o], n[o], i); return e }; var M0 = nc; function aS(e) { e = y(e, y.EMPTY_OBJECT); let t = e.count, n = e.property, i = e.classProperty, o = e.bufferViews, r = i.type, s = i.isArray, a = i.isVariableLengthArray, c = i.valueType, u = i.enumType, f = r === Dn.STRING, d = r === Dn.BOOLEAN, p = 0, g; if (a) { let _ = y(n.arrayOffsetType, n.offsetType); _ = y(wn[_], wn.UINT32); let E = y(n.arrayOffsets, n.arrayOffsetBufferView); g = new KG(o[E], _, t + 1), p += g.typedArray.byteLength } let m = Dn.getComponentCount(r), A; a ? A = g.get(t) - g.get(0) : s ? A = t * i.arrayLength : A = t; let C = m * A, x; if (f) { let _ = y(n.stringOffsetType, n.offsetType); _ = y(wn[_], wn.UINT32); let E = y(n.stringOffsets, n.stringOffsetBufferView); x = new KG(o[E], _, C + 1), p += x.typedArray.byteLength } (f || d) && (c = wn.UINT8); let T; f ? T = x.get(C) - x.get(0) : d ? T = Math.ceil(C / 8) : T = C; let b = y(n.values, n.bufferView), S = new KG(o[b], c, T); p += S.typedArray.byteLength; let D = n.offset, P = n.scale, B = i.hasValueTransform || l(D) || l(P); D = y(D, i.offset), P = y(P, i.scale), D = PQ(D), P = PQ(P); let R, M, L = this; f ? R = function (_) { return dIe(_, L._values, L._stringOffsets) } : d ? (R = function (_) { return hIe(_, L._values) }, M = function (_, E) { mIe(_, L._values, E) }) : l(u) ? (R = function (_) { let E = L._values.get(_); return u.namesByValue[E] }, M = function (_, E) { let w = u.valuesByName[E]; L._values.set(_, w) }) : (R = function (_) { return L._values.get(_) }, M = function (_, E) { L._values.set(_, E) }), this._arrayOffsets = g, this._stringOffsets = x, this._values = S, this._classProperty = i, this._count = t, this._vectorComponentCount = m, this._min = n.min, this._max = n.max, this._offset = D, this._scale = P, this._hasValueTransform = B, this._getValue = R, this._setValue = M, this._unpackedValues = void 0, this._extras = n.extras, this._extensions = n.extensions, this._byteLength = p } Object.defineProperties(aS.prototype, { hasValueTransform: { get: function () { return this._hasValueTransform } }, offset: { get: function () { return this._offset } }, scale: { get: function () { return this._scale } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } }, byteLength: { get: function () { return this._byteLength } } }); aS.prototype.get = function (e) { let t = uIe(this, e); return t = this._classProperty.handleNoData(t), l(t) ? (t = this._classProperty.normalize(t), t = TIe(this, t), this._classProperty.unpackVectorAndMatrixTypes(t)) : (t = this._classProperty.default, this._classProperty.unpackVectorAndMatrixTypes(t)) }; aS.prototype.set = function (e, t) { let n = this._classProperty; t = n.packVectorAndMatrixTypes(t), t = EIe(this, t), t = n.unnormalize(t), fIe(this, e, t) }; aS.prototype.getTypedArray = function () { if (l(this._values)) return this._values.typedArray }; function PQ(e) { if (!Array.isArray(e)) return e; let t = []; for (let n = 0; n < e.length; n++) { let i = e[n]; Array.isArray(i) ? t.push.apply(t, i) : t.push(i) } return t } function uIe(e, t) { OQ(e) && BQ(e); let n = e._classProperty, i = n.isArray, o = n.type, r = Dn.getComponentCount(o); if (l(e._unpackedValues)) { let s = e._unpackedValues[t]; return i ? tt(s, !0) : s } return !i && r === 1 ? e._getValue(t) : IQ(e, n, t) } function IQ(e, t, n) { let i, o; if (t.isVariableLengthArray) { i = e._arrayOffsets.get(n), o = e._arrayOffsets.get(n + 1) - i; let s = Dn.getComponentCount(t.type); i *= s, o *= s } else { let a = y(t.arrayLength, 1) * e._vectorComponentCount; i = n * a, o = a } let r = new Array(o); for (let s = 0; s < o; s++)r[s] = e._getValue(i + s); return r } function fIe(e, t, n) { CIe(e, t, n) && BQ(e); let i = e._classProperty, o = i.isArray, r = i.type, s = Dn.getComponentCount(r); if (l(e._unpackedValues)) { i.isArray && (n = tt(n, !0)), e._unpackedValues[t] = n; return } if (!o && s === 1) { e._setValue(t, n); return } let a, c; if (i.isVariableLengthArray) a = e._arrayOffsets.get(t), c = e._arrayOffsets.get(t + 1) - a; else { let f = y(i.arrayLength, 1) * e._vectorComponentCount; a = t * f, c = f } for (let u = 0; u < c; ++u)e._setValue(a + u, n[u]) } function dIe(e, t, n) { let i = n.get(e), o = n.get(e + 1) - i; return pl(t.typedArray, i, o) } function hIe(e, t) { let n = e >> 3, i = e % 8; return (t.typedArray[n] >> i & 1) === 1 } function mIe(e, t, n) { let i = e >> 3, o = e % 8; n ? t.typedArray[i] |= 1 << o : t.typedArray[i] &= ~(1 << o) } function pIe(e, t) { let n = t.dataView, i = e * 8, o = 0, r = (n.getUint8(i + 7) & 128) > 0, s = !0; for (let a = 0; a < 8; ++a) { let c = n.getUint8(i + a); r && (s ? c !== 0 && (c = ~(c - 1) & 255, s = !1) : c = ~c & 255), o += c * Math.pow(256, a) } return r && (o = -o), o } function _Ie(e, t) { let n = t.dataView, i = e * 8, o = BigInt(0), r = (n.getUint8(i + 7) & 128) > 0, s = !0; for (let a = 0; a < 8; ++a) { let c = n.getUint8(i + a); r && (s ? c !== 0 && (c = ~(c - 1) & 255, s = !1) : c = ~c & 255), o += BigInt(c) * (BigInt(1) << BigInt(a * 8)) } return r && (o = -o), o } function gIe(e, t) { let n = t.dataView, i = e * 8, o = n.getUint32(i, !0), r = n.getUint32(i + 4, !0); return o + 4294967296 * r } function yIe(e, t) { let n = t.dataView, i = e * 8, o = BigInt(n.getUint32(i, !0)), r = BigInt(n.getUint32(i + 4, !0)); return o + BigInt(4294967296) * r } function AIe(e) { switch (e) { case wn.INT8: return Y.BYTE; case wn.UINT8: return Y.UNSIGNED_BYTE; case wn.INT16: return Y.SHORT; case wn.UINT16: return Y.UNSIGNED_SHORT; case wn.INT32: return Y.INT; case wn.UINT32: return Y.UNSIGNED_INT; case wn.FLOAT32: return Y.FLOAT; case wn.FLOAT64: return Y.DOUBLE } } function OQ(e) { if (l(e._unpackedValues)) return !1; let t = e._classProperty, n = t.type, i = t.valueType; return n === Dn.STRING || i === wn.INT64 && !Nt.supportsBigInt64Array() || i === wn.UINT64 && !Nt.supportsBigUint64Array() } function CIe(e, t, n) { if (OQ(e)) return !0; let i = e._arrayOffsets; if (l(i)) { let o = i.get(t + 1) - i.get(t), r = n.length; if (o !== r) return !0 } return !1 } function BQ(e) { e._unpackedValues = xIe(e), e._arrayOffsets = void 0, e._stringOffsets = void 0, e._values = void 0 } function xIe(e) { let t = e._count, n = new Array(t), i = e._classProperty, o = i.isArray, r = i.type, s = Dn.getComponentCount(r); if (!o && s === 1) { for (let a = 0; a < t; ++a)n[a] = e._getValue(a); return n } for (let a = 0; a < t; a++)n[a] = IQ(e, i, a); return n } function TIe(e, t) { let i = e._classProperty.isVariableLengthArray; return !e._hasValueTransform || i ? t : M0.valueTransformInPlace(t, e._offset, e._scale, wn.applyValueTransform) } function EIe(e, t) { let i = e._classProperty.isVariableLengthArray; return !e._hasValueTransform || i ? t : M0.valueTransformInPlace(t, e._offset, e._scale, wn.unapplyValueTransform) } function KG(e, t, n) { let i = this, o, r, s; if (t === wn.INT64) Nt.supportsBigInt() ? Nt.supportsBigInt64Array() ? (o = new BigInt64Array(e.buffer, e.byteOffset, n), s = function (a, c) { i.typedArray[a] = BigInt(c) }) : (o = new Uint8Array(e.buffer, e.byteOffset, n * 8), r = function (a) { return _Ie(a, i) }) : (Pt("INT64 type is not fully supported on this platform. Values greater than 2^53 - 1 or less than -(2^53 - 1) may lose precision when read."), o = new Uint8Array(e.buffer, e.byteOffset, n * 8), r = function (a) { return pIe(a, i) }); else if (t === wn.UINT64) Nt.supportsBigInt() ? Nt.supportsBigUint64Array() ? (o = new BigUint64Array(e.buffer, e.byteOffset, n), s = function (a, c) { i.typedArray[a] = BigInt(c) }) : (o = new Uint8Array(e.buffer, e.byteOffset, n * 8), r = function (a) { return yIe(a, i) }) : (Pt("UINT64 type is not fully supported on this platform. Values greater than 2^53 - 1 may lose precision when read."), o = new Uint8Array(e.buffer, e.byteOffset, n * 8), r = function (a) { return gIe(a, i) }); else { let a = AIe(t); o = Y.createArrayBufferView(a, e.buffer, e.byteOffset, n), s = function (c, u) { i.typedArray[c] = u } } l(r) || (r = function (a) { return i.typedArray[a] }), this.typedArray = o, this.dataView = new DataView(o.buffer, o.byteOffset), this.get = r, this.set = s, this._componentType = t } var qB = aS; function yf(e) { e = y(e, y.EMPTY_OBJECT); let t = e.count, n = e.class, i = 0, o = {}; if (l(e.properties)) { for (let r in e.properties) if (e.properties.hasOwnProperty(r)) { let s = new qB({ count: t, property: e.properties[r], classProperty: n.properties[r], bufferViews: e.bufferViews }); o[r] = s, i += s.byteLength } } this._count = t, this._class = n, this._properties = o, this._byteLength = i } Object.defineProperties(yf.prototype, { count: { get: function () { return this._count } }, class: { get: function () { return this._class } }, byteLength: { get: function () { return this._byteLength } } }); yf.prototype.hasProperty = function (e) { return Rn.hasProperty(e, this._properties, this._class) }; yf.prototype.hasPropertyBySemantic = function (e) { return Rn.hasPropertyBySemantic(e, this._properties, this._class) }; yf.prototype.getPropertyIds = function (e) { return Rn.getPropertyIds(this._properties, this._class, e) }; yf.prototype.getProperty = function (e, t) { let n = this._properties[t], i; return l(n) ? i = n.get(e) : i = bIe(this._class, t), i }; yf.prototype.setProperty = function (e, t, n) { let i = this._properties[t]; return l(i) ? (i.set(e, n), !0) : !1 }; yf.prototype.getPropertyBySemantic = function (e, t) { let n, i = this._class.propertiesBySemantic; if (l(i) && (n = i[t]), l(n)) return this.getProperty(e, n.id) }; yf.prototype.setPropertyBySemantic = function (e, t, n) { let i, o = this._class.propertiesBySemantic; return l(o) && (i = o[t]), l(i) ? this.setProperty(e, i.id, n) : !1 }; yf.prototype.getPropertyTypedArray = function (e) { let t = this._properties[e]; if (l(t)) return t.getTypedArray() }; yf.prototype.getPropertyTypedArrayBySemantic = function (e) { let t, n = this._class.propertiesBySemantic; if (l(n) && (t = n[e]), l(t)) return this.getPropertyTypedArray(t.id) }; function bIe(e, t) { let n = e.properties; if (!l(n)) return; let i = n[t]; if (l(i) && l(i.default)) { let o = i.default; return i.isArray && (o = tt(o, !0)), o = i.normalize(o), i.unpackVectorAndMatrixTypes(o) } } var Af = yf; function t_() { } Object.defineProperties(t_.prototype, { promise: { get: function () { ye.throwInstantiationError() } }, cacheKey: { get: function () { ye.throwInstantiationError() } } }); t_.prototype.load = function () { ye.throwInstantiationError() }; t_.prototype.unload = function () { }; t_.prototype.process = function (e) { }; t_.prototype.getError = function (e, t) {
        l(t) && (e += `
${t.message}`); let n = new fe(e); return l(t) && (n.stack = `Original stack:
${t.stack}
Handler stack:
${n.stack}`), n
    }; t_.prototype.isDestroyed = function () { return !1 }; t_.prototype.destroy = function () { return this.unload(), le(this) }; var Zi = t_; var SIe = { UNLOADED: 0, LOADING: 1, PROCESSING: 2, READY: 3, FAILED: 4 }, kt = Object.freeze(SIe); function Am(e) { e = y(e, y.EMPTY_OBJECT); let t = e.typedArray, n = e.resource, i = e.cacheKey; this._typedArray = t, this._resource = n, this._cacheKey = i, this._state = kt.UNLOADED, this._promise = void 0 } l(Object.create) && (Am.prototype = Object.create(Zi.prototype), Am.prototype.constructor = Am); Object.defineProperties(Am.prototype, { promise: { get: function () { return this._promise } }, cacheKey: { get: function () { return this._cacheKey } }, typedArray: { get: function () { return this._typedArray } } }); Am.prototype.load = function () { return l(this._typedArray) ? this._promise = Promise.resolve(this) : this._promise = wIe(this), this._promise }; function wIe(e) { let t = e._resource; return e._state = kt.LOADING, Am._fetchArrayBuffer(t).then(function (n) { if (!e.isDestroyed()) return e._typedArray = new Uint8Array(n), e._state = kt.READY, e }).catch(function (n) { if (e.isDestroyed()) return; e._state = kt.FAILED; let i = `Failed to load external buffer: ${t.url}`; return Promise.reject(e.getError(i, n)) }) } Am._fetchArrayBuffer = function (e) { return e.fetchArrayBuffer() }; Am.prototype.unload = function () { this._typedArray = void 0 }; var GC = Am; var iGt = function () { "use strict"; var e = "B9h79tEBBBENQ9gEUEU9gEUB9gBB9gVUUUUUEU9gDUUEU9gLUUUUEU9gVUUUUUB9gLUUUUB9gIUUUEU9gD99UE99I8ayDILEVLEVLOOOOORRVBWWBEdddLVE9wEIIVIEBEOWEUEC+g/KEKR/QIhO9tw9t9vv95DBh9f9f939h79t9f9j9h229f9jT9vv7BB8a9tw79o9v9wT9fw9u9j9v9kw9WwvTw949C919m9mwvBE8f9tw79o9v9wT9fw9u9j9v9kw9WwvTw949C919m9mwv9C9v919u9kBDe9tw79o9v9wT9fw9u9j9v9kw9WwvTw949Wwv79p9v9uBIy9tw79o9v9wT9fw9u9j9v9kw69u9kw949C919m9mwvBL8e9tw79o9v9wT9fw9u9j9v9kw69u9kw949C919m9mwv9C9v919u9kBV8a9tw79o9v9wT9fw9u9j9v9kw69u9kw949Wwv79p9v9uBOe9tw79o9v9wT9fw9u9j9v9kw69u9kw949Twg91w9u9jwBRA9tw79o9v9wT9fw9u9j9v9kw69u9kw949Twg91w9u9jw9C9v919u9kBWl9tw79o9v9wT9fw9u9j9v9kws9p2Twv9P9jTBdk9tw79o9v9wT9fw9u9j9v9kws9p2Twv9R919hTBQl9tw79o9v9wT9fw9u9j9v9kws9p2Twvt949wBKe9tw79o9v9wT9f9v9wT9p9t9p96w9WwvTw94j9h9j9owBpA9tw79o9v9wT9f9v9wT9p9t9p96w9WwvTw94j9h9j9ow9TTv9p9wBSA9tw79o9v9wT9f9v9wT9p9t9p96w9WwvTw94swT9j9o9Sw9t9h9wBZL79iv9rBhdWEBCEKDxcQ+1tyDBK/hKEyU8jJJJJBCJO9rGV8kJJJJBCBHODNALCEFAE0MBABCBrB+Q+KJJBC+gEv86BBAVCJDFCBCJDZ+TJJJB8aDNAItMBAVCJDFADALZmJJJB8aKABAEFHRABCEFHWAVALFCBCBCJDAL9rALCfE0eZ+TJJJB8aAVAVCJDFALZmJJJBHdCJ/ABAL9uHEDNDNALtMBAEC/wfBgGECJDAECJD6eHQCBHKINAKAI9PMEAdCJLFCBCJDZ+TJJJB8aAQAIAK9rAKAQFAI6eGXCSFGECL4CIFCD4HMADAKAL2FHpDNDNDNDNDNAEC9wgGStMBCBHZCEHhApHoAWHaXEKDNAXtMBCBHaCEHhApHcINAdAaFrBBHxAcHECBHOINAdCJLFAOFAErBBGqAx9rGxCETAxCkTCk91CR4786BBAEALFHEAqHxAOCEFGOAX9HMBKARAW9rAM6MIAWCBAMZ+TJJJBGEtMIAEAMFHWAcCEFHcAaCEFGaAL6HhAaAL9HMBXVKKARAW9rAM6MOAWCBAMZ+TJJJB8aCEHEINAWGxAMFHWALAEGOsMLDNARAW9rAM6MBAOCEFHEAWCBAMZ+TJJJB8aAxMEKKCBHWAOAL6MOXIKINDNAXtMBAdAZFrBBHxCBHEAoHOINAdCJLFAEFAOrBBGqAx9rGxCETAxCkTCk91CR4786BBAOALFHOAqHxAECEFGEAX9HMBKKARAa9rAM6MEARAaCBAMZ+TJJJBGlAMFGW9rCk6MDCBHkAdCJLFHcINAdCJLFAkFHyCWH8aCZHaCEHqINDNDNAqCE9HMBCUHOAyrBBMECBHODNINAOGECSsMEAECEFHOAcAEFCEFrBBtMBKKCUCBAECS6eHOXEKAqCETC/+fffEgHOCUAqTCU7CfEgHxCBHEINAOAxAcAEFrBB9NFHOAECEFGECZ9HMBKKAOAaAOAa6GEeHaAqA8aAEeH8aAqCETGqCW6MBKDNDNDNDNA8aCUFpDIEBKAlAkCO4FGEAErBBCDCIA8aCLseAkCI4COgTv86BBA8aCW9HMEAWAy8pBB83BBAWCWFAyCWF8pBB83BBAWCZFHWXDKAlAkCO4FGEAErBBCEAkCI4COgTv86BBKDNCWA8a9tGeMBINAWCB86BBAWCEFHWXBKKCUA8aTCU7HqCBH3AcH5INA5HEAeHxCBHOINAErBBGaAqAaAqCfEgGy6eAOCfEgA8aTvHOAECEFHEAxCUFGxMBKAWAO86BBA5AeFH5AWCEFHWA3AeFG3CZ6MBKCBHEINDNAcAEFrBBGOAy6MBAWAO86BBAWCEFHWKAECEFGECZ9HMBKKDNAkCZFGkAS9PMBAcCZFHcARAW9rCl0MEKKAkAS6MEAWtMEAoCEFHoAZCEFGZAL6HhAWHaAZALsMIXBKKCBHWAhCEgtMEXLKCBHWAhCEgMIKAdApAXCUFAL2FALZmJJJB8aAXAKFHKAWMBKCBHOXDKCBHOARAW9rCAALALCA6e6MEDNALC8f0MBAWCBCAAL9rGEZ+TJJJBAEFHWKAWAdCJDFALZmJJJBALFAB9rHOXEKCBHOKAVCJOF8kJJJJBAOK9HEEUAECAAECA0eABCJ/ABAE9uC/wfBgGDCJDADCJD6eGDFCUFAD9uAE2ADCL4CIFCD4ADv2FCEFKMBCBABbD+Q+KJJBK/YSE3U8jJJJJBC/AE9rGL8kJJJJBCBHVDNAICI9uGOChFAE0MBABCBYDn+KJJBGVC/gEv86BBALC/ABFCfECJEZ+TJJJB8aALCuFGR9CU83IBALC8wFGW9CU83IBALCYFGd9CU83IBALCAFGQ9CU83IBALCkFGK9CU83IBALCZFGX9CU83IBAL9CU83IWAL9CU83IBABAEFC9wFHMABCEFGpAOFHEDNAItMBCMCSAVCB9KGSeHZAVCE9IHhCBHoCBHaCBHcCBHxCBHqINDNAEAM9NMBCBHVXIKAqCUFHVADAcCDTFGOYDBHlAOCWFYDBHkAOCLFYDBHyCBH8aDNDNINALC/ABFAVCSgCITFGOYDLHeDNDNDNAOYDBGOAl9HMBAeAysMEKDNAOAy9HMBAeAk9HMBA8aCEFH8aXEKAOAk9HMEAeAl9HMEA8aCDFH8aKA8aC870MDAxCUFHVADA8aCIgCX2GOC+Y1JJBFYDBAcFCDTFYDBHeADAOCn1JJBFYDBAcFCDTFYDBHkADAOC+Q1JJBFYDBAcFCDTFYDBHlCBHODNINDNALAVCSgCDTFYDBAe9HMBAOHyXDKCUHyAVCUFHVAOCEFGOCZ9HMBKKAyCB9KAyAZ9IgGVCU7AeAosGOgH3DNDNDNDNDNAyCBCSAOeAVeGVCS9HMBAhMBAeAeAaAeCEFAasGVeGaCEFsMECMCSAVeHVKApAVA8aCDTC/wEgv86BBAVCS9HMEAeAa9rGVCETAVC8f917HVINAEAVCfB0CRTAVCfBgv86BBAECEFHEAVCJE6HOAVCR4HVAOtMBKAeHaXDKCpHVApA8aCDTCpv86BBAeHaKAVtMBAVAZ9IMEKALAxCDTFAebDBAxCEFCSgHxKAoA3FHoALC/ABFAqCITFGVAkbDLAVAebDBALC/ABFAqCEFCSgGVCITFGOAebDLAOAlbDBAVCEFHOXIKAVCUFHVA8aCLFG8aC/AB9HMBKKDNADCEAkAosCETAyAoseCX2GVC+Q1JJBFYDBAcFCDTFYDBGltADAVCn1JJBFYDBAcFCDTFYDBG8aCEsgADAVC+Y1JJBFYDBAcFCDTFYDBGyCDsgAoCB9HgASgG5CE9HMBAR9CU83IBAW9CU83IBAd9CU83IBAQ9CU83IBAK9CU83IBAX9CU83IBAL9CU83IWAL9CU83IBCBHoKCBHeAxCUFGVHODNINDNALAOCSgCDTFYDBA8a9HMBAeHkXDKCUHkAOCUFHOAeCEFGeCZ9HMBKKCBHODNINDNALAVCSgCDTFYDBAy9HMBAOHeXDKCUHeAVCUFHVAOCEFGOCZ9HMBKKAoAlAosG8eFH3DNDNAkCM0MBAkCEFHkXEKCBCSA8aA3sGVeHkA3AVFH3KDNDNAeCM0MBAeCEFHeXEKCBCSAyA3sGVeHeA3AVFH3KC9+CUA8eeH8fAeAkCLTvHOCBHVDNDNDNINAVCJ1JJBFrBBAOCfEgsMEAVCEFGVCZ9HMBXDKKAlAo9HAVCM0vA5vMBApAVC/wEv86BBXEKApA8f86BBAEAO86BBAECEFHEKDNA8eMBAlAa9rGVCETAVC8f917HVINAEAVCfB0GOCRTAVCfBgv86BBAVCR4HVAECEFHEAOMBKAlHaKDNAkCS9HMBA8aAa9rGVCETAVC8f917HVINAEAVCfB0GOCRTAVCfBgv86BBAVCR4HVAECEFHEAOMBKA8aHaKDNAeCS9HMBAyAa9rGVCETAVC8f917HVINAEAVCfB0GOCRTAVCfBgv86BBAVCR4HVAECEFHEAOMBKAyHaKALAxCDTFAlbDBAxCEFCSgHVDNDNAkpZBEEEEEEEEEEEEEEBEKALAVCDTFA8abDBAxCDFCSgHVKDNDNAepZBEEEEEEEEEEEEEEBEKALAVCDTFAybDBAVCEFCSgHVKALC/ABFAqCITFGOAlbDLAOA8abDBALC/ABFAqCEFCSgCITFGOA8abDLAOAybDBALC/ABFAqCDFCSgCITFGOAybDLAOAlbDBAqCIFHOAVHxA3HoKApCEFHpAOCSgHqAcCIFGcAI6MBKKCBHVAEAM0MBCBHVINAEAVFAVCJ1JJBFrBB86BBAVCEFGVCZ9HMBKAEAB9rAVFHVKALC/AEF8kJJJJBAVKzEEUCBHDDNINADCEFGDC8f0MECEADTAE6MBKKADCRFCfEgCR9uCI2CDFABCI9u2ChFKMBCBABbDn+KJJBK+cDEWU8jJJJJBCZ9rHLCBHVDNAICVFAE0MBCBHOABCBrBn+KJJBC/QEv86BBAL9CB83IWABCEFHRABAEFC98FHWDNAItMBCBHdINDNARAW6MBCBSKADAdCDTFYDBGQALCWFAOAQALCWFAOCDTFYDB9rGEAEC8f91GEFAE7C507GOCDTFGKYDB9rGEC8e91C9+gAECDT7AOvHEINARAECfB0GVCRTAECfBgv86BBAECR4HEARCEFHRAVMBKAKAQbDBAdCEFGdAI9HMBKKCBHVARAW0MBARCBbBBARAB9rCLFHVKAVKbEEUCBHDDNINADCEFGDC8f0MECEADTAE6MBKKADCWFCfEgCR9uAB2CVFK+DVLI99DUI99LUDNAEtMBCUADCETCUFTCU7+yHVDNDNCUAICUFTCU7+yGOjBBBzmGR+LjBBB9P9dtMBAR+oHWXEKCJJJJ94HWKCBHICBHdINALCLFiDBGRjBBBBjBBJzALiDBGQ+LAR+LmALCWFiDBGK+LmGR+VARjBBBB9beGRnHXAQARnHRALCXFiDBHQDNDNAKjBBBB9gtMBAXHKXEKjBBJzAR+L+TGKAK+MAXjBBBB9geHKjBBJzAX+L+TGXAX+MARjBBBB9geHRKDNDNAQjBBJ+/AQjBBJ+/9geGXjBBJzAXjBBJz9feAVnjBBBzjBBB+/AQjBBBB9gemGQ+LjBBB9P9dtMBAQ+oHMXEKCJJJJ94HMKDNDNAKjBBJ+/AKjBBJ+/9geGQjBBJzAQjBBJz9feAOnjBBBzjBBB+/AKjBBBB9gemGQ+LjBBB9P9dtMBAQ+oHpXEKCJJJJ94HpKDNDNARjBBJ+/ARjBBJ+/9geGQjBBJzAQjBBJz9feAOnjBBBzjBBB+/ARjBBBB9gemGR+LjBBB9P9dtMBAR+oHSXEKCJJJJ94HSKDNDNADCL9HMBABAdFGZAS86BBAZCIFAM86BBAZCDFAW86BBAZCEFAp86BBXEKABAIFGZAS87EBAZCOFAM87EBAZCLFAW87EBAZCDFAp87EBKALCZFHLAICWFHIAdCLFHdAECUFGEMBKKK/KLLD99EUD99EUDNAEtMBDNDNCUAICUFTCU7+yGVjBBBzmGO+LjBBB9P9dtMBAO+oHIXEKCJJJJ94HIKAIC/8fIgHRINABCOFCICDALCLFiDB+LALiDB+L9eGIALCWFiDB+LALAICDTFiDB+L9eeGIALCXFiDB+LALAICDTFiDB+L9eeGIARv87EBDNDNALAICEFCIgCDTFiDBj/zL+1znjBBJ+/jBBJzALAICDTFiDBjBBBB9deGOnGWjBBJ+/AWjBBJ+/9geGdjBBJzAdjBBJz9feAVnjBBBzjBBB+/AWjBBBB9gemGW+LjBBB9P9dtMBAW+oHQXEKCJJJJ94HQKABAQ87EBDNDNAOALAICDFCIgCDTFiDBj/zL+1znnGWjBBJ+/AWjBBJ+/9geGdjBBJzAdjBBJz9feAVnjBBBzjBBB+/AWjBBBB9gemGW+LjBBB9P9dtMBAW+oHQXEKCJJJJ94HQKABCDFAQ87EBDNDNAOALAICUFCIgCDTFiDBj/zL+1znnGOjBBJ+/AOjBBJ+/9geGWjBBJzAWjBBJz9feAVnjBBBzjBBB+/AOjBBBB9gemGO+LjBBB9P9dtMBAO+oHIXEKCJJJJ94HIKABCLFAI87EBABCWFHBALCZFHLAECUFGEMBKKK+7DDWUE998jJJJJBCZ9rGV8kJJJJBDNAEtMBADCL6MBCEAI9rHOADCD4GDCEADCE0eHRADCDTHWCBHdINC+cUHDALHIARHQINAIiDBAVCXFZ+XJJJB8aAVYDXGKADADAK9IeHDAICLFHIAQCUFGQMBKAOADFGICkTHKCBHDCBAI9rHXARHIINDNDNALADFiDBGMAXZ+WJJJBjBBBzjBBB+/AMjBBBB9gemGM+LjBBB9P9dtMBAM+oHQXEKCJJJJ94HQKABADFAQCfffRgAKvbDBADCLFHDAICUFGIMBKABAWFHBALAWFHLAdCEFGdAE9HMBKKAVCZF8kJJJJBK/tKDcUI998jJJJJBC+QD9rGV8kJJJJBAVC+oEFCBC/kBZ+TJJJB8aCBHODNADtMBCBHOAItMBDNABAE9HMBAVCUADCDTGOADCffffI0eCBYD1+KJJBhJJJJBBGEbD+oEAVCEbD1DAEABAOZmJJJB8aKAVC+YEFCWFCBbDBAV9CB83I+YEAVC+YEFAEADAIAVC+oEFZ+NJJJBCUAICDTGRAICffffI0eGWCBYD1+KJJBhJJJJBBHOAVC+oEFAVYD1DGdCDTFAObDBAVAdCEFGQbD1DAOAVYD+YEGKARZmJJJBHXAVC+oEFAQCDTFADCI9uGMCBYD1+KJJBhJJJJBBGObDBAVAdCDFGRbD1DAOCBAMZ+TJJJBHpAVC+oEFARCDTFAWCBYD1+KJJBhJJJJBBGSbDBAVAdCIFGQbD1DAXHOASHRINARALiDBALAOYDBGWCWAWCW6eCDTFC/EBFiDBmuDBAOCLFHOARCLFHRAICUFGIMBKAVC+oEFAQCDTFCUAMCDTADCffff970eCBYD1+KJJBhJJJJBBGQbDBAVAdCLFbD1DDNADCI6MBAMCEAMCE0eHIAEHOAQHRINARASAOYDBCDTFiDBASAOCLFYDBCDTFiDBmASAOCWFYDBCDTFiDBmuDBAOCXFHOARCLFHRAICUFGIMBKKAVC/MBFHZAVYD+cEHhAVYD+gEHoAVHOCBHWCBHRCBHaCEHcINAOHxCIHqAEARCI2GlCDTFGOCWFYDBHkAOYDBHDABAaCX2FGICLFAOCLFYDBGdbDBAIADbDBAICWFAkbDBApARFCE86BBAZAkbDWAZAdbDLAZADbDBAQARCDTFCBbDBDNAWtMBCIHqAxHIINDNAIYDBGOADsMBAOAdsMBAOAksMBAZAqCDTFAObDBAqCEFHqKAICLFHIAWCUFGWMBKKAaCEFHaAXADCDTFGOAOYDBCUFbDBAXAdCDTFGOAOYDBCUFbDBAXAkCDTFGOAOYDBCUFbDBCBHWINAoAhAEAWAlFCDTFYDBCDTGIFYDBCDTFGkHOAKAIFGdYDBGDHIDNADtMBDNINAOYDBARsMEAOCLFHOAICUFGItMDXBKKAOADCDTAkFC98FYDBbDBAdAdYDBCUFbDBKAWCEFGWCI9HMBKDNDNDNAqtMBCUHRjBBBBHyCBHOINASAZAOCDTFYDBCDTGIFGWiDBH8aAWALCBAOCEFGdAOCS0eCDTFiDBALAXAIFYDBGOCWAOCW6eCDTFC/EBFiDBmGeuDBDNAKAIFYDBGWtMBAeA8a+THeAoAhAIFYDBCDTFHOAWCDTHIINAQAOYDBGWCDTFGDAeADiDBmG8auDBA8aAyAyA8a9dGDeHyAWARADeHRAOCLFHOAIC98FGIMBKKAdHOAdAq9HMBKARCU9HMEKAcAM9PMEINDNApAcFrBBMBAcHRXDKAMAcCEFGc9HMBXDKKAqCZAqCZ6eHWAZHOAxHZARCU9HMEKKAVYD1DHOKAOCDTAVC+oEFFC98FHRDNINAOtMEARYDBCBYD+E+KJJBh+BJJJBBARC98FHRAOCUFHOXBKKAVC+QDF8kJJJJBK/uLEVUCUAICDTGVAICffffI0eGOCBYD1+KJJBhJJJJBBHRALALYD9gGWCDTFARbDBALAWCEFbD9gABARbDBAOCBYD1+KJJBhJJJJBBHRALALYD9gGOCDTFARbDBALAOCEFbD9gABARbDLCUADCDTADCffffI0eCBYD1+KJJBhJJJJBBHRALALYD9gGOCDTFARbDBALAOCEFbD9gABARbDWABYDBCBAVZ+TJJJB8aADCI9uHWDNADtMBABYDBHOAEHLADHRINAOALYDBCDTFGVAVYDBCEFbDBALCLFHLARCUFGRMBKKDNAItMBABYDBHLABYDLHRCBHVAIHOINARAVbDBARCLFHRALYDBAVFHVALCLFHLAOCUFGOMBKKDNADCI6MBAWCEAWCE0eHdABYDLHRABYDWHVCBHLINAECWFYDBHOAECLFYDBHDARAEYDBCDTFGWAWYDBGWCEFbDBAVAWCDTFALbDBARADCDTFGDADYDBGDCEFbDBAVADCDTFALbDBARAOCDTFGOAOYDBGOCEFbDBAVAOCDTFALbDBAECXFHEAdALCEFGL9HMBKKDNAItMBABYDLHEABYDBHLINAEAEYDBALYDB9rbDBALCLFHLAECLFHEAICUFGIMBKKKqBABAEADAIC+01JJBZ+MJJJBKqBABAEADAIC+c+JJJBZ+MJJJBK9dEEUABCfEAICDTZ+TJJJBHLCBHIDNADtMBINDNALAEYDBCDTFGBYDBCU9HMBABAIbDBAICEFHIKAECLFHEADCUFGDMBKKAIK9TEIUCBCBYD+M+KJJBGEABCIFC98gFGBbD+M+KJJBDNDNABzBCZTGD9NMBCUHIABAD9rCffIFCZ4NBCUsMEKAEHIKAIK/lEEEUDNDNAEABvCIgtMBABHIXEKDNDNADCZ9PMBABHIXEKABHIINAIAEYDBbDBAICLFAECLFYDBbDBAICWFAECWFYDBbDBAICXFAECXFYDBbDBAICZFHIAECZFHEADC9wFGDCS0MBKKADCL6MBINAIAEYDBbDBAECLFHEAICLFHIADC98FGDCI0MBKKDNADtMBINAIAErBB86BBAICEFHIAECEFHEADCUFGDMBKKABK/AEEDUDNDNABCIgtMBABHIXEKAECfEgC+B+C+EW2HLDNDNADCZ9PMBABHIXEKABHIINAIALbDBAICXFALbDBAICWFALbDBAICLFALbDBAICZFHIADC9wFGDCS0MBKKADCL6MBINAIALbDBAICLFHIADC98FGDCI0MBKKDNADtMBINAIAE86BBAICEFHIADCUFGDMBKKABK9TEIUCBCBYD+M+KJJBGEABCIFC98gFGBbD+M+KJJBDNDNABzBCZTGD9NMBCUHIABAD9rCffIFCZ4NBCUsMEKAEHIKAIK9+EIUzBHEDNDNCBYD+M+KJJBGDAECZTGI9NMBCUHEADAI9rCffIFCZ4NBCUsMEKADHEKCBABAE9rCIFC98gCBYD+M+KJJBFGDbD+M+KJJBDNADzBCZTGE9NMBADAE9rCffIFCZ4NB8aKKXBABAEZ+YJJJBK+BEEIUDNAB+8GDCl4GICfEgGLCfEsMBDNALMBDNABjBBBB9cMBAECBbDBABSKABjBBJ9fnAEZ+XJJJBHBAEAEYDBCNFbDBABSKAEAICfEgC+CUFbDBADCfff+D94gCJJJ/4Iv++HBKABK+gEBDNDNAECJE9IMBABjBBBUnHBDNAECfE9PMBAEC+BUFHEXDKABjBBBUnHBAECPDAECPD6eC+C9+FHEXEKAEC+BU9KMBABjBBJXnHBDNAEC+b9+9NMBAEC/mBFHEXEKABjBBJXnHBAEC+299AEC+2990eC/MEFHEKABAEClTCJJJ/8IF++nKK+eDDBCJWK+EDB4+H9W9n94+p+Gw+J9o+YE9pBBBBBBEBBBDBBBEBBBDBBBBBBBDBBBBBBBEBBBBBBB+L29Hz/69+9Kz/n/76z/RG97z/Z/O9Xz8j/b85z/+/U9Yz/B/K9hz+2/z9dz9E+L9Mz59a8kz+R/t3z+a+Zyz79ohz/J4++8++y+d9v8+BBBB9S+49+z8r+Hbz9m9m/m8+l/Z/O8+/8+pg89Q/X+j878r+Hq8++m+b/E87BBBBBBJzBBJzBBJz+e/v/n8++y+dSz9I/h/68+XD/r8+/H0838+/w+nOzBBBB+wv9o8+UF888+9I/h/68+9C9g/l89/N/M9M89/d8kO8+BBBBF+8Tz9M836zs+2azl/Zpzz818ez9E+LXz/u98f8+819e/68+BC+EQKXEBBBDBBBAwBB", t = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]); if (typeof WebAssembly != "object") return { supported: !1 }; var n, i = WebAssembly.instantiate(o(e), {}).then(function (p) { n = p.instance, n.exports.__wasm_call_ctors(), n.exports.meshopt_encodeVertexVersion(0), n.exports.meshopt_encodeIndexVersion(1) }); function o(p) { for (var g = new Uint8Array(p.length), m = 0; m < p.length; ++m) { var A = p.charCodeAt(m); g[m] = A > 96 ? A - 71 : A > 64 ? A - 65 : A > 47 ? A + 4 : A > 46 ? 63 : 62 } for (var C = 0, m = 0; m < p.length; ++m)g[C++] = g[m] < 60 ? t[g[m]] : (g[m] - 60) * 64 + g[++m]; return g.buffer.slice(0, C) } function r(p) { if (!p) throw new Error("Assertion failed") } function s(p) { return new Uint8Array(p.buffer, p.byteOffset, p.byteLength) } function a(p, g, m) { var A = n.exports.sbrk, C = A(p.length * 4), x = A(g * 4), T = new Uint8Array(n.exports.memory.buffer), b = s(p); T.set(b, C), m && m(C, C, p.length, g); var S = n.exports.meshopt_optimizeVertexFetchRemap(x, C, p.length, g); T = new Uint8Array(n.exports.memory.buffer); var D = new Uint32Array(g); new Uint8Array(D.buffer).set(T.subarray(x, x + g * 4)), b.set(T.subarray(C, C + p.length * 4)), A(C - A(0)); for (var P = 0; P < p.length; ++P)p[P] = D[p[P]]; return [D, S] } function c(p, g, m, A, C) { var x = n.exports.sbrk, T = x(g), b = x(A * C), S = new Uint8Array(n.exports.memory.buffer); S.set(s(m), b); var D = p(T, g, b, A, C), P = new Uint8Array(D); return P.set(S.subarray(T, T + D)), x(T - x(0)), P } function u(p) { for (var g = 0, m = 0; m < p.length; ++m) { var A = p[m]; g = g < A ? A : g } return g } function f(p, g) { if (r(g == 2 || g == 4), g == 4) return new Uint32Array(p.buffer, p.byteOffset, p.byteLength / 4); var m = new Uint16Array(p.buffer, p.byteOffset, p.byteLength / 2); return new Uint32Array(m) } function d(p, g, m, A, C, x) { var T = n.exports.sbrk, b = T(m * A), S = T(m * x), D = new Uint8Array(n.exports.memory.buffer); D.set(s(g), S), p(b, m, A, C, S); var P = new Uint8Array(m * A); return P.set(D.subarray(b, b + m * A)), T(b - T(0)), P } return { ready: i, supported: !0, reorderMesh: function (p, g, m) { var A = g ? m ? n.exports.meshopt_optimizeVertexCacheStrip : n.exports.meshopt_optimizeVertexCache : void 0; return a(p, u(p) + 1, A) }, encodeVertexBuffer: function (p, g, m) { r(m > 0 && m <= 256), r(m % 4 == 0); var A = n.exports.meshopt_encodeVertexBufferBound(g, m); return c(n.exports.meshopt_encodeVertexBuffer, A, p, g, m) }, encodeIndexBuffer: function (p, g, m) { r(m == 2 || m == 4), r(g % 3 == 0); var A = f(p, m), C = n.exports.meshopt_encodeIndexBufferBound(g, u(A) + 1); return c(n.exports.meshopt_encodeIndexBuffer, C, A, g, 4) }, encodeIndexSequence: function (p, g, m) { r(m == 2 || m == 4); var A = f(p, m), C = n.exports.meshopt_encodeIndexSequenceBound(g, u(A) + 1); return c(n.exports.meshopt_encodeIndexSequence, C, A, g, 4) }, encodeGltfBuffer: function (p, g, m, A) { var C = { ATTRIBUTES: this.encodeVertexBuffer, TRIANGLES: this.encodeIndexBuffer, INDICES: this.encodeIndexSequence }; return r(C[A]), C[A](p, g, m) }, encodeFilterOct: function (p, g, m, A) { return r(m == 4 || m == 8), r(A >= 1 && A <= 16), d(n.exports.meshopt_encodeFilterOct, p, g, m, A, 16) }, encodeFilterQuat: function (p, g, m, A) { return r(m == 8), r(A >= 4 && A <= 16), d(n.exports.meshopt_encodeFilterQuat, p, g, m, A, 16) }, encodeFilterExp: function (p, g, m, A) { return r(m > 0 && m % 4 == 0), r(A >= 1 && A <= 24), d(n.exports.meshopt_encodeFilterExp, p, g, m, A, m) } } }(); var RQ = function () { "use strict"; var e = "B9h79tEBBBE8fV9gBB9gVUUUUUEU9gIUUUB9gEUEU9gIUUUEUIKQBEEEDDDILLVIEBEOWEUEC+Q/IEKR/LEdO9tw9t9vv95DBh9f9f939h79t9f9j9h229f9jT9vv7BB8a9tw79o9v9wT9f9kw9j9v9kw9WwvTw949C919m9mwvBEy9tw79o9v9wT9f9kw9j9v9kw69u9kw949C919m9mwvBDe9tw79o9v9wT9f9kw9j9v9kw69u9kw949Twg91w9u9jwBIl9tw79o9v9wT9f9kw9j9v9kws9p2Twv9P9jTBLk9tw79o9v9wT9f9kw9j9v9kws9p2Twv9R919hTBVl9tw79o9v9wT9f9kw9j9v9kws9p2Twvt949wBOL79iv9rBRQ+p8yQDBK/3SEZU8jJJJJBCJ/EB9rGV8kJJJJBC9+HODNADCEFAL0MBCUHOAIrBBC+gE9HMBAVAIALFGRAD9rADZ1JJJBHWCJ/ABAD9uHOAICEFHLDNADtMBAOC/wfBgGOCJDAOCJD6eHdCBHQINAQAE9PMEAdAEAQ9rAQAdFAE6eGKCSFGOCL4CIFCD4HXDNDNDNDNAOC9wgGMtMBCBHpCEHSAWCJDFHZALHhINARAh9rAX6MIDNARAhAXFGL9rCk6MBCZHOINAWCJ/CBFAOGIFGOC9wFHoDNDNDNDNDNAhAIC9wFGaCO4FrBBAaCI4COg4CIgpLBEDIBKAo9CB83IBAoCWF9CB83IBXIKAoALrBLALrBBGaCO4GcAcCIsGce86BBAOCgFALCLFAcFGorBBAaCL4CIgGcAcCIsGce86BBAOCvFAoAcFGorBBAaCD4CIgGcAcCIsGce86BBAOC7FAoAcFGorBBAaCIgGaAaCIsGae86BBAOCTFAoAaFGarBBALrBEGoCO4GcAcCIsGce86BBAOC91FAaAcFGarBBAoCL4CIgGcAcCIsGce86BBAOC4FAaAcFGarBBAoCD4CIgGcAcCIsGce86BBAOC93FAaAcFGarBBAoCIgGoAoCIsGoe86BBAOC94FAaAoFGarBBALrBDGoCO4GcAcCIsGce86BBAOC95FAaAcFGarBBAoCL4CIgGcAcCIsGce86BBAOC96FAaAcFGarBBAoCD4CIgGcAcCIsGce86BBAOC97FAaAcFGarBBAoCIgGoAoCIsGoe86BBAOC98FAaAoFGorBBALrBIGLCO4GaAaCIsGae86BBAOC99FAoAaFGorBBALCL4CIgGaAaCIsGae86BBAOC9+FAoAaFGorBBALCD4CIgGaAaCIsGae86BBAOCUFAoAaFGOrBBALCIgGLALCIsGLe86BBAOALFHLXDKAoALrBWALrBBGaCL4GcAcCSsGce86BBAOCgFALCWFAcFGorBBAaCSgGaAaCSsGae86BBAOCvFAoAaFGorBBALrBEGaCL4GcAcCSsGce86BBAOC7FAoAcFGorBBAaCSgGaAaCSsGae86BBAOCTFAoAaFGorBBALrBDGaCL4GcAcCSsGce86BBAOC91FAoAcFGorBBAaCSgGaAaCSsGae86BBAOC4FAoAaFGorBBALrBIGaCL4GcAcCSsGce86BBAOC93FAoAcFGorBBAaCSgGaAaCSsGae86BBAOC94FAoAaFGorBBALrBLGaCL4GcAcCSsGce86BBAOC95FAoAcFGorBBAaCSgGaAaCSsGae86BBAOC96FAoAaFGorBBALrBVGaCL4GcAcCSsGce86BBAOC97FAoAcFGorBBAaCSgGaAaCSsGae86BBAOC98FAoAaFGorBBALrBOGaCL4GcAcCSsGce86BBAOC99FAoAcFGorBBAaCSgGaAaCSsGae86BBAOC9+FAoAaFGorBBALrBRGLCL4GaAaCSsGae86BBAOCUFAoAaFGOrBBALCSgGLALCSsGLe86BBAOALFHLXEKAoAL8pBB83BBAoCWFALCWF8pBB83BBALCZFHLKDNAIAM9PMBAICZFHOARAL9rCl0MEKKAIAM6MIALtMIDNAKtMBAWApFrBBHoCBHOAZHIINAIAWCJ/CBFAOFrBBGaCE4CBAaCEg9r7AoFGo86BBAIADFHIAOCEFGOAK9HMBKKAZCEFHZApCEFGpAD6HSALHhApAD9HMEXVKKCBHLASCEgMDXIKALAXAD2FHcDNAKtMBCBHhCEHSAWCJDFHMINARAL9rAX6MIALtMDALAXFHLAWAhFrBBHoCBHOAMHIINAIAWCJ/CBFAOFrBBGaCE4CBAaCEg9r7AoFGo86BBAIADFHIAOCEFGOAK9HMBKAMCEFHMAhCEFGhAD6HSAhAD9HMBKAcHLXIKCBHOCEHSINARAL9rAX6MDALtMEALAXFHLAOCEFGOAD6HSADAO9HMBKAcHLXDKCBHLASCEgtMEKC9+HOXIKABAQAD2FAWCJDFAKAD2Z1JJJB8aAWAWCJDFAKCUFAD2FADZ1JJJB8aAKAQFHQALMBKC9+HOXEKCBC99ARAL9rADCAADCA0eseHOKAVCJ/EBF8kJJJJBAOK/YZEhU8jJJJJBC/AE9rGV8kJJJJBC9+HODNAECI9uGRChFAL0MBCUHOAIrBBGWC/wEgC/gE9HMBAWCSgGdCE0MBAVC/ABFCfECJEZ+JJJJB8aAVCuF9CU83IBAVC8wF9CU83IBAVCYF9CU83IBAVCAF9CU83IBAVCkF9CU83IBAVCZF9CU83IBAV9CU83IWAV9CU83IBAIALFC9wFHQAICEFGWARFHODNAEtMBCMCSAdCEseHKCBHXCBHMCBHdCBHICBHLINDNAOAQ9NMBC9+HOXIKDNDNAWrBBGRC/vE0MBAVC/ABFALARCL4CU7FCSgCITFGpYDLHSApYDBHZDNARCSgGpAK9PMBAVAIARCU7FCSgCDTFYDBAXApeHRAptHpDNDNADCD9HMBABAdCETFGhAZ87EBAhCDFAS87EBAhCLFAR87EBXEKABAdCDTFGhAZbDBAhCLFASbDBAhCWFARbDBKAXApFHXAVC/ABFALCITFGhARbDBAhASbDLAVAICDTFARbDBAVC/ABFALCEFCSgGLCITFGhAZbDBAhARbDLAIApFHIALCEFHLXDKDNDNApCSsMBAMApFApC987FCEFHMXEKAOCEFHRAO8sBBGpCfEgHhDNDNApCU9MMBARHOXEKAOCVFHOAhCfBgHhCRHpDNINAR8sBBGoCfBgApTAhvHhAoCU9KMEARCEFHRApCRFGpC8j9HMBXDKKARCEFHOKAhCE4CBAhCEg9r7AMFHMKDNDNADCD9HMBABAdCETFGRAZ87EBARCDFAS87EBARCLFAM87EBXEKABAdCDTFGRAZbDBARCLFASbDBARCWFAMbDBKAVC/ABFALCITFGRAMbDBARASbDLAVAICDTFAMbDBAVC/ABFALCEFCSgGLCITFGRAZbDBARAMbDLAICEFHIALCEFHLXEKDNARCPE0MBAXCEFGoAVAIAQARCSgFrBBGpCL49rCSgCDTFYDBApCZ6GheHRAVAIAp9rCSgCDTFYDBAoAhFGSApCSgGoeHpAotHoDNDNADCD9HMBABAdCETFGZAX87EBAZCDFAR87EBAZCLFAp87EBXEKABAdCDTFGZAXbDBAZCLFARbDBAZCWFApbDBKAVAICDTFAXbDBAVC/ABFALCITFGZARbDBAZAXbDLAVAICEFGICSgCDTFARbDBAVC/ABFALCEFCSgCITFGZApbDBAZARbDLAVAIAhFCSgGICDTFApbDBAVC/ABFALCDFCSgGLCITFGRAXbDBARApbDLALCEFHLAIAoFHIASAoFHXXEKAXCBAOrBBGZeGaARC/+EsGRFHSAZCSgHcAZCL4HxDNDNAZCS0MBASCEFHoXEKASHoAVAIAx9rCSgCDTFYDBHSKDNDNAcMBAoCEFHXXEKAoHXAVAIAZ9rCSgCDTFYDBHoKDNDNARtMBAOCEFHRXEKAOCDFHRAO8sBEGhCfEgHpDNAhCU9KMBAOCOFHaApCfBgHpCRHODNINAR8sBBGhCfBgAOTApvHpAhCU9KMEARCEFHRAOCRFGOC8j9HMBKAaHRXEKARCEFHRKApCE4CBApCEg9r7AMFGMHaKDNDNAxCSsMBARHpXEKARCEFHpAR8sBBGOCfEgHhDNAOCU9KMBARCVFHSAhCfBgHhCRHODNINAp8sBBGRCfBgAOTAhvHhARCU9KMEApCEFHpAOCRFGOC8j9HMBKASHpXEKApCEFHpKAhCE4CBAhCEg9r7AMFGMHSKDNDNAcCSsMBApHOXEKApCEFHOAp8sBBGRCfEgHhDNARCU9KMBApCVFHoAhCfBgHhCRHRDNINAO8sBBGpCfBgARTAhvHhApCU9KMEAOCEFHOARCRFGRC8j9HMBKAoHOXEKAOCEFHOKAhCE4CBAhCEg9r7AMFGMHoKDNDNADCD9HMBABAdCETFGRAa87EBARCDFAS87EBARCLFAo87EBXEKABAdCDTFGRAabDBARCLFASbDBARCWFAobDBKAVC/ABFALCITFGRASbDBARAabDLAVAICDTFAabDBAVC/ABFALCEFCSgCITFGRAobDBARASbDLAVAICEFGICSgCDTFASbDBAVC/ABFALCDFCSgCITFGRAabDBARAobDLAVAIAZCZ6AxCSsvFGICSgCDTFAobDBAIActAcCSsvFHIALCIFHLKAWCEFHWALCSgHLAICSgHIAdCIFGdAE6MBKKCBC99AOAQseHOKAVC/AEF8kJJJJBAOK+LLEVU8jJJJJBCZ9rHVC9+HODNAECVFAL0MBCUHOAIrBBC/+EgC/QE9HMBAV9CB83IWAICEFHRAIALFC98FHWDNAEtMBDNADCDsMBCBHdINDNARAW6MBC9+SKARCEFHOAR8sBBGLCfEgHIDNDNALCU9MMBAOHRXEKARCVFHRAICfBgHICRHLDNINAO8sBBGDCfBgALTAIvHIADCU9KMEAOCEFHOALCRFGLC8j9HMBXDKKAOCEFHRKABAdCDTFAICD4CBAICE4CEg9r7AVCWFAICEgCDTvGOYDBFGLbDBAOALbDBAdCEFGdAE9HMBXDKKCBHdINDNARAW6MBC9+SKARCEFHOAR8sBBGLCfEgHIDNDNALCU9MMBAOHRXEKARCVFHRAICfBgHICRHLDNINAO8sBBGDCfBgALTAIvHIADCU9KMEAOCEFHOALCRFGLC8j9HMBXDKKAOCEFHRKABAdCETFAICD4CBAICE4CEg9r7AVCWFAICEgCDTvGOYDBFGL87EBAOALbDBAdCEFGdAE9HMBKKCBC99ARAWseHOKAOK+lVOEUE99DUD99EUD99DNDNADCL9HMBAEtMEINDNDNABCDFGD8sBB+yAB8sBBGI+yGL+L+TABCEFGV8sBBGO+yGR+L+TGWjBB/+9CAWAWnjBBBBAWAWjBBBB9gGdeGQ+MGKAQAICB9IeALmGWAWnAKAQAOCB9IeARmGQAQnmm+R+VGLnjBBBzjBBB+/AdemGR+LjBBB9P9dtMBAR+oHIXEKCJJJJ94HIKADAI86BBDNDNAQALnjBBBzjBBB+/AQjBBBB9gemGQ+LjBBB9P9dtMBAQ+oHDXEKCJJJJ94HDKAVAD86BBDNDNAWALnjBBBzjBBB+/AWjBBBB9gemGW+LjBBB9P9dtMBAW+oHDXEKCJJJJ94HDKABAD86BBABCLFHBAECUFGEMBXDKKAEtMBINDNDNABCLFGD8uEB+yAB8uEBGI+yGL+L+TABCDFGV8uEBGO+yGR+L+TGWjB/+fsAWAWnjBBBBAWAWjBBBB9gGdeGQ+MGKAQAICB9IeALmGWAWnAKAQAOCB9IeARmGQAQnmm+R+VGLnjBBBzjBBB+/AdemGR+LjBBB9P9dtMBAR+oHIXEKCJJJJ94HIKADAI87EBDNDNAQALnjBBBzjBBB+/AQjBBBB9gemGQ+LjBBB9P9dtMBAQ+oHDXEKCJJJJ94HDKAVAD87EBDNDNAWALnjBBBzjBBB+/AWjBBBB9gemGW+LjBBB9P9dtMBAW+oHDXEKCJJJJ94HDKABAD87EBABCWFHBAECUFGEMBKKK/SILIUI99IUE99DNAEtMBCBHIABHLINDNDNj/zL81zALCOF8uEBGVCIv+y+VGOAL8uEB+ynGRjB/+fsnjBBBzjBBB+/ARjBBBB9gemGW+LjBBB9P9dtMBAW+oHdXEKCJJJJ94HdKALCLF8uEBHQALCDF8uEBHKABAVCEFCIgAIvCETFAd87EBDNDNAOAK+ynGWjB/+fsnjBBBzjBBB+/AWjBBBB9gemGX+LjBBB9P9dtMBAX+oHKXEKCJJJJ94HKKABAVCDFCIgAIvCETFAK87EBDNDNAOAQ+ynGOjB/+fsnjBBBzjBBB+/AOjBBBB9gemGX+LjBBB9P9dtMBAX+oHQXEKCJJJJ94HQKABAVCUFCIgAIvCETFAQ87EBDNDNjBBJzARARn+TAWAWn+TAOAOn+TGRjBBBBARjBBBB9ge+RjB/+fsnjBBBzmGR+LjBBB9P9dtMBAR+oHQXEKCJJJJ94HQKABAVCIgAIvCETFAQ87EBALCWFHLAICLFHIAECUFGEMBKKK9MBDNADCD4AE2GEtMBINABABYDBGDCWTCW91+yADCE91CJJJ/8IFCJJJ98g++nuDBABCLFHBAECUFGEMBKKK9TEIUCBCBYDJ1JJBGEABCIFC98gFGBbDJ1JJBDNDNABzBCZTGD9NMBCUHIABAD9rCffIFCZ4NBCUsMEKAEHIKAIK/lEEEUDNDNAEABvCIgtMBABHIXEKDNDNADCZ9PMBABHIXEKABHIINAIAEYDBbDBAICLFAECLFYDBbDBAICWFAECWFYDBbDBAICXFAECXFYDBbDBAICZFHIAECZFHEADC9wFGDCS0MBKKADCL6MBINAIAEYDBbDBAECLFHEAICLFHIADC98FGDCI0MBKKDNADtMBINAIAErBB86BBAICEFHIAECEFHEADCUFGDMBKKABK/AEEDUDNDNABCIgtMBABHIXEKAECfEgC+B+C+EW2HLDNDNADCZ9PMBABHIXEKABHIINAIALbDBAICXFALbDBAICWFALbDBAICLFALbDBAICZFHIADC9wFGDCS0MBKKADCL6MBINAIALbDBAICLFHIADC98FGDCI0MBKKDNADtMBINAIAE86BBAICEFHIADCUFGDMBKKABKKKEBCJWKLZ9kBB", t = "B9h79tEBBBEkL9gBB9gVUUUUUEU9gIUUUB9gEUEUIKQBBEBEEDDDILVE9wEEEVIEBEOWEUEC+Q/aEKR/LEdO9tw9t9vv95DBh9f9f939h79t9f9j9h229f9jT9vv7BB8a9tw79o9v9wT9f9kw9j9v9kw9WwvTw949C919m9mwvBDy9tw79o9v9wT9f9kw9j9v9kw69u9kw949C919m9mwvBLe9tw79o9v9wT9f9kw9j9v9kw69u9kw949Twg91w9u9jwBVl9tw79o9v9wT9f9kw9j9v9kws9p2Twv9P9jTBOk9tw79o9v9wT9f9kw9j9v9kws9p2Twv9R919hTBRl9tw79o9v9wT9f9kw9j9v9kws9p2Twvt949wBWL79iv9rBdQ/T9TQLBZIK9+EVU8jJJJJBCZ9rHBCBHEINCBHDCBHIINABCWFADFAICJUAEAD4CEgGLe86BBAIALFHIADCEFGDCW9HMBKAEC+Q+YJJBFAI86BBAECITC+Q1JJBFAB8pIW83IBAECEFGECJD9HMBKK/H8jLhUD97EUO978jJJJJBCJ/KB9rGV8kJJJJBC9+HODNADCEFAL0MBCUHOAIrBBC+gE9HMBAVAIALFGRAD9rAD/8QBBCJ/ABAD9uHOAICEFHLDNADtMBAOC/wfBgGOCJDAOCJD6eHWCBHdINAdAE9PMEAWAEAd9rAdAWFAE6eGQCSFGOC9wgGKCI2HXAKCETHMAOCL4CIFCD4HpABAdAD2FHSCBHZDNINCEHhALHoCBHaDNINARAo9rAp6MIAVCJ/CBFAaAK2FHcAoApFHLCBHIDNAKC/AB6MBARAL9rC/gB6MBCBHOINAcAOFHIDNDNDNDNDNAoAOCO4FrBBGxCIgpLBEDIBKAIPXBBBBBBBBBBBBBBBBPKLBXIKAIALPBBLALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlGqCDP+MEAqPMBZEhDoIaLcVxOqRlPXIIIIIIIIIIIIIIIIP9OGlPXIIIIIIIIIIIIIIIIP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLBALCLFAyPqBFAkC+Q+YJJBFrBBFHLXDKAIALPBBWALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlPXSSSSSSSSSSSSSSSSP9OGlPXSSSSSSSSSSSSSSSSP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLBALCWFAyPqBFAkC+Q+YJJBFrBBFHLXEKAIALPBBBPKLBALCZFHLKDNDNDNDNDNAxCD4CIgpLBEDIBKAIPXBBBBBBBBBBBBBBBBPKLZXIKAIALPBBLALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlGqCDP+MEAqPMBZEhDoIaLcVxOqRlPXIIIIIIIIIIIIIIIIP9OGlPXIIIIIIIIIIIIIIIIP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLZALCLFAyPqBFAkC+Q+YJJBFrBBFHLXDKAIALPBBWALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlPXSSSSSSSSSSSSSSSSP9OGlPXSSSSSSSSSSSSSSSSP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLZALCWFAyPqBFAkC+Q+YJJBFrBBFHLXEKAIALPBBBPKLZALCZFHLKDNDNDNDNDNAxCL4CIgpLBEDIBKAIPXBBBBBBBBBBBBBBBBPKLAXIKAIALPBBLALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlGqCDP+MEAqPMBZEhDoIaLcVxOqRlPXIIIIIIIIIIIIIIIIP9OGlPXIIIIIIIIIIIIIIIIP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLAALCLFAyPqBFAkC+Q+YJJBFrBBFHLXDKAIALPBBWALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlPXSSSSSSSSSSSSSSSSP9OGlPXSSSSSSSSSSSSSSSSP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLAALCWFAyPqBFAkC+Q+YJJBFrBBFHLXEKAIALPBBBPKLAALCZFHLKDNDNDNDNDNAxCO4pLBEDIBKAIPXBBBBBBBBBBBBBBBBPKL8wXIKAIALPBBLALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlGqCDP+MEAqPMBZEhDoIaLcVxOqRlPXIIIIIIIIIIIIIIIIP9OGlPXIIIIIIIIIIIIIIIIP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGxCITC+Q1JJBFPBIBAxC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGxCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKL8wALCLFAyPqBFAxC+Q+YJJBFrBBFHLXDKAIALPBBWALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlPXSSSSSSSSSSSSSSSSP9OGlPXSSSSSSSSSSSSSSSSP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGxCITC+Q1JJBFPBIBAxC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGxCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKL8wALCWFAyPqBFAxC+Q+YJJBFrBBFHLXEKAIALPBBBPKL8wALCZFHLKAOC/ABFHIAOCJEFAK0MEAIHOARAL9rC/fB0MBKKDNDNAIAK9PMBAICI4HOINARAL9rCk6MDAcAIFHxDNDNDNDNDNAoAICO4FrBBAOCOg4CIgpLBEDIBKAxPXBBBBBBBBBBBBBBBBPKLBXIKAxALPBBLALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlGqCDP+MEAqPMBZEhDoIaLcVxOqRlPXIIIIIIIIIIIIIIIIP9OGlPXIIIIIIIIIIIIIIIIP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLBALCLFAyPqBFAkC+Q+YJJBFrBBFHLXDKAxALPBBWALPBBBGqCLP+MEAqPMBZEhDoIaLcVxOqRlPXSSSSSSSSSSSSSSSSP9OGlPXSSSSSSSSSSSSSSSSP8jGqP5B9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBAkC+Q+YJJBFPBBBGyAyPMBBBBBBBBBBBBBBBBAqP5E9CJf/8/4/w/g/AB9+9Cu1+nGkCITC+Q1JJBFPBIBP9uPMBEDILVORZhoacxqlPpAlAqP9SPKLBALCWFAyPqBFAkC+Q+YJJBFrBBFHLXEKAxALPBBBPKLBALCZFHLKAOCDFHOAICZFGIAK6MBKKALtMBAaCI6HhALHoAaCEFGOHaAOCLsMDXEKKCBHLAhCEgMDKDNAKtMBAVCJDFAZFHIAVAZFPBDBHyCBHxINAIAVCJ/CBFAxFGOPBLBGlCEP9tAlPXEEEEEEEEEEEEEEEEGqP9OP9hP9RGlAOAKFPBLBG8aCEP9tA8aAqP9OP9hP9RG8aPMBZEhDoIaLcVxOqRlGeAOAMFPBLBG3CEP9tA3AqP9OP9hP9RG3AOAXFPBLBG5CEP9tA5AqP9OP9hP9RG5PMBZEhDoIaLcVxOqRlG8ePMBEZhDIoaLVcxORqlGqAqPMBEDIBEDIBEDIBEDIAyP9uGyP9aDBBAIADFGOAyAqAqPMLVORLVORLVORLVORP9uGyP9aDBBAOADFGOAyAqAqPMWdQKWdQKWdQKWdQKP9uGyP9aDBBAOADFGOAyAqAqPMXMpSXMpSXMpSXMpSP9uGyP9aDBBAOADFGOAyAeA8ePMWdkyQK8aeXM35pS8e8fGqAqPMBEDIBEDIBEDIBEDIP9uGyP9aDBBAOADFGOAyAqAqPMLVORLVORLVORLVORP9uGyP9aDBBAOADFGOAyAqAqPMWdQKWdQKWdQKWdQKP9uGyP9aDBBAOADFGOAyAqAqPMXMpSXMpSXMpSXMpSP9uGyP9aDBBAOADFGOAyAlA8aPMWkdyQ8aKeX3M5p8eS8fGlA3A5PMWkdyQ8aKeX3M5p8eS8fG8aPMBEZhDIoaLVcxORqlGqAqPMBEDIBEDIBEDIBEDIP9uGyP9aDBBAOADFGOAyAqAqPMLVORLVORLVORLVORP9uGyP9aDBBAOADFGOAyAqAqPMWdQKWdQKWdQKWdQKP9uGyP9aDBBAOADFGOAyAqAqPMXMpSXMpSXMpSXMpSP9uGyP9aDBBAOADFGOAyAlA8aPMWdkyQK8aeXM35pS8e8fGqAqPMBEDIBEDIBEDIBEDIP9uGyP9aDBBAOADFGOAyAqAqPMLVORLVORLVORLVORP9uGyP9aDBBAOADFGOAyAqAqPMWdQKWdQKWdQKWdQKP9uGyP9aDBBAOADFGOAyAqAqPMXMpSXMpSXMpSXMpSP9uGyP9aDBBAOADFHIAxCZFGxAK6MBKKAZCLFGZAD6MBKASAVCJDFAQAD2/8QBBAVAVCJDFAQCUFAD2FAD/8QBBAQAdFHdC9+HOALMEXIKKC9+HOXEKCBC99ARAL9rADCAADCA0eseHOKAVCJ/KBF8kJJJJBAOKWBZ+BJJJBK/UZEhU8jJJJJBC/AE9rGV8kJJJJBC9+HODNAECI9uGRChFAL0MBCUHOAIrBBGWC/wEgC/gE9HMBAWCSgGdCE0MBAVC/ABFCfECJE/8KBAVCuF9CU83IBAVC8wF9CU83IBAVCYF9CU83IBAVCAF9CU83IBAVCkF9CU83IBAVCZF9CU83IBAV9CU83IWAV9CU83IBAIALFC9wFHQAICEFGWARFHODNAEtMBCMCSAdCEseHKCBHXCBHMCBHdCBHICBHLINDNAOAQ9NMBC9+HOXIKDNDNAWrBBGRC/vE0MBAVC/ABFALARCL4CU7FCSgCITFGpYDLHSApYDBHZDNARCSgGpAK9PMBAVAIARCU7FCSgCDTFYDBAXApeHRAptHpDNDNADCD9HMBABAdCETFGhAZ87EBAhCDFAS87EBAhCLFAR87EBXEKABAdCDTFGhAZbDBAhCLFASbDBAhCWFARbDBKAXApFHXAVC/ABFALCITFGhARbDBAhASbDLAVAICDTFARbDBAVC/ABFALCEFCSgGLCITFGhAZbDBAhARbDLAIApFHIALCEFHLXDKDNDNApCSsMBAMApFApC987FCEFHMXEKAOCEFHRAO8sBBGpCfEgHhDNDNApCU9MMBARHOXEKAOCVFHOAhCfBgHhCRHpDNINAR8sBBGoCfBgApTAhvHhAoCU9KMEARCEFHRApCRFGpC8j9HMBXDKKARCEFHOKAhCE4CBAhCEg9r7AMFHMKDNDNADCD9HMBABAdCETFGRAZ87EBARCDFAS87EBARCLFAM87EBXEKABAdCDTFGRAZbDBARCLFASbDBARCWFAMbDBKAVC/ABFALCITFGRAMbDBARASbDLAVAICDTFAMbDBAVC/ABFALCEFCSgGLCITFGRAZbDBARAMbDLAICEFHIALCEFHLXEKDNARCPE0MBAXCEFGoAVAIAQARCSgFrBBGpCL49rCSgCDTFYDBApCZ6GheHRAVAIAp9rCSgCDTFYDBAoAhFGSApCSgGoeHpAotHoDNDNADCD9HMBABAdCETFGZAX87EBAZCDFAR87EBAZCLFAp87EBXEKABAdCDTFGZAXbDBAZCLFARbDBAZCWFApbDBKAVAICDTFAXbDBAVC/ABFALCITFGZARbDBAZAXbDLAVAICEFGICSgCDTFARbDBAVC/ABFALCEFCSgCITFGZApbDBAZARbDLAVAIAhFCSgGICDTFApbDBAVC/ABFALCDFCSgGLCITFGRAXbDBARApbDLALCEFHLAIAoFHIASAoFHXXEKAXCBAOrBBGZeGaARC/+EsGRFHSAZCSgHcAZCL4HxDNDNAZCS0MBASCEFHoXEKASHoAVAIAx9rCSgCDTFYDBHSKDNDNAcMBAoCEFHXXEKAoHXAVAIAZ9rCSgCDTFYDBHoKDNDNARtMBAOCEFHRXEKAOCDFHRAO8sBEGhCfEgHpDNAhCU9KMBAOCOFHaApCfBgHpCRHODNINAR8sBBGhCfBgAOTApvHpAhCU9KMEARCEFHRAOCRFGOC8j9HMBKAaHRXEKARCEFHRKApCE4CBApCEg9r7AMFGMHaKDNDNAxCSsMBARHpXEKARCEFHpAR8sBBGOCfEgHhDNAOCU9KMBARCVFHSAhCfBgHhCRHODNINAp8sBBGRCfBgAOTAhvHhARCU9KMEApCEFHpAOCRFGOC8j9HMBKASHpXEKApCEFHpKAhCE4CBAhCEg9r7AMFGMHSKDNDNAcCSsMBApHOXEKApCEFHOAp8sBBGRCfEgHhDNARCU9KMBApCVFHoAhCfBgHhCRHRDNINAO8sBBGpCfBgARTAhvHhApCU9KMEAOCEFHOARCRFGRC8j9HMBKAoHOXEKAOCEFHOKAhCE4CBAhCEg9r7AMFGMHoKDNDNADCD9HMBABAdCETFGRAa87EBARCDFAS87EBARCLFAo87EBXEKABAdCDTFGRAabDBARCLFASbDBARCWFAobDBKAVC/ABFALCITFGRASbDBARAabDLAVAICDTFAabDBAVC/ABFALCEFCSgCITFGRAobDBARASbDLAVAICEFGICSgCDTFASbDBAVC/ABFALCDFCSgCITFGRAabDBARAobDLAVAIAZCZ6AxCSsvFGICSgCDTFAobDBAIActAcCSsvFHIALCIFHLKAWCEFHWALCSgHLAICSgHIAdCIFGdAE6MBKKCBC99AOAQseHOKAVC/AEF8kJJJJBAOK+LLEVU8jJJJJBCZ9rHVC9+HODNAECVFAL0MBCUHOAIrBBC/+EgC/QE9HMBAV9CB83IWAICEFHRAIALFC98FHWDNAEtMBDNADCDsMBCBHdINDNARAW6MBC9+SKARCEFHOAR8sBBGLCfEgHIDNDNALCU9MMBAOHRXEKARCVFHRAICfBgHICRHLDNINAO8sBBGDCfBgALTAIvHIADCU9KMEAOCEFHOALCRFGLC8j9HMBXDKKAOCEFHRKABAdCDTFAICD4CBAICE4CEg9r7AVCWFAICEgCDTvGOYDBFGLbDBAOALbDBAdCEFGdAE9HMBXDKKCBHdINDNARAW6MBC9+SKARCEFHOAR8sBBGLCfEgHIDNDNALCU9MMBAOHRXEKARCVFHRAICfBgHICRHLDNINAO8sBBGDCfBgALTAIvHIADCU9KMEAOCEFHOALCRFGLC8j9HMBXDKKAOCEFHRKABAdCETFAICD4CBAICE4CEg9r7AVCWFAICEgCDTvGOYDBFGL87EBAOALbDBAdCEFGdAE9HMBKKCBC99ARAWseHOKAOK+epLIUO97EUE978jJJJJBCA9rHIDNDNADCL9HMBDNAEC98gGLtMBCBHVABHDINADADPBBBGOCkP+rECkP+sEP/6EGRAOCWP+rECkP+sEP/6EARP/gEAOCZP+rECkP+sEP/6EGWP/gEP/kEP/lEGdPXBBBBBBBBBBBBBBBBP+2EGQARPXBBBJBBBJBBBJBBBJGKP9OP9RP/kEGRPXBB/+9CBB/+9CBB/+9CBB/+9CARARP/mEAdAdP/mEAWAQAWAKP9OP9RP/kEGRARP/mEP/kEP/kEP/jEP/nEGWP/mEPXBBN0BBN0BBN0BBN0GQP/kEPXfBBBfBBBfBBBfBBBP9OAOPXBBBfBBBfBBBfBBBfP9OP9QARAWP/mEAQP/kECWP+rEPXBfBBBfBBBfBBBfBBP9OP9QAdAWP/mEAQP/kECZP+rEPXBBfBBBfBBBfBBBfBP9OP9QPKBBADCZFHDAVCLFGVAL6MBKKALAE9PMEAIAECIgGVCDTGDvCBCZAD9r/8KBAIABALCDTFGLAD/8QBBDNAVtMBAIAIPBLBGOCkP+rECkP+sEP/6EGRAOCWP+rECkP+sEP/6EARP/gEAOCZP+rECkP+sEP/6EGWP/gEP/kEP/lEGdPXBBBBBBBBBBBBBBBBP+2EGQARPXBBBJBBBJBBBJBBBJGKP9OP9RP/kEGRPXBB/+9CBB/+9CBB/+9CBB/+9CARARP/mEAdAdP/mEAWAQAWAKP9OP9RP/kEGRARP/mEP/kEP/kEP/jEP/nEGWP/mEPXBBN0BBN0BBN0BBN0GQP/kEPXfBBBfBBBfBBBfBBBP9OAOPXBBBfBBBfBBBfBBBfP9OP9QARAWP/mEAQP/kECWP+rEPXBfBBBfBBBfBBBfBBP9OP9QAdAWP/mEAQP/kECZP+rEPXBBfBBBfBBBfBBBfBP9OP9QPKLBKALAIAD/8QBBSKDNAEC98gGXtMBCBHVABHDINADCZFGLALPBBBGOPXBBBBBBffBBBBBBffGKP9OADPBBBGdAOPMLVORXMpScxql358e8fPXfUBBfUBBfUBBfUBBP9OP/6EAdAOPMBEDIWdQKZhoaky8aeGOCZP+sEP/6EGRP/gEAOCZP+rECZP+sEP/6EGWP/gEP/kEP/lEGOPXB/+fsB/+fsB/+fsB/+fsAWAOPXBBBBBBBBBBBBBBBBP+2EGQAWPXBBBJBBBJBBBJBBBJGMP9OP9RP/kEGWAWP/mEAOAOP/mEARAQARAMP9OP9RP/kEGOAOP/mEP/kEP/kEP/jEP/nEGRP/mEPXBBN0BBN0BBN0BBN0GQP/kECZP+rEAWARP/mEAQP/kEPXffBBffBBffBBffBBP9OP9QGWAOARP/mEAQP/kEPXffBBffBBffBBffBBP9OGOPMWdkyQK8aeXM35pS8e8fP9QPKBBADAdAKP9OAWAOPMBEZhDIoaLVcxORqlP9QPKBBADCAFHDAVCLFGVAX6MBKKAXAE9PMBAIAECIgGVCITGDFCBCAAD9r/8KBAIABAXCITFGLAD/8QBBDNAVtMBAIAIPBLZGOPXBBBBBBffBBBBBBffGKP9OAIPBLBGdAOPMLVORXMpScxql358e8fPXfUBBfUBBfUBBfUBBP9OP/6EAdAOPMBEDIWdQKZhoaky8aeGOCZP+sEP/6EGRP/gEAOCZP+rECZP+sEP/6EGWP/gEP/kEP/lEGOPXB/+fsB/+fsB/+fsB/+fsAWAOPXBBBBBBBBBBBBBBBBP+2EGQAWPXBBBJBBBJBBBJBBBJGMP9OP9RP/kEGWAWP/mEAOAOP/mEARAQARAMP9OP9RP/kEGOAOP/mEP/kEP/kEP/jEP/nEGRP/mEPXBBN0BBN0BBN0BBN0GQP/kECZP+rEAWARP/mEAQP/kEPXffBBffBBffBBffBBP9OP9QGWAOARP/mEAQP/kEPXffBBffBBffBBffBBP9OGOPMWdkyQK8aeXM35pS8e8fP9QPKLZAIAdAKP9OAWAOPMBEZhDIoaLVcxORqlP9QPKLBKALAIAD/8QBBKK/4WLLUE97EUV978jJJJJBC8w9rHIDNAEC98gGLtMBCBHVABHOINAIAOPBBBGRAOCZFGWPBBBGdPMLVORXMpScxql358e8fGQCZP+sEGKCLP+rEPKLBAOPXBBJzBBJzBBJzBBJzPX/zL81z/zL81z/zL81z/zL81zAKPXIBBBIBBBIBBBIBBBP9QP/6EP/nEGKARAdPMBEDIWdQKZhoaky8aeGRCZP+rECZP+sEP/6EP/mEGdAdP/mEAKARCZP+sEP/6EP/mEGXAXP/mEAKAQCZP+rECZP+sEP/6EP/mEGQAQP/mEP/kEP/kEP/lEPXBBBBBBBBBBBBBBBBP+4EP/jEPXB/+fsB/+fsB/+fsB/+fsGKP/mEPXBBN0BBN0BBN0BBN0GRP/kEPXffBBffBBffBBffBBGMP9OAXAKP/mEARP/kECZP+rEP9QGXAQAKP/mEARP/kECZP+rEAdAKP/mEARP/kEAMP9OP9QGKPMBEZhDIoaLVcxORqlGRP5BAIPBLBPeB+t+J83IBAOCWFARP5EAIPBLBPeE+t+J83IBAWAXAKPMWdkyQK8aeXM35pS8e8fGKP5BAIPBLBPeD+t+J83IBAOCkFAKP5EAIPBLBPeI+t+J83IBAOCAFHOAVCLFGVAL6MBKKDNALAE9PMBAIAECIgGVCITGOFCBCAAO9r/8KBAIABALCITFGWAO/8QBBDNAVtMBAIAIPBLBGRAIPBLZGdPMLVORXMpScxql358e8fGQCZP+sEGKCLP+rEPKLAAIPXBBJzBBJzBBJzBBJzPX/zL81z/zL81z/zL81z/zL81zAKPXIBBBIBBBIBBBIBBBP9QP/6EP/nEGKARAdPMBEDIWdQKZhoaky8aeGRCZP+rECZP+sEP/6EP/mEGdAdP/mEAKARCZP+sEP/6EP/mEGXAXP/mEAKAQCZP+rECZP+sEP/6EP/mEGQAQP/mEP/kEP/kEP/lEPXBBBBBBBBBBBBBBBBP+4EP/jEPXB/+fsB/+fsB/+fsB/+fsGKP/mEPXBBN0BBN0BBN0BBN0GRP/kEPXffBBffBBffBBffBBGMP9OAXAKP/mEARP/kECZP+rEP9QGXAQAKP/mEARP/kECZP+rEAdAKP/mEARP/kEAMP9OP9QGKPMBEZhDIoaLVcxORqlGRP5BAIPBLAPeB+t+J83IBAIARP5EAIPBLAPeE+t+J83IWAIAXAKPMWdkyQK8aeXM35pS8e8fGKP5BAIPBLAPeD+t+J83IZAIAKP5EAIPBLAPeI+t+J83IkKAWAIAO/8QBBKK+pDDIUE978jJJJJBC/AB9rHIDNADCD4AE2GLC98gGVtMBCBHDABHEINAEAEPBBBGOCWP+rECWP+sEP/6EAOCEP+sEPXBBJzBBJzBBJzBBJzP+uEPXBBJfBBJfBBJfBBJfP9OP/mEPKBBAECZFHEADCLFGDAV6MBKKDNAVAL9PMBAIALCIgGDCDTGEvCBC/ABAE9r/8KBAIABAVCDTFGVAE/8QBBDNADtMBAIAIPBLBGOCWP+rECWP+sEP/6EAOCEP+sEPXBBJzBBJzBBJzBBJzP+uEPXBBJfBBJfBBJfBBJfP9OP/mEPKLBKAVAIAE/8QBBKK9TEIUCBCBYDJ1JJBGEABCIFC98gFGBbDJ1JJBDNDNABzBCZTGD9NMBCUHIABAD9rCffIFCZ4NBCUsMEKAEHIKAIKKKEBCJWKLZ9tBB", n = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), i = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]); if (typeof WebAssembly != "object") return { supported: !1 }; var o = e; WebAssembly.validate(n) && (o = t); var r, s = WebAssembly.instantiate(a(o), {}).then(function (d) { r = d.instance, r.exports.__wasm_call_ctors() }); function a(d) { for (var p = new Uint8Array(d.length), g = 0; g < d.length; ++g) { var m = d.charCodeAt(g); p[g] = m > 96 ? m - 71 : m > 64 ? m - 65 : m > 47 ? m + 4 : m > 46 ? 63 : 62 } for (var A = 0, g = 0; g < d.length; ++g)p[A++] = p[g] < 60 ? i[p[g]] : (p[g] - 60) * 64 + p[++g]; return p.buffer.slice(0, A) } function c(d, p, g, m, A, C) { var x = r.exports.sbrk, T = g + 3 & -4, b = x(T * m), S = x(A.length), D = new Uint8Array(r.exports.memory.buffer); D.set(A, S); var P = d(b, g, m, S, A.length); if (P == 0 && C && C(b, T, m), p.set(D.subarray(b, b + g * m)), x(b - x(0)), P != 0) throw new Error("Malformed buffer data: " + P) } var u = { 0: "", 1: "meshopt_decodeFilterOct", 2: "meshopt_decodeFilterQuat", 3: "meshopt_decodeFilterExp", NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, f = { 0: "meshopt_decodeVertexBuffer", 1: "meshopt_decodeIndexBuffer", 2: "meshopt_decodeIndexSequence", ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" }; return { ready: s, supported: !0, decodeVertexBuffer: function (d, p, g, m, A) { c(r.exports.meshopt_decodeVertexBuffer, d, p, g, m, r.exports[u[A]]) }, decodeIndexBuffer: function (d, p, g, m) { c(r.exports.meshopt_decodeIndexBuffer, d, p, g, m) }, decodeIndexSequence: function (d, p, g, m) { c(r.exports.meshopt_decodeIndexSequence, d, p, g, m) }, decodeGltfBuffer: function (d, p, g, m, A, C) { c(r.exports[f[A]], d, p, g, m, r.exports[u[C]]) } } }(); var sGt = function () { "use strict"; var e = "B9h79tEBBBECd9gEUEU9gEUB9gBB9gQUUUUUUU99UUEU9gVUUUUUB9gLUUUUE999gIUUUE999gLUUUUEU9gIUUUEUIMXDILVORBWWBEWLVE9wEIIVIEBEOWEUECJ/JEKR7OO9tw9t9vv95DBh9f9f939h79t9f9j9h229f9jT9vv7BBZ9tw79o9v9wT9f79p9t9w29p9m95BEx9tw79o9v9wT9f79p9t9w29p9m959T9j9h2wBLA9tw79o9v9wT9f9v9wT9p9t9p96w9WwvTw94swT9j9o9Sw9t9h9wBVL79iv9rBOdWEBCEKDdQQ+stXDBK/48yIkUp99hU8jJJJJBCJ/BB9rGQ8kJJJJBAQCkFCBC/kBZ1JJJB8aCUALCDTGKALCffffI0eGXCBYD/s1JJBhJJJJBBHMAQCkFAQYD94GpCDTFAMbDBAQAMbDWAQApCEFbD94AXCBYD/s1JJBhJJJJBBHSAQCkFAQYD94GpCDTFASbDBAQASbDXAQApCEFbD94CUADCITADCffffE0eCBYD/s1JJBhJJJJBBHZAQCkFAQYD94GpCDTFAZbDBAQAZbDZAQApCEFbD94AQCWFAEADALCBZ+CJJJBAXCBYD/s1JJBhJJJJBBHhAQCkFAQYD94GpCDTFAhbDBAQApCEFbD94AXCBYD/s1JJBhJJJJBBHoAQCkFAQYD94GpCDTFAobDBAQApCEFbD94ALCD4ALFHaCEHcINAcGpCETHcApAa6MBKCBHxCUApCDTGaApCffffI0eCBYD/s1JJBhJJJJBBHcAQCkFAQYD94GqCDTFAcbDBAQAqCEFbD94AcCfEAaZ1JJJBHlDNALtMBAVCD4HkApCUFHqINAIAxAk2CDTFGyYDLGpCh4Ap7C+f+B+dd2AyYDBGpCh4Ap7C/d/o+b8j27AyYDWGpCh4Ap7C+3f/n8n27HaCBHpDNDNINAlAaAqgGaCDTFG8aYDBGcCUsMEAIAcAk2CDTFAyCXZ+LJJJBtMDApCEFGpAaFHaApAq9NMBXDKKA8aAxbDBAxHcKAhAxCDTFAcbDBAxCEFGxAL9HMBKCBHpAoHcINAcApbDBAcCLFHcALApCEFGp9HMBKCBHpAhHcAoHaINDNApAcYDBGqsMBAaAoAqCDTFGqYDBbDBAqApbDBKAcCLFHcAaCLFHaALApCEFGp9HMBKKCBHaALCBYD/s1JJBhJJJJBBHyAQCkFAQYD94GpCDTFAybDBAQApCEFbD94AXCBYD/s1JJBhJJJJBBHpAQCkFAQYD94GcCDTFApbDBAQAcCEFbD94AXCBYD/s1JJBhJJJJBBHcAQCkFAQYD94GqCDTFAcbDBAQAqCEFbD94ApCfEAKZ1JJJBHeAcCfEAKZ1JJJBH3DNALtMBAZCWFH5INDNAMAaCDTGpFYDBG8etMBAZASApFYDBCITFH8fA3ApFHAAeApFHxCBHkINDNDNA8fAkCITFYDBGlAa9HMBAxAabDBAAAabDBXEKDNAMAlCDTGKFYDBGHtMBAZASAKFYDBCITGpFYDBAasMEAHCUFH8aA5ApFHcCBHpINA8aApsMEApCEFHpAcYDBHqAcCWFHcAqAa9HMBKApAH6MEKA3AKFGpAaAlApYDBCUsebDBAxAlAaAxYDBCUsebDBKAkCEFGkA8e9HMBKKAaCEFGaAL9HMBKAhHcAoHaA3HqAeHkCBHpINDNDNApAcYDBG8a9HMBDNApAaYDBG8a9HMBAkYDBH8aDNAqYDBGlCU9HMBA8aCU9HMBAyApFCB86BBXIKAyApFHxDNApAlsMBApA8asMBAxCE86BBXIKAxCL86BBXDKDNApAoA8aCDTGlFYDB9HMBDNAqYDBGxCUsMBApAxsMBAkYDBGKCUsMBApAKsMBA3AlFYDBG8eCUsMBA8eA8asMBAeAlFYDBGlCUsMBAlA8asMBDNAhAxCDTFYDBAhAlCDTFYDB9HMBAhAKCDTFYDBAhA8eCDTFYDB9HMBAyApFCD86BBXLKAyApFCL86BBXIKAyApFCL86BBXDKAyApFCL86BBXEKAyApFAyA8aFrBB86BBKAcCLFHcAaCLFHaAqCLFHqAkCLFHkALApCEFGp9HMBKAWCEgtMBAyHpALHcINDNAprBBCE9HMBApCL86BBKApCEFHpAcCUFGcMBKKCBHkCUALCX2ALC/V+q/V+qE0eCBYD/s1JJBhJJJJBBHMAQCkFAQYD94GpCDTFAMbDBAQApCEFbD94AMAIALAVZ+DJJJB8aCUALC8s2GcALC/d/o/F8u0eCBYD/s1JJBhJJJJBBHpAQCkFAQYD94GaCDTFApbDBAQAaCEFbD94ApCBAcZ1JJJBHZDNADtMBAEHcINDNAMAcCLFYDBG8aCX2FGpiDBAMAcYDBGlCX2FGaiDBGG+TG8jAMAcCWFYDBGxCX2FGqCLFiDBAaCLFiDBG8k+TG8lnAqiDBAG+TG8mApCLFiDBA8k+TG8nn+TGYAYnA8nAqCWFiDBAaCWFiDBG8p+TGinA8lApCWFiDBA8p+TG8nn+TG8lA8lnA8nA8mnAiA8jn+TG8jA8jnmm+RG8mjBBBB9etMBAYA8m+VHYA8jA8m+VH8jA8lA8m+VH8lKAZAhAlCDTFYDBC8s2FGpA8lA8m+RG8mA8lnnG8nApiDBmuDBApA8jA8mA8jnG8rnGiApiDLmuDLApAYA8mAYnG8snGrApiDWmuDWApA8rA8lnG8rApiDXmuDXApA8sA8lnG8uApiDZmuDZApA8sA8jnG8sApiDcmuDcApA8lA8mAYA8pnA8lAGnA8kA8jnmm+MG8knGGnG8lApiDkmuDkApA8jAGnG8jApiD3muD3ApAYAGnGYApiDAmuDAApAGA8knGGApiD8kmuD8kApA8mApiDYmuDYAZAhA8aCDTFYDBC8s2FGpA8nApiDBmuDBApAiApiDLmuDLApArApiDWmuDWApA8rApiDXmuDXApA8uApiDZmuDZApA8sApiDcmuDcApA8lApiDkmuDkApA8jApiD3muD3ApAYApiDAmuDAApAGApiD8kmuD8kApA8mApiDYmuDYAZAhAxCDTFYDBC8s2FGpA8nApiDBmuDBApAiApiDLmuDLApArApiDWmuDWApA8rApiDXmuDXApA8uApiDZmuDZApA8sApiDcmuDcApA8lApiDkmuDkApA8jApiD3muD3ApAYApiDAmuDAApAGApiD8kmuD8kApA8mApiDYmuDYAcCXFHcAkCIFGkAD6MBKCBH8aAEHxINCBHcINAyAEAcC+81JJBFYDBGlA8aFCDTFYDBGaFrBBHpDNDNAyAxAcFYDBGqFrBBGkC99FCfEgCPE0MBApCEsMBApCD9HMEKDNAkCUFCfEgCE0MBAeAqCDTFYDBAa9HMEKDNApCUFCfEgCE0MBA3AaCDTFYDBAq9HMEKDNAkCV2ApFC+g1JJBFrBBtMBAhAaCDTFYDBAhAqCDTFYDB0MEKjBBACjBBJzApCEseH8mAkCEsHKAEAlCDTC+81JJBFYDBA8aFCDTFYDBHlDNAMAaCX2FGpCWFiDBAMAqCX2FGkCWFiDBG8k+TG8lA8lnApiDBAkiDBG8p+TG8jA8jnApCLFiDBAkCLFiDBG8n+TGYAYnmm+RGGjBBBB9etMBA8lAG+VH8lAYAG+VHYA8jAG+VH8jKjBBACA8mAKeH8sDNAMAlCX2FGpiDWA8k+TG8mA8lA8mA8lnApiDBA8p+TGrA8jnAYApiDLA8n+TG8rnmmGin+TG8mA8mnArA8jAin+TG8lA8lnA8rAYAin+TG8jA8jnmm+RGYjBBBB9etMBA8mAY+VH8mA8jAY+VH8jA8lAY+VH8lKAZAhAqCDTFYDBC8s2FGpA8lA8sAGnGYA8lnnGiApiDBmuDBApA8jAYA8jnG8snGrApiDLmuDLApA8mAYA8mnGGnG8rApiDWmuDWApA8sA8lnG8sApiDXmuDXApAGA8lnG8uApiDZmuDZApAGA8jnG8vApiDcmuDcApA8lAYA8mA8knA8lA8pnA8nA8jnmm+MG8knGGnG8lApiDkmuDkApA8jAGnG8jApiD3muD3ApA8mAGnG8mApiDAmuDAApAGA8knGGApiD8kmuD8kApAYApiDYmuDYAZAhAaCDTFYDBC8s2FGpAiApiDBmuDBApArApiDLmuDLApA8rApiDWmuDWApA8sApiDXmuDXApA8uApiDZmuDZApA8vApiDcmuDcApA8lApiDkmuDkApA8jApiD3muD3ApA8mApiDAmuDAApAGApiD8kmuD8kApAYApiDYmuDYKAcCLFGcCX9HMBKAxCXFHxA8aCIFG8aAD6MBKKDNABAEsMBABAEADCDTZ+HJJJB8aKCUADCX2ADC/V+q/V+qE0eCBYD/s1JJBhJJJJBBHAAQCkFAQYD94GpCDTFAAbDBAQApCEFbD94CUADCDTADCffffI0eCBYD/s1JJBhJJJJBBH5AQCkFAQYD94GpCDTFA5bDBAQApCEFbD94AXCBYD/s1JJBhJJJJBBHIAQCkFAQYD94GpCDTFAIbDBAQApCEFbD94ALCBYD/s1JJBhJJJJBBH8wAQCkFAQYD94GpCDTFA8wbDBAQApCEFbD94jBBBBHrDNADAO9NMBARARnH8sAACWFH8xAQYDZH8yAQYDXH8zAQYDWH80jBBBBHrINAQCWFABADGSALAhZ+CJJJBCBHHABHxCBHKINCBHpINDNAhAxApFYDBGaCDTGEFYDBGkAhABApC+81JJBFYDBAKFCDTFYDBGcCDTFYDBG8asMBAyAcFrBBGlCV2AyAaFrBBGqFC/Q1JJBFrBBGDAqCV2AlFG8eC/Q1JJBFrBBG8fvCfEgtMBDNA8eC+g1JJBFrBBtMBA8aAk0MEKDNAqAl9HMBAqCUFCfEgCE0MBAeAEFYDBAc9HMEKAAAHCX2FGqAcAaA8fCfEgGkebDLAqAaAcAkebDBAqADA8fgCfEgCB9HbDWAHCEFHHKApCLFGpCX9HMBKAxCXFHxAKCIFGKAS6MBKDNDNAHtMBAAHcAHH8aINAcCWFGljBBBBjBBJzAZAhAcYDBGaCDTFYDBC8s2FGpiDYG8l+VA8ljBBBB9beApiDWAMAcCLFGEYDBGqCX2FGkCWFiDBG8lnApiDZAkiDBG8jnApiDAmG8mA8mmmA8lnApiDLAkCLFiDBG8mnApiDcA8lnApiD3mG8lA8lmmA8mnApiDBA8jnApiDXA8mnApiDkmG8lA8lmmA8jnApiD8kmmm+LnGYjBBBBjBBJzAZAhAqAaAlYDBGkeGlCDTFYDBC8s2FGpiDYG8l+VA8ljBBBB9beApiDWAMAaAqAkeGxCX2FGkCWFiDBG8lnApiDZAkiDBG8jnApiDAmG8mA8mmmA8lnApiDLAkCLFiDBG8mnApiDcA8lnApiD3mG8lA8lmmA8mnApiDBA8jnApiDXA8mnApiDkmG8lA8lmmA8jnApiD8kmmm+LnG8lAYA8l9fGpeuDBAEAqAxApebDBAcAaAlApebDBAcCXFHcA8aCUFG8aMBKAQCJEFCBCJ/ABZ1JJJB8aA8xHpAHHcINAQCJEFApYDBCo4C/8zgFGaAaYDBCEFbDBApCXFHpAcCUFGcMBKCBHpCBHcINAQCJEFApFGaYDBHqAaAcbDBAqAcFHcApCLFGpCJ/AB9HMBKCBHpA8xHcINAQCJEFAcYDBCo4C/8zgFGaAaYDBGaCEFbDBA5AaCDTFApbDBAcCXFHcAHApCEFGp9HMBKASAO9rGaCI9uH81DNALtMBCBHpAIHcINAcApbDBAcCLFHcALApCEFGp9HMBKKCBHbA8wCBALZ1JJJBH83AaCo9uHuA81CE4H85CBH86CBHKDNINAAA5AKCDTFYDBCX2FGxiDWG8jA8s9eMEA86A819PMEjffUUH8lDNA85AH9PMBAAA5A85CDTFYDBCX2FiDWjBB/AznH8lKDNA8jA8l9etMBA86Au0MDKDNA83AhAxYDLG87CDTG88FYDBGaFG89rBBA83AhAxYDBGECDTG8+FYDBGzFGNrBBvMBDNA80AzCDTGpFYDBGqtMBA8yA8zApFYDBCITFHpAMAaCX2FG8eCWFHDA8eCLFHXAMAzCX2FG8fCWFHVA8fCLFHWCBHcCEHlDNINDNAIApYDBCDTFYDBGkAasMBAIApCLFYDBCDTFYDBG8aAasMBAMA8aCX2FG8aiDBAMAkCX2FGkiDBG8m+TG8lAWiDBAkCLFiDBGY+TGGnA8fiDBA8m+TG8kA8aCLFiDBAY+TG8jn+TA8lAXiDBAY+TG8pnA8eiDBA8m+TG8nA8jn+TnA8jAViDBAkCWFiDBGY+TGinAGA8aCWFiDBAY+TG8mn+TA8jADiDBAY+TGYnA8pA8mn+TnA8mA8knAiA8ln+TA8mA8nnAYA8ln+TnmmjBBBB9dMDKApCWFHpAcCEFGcAq6HlAqAc9HMBKKAlCEgtMBA85CEFH85XEKAxCWFHqAZAaC8s2FGpAZAzC8s2FGciDBApiDBmuDBApAciDLApiDLmuDLApAciDWApiDWmuDWApAciDXApiDXmuDXApAciDZApiDZmuDZApAciDcApiDcmuDcApAciDkApiDkmuDkApAciD3ApiD3muD3ApAciDAApiDAmuDAApAciD8kApiD8kmuD8kApAciDYApiDYmuDYDNDNDNDNAyAEFGcrBBC9+FpDEBDKAEHpINAIApCDTGpFAabDBAoApFYDBGpAE9HMBXIKKAoA88FYDBHpAoA8+FYDBHEAIA8+FA87bDBApH87KAIAECDTFA87bDBKANCE86BBA89CE86BBAqiDBG8lArArA8l9deHrAbCEFHbCECDAcrBBCEseA86FH86KAKCEFGKAH9HMBKKAbtMBDNALtMBCBHcAeHpINDNApYDBGaCUsMBDNAcAIAaCDTGqFYDBGa9HMBAeAqFYDBHaKApAabDBKApCLFHpALAcCEFGc9HMBKCBHcA3HpINDNApYDBGaCUsMBDNAcAIAaCDTGqFYDBGa9HMBA3AqFYDBHaKApAabDBKApCLFHpALAcCEFGc9HMBKKCBHDABHpCBHkINDNAIApYDBCDTFYDBGcAIApCLFYDBCDTFYDBGasMBAcAIApCWFYDBCDTFYDBGqsMBAaAqsMBABADCDTFG8aAcbDBA8aCLFAabDBA8aCWFAqbDBADCIFHDKApCXFHpAkCIFGkAS9PMDXBKKASHDXDKADAO0MBKKDNAdtMBAdAr+RuDBKAQYD94GpCDTAQCkFFC98FHhDNINAptMEAhYDBCBYD/w1JJBh+BJJJBBAhC98FHhApCUFHpXBKKAQCJ/BBF8kJJJJBADK/PLEOUABYDBCBAICDTZ1JJJB8aADCI9uHVDNADtMBABYDBHODNALtMBAEHRADHWINAOALARYDBCDTFYDBCDTFGdAdYDBCEFbDBARCLFHRAWCUFGWMBXDKKAEHRADHWINAOARYDBCDTFGdAdYDBCEFbDBARCLFHRAWCUFGWMBKKDNAItMBABYDBHRABYDLHWCBHdAIHOINAWAdbDBAWCLFHWARYDBAdFHdARCLFHRAOCUFGOMBKKDNADCI6MBAVCEAVCE0eHQABYDLHVABYDWHRINAECWFYDBHWAECLFYDBHdAEYDBHODNALtMBALAWCDTFYDBHWALAdCDTFYDBHdALAOCDTFYDBHOKARAVAOCDTFGDYDBCITFAdbDBARADYDBCITFAWbDLADADYDBCEFbDBARAVAdCDTFGDYDBCITFAWbDBARADYDBCITFAObDLADADYDBCEFbDBARAVAWCDTFGWYDBCITFAObDBARAWYDBCITFAdbDLAWAWYDBCEFbDBAECXFHEAQCUFGQMBKKDNAItMBABYDLHRABYDBHWINARARYDBAWYDB9rbDBAWCLFHWARCLFHRAICUFGIMBKKK+3LDOUV998jJJJJBCA9rGLCZFCWFCBYD11JJBbDBALCB8pDJ1JJB83IZALCWFCBYDn1JJBbDBALCB8pD+M1JJB83IBDNADtMBAICD4HVDNABtMBAVCDTHOCBHRAEHWINABARCX2FGIAEARAV2CDTFGdiDBuDBAIAdiDLuDLAIAdiDWuDWCBHIINALCZFAIFGdAWAIFiDBGQAdiDBGKAKAQ9eeuDBALAIFGdAQAdiDBGKAKAQ9deuDBAICLFGICX9HMBKAWAOFHWARCEFGRAD9HMBXDKKAVCDTHRCBHWINCBHIINALCZFAIFGdAEAIFiDBGQAdiDBGKAKAQ9eeuDBALAIFGdAQAdiDBGKAKAQ9deuDBAICLFGICX9HMBKAEARFHEAWCEFGWAD9HMBKKALiDBALiDZGK+TjBBBB+XGQALiDLALiDcGX+TGMAMAQ9deGQALiDWALiDkGM+TGpApAQ9deHpDNABtMBADtMBjBBBBjBBJzAp+VApjBBBB9beHQINABAQABiDBAK+TnuDBABCLFGIAQAIiDBAX+TnuDBABCWFGIAQAIiDBAM+TnuDBABCXFHBADCUFGDMBKKApK+qDIDUI99DUCBHI8jJJJJBCA9rGLCZFCWFCBYD11JJBbDBALCB8pDJ1JJB83IZALCWFCBYDn1JJBbDBALCB8pD+M1JJB83IBDNDNAEMBjBBJfHVjBBJfHOjBBJfHRXEKADCD4CDTHWINCBHDINALCZFADFGdABADFiDBGOAdiDBGRARAO9eeuDBALADFGdAOAdiDBGRARAO9deuDBADCLFGDCX9HMBKABAWFHBAICEFGIAE9HMBKALiDWALiDk+THRALiDLALiDc+THOALiDBALiDZ+THVKAVjBBBB+XGVAOAOAV9deGOARARAO9deK9dEEUABCfEAICDTZ1JJJBHLCBHIDNADtMBINDNALAEYDBCDTFGBYDBCU9HMBABAIbDBAICEFHIKAECLFHEADCUFGDMBKKAIK9TEIUCBCBYD/01JJBGEABCIFC98gFGBbD/01JJBDNDNABzBCZTGD9NMBCUHIABAD9rCffIFCZ4NBCUsMEKAEHIKAIK/lEEEUDNDNAEABvCIgtMBABHIXEKDNDNADCZ9PMBABHIXEKABHIINAIAEYDBbDBAICLFAECLFYDBbDBAICWFAECWFYDBbDBAICXFAECXFYDBbDBAICZFHIAECZFHEADC9wFGDCS0MBKKADCL6MBINAIAEYDBbDBAECLFHEAICLFHIADC98FGDCI0MBKKDNADtMBINAIAErBB86BBAICEFHIAECEFHEADCUFGDMBKKABK/AEEDUDNDNABCIgtMBABHIXEKAECfEgC+B+C+EW2HLDNDNADCZ9PMBABHIXEKABHIINAIALbDBAICXFALbDBAICWFALbDBAICLFALbDBAICZFHIADC9wFGDCS0MBKKADCL6MBINAIALbDBAICLFHIADC98FGDCI0MBKKDNADtMBINAIAE86BBAICEFHIADCUFGDMBKKABK9TEIUCBCBYD/01JJBGEABCIFC98gFGBbD/01JJBDNDNABzBCZTGD9NMBCUHIABAD9rCffIFCZ4NBCUsMEKAEHIKAIK9+EIUzBHEDNDNCBYD/01JJBGDAECZTGI9NMBCUHEADAI9rCffIFCZ4NBCUsMEKADHEKCBABAE9rCIFC98gCBYD/01JJBFGDbD/01JJBDNADzBCZTGE9NMBADAE9rCffIFCZ4NB8aKK6EIUCBHIDNADtMBDNINABrBBGLAErBBGV9HMEAECEFHEABCEFHBADCUFGDMBXDKKALAV9rHIKAIKK+CEDBCJWK9pffUUffUUffUUffUfffUfffUfBBBBBBBBEEEBEEBEBBEEEBEBBBBBEBEBBBBBEBBBDBBBBBBBBBBBBBBBEEEEEBEBBBBBEBBBBBEEBBBBBBC/sWKXEBBBDBBBJ9kBB", t = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]); if (typeof WebAssembly != "object") return { supported: !1 }; var n, i = WebAssembly.instantiate(o(e), {}).then(function (p) { n = p.instance, n.exports.__wasm_call_ctors() }); function o(p) { for (var g = new Uint8Array(p.length), m = 0; m < p.length; ++m) { var A = p.charCodeAt(m); g[m] = A > 96 ? A - 71 : A > 64 ? A - 65 : A > 47 ? A + 4 : A > 46 ? 63 : 62 } for (var C = 0, m = 0; m < p.length; ++m)g[C++] = g[m] < 60 ? t[g[m]] : (g[m] - 60) * 64 + g[++m]; return g.buffer.slice(0, C) } function r(p) { if (!p) throw new Error("Assertion failed") } function s(p) { return new Uint8Array(p.buffer, p.byteOffset, p.byteLength) } function a(p, g) { var m = n.exports.sbrk, A = m(p.length * 4), C = m(g * 4), x = new Uint8Array(n.exports.memory.buffer), T = s(p); x.set(T, A); var b = n.exports.meshopt_optimizeVertexFetchRemap(C, A, p.length, g); x = new Uint8Array(n.exports.memory.buffer); var S = new Uint32Array(g); new Uint8Array(S.buffer).set(x.subarray(C, C + g * 4)), T.set(x.subarray(A, A + p.length * 4)), m(A - m(0)); for (var D = 0; D < p.length; ++D)p[D] = S[p[D]]; return [S, b] } function c(p) { for (var g = 0, m = 0; m < p.length; ++m) { var A = p[m]; g = g < A ? A : g } return g } function u(p, g, m, A, C, x, T, b, S) { var D = n.exports.sbrk, P = D(4), B = D(m * 4), R = D(C * x), M = D(m * 4), L = new Uint8Array(n.exports.memory.buffer); L.set(s(A), R), L.set(s(g), M); var _ = p(B, M, m, R, C, x, T, b, S, P); L = new Uint8Array(n.exports.memory.buffer); var E = new Uint32Array(_); s(E).set(L.subarray(B, B + _ * 4)); var w = new Float32Array(1); return s(w).set(L.subarray(P, P + 4)), D(P - D(0)), [E, w[0]] } function f(p, g, m, A) { var C = n.exports.sbrk, x = C(m * A), T = new Uint8Array(n.exports.memory.buffer); T.set(s(g), x); var b = p(x, m, A); return C(x - C(0)), b } var d = { LockBorder: 1 }; return { ready: i, supported: !0, compactMesh: function (p) { r(p instanceof Uint32Array || p instanceof Int32Array || p instanceof Uint16Array || p instanceof Int16Array), r(p.length % 3 == 0); var g = p.BYTES_PER_ELEMENT == 4 ? p : new Uint32Array(p); return a(g, c(p) + 1) }, simplify: function (p, g, m, A, C, x) { r(p instanceof Uint32Array || p instanceof Int32Array || p instanceof Uint16Array || p instanceof Int16Array), r(p.length % 3 == 0), r(g instanceof Float32Array), r(g.length % m == 0), r(m >= 3), r(A % 3 == 0); for (var T = 0, b = 0; b < (x ? x.length : 0); ++b)T |= d[x[b]]; var S = p.BYTES_PER_ELEMENT == 4 ? p : new Uint32Array(p), D = u(n.exports.meshopt_simplify, S, p.length, g, g.length, m * 4, A, C, T); return D[0] = p instanceof Uint32Array ? D[0] : new p.constructor(D[0]), D }, getScale: function (p, g) { return r(p instanceof Float32Array), r(p.length % g == 0), f(n.exports.meshopt_simplifyScale, p, p.length, g * 4) } } }(); function n_(e) { e = y(e, y.EMPTY_OBJECT); let t = e.resourceCache, n = e.gltf, i = e.bufferViewId, o = e.gltfResource, r = e.baseResource, s = e.cacheKey, a = n.bufferViews[i], c = a.buffer, u = a.byteOffset, f = a.byteLength, d = !1, p, g, m, A; if (Mi(a, "EXT_meshopt_compression")) { let x = a.extensions.EXT_meshopt_compression; c = x.buffer, u = y(x.byteOffset, 0), f = x.byteLength, d = !0, p = x.byteStride, g = x.count, m = x.mode, A = y(x.filter, "NONE") } let C = n.buffers[c]; this._hasMeshopt = d, this._meshoptByteStride = p, this._meshoptCount = g, this._meshoptMode = m, this._meshoptFilter = A, this._resourceCache = t, this._gltfResource = o, this._baseResource = r, this._buffer = C, this._bufferId = c, this._byteOffset = u, this._byteLength = f, this._cacheKey = s, this._bufferLoader = void 0, this._typedArray = void 0, this._state = kt.UNLOADED, this._promise = void 0, this._process = function (x, T) { } } l(Object.create) && (n_.prototype = Object.create(Zi.prototype), n_.prototype.constructor = n_); Object.defineProperties(n_.prototype, { promise: { get: function () { return this._promise } }, cacheKey: { get: function () { return this._cacheKey } }, typedArray: { get: function () { return this._typedArray } } }); n_.prototype.load = function () { let e = DIe(this); this._bufferLoader = e, this._state = kt.LOADING; let t = this, n = new Promise(function (i) { t._process = function (o, r) { if (!o._hasMeshopt || !l(o._typedArray) || o._state !== kt.PROCESSING) return; let s = o._meshoptCount, a = o._meshoptByteStride, c = new Uint8Array(s * a); RQ.decodeGltfBuffer(c, s, a, o._typedArray, o._meshoptMode, o._meshoptFilter), o._typedArray = c, o._state = kt.READY, i(o) } }); return this._promise = e.promise.then(function () { if (t.isDestroyed()) return; let i = e.typedArray, o = new Uint8Array(i.buffer, i.byteOffset + t._byteOffset, t._byteLength); return t.unload(), t._typedArray = o, t._hasMeshopt ? (t._state = kt.PROCESSING, n) : (t._state = kt.READY, t) }).catch(function (i) { if (t.isDestroyed()) return; t.unload(), t._state = kt.FAILED; let o = "Failed to load buffer view"; return Promise.reject(t.getError(o, i)) }), this._promise }; function DIe(e) { let t = e._resourceCache, n = e._buffer; if (l(n.uri)) { let o = e._baseResource.getDerivedResource({ url: n.uri }); return t.loadExternalBuffer({ resource: o }) } return t.loadEmbeddedBuffer({ parentResource: e._gltfResource, bufferId: e._bufferId }) } n_.prototype.process = function (e) { return this._process(this, e) }; n_.prototype.unload = function () { l(this._bufferLoader) && this._resourceCache.unload(this._bufferLoader), this._bufferLoader = void 0, this._typedArray = void 0 }; var cS = n_; function Aa() { } Aa._maxDecodingConcurrency = Math.max(Nt.hardwareConcurrency - 1, 1); Aa._decoderTaskProcessor = void 0; Aa._taskProcessorReady = !1; Aa._getDecoderTaskProcessor = function () { if (!l(Aa._decoderTaskProcessor)) { let e = new yi("decodeDraco", Aa._maxDecodingConcurrency); e.initWebAssemblyModule({ modulePath: "ThirdParty/Workers/draco_decoder_nodejs.js", wasmBinaryFile: "ThirdParty/draco_decoder.wasm" }).then(function () { Aa._taskProcessorReady = !0 }), Aa._decoderTaskProcessor = e } return Aa._decoderTaskProcessor }; Aa.decodePointCloud = function (e) { let t = Aa._getDecoderTaskProcessor(); if (!!Aa._taskProcessorReady) return t.scheduleTask(e, [e.buffer.buffer]) }; Aa.decodeBufferView = function (e) { let t = Aa._getDecoderTaskProcessor(); if (!!Aa._taskProcessorReady) return t.scheduleTask(e, [e.array.buffer]) }; var i_ = Aa; function o_(e) { e = y(e, y.EMPTY_OBJECT); let t = e.resourceCache, n = e.gltf, i = e.draco, o = e.gltfResource, r = e.baseResource, s = e.cacheKey; this._resourceCache = t, this._gltfResource = o, this._baseResource = r, this._gltf = n, this._draco = i, this._cacheKey = s, this._bufferViewLoader = void 0, this._bufferViewTypedArray = void 0, this._decodePromise = void 0, this._decodedData = void 0, this._state = kt.UNLOADED, this._promise = void 0, this._process = function (a, c) { } } l(Object.create) && (o_.prototype = Object.create(Zi.prototype), o_.prototype.constructor = o_); Object.defineProperties(o_.prototype, { promise: { get: function () { return this._promise } }, cacheKey: { get: function () { return this._cacheKey } }, decodedData: { get: function () { return this._decodedData } } }); o_.prototype.load = function () { let t = this._resourceCache.loadBufferView({ gltf: this._gltf, bufferViewId: this._draco.bufferView, gltfResource: this._gltfResource, baseResource: this._baseResource }); this._bufferViewLoader = t, this._state = kt.LOADING; let n = this, i = new Promise(function (o, r) { n._process = function (s, a) { if (!l(s._bufferViewTypedArray) || l(s._decodePromise)) return; let c = s._draco, f = s._gltf.bufferViews, d = c.bufferView, p = f[d], g = c.attributes, m = { array: new Uint8Array(s._bufferViewTypedArray), bufferView: p, compressedAttributes: g, dequantizeInShader: !0 }, A = i_.decodeBufferView(m); !l(A) || (s._decodePromise = A.then(function (C) { if (s.isDestroyed()) { o(); return } s.unload(), s._decodedData = { indices: C.indexArray, vertexAttributes: C.attributeData }, s._state = kt.READY, o(s) }).catch(function (C) { if (s.isDestroyed()) { o(); return } r(C) })) } }); return this._promise = t.promise.then(function () { if (!n.isDestroyed()) return n._bufferViewTypedArray = t.typedArray, n._state = kt.PROCESSING, i }).catch(function (o) { if (!n.isDestroyed()) return vIe(n, o) }), this._promise }; function vIe(e, t) { e.unload(), e._state = kt.FAILED; let n = "Failed to load Draco"; return Promise.reject(e.getError(n, t)) } o_.prototype.process = function (e) { return this._process(this, e) }; o_.prototype.unload = function () { l(this._bufferViewLoader) && this._resourceCache.unload(this._bufferViewLoader), this._bufferViewLoader = void 0, this._bufferViewTypedArray = void 0, this._decodedData = void 0, this._gltf = void 0 }; var lS = o_; function PIe(e) { let t = e.uint8Array, n = e.format, i = e.request, o = y(e.flipY, !1), r = y(e.skipColorSpaceConversion, !1), s = new Blob([t], { type: n }), a; return Pe.supportsImageBitmapOptions().then(function (c) { return c ? Promise.resolve(Pe.createImageBitmapFromBlob(s, { flipY: o, premultiplyAlpha: !1, skipColorSpaceConversion: r })) : (a = window.URL.createObjectURL(s), new Pe({ url: a, request: i }).fetchImage({ flipY: o, skipColorSpaceConversion: r })) }).then(function (c) { return l(a) && window.URL.revokeObjectURL(a), c }).catch(function (c) { return l(a) && window.URL.revokeObjectURL(a), Promise.reject(c) }) } var WC = PIe; function Cm(e) { e = y(e, y.EMPTY_OBJECT); let t = e.resourceCache, n = e.gltf, i = e.imageId, o = e.gltfResource, r = e.baseResource, s = e.cacheKey, a = n.images[i], c = a.bufferView, u = a.uri; this._resourceCache = t, this._gltfResource = o, this._baseResource = r, this._gltf = n, this._bufferViewId = c, this._uri = u, this._cacheKey = s, this._bufferViewLoader = void 0, this._image = void 0, this._mipLevels = void 0, this._state = kt.UNLOADED, this._promise = void 0 } l(Object.create) && (Cm.prototype = Object.create(Zi.prototype), Cm.prototype.constructor = Cm); Object.defineProperties(Cm.prototype, { promise: { get: function () { return this._promise } }, cacheKey: { get: function () { return this._cacheKey } }, image: { get: function () { return this._image } }, mipLevels: { get: function () { return this._mipLevels } } }); Cm.prototype.load = function () { return l(this._bufferViewId) ? (this._promise = IIe(this), this._promise) : (this._promise = OIe(this), this._promise) }; function MQ(e) { let t; return Array.isArray(e) && (t = e.slice(1, e.length).map(function (n) { return n.bufferView }), e = e[0]), { image: e, mipLevels: t } } function IIe(e) { let n = e._resourceCache.loadBufferView({ gltf: e._gltf, bufferViewId: e._bufferViewId, gltfResource: e._gltfResource, baseResource: e._baseResource }); return e._bufferViewLoader = n, e._state = kt.LOADING, n.promise.then(function () { if (e.isDestroyed()) return; let i = n.typedArray; return RIe(i).then(function (o) { if (e.isDestroyed()) return; let r = MQ(o); return e.unload(), e._image = r.image, e._mipLevels = r.mipLevels, e._state = kt.READY, e }) }).catch(function (i) { if (!e.isDestroyed()) return LQ(e, i, "Failed to load embedded image") }) } function OIe(e) { let t = e._baseResource, n = e._uri, i = t.getDerivedResource({ url: n }); return e._state = kt.LOADING, LIe(i).then(function (o) { if (e.isDestroyed()) return; let r = MQ(o); return e.unload(), e._image = r.image, e._mipLevels = r.mipLevels, e._state = kt.READY, e }).catch(function (o) { if (!e.isDestroyed()) return LQ(e, o, `Failed to load image: ${n}`) }) } function LQ(e, t, n) { return e.unload(), e._state = kt.FAILED, Promise.reject(e.getError(n, t)) } function BIe(e) { let t = e.subarray(0, 2), n = e.subarray(0, 4), i = e.subarray(8, 12); if (t[0] === 255 && t[1] === 216) return "image/jpeg"; if (t[0] === 137 && t[1] === 80) return "image/png"; if (t[0] === 171 && t[1] === 75) return "image/ktx2"; if (n[0] === 82 && n[1] === 73 && n[2] === 70 && n[3] === 70 && i[0] === 87 && i[1] === 69 && i[2] === 66 && i[3] === 80) return "image/webp"; throw new fe("Image format is not recognized") } function RIe(e) { let t = BIe(e); if (t === "image/ktx2") { let n = new Uint8Array(e); return ul(n) } return Cm._loadImageFromTypedArray({ uint8Array: e, format: t, flipY: !1, skipColorSpaceConversion: !0 }) } var MIe = /(^data:image\/ktx2)|(\.ktx2$)/i; function LIe(e) { let t = e.url; return MIe.test(t) ? ul(e) : e.fetchImage({ skipColorSpaceConversion: !0, preferImageBitmap: !0 }) } Cm.prototype.unload = function () { l(this._bufferViewLoader) && this._resourceCache.unload(this._bufferViewLoader), this._bufferViewLoader = void 0, this._uri = void 0, this._image = void 0, this._mipLevels = void 0, this._gltf = void 0 }; Cm._loadImageFromTypedArray = WC; var uS = Cm; var FIe = { TEXTURE: 0, PROGRAM: 1, BUFFER: 2, NUMBER_OF_JOB_TYPES: 3 }, Ca = Object.freeze(FIe); function r_(e) { e = y(e, y.EMPTY_OBJECT); let t = e.resourceCache, n = e.gltf, i = e.accessorId, o = e.gltfResource, r = e.baseResource, s = e.draco, a = e.cacheKey, c = y(e.asynchronous, !0), u = y(e.loadBuffer, !1), f = y(e.loadTypedArray, !1), d = n.accessors[i].componentType; this._resourceCache = t, this._gltfResource = o, this._baseResource = r, this._gltf = n, this._accessorId = i, this._indexDatatype = d, this._draco = s, this._cacheKey = a, this._asynchronous = c, this._loadBuffer = u, this._loadTypedArray = f, this._bufferViewLoader = void 0, this._dracoLoader = void 0, this._typedArray = void 0, this._buffer = void 0, this._state = kt.UNLOADED, this._promise = void 0, this._process = function (p, g) { } } l(Object.create) && (r_.prototype = Object.create(Zi.prototype), r_.prototype.constructor = r_); Object.defineProperties(r_.prototype, { promise: { get: function () { return this._promise } }, cacheKey: { get: function () { return this._cacheKey } }, buffer: { get: function () { return this._buffer } }, typedArray: { get: function () { return this._typedArray } }, indexDatatype: { get: function () { return this._indexDatatype } } }); var NIe = new JG; r_.prototype.load = function () { let e; l(this._draco) ? e = VIe(this) : e = kIe(this); let t = this, n = new Promise(function (i) { t._process = function (o, r) { if (o._state === kt.READY) return; let s = o._typedArray, a = o._indexDatatype; if (l(o._dracoLoader) && o._dracoLoader.process(r), l(o._bufferViewLoader) && o._bufferViewLoader.process(r), !l(s)) return; let c; if (o._loadBuffer && o._asynchronous) { let u = NIe; if (u.set(s, a, r.context), !r.jobScheduler.execute(u, Ca.BUFFER)) return; c = u.buffer } else o._loadBuffer && (c = FQ(s, a, r.context)); o.unload(), o._buffer = c, o._typedArray = o._loadTypedArray ? s : void 0, o._state = kt.READY, i(o) } }); return this._promise = e.then(function () { if (!t.isDestroyed()) return n }).catch(function (i) { if (!t.isDestroyed()) return zIe(t, i) }), this._promise }; function VIe(e) { let n = e._resourceCache.loadDraco({ gltf: e._gltf, draco: e._draco, gltfResource: e._gltfResource, baseResource: e._baseResource }); return e._dracoLoader = n, e._state = kt.LOADING, n.promise.then(function () { if (e.isDestroyed()) return; let i = n.decodedData.indices.typedArray; return e._typedArray = i, e._indexDatatype = Y.fromTypedArray(i), e._state = kt.PROCESSING, e }) } function kIe(e) { let t = e._gltf, n = e._accessorId, o = t.accessors[n].bufferView, s = e._resourceCache.loadBufferView({ gltf: t, bufferViewId: o, gltfResource: e._gltfResource, baseResource: e._baseResource }); return e._state = kt.LOADING, e._bufferViewLoader = s, s.promise.then(function () { if (e.isDestroyed()) return; let a = s.typedArray; return e._typedArray = UIe(e, a), e._state = kt.PROCESSING, e }) } function UIe(e, t) { let n = e._gltf, i = e._accessorId, o = n.accessors[i], r = o.count, s = o.componentType, a = Me.getSizeInBytes(s), c = t.buffer, u = t.byteOffset + o.byteOffset; if (u % a !== 0) { let d = r * a, p = new Uint8Array(c, u, d); c = new Uint8Array(p).buffer, u = 0, Jr("index-buffer-unaligned", `The index array is not aligned to a ${a}-byte boundary.`) } let f; return s === Me.UNSIGNED_BYTE ? f = new Uint8Array(c, u, r) : s === Me.UNSIGNED_SHORT ? f = new Uint16Array(c, u, r) : s === Me.UNSIGNED_INT && (f = new Uint32Array(c, u, r)), f } function zIe(e, t) { e.unload(), e._state = kt.FAILED; let n = "Failed to load index buffer"; return t = e.getError(n, t), Promise.reject(t) } function JG() { this.typedArray = void 0, this.indexDatatype = void 0, this.context = void 0, this.buffer = void 0 } JG.prototype.set = function (e, t, n) { this.typedArray = e, this.indexDatatype = t, this.context = n }; JG.prototype.execute = function () { this.buffer = FQ(this.typedArray, this.indexDatatype, this.context) }; function FQ(e, t, n) { let i = ct.createIndexBuffer({ typedArray: e, context: n, usage: Re.STATIC_DRAW, indexDatatype: t }); return i.vertexArrayDestroyable = !1, i } r_.prototype.process = function (e) { return this._process(this, e) }; r_.prototype.unload = function () { l(this._buffer) && this._buffer.destroy(); let e = this._resourceCache; l(this._bufferViewLoader) && e.unload(this._bufferViewLoader), l(this._dracoLoader) && e.unload(this._dracoLoader), this._bufferViewLoader = void 0, this._dracoLoader = void 0, this._typedArray = void 0, this._buffer = void 0, this._gltf = void 0 }; var fS = r_; function HIe(e, t, n) { if (n = y(n, !1), n) { let i = e.indexOf(t); if (i > -1) return i } return e.push(t), e.length - 1 } var us = HIe; function GIe(e, t) { return l(e.extensionsUsed) && e.extensionsUsed.indexOf(t) >= 0 } var pr = GIe; function zt() { } zt.objectLegacy = function (e, t) { if (l(e)) { for (let n in e) if (Object.prototype.hasOwnProperty.call(e, n)) { let i = e[n], o = t(i, n); if (l(o)) return o } } }; zt.object = function (e, t) { if (l(e)) { let n = e.length; for (let i = 0; i < n; i++) { let o = e[i], r = t(o, i); if (l(r)) return r } } }; zt.topLevel = function (e, t, n) { let i = e[t]; return l(i) && !Array.isArray(i) ? zt.objectLegacy(i, n) : zt.object(i, n) }; zt.accessor = function (e, t) { return zt.topLevel(e, "accessors", t) }; zt.accessorWithSemantic = function (e, t, n) { let i = {}; return zt.mesh(e, function (o) { return zt.meshPrimitive(o, function (r) { let s = zt.meshPrimitiveAttribute(r, function (a, c) { if (c.indexOf(t) === 0 && !l(i[a])) { i[a] = !0; let u = n(a); if (l(u)) return u } }); return l(s) ? s : zt.meshPrimitiveTarget(r, function (a) { return zt.meshPrimitiveTargetAttribute(a, function (c, u) { if (u.indexOf(t) === 0 && !l(i[c])) { i[c] = !0; let f = n(c); if (l(f)) return f } }) }) }) }) }; zt.accessorContainingVertexAttributeData = function (e, t) { let n = {}; return zt.mesh(e, function (i) { return zt.meshPrimitive(i, function (o) { let r = zt.meshPrimitiveAttribute(o, function (s) { if (!l(n[s])) { n[s] = !0; let a = t(s); if (l(a)) return a } }); return l(r) ? r : zt.meshPrimitiveTarget(o, function (s) { return zt.meshPrimitiveTargetAttribute(s, function (a) { if (!l(n[a])) { n[a] = !0; let c = t(a); if (l(c)) return c } }) }) }) }) }; zt.accessorContainingIndexData = function (e, t) { let n = {}; return zt.mesh(e, function (i) { return zt.meshPrimitive(i, function (o) { let r = o.indices; if (l(r) && !l(n[r])) { n[r] = !0; let s = t(r); if (l(s)) return s } }) }) }; zt.animation = function (e, t) { return zt.topLevel(e, "animations", t) }; zt.animationChannel = function (e, t) { let n = e.channels; return zt.object(n, t) }; zt.animationSampler = function (e, t) { let n = e.samplers; return zt.object(n, t) }; zt.buffer = function (e, t) { return zt.topLevel(e, "buffers", t) }; zt.bufferView = function (e, t) { return zt.topLevel(e, "bufferViews", t) }; zt.camera = function (e, t) { return zt.topLevel(e, "cameras", t) }; zt.image = function (e, t) { return zt.topLevel(e, "images", t) }; zt.material = function (e, t) { return zt.topLevel(e, "materials", t) }; zt.materialValue = function (e, t) { let n = e.values; l(e.extensions) && l(e.extensions.KHR_techniques_webgl) && (n = e.extensions.KHR_techniques_webgl.values); for (let i in n) if (Object.prototype.hasOwnProperty.call(n, i)) { let o = t(n[i], i); if (l(o)) return o } }; zt.mesh = function (e, t) { return zt.topLevel(e, "meshes", t) }; zt.meshPrimitive = function (e, t) { let n = e.primitives; if (l(n)) { let i = n.length; for (let o = 0; o < i; o++) { let r = n[o], s = t(r, o); if (l(s)) return s } } }; zt.meshPrimitiveAttribute = function (e, t) { let n = e.attributes; for (let i in n) if (Object.prototype.hasOwnProperty.call(n, i)) { let o = t(n[i], i); if (l(o)) return o } }; zt.meshPrimitiveTarget = function (e, t) { let n = e.targets; if (l(n)) { let i = n.length; for (let o = 0; o < i; ++o) { let r = t(n[o], o); if (l(r)) return r } } }; zt.meshPrimitiveTargetAttribute = function (e, t) { for (let n in e) if (Object.prototype.hasOwnProperty.call(e, n)) { let i = e[n], o = t(i, n); if (l(o)) return o } }; zt.node = function (e, t) { return zt.topLevel(e, "nodes", t) }; zt.nodeInTree = function (e, t, n) { let i = e.nodes; if (l(i)) { let o = t.length; for (let r = 0; r < o; r++) { let s = t[r], a = i[s]; if (l(a)) { let c = n(a, s); if (l(c)) return c; let u = a.children; if (l(u) && (c = zt.nodeInTree(e, u, n), l(c))) return c } } } }; zt.nodeInScene = function (e, t, n) { let i = t.nodes; if (l(i)) return zt.nodeInTree(e, i, n) }; zt.program = function (e, t) { return pr(e, "KHR_techniques_webgl") ? zt.object(e.extensions.KHR_techniques_webgl.programs, t) : zt.topLevel(e, "programs", t) }; zt.sampler = function (e, t) { return zt.topLevel(e, "samplers", t) }; zt.scene = function (e, t) { return zt.topLevel(e, "scenes", t) }; zt.shader = function (e, t) { return pr(e, "KHR_techniques_webgl") ? zt.object(e.extensions.KHR_techniques_webgl.shaders, t) : zt.topLevel(e, "shaders", t) }; zt.skin = function (e, t) { return zt.topLevel(e, "skins", t) }; zt.skinJoint = function (e, t) { let n = e.joints; if (l(n)) { let i = n.length; for (let o = 0; o < i; o++) { let r = n[o], s = t(r); if (l(s)) return s } } }; zt.techniqueAttribute = function (e, t) { let n = e.attributes; for (let i in n) if (Object.prototype.hasOwnProperty.call(n, i)) { let o = t(n[i], i); if (l(o)) return o } }; zt.techniqueUniform = function (e, t) { let n = e.uniforms; for (let i in n) if (Object.prototype.hasOwnProperty.call(n, i)) { let o = t(n[i], i); if (l(o)) return o } }; zt.techniqueParameter = function (e, t) { let n = e.parameters; for (let i in n) if (Object.prototype.hasOwnProperty.call(n, i)) { let o = t(n[i], i); if (l(o)) return o } }; zt.technique = function (e, t) { return pr(e, "KHR_techniques_webgl") ? zt.object(e.extensions.KHR_techniques_webgl.techniques, t) : zt.topLevel(e, "techniques", t) }; zt.texture = function (e, t) { return zt.topLevel(e, "textures", t) }; var De = zt; function WIe(e) { switch (e) { case "SCALAR": return 1; case "VEC2": return 2; case "VEC3": return 3; case "VEC4": case "MAT2": return 4; case "MAT3": return 9; case "MAT4": return 16 } } var uu = WIe; function jIe(e, t) { let n = t.bufferView; if (l(n)) { let i = e.bufferViews[n]; if (l(i.byteStride) && i.byteStride > 0) return i.byteStride } return Y.getSizeInBytes(t.componentType) * uu(t.type) } var yl = jIe; function qIe(e) { De.accessor(e, function (n) { l(n.bufferView) && (n.byteOffset = y(n.byteOffset, 0)) }), De.bufferView(e, function (n) { l(n.buffer) && (n.byteOffset = y(n.byteOffset, 0)) }), De.mesh(e, function (n) { De.meshPrimitive(n, function (i) { if (i.mode = y(i.mode, te.TRIANGLES), !l(i.material)) { l(e.materials) || (e.materials = []); let o = { name: "default" }; i.material = us(e.materials, o) } }) }), De.accessorContainingVertexAttributeData(e, function (n) { let i = e.accessors[n], o = i.bufferView; if (i.normalized = y(i.normalized, !1), l(o)) { let r = e.bufferViews[o]; r.byteStride = yl(e, i), r.target = te.ARRAY_BUFFER } }), De.accessorContainingIndexData(e, function (n) { let o = e.accessors[n].bufferView; if (l(o)) { let r = e.bufferViews[o]; r.target = te.ELEMENT_ARRAY_BUFFER } }), De.material(e, function (n) { let i = y(n.extensions, y.EMPTY_OBJECT), o = i.KHR_materials_common; if (l(o)) { let c = o.technique, u = l(o.values) ? o.values : {}; o.values = u, u.ambient = l(u.ambient) ? u.ambient : [0, 0, 0, 1], u.emission = l(u.emission) ? u.emission : [0, 0, 0, 1], u.transparency = y(u.transparency, 1), c !== "CONSTANT" && (u.diffuse = l(u.diffuse) ? u.diffuse : [0, 0, 0, 1], c !== "LAMBERT" && (u.specular = l(u.specular) ? u.specular : [0, 0, 0, 1], u.shininess = y(u.shininess, 0))), o.transparent = y(o.transparent, !1), o.doubleSided = y(o.doubleSided, !1); return } n.emissiveFactor = y(n.emissiveFactor, [0, 0, 0]), n.alphaMode = y(n.alphaMode, "OPAQUE"), n.doubleSided = y(n.doubleSided, !1), n.alphaMode === "MASK" && (n.alphaCutoff = y(n.alphaCutoff, .5)); let r = i.KHR_techniques_webgl; l(r) && De.materialValue(n, function (c) { l(c.index) && L0(c) }), L0(n.emissiveTexture), L0(n.normalTexture), L0(n.occlusionTexture); let s = n.pbrMetallicRoughness; l(s) && (s.baseColorFactor = y(s.baseColorFactor, [1, 1, 1, 1]), s.metallicFactor = y(s.metallicFactor, 1), s.roughnessFactor = y(s.roughnessFactor, 1), L0(s.baseColorTexture), L0(s.metallicRoughnessTexture)); let a = i.KHR_materials_pbrSpecularGlossiness; l(a) && (a.diffuseFactor = y(a.diffuseFactor, [1, 1, 1, 1]), a.specularFactor = y(a.specularFactor, [1, 1, 1]), a.glossinessFactor = y(a.glossinessFactor, 1), L0(a.specularGlossinessTexture)) }), De.animation(e, function (n) { De.animationSampler(n, function (i) { i.interpolation = y(i.interpolation, "LINEAR") }) }); let t = YIe(e); return De.node(e, function (n, i) { l(t[i]) || l(n.translation) || l(n.rotation) || l(n.scale) ? (n.translation = y(n.translation, [0, 0, 0]), n.rotation = y(n.rotation, [0, 0, 0, 1]), n.scale = y(n.scale, [1, 1, 1])) : n.matrix = y(n.matrix, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) }), De.sampler(e, function (n) { n.wrapS = y(n.wrapS, te.REPEAT), n.wrapT = y(n.wrapT, te.REPEAT) }), l(e.scenes) && !l(e.scene) && (e.scene = 0), e } function YIe(e) { let t = {}; return De.animation(e, function (n) { De.animationChannel(n, function (i) { let o = i.target, r = o.node, s = o.path; (s === "translation" || s === "rotation" || s === "scale") && (t[r] = !0) }) }), t } function L0(e) { l(e) && (e.texCoord = y(e.texCoord, 0)) } var YB = qIe; function XIe(e) { return De.shader(e, function (t) { XB(t) }), De.buffer(e, function (t) { XB(t) }), De.image(e, function (t) { XB(t) }), XB(e), e } function XB(e) { e.extras = l(e.extras) ? e.extras : {}, e.extras._pipeline = l(e.extras._pipeline) ? e.extras._pipeline : {} } var F0 = XIe; function KIe(e, t) { let n = e.extensionsRequired; if (l(n)) { let i = n.indexOf(t); i >= 0 && n.splice(i, 1), n.length === 0 && delete e.extensionsRequired } } var KB = KIe; function JIe(e, t) { let n = e.extensionsUsed; if (l(n)) { let i = n.indexOf(t); i >= 0 && n.splice(i, 1), KB(e, t), n.length === 0 && delete e.extensionsUsed } } var jC = JIe; var ZIe = 4; function QIe(e) { if (zd(e) !== "glTF") throw new fe("File is not valid binary glTF"); let n = NQ(e, 0, 5), i = n[1]; if (i !== 1 && i !== 2) throw new fe("Binary glTF version is not 1 or 2"); return i === 1 ? $Ie(e, n) : eOe(e, n) } function NQ(e, t, n) { let i = new DataView(e.buffer), o = new Array(n); for (let r = 0; r < n; ++r)o[r] = i.getUint32(e.byteOffset + t + r * ZIe, !0); return o } function $Ie(e, t) { let n = t[2], i = t[3]; if (t[4] !== 0) throw new fe("Binary glTF scene format is not JSON"); let r = 20, s = r + i, a = pl(e, r, i), c = JSON.parse(a); F0(c); let u = e.subarray(s, n), f = c.buffers; if (l(f) && Object.keys(f).length > 0) { let d = y(f.binary_glTF, f.KHR_binary_glTF); l(d) && (d.extras._pipeline.source = u, delete d.uri) } return jC(c, "KHR_binary_glTF"), c } function eOe(e, t) { let n = t[2], i = 12, o, r; for (; i < n;) { let s = NQ(e, i, 2), a = s[0], c = s[1]; i += 8; let u = e.subarray(i, i + a); if (i += a, c === 1313821514) { let f = pl(u); o = JSON.parse(f), F0(o) } else c === 5130562 && (r = u) } if (l(o) && l(r)) { let s = o.buffers; if (l(s) && s.length > 0) { let a = s[0]; a.extras._pipeline.source = r } } return o } var JB = QIe; function tOe(e) { return De.shader(e, function (t) { ZB(t) }), De.buffer(e, function (t) { ZB(t) }), De.image(e, function (t) { ZB(t) }), ZB(e), e } function ZB(e) { !l(e.extras) || (l(e.extras._pipeline) && delete e.extras._pipeline, Object.keys(e.extras).length === 0 && delete e.extras) } var QB = tOe; function nOe(e, t) { let n = e.extensionsUsed; l(n) || (n = [], e.extensionsUsed = n), us(n, t, !0) } var Cf = nOe; function iOe(e) { switch (e) { case Y.BYTE: return function (t, n, i, o, r) { for (let s = 0; s < i; ++s)r[s] = t.getInt8(n + s * o) }; case Y.UNSIGNED_BYTE: return function (t, n, i, o, r) { for (let s = 0; s < i; ++s)r[s] = t.getUint8(n + s * o) }; case Y.SHORT: return function (t, n, i, o, r) { for (let s = 0; s < i; ++s)r[s] = t.getInt16(n + s * o, !0) }; case Y.UNSIGNED_SHORT: return function (t, n, i, o, r) { for (let s = 0; s < i; ++s)r[s] = t.getUint16(n + s * o, !0) }; case Y.INT: return function (t, n, i, o, r) { for (let s = 0; s < i; ++s)r[s] = t.getInt32(n + s * o, !0) }; case Y.UNSIGNED_INT: return function (t, n, i, o, r) { for (let s = 0; s < i; ++s)r[s] = t.getUint32(n + s * o, !0) }; case Y.FLOAT: return function (t, n, i, o, r) { for (let s = 0; s < i; ++s)r[s] = t.getFloat32(n + s * o, !0) }; case Y.DOUBLE: return function (t, n, i, o, r) { for (let s = 0; s < i; ++s)r[s] = t.getFloat64(n + s * o, !0) } } } var s_ = iOe; function oOe(e, t) { let n = e.bufferViews, i = e.buffers, o = t.bufferView, r = uu(t.type); if (!l(t.bufferView)) return { min: new Array(r).fill(0), max: new Array(r).fill(0) }; let s = new Array(r).fill(Number.POSITIVE_INFINITY), a = new Array(r).fill(Number.NEGATIVE_INFINITY), c = n[o], u = c.buffer, d = i[u].extras._pipeline.source, p = t.count, g = yl(e, t), m = t.byteOffset + c.byteOffset + d.byteOffset, A = t.componentType, C = Y.getSizeInBytes(A), x = new DataView(d.buffer), T = new Array(r), b = s_(A); for (let S = 0; S < p; S++) { b(x, m, r, C, T); for (let D = 0; D < r; D++) { let P = T[D]; s[D] = Math.min(s[D], P), a[D] = Math.max(a[D], P) } m += g } return { min: s, max: a } } var qC = oOe; var rOe = [te.FUNC_ADD, te.FUNC_ADD], sOe = [te.ONE, te.ZERO, te.ONE, te.ZERO]; function VQ(e, t) { let n = e.enable; return l(n) ? n.indexOf(t) > -1 : !1 } var aOe = [te.ZERO, te.ONE, te.SRC_COLOR, te.ONE_MINUS_SRC_COLOR, te.SRC_ALPHA, te.ONE_MINUS_SRC_ALPHA, te.DST_ALPHA, te.ONE_MINUS_DST_ALPHA, te.DST_COLOR, te.ONE_MINUS_DST_COLOR]; function cOe(e, t) { if (!l(e)) return t; for (let n = 0; n < 4; n++)if (aOe.indexOf(e[n]) === -1) return t; return e } function lOe(e) { let t = {}, n = {}, i = e.techniques; return l(i) && (De.technique(e, function (o, r) { let s = o.states; if (l(s)) { let a = n[r] = {}; if (VQ(s, te.BLEND)) { a.alphaMode = "BLEND"; let c = s.functions; l(c) && (l(c.blendEquationSeparate) || l(c.blendFuncSeparate)) && (t[r] = { blendEquation: y(c.blendEquationSeparate, rOe), blendFactors: cOe(c.blendFuncSeparate, sOe) }) } VQ(s, te.CULL_FACE) || (a.doubleSided = !0), delete o.states } }), Object.keys(t).length > 0 && (l(e.extensions) || (e.extensions = {}), Cf(e, "KHR_blend")), De.material(e, function (o) { if (l(o.technique)) { let r = n[o.technique]; De.objectLegacy(r, function (a, c) { o[c] = a }); let s = t[o.technique]; l(s) && (l(o.extensions) || (o.extensions = {}), o.extensions.KHR_blend = s) } })), e } var $B = lOe; function uOe(e, t) { let n = e.extensionsRequired; l(n) || (n = [], e.extensionsRequired = n), us(n, t, !0), Cf(e, t) } var eR = uOe; function fOe(e) { let t = e.techniques, n = {}, i = {}, o = {}; if (l(t)) { let r = { programs: [], shaders: [], techniques: [] }, s = e.glExtensionsUsed; delete e.glExtensionsUsed, De.technique(e, function (a, c) { let u = { name: a.name, program: void 0, attributes: {}, uniforms: {} }, f; if (De.techniqueAttribute(a, function (d, p) { f = a.parameters[d], u.attributes[p] = { semantic: f.semantic } }), De.techniqueUniform(a, function (d, p) { f = a.parameters[d], u.uniforms[p] = { count: f.count, node: f.node, type: f.type, semantic: f.semantic, value: f.value }, l(n[c]) || (n[c] = {}), n[c][d] = p }), l(o[a.program])) u.program = o[a.program]; else { let d = e.programs[a.program], p = { name: d.name, fragmentShader: void 0, vertexShader: void 0, glExtensions: s }, g = e.shaders[d.fragmentShader]; p.fragmentShader = us(r.shaders, g, !0); let m = e.shaders[d.vertexShader]; p.vertexShader = us(r.shaders, m, !0), u.program = us(r.programs, p), o[a.program] = u.program } i[c] = us(r.techniques, u) }), r.techniques.length > 0 && (l(e.extensions) || (e.extensions = {}), e.extensions.KHR_techniques_webgl = r, Cf(e, "KHR_techniques_webgl"), eR(e, "KHR_techniques_webgl")) } return De.material(e, function (r) { if (l(r.technique)) { let s = { technique: i[r.technique] }; De.objectLegacy(r.values, function (a, c) { l(s.values) || (s.values = {}); let u = n[r.technique][c]; l(u) && (s.values[u] = a) }), l(r.extensions) || (r.extensions = {}), r.extensions.KHR_techniques_webgl = s } delete r.technique, delete r.values }), delete e.techniques, delete e.programs, delete e.shaders, e } var tR = fOe; function dOe(e, t) { rl.typeOf.object("material", e), rl.defined("handler", t); let n = e.pbrMetallicRoughness; if (l(n)) { if (l(n.baseColorTexture)) { let o = n.baseColorTexture, r = t(o.index, o); if (l(r)) return r } if (l(n.metallicRoughnessTexture)) { let o = n.metallicRoughnessTexture, r = t(o.index, o); if (l(r)) return r } } if (l(e.extensions)) { let o = e.extensions.KHR_materials_pbrSpecularGlossiness; if (l(o)) { if (l(o.diffuseTexture)) { let s = o.diffuseTexture, a = t(s.index, s); if (l(a)) return a } if (l(o.specularGlossinessTexture)) { let s = o.specularGlossinessTexture, a = t(s.index, s); if (l(a)) return a } } let r = e.extensions.KHR_materials_common; if (l(r) && l(r.values)) { let s = r.values.diffuse, a = r.values.ambient, c = r.values.emission, u = r.values.specular; if (l(s) && l(s.index)) { let f = t(s.index, s); if (l(f)) return f } if (l(a) && l(a.index)) { let f = t(a.index, a); if (l(f)) return f } if (l(c) && l(c.index)) { let f = t(c.index, c); if (l(f)) return f } if (l(u) && l(u.index)) { let f = t(u.index, u); if (l(f)) return f } } } let i = De.materialValue(e, function (o) { if (l(o.index)) { let r = t(o.index, o); if (l(r)) return r } }); if (l(i)) return i; if (l(e.emissiveTexture)) { let o = e.emissiveTexture, r = t(o.index, o); if (l(r)) return r } if (l(e.normalTexture)) { let o = e.normalTexture, r = t(o.index, o); if (l(r)) return r } if (l(e.occlusionTexture)) { let o = e.occlusionTexture, r = t(o.index, o); if (l(r)) return r } } var dS = dOe; var kQ = ["mesh", "node", "material", "accessor", "bufferView", "buffer", "texture", "sampler", "image"]; function hOe(e, t) { return t = y(t, kQ), kQ.forEach(function (n) { t.indexOf(n) > -1 && pOe(e, n) }), e } var mOe = { accessor: "accessors", buffer: "buffers", bufferView: "bufferViews", image: "images", node: "nodes", material: "materials", mesh: "meshes", sampler: "samplers", texture: "textures" }; function pOe(e, t) { let n = mOe[t], i = e[n]; if (l(i)) { let o = 0, r = Gd[t](e), s = i.length; for (let a = 0; a < s; ++a)r[a] || (Hd[t](e, a - o), o++) } } function Hd() { } Hd.accessor = function (e, t) { e.accessors.splice(t, 1), De.mesh(e, function (i) { De.meshPrimitive(i, function (o) { De.meshPrimitiveAttribute(o, function (s, a) { s > t && o.attributes[a]-- }), De.meshPrimitiveTarget(o, function (s) { De.meshPrimitiveTargetAttribute(s, function (a, c) { a > t && s[c]-- }) }); let r = o.indices; l(r) && r > t && o.indices-- }) }), De.skin(e, function (i) { l(i.inverseBindMatrices) && i.inverseBindMatrices > t && i.inverseBindMatrices-- }), De.animation(e, function (i) { De.animationSampler(i, function (o) { l(o.input) && o.input > t && o.input--, l(o.output) && o.output > t && o.output-- }) }) }; Hd.buffer = function (e, t) { e.buffers.splice(t, 1), De.bufferView(e, function (i) { l(i.buffer) && i.buffer > t && i.buffer--, l(i.extensions) && l(i.extensions.EXT_meshopt_compression) && i.extensions.EXT_meshopt_compression.buffer-- }) }; Hd.bufferView = function (e, t) { if (e.bufferViews.splice(t, 1), De.accessor(e, function (i) { l(i.bufferView) && i.bufferView > t && i.bufferView-- }), De.shader(e, function (i) { l(i.bufferView) && i.bufferView > t && i.bufferView-- }), De.image(e, function (i) { l(i.bufferView) && i.bufferView > t && i.bufferView-- }), pr(e, "KHR_draco_mesh_compression") && De.mesh(e, function (i) { De.meshPrimitive(i, function (o) { l(o.extensions) && l(o.extensions.KHR_draco_mesh_compression) && o.extensions.KHR_draco_mesh_compression.bufferView > t && o.extensions.KHR_draco_mesh_compression.bufferView-- }) }), pr(e, "EXT_feature_metadata")) { let o = e.extensions.EXT_feature_metadata.featureTables; for (let r in o) if (o.hasOwnProperty(r)) { let a = o[r].properties; if (l(a)) { for (let c in a) if (a.hasOwnProperty(c)) { let u = a[c]; l(u.bufferView) && u.bufferView > t && u.bufferView--, l(u.arrayOffsetBufferView) && u.arrayOffsetBufferView > t && u.arrayOffsetBufferView--, l(u.stringOffsetBufferView) && u.stringOffsetBufferView > t && u.stringOffsetBufferView-- } } } } if (pr(e, "EXT_structural_metadata")) { let o = e.extensions.EXT_structural_metadata.propertyTables; if (l(o)) { let r = o.length; for (let s = 0; s < r; ++s) { let c = o[s].properties; for (let u in c) if (c.hasOwnProperty(u)) { let f = c[u]; l(f.values) && f.values > t && f.values--, l(f.arrayOffsets) && f.arrayOffsets > t && f.arrayOffsets--, l(f.stringOffsets) && f.stringOffsets > t && f.stringOffsets-- } } } } }; Hd.image = function (e, t) { e.images.splice(t, 1), De.texture(e, function (i) { l(i.source) && i.source > t && --i.source; let o = i.extensions; l(o) && l(o.EXT_texture_webp) && o.EXT_texture_webp.source > t ? --i.extensions.EXT_texture_webp.source : l(o) && l(o.KHR_texture_basisu) && o.KHR_texture_basisu.source > t && --i.extensions.KHR_texture_basisu.source }) }; Hd.mesh = function (e, t) { e.meshes.splice(t, 1), De.node(e, function (i) { l(i.mesh) && (i.mesh > t ? i.mesh-- : i.mesh === t && delete i.mesh) }) }; Hd.node = function (e, t) { e.nodes.splice(t, 1), De.skin(e, function (i) { l(i.skeleton) && i.skeleton > t && i.skeleton--, i.joints = i.joints.map(function (o) { return o > t ? o - 1 : o }) }), De.animation(e, function (i) { De.animationChannel(i, function (o) { l(o.target) && l(o.target.node) && o.target.node > t && o.target.node-- }) }), De.technique(e, function (i) { De.techniqueUniform(i, function (o) { l(o.node) && o.node > t && o.node-- }) }), De.node(e, function (i) { !l(i.children) || (i.children = i.children.filter(function (o) { return o !== t }).map(function (o) { return o > t ? o - 1 : o })) }), De.scene(e, function (i) { i.nodes = i.nodes.filter(function (o) { return o !== t }).map(function (o) { return o > t ? o - 1 : o }) }) }; Hd.material = function (e, t) { e.materials.splice(t, 1), De.mesh(e, function (i) { De.meshPrimitive(i, function (o) { l(o.material) && o.material > t && o.material-- }) }) }; Hd.sampler = function (e, t) { e.samplers.splice(t, 1), De.texture(e, function (i) { l(i.sampler) && i.sampler > t && --i.sampler }) }; Hd.texture = function (e, t) { if (e.textures.splice(t, 1), De.material(e, function (i) { dS(i, function (o, r) { r.index > t && --r.index }) }), pr(e, "EXT_feature_metadata")) { De.mesh(e, function (r) { De.meshPrimitive(r, function (s) { let a = s.extensions; if (l(a) && l(a.EXT_feature_metadata)) { let u = a.EXT_feature_metadata.featureIdTextures; if (l(u)) { let f = u.length; for (let d = 0; d < f; ++d) { let g = u[d].featureIds.texture; g.index > t && --g.index } } } }) }); let o = e.extensions.EXT_feature_metadata.featureTextures; for (let r in o) if (o.hasOwnProperty(r)) { let a = o[r].properties; if (l(a)) { for (let c in a) if (a.hasOwnProperty(c)) { let f = a[c].texture; f.index > t && --f.index } } } } if (pr(e, "EXT_mesh_features") && De.mesh(e, function (i) { De.meshPrimitive(i, function (o) { let r = o.extensions; if (l(r) && l(r.EXT_mesh_features)) { let a = r.EXT_mesh_features.featureIds; if (l(a)) { let c = a.length; for (let u = 0; u < c; ++u) { let f = a[u]; l(f.texture) && f.texture.index > t && --f.texture.index } } } }) }), pr(e, "EXT_structural_metadata")) { let o = e.extensions.EXT_structural_metadata.propertyTextures; if (l(o)) { let r = o.length; for (let s = 0; s < r; ++s) { let c = o[s].properties; for (let u in c) if (c.hasOwnProperty(u)) { let f = c[u]; f.index > t && --f.index } } } } }; function Gd() { } Gd.accessor = function (e) { let t = {}; return De.mesh(e, function (n) { De.meshPrimitive(n, function (i) { De.meshPrimitiveAttribute(i, function (r) { t[r] = !0 }), De.meshPrimitiveTarget(i, function (r) { De.meshPrimitiveTargetAttribute(r, function (s) { t[s] = !0 }) }); let o = i.indices; l(o) && (t[o] = !0) }) }), De.skin(e, function (n) { l(n.inverseBindMatrices) && (t[n.inverseBindMatrices] = !0) }), De.animation(e, function (n) { De.animationSampler(n, function (i) { l(i.input) && (t[i.input] = !0), l(i.output) && (t[i.output] = !0) }) }), pr(e, "EXT_mesh_gpu_instancing") && De.node(e, function (n) { l(n.extensions) && l(n.extensions.EXT_mesh_gpu_instancing) && Object.keys(n.extensions.EXT_mesh_gpu_instancing.attributes).forEach(function (i) { let o = n.extensions.EXT_mesh_gpu_instancing.attributes[i]; t[o] = !0 }) }), t }; Gd.buffer = function (e) { let t = {}; return De.bufferView(e, function (n) { l(n.buffer) && (t[n.buffer] = !0), l(n.extensions) && l(n.extensions.EXT_meshopt_compression) && (t[n.extensions.EXT_meshopt_compression.buffer] = !0) }), t }; Gd.bufferView = function (e) { let t = {}; if (De.accessor(e, function (n) { l(n.bufferView) && (t[n.bufferView] = !0) }), De.shader(e, function (n) { l(n.bufferView) && (t[n.bufferView] = !0) }), De.image(e, function (n) { l(n.bufferView) && (t[n.bufferView] = !0) }), pr(e, "KHR_draco_mesh_compression") && De.mesh(e, function (n) { De.meshPrimitive(n, function (i) { l(i.extensions) && l(i.extensions.KHR_draco_mesh_compression) && (t[i.extensions.KHR_draco_mesh_compression.bufferView] = !0) }) }), pr(e, "EXT_feature_metadata")) { let i = e.extensions.EXT_feature_metadata.featureTables; for (let o in i) if (i.hasOwnProperty(o)) { let s = i[o].properties; if (l(s)) { for (let a in s) if (s.hasOwnProperty(a)) { let c = s[a]; l(c.bufferView) && (t[c.bufferView] = !0), l(c.arrayOffsetBufferView) && (t[c.arrayOffsetBufferView] = !0), l(c.stringOffsetBufferView) && (t[c.stringOffsetBufferView] = !0) } } } } if (pr(e, "EXT_structural_metadata")) { let i = e.extensions.EXT_structural_metadata.propertyTables; if (l(i)) { let o = i.length; for (let r = 0; r < o; ++r) { let a = i[r].properties; for (let c in a) if (a.hasOwnProperty(c)) { let u = a[c]; l(u.values) && (t[u.values] = !0), l(u.arrayOffsets) && (t[u.arrayOffsets] = !0), l(u.stringOffsets) && (t[u.stringOffsets] = !0) } } } } return t }; Gd.image = function (e) { let t = {}; return De.texture(e, function (n) { l(n.source) && (t[n.source] = !0), l(n.extensions) && l(n.extensions.EXT_texture_webp) ? t[n.extensions.EXT_texture_webp.source] = !0 : l(n.extensions) && l(n.extensions.KHR_texture_basisu) && (t[n.extensions.KHR_texture_basisu.source] = !0) }), t }; Gd.mesh = function (e) { let t = {}; return De.node(e, function (n) { if (l(n.mesh && l(e.meshes))) { let i = e.meshes[n.mesh]; l(i) && l(i.primitives) && i.primitives.length > 0 && (t[n.mesh] = !0) } }), t }; function UQ(e, t, n) { let i = e.nodes[t]; return l(i.mesh) || l(i.camera) || l(i.skin) || l(i.weights) || l(i.extras) || l(i.extensions) && Object.keys(i.extensions).length !== 0 || l(n[t]) ? !1 : !l(i.children) || i.children.filter(function (o) { return !UQ(e, o, n) }).length === 0 } Gd.node = function (e) { let t = {}; return De.skin(e, function (n) { l(n.skeleton) && (t[n.skeleton] = !0), De.skinJoint(n, function (i) { t[i] = !0 }) }), De.animation(e, function (n) { De.animationChannel(n, function (i) { l(i.target) && l(i.target.node) && (t[i.target.node] = !0) }) }), De.technique(e, function (n) { De.techniqueUniform(n, function (i) { l(i.node) && (t[i.node] = !0) }) }), De.node(e, function (n, i) { UQ(e, i, t) || (t[i] = !0) }), t }; Gd.material = function (e) { let t = {}; return De.mesh(e, function (n) { De.meshPrimitive(n, function (i) { l(i.material) && (t[i.material] = !0) }) }), t }; Gd.texture = function (e) { let t = {}; if (De.material(e, function (n) { dS(n, function (i) { t[i] = !0 }) }), pr(e, "EXT_feature_metadata")) { De.mesh(e, function (o) { De.meshPrimitive(o, function (r) { let s = r.extensions; if (l(s) && l(s.EXT_feature_metadata)) { let c = s.EXT_feature_metadata.featureIdTextures; if (l(c)) { let u = c.length; for (let f = 0; f < u; ++f) { let p = c[f].featureIds.texture; t[p.index] = !0 } } } }) }); let i = e.extensions.EXT_feature_metadata.featureTextures; for (let o in i) if (i.hasOwnProperty(o)) { let s = i[o].properties; if (l(s)) { for (let a in s) if (s.hasOwnProperty(a)) { let u = s[a].texture; t[u.index] = !0 } } } } if (pr(e, "EXT_mesh_features") && De.mesh(e, function (n) { De.meshPrimitive(n, function (i) { let o = i.extensions; if (l(o) && l(o.EXT_mesh_features)) { let s = o.EXT_mesh_features.featureIds; if (l(s)) { let a = s.length; for (let c = 0; c < a; ++c) { let u = s[c]; l(u.texture) && (t[u.texture.index] = !0) } } } }) }), pr(e, "EXT_structural_metadata")) { let i = e.extensions.EXT_structural_metadata.propertyTextures; if (l(i)) { let o = i.length; for (let r = 0; r < o; ++r) { let a = i[r].properties; for (let c in a) if (a.hasOwnProperty(c)) { let u = a[c]; t[u.index] = !0 } } } } return t }; Gd.sampler = function (e) { let t = {}; return De.texture(e, function (n) { l(n.sampler) && (t[n.sampler] = !0) }), t }; var nR = hOe; function _Oe(e, t) { let n = { byteLength: t.length, extras: { _pipeline: { source: t } } }, o = { buffer: us(e.buffers, n), byteOffset: 0, byteLength: t.length }; return us(e.bufferViews, o) } var iR = _Oe; function gOe(e, t) { let n = yl(e, t), i = Y.getSizeInBytes(t.componentType), o = uu(t.type), r = t.count, s = new Array(o * r); if (!l(t.bufferView)) return s.fill(0); let a = e.bufferViews[t.bufferView], c = e.buffers[a.buffer].extras._pipeline.source, u = t.byteOffset + a.byteOffset + c.byteOffset, f = new DataView(c.buffer), d = new Array(o), p = s_(t.componentType); for (let g = 0; g < r; ++g) { p(f, u, o, i, d); for (let m = 0; m < o; ++m)s[g * o + m] = d[m]; u += n } return s } var oR = gOe; function yOe(e) { let t; return De.accessorWithSemantic(e, "JOINTS_0", function (n) { let i = e.accessors[n]; t = i.componentType, t === te.BYTE ? rR(e, i, Y.UNSIGNED_BYTE) : t !== te.UNSIGNED_BYTE && t !== te.UNSIGNED_SHORT && rR(e, i, Y.UNSIGNED_SHORT) }), De.accessorWithSemantic(e, "WEIGHTS_0", function (n) { let i = e.accessors[n]; t = i.componentType, t === te.BYTE ? rR(e, i, Y.UNSIGNED_BYTE) : t === te.SHORT && rR(e, i, Y.UNSIGNED_SHORT) }), e } function rR(e, t, n) { let i = Y.createTypedArray(n, oR(e, t)), o = new Uint8Array(i.buffer); t.bufferView = iR(e, o), t.componentType = n, t.byteOffset = 0 } var sR = yOe; function AOe(e, t) { return jC(e, t), t === "CESIUM_RTC" && COe(e), ZG(e, t) } function COe(e) { De.technique(e, function (t) { De.techniqueUniform(t, function (n) { n.semantic === "CESIUM_RTC_MODELVIEW" && (n.semantic = "MODELVIEW") }) }) } function ZG(e, t) { if (Array.isArray(e)) { let n = e.length; for (let i = 0; i < n; ++i)ZG(e[i], t) } else if (e !== null && typeof e == "object" && e.constructor === Object) { let n = e.extensions, i; l(n) && (i = n[t], l(i) && (delete n[t], Object.keys(n).length === 0 && delete e.extensions)); for (let o in e) Object.prototype.hasOwnProperty.call(e, o) && ZG(e[o], t); return i } } var YC = AOe; var aR = { .8: wOe, "1.0": YOe, "2.0": void 0 }; function xOe(e, t) { t = y(t, y.EMPTY_OBJECT); let n = t.targetVersion, i = e.version; e.asset = y(e.asset, { version: "1.0" }), e.asset.version = y(e.asset.version, "1.0"), i = y(i, e.asset.version).toString(), Object.prototype.hasOwnProperty.call(aR, i) || (l(i) && (i = i.substring(0, 3)), Object.prototype.hasOwnProperty.call(aR, i) || (i = "1.0")); let o = aR[i]; for (; l(o) && i !== n;)o(e, t), i = e.asset.version, o = aR[i]; return t.keepLegacyExtensions || (JOe(e), ZOe(e)), e } function HQ(e) { let t = e.materials; for (let n in t) if (Object.prototype.hasOwnProperty.call(t, n)) { let i = t[n], o = i.instanceTechnique; l(o) && (i.technique = o.technique, i.values = o.values, delete i.instanceTechnique) } } function TOe(e) { let t = e.meshes; for (let n in t) if (Object.prototype.hasOwnProperty.call(t, n)) { let o = t[n].primitives; if (l(o)) { let r = o.length; for (let s = 0; s < r; ++s) { let a = o[s], c = y(a.primitive, te.TRIANGLES); a.mode = y(a.mode, c), delete a.primitive } } } } function EOe(e) { let t = e.nodes, n = new h, i = new Be; for (let o in t) if (Object.prototype.hasOwnProperty.call(t, o)) { let r = t[o]; if (l(r.rotation)) { let a = r.rotation; h.fromArray(a, 0, n), Be.fromAxisAngle(n, a[3], i), r.rotation = [i.x, i.y, i.z, i.w] } let s = r.instanceSkin; l(s) && (r.skeletons = s.skeletons, r.skin = s.skin, r.meshes = s.meshes, delete r.instanceSkin) } } function bOe(e) { let t = e.animations, n = e.accessors, i = e.bufferViews, o = e.buffers, r = {}, s = new h, a = new Be; for (let c in t) if (Object.prototype.hasOwnProperty.call(t, c)) { let u = t[c], f = u.channels, d = u.parameters, p = u.samplers; if (l(f)) { let g = f.length; for (let m = 0; m < g; ++m) { let A = f[m]; if (A.target.path === "rotation") { let C = d[p[A.sampler].output]; if (l(r[C])) continue; r[C] = !0; let x = n[C], T = i[x.bufferView], S = o[T.buffer].extras._pipeline.source, D = S.byteOffset + T.byteOffset + x.byteOffset, P = x.componentType, B = x.count, R = uu(x.type), M = x.count * R, L = Y.createArrayBufferView(P, S.buffer, D, M); for (let _ = 0; _ < B; _++) { let E = _ * R; h.unpack(L, E, s); let w = L[E + 3]; Be.fromAxisAngle(s, w, a), Be.pack(a, L, E) } } } } } } function SOe(e) { let t = e.techniques; for (let n in t) if (Object.prototype.hasOwnProperty.call(t, n)) { let i = t[n], o = i.passes; if (l(o)) { let r = y(i.pass, "defaultPass"); if (Object.prototype.hasOwnProperty.call(o, r)) { let s = o[r], a = s.instanceProgram; i.attributes = y(i.attributes, a.attributes), i.program = y(i.program, a.program), i.uniforms = y(i.uniforms, a.uniforms), i.states = y(i.states, s.states) } delete i.passes, delete i.pass } } } function wOe(e) { l(e.asset) || (e.asset = {}); let t = e.asset; if (t.version = "1.0", typeof t.profile == "string") { let n = t.profile.split(" "); t.profile = { api: n[0], version: n[1] } } else t.profile = {}; if (l(e.version) && delete e.version, HQ(e), TOe(e), EOe(e), bOe(e), SOe(e), l(e.allExtensions) && (e.extensionsUsed = e.allExtensions, delete e.allExtensions), l(e.lights)) { let n = y(e.extensions, {}); e.extensions = n; let i = y(n.KHR_materials_common, {}); n.KHR_materials_common = i, i.lights = e.lights, delete e.lights, Cf(e, "KHR_materials_common") } } function DOe(e) { let t = e.animations; for (let n in t) if (Object.prototype.hasOwnProperty.call(t, n)) { let i = t[n], o = i.parameters; if (l(o)) { let r = i.samplers; for (let s in r) if (Object.prototype.hasOwnProperty.call(r, s)) { let a = r[s]; a.input = o[a.input], a.output = o[a.output] } delete i.parameters } } } function zQ(e, t) { let n = []; for (let i in e) if (Object.prototype.hasOwnProperty.call(e, i)) { let o = e[i]; t[i] = n.length, n.push(o), l(o.name) || (o.name = i) } return n } function vOe(e) { let t, n = { accessors: {}, animations: {}, buffers: {}, bufferViews: {}, cameras: {}, images: {}, materials: {}, meshes: {}, nodes: {}, programs: {}, samplers: {}, scenes: {}, shaders: {}, skins: {}, textures: {}, techniques: {} }, i, o = {}, r = e.nodes; for (let s in r) Object.prototype.hasOwnProperty.call(r, s) && (i = r[s].jointName, l(i) && (o[i] = s)); for (let s in e) if (Object.prototype.hasOwnProperty.call(e, s) && l(n[s])) { let a = {}, c = e[s]; e[s] = zQ(c, a), n[s] = a } for (i in o) Object.prototype.hasOwnProperty.call(o, i) && (o[i] = n.nodes[o[i]]); l(e.scene) && (e.scene = n.scenes[e.scene]), De.bufferView(e, function (s) { l(s.buffer) && (s.buffer = n.buffers[s.buffer]) }), De.accessor(e, function (s) { l(s.bufferView) && (s.bufferView = n.bufferViews[s.bufferView]) }), De.shader(e, function (s) { let a = s.extensions; if (l(a)) { let c = a.KHR_binary_glTF; l(c) && (s.bufferView = n.bufferViews[c.bufferView], delete a.KHR_binary_glTF), Object.keys(a).length === 0 && delete s.extensions } }), De.program(e, function (s) { l(s.vertexShader) && (s.vertexShader = n.shaders[s.vertexShader]), l(s.fragmentShader) && (s.fragmentShader = n.shaders[s.fragmentShader]) }), De.technique(e, function (s) { l(s.program) && (s.program = n.programs[s.program]), De.techniqueParameter(s, function (a) { l(a.node) && (a.node = n.nodes[a.node]); let c = a.value; typeof c == "string" && (a.value = { index: n.textures[c] }) }) }), De.mesh(e, function (s) { De.meshPrimitive(s, function (a) { l(a.indices) && (a.indices = n.accessors[a.indices]), De.meshPrimitiveAttribute(a, function (c, u) { a.attributes[u] = n.accessors[c] }), l(a.material) && (a.material = n.materials[a.material]) }) }), De.node(e, function (s) { let a = s.children; if (l(a)) { let c = a.length; for (t = 0; t < c; ++t)a[t] = n.nodes[a[t]] } if (l(s.meshes)) { let c = s.meshes, u = c.length; if (u > 0) for (s.mesh = n.meshes[c[0]], t = 1; t < u; ++t) { let f = { mesh: n.meshes[c[t]] }, d = us(e.nodes, f); l(a) || (a = [], s.children = a), a.push(d) } delete s.meshes } if (l(s.camera) && (s.camera = n.cameras[s.camera]), l(s.skin) && (s.skin = n.skins[s.skin]), l(s.skeletons)) { let c = s.skeletons; if (c.length > 0 && l(s.skin)) { let f = e.skins[s.skin]; f.skeleton = n.nodes[c[0]] } delete s.skeletons } l(s.jointName) && delete s.jointName }), De.skin(e, function (s) { l(s.inverseBindMatrices) && (s.inverseBindMatrices = n.accessors[s.inverseBindMatrices]); let a = s.jointNames; if (l(a)) { let c = [], u = a.length; for (t = 0; t < u; ++t)c[t] = o[a[t]]; s.joints = c, delete s.jointNames } }), De.scene(e, function (s) { let a = s.nodes; if (l(a)) { let c = a.length; for (t = 0; t < c; ++t)a[t] = n.nodes[a[t]] } }), De.animation(e, function (s) { let a = {}; s.samplers = zQ(s.samplers, a), De.animationSampler(s, function (c) { c.input = n.accessors[c.input], c.output = n.accessors[c.output] }), De.animationChannel(s, function (c) { c.sampler = a[c.sampler]; let u = c.target; l(u) && (u.node = n.nodes[u.id], delete u.id) }) }), De.material(e, function (s) { l(s.technique) && (s.technique = n.techniques[s.technique]), De.materialValue(s, function (c, u) { typeof c == "string" && (s.values[u] = { index: n.textures[c] }) }); let a = s.extensions; if (l(a)) { let c = a.KHR_materials_common; l(c) && l(c.values) && De.materialValue(c, function (u, f) { typeof u == "string" && (c.values[f] = { index: n.textures[u] }) }) } }), De.image(e, function (s) { let a = s.extensions; if (l(a)) { let c = a.KHR_binary_glTF; l(c) && (s.bufferView = n.bufferViews[c.bufferView], s.mimeType = c.mimeType, delete a.KHR_binary_glTF), Object.keys(a).length === 0 && delete s.extensions } }), De.texture(e, function (s) { l(s.sampler) && (s.sampler = n.samplers[s.sampler]), l(s.source) && (s.source = n.images[s.source]) }) } function POe(e) { De.animation(e, function (t) { De.animationSampler(t, function (n) { delete n.name }) }) } function IOe(e) { for (let t in e) if (Object.prototype.hasOwnProperty.call(e, t)) { let n = e[t]; Array.isArray(n) && n.length === 0 && delete e[t] } De.node(e, function (t) { l(t.children) && t.children.length === 0 && delete t.children }) } function OOe(e) { let t = e.asset; delete t.profile, delete t.premultipliedAlpha } var BOe = { CESIUM_RTC: !0, KHR_materials_common: !0, WEB3D_quantized_attributes: !0 }; function ROe(e) { let t = e.extensionsUsed; if (e.extensionsRequired = y(e.extensionsRequired, []), l(t)) { let n = t.length; for (let i = 0; i < n; ++i) { let o = t[i]; l(BOe[o]) && e.extensionsRequired.push(o) } } } function MOe(e) { De.buffer(e, function (t) { delete t.type }) } function LOe(e) { De.texture(e, function (t) { delete t.format, delete t.internalFormat, delete t.target, delete t.type }) } function FOe(e) { De.mesh(e, function (t) { De.meshPrimitive(t, function (n) { De.meshPrimitiveAttribute(n, function (i, o) { o === "TEXCOORD" ? n.attributes.TEXCOORD_0 = i : o === "COLOR" && (n.attributes.COLOR_0 = i) }), delete n.attributes.TEXCOORD, delete n.attributes.COLOR }) }), De.technique(e, function (t) { De.techniqueParameter(t, function (n) { let i = n.semantic; l(i) && (i === "TEXCOORD" ? n.semantic = "TEXCOORD_0" : i === "COLOR" && (n.semantic = "COLOR_0")) }) }) } var NOe = { POSITION: !0, NORMAL: !0, TANGENT: !0 }, VOe = { COLOR: "COLOR", JOINT: "JOINTS", JOINTS: "JOINTS", TEXCOORD: "TEXCOORD", WEIGHT: "WEIGHTS", WEIGHTS: "WEIGHTS" }; function kOe(e) { let t = {}; De.mesh(e, function (n) { De.meshPrimitive(n, function (i) { De.meshPrimitiveAttribute(i, function (o, r) { if (r.charAt(0) !== "_") { let s = r.search(/_[0-9]+/g), a = r, c = "_0"; s >= 0 && (a = r.substring(0, s), c = r.substring(s)); let u, f = VOe[a]; l(f) ? (u = f + c, t[r] = u) : l(NOe[a]) || (u = `_${r}`, t[r] = u) } }); for (let o in t) if (Object.prototype.hasOwnProperty.call(t, o)) { let r = t[o], s = i.attributes[o]; l(s) && (delete i.attributes[o], i.attributes[r] = s) } }) }), De.technique(e, function (n) { De.techniqueParameter(n, function (i) { let o = t[i.semantic]; l(o) && (i.semantic = o) }) }) } function UOe(e) { De.camera(e, function (t) { let n = t.perspective; if (l(n)) { let i = n.aspectRatio; l(i) && i === 0 && delete n.aspectRatio; let o = n.yfov; l(o) && o === 0 && (n.yfov = 1) } }) } function QG(e, t) { return l(t.byteStride) && t.byteStride !== 0 ? t.byteStride : yl(e, t) } function zOe(e) { De.buffer(e, function (t) { l(t.byteLength) || (t.byteLength = t.extras._pipeline.source.length) }), De.accessor(e, function (t) { let n = t.bufferView; if (l(n)) { let i = e.bufferViews[n], o = QG(e, t), r = t.byteOffset + t.count * o; i.byteLength = Math.max(y(i.byteLength, 0), r) } }) } function HOe(e) { let t, n, i, o = e.bufferViews, r = {}; De.accessorContainingVertexAttributeData(e, function (a) { let c = e.accessors[a]; l(c.bufferView) && (r[c.bufferView] = !0) }); let s = {}; De.accessor(e, function (a) { l(a.bufferView) && (s[a.bufferView] = y(s[a.bufferView], []), s[a.bufferView].push(a)) }); for (let a in s) if (Object.prototype.hasOwnProperty.call(s, a)) { i = o[a]; let c = s[a]; c.sort(function (p, g) { return p.byteOffset - g.byteOffset }); let u = 0, f = 0, d = c.length; for (t = 0; t < d; ++t) { let p = c[t], g = QG(e, p), m = p.byteOffset, A = p.count * g; delete p.byteStride; let C = t < d - 1, x = C ? QG(e, c[t + 1]) : void 0; if (g !== x) { let T = tt(i, !0); r[a] && (T.byteStride = g), T.byteOffset += u, T.byteLength = m + A - u; let b = us(o, T); for (n = f; n <= t; ++n)p = c[n], p.bufferView = b, p.byteOffset = p.byteOffset - u; u = C ? c[t + 1].byteOffset : void 0, f = t + 1 } } } nR(e, ["accessor", "bufferView", "buffer"]) } function GOe(e) { De.accessorWithSemantic(e, "POSITION", function (t) { let n = e.accessors[t]; if (!l(n.min) || !l(n.max)) { let i = qC(e, n); n.min = i.min, n.max = i.max } }) } function GQ(e) { return (!l(e.children) || e.children.length === 0) && (!l(e.meshes) || e.meshes.length === 0) && !l(e.camera) && !l(e.skin) && !l(e.skeletons) && !l(e.jointName) && (!l(e.translation) || h.fromArray(e.translation).equals(h.ZERO)) && (!l(e.scale) || h.fromArray(e.scale).equals(new h(1, 1, 1))) && (!l(e.rotation) || se.fromArray(e.rotation).equals(new se(0, 0, 0, 1))) && (!l(e.matrix) || F.fromColumnMajorArray(e.matrix).equals(F.IDENTITY)) && !l(e.extensions) && !l(e.extras) } function WQ(e, t) { De.scene(e, function (n) { let i = n.nodes; if (l(i)) { let o = i.length; for (let r = o; r >= 0; --r)if (i[r] === t) { i.splice(r, 1); return } } }), De.node(e, function (n, i) { if (l(n.children)) { let o = n.children.indexOf(t); o > -1 && (n.children.splice(o, 1), GQ(n) && WQ(e, i)) } }), delete e.nodes[t] } function WOe(e) { return De.node(e, function (t, n) { GQ(t) && WQ(e, n) }), e } function jOe(e) { De.animation(e, function (t) { De.animationSampler(t, function (n) { let i = e.accessors[n.input]; if (!l(i.min) || !l(i.max)) { let o = qC(e, i); i.min = o.min, i.max = o.max } }) }) } function qOe(e) { De.accessor(e, function (t) { if (l(t.min) || l(t.max)) { let n = qC(e, t); l(t.min) && (t.min = n.min), l(t.max) && (t.max = n.max) } }) } function YOe(e) { e.asset = y(e.asset, {}), e.asset.version = "2.0", HQ(e), DOe(e), WOe(e), vOe(e), POe(e), OOe(e), ROe(e), zOe(e), HOe(e), GOe(e), jOe(e), qOe(e), MOe(e), LOe(e), FOe(e), kOe(e), sR(e), UOe(e), $B(e), tR(e), IOe(e) } var XOe = ["u_tex", "u_diffuse", "u_emission"], KOe = ["u_diffuse"]; function $G(e) { e.pbrMetallicRoughness = l(e.pbrMetallicRoughness) ? e.pbrMetallicRoughness : {}, e.pbrMetallicRoughness.roughnessFactor = 1, e.pbrMetallicRoughness.metallicFactor = 0 } function cR(e) { return l(e.index) } function lR(e) { return Array.isArray(e) && e.length === 4 } function jQ(e) { let t = new Array(4); t[3] = e[3]; for (let n = 0; n < 3; n++) { let i = e[n]; i <= .04045 ? t[n] = e[n] * .07739938080495357 : t[n] = Math.pow((i + .055) * .9478672985781991, 2.4) } return t } function JOe(e) { De.material(e, function (t) { De.materialValue(t, function (n, i) { XOe.indexOf(i) !== -1 && cR(n) ? ($G(t), t.pbrMetallicRoughness.baseColorTexture = n) : KOe.indexOf(i) !== -1 && lR(n) && ($G(t), t.pbrMetallicRoughness.baseColorFactor = jQ(n)) }) }), YC(e, "KHR_techniques_webgl"), YC(e, "KHR_blend") } function ZOe(e) { De.material(e, function (t) { let n = y(t.extensions, y.EMPTY_OBJECT).KHR_materials_common; if (l(n)) { n.technique === "CONSTANT" && (Cf(e, "KHR_materials_unlit"), t.extensions = l(t.extensions) ? t.extensions : {}, t.extensions.KHR_materials_unlit = {}); let o = l(n.values) ? n.values : {}, r = o.ambient, s = o.diffuse, a = o.emission, c = o.transparency, u = n.doubleSided, f = n.transparent; $G(t), l(r) && (lR(r) ? t.emissiveFactor = r.slice(0, 3) : cR(r) && (t.emissiveTexture = r)), l(s) && (lR(s) ? t.pbrMetallicRoughness.baseColorFactor = jQ(s) : cR(s) && (t.pbrMetallicRoughness.baseColorTexture = s)), l(u) && (t.doubleSided = u), l(a) && (lR(a) ? t.emissiveFactor = a.slice(0, 3) : cR(a) && (t.emissiveTexture = a)), l(c) && (l(t.pbrMetallicRoughness.baseColorFactor) ? t.pbrMetallicRoughness.baseColorFactor[3] *= c : t.pbrMetallicRoughness.baseColorFactor = [1, 1, 1, c]), l(f) && (t.alphaMode = f ? "BLEND" : "OPAQUE") } }), YC(e, "KHR_materials_common") } var uR = xOe; function a_(e) { e = y(e, y.EMPTY_OBJECT); let t = e.resourceCache, n = e.gltfResource, i = e.baseResource, o = e.typedArray, r = e.gltfJson, s = e.cacheKey; this._resourceCache = t, this._gltfResource = n, this._baseResource = i, this._typedArray = o, this._gltfJson = r, this._cacheKey = s, this._gltf = void 0, this._bufferLoaders = [], this._state = kt.UNLOADED, this._promise = void 0 } l(Object.create) && (a_.prototype = Object.create(Zi.prototype), a_.prototype.constructor = a_); Object.defineProperties(a_.prototype, { promise: { get: function () { return this._promise } }, cacheKey: { get: function () { return this._cacheKey } }, gltf: { get: function () { return this._gltf } } }); a_.prototype.load = function () { this._state = kt.LOADING; let e; l(this._gltfJson) ? e = qQ(this, this._gltfJson) : l(this._typedArray) ? e = YQ(this, this._typedArray) : e = QOe(this); let t = this; return this._promise = e.then(function (n) { if (!t.isDestroyed()) return t._gltf = n, t._state = kt.READY, t }).catch(function (n) { if (!t.isDestroyed()) return $Oe(t, n) }), this._promise }; function QOe(e) { return e._fetchGltf().then(function (t) { if (e.isDestroyed()) return; let n = new Uint8Array(t); return YQ(e, n) }) } function $Oe(e, t) { e.unload(), e._state = kt.FAILED; let n = `Failed to load glTF: ${e._gltfResource.url}`; return Promise.reject(e.getError(n, t)) } function eBe(e, t) { if (l(t.asset) && t.asset.version === "2.0" && !pr(t, "KHR_techniques_webgl") && !pr(t, "KHR_materials_common")) return Promise.resolve(); let n = []; return De.buffer(t, function (i) { if (!l(i.extras._pipeline.source) && l(i.uri)) { let o = e._baseResource.getDerivedResource({ url: i.uri }), s = e._resourceCache.loadExternalBuffer({ resource: o }); e._bufferLoaders.push(s), n.push(s.promise.then(function (a) { i.extras._pipeline.source = a.typedArray })) } }), Promise.all(n).then(function () { uR(t) }) } function tBe(e) { let t = []; return De.buffer(e, function (n) { let i = n.uri; !l(n.extras._pipeline.source) && l(i) && Pp(i) && (delete n.uri, t.push(Pe.fetchArrayBuffer(i).then(function (o) { n.extras._pipeline.source = new Uint8Array(o) }))) }), Promise.all(t) } function nBe(e, t) { let n = []; return De.buffer(t, function (i, o) { let r = i.extras._pipeline.source; if (l(r) && !l(i.uri)) { let a = e._resourceCache.loadEmbeddedBuffer({ parentResource: e._gltfResource, bufferId: o, typedArray: r }); e._bufferLoaders.push(a), n.push(a.promise) } }), Promise.all(n) } function qQ(e, t) { return F0(t), tBe(t).then(function () { return eBe(e, t) }).then(function () { return YB(t), nBe(e, t) }).then(function () { return QB(t), t }) } function YQ(e, t) { let n; return zd(t) === "glTF" ? n = JB(t) : n = Ko(t), qQ(e, n) } a_.prototype.unload = function () { let e = this._bufferLoaders, t = e.length; for (let n = 0; n < t; ++n)this._resourceCache.unload(e[n]); this._bufferLoaders.length = 0, this._gltf = void 0 }; a_.prototype._fetchGltf = function () { return this._gltfResource.fetchArrayBuffer() }; var hS = a_; var iBe = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" }, xm = Object.freeze(iBe); var Lo = {}; function oBe() { this.octEncoded = !1, this.octEncodedZXY = !1, this.normalizationRange = void 0, this.quantizedVolumeOffset = void 0, this.quantizedVolumeDimensions = void 0, this.quantizedVolumeStepSize = void 0, this.componentDatatype = void 0, this.type = void 0 } function rBe() { this.name = void 0, this.semantic = void 0, this.setIndex = void 0, this.componentDatatype = void 0, this.type = void 0, this.normalized = !1, this.count = void 0, this.min = void 0, this.max = void 0, this.constant = void 0, this.quantization = void 0, this.typedArray = void 0, this.buffer = void 0, this.byteOffset = 0, this.byteStride = void 0 } function sBe() { this.indexDatatype = void 0, this.count = void 0, this.buffer = void 0, this.typedArray = void 0 } function aBe() { this.featureCount = void 0, this.nullFeatureId = void 0, this.propertyTableId = void 0, this.setIndex = void 0, this.label = void 0, this.positionalLabel = void 0 } function cBe() { this.featureCount = void 0, this.nullFeatureId = void 0, this.propertyTableId = void 0, this.offset = 0, this.repeat = void 0, this.label = void 0, this.positionalLabel = void 0 } function lBe() { this.featureCount = void 0, this.nullFeatureId = void 0, this.propertyTableId = void 0, this.textureReader = void 0, this.label = void 0, this.positionalLabel = void 0 } function uBe() { this.attributes = [] } function fBe() { this.attributes = [], this.morphTargets = [], this.indices = void 0, this.material = void 0, this.primitiveType = void 0, this.featureIds = [], this.propertyTextureIds = [], this.propertyAttributeIds = [], this.outlineCoordinates = void 0 } function dBe() { this.attributes = [], this.featureIds = [], this.transformInWorldSpace = !1 } function hBe() { this.index = void 0, this.joints = [], this.inverseBindMatrices = [] } function mBe() { this.name = void 0, this.index = void 0, this.children = [], this.primitives = [], this.instances = void 0, this.skin = void 0, this.matrix = void 0, this.translation = void 0, this.rotation = void 0, this.scale = void 0, this.morphWeights = [], this.articulationName = void 0 } function pBe() { this.nodes = [] } var _Be = { TRANSLATION: "translation", ROTATION: "rotation", SCALE: "scale", WEIGHTS: "weights" }; function gBe() { this.input = [], this.interpolation = void 0, this.output = [] } function yBe() { this.node = void 0, this.path = void 0 } function ABe() { this.sampler = void 0, this.target = void 0 } function CBe() { this.name = void 0, this.samplers = [], this.channels = [] } function xBe() { this.name = void 0, this.type = void 0, this.minimumValue = void 0, this.maximumValue = void 0, this.initialValue = void 0 } function TBe() { this.name = void 0, this.stages = [] } function XQ() { this.credits = [] } function EBe() { this.asset = new XQ, this.scene = void 0, this.nodes = [], this.skins = [], this.animations = [], this.articulations = [], this.structuralMetadata = void 0, this.upAxis = void 0, this.forwardAxis = void 0, this.transform = F.clone(F.IDENTITY) } function bBe() { this.texture = void 0, this.index = void 0, this.texCoord = 0, this.transform = Q.clone(Q.IDENTITY), this.channels = void 0 } function c_() { this.baseColorTexture = void 0, this.metallicRoughnessTexture = void 0, this.baseColorFactor = se.clone(c_.DEFAULT_BASE_COLOR_FACTOR), this.metallicFactor = c_.DEFAULT_METALLIC_FACTOR, this.roughnessFactor = c_.DEFAULT_ROUGHNESS_FACTOR } c_.DEFAULT_BASE_COLOR_FACTOR = se.ONE; c_.DEFAULT_METALLIC_FACTOR = 1; c_.DEFAULT_ROUGHNESS_FACTOR = 1; function N0() { this.diffuseTexture = void 0, this.specularGlossinessTexture = void 0, this.diffuseFactor = se.clone(N0.DEFAULT_DIFFUSE_FACTOR), this.specularFactor = h.clone(N0.DEFAULT_SPECULAR_FACTOR), this.glossinessFactor = N0.DEFAULT_GLOSSINESS_FACTOR } N0.DEFAULT_DIFFUSE_FACTOR = se.ONE; N0.DEFAULT_SPECULAR_FACTOR = h.ONE; N0.DEFAULT_GLOSSINESS_FACTOR = 1; function e8() { this.metallicRoughness = new c_, this.specularGlossiness = void 0, this.emissiveTexture = void 0, this.normalTexture = void 0, this.occlusionTexture = void 0, this.emissiveFactor = h.clone(e8.DEFAULT_EMISSIVE_FACTOR), this.alphaMode = xm.OPAQUE, this.alphaCutoff = .5, this.doubleSided = !1, this.unlit = !1 } e8.DEFAULT_EMISSIVE_FACTOR = h.ZERO; Lo.Quantization = oBe; Lo.Attribute = rBe; Lo.Indices = sBe; Lo.FeatureIdAttribute = aBe; Lo.FeatureIdTexture = lBe; Lo.FeatureIdImplicitRange = cBe; Lo.MorphTarget = uBe; Lo.Primitive = fBe; Lo.Instances = dBe; Lo.Skin = hBe; Lo.Node = mBe; Lo.Scene = pBe; Lo.AnimatedPropertyType = Object.freeze(_Be); Lo.AnimationSampler = gBe; Lo.AnimationTarget = yBe; Lo.AnimationChannel = ABe; Lo.Animation = CBe; Lo.ArticulationStage = xBe; Lo.Articulation = TBe; Lo.Asset = XQ; Lo.Components = EBe; Lo.TextureReader = bBe; Lo.MetallicRoughness = c_; Lo.SpecularGlossiness = N0; Lo.Material = e8; var Dt = Lo; var fR = {}; fR.getImageIdFromTexture = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltf, n = e.textureId, i = e.supportedImageFormats, o = t.textures[n], r = o.extensions; if (l(r)) { if (i.webp && l(r.EXT_texture_webp)) return r.EXT_texture_webp.source; if (i.basis && l(r.KHR_texture_basisu)) return r.KHR_texture_basisu.source } return o.source }; fR.createSampler = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltf, n = e.textureInfo, i = y(e.compressedTextureNoMipmap, !1), o = In.REPEAT, r = In.REPEAT, s = ln.LINEAR, a = Xi.LINEAR, c = n.index, f = t.textures[c].sampler; if (l(f)) { let g = t.samplers[f]; o = y(g.wrapS, o), r = y(g.wrapT, r), s = y(g.minFilter, s), a = y(g.magFilter, a) } let d = !1, p = n.extensions; return l(p) && l(p.KHR_texture_transform) && (d = !0), (i || d) && s !== ln.LINEAR && s !== ln.NEAREST && (s === ln.NEAREST_MIPMAP_NEAREST || s === ln.NEAREST_MIPMAP_LINEAR ? s = ln.NEAREST : s = ln.LINEAR), new dn({ wrapS: o, wrapT: r, minificationFilter: s, magnificationFilter: a }) }; var SBe = new H(1, 1); fR.createModelTextureReader = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.textureInfo, n = e.channels, i = e.texture, o = y(t.texCoord, 0), r, s = y(t.extensions, y.EMPTY_OBJECT).KHR_texture_transform; if (l(s)) { o = y(s.texCoord, o); let c = l(s.offset) ? H.unpack(s.offset) : H.ZERO, u = y(s.rotation, 0), f = l(s.scale) ? H.unpack(s.scale) : SBe; u = -u, r = new Q(Math.cos(u) * f.x, -Math.sin(u) * f.y, c.x, Math.sin(u) * f.x, Math.cos(u) * f.y, c.y, 0, 0, 1) } let a = new Dt.TextureReader; return a.index = t.index, a.texture = i, a.texCoord = o, a.transform = r, a.channels = n, a }; var Al = fR; function wBe(e) { let t = document.createElement("canvas"); return t.width = I.nextPowerOfTwo(e.width), t.height = I.nextPowerOfTwo(e.height), t.getContext("2d").drawImage(e, 0, 0, e.width, e.height, 0, 0, t.width, t.height), t } var V0 = wBe; function l_(e) { e = y(e, y.EMPTY_OBJECT); let t = e.resourceCache, n = e.gltf, i = e.textureInfo, o = e.gltfResource, r = e.baseResource, s = e.supportedImageFormats, a = e.cacheKey, c = y(e.asynchronous, !0), u = i.index, f = Al.getImageIdFromTexture({ gltf: n, textureId: u, supportedImageFormats: s }); this._resourceCache = t, this._gltf = n, this._textureInfo = i, this._imageId = f, this._gltfResource = o, this._baseResource = r, this._cacheKey = a, this._asynchronous = c, this._imageLoader = void 0, this._image = void 0, this._mipLevels = void 0, this._texture = void 0, this._state = kt.UNLOADED, this._promise = void 0, this._process = function (d, p) { } } l(Object.create) && (l_.prototype = Object.create(Zi.prototype), l_.prototype.constructor = l_); Object.defineProperties(l_.prototype, { promise: { get: function () { return this._promise } }, cacheKey: { get: function () { return this._cacheKey } }, texture: { get: function () { return this._texture } } }); var DBe = new t8; l_.prototype.load = function () { let t = this._resourceCache.loadImage({ gltf: this._gltf, imageId: this._imageId, gltfResource: this._gltfResource, baseResource: this._baseResource }); this._imageLoader = t, this._state = kt.LOADING; let n = this, i = new Promise(function (o) { n._process = function (r, s) { if (l(r._texture) || !l(r._image)) return; let a; if (r._asynchronous) { let c = DBe; if (c.set(r._gltf, r._textureInfo, r._image, r._mipLevels, s.context), !s.jobScheduler.execute(c, Ca.TEXTURE)) return; a = c.texture } else a = KQ(r._gltf, r._textureInfo, r._image, r._mipLevels, s.context); r.unload(), r._texture = a, r._state = kt.READY, o(r) } }); return this._promise = t.promise.then(function () { if (!n.isDestroyed()) return n._image = t.image, n._mipLevels = t.mipLevels, n._state = kt.PROCESSING, i }).catch(function (o) { if (n.isDestroyed()) return; n.unload(), n._state = kt.FAILED; let r = "Failed to load texture"; return Promise.reject(n.getError(r, o)) }), this._promise }; function t8() { this.gltf = void 0, this.textureInfo = void 0, this.image = void 0, this.context = void 0, this.texture = void 0 } t8.prototype.set = function (e, t, n, i, o) { this.gltf = e, this.textureInfo = t, this.image = n, this.mipLevels = i, this.context = o }; t8.prototype.execute = function () { this.texture = KQ(this.gltf, this.textureInfo, this.image, this.mipLevels, this.context) }; function KQ(e, t, n, i, o) { let r = n.internalFormat, s = !1; ht.isCompressedFormat(r) && !l(i) && (s = !0); let a = Al.createSampler({ gltf: e, textureInfo: t, compressedTextureNoMipmap: s }), c = a.minificationFilter, u = a.wrapS, f = a.wrapT, d = c === ln.NEAREST_MIPMAP_NEAREST || c === ln.NEAREST_MIPMAP_LINEAR || c === ln.LINEAR_MIPMAP_NEAREST || c === ln.LINEAR_MIPMAP_LINEAR, p = !l(r) && d, g = p || u === In.REPEAT || u === In.MIRRORED_REPEAT || f === In.REPEAT || f === In.MIRRORED_REPEAT, m = !I.isPowerOfTwo(n.width) || !I.isPowerOfTwo(n.height), A = g && m, C; return l(r) ? (!o.webgl2 && ht.isCompressedFormat(r) && m && g && console.warn("Compressed texture uses REPEAT or MIRRORED_REPEAT texture wrap mode and dimensions are not powers of two. The texture may be rendered incorrectly."), C = Rt.create({ context: o, source: { arrayBufferView: n.bufferView, mipLevels: i }, width: n.width, height: n.height, pixelFormat: n.internalFormat, sampler: a })) : (A && (n = V0(n)), C = Rt.create({ context: o, source: n, sampler: a, flipY: !1, skipColorSpaceConversion: !0 })), p && C.generateMipmap(), C } l_.prototype.process = function (e) { return this._process(this, e) }; l_.prototype.unload = function () { l(this._texture) && this._texture.destroy(), l(this._imageLoader) && this._resourceCache.unload(this._imageLoader), this._imageLoader = void 0, this._image = void 0, this._mipLevels = void 0, this._texture = void 0, this._gltf = void 0 }; var mS = l_; function u_(e) { e = y(e, y.EMPTY_OBJECT); let t = e.resourceCache, n = e.gltf, i = e.gltfResource, o = e.baseResource, r = e.bufferViewId, s = e.draco, a = e.attributeSemantic, c = e.accessorId, u = e.cacheKey, f = y(e.asynchronous, !0), d = y(e.loadBuffer, !1), p = y(e.loadTypedArray, !1); this._resourceCache = t, this._gltfResource = i, this._baseResource = o, this._gltf = n, this._bufferViewId = r, this._draco = s, this._attributeSemantic = a, this._accessorId = c, this._cacheKey = u, this._asynchronous = f, this._loadBuffer = d, this._loadTypedArray = p, this._bufferViewLoader = void 0, this._dracoLoader = void 0, this._quantization = void 0, this._typedArray = void 0, this._buffer = void 0, this._state = kt.UNLOADED, this._promise = void 0, this._process = function (g, m) { } } l(Object.create) && (u_.prototype = Object.create(Zi.prototype), u_.prototype.constructor = u_); Object.defineProperties(u_.prototype, { promise: { get: function () { return this._promise } }, cacheKey: { get: function () { return this._cacheKey } }, buffer: { get: function () { return this._buffer } }, typedArray: { get: function () { return this._typedArray } }, quantization: { get: function () { return this._quantization } } }); u_.prototype.load = function () { let e; l(this._draco) ? e = PBe(this) : e = IBe(this); let t = this, n = new n8, i = new Promise(function (o) { t._process = function (r, s) { if (r._state === kt.READY) return; let a = r._typedArray; if (l(r._dracoLoader) && r._dracoLoader.process(s), l(r._bufferViewLoader) && r._bufferViewLoader.process(s), !l(a)) return; let c; if (r._loadBuffer && r._asynchronous) { let u = n; if (u.set(a, s.context), !s.jobScheduler.execute(u, Ca.BUFFER)) return; c = u.buffer } else r._loadBuffer && (c = JQ(a, s.context)); r.unload(), r._buffer = c, r._typedArray = r._loadTypedArray ? a : void 0, r._state = kt.READY, o(r) } }); return this._promise = e.then(function () { if (!t.isDestroyed()) return i }).catch(function (o) { if (!t.isDestroyed()) return OBe(t, o) }), this._promise }; function vBe(e, t, n, i) { let o = e.quantizationBits, r = (1 << o) - 1, s = 1 / r, a = new Dt.Quantization; if (a.componentDatatype = t, a.octEncoded = e.octEncoded, a.octEncodedZXY = !0, a.type = i, a.octEncoded) a.type = en.VEC2, a.normalizationRange = r; else { let c = en.getMathType(i); if (c === Number) { let u = e.range; a.quantizedVolumeOffset = e.minValues[0], a.quantizedVolumeDimensions = u, a.normalizationRange = r, a.quantizedVolumeStepSize = u * s } else { a.quantizedVolumeOffset = c.unpack(e.minValues), a.normalizationRange = c.unpack(new Array(n).fill(r)); let u = new Array(n).fill(e.range); a.quantizedVolumeDimensions = c.unpack(u); let f = u.map(function (d) { return d * s }); a.quantizedVolumeStepSize = c.unpack(f) } } return a } function PBe(e) { let n = e._resourceCache.loadDraco({ gltf: e._gltf, draco: e._draco, gltfResource: e._gltfResource, baseResource: e._baseResource }); return e._dracoLoader = n, e._state = kt.LOADING, n.promise.then(function () { if (e.isDestroyed()) return; let i = n.decodedData.vertexAttributes, o = e._attributeSemantic, r = i[o], s = e._accessorId, c = e._gltf.accessors[s].type, u = r.array, f = r.data.quantization; return l(f) && (e._quantization = vBe(f, r.data.componentDatatype, r.data.componentsPerAttribute, c)), e._typedArray = new Uint8Array(u.buffer, u.byteOffset, u.byteLength), e._state = kt.PROCESSING, e }) } function IBe(e) { let n = e._resourceCache.loadBufferView({ gltf: e._gltf, bufferViewId: e._bufferViewId, gltfResource: e._gltfResource, baseResource: e._baseResource }); return e._state = kt.LOADING, e._bufferViewLoader = n, n.promise.then(function () { if (!e.isDestroyed()) return e._typedArray = n.typedArray, e._state = kt.PROCESSING, e }) } function OBe(e, t) { e.unload(), e._state = kt.FAILED; let n = "Failed to load vertex buffer"; return t = e.getError(n, t), Promise.reject(t) } function n8() { this.typedArray = void 0, this.context = void 0, this.buffer = void 0 } n8.prototype.set = function (e, t) { this.typedArray = e, this.context = t }; n8.prototype.execute = function () { this.buffer = JQ(this.typedArray, this.context) }; function JQ(e, t) { let n = ct.createVertexBuffer({ typedArray: e, context: t, usage: Re.STATIC_DRAW }); return n.vertexArrayDestroyable = !1, n } u_.prototype.process = function (e) { return this._process(this, e) }; u_.prototype.unload = function () { l(this._buffer) && this._buffer.destroy(); let e = this._resourceCache; l(this._bufferViewLoader) && e.unload(this._bufferViewLoader), l(this._dracoLoader) && e.unload(this._dracoLoader), this._bufferViewLoader = void 0, this._dracoLoader = void 0, this._typedArray = void 0, this._buffer = void 0, this._gltf = void 0 }; var pS = u_; function i8(e) { e = y(e, y.EMPTY_OBJECT); let t = e.id, n = e.class, i = {}, o = {}; for (let r in n.properties) if (n.properties.hasOwnProperty(r)) { let s = new M0({ id: r, property: n.properties[r], enums: e.enums }); i[r] = s, l(s.semantic) && (o[s.semantic] = s) } this._properties = i, this._propertiesBySemantic = o, this._id = t, this._name = n.name, this._description = n.description, this._extras = n.extras, this._extensions = n.extensions } Object.defineProperties(i8.prototype, { properties: { get: function () { return this._properties } }, propertiesBySemantic: { get: function () { return this._propertiesBySemantic } }, id: { get: function () { return this._id } }, name: { get: function () { return this._name } }, description: { get: function () { return this._description } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); i8.BATCH_TABLE_CLASS_NAME = "_batchTable"; var Wd = i8; function ZQ(e) { this._value = e.value, this._name = e.name, this._description = e.description, this._extras = e.extras, this._extensions = e.extensions } Object.defineProperties(ZQ.prototype, { value: { get: function () { return this._value } }, name: { get: function () { return this._name } }, description: { get: function () { return this._description } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); var dR = ZQ; function QQ(e) { e = y(e, y.EMPTY_OBJECT); let t = e.id, n = e.enum, i = {}, o = {}, r = n.values.map(function (a) { return i[a.value] = a.name, o[a.name] = a.value, new dR(a) }), s = y(wn[n.valueType], wn.UINT16); this._values = r, this._namesByValue = i, this._valuesByName = o, this._valueType = s, this._id = t, this._name = n.name, this._description = n.description, this._extras = n.extras, this._extensions = n.extensions } Object.defineProperties(QQ.prototype, { values: { get: function () { return this._values } }, namesByValue: { get: function () { return this._namesByValue } }, valuesByName: { get: function () { return this._valuesByName } }, valueType: { get: function () { return this._valueType } }, id: { get: function () { return this._id } }, name: { get: function () { return this._name } }, description: { get: function () { return this._description } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); var hR = QQ; function $Q(e) { let t = {}; if (l(e.enums)) for (let i in e.enums) e.enums.hasOwnProperty(i) && (t[i] = new hR({ id: i, enum: e.enums[i] })); let n = {}; if (l(e.classes)) for (let i in e.classes) e.classes.hasOwnProperty(i) && (n[i] = new Wd({ id: i, class: e.classes[i], enums: t })); this._classes = n, this._enums = t, this._id = e.id, this._name = e.name, this._description = e.description, this._version = e.version, this._extras = e.extras, this._extensions = e.extensions } Object.defineProperties($Q.prototype, { classes: { get: function () { return this._classes } }, enums: { get: function () { return this._enums } }, id: { get: function () { return this._id } }, name: { get: function () { return this._name } }, description: { get: function () { return this._description } }, version: { get: function () { return this._version } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); var jd = $Q; function k0(e) { e = y(e, y.EMPTY_OBJECT); let t = e.schema, n = e.resource, i = e.cacheKey; this._schema = l(t) ? new jd(t) : void 0, this._resource = n, this._cacheKey = i, this._state = kt.UNLOADED, this._promise = void 0 } l(Object.create) && (k0.prototype = Object.create(Zi.prototype), k0.prototype.constructor = k0); Object.defineProperties(k0.prototype, { promise: { get: function () { return this._promise } }, cacheKey: { get: function () { return this._cacheKey } }, schema: { get: function () { return this._schema } } }); k0.prototype.load = function () { return l(this._schema) ? this._promise = Promise.resolve(this) : this._promise = BBe(this), this._promise }; function BBe(e) { let t = e._resource; return e._state = kt.LOADING, t.fetchJson().then(function (n) { if (!e.isDestroyed()) return e._schema = new jd(n), e._state = kt.READY, e }).catch(function (n) { if (e.isDestroyed()) return; e._state = kt.FAILED; let i = `Failed to load schema: ${t.url}`; return Promise.reject(e.getError(i, n)) }) } k0.prototype.unload = function () { this._schema = void 0 }; var _S = k0; var xf = {}; function gS(e) { return vp(e.url) } function mR(e) { let t = e.byteOffset, n = e.byteLength; if (Mi(e, "EXT_meshopt_compression")) { let i = e.extensions.EXT_meshopt_compression; t = y(i.byteOffset, 0), n = i.byteLength } return `${t}-${t + n}` } function RBe(e, t) { let n = t.byteOffset + e.byteOffset, i = e.componentType, o = e.type, r = e.count; return `${n}-${i}-${o}-${r}` } function e$(e) { return gS(e) } function t$(e, t) { return `${gS(e)}-buffer-id-${t}` } function yS(e, t, n, i) { if (l(e.uri)) { let o = i.getDerivedResource({ url: e.uri }); return e$(o) } return t$(n, t) } function o8(e, t, n, i) { let o = t.bufferView, r = e.bufferViews[o], s = r.buffer, a = e.buffers[s], c = yS(a, s, n, i), u = mR(r); return `${c}-range-${u}` } function n$(e, t, n, i) { let o = e.images[t], r = o.bufferView, s = o.uri; if (l(s)) { let p = i.getDerivedResource({ url: s }); return gS(p) } let a = e.bufferViews[r], c = a.buffer, u = e.buffers[c], f = yS(u, c, n, i), d = mR(a); return `${f}-range-${d}` } function MBe(e, t) { let n = Al.createSampler({ gltf: e, textureInfo: t }); return `${n.wrapS}-${n.wrapT}-${n.minificationFilter}-${n.magnificationFilter}` } xf.getSchemaCacheKey = function (e) { let t = e.schema, n = e.resource; return l(t) ? `embedded-schema:${JSON.stringify(t)}` : `external-schema:${gS(n)}` }; xf.getExternalBufferCacheKey = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.resource; return `external-buffer:${e$(t)}` }; xf.getEmbeddedBufferCacheKey = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.parentResource, n = e.bufferId; return `embedded-buffer:${t$(t, n)}` }; xf.getGltfCacheKey = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltfResource; return `gltf:${gS(t)}` }; xf.getBufferViewCacheKey = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltf, n = e.bufferViewId, i = e.gltfResource, o = e.baseResource, r = t.bufferViews[n], s = r.buffer, a = t.buffers[s]; Mi(r, "EXT_meshopt_compression") && (s = r.extensions.EXT_meshopt_compression.buffer); let c = yS(a, s, i, o), u = mR(r); return `buffer-view:${c}-range-${u}` }; xf.getDracoCacheKey = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltf, n = e.draco, i = e.gltfResource, o = e.baseResource; return `draco:${o8(t, n, i, o)}` }; xf.getVertexBufferCacheKey = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltf, n = e.gltfResource, i = e.baseResource, o = e.frameState, r = e.bufferViewId, s = e.draco, a = e.attributeSemantic, c = y(e.dequantize, !1), u = y(e.loadBuffer, !1), f = y(e.loadTypedArray, !1), d = ""; if (c && (d += "-dequantize"), u && (d += "-buffer", d += `-context-${o.context.id}`), f && (d += "-typed-array"), l(s)) return `vertex-buffer:${o8(t, s, n, i)}-draco-${a}${d}`; let p = t.bufferViews[r], g = p.buffer, m = t.buffers[g], A = yS(m, g, n, i), C = mR(p); return `vertex-buffer:${A}-range-${C}${d}` }; xf.getIndexBufferCacheKey = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltf, n = e.accessorId, i = e.gltfResource, o = e.baseResource, r = e.frameState, s = e.draco, a = y(e.loadBuffer, !1), c = y(e.loadTypedArray, !1), u = ""; if (a && (u += "-buffer", u += `-context-${r.context.id}`), c && (u += "-typed-array"), l(s)) return `index-buffer:${o8(t, s, i, o)}-draco${u}`; let f = t.accessors[n], d = f.bufferView, p = t.bufferViews[d], g = p.buffer, m = t.buffers[g], A = yS(m, g, i, o), C = RBe(f, p); return `index-buffer:${A}-accessor-${C}${u}` }; xf.getImageCacheKey = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltf, n = e.imageId, i = e.gltfResource, o = e.baseResource; return `image:${n$(t, n, i, o)}` }; xf.getTextureCacheKey = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltf, n = e.textureInfo, i = e.gltfResource, o = e.baseResource, r = e.supportedImageFormats, s = e.frameState, a = n.index, c = Al.getImageIdFromTexture({ gltf: t, textureId: a, supportedImageFormats: r }), u = n$(t, c, i, o), f = MBe(t, n); return `texture:${u}-sampler-${f}-context-${s.context.id}` }; var Cl = xf; function AS() { this.geometryByteLength = 0, this.texturesByteLength = 0, this._geometrySizes = {}, this._textureSizes = {} } AS.prototype.clear = function () { this.geometryByteLength = 0, this.texturesByteLength = 0, this._geometrySizes = {}, this._textureSizes = {} }; AS.prototype.addGeometryLoader = function (e) { let t = e.cacheKey; if (this._geometrySizes.hasOwnProperty(t)) return; this._geometrySizes[t] = 0; let n = this; return e.promise.then(function (i) { if (!n._geometrySizes.hasOwnProperty(t)) return; let o = i.buffer, r = i.typedArray, s = 0; l(o) && (s += o.sizeInBytes), l(r) && (s += r.byteLength), n.geometryByteLength += s, n._geometrySizes[t] = s }).catch(function () { delete n._geometrySizes[t] }) }; AS.prototype.addTextureLoader = function (e) { let t = e.cacheKey; if (this._textureSizes.hasOwnProperty(t)) return; this._textureSizes[t] = 0; let n = this; return e.promise.then(function (i) { if (!n._textureSizes.hasOwnProperty(t)) return; let o = i.texture.sizeInBytes; n.texturesByteLength += i.texture.sizeInBytes, n._textureSizes[t] = o }).catch(function () { delete n._textureSizes[t] }) }; AS.prototype.removeLoader = function (e) { let t = e.cacheKey, n = this._geometrySizes[t]; delete this._geometrySizes[t], l(n) && (this.geometryByteLength -= n); let i = this._textureSizes[t]; delete this._textureSizes[t], l(i) && (this.texturesByteLength -= i) }; var pR = AS; function mn() { } mn.cacheEntries = {}; mn.statistics = new pR; function LBe(e) { this.referenceCount = 1, this.resourceLoader = e, this._statisticsPromise = void 0 } mn.get = function (e) { let t = mn.cacheEntries[e]; if (l(t)) return ++t.referenceCount, t.resourceLoader }; mn.load = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.resourceLoader, n = t.cacheKey; mn.cacheEntries[n] = new LBe(t), t.load() }; mn.unload = function (e) { let t = e.cacheKey, n = mn.cacheEntries[t]; --n.referenceCount, n.referenceCount === 0 && (mn.statistics.removeLoader(e), e.destroy(), delete mn.cacheEntries[t]) }; mn.loadSchema = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.schema, n = e.resource, i = Cl.getSchemaCacheKey({ schema: t, resource: n }), o = mn.get(i); return l(o) || (o = new _S({ schema: t, resource: n, cacheKey: i }), mn.load({ resourceLoader: o })), o }; mn.loadEmbeddedBuffer = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.parentResource, n = e.bufferId, i = e.typedArray, o = Cl.getEmbeddedBufferCacheKey({ parentResource: t, bufferId: n }), r = mn.get(o); return l(r) || (r = new GC({ typedArray: i, cacheKey: o }), mn.load({ resourceLoader: r })), r }; mn.loadExternalBuffer = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.resource, n = Cl.getExternalBufferCacheKey({ resource: t }), i = mn.get(n); return l(i) || (i = new GC({ resource: t, cacheKey: n }), mn.load({ resourceLoader: i })), i }; mn.loadGltfJson = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltfResource, n = e.baseResource, i = e.typedArray, o = e.gltfJson, r = Cl.getGltfCacheKey({ gltfResource: t }), s = mn.get(r); return l(s) || (s = new hS({ resourceCache: mn, gltfResource: t, baseResource: n, typedArray: i, gltfJson: o, cacheKey: r }), mn.load({ resourceLoader: s })), s }; mn.loadBufferView = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltf, n = e.bufferViewId, i = e.gltfResource, o = e.baseResource, r = Cl.getBufferViewCacheKey({ gltf: t, bufferViewId: n, gltfResource: i, baseResource: o }), s = mn.get(r); return l(s) || (s = new cS({ resourceCache: mn, gltf: t, bufferViewId: n, gltfResource: i, baseResource: o, cacheKey: r }), mn.load({ resourceLoader: s })), s }; mn.loadDraco = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltf, n = e.draco, i = e.gltfResource, o = e.baseResource, r = Cl.getDracoCacheKey({ gltf: t, draco: n, gltfResource: i, baseResource: o }), s = mn.get(r); return l(s) || (s = new lS({ resourceCache: mn, gltf: t, draco: n, gltfResource: i, baseResource: o, cacheKey: r }), mn.load({ resourceLoader: s })), s }; mn.loadVertexBuffer = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltf, n = e.gltfResource, i = e.baseResource, o = e.frameState, r = e.bufferViewId, s = e.draco, a = e.attributeSemantic, c = e.accessorId, u = y(e.asynchronous, !0), f = y(e.dequantize, !1), d = y(e.loadBuffer, !1), p = y(e.loadTypedArray, !1), g = Cl.getVertexBufferCacheKey({ gltf: t, gltfResource: n, baseResource: i, frameState: o, bufferViewId: r, draco: s, attributeSemantic: a, dequantize: f, loadBuffer: d, loadTypedArray: p }), m = mn.get(g); if (l(m)) return m; m = new pS({ resourceCache: mn, gltf: t, gltfResource: n, baseResource: i, bufferViewId: r, draco: s, attributeSemantic: a, accessorId: c, cacheKey: g, asynchronous: u, dequantize: f, loadBuffer: d, loadTypedArray: p }), mn.load({ resourceLoader: m }); let A = mn.statistics.addGeometryLoader(m); return mn.cacheEntries[g]._statisticsPromise = A, m }; mn.loadIndexBuffer = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltf, n = e.accessorId, i = e.gltfResource, o = e.baseResource, r = e.frameState, s = e.draco, a = y(e.asynchronous, !0), c = y(e.loadBuffer, !1), u = y(e.loadTypedArray, !1), f = Cl.getIndexBufferCacheKey({ gltf: t, accessorId: n, gltfResource: i, baseResource: o, frameState: r, draco: s, loadBuffer: c, loadTypedArray: u }), d = mn.get(f); if (l(d)) return d; d = new fS({ resourceCache: mn, gltf: t, accessorId: n, gltfResource: i, baseResource: o, draco: s, cacheKey: f, asynchronous: a, loadBuffer: c, loadTypedArray: u }), mn.load({ resourceLoader: d }); let p = mn.statistics.addGeometryLoader(d); return mn.cacheEntries[f]._statisticsPromise = p, d }; mn.loadImage = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltf, n = e.imageId, i = e.gltfResource, o = e.baseResource, r = Cl.getImageCacheKey({ gltf: t, imageId: n, gltfResource: i, baseResource: o }), s = mn.get(r); return l(s) || (s = new uS({ resourceCache: mn, gltf: t, imageId: n, gltfResource: i, baseResource: o, cacheKey: r }), mn.load({ resourceLoader: s })), s }; mn.loadTexture = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltf, n = e.textureInfo, i = e.gltfResource, o = e.baseResource, r = e.supportedImageFormats, s = e.frameState, a = y(e.asynchronous, !0), c = Cl.getTextureCacheKey({ gltf: t, textureInfo: n, gltfResource: i, baseResource: o, supportedImageFormats: r, frameState: s }), u = mn.get(c); if (l(u)) return u; u = new mS({ resourceCache: mn, gltf: t, textureInfo: n, gltfResource: i, baseResource: o, supportedImageFormats: r, cacheKey: c, asynchronous: a }), mn.load({ resourceLoader: u }); let f = mn.statistics.addTextureLoader(u); return mn.cacheEntries[c]._statisticsPromise = f, u }; mn.clearForSpecs = function () { let e = [pS, fS, lS, mS, uS, cS, GC, _S, hS], t, n = mn.cacheEntries, i = []; for (t in n) n.hasOwnProperty(t) && i.push(n[t]); i.sort(function (r, s) { let a = e.indexOf(r.resourceLoader.constructor), c = e.indexOf(s.resourceLoader.constructor); return a - c }); let o = i.length; for (let r = 0; r < o; ++r) { let s = i[r]; t = s.resourceLoader.cacheKey, l(n[t]) && (s.resourceLoader.destroy(), delete n[t]) } mn.statistics.clear() }; var ao = mn; function xa(e, t, n, i, o) { this._resource = e, this._subtreeJson = void 0, this._bufferLoader = void 0, this._tileAvailability = void 0, this._contentAvailabilityBitstreams = [], this._childSubtreeAvailability = void 0, this._implicitCoordinates = o, this._subtreeLevels = i.subtreeLevels, this._subdivisionScheme = i.subdivisionScheme, this._branchingFactor = i.branchingFactor, this._metadata = void 0, this._tileMetadataTable = void 0, this._tilePropertyTableJson = void 0, this._contentMetadataTables = [], this._contentPropertyTableJsons = [], this._tileJumpBuffer = void 0, this._contentJumpBuffers = [], this._readyPromise = FBe(this, t, n, i) } Object.defineProperties(xa.prototype, { readyPromise: { get: function () { return this._readyPromise } }, metadata: { get: function () { return this._metadata } }, tileMetadataTable: { get: function () { return this._tileMetadataTable } }, tilePropertyTableJson: { get: function () { return this._tilePropertyTableJson } }, contentMetadataTables: { get: function () { return this._contentMetadataTables } }, contentPropertyTableJsons: { get: function () { return this._contentPropertyTableJsons } }, implicitCoordinates: { get: function () { return this._implicitCoordinates } } }); xa.prototype.tileIsAvailableAtIndex = function (e) { return this._tileAvailability.getBit(e) }; xa.prototype.tileIsAvailableAtCoordinates = function (e) { let t = this.getTileIndex(e); return this.tileIsAvailableAtIndex(t) }; xa.prototype.contentIsAvailableAtIndex = function (e, t) { return t = y(t, 0), this._contentAvailabilityBitstreams[t].getBit(e) }; xa.prototype.contentIsAvailableAtCoordinates = function (e, t) { let n = this.getTileIndex(e); return this.contentIsAvailableAtIndex(n, t) }; xa.prototype.childSubtreeIsAvailableAtIndex = function (e) { return this._childSubtreeAvailability.getBit(e) }; xa.prototype.childSubtreeIsAvailableAtCoordinates = function (e) { let t = this.getChildSubtreeIndex(e); return this.childSubtreeIsAvailableAtIndex(t) }; xa.prototype.getLevelOffset = function (e) { let t = this._branchingFactor; return (Math.pow(t, e) - 1) / (t - 1) }; xa.prototype.getParentMortonIndex = function (e) { let t = 2; return this._subdivisionScheme === kr.OCTREE && (t = 3), e >> t }; function FBe(e, t, n, i) { let o; l(t) ? o = { json: t, binary: void 0 } : o = NBe(n); let r = o.json; e._subtreeJson = r; let s; if (Mi(r, "3DTILES_metadata")) s = r.extensions["3DTILES_metadata"]; else if (l(r.tileMetadata)) { let m = r.tileMetadata; s = r.propertyTables[m] } let a = []; if (l(r.contentMetadata)) { let m = r.contentMetadata.length; for (let A = 0; A < m; A++) { let C = r.contentMetadata[A]; a.push(r.propertyTables[C]) } } let c, u = i.metadataSchema, f = r.subtreeMetadata; if (l(f)) { let m = f.class, A = u.classes[m]; c = new WB({ subtreeMetadata: f, class: A }) } e._metadata = c, e._tilePropertyTableJson = s, e._contentPropertyTableJsons = a; let d = { constant: 0 }; r.contentAvailabilityHeaders = [], Mi(r, "3DTILES_multiple_contents") ? r.contentAvailabilityHeaders = r.extensions["3DTILES_multiple_contents"].contentAvailability : Array.isArray(r.contentAvailability) ? r.contentAvailabilityHeaders = r.contentAvailability : r.contentAvailabilityHeaders.push(y(r.contentAvailability, d)); let p = VBe(r.buffers), g = kBe(r.bufferViews, p); UBe(r, g), l(s) && i$(s, g); for (let m = 0; m < a.length; m++) { let A = a[m]; i$(A, g) } return zBe(e, p, o.binary).then(function (m) { let A = GBe(g, m); return WBe(e, r, i, A), l(s) && (jBe(e, i, A), YBe(e)), qBe(e, i, A), XBe(e), e }) } function NBe(e) { let n = new DataView(e.buffer, e.byteOffset), i = 8, o = n.getUint32(i, !0); i += 8; let r = n.getUint32(i, !0); i += 8; let s = Ko(e, i, o); i += o; let a = e.subarray(i, i + r); return { json: s, binary: a } } function VBe(e) { e = l(e) ? e : []; for (let t = 0; t < e.length; t++) { let n = e[t]; n.isExternal = l(n.uri), n.isActive = !1 } return e } function kBe(e, t) { e = l(e) ? e : []; for (let n = 0; n < e.length; n++) { let i = e[n], o = t[i.buffer]; i.bufferHeader = o, i.isActive = !1 } return e } function UBe(e, t) { let n, i = e.tileAvailability; l(i.bitstream) ? n = t[i.bitstream] : l(i.bufferView) && (n = t[i.bufferView]), l(n) && (n.isActive = !0, n.bufferHeader.isActive = !0); let o = e.contentAvailabilityHeaders; for (let s = 0; s < o.length; s++)n = void 0, l(o[s].bitstream) ? n = t[o[s].bitstream] : l(o[s].bufferView) && (n = t[o[s].bufferView]), l(n) && (n.isActive = !0, n.bufferHeader.isActive = !0); n = void 0; let r = e.childSubtreeAvailability; l(r.bitstream) ? n = t[r.bitstream] : l(r.bufferView) && (n = t[r.bufferView]), l(n) && (n.isActive = !0, n.bufferHeader.isActive = !0) } function i$(e, t) { let n = e.properties, i; for (let o in n) if (n.hasOwnProperty(o)) { let r = n[o], s = y(r.values, r.bufferView); i = t[s], i.isActive = !0, i.bufferHeader.isActive = !0; let a = y(r.stringOffsets, r.stringOffsetBufferView); l(a) && (i = t[a], i.isActive = !0, i.bufferHeader.isActive = !0); let c = y(r.arrayOffsets, r.arrayOffsetBufferView); l(c) && (i = t[c], i.isActive = !0, i.bufferHeader.isActive = !0) } } function zBe(e, t, n) { let i = []; for (let o = 0; o < t.length; o++) { let r = t[o]; if (!r.isActive) i.push(Promise.resolve(void 0)); else if (r.isExternal) { let s = HBe(e, r); i.push(s) } else i.push(Promise.resolve(n)) } return Promise.all(i).then(function (o) { let r = {}; for (let s = 0; s < o.length; s++) { let a = o[s]; l(a) && (r[s] = a) } return r }) } function HBe(e, t) { let i = e._resource.getDerivedResource({ url: t.uri }), o = ao.loadExternalBuffer({ resource: i }); return e._bufferLoader = o, o.promise.then(function (r) { return r.typedArray }) } function GBe(e, t) { let n = {}; for (let i = 0; i < e.length; i++) { let o = e[i]; if (!o.isActive) continue; let r = o.byteOffset, s = r + o.byteLength, c = t[o.buffer].subarray(r, s); n[i] = c } return n } function WBe(e, t, n, i) { let o = n.branchingFactor, r = n.subtreeLevels, s = (Math.pow(o, r) - 1) / (o - 1), a = Math.pow(o, r), c = Mi(t, "3DTILES_metadata"), u = l(e._tilePropertyTableJson), f = c || u; e._tileAvailability = r8(t.tileAvailability, i, s, f); let d = e._contentPropertyTableJsons.length > 0; f = f || d; for (let p = 0; p < t.contentAvailabilityHeaders.length; p++) { let g = r8(t.contentAvailabilityHeaders[p], i, s, f); e._contentAvailabilityBitstreams.push(g) } e._childSubtreeAvailability = r8(t.childSubtreeAvailability, i, a) } function r8(e, t, n, i) { if (l(e.constant)) return new rS({ constant: Boolean(e.constant), lengthBits: n, availableCount: e.availableCount }); let o; return l(e.bitstream) ? o = t[e.bitstream] : l(e.bufferView) && (o = t[e.bufferView]), new rS({ bitstream: o, lengthBits: n, availableCount: e.availableCount, computeAvailableCountEnabled: i }) } function jBe(e, t, n) { let i = e._tilePropertyTableJson, o = e._tileAvailability.availableCount, r = t.metadataSchema, s = i.class, a = r.classes[s]; e._tileMetadataTable = new Af({ class: a, count: o, properties: i.properties, bufferViews: n }) } function qBe(e, t, n) { let i = e._contentPropertyTableJsons, o = e._contentAvailabilityBitstreams, r = t.metadataSchema, s = e._contentMetadataTables; for (let a = 0; a < i.length; a++) { let c = i[a], f = o[a].availableCount, d = c.class, p = r.classes[d], g = new Af({ class: p, count: f, properties: c.properties, bufferViews: n }); s.push(g) } } function o$(e) { let t = 0, n = e.lengthBits, i = e.availableCount, o; i < 256 ? o = new Uint8Array(n) : i < 65536 ? o = new Uint16Array(n) : o = new Uint32Array(n); for (let r = 0; r < e.lengthBits; r++)e.getBit(r) && (o[r] = t, t++); return o } function YBe(e) { let t = o$(e._tileAvailability); e._tileJumpBuffer = t } function XBe(e) { let t = e._contentJumpBuffers, n = e._contentAvailabilityBitstreams; for (let i = 0; i < n.length; i++) { let o = n[i], r = o$(o); t.push(r) } } xa.prototype.getTileIndex = function (e) { let t = e.level - this._implicitCoordinates.level; if (t < 0 || this._subtreeLevels <= t) throw new fe("level is out of bounds for this subtree"); return e.getSubtreeCoordinates().getOffsetCoordinates(e).tileIndex }; xa.prototype.getChildSubtreeIndex = function (e) { if (e.level - this._implicitCoordinates.level !== this._implicitCoordinates.subtreeLevels) throw new fe("level is out of bounds for this subtree"); return e.getParentSubtreeCoordinates().getOffsetCoordinates(e).mortonIndex }; function KBe(e, t) { if (!l(e._tileMetadataTable)) return; let n = e.getTileIndex(t); if (e._tileAvailability.getBit(n)) return e._tileJumpBuffer[n] } function JBe(e, t, n) { let i = e._contentMetadataTables; if (!l(i)) return; let o = i[n]; if (!l(o)) return; let r = e._contentAvailabilityBitstreams[n], s = e.getTileIndex(t); if (r.getBit(s)) return e._contentJumpBuffers[n][s] } xa.prototype.getTileMetadataView = function (e) { let t = KBe(this, e); if (!l(t)) return; let n = this._tileMetadataTable; return new sS({ class: n.class, metadataTable: n, entityId: t, propertyTableJson: this._tilePropertyTableJson }) }; xa.prototype.getContentMetadataView = function (e, t) { let n = JBe(this, e, t); if (!l(n)) return; let i = this._contentMetadataTables[t], o = this._contentPropertyTableJsons[t]; return new sS({ class: i.class, metadataTable: i, entityId: n, contentIndex: t, propertyTableJson: o }) }; xa.prototype.isDestroyed = function () { return !1 }; xa.prototype.destroy = function () { return l(this._bufferLoader) && ao.unload(this._bufferLoader), le(this) }; var _R = xa; var ZBe = { ID: "ID", NAME: "NAME", DESCRIPTION: "DESCRIPTION", TILE_BOUNDING_BOX: "TILE_BOUNDING_BOX", TILE_BOUNDING_REGION: "TILE_BOUNDING_REGION", TILE_BOUNDING_SPHERE: "TILE_BOUNDING_SPHERE", TILE_MINIMUM_HEIGHT: "TILE_MINIMUM_HEIGHT", TILE_MAXIMUM_HEIGHT: "TILE_MAXIMUM_HEIGHT", TILE_HORIZON_OCCLUSION_POINT: "TILE_HORIZON_OCCLUSION_POINT", TILE_GEOMETRIC_ERROR: "TILE_GEOMETRIC_ERROR", CONTENT_BOUNDING_BOX: "CONTENT_BOUNDING_BOX", CONTENT_BOUNDING_REGION: "CONTENT_BOUNDING_REGION", CONTENT_BOUNDING_SPHERE: "CONTENT_BOUNDING_SPHERE", CONTENT_MINIMUM_HEIGHT: "CONTENT_MINIMUM_HEIGHT", CONTENT_MAXIMUM_HEIGHT: "CONTENT_MAXIMUM_HEIGHT", CONTENT_HORIZON_OCCLUSION_POINT: "CONTENT_HORIZON_OCCLUSION_POINT" }, gR = Object.freeze(ZBe); function QBe(e) { return { tile: { boundingVolume: r$("TILE", e), minimumHeight: s$("TILE", e), maximumHeight: a$("TILE", e) }, content: { boundingVolume: r$("CONTENT", e), minimumHeight: s$("CONTENT", e), maximumHeight: a$("CONTENT", e) } } } function r$(e, t) { let n = `${e}_BOUNDING_BOX`, i = t.getPropertyBySemantic(n); if (l(i)) return { box: i }; let o = `${e}_BOUNDING_REGION`, r = t.getPropertyBySemantic(o); if (l(r)) return { region: r }; let s = `${e}_BOUNDING_SPHERE`, a = t.getPropertyBySemantic(s); if (l(a)) return { sphere: a } } function s$(e, t) { let n = `${e}_MINIMUM_HEIGHT`; return t.getPropertyBySemantic(n) } function a$(e, t) { let n = `${e}_MAXIMUM_HEIGHT`; return t.getPropertyBySemantic(n) } var yR = QBe; function fu(e, t, n, i, o, r) { let s = t.implicitTileset, a = t.implicitCoordinates; this._implicitTileset = s, this._implicitCoordinates = a, this._implicitSubtree = void 0, this._tileset = e, this._tile = t, this._resource = n, this._metadata = void 0, this.featurePropertiesDirty = !1, this._group = void 0; let c = a.getTemplateValues(), u = s.subtreeUriTemplate.getDerivedResource({ templateValues: c }); this._url = u.getUrlComponent(!0), this._readyPromise = $Be(this, i, o, r) } Object.defineProperties(fu.prototype, { featuresLength: { get: function () { return 0 } }, pointsLength: { get: function () { return 0 } }, trianglesLength: { get: function () { return 0 } }, geometryByteLength: { get: function () { return 0 } }, texturesByteLength: { get: function () { return 0 } }, batchTableByteLength: { get: function () { return 0 } }, innerContents: { get: function () { } }, readyPromise: { get: function () { return this._readyPromise } }, tileset: { get: function () { return this._tileset } }, tile: { get: function () { return this._tile } }, url: { get: function () { return this._url } }, metadata: { get: function () { }, set: function () { } }, batchTable: { get: function () { } }, group: { get: function () { return this._group }, set: function (e) { this._group = e } } }); function $Be(e, t, n, i) { i = y(i, 0); let o; l(n) && (o = new Uint8Array(n, i)); let r = new _R(e._resource, t, o, e._implicitTileset, e._implicitCoordinates); return e._implicitSubtree = r, r.readyPromise.then(function () { return eRe(e, r), e }) } function eRe(e, t) { let n = e._tile, i = e._implicitCoordinates.childIndex, o = nRe(e, t, n, i), r = e._tileset.statistics; n.children.push(o.rootTile), r.numberOfTilesTotal++; let s = tRe(e, t, o.bottomRow); for (let a = 0; a < s.length; a++) { let c = s[a], u = c.tile, f = fRe(e, u, c.childIndex); u.children.push(f), r.numberOfTilesTotal++ } } function tRe(e, t, n) { let i = [], o = e._implicitTileset.branchingFactor; for (let r = 0; r < n.length; r++) { let s = n[r]; if (!!l(s)) for (let a = 0; a < o; a++) { let c = r * o + a; t.childSubtreeIsAvailableAtIndex(c) && i.push({ tile: s, childIndex: a }) } } return i } function nRe(e, t, n, i) { let s = c$(e, t, n, i, 0, !0), a = e._tileset.statistics, c = [s], u = [], f = e._implicitTileset; for (let d = 1; d < f.subtreeLevels; d++) { let p = t.getLevelOffset(d), g = f.branchingFactor * c.length; for (let m = 0; m < g; m++) { let A = p + m; if (!t.tileIsAvailableAtIndex(A)) { u.push(void 0); continue } let C = t.getParentMortonIndex(m), x = c[C], T = m % f.branchingFactor, b = c$(e, t, x, T, A); x.children.push(b), a.numberOfTilesTotal++, u.push(b) } c = u, u = [] } return { rootTile: s, bottomRow: c } } function l$(e, t, n) { let i = gR.TILE_GEOMETRIC_ERROR; return l(e) && e.hasPropertyBySemantic(i) ? e.getPropertyBySemantic(i) : t.geometricError / Math.pow(2, n.level) } function c$(e, t, n, i, o, r) { let s = e._implicitTileset, a; y(r, !1) ? a = n.implicitCoordinates : a = n.implicitCoordinates.getChildCoordinates(i); let c, u, f; if (l(t.tilePropertyTableJson)) { c = t.getTileMetadataView(a); let P = yR(c); u = P.tile, f = P.content } let p = t.contentPropertyTableJsons.length, g = !1; for (let P = 0; P < p; P++)if (t.contentIsAvailableAtCoordinates(a, P)) { g = !0; break } let m = rRe(s, a, i, r, n, u), A = []; for (let P = 0; P < s.contentCount; P++) { if (!t.contentIsAvailableAtIndex(o, P)) continue; let M = { uri: s.contentUriTemplates[P].getDerivedResource({ templateValues: a.getTemplateValues() }).url }, L = sRe(m, f); l(L) && (M.boundingVolume = L), A.push(yt(M, s.contentHeaders[P])) } let C = l$(c, s, a), x = { boundingVolume: m, geometricError: C, refine: s.refine, contents: A }, T = !0, b = tt(s.tileHeader, T); delete b.boundingVolume, delete b.transform; let S = yt(x, b, T), D = m$(e, s.baseResource, S, n); return D.implicitCoordinates = a, D.implicitSubtree = t, D.metadata = c, D.hasImplicitContentMetadata = g, D } function AR(e, t) { return l(e) && l(t) && (l(t.minimumHeight) || l(t.maximumHeight)) && (Mi(e, "3DTILES_bounding_volume_S2") || l(e.region)) } function a8(e, t) { !l(t) || (Mi(e, "3DTILES_bounding_volume_S2") ? oRe(e.extensions["3DTILES_bounding_volume_S2"], t.minimumHeight, t.maximumHeight) : l(e.region) && iRe(e.region, t.minimumHeight, t.maximumHeight)) } function iRe(e, t, n) { l(t) && (e[4] = t), l(n) && (e[5] = n) } function oRe(e, t, n) { l(t) && (e.minimumHeight = t), l(n) && (e.maximumHeight = n) } function rRe(e, t, n, i, o, r) { let s; return !l(r) || !l(r.boundingVolume) || !AR(r.boundingVolume, r) && AR(e.boundingVolume, r) ? s = u$(e, t, n, y(i, !1), o) : s = r.boundingVolume, a8(s, r), s } function sRe(e, t) { let n; return l(t) && (n = t.boundingVolume), AR(n, t) ? a8(n, t) : AR(e, t) && (n = tt(e, !0), a8(n, t)), n } function u$(e, t, n, i, o) { let r = e.boundingVolume; return Mi(r, "3DTILES_bounding_volume_S2") ? f$(i, o, n, t.level, t.x, t.y, t.z) : l(r.region) ? { region: h$(r.region, t.level, t.x, t.y, t.z) } : { box: d$(r.box, t.level, t.x, t.y, t.z) } } function f$(e, t, n, i, o, r, s) { let a = t._boundingVolume; if (e) return { extensions: { "3DTILES_bounding_volume_S2": { token: e_.getTokenFromId(a.s2Cell._cellId), minimumHeight: a.minimumHeight, maximumHeight: a.maximumHeight } } }; let c = Number(t._boundingVolume.s2Cell._cellId >> BigInt(61)), u = c % 2 === 0 ? oS.encode2D(i, o, r) : oS.encode2D(i, r, o), f = e_.fromFacePositionLevel(c, BigInt(u), i), d, p; if (l(s)) { let g = (a.maximumHeight + a.minimumHeight) / 2; d = n < 4 ? a.minimumHeight : g, p = n < 4 ? g : a.maximumHeight } else d = a.minimumHeight, p = a.maximumHeight; return { extensions: { "3DTILES_bounding_volume_S2": { token: e_.getTokenFromId(f._cellId), minimumHeight: d, maximumHeight: p } } } } var aRe = new h, cRe = new h, s8 = new h, lRe = new Q; function d$(e, t, n, i, o) { if (t === 0) return e; let r = h.unpack(e, 0, cRe), s = Q.unpack(e, 3, lRe), a = Math.pow(2, -t), c = -1 + (2 * n + 1) * a, u = -1 + (2 * i + 1) * a, f = 0, d = h.fromElements(a, a, 1, aRe); l(o) && (f = -1 + (2 * o + 1) * a, d.z = a); let p = h.fromElements(c, u, f, s8); p = Q.multiplyByVector(s, p, s8), p = h.add(p, r, s8); let g = Q.clone(s); g = Q.multiplyByScale(g, d, g); let m = new Array(12); return h.pack(p, m), Q.pack(g, m, 3), m } var uRe = new ce; function h$(e, t, n, i, o) { if (t === 0) return e.slice(); let r = ce.unpack(e, 0, uRe), s = e[4], a = e[5], c = Math.pow(2, -t), u = c * r.width, f = I.negativePiToPi(r.west + n * u), d = I.negativePiToPi(f + u), p = c * r.height, g = I.negativePiToPi(r.south + i * p), m = I.negativePiToPi(g + p), A = s, C = a; if (l(o)) { let x = c * (a - s); A += o * x, C = A + x } return [f, g, d, m, A, C] } function fRe(e, t, n) { let i = e._implicitTileset, o = t.implicitCoordinates.getChildCoordinates(n), r = u$(i, o, n, !1, t), s = l$(void 0, i, o), a = i.subtreeUriTemplate.getDerivedResource({ templateValues: o.getTemplateValues() }).url, c = { boundingVolume: r, geometricError: s, refine: i.refine, contents: [{ uri: a }] }, u = m$(e, i.baseResource, c, t); return u.implicitTileset = i, u.implicitCoordinates = o, u } function m$(e, t, n, i) { let o = e._tile.constructor; return new o(e._tileset, t, n, i) } fu.prototype.hasProperty = function (e, t) { return !1 }; fu.prototype.getFeature = function (e) { }; fu.prototype.applyDebugSettings = function (e, t) { }; fu.prototype.applyStyle = function (e) { }; fu.prototype.update = function (e, t) { }; fu.prototype.isDestroyed = function () { return !1 }; fu.prototype.destroy = function () { return this._implicitSubtree = this._implicitSubtree && this._implicitSubtree.destroy(), le(this) }; fu._deriveBoundingBox = d$; fu._deriveBoundingRegion = h$; fu._deriveBoundingVolumeS2 = f$; var CS = fu; var dRe = { NONE: 0, REPEAT: 1, MIRRORED_REPEAT: 2 }, ic = Object.freeze(dRe); function XC(e, t) { this._distance = t, this._normal = new p$(e, this), this.onChangeCallback = void 0, this.index = -1 } Object.defineProperties(XC.prototype, { distance: { get: function () { return this._distance }, set: function (e) { l(this.onChangeCallback) && e !== this._distance && this.onChangeCallback(this.index), this._distance = e } }, normal: { get: function () { return this._normal }, set: function (e) { l(this.onChangeCallback) && !h.equals(this._normal._cartesian3, e) && this.onChangeCallback(this.index), h.clone(e, this._normal._cartesian3) } } }); XC.fromPlane = function (e, t) { return l(t) ? (t.normal = e.normal, t.distance = e.distance) : t = new XC(e.normal, e.distance), t }; XC.clone = function (e, t) { return l(t) ? (t.normal = e.normal, t.distance = e.distance, t) : new XC(e.normal, e.distance) }; function p$(e, t) { this._clippingPlane = t, this._cartesian3 = h.clone(e) } Object.defineProperties(p$.prototype, { x: { get: function () { return this._cartesian3.x }, set: function (e) { l(this._clippingPlane.onChangeCallback) && e !== this._cartesian3.x && this._clippingPlane.onChangeCallback(this._clippingPlane.index), this._cartesian3.x = e } }, y: { get: function () { return this._cartesian3.y }, set: function (e) { l(this._clippingPlane.onChangeCallback) && e !== this._cartesian3.y && this._clippingPlane.onChangeCallback(this._clippingPlane.index), this._cartesian3.y = e } }, z: { get: function () { return this._cartesian3.z }, set: function (e) { l(this._clippingPlane.onChangeCallback) && e !== this._cartesian3.z && this._clippingPlane.onChangeCallback(this._clippingPlane.index), this._cartesian3.z = e } } }); var KC = XC; function Ta(e) { e = y(e, y.EMPTY_OBJECT), this._planes = [], this._dirtyIndex = -1, this._multipleDirtyPlanes = !1, this._enabled = y(e.enabled, !0), this.modelMatrix = F.clone(y(e.modelMatrix, F.IDENTITY)), this.edgeColor = U.clone(y(e.edgeColor, U.WHITE)), this.edgeWidth = y(e.edgeWidth, 0), this.planeAdded = new _e, this.planeRemoved = new _e, this._owner = void 0; let t = y(e.unionClippingRegions, !1); this._unionClippingRegions = t, this._testIntersection = t ? C$ : x$, this._uint8View = void 0, this._float32View = void 0, this._clippingPlanesTexture = void 0; let n = e.planes; if (l(n)) { let i = n.length; for (let o = 0; o < i; ++o)this.add(n[o]) } } function C$(e) { return e === Kt.OUTSIDE } function x$(e) { return e === Kt.INSIDE } Object.defineProperties(Ta.prototype, { length: { get: function () { return this._planes.length } }, unionClippingRegions: { get: function () { return this._unionClippingRegions }, set: function (e) { this._unionClippingRegions !== e && (this._unionClippingRegions = e, this._testIntersection = e ? C$ : x$) } }, enabled: { get: function () { return this._enabled }, set: function (e) { this._enabled !== e && (this._enabled = e) } }, texture: { get: function () { return this._clippingPlanesTexture } }, owner: { get: function () { return this._owner } }, clippingPlanesState: { get: function () { return this._unionClippingRegions ? this._planes.length : -this._planes.length } } }); function _$(e, t) { e._multipleDirtyPlanes = e._multipleDirtyPlanes || e._dirtyIndex !== -1 && e._dirtyIndex !== t, e._dirtyIndex = t } Ta.prototype.add = function (e) { let t = this._planes.length, n = this; e.onChangeCallback = function (i) { _$(n, i) }, e.index = t, _$(this, t), this._planes.push(e), this.planeAdded.raiseEvent(e, t) }; Ta.prototype.get = function (e) { return this._planes[e] }; function T$(e, t) { let n = e.length; for (let i = 0; i < n; ++i)if (nn.equals(e[i], t)) return i; return -1 } Ta.prototype.contains = function (e) { return T$(this._planes, e) !== -1 }; Ta.prototype.remove = function (e) { let t = this._planes, n = T$(t, e); if (n === -1) return !1; e instanceof KC && (e.onChangeCallback = void 0, e.index = -1); let i = t.length - 1; for (let o = n; o < i; ++o) { let r = t[o + 1]; t[o] = r, r instanceof KC && (r.index = o) } return this._multipleDirtyPlanes = !0, t.length = i, this.planeRemoved.raiseEvent(e, n), !0 }; Ta.prototype.removeAll = function () { let e = this._planes, t = e.length; for (let n = 0; n < t; ++n) { let i = e[n]; i instanceof KC && (i.onChangeCallback = void 0, i.index = -1), this.planeRemoved.raiseEvent(i, n) } this._multipleDirtyPlanes = !0, this._planes = [] }; var hRe = new se, mRe = new se; function g$(e, t, n) { let i = e._uint8View, o = e._planes, r = 0; for (let s = t; s < n; ++s) { let a = o[s], c = kn.octEncodeToCartesian4(a.normal, mRe); i[r] = c.x, i[r + 1] = c.y, i[r + 2] = c.z, i[r + 3] = c.w; let u = se.packFloat(a.distance, hRe); i[r + 4] = u.x, i[r + 5] = u.y, i[r + 6] = u.z, i[r + 7] = u.w, r += 8 } } function y$(e, t, n) { let i = e._float32View, o = e._planes, r = 0; for (let s = t; s < n; ++s) { let a = o[s], c = a.normal; i[r] = c.x, i[r + 1] = c.y, i[r + 2] = c.z, i[r + 3] = a.distance, r += 4 } } function E$(e, t) { let n = Ut.maximumTextureSize; return t.x = Math.min(e, n), t.y = Math.ceil(e / t.x), t } var pRe = new H; Ta.prototype.update = function (e) { let t = this._clippingPlanesTexture, n = e.context, i = Ta.useFloatTexture(n), o = i ? this.length : this.length * 2; if (l(t)) { let s = t.width * t.height; (s < o || o < .25 * s) && (t.destroy(), t = void 0, this._clippingPlanesTexture = void 0) } if (this.length === 0) return; if (!l(t)) { let s = E$(o, pRe); s.y *= 2, i ? (t = new Rt({ context: n, width: s.x, height: s.y, pixelFormat: ht.RGBA, pixelDatatype: Ye.FLOAT, sampler: dn.NEAREST, flipY: !1 }), this._float32View = new Float32Array(s.x * s.y * 4)) : (t = new Rt({ context: n, width: s.x, height: s.y, pixelFormat: ht.RGBA, pixelDatatype: Ye.UNSIGNED_BYTE, sampler: dn.NEAREST, flipY: !1 }), this._uint8View = new Uint8Array(s.x * s.y * 4)), this._clippingPlanesTexture = t, this._multipleDirtyPlanes = !0 } let r = this._dirtyIndex; if (!(!this._multipleDirtyPlanes && r === -1)) { if (this._multipleDirtyPlanes) i ? (y$(this, 0, this._planes.length), t.copyFrom({ source: { width: t.width, height: t.height, arrayBufferView: this._float32View } })) : (g$(this, 0, this._planes.length), t.copyFrom({ source: { width: t.width, height: t.height, arrayBufferView: this._uint8View } })); else { let s = 0, a = 0; i ? (a = Math.floor(r / t.width), s = Math.floor(r - a * t.width), y$(this, r, r + 1), t.copyFrom({ source: { width: 1, height: 1, arrayBufferView: this._float32View }, xOffset: s, yOffset: a })) : (a = Math.floor(r * 2 / t.width), s = Math.floor(r * 2 - a * t.width), g$(this, r, r + 1), t.copyFrom({ source: { width: 2, height: 1, arrayBufferView: this._uint8View }, xOffset: s, yOffset: a })) } this._multipleDirtyPlanes = !1, this._dirtyIndex = -1 } }; var _Re = new F, A$ = new nn(h.UNIT_X, 0); Ta.prototype.computeIntersectionWithBoundingVolume = function (e, t) { let n = this._planes, i = n.length, o = this.modelMatrix; l(t) && (o = F.multiply(t, o, _Re)); let r = Kt.INSIDE; !this.unionClippingRegions && i > 0 && (r = Kt.OUTSIDE); for (let s = 0; s < i; ++s) { let a = n[s]; nn.transform(a, o, A$); let c = e.intersectPlane(A$); if (c === Kt.INTERSECTING) r = c; else if (this._testIntersection(c)) return c } return r }; Ta.setOwner = function (e, t, n) { e !== t[n] && (t[n] = t[n] && t[n].destroy(), l(e) && (e._owner = t, t[n] = e)) }; Ta.useFloatTexture = function (e) { return e.floatingPointTexture }; Ta.getTextureResolution = function (e, t, n) { let i = e.texture; if (l(i)) return n.x = i.width, n.y = i.height, n; let o = Ta.useFloatTexture(t) ? e.length : e.length * 2, r = E$(o, n); return r.y *= 2, r }; Ta.prototype.isDestroyed = function () { return !1 }; Ta.prototype.destroy = function () { return this._clippingPlanesTexture = this._clippingPlanesTexture && this._clippingPlanesTexture.destroy(), le(this) }; var Ks = Ta; var xS = { HIGHLIGHT: 0, REPLACE: 1, MIX: 2 }; xS.getColorBlend = function (e, t) { if (e === xS.HIGHLIGHT) return 0; if (e === xS.REPLACE) return 1; if (e === xS.MIX) return I.clamp(t, I.EPSILON4, 1) }; var oc = Object.freeze(xS); var gRe = { XTRANSLATE: "xTranslate", YTRANSLATE: "yTranslate", ZTRANSLATE: "zTranslate", XROTATE: "xRotate", YROTATE: "yRotate", ZROTATE: "zRotate", XSCALE: "xScale", YSCALE: "yScale", ZSCALE: "zScale", UNIFORMSCALE: "uniformScale" }, rc = Object.freeze(gRe); var yRe = { STEP: 0, LINEAR: 1, CUBICSPLINE: 2 }, qd = Object.freeze(yRe); var b$ = {}; function TS(e) { this._count = e.count, this._properties = tt(e.properties, !0) } TS.prototype.hasProperty = function (e) { return Rn.hasProperty(e, this._properties, b$) }; TS.prototype.getPropertyIds = function (e) { return Rn.getPropertyIds(this._properties, b$, e) }; TS.prototype.getProperty = function (e, t) { let n = this._properties[t]; if (l(n)) return tt(n[e], !0) }; TS.prototype.setProperty = function (e, t, n) { let i = this._properties[t]; l(i) || (i = new Array(this._count), this._properties[t] = i), i[e] = tt(n, !0) }; var f_ = TS; function Ea(e) { e = y(e, y.EMPTY_OBJECT), this._name = e.name, this._id = e.id, this._count = e.count, this._extras = e.extras, this._extensions = e.extensions, this._metadataTable = e.metadataTable, this._jsonMetadataTable = e.jsonMetadataTable, this._batchTableHierarchy = e.batchTableHierarchy } Object.defineProperties(Ea.prototype, { name: { get: function () { return this._name } }, id: { get: function () { return this._id } }, count: { get: function () { return this._count } }, class: { get: function () { if (l(this._metadataTable)) return this._metadataTable.class } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } }, byteLength: { get: function () { let e = 0; return l(this._metadataTable) && (e += this._metadataTable.byteLength), l(this._batchTableHierarchy) && (e += this._batchTableHierarchy.byteLength), e } } }); Ea.prototype.hasProperty = function (e, t) { return !!(l(this._metadataTable) && this._metadataTable.hasProperty(t) || l(this._batchTableHierarchy) && this._batchTableHierarchy.hasProperty(e, t) || l(this._jsonMetadataTable) && this._jsonMetadataTable.hasProperty(t)) }; Ea.prototype.hasPropertyBySemantic = function (e, t) { return l(this._metadataTable) ? this._metadataTable.hasPropertyBySemantic(t) : !1 }; Ea.prototype.propertyExists = function (e) { return !!(l(this._metadataTable) && this._metadataTable.hasProperty(e) || l(this._batchTableHierarchy) && this._batchTableHierarchy.propertyExists(e) || l(this._jsonMetadataTable) && this._jsonMetadataTable.hasProperty(e)) }; Ea.prototype.propertyExistsBySemantic = function (e) { return l(this._metadataTable) ? this._metadataTable.hasPropertyBySemantic(e) : !1 }; var c8 = []; Ea.prototype.getPropertyIds = function (e, t) { return t = l(t) ? t : [], t.length = 0, l(this._metadataTable) && t.push.apply(t, this._metadataTable.getPropertyIds(c8)), l(this._batchTableHierarchy) && t.push.apply(t, this._batchTableHierarchy.getPropertyIds(e, c8)), l(this._jsonMetadataTable) && t.push.apply(t, this._jsonMetadataTable.getPropertyIds(c8)), t }; Ea.prototype.getProperty = function (e, t) { let n; if (l(this._metadataTable) && (n = this._metadataTable.getProperty(e, t), l(n)) || l(this._batchTableHierarchy) && (n = this._batchTableHierarchy.getProperty(e, t), l(n)) || l(this._jsonMetadataTable) && (n = this._jsonMetadataTable.getProperty(e, t), l(n))) return n }; Ea.prototype.setProperty = function (e, t, n) { l(this._metadataTable) && this._metadataTable.setProperty(e, t, n) || l(this._batchTableHierarchy) && this._batchTableHierarchy.setProperty(e, t, n) || (l(this._jsonMetadataTable) || (this._jsonMetadataTable = new f_({ count: this._count, properties: {} })), this._jsonMetadataTable.setProperty(e, t, n)) }; Ea.prototype.getPropertyBySemantic = function (e, t) { if (l(this._metadataTable)) return this._metadataTable.getPropertyBySemantic(e, t) }; Ea.prototype.setPropertyBySemantic = function (e, t, n) { return l(this._metadataTable) ? this._metadataTable.setPropertyBySemantic(e, t, n) : !1 }; Ea.prototype.getPropertyTypedArray = function (e) { if (l(this._metadataTable)) return this._metadataTable.getPropertyTypedArray(e) }; Ea.prototype.getPropertyTypedArrayBySemantic = function (e) { if (l(this._metadataTable)) return this._metadataTable.getPropertyTypedArrayBySemantic(e) }; Ea.prototype.isClass = function (e, t) { let n = this._batchTableHierarchy; return l(n) ? n.isClass(e, t) : !1 }; Ea.prototype.isExactClass = function (e, t) { return this.getExactClassName(e) === t }; Ea.prototype.getExactClassName = function (e) { let t = this._batchTableHierarchy; if (!!l(t)) return t.getClassName(e) }; var Vc = Ea; function ES(e) { e = y(e, y.EMPTY_OBJECT); let t = e.property, n = e.classProperty, i = e.textures, o = l(t.channels) ? t.channels : [0], r = t, s = Al.createModelTextureReader({ textureInfo: r, channels: xRe(o), texture: i[r.index] }); this._min = t.min, this._max = t.max; let a = t.offset, c = t.scale, u = n.hasValueTransform || l(a) || l(c); a = y(a, n.offset), c = y(c, n.scale), a = n.unpackVectorAndMatrixTypes(a), c = n.unpackVectorAndMatrixTypes(c), this._offset = a, this._scale = c, this._hasValueTransform = u, this._textureReader = s, this._classProperty = n, this._extras = t.extras, this._extensions = t.extensions } Object.defineProperties(ES.prototype, { textureReader: { get: function () { return this._textureReader } }, hasValueTransform: { get: function () { return this._hasValueTransform } }, offset: { get: function () { return this._offset } }, scale: { get: function () { return this._scale } }, classProperty: { get: function () { return this._classProperty } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); ES.prototype.isGpuCompatible = function () { let e = this._classProperty, t = e.type, n = e.componentType; return e.isArray ? !e.isVariableLengthArray && e.arrayLength <= 4 && t === Dn.SCALAR && n === wn.UINT8 : Dn.isVectorType(t) || t === Dn.SCALAR ? n === wn.UINT8 : !1 }; var ARe = [void 0, "float", "vec2", "vec3", "vec4"], CRe = [void 0, "int", "ivec2", "ivec3", "ivec4"]; ES.prototype.getGlslType = function () { let e = this._classProperty, t = Dn.getComponentCount(e.type); return e.isArray && (t = e.arrayLength), e.normalized ? ARe[t] : CRe[t] }; ES.prototype.unpackInShader = function (e) { return this._classProperty.normalized ? e : `${this.getGlslType()}(255.0 * ${e})` }; function xRe(e) { return e.map(function (t) { return "rgba".charAt(t) }).join("") } var CR = ES; function l8(e) { e = y(e, y.EMPTY_OBJECT); let t = e.propertyTexture, n = e.class, i = e.textures, o = t.extensions, r = t.extras, s = {}; if (l(t.properties)) for (let a in t.properties) t.properties.hasOwnProperty(a) && (s[a] = new CR({ property: t.properties[a], classProperty: n.properties[a], textures: i })); this._name = e.name, this._id = e.id, this._class = n, this._properties = s, this._extras = r, this._extensions = o } Object.defineProperties(l8.prototype, { name: { get: function () { return this._name } }, id: { get: function () { return this._id } }, class: { get: function () { return this._class } }, properties: { get: function () { return this._properties } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); l8.prototype.getProperty = function (e) { return this._properties[e] }; var JC = l8; function S$(e) { e = y(e, y.EMPTY_OBJECT); let t = e.property, n = e.classProperty; this._attribute = t.attribute, this._classProperty = n, this._min = t.min, this._max = t.max; let i = t.offset, o = t.scale, r = n.hasValueTransform || l(i) || l(o); i = y(i, n.offset), o = y(o, n.scale), i = n.unpackVectorAndMatrixTypes(i), o = n.unpackVectorAndMatrixTypes(o), this._offset = i, this._scale = o, this._hasValueTransform = r, this._extras = t.extras, this._extensions = t.extensions } Object.defineProperties(S$.prototype, { attribute: { get: function () { return this._attribute } }, hasValueTransform: { get: function () { return this._hasValueTransform } }, offset: { get: function () { return this._offset } }, scale: { get: function () { return this._scale } }, classProperty: { get: function () { return this._classProperty } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); var xR = S$; function u8(e) { e = y(e, y.EMPTY_OBJECT); let t = e.propertyAttribute, n = e.class, i = {}; if (l(t.properties)) for (let o in t.properties) t.properties.hasOwnProperty(o) && (i[o] = new xR({ property: t.properties[o], classProperty: n.properties[o] })); this._name = e.name, this._id = e.id, this._class = n, this._properties = i, this._extras = t.extras, this._extensions = t.extensions } Object.defineProperties(u8.prototype, { name: { get: function () { return this._name } }, id: { get: function () { return this._id } }, class: { get: function () { return this._class } }, properties: { get: function () { return this._properties } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); u8.prototype.getProperty = function (e) { return this._properties[e] }; var ZC = u8; function bS(e) { e = y(e, y.EMPTY_OBJECT), this._schema = e.schema; let t = e.propertyTables; this._propertyTableCount = l(t) ? t.length : 0, this._propertyTables = t, this._propertyTextures = e.propertyTextures, this._propertyAttributes = e.propertyAttributes, this._statistics = e.statistics, this._extras = e.extras, this._extensions = e.extensions } Object.defineProperties(bS.prototype, { schema: { get: function () { return this._schema } }, statistics: { get: function () { return this._statistics } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } }, propertyTableCount: { get: function () { return this._propertyTableCount } }, propertyTables: { get: function () { return this._propertyTables } }, propertyTextures: { get: function () { return this._propertyTextures } }, propertyAttributes: { get: function () { return this._propertyAttributes } }, propertyTablesByteLength: { get: function () { if (!l(this._propertyTables)) return 0; let e = 0, t = this._propertyTables.length; for (let n = 0; n < t; n++)e += this._propertyTables[n].byteLength; return e } } }); bS.prototype.getPropertyTable = function (e) { return this._propertyTables[e] }; bS.prototype.getPropertyTexture = function (e) { return this._propertyTextures[e] }; bS.prototype.getPropertyAttribute = function (e) { return this._propertyAttributes[e] }; var ba = bS; function TRe(e) { e = y(e, y.EMPTY_OBJECT); let t = e.extension, n = e.schema, i = []; if (l(t.propertyTables)) for (let s = 0; s < t.propertyTables.length; s++) { let a = t.propertyTables[s], c = n.classes[a.class], u = new Af({ count: a.count, properties: a.properties, class: c, bufferViews: e.bufferViews }); i.push(new Vc({ id: s, name: a.name, count: a.count, metadataTable: u, extras: a.extras, extensions: a.extensions })) } let o = []; if (l(t.propertyTextures)) for (let s = 0; s < t.propertyTextures.length; s++) { let a = t.propertyTextures[s]; o.push(new JC({ id: s, name: a.name, propertyTexture: a, class: n.classes[a.class], textures: e.textures })) } let r = []; if (l(t.propertyAttributes)) for (let s = 0; s < t.propertyAttributes.length; s++) { let a = t.propertyAttributes[s]; r.push(new ZC({ id: s, name: a.name, class: n.classes[a.class], propertyAttribute: a })) } return new ba({ schema: n, propertyTables: i, propertyTextures: o, propertyAttributes: r, statistics: t.statistics, extras: t.extras, extensions: t.extensions }) } var TR = TRe; function ERe(e) { e = y(e, y.EMPTY_OBJECT); let t = e.extension, n = e.schema, i, o = [], r; if (l(t.featureTables)) for (r = Object.keys(t.featureTables).sort(), i = 0; i < r.length; i++) { let a = r[i], c = t.featureTables[a], u = n.classes[c.class], f = new Af({ count: c.count, properties: c.properties, class: u, bufferViews: e.bufferViews }); o.push(new Vc({ id: a, count: c.count, metadataTable: f, extras: c.extras, extensions: c.extensions })) } let s = []; if (l(t.featureTextures)) for (r = Object.keys(t.featureTextures).sort(), i = 0; i < r.length; i++) { let a = r[i], c = t.featureTextures[a]; s.push(new JC({ id: a, propertyTexture: bRe(c), class: n.classes[c.class], textures: e.textures })) } return new ba({ schema: n, propertyTables: o, propertyTextures: s, statistics: t.statistics, extras: t.extras, extensions: t.extensions }) } function bRe(e) { let t = { class: e.class, properties: {} }, n = e.properties; for (let i in n) if (n.hasOwnProperty(i)) { let o = n[i], r = { channels: SRe(o.channels), extras: o.extras, extensions: o.extensions }; t.properties[i] = yt(o.texture, r, !0) } return t } function SRe(e) { let t = e.length, n = new Array(t); for (let i = 0; i < t; i++)n[i] = "rgba".indexOf(e[i]); return n } var ER = ERe; function d_(e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltf, n = e.extension, i = e.extensionLegacy, o = e.gltfResource, r = e.baseResource, s = e.supportedImageFormats, a = e.frameState, c = e.cacheKey, u = y(e.asynchronous, !0); this._gltfResource = o, this._baseResource = r, this._gltf = t, this._extension = n, this._extensionLegacy = i, this._supportedImageFormats = s, this._frameState = a, this._cacheKey = c, this._asynchronous = u, this._bufferViewLoaders = [], this._textureLoaders = [], this._schemaLoader = void 0, this._structuralMetadata = void 0, this._state = kt.UNLOADED, this._promise = void 0 } l(Object.create) && (d_.prototype = Object.create(Zi.prototype), d_.prototype.constructor = d_); Object.defineProperties(d_.prototype, { promise: { get: function () { return this._promise } }, cacheKey: { get: function () { return this._cacheKey } }, structuralMetadata: { get: function () { return this._structuralMetadata } } }); d_.prototype.load = function () { let e = IRe(this), t = LRe(this), n = FRe(this); this._gltf = void 0, this._state = kt.LOADING; let i = this; this._promise = Promise.all([e, t, n]).then(function (o) { if (i.isDestroyed()) return; let r = o[0], s = o[1], a = o[2]; return l(i._extension) ? i._structuralMetadata = TR({ extension: i._extension, schema: a, bufferViews: r, textures: s }) : i._structuralMetadata = ER({ extension: i._extensionLegacy, schema: a, bufferViews: r, textures: s }), i._state = kt.READY, i }).catch(function (o) { if (i.isDestroyed()) return; i.unload(), i._state = kt.FAILED; let r = "Failed to load structural metadata"; return Promise.reject(i.getError(r, o)) }) }; function wRe(e, t) { for (let n in e) if (e.hasOwnProperty(n)) { let i = e[n], o = i.values, r = i.arrayOffsets, s = i.stringOffsets; l(o) && (t[o] = !0), l(r) && (t[r] = !0), l(s) && (t[s] = !0) } } function DRe(e, t) { for (let n in e) if (e.hasOwnProperty(n)) { let i = e[n], o = i.bufferView, r = i.arrayOffsetBufferView, s = i.stringOffsetBufferView; l(o) && (t[o] = !0), l(r) && (t[r] = !0), l(s) && (t[s] = !0) } } function vRe(e) { let t = e.propertyTables, n = {}; if (l(t)) for (let i = 0; i < t.length; i++) { let o = t[i]; wRe(o.properties, n) } return n } function PRe(e) { let t = e.featureTables, n = {}; if (l(t)) { for (let i in t) if (t.hasOwnProperty(i)) { let r = t[i].properties; l(r) && DRe(r, n) } } return n } function IRe(e) { let t; l(e._extension) ? t = vRe(e._extension) : t = PRe(e._extensionLegacy); let n = [], i = {}; for (let o in t) if (t.hasOwnProperty(o)) { let r = ao.loadBufferView({ gltf: e._gltf, bufferViewId: parseInt(o), gltfResource: e._gltfResource, baseResource: e._baseResource }); n.push(r.promise), e._bufferViewLoaders.push(r), i[o] = r } return Promise.all(n).then(function () { let o = {}; for (let r in i) if (i.hasOwnProperty(r)) { let s = i[r], a = new Uint8Array(s.typedArray); o[r] = a } return w$(e), o }) } function ORe(e) { let t = {}, n = e.propertyTextures; if (l(n)) for (let i = 0; i < n.length; i++) { let r = n[i].properties; l(r) && BRe(r, t) } return t } function BRe(e, t) { for (let n in e) if (e.hasOwnProperty(n)) { let i = e[n]; t[i.index] = i } } function RRe(e) { let t = {}, n = e.featureTextures; if (l(n)) { for (let i in n) if (n.hasOwnProperty(i)) { let r = n[i].properties; l(r) && MRe(r, t) } } return t } function MRe(e, t) { for (let n in e) if (e.hasOwnProperty(n)) { let o = e[n].texture; t[o.index] = o } } function LRe(e) { let t; l(e._extension) ? t = ORe(e._extension) : t = RRe(e._extensionLegacy); let n = e._gltf, i = e._gltfResource, o = e._baseResource, r = e._supportedImageFormats, s = e._frameState, a = e._asynchronous, c = [], u = {}; for (let f in t) if (t.hasOwnProperty(f)) { let d = ao.loadTexture({ gltf: n, textureInfo: t[f], gltfResource: i, baseResource: o, supportedImageFormats: r, frameState: s, asynchronous: a }); c.push(d.promise), e._textureLoaders.push(d), u[f] = d } return Promise.all(c).then(function () { let f = {}; for (let d in u) if (u.hasOwnProperty(d)) { let p = u[d]; f[d] = p.texture } return f }) } function FRe(e) { let t = y(e._extension, e._extensionLegacy), n; if (l(t.schemaUri)) { let i = e._baseResource.getDerivedResource({ url: t.schemaUri }); n = ao.loadSchema({ resource: i }) } else n = ao.loadSchema({ schema: t.schema }); return e._schemaLoader = n, n.promise.then(function (i) { return i.schema }) } d_.prototype.process = function (e) { if (this._state !== kt.LOADING) return; let t = this._textureLoaders, n = t.length; for (let i = 0; i < n; ++i)t[i].process(e) }; function w$(e) { let t = e._bufferViewLoaders, n = t.length; for (let i = 0; i < n; ++i)ao.unload(t[i]); e._bufferViewLoaders.length = 0 } function NRe(e) { let t = e._textureLoaders, n = t.length; for (let i = 0; i < n; ++i)ao.unload(t[i]); e._textureLoaders.length = 0 } d_.prototype.unload = function () { w$(this), NRe(this), l(this._schemaLoader) && ao.unload(this._schemaLoader), this._schemaLoader = void 0, this._structuralMetadata = void 0 }; var bR = d_; var Kn = { POSITION: "POSITION", NORMAL: "NORMAL", TANGENT: "TANGENT", TEXCOORD: "TEXCOORD", COLOR: "COLOR", JOINTS: "JOINTS", WEIGHTS: "WEIGHTS", FEATURE_ID: "_FEATURE_ID" }; function VRe(e) { switch (e) { case Kn.POSITION: return "positionMC"; case Kn.NORMAL: return "normalMC"; case Kn.TANGENT: return "tangentMC"; case Kn.TEXCOORD: return "texCoord"; case Kn.COLOR: return "color"; case Kn.JOINTS: return "joints"; case Kn.WEIGHTS: return "weights"; case Kn.FEATURE_ID: return "featureId" } } Kn.hasSetIndex = function (e) { switch (e) { case Kn.POSITION: case Kn.NORMAL: case Kn.TANGENT: return !1; case Kn.TEXCOORD: case Kn.COLOR: case Kn.JOINTS: case Kn.WEIGHTS: case Kn.FEATURE_ID: return !0 } }; Kn.fromGltfSemantic = function (e) { let t = e, i = /^(\w+)_\d+$/.exec(e); switch (i !== null && (t = i[1]), t) { case "POSITION": return Kn.POSITION; case "NORMAL": return Kn.NORMAL; case "TANGENT": return Kn.TANGENT; case "TEXCOORD": return Kn.TEXCOORD; case "COLOR": return Kn.COLOR; case "JOINTS": return Kn.JOINTS; case "WEIGHTS": return Kn.WEIGHTS; case "_FEATURE_ID": return Kn.FEATURE_ID } }; Kn.fromPntsSemantic = function (e) { switch (e) { case "POSITION": case "POSITION_QUANTIZED": return Kn.POSITION; case "RGBA": case "RGB": case "RGB565": return Kn.COLOR; case "NORMAL": case "NORMAL_OCT16P": return Kn.NORMAL; case "BATCH_ID": return Kn.FEATURE_ID } }; Kn.getGlslType = function (e) { switch (e) { case Kn.POSITION: case Kn.NORMAL: case Kn.TANGENT: return "vec3"; case Kn.TEXCOORD: return "vec2"; case Kn.COLOR: return "vec4"; case Kn.JOINTS: return "ivec4"; case Kn.WEIGHTS: return "vec4"; case Kn.FEATURE_ID: return "int" } }; Kn.getVariableName = function (e, t) { let n = VRe(e); return l(t) && (n += `_${t}`), n }; var xt = Object.freeze(Kn); function Sa() { } Sa.getFailedLoadFunction = function (e, t, n) {
        return function (i) {
            let o = `Failed to load ${t}: ${n}`; l(i) && (o += `
${i.message}`); let r = new fe(o); return l(i) && (r.stack = `Original stack:
${i.stack}
Handler stack:
${r.stack}`), Promise.reject(r)
        }
    }; Sa.getNodeTransform = function (e) { return l(e.matrix) ? e.matrix : F.fromTranslationQuaternionRotationScale(l(e.translation) ? e.translation : h.ZERO, l(e.rotation) ? e.rotation : Be.IDENTITY, l(e.scale) ? e.scale : h.ONE) }; Sa.getAttributeBySemantic = function (e, t, n) { let i = e.attributes, o = i.length; for (let r = 0; r < o; ++r) { let s = i[r], a = l(n) ? s.setIndex === n : !0; if (s.semantic === t && a) return s } }; Sa.getAttributeByName = function (e, t) { let n = e.attributes, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; if (r.name === t) return r } }; Sa.getFeatureIdsByLabel = function (e, t) { for (let n = 0; n < e.length; n++) { let i = e[n]; if (i.positionalLabel === t || i.label === t) return i } }; Sa.hasQuantizedAttributes = function (e) { if (!l(e)) return !1; for (let t = 0; t < e.length; t++) { let n = e[t]; if (l(n.quantization)) return !0 } return !1 }; Sa.getAttributeInfo = function (e) { let t = e.semantic, n = e.setIndex, i, o = !1; l(t) ? (i = xt.getVariableName(t, n), o = !0) : (i = e.name, i = i.replace(/^_/, ""), i = i.toLowerCase()); let r = /^color_\d+$/.test(i), s = e.type, a = en.getGlslType(s); r && (a = "vec4"); let c = l(e.quantization), u; return c && (u = r ? "vec4" : en.getGlslType(e.quantization.type)), { attribute: e, isQuantized: c, variableName: i, hasSemantic: o, glslType: a, quantizedGlslType: u } }; var kRe = new h, URe = new h; Sa.getPositionMinMax = function (e, t, n) { let i = Sa.getAttributeBySemantic(e, "POSITION"), o = i.max, r = i.min; return l(n) && l(t) && (r = h.add(r, t, URe), o = h.add(o, n, kRe)), { min: r, max: o } }; Sa.getAxisCorrectionMatrix = function (e, t, n) { return n = F.clone(F.IDENTITY, n), e === Do.Y ? n = F.clone(Do.Y_UP_TO_Z_UP, n) : e === Do.X && (n = F.clone(Do.X_UP_TO_Z_UP, n)), t === Do.Z && (n = F.multiplyTransformation(n, Do.Z_UP_TO_X_UP, n)), n }; var zRe = new Q; Sa.getCullFace = function (e, t) { if (!Oe.isTriangles(t)) return gi.BACK; let n = F.getMatrix3(e, zRe); return Q.determinant(n) < 0 ? gi.FRONT : gi.BACK }; Sa.sanitizeGlslIdentifier = function (e) { let t = e.replaceAll(/[^A-Za-z0-9]+/g, "_"); return t = t.replace(/^gl_/, ""), /^\d/.test(t) && (t = `_${t}`), t }; Sa.supportedExtensions = { AGI_articulations: !0, CESIUM_primitive_outline: !0, CESIUM_RTC: !0, EXT_feature_metadata: !0, EXT_instance_features: !0, EXT_mesh_features: !0, EXT_mesh_gpu_instancing: !0, EXT_meshopt_compression: !0, EXT_structural_metadata: !0, EXT_texture_webp: !0, KHR_blend: !0, KHR_draco_mesh_compression: !0, KHR_techniques_webgl: !0, KHR_materials_common: !0, KHR_materials_pbrSpecularGlossiness: !0, KHR_materials_unlit: !0, KHR_mesh_quantization: !0, KHR_texture_basisu: !0, KHR_texture_transform: !0, WEB3D_quantized_attributes: !0 }; Sa.checkSupportedExtensions = function (e) { let t = e.length; for (let n = 0; n < t; n++) { let i = e[n]; if (!Sa.supportedExtensions[i]) throw new fe(`Unsupported glTF Extension: ${i}`) } }; var tn = Sa; var QC = { TRANSLATION: "TRANSLATION", ROTATION: "ROTATION", SCALE: "SCALE", FEATURE_ID: "_FEATURE_ID" }; QC.fromGltfSemantic = function (e) { let t = e, i = /^(\w+)_\d+$/.exec(e); switch (i !== null && (t = i[1]), t) { case "TRANSLATION": return QC.TRANSLATION; case "ROTATION": return QC.ROTATION; case "SCALE": return QC.SCALE; case "_FEATURE_ID": return QC.FEATURE_ID } }; var Ur = Object.freeze(QC); var HRe = 65534, GRe = 255; function SR(e) { e = y(e, y.EMPTY_OBJECT); let t = e.triangleIndices, n = e.outlineIndices, i = e.originalVertexCount; this._triangleIndices = t, this._originalVertexCount = i, this._edges = new P$(n, i), this._outlineCoordinatesTypedArray = void 0, this._extraVertices = [], WRe(this) } Object.defineProperties(SR.prototype, { updatedTriangleIndices: { get: function () { return this._triangleIndices } }, outlineCoordinates: { get: function () { return this._outlineCoordinatesTypedArray } } }); function WRe(e) { let t = e._triangleIndices, n = e._edges, i = [], o = e._extraVertices, r = e._originalVertexCount, s = {}; for (let a = 0; a < t.length; a += 3) { let c = t[a], u = t[a + 1], f = t[a + 2], d = !1, p = d || n.hasEdge(c, u), g = d || n.hasEdge(u, f), m = d || n.hasEdge(f, c), A = D$(i, c, u, f, p, g, m); for (; l(A);) { let C = s[A]; if (!l(C)) { C = r + o.length; let x = A; for (; x >= r;)x = o[x - r]; o.push(x), s[A] = C } C > HRe && (t instanceof Uint16Array || t instanceof Uint8Array) ? t = new Uint32Array(t) : C > GRe && t instanceof Uint8Array && (t = new Uint16Array(t)), A === c ? (c = C, t[a] = C) : A === u ? (u = C, t[a + 1] = C) : (f = C, t[a + 2] = C), A = D$(i, c, u, f, p, g, m) } } e._triangleIndices = t, e._outlineCoordinatesTypedArray = new Float32Array(i) } function D$(e, t, n, i, o, r, s) { let a = s ? 1 : 0, c = o ? 1 : 0, u = 0, f = f8(e, t, a, c, u); if (f === 0) return t; let d = 0, p = o ? 1 : 0, g = r ? 1 : 0, m = f8(e, n, d, p, g); if (m === 0) return n; let A = s ? 1 : 0, C = 0, x = r ? 1 : 0, T = f8(e, i, A, C, x); if (T === 0) return i; let b = f & m & T, S, D, P; if (b & 1 << 0) S = 0, D = 1, P = 2; else if (b & 1 << 1) S = 0, P = 1, D = 2; else if (b & 1 << 2) D = 0, S = 1, P = 2; else if (b & 1 << 3) D = 0, P = 1, S = 2; else if (b & 1 << 4) P = 0, S = 1, D = 2; else if (b & 1 << 5) P = 0, D = 1, S = 2; else { let L = d8(f), _ = d8(m), E = d8(T); return L < _ && L < E ? t : _ < E ? n : i } let B = t * 3; e[B + S] = a, e[B + D] = c, e[B + P] = u; let R = n * 3; e[R + S] = d, e[R + D] = p, e[R + P] = g; let M = i * 3; e[M + S] = A, e[M + D] = C, e[M + P] = x } function f8(e, t, n, i, o) { let r = t * 3, s = e[r], a = e[r + 1], c = e[r + 2]; return l(s) ? (s === n && a === i && c === o) << 0 | (s === n && a === o && c === i) << 1 | (s === i && a === n && c === o) << 2 | (s === i && a === o && c === n) << 3 | (s === o && a === n && c === i) << 4 | (s === o && a === i && c === n) << 5 : 63 } function d8(e) { return (e & 1) + (e >> 1 & 1) + (e >> 2 & 1) + (e >> 3 & 1) + (e >> 4 & 1) + (e >> 5 & 1) } SR.prototype.updateAttribute = function (e) { let t = this._extraVertices, n = e.length, i = n / this._originalVertexCount, o = t.length, r = e.constructor, s = new r(e.length + o * i); s.set(e); for (let a = 0; a < o; a++) { let c = t[a] * i, u = n + a * i; for (let f = 0; f < i; f++)s[u + f] = s[c + f] } return s }; SR.createTexture = function (e) { let t = e.cache.modelOutliningCache; if (l(t) || (t = e.cache.modelOutliningCache = {}), l(t.outlineTexture)) return t.outlineTexture; let n = Math.min(4096, Ut.maximumTextureSize), i = n, o = v$(i), r = []; for (; i > 1;)i >>= 1, r.push(v$(i)); let s = new Rt({ context: e, source: { arrayBufferView: o, mipLevels: r }, width: n, height: 1, pixelFormat: ht.LUMINANCE, sampler: new dn({ wrapS: In.CLAMP_TO_EDGE, wrapT: In.CLAMP_TO_EDGE, minificationFilter: ln.LINEAR_MIPMAP_LINEAR, magnificationFilter: Xi.LINEAR }) }); return t.outlineTexture = s, s }; function v$(e) { let t = new Uint8Array(e); return t[e - 1] = 192, e === 8 ? t[e - 1] = 96 : e === 4 ? t[e - 1] = 48 : e === 2 ? t[e - 1] = 24 : e === 1 && (t[e - 1] = 12), t } function P$(e, t) { this._originalVertexCount = t, this._edges = new Set; for (let n = 0; n < e.length; n += 2) { let i = e[n], o = e[n + 1], r = Math.min(i, o), s = Math.max(i, o), a = r * this._originalVertexCount + s; this._edges.add(a) } } P$.prototype.hasEdge = function (e, t) { let n = Math.min(e, t), i = Math.max(e, t), o = n * this._originalVertexCount + i; return this._edges.has(o) }; var $C = SR; function I$(e) { this.attribute = e, this.loadBuffer = !1, this.loadTypedArray = !1 } function jRe(e) { this.indices = e, this.loadBuffer = !1, this.loadTypedArray = !1 } function wR(e) { this.primitive = e, this.attributePlans = [], this.indicesPlan = void 0, this.needsOutlines = !1, this.outlineIndices = void 0 } wR.prototype.postProcess = function (e) { this.needsOutlines && (qRe(this), XRe(this, e)) }; function qRe(e) { let t = e.primitive, n = t.indices, i = t.attributes[0].count, o = new $C({ triangleIndices: n.typedArray, outlineIndices: e.outlineIndices, originalVertexCount: i }); n.typedArray = o.updatedTriangleIndices, n.indexDatatype = Me.fromTypedArray(n.typedArray); let r = YRe(o.outlineCoordinates), s = new I$(r); s.loadBuffer = !0, s.loadTypedArray = !1, e.attributePlans.push(s), t.outlineCoordinates = s.attribute; let a = e.attributePlans, c = e.attributePlans.length; for (let u = 0; u < c; u++) { let f = a[u].attribute; f.typedArray = o.updateAttribute(f.typedArray) } } function YRe(e) { let t = new Dt.Attribute; return t.name = "_OUTLINE_COORDINATES", t.typedArray = e, t.componentDatatype = Y.FLOAT, t.type = en.VEC3, t.normalized = !1, t.count = e.length / 3, t } function XRe(e, t) { KRe(e.attributePlans, t), l(e.indicesPlan) && JRe(e.indicesPlan, t) } function KRe(e, t) { let n = e.length; for (let i = 0; i < n; i++) { let o = e[i], r = o.attribute, s = r.typedArray; if (o.loadBuffer) { let a = ct.createVertexBuffer({ typedArray: s, context: t, usage: Re.STATIC_DRAW }); a.vertexArrayDestroyable = !1, r.buffer = a } o.loadTypedArray || (r.typedArray = void 0) } } function JRe(e, t) { let n = e.indices; if (e.loadBuffer) { let i = ct.createIndexBuffer({ typedArray: n.typedArray, context: t, usage: Re.STATIC_DRAW, indexDatatype: n.indexDatatype }); n.buffer = i, i.vertexArrayDestroyable = !1 } e.loadTypedArray || (n.typedArray = void 0) } wR.AttributeLoadPlan = I$; wR.IndicesLoadPlan = jRe; var ex = wR; function ZRe(e) { e = y(e, y.EMPTY_OBJECT), this.webp = y(e.webp, !1), this.basis = y(e.basis, !1) } var DR = ZRe; var QRe = Dt.Attribute, $Re = Dt.Indices, B$ = Dt.FeatureIdAttribute, R$ = Dt.FeatureIdTexture, M$ = Dt.FeatureIdImplicitRange, eMe = Dt.MorphTarget, tMe = Dt.Primitive, nMe = Dt.Instances, iMe = Dt.Skin, oMe = Dt.Node, rMe = Dt.AnimatedPropertyType, sMe = Dt.AnimationSampler, aMe = Dt.AnimationTarget, cMe = Dt.AnimationChannel, lMe = Dt.Animation, uMe = Dt.ArticulationStage, fMe = Dt.Articulation, dMe = Dt.Asset, hMe = Dt.Scene, mMe = Dt.Components, pMe = Dt.MetallicRoughness, _Me = Dt.SpecularGlossiness, gMe = Dt.Material, Jo = { NOT_LOADED: 0, LOADING: 1, LOADED: 2, PROCESSING: 3, POST_PROCESSING: 4, PROCESSED: 5, READY: 6, FAILED: 7, UNLOADED: 8 }; function Em(e) { e = y(e, y.EMPTY_OBJECT); let t = e.gltfResource, n = e.baseResource, i = e.typedArray, o = y(e.releaseGltfJson, !1), r = y(e.asynchronous, !0), s = y(e.incrementallyLoadTextures, !0), a = y(e.upAxis, Do.Y), c = y(e.forwardAxis, Do.Z), u = y(e.loadAttributesAsTypedArray, !1), f = y(e.loadAttributesFor2D, !1), d = y(e.loadIndicesForWireframe, !1), p = y(e.loadPrimitiveOutline, !0), g = y(e.loadForClassification, !1), m = y(e.renameBatchIdSemantic, !1); n = l(n) ? n : t.clone(), this._gltfJson = e.gltfJson, this._gltfResource = t, this._baseResource = n, this._typedArray = i, this._releaseGltfJson = o, this._asynchronous = r, this._incrementallyLoadTextures = s, this._upAxis = a, this._forwardAxis = c, this._loadAttributesAsTypedArray = u, this._loadAttributesFor2D = f, this._loadIndicesForWireframe = d, this._loadPrimitiveOutline = p, this._loadForClassification = g, this._renameBatchIdSemantic = m, this._hasKhrMeshQuantization = !1, this._sortedPropertyTableIds = void 0, this._sortedFeatureTextureIds = void 0, this._gltfJsonLoader = void 0, this._state = Jo.NOT_LOADED, this._textureState = Jo.NOT_LOADED, this._promise = void 0, this._texturesLoadedPromise = void 0, this._process = function (A, C) { }, this._processTextures = function (A, C) { }, this._primitiveLoadPlans = [], this._loaderPromises = [], this._textureLoaders = [], this._texturesPromises = [], this._bufferViewLoaders = [], this._geometryLoaders = [], this._structuralMetadataLoader = void 0, this._postProcessBuffers = [], this._components = void 0 } l(Object.create) && (Em.prototype = Object.create(Zi.prototype), Em.prototype.constructor = Em); Object.defineProperties(Em.prototype, { promise: { get: function () { return this._promise } }, cacheKey: { get: function () { } }, components: { get: function () { return this._components } }, texturesLoadedPromise: { get: function () { return this._texturesLoadedPromise } } }); Em.prototype.load = function () { let e = ao.loadGltfJson({ gltfResource: this._gltfResource, baseResource: this._baseResource, typedArray: this._typedArray, gltfJson: this._gltfJson }); this._gltfJsonLoader = e, this._state = Jo.LOADING, this._textureState = Jo.LOADING; let t = this, n, i = new Promise(function (o, r) { n = new Promise(function (s, a) { t._process = function (c, u) { if (!Nt.supportsWebP.initialized) { Nt.supportsWebP.initialize(); return } if (c._state === Jo.LOADED) { c._state = Jo.PROCESSING; let f = new DR({ webp: Nt.supportsWebP(), basis: u.context.supportsBasis }), d; l(c._gltfJsonLoader) ? d = c._gltfJsonLoader.gltf : d = c._gltfJson, hLe(c, d, f, u, r, a), l(c._gltfJsonLoader) && c._releaseGltfJson && (ao.unload(c._gltfJsonLoader), c._gltfJsonLoader = void 0) } c._state === Jo.PROCESSING && yMe(c, u), c._state === Jo.POST_PROCESSING && (AMe(c, u.context), c._state = Jo.PROCESSED), c._state === Jo.PROCESSED && (G$(c), c._typedArray = void 0, c._state = Jo.READY, o(c)) }, t._processTextures = function (c, u) { if (c._textureState === Jo.LOADED && (c._textureState = Jo.PROCESSING), c._textureState === Jo.PROCESSING) { let f, d = c._textureLoaders, p = d.length; for (f = 0; f < p; ++f)d[f].process(u) } c._textureState === Jo.PROCESSED && (c._textureState = Jo.READY, s(c)) } }) }); return this._promise = e.promise.then(function () { if (!t.isDestroyed()) return t._state = Jo.LOADED, t._textureState = Jo.LOADED, i }).catch(function (o) { if (!t.isDestroyed()) return t._state = Jo.FAILED, t._textureState = Jo.FAILED, O$(t, o) }), this._texturesLoadedPromise = n.catch(function (o) { if (!t.isDestroyed()) return t._textureState = Jo.FAILED, O$(t, o) }), this._promise }; function O$(e, t) { e.unload(); let n = "Failed to load glTF"; return t = e.getError(n, t), Promise.reject(t) } function yMe(e, t) { let n = e._bufferViewLoaders, i = n.length; for (let s = 0; s < i; ++s)n[s].process(t); let o = e._geometryLoaders, r = o.length; for (let s = 0; s < r; ++s)o[s].process(t); l(e._structuralMetadataLoader) && e._structuralMetadataLoader.process(t) } function AMe(e, t) { let n = e._primitiveLoadPlans, i = n.length; for (let o = 0; o < i; o++) { let r = n[o]; r.postProcess(t), r.needsOutlines && CMe(e, r) } } function CMe(e, t) { let n = e._postProcessBuffers, i = t.primitive, o = i.outlineCoordinates; l(o) && n.push(o.buffer); let r = i.attributes, s = r.length; for (let c = 0; c < s; c++) { let u = r[c]; l(u.buffer) && n.push(u.buffer) } let a = i.indices; l(a) && l(a.buffer) && n.push(a.buffer) } Em.prototype.process = function (e) { this._process(this, e), this._processTextures(this, e) }; function xMe(e, t, n, i, o, r, s, a) { let u = t.accessors[n].bufferView, f = ao.loadVertexBuffer({ gltf: t, gltfResource: e._gltfResource, baseResource: e._baseResource, frameState: a, bufferViewId: u, draco: o, attributeSemantic: i, accessorId: n, asynchronous: e._asynchronous, loadBuffer: r, loadTypedArray: s }); return e._geometryLoaders.push(f), f } function TMe(e, t, n, i, o, r, s) { let a = ao.loadIndexBuffer({ gltf: t, accessorId: n, gltfResource: e._gltfResource, baseResource: e._baseResource, frameState: s, draco: i, asynchronous: e._asynchronous, loadBuffer: o, loadTypedArray: r }); return e._geometryLoaders.push(a), a } function EMe(e, t, n) { let i = ao.loadBufferView({ gltf: t, bufferViewId: n, gltfResource: e._gltfResource, baseResource: e._baseResource }); return e._bufferViewLoaders.push(i), i } function L$(e, t, n) { let i = t.byteOffset, o = yl(e, t), r = t.count, s = uu(t.type), a = t.componentType, c = Y.getSizeInBytes(a), u = c * s, f = r * s; if (o === u) return n = new Uint8Array(n), Y.createArrayBufferView(a, n.buffer, n.byteOffset + i, f); let d = Y.createTypedArray(a, f), p = new DataView(n.buffer), g = new Array(s), m = s_(t.componentType); i = n.byteOffset + i; for (let A = 0; A < r; ++A) { m(p, i, s, c, g); for (let C = 0; C < s; ++C)d[A * s + C] = g[C]; i += o } return d } function bMe(e, t) { let n = e.type; if (n === en.SCALAR) return t.fill(0); let i = en.getMathType(n); return t.fill(i.clone(i.ZERO)) } function SMe(e, t, n, i) { let o = e.type, r = e.count; if (o === en.SCALAR) for (let s = 0; s < r; s++)n[s] = t[s]; else if (o === en.VEC4 && i) for (let s = 0; s < r; s++)n[s] = Be.unpack(t, s * 4); else { let s = en.getMathType(o), a = en.getNumberOfComponents(o); for (let c = 0; c < r; c++)n[c] = s.unpack(t, c * a) } return n } function vR(e, t, n, i) { let o = t.accessors[n], r = o.count, s = new Array(r), a = o.bufferView; if (l(a)) { let u = EMe(e, t, a).promise.then(function (f) { if (e.isDestroyed()) return; let d = f.typedArray, p = L$(t, o, d); i = y(i, !1), SMe(o, p, s, i) }); return e._loaderPromises.push(u), s } return bMe(o, s) } function du(e, t) { if (!!l(t)) return e === Number ? t[0] : e.unpack(t) } function wMe(e) { return e === Number ? 0 : new e } function DMe(e) { switch (e) { case Y.BYTE: return 127; case Y.UNSIGNED_BYTE: return 255; case Y.SHORT: return 32767; case Y.UNSIGNED_SHORT: return 65535; default: return 1 } } var vMe = { VEC2: new H(-1, -1), VEC3: new h(-1, -1, -1), VEC4: new se(-1, -1, -1, -1) }; function PMe(e, t) { let n = DMe(e.componentDatatype), i = vMe[e.type], o = e.min; l(o) && (o = t.divideByScalar(o, n, o), o = t.maximumByComponent(o, i, o)); let r = e.max; l(r) && (r = t.divideByScalar(r, n, r), r = t.maximumByComponent(r, i, r)), e.min = o, e.max = r } function IMe(e, t, n) { let i = e.decodeMatrix, o = du(n, e.decodedMin), r = du(n, e.decodedMax); l(o) && l(r) && (t.min = o, t.max = r); let s = new Dt.Quantization; s.componentDatatype = t.componentDatatype, s.type = t.type, i.length === 4 ? (s.quantizedVolumeOffset = i[2], s.quantizedVolumeStepSize = i[0]) : i.length === 9 ? (s.quantizedVolumeOffset = new H(i[6], i[7]), s.quantizedVolumeStepSize = new H(i[0], i[4])) : i.length === 16 ? (s.quantizedVolumeOffset = new h(i[12], i[13], i[14]), s.quantizedVolumeStepSize = new h(i[0], i[5], i[10])) : i.length === 25 && (s.quantizedVolumeOffset = new se(i[20], i[21], i[22], i[23]), s.quantizedVolumeStepSize = new se(i[0], i[6], i[12], i[18])), t.quantization = s } function OMe(e, t, n, i, o, r) { let s = e.accessors[t], a = en.getMathType(s.type), c = y(s.normalized, !1), u = new QRe; u.name = n, u.semantic = i, u.setIndex = o, u.constant = wMe(a), u.componentDatatype = s.componentType, u.normalized = c, u.count = s.count, u.type = s.type, u.min = du(a, s.min), u.max = du(a, s.max), u.byteOffset = s.byteOffset, u.byteStride = yl(e, s), Mi(s, "WEB3D_quantized_attributes") && IMe(s.extensions.WEB3D_quantized_attributes, u, a); let f = u.semantic === xt.POSITION || u.semantic === xt.NORMAL || u.semantic === xt.TANGENT || u.semantic === xt.TEXCOORD; return r && c && f && PMe(u, a), u } function F$(e) { let n = /^\w+_(\d+)$/.exec(e); if (n !== null) return parseInt(n[1]) } var BMe = { gltfSemantic: void 0, renamedSemantic: void 0, modelSemantic: void 0 }; function h8(e, t, n) { let i = n; e._renameBatchIdSemantic && (n === "_BATCHID" || n === "BATCHID") && (i = "_FEATURE_ID_0"); let o = t.fromGltfSemantic(i), r = BMe; return r.gltfSemantic = n, r.renamedSemantic = i, r.modelSemantic = o, r } function RMe(e) { let t = e === xt.POSITION, n = e === xt.FEATURE_ID, i = e === xt.TEXCOORD; return t || n || i } function MMe(e, t, n, i) { if (e.byteOffset = 0, e.byteStride = void 0, e.quantization = t.quantization, n && (e.buffer = t.buffer), i) { let o = l(t.quantization) ? t.quantization.componentDatatype : e.componentDatatype; e.typedArray = Y.createArrayBufferView(o, t.typedArray.buffer) } } function LMe(e, t, n, i, o, r) { if (o && (n.buffer = i.buffer), r) { let s = i.typedArray; n.typedArray = L$(e, t, s), o || (n.byteOffset = 0, n.byteStride = void 0) } } function N$(e, t, n, i, o, r, s, a) { let c = t.accessors[n], u = c.bufferView, f = i.gltfSemantic, d = i.renamedSemantic, p = i.modelSemantic, g = l(p) ? F$(d) : void 0, A = OMe(t, n, f, p, g, e._hasKhrMeshQuantization); if (!l(o) && !l(u)) return A; let x = xMe(e, t, n, f, o, r, s, a).promise.then(function (T) { e.isDestroyed() || (l(o) && l(o.attributes) && l(o.attributes[f]) ? MMe(A, T, r, s) : LMe(t, c, A, T, r, s)) }); return e._loaderPromises.push(x), A } function V$(e, t, n, i, o, r, s, a) { let c = i.modelSemantic, u = c === xt.POSITION, f = c === xt.FEATURE_ID, d = u && !r && e._loadAttributesFor2D && !a.scene3DOnly, p = e._loadForClassification && f, g = e._loadAttributesAsTypedArray, m = !g, A = g || d || p, T = N$(e, t, n, i, o, s ? !1 : m, s ? !0 : A, a), b = new ex.AttributeLoadPlan(T); return b.loadBuffer = m, b.loadTypedArray = A, b } function FMe(e, t, n, i, o, r) { let s = l(i.ROTATION), a = l(i.TRANSLATION) && l(t.accessors[i.TRANSLATION].min) && l(t.accessors[i.TRANSLATION].max), c = h8(e, Ur, o), u = c.modelSemantic, f = u === Ur.TRANSLATION || u === Ur.ROTATION || u === Ur.SCALE, d = u === Ur.TRANSLATION, p = e._loadAttributesAsTypedArray || s && f || !r.context.instancedArrays, g = !p, m = e._loadAttributesFor2D && !r.scene3DOnly; return N$(e, t, n, c, void 0, g, p || d && (!a || m), r) } function NMe(e, t, n, i, o, r, s) { let a = t.accessors[n], c = a.bufferView; if (!l(i) && !l(c)) return; let u = new $Re; u.count = a.count; let f = e._loadAttributesAsTypedArray, d = e._loadIndicesForWireframe && !s.context.webgl2, p = e._loadForClassification && o, m = !f, A = f || d || p, b = TMe(e, t, n, i, r ? !1 : m, r ? !0 : A, s).promise.then(function (D) { e.isDestroyed() || (u.indexDatatype = D.indexDatatype, u.buffer = D.buffer, u.typedArray = D.typedArray) }); e._loaderPromises.push(b); let S = new ex.IndicesLoadPlan(u); return S.loadBuffer = m, S.loadTypedArray = A, S } function Tm(e, t, n, i, o, r) { let s = Al.getImageIdFromTexture({ gltf: t, textureId: n.index, supportedImageFormats: i }); if (!l(s)) return; let a = ao.loadTexture({ gltf: t, textureInfo: n, gltfResource: e._gltfResource, baseResource: e._baseResource, supportedImageFormats: i, frameState: o, asynchronous: e._asynchronous }); e._textureLoaders.push(a); let c = Al.createModelTextureReader({ textureInfo: n }), u = a.promise.then(function (f) { e.isUnloaded() || e.isDestroyed() || (c.texture = f.texture, l(r) && (c.texture.sampler = r)) }); return e._texturesPromises.push(u), c } function VMe(e, t, n, i, o) { let r = new gMe, s = y(n.extensions, y.EMPTY_OBJECT), a = s.KHR_materials_pbrSpecularGlossiness, c = n.pbrMetallicRoughness; if (r.unlit = l(s.KHR_materials_unlit), l(a)) { let u = new _Me; r.specularGlossiness = u, l(a.diffuseTexture) && (u.diffuseTexture = Tm(e, t, a.diffuseTexture, i, o)), l(a.specularGlossinessTexture) && l(a.specularGlossinessTexture) && (u.specularGlossinessTexture = Tm(e, t, a.specularGlossinessTexture, i, o)), u.diffuseFactor = du(se, a.diffuseFactor), u.specularFactor = du(h, a.specularFactor), u.glossinessFactor = a.glossinessFactor, r.pbrSpecularGlossiness = a } else if (l(c)) { let u = new pMe; l(c.baseColorTexture) && (u.baseColorTexture = Tm(e, t, c.baseColorTexture, i, o)), l(c.metallicRoughnessTexture) && (u.metallicRoughnessTexture = Tm(e, t, c.metallicRoughnessTexture, i, o)), u.baseColorFactor = du(se, c.baseColorFactor), u.metallicFactor = c.metallicFactor, u.roughnessFactor = c.roughnessFactor, r.metallicRoughness = u } return l(n.emissiveTexture) && (r.emissiveTexture = Tm(e, t, n.emissiveTexture, i, o)), l(n.normalTexture) && !e._loadForClassification && (r.normalTexture = Tm(e, t, n.normalTexture, i, o)), l(n.occlusionTexture) && (r.occlusionTexture = Tm(e, t, n.occlusionTexture, i, o)), r.emissiveFactor = du(h, n.emissiveFactor), r.alphaMode = n.alphaMode, r.alphaCutoff = n.alphaCutoff, r.doubleSided = n.doubleSided, r } function k$(e, t) { let n = new B$; return n.featureCount = e.featureCount, n.nullFeatureId = e.nullFeatureId, n.propertyTableId = e.propertyTable, n.setIndex = e.attribute, n.label = e.label, n.positionalLabel = t, n } function U$(e, t, n, i) { let o = new B$, r = e.featureIds; return o.featureCount = n, o.propertyTableId = t, o.setIndex = F$(r.attribute), o.positionalLabel = i, o } function z$(e, t) { let n = new M$; return n.propertyTableId = e.propertyTable, n.featureCount = e.featureCount, n.nullFeatureId = e.nullFeatureId, n.label = e.label, n.positionalLabel = t, n.offset = 0, n.repeat = 1, n } function H$(e, t, n, i) { let o = new M$, r = e.featureIds; o.propertyTableId = t, o.featureCount = n, o.offset = y(r.constant, 0); let s = y(r.divisor, 0); return o.repeat = s === 0 ? void 0 : s, o.positionalLabel = i, o } function kMe(e, t, n, i, o, r) { let s = new R$; s.featureCount = n.featureCount, s.nullFeatureId = n.nullFeatureId, s.propertyTableId = n.propertyTable, s.label = n.label, s.positionalLabel = r; let a = n.texture; s.textureReader = Tm(e, t, a, i, o, dn.NEAREST); let u = (l(a.channels) ? a.channels : [0]).map(function (f) { return "rgba".charAt(f) }).join(""); return s.textureReader.channels = u, s } function UMe(e, t, n, i, o, r, s, a) { let c = new R$, u = n.featureIds, f = u.texture; return c.featureCount = s, c.propertyTableId = i, c.textureReader = Tm(e, t, f, o, r, dn.NEAREST), c.textureReader.channels = u.channels, c.positionalLabel = a, c } function zMe(e, t, n, i, o, r) { let s = new eMe, a = void 0, c = !1; for (let u in n) if (n.hasOwnProperty(u)) { let f = n[u], d = h8(e, xt, u), p = V$(e, t, f, d, a, c, i, r); s.attributes.push(p.attribute), o.attributePlans.push(p) } return s } function HMe(e, t, n, i, o, r) { let s = new tMe, a = new ex(s); e._primitiveLoadPlans.push(a); let c = n.material; l(c) && (s.material = VMe(e, t, t.materials[c], o, r)); let u = y(n.extensions, y.EMPTY_OBJECT), f = !1, d = u.CESIUM_primitive_outline; e._loadPrimitiveOutline && l(d) && (f = !0, a.needsOutlines = !0, a.outlineIndices = GMe(e, t, d, a)); let p = e._loadForClassification, g = u.KHR_draco_mesh_compression, m = !1, A = n.attributes; if (l(A)) { for (let B in A) if (A.hasOwnProperty(B)) { let R = A[B], M = h8(e, xt, B), L = M.modelSemantic; if (p && !RMe(L)) continue; L === xt.FEATURE_ID && (m = !0); let _ = V$(e, t, R, M, g, i, f, r); a.attributePlans.push(_), s.attributes.push(_.attribute) } } let C = n.targets; if (l(C) && !p) { let B = C.length; for (let R = 0; R < B; ++R)s.morphTargets.push(zMe(e, t, C[R], f, a, r)) } let x = n.indices; if (l(x)) { let B = NMe(e, t, x, g, m, f, r); l(B) && (a.indicesPlan = B, s.indices = B.indices) } let T = u.EXT_structural_metadata, b = u.EXT_mesh_features, S = u.EXT_feature_metadata, D = l(S); l(b) ? WMe(e, t, s, b, o, r) : D && jMe(e, t, s, S, o, r), l(T) ? qMe(s, T) : D && YMe(e, s, S); let P = n.mode; if (p && P !== Oe.TRIANGLES) throw new fe("Only triangle meshes can be used for classification."); return s.primitiveType = P, s } function GMe(e, t, n) { let i = n.indices; return vR(e, t, i, !1) } function WMe(e, t, n, i, o, r) { let s; l(i) && l(i.featureIds) ? s = i.featureIds : s = []; for (let a = 0; a < s.length; a++) { let c = s[a], u = `featureId_${a}`, f; l(c.texture) ? f = kMe(e, t, c, o, r, u) : l(c.attribute) ? f = k$(c, u) : f = z$(c, u), n.featureIds.push(f) } } function jMe(e, t, n, i, o, r) { let s = t.extensions.EXT_feature_metadata.featureTables, a = 0, c = i.featureIdAttributes; if (l(c)) { let f = c.length; for (let d = 0; d < f; ++d) { let p = c[d], g = p.featureTable, m = e._sortedPropertyTableIds.indexOf(g), A = s[g].count, C = `featureId_${a}`; a++; let x; l(p.featureIds.attribute) ? x = U$(p, m, A, C) : x = H$(p, m, A, C), n.featureIds.push(x) } } let u = i.featureIdTextures; if (l(u)) { let f = u.length; for (let d = 0; d < f; ++d) { let p = u[d], g = p.featureTable, m = e._sortedPropertyTableIds.indexOf(g), A = s[g].count, C = `featureId_${a}`; a++; let x = UMe(e, t, p, m, o, r, A, C); n.featureIds.push(x) } } } function qMe(e, t) { !l(t) || (l(t.propertyTextures) && (e.propertyTextureIds = t.propertyTextures), l(t.propertyAttributes) && (e.propertyAttributeIds = t.propertyAttributes)) } function YMe(e, t, n) { l(n.featureTextures) && (t.propertyTextureIds = n.featureTextures.map(function (i) { return e._sortedFeatureTextureIds.indexOf(i) })) } function XMe(e, t, n, i) { let o = n.EXT_mesh_gpu_instancing, r = new nMe, s = o.attributes; if (l(s)) { for (let f in s) if (s.hasOwnProperty(f)) { let d = s[f]; r.attributes.push(FMe(e, t, d, s, f, i)) } } let a = y(o.extensions, y.EMPTY_OBJECT), c = n.EXT_instance_features, u = a.EXT_feature_metadata; return l(c) ? KMe(r, c) : l(u) && JMe(t, r, u, e._sortedPropertyTableIds), r } function KMe(e, t) { let n = t.featureIds; for (let i = 0; i < n.length; i++) { let o = n[i], r = `instanceFeatureId_${i}`, s; l(o.attribute) ? s = k$(o, r) : s = z$(o, r), e.featureIds.push(s) } } function JMe(e, t, n, i) { let o = e.extensions.EXT_feature_metadata.featureTables, r = n.featureIdAttributes; if (l(r)) { let s = r.length; for (let a = 0; a < s; ++a) { let c = r[a], u = c.featureTable, f = i.indexOf(u), d = o[u].count, p = `instanceFeatureId_${a}`, g; l(c.featureIds.attribute) ? g = U$(c, f, d, p) : g = H$(c, f, d, p), t.featureIds.push(g) } } } function ZMe(e, t, n, i, o) { let r = new oMe; r.name = n.name, r.matrix = du(F, n.matrix), r.translation = du(h, n.translation), r.rotation = du(Be, n.rotation), r.scale = du(h, n.scale); let s = y(n.extensions, y.EMPTY_OBJECT), a = s.EXT_mesh_gpu_instancing, c = s.AGI_articulations; if (l(a)) { if (e._loadForClassification) throw new fe("Models with the EXT_mesh_gpu_instancing extension cannot be used for classification."); r.instances = XMe(e, t, s, o) } l(c) && (r.articulationName = c.articulationName); let u = n.mesh; if (l(u)) { let f = t.meshes[u], d = f.primitives, p = d.length; for (let C = 0; C < p; ++C)r.primitives.push(HMe(e, t, d[C], l(r.instances), i, o)); let g = y(n.weights, f.weights), A = r.primitives[0].morphTargets.length; r.morphWeights = l(g) ? g.slice() : new Array(A).fill(0) } return r } function QMe(e, t, n, i) { if (!l(t.nodes)) return []; let o, r, s = t.nodes.length, a = new Array(s); for (o = 0; o < s; ++o) { let c = ZMe(e, t, t.nodes[o], n, i); c.index = o, a[o] = c } for (o = 0; o < s; ++o) { let c = t.nodes[o].children; if (l(c)) { let u = c.length; for (r = 0; r < u; ++r)a[o].children.push(a[c[r]]) } } return a } function $Me(e, t, n, i) { let o = new iMe, r = n.joints, s = r.length, a = new Array(s); for (let u = 0; u < s; ++u)a[u] = i[r[u]]; o.joints = a; let c = n.inverseBindMatrices; return l(c) ? o.inverseBindMatrices = vR(e, t, c) : o.inverseBindMatrices = new Array(s).fill(F.IDENTITY), o } function eLe(e, t, n) { let i = t.skins; if (e._loadForClassification || !l(i)) return []; let o = t.skins.length, r = new Array(o); for (let a = 0; a < o; ++a) { let c = $Me(e, t, t.skins[a], n); c.index = a, r[a] = c } let s = n.length; for (let a = 0; a < s; ++a) { let c = t.nodes[a].skin; l(c) && (n[a].skin = r[c]) } return r } function tLe(e, t, n, i, o, r) { let s = new bR({ gltf: t, extension: n, extensionLegacy: i, gltfResource: e._gltfResource, baseResource: e._baseResource, supportedImageFormats: o, frameState: r, asynchronous: e._asynchronous }); return s.load(), e._structuralMetadataLoader = s, s } function nLe(e, t, n) { let i = new sMe, o = n.input; i.input = vR(e, t, o); let r = n.interpolation; i.interpolation = y(qd[r], qd.LINEAR); let s = n.output; return i.output = vR(e, t, s, !0), i } function iLe(e, t) { let n = new aMe, i = e.node; if (!l(i)) return; n.node = t[i]; let o = e.path.toUpperCase(); return n.path = rMe[o], n } function oLe(e, t, n) { let i = new cMe, o = e.sampler; return i.sampler = t[o], i.target = iLe(e.target, n), i } function rLe(e, t, n, i) { let o, r = new lMe; r.name = n.name; let s = n.samplers, a = s.length, c = new Array(a); for (o = 0; o < a; o++) { let p = nLe(e, t, s[o]); p.index = o, c[o] = p } let u = n.channels, f = u.length, d = new Array(f); for (o = 0; o < f; o++)d[o] = oLe(u[o], c, i); return r.samplers = c, r.channels = d, r } function sLe(e, t, n) { let i = t.animations; if (e._loadForClassification || !l(i)) return []; let o = t.animations.length, r = new Array(o); for (let s = 0; s < o; ++s) { let a = rLe(e, t, t.animations[s], n); a.index = s, r[s] = a } return r } function aLe(e) { let t = new uMe; t.name = e.name; let n = e.type.toUpperCase(); return t.type = rc[n], t.minimumValue = e.minimumValue, t.maximumValue = e.maximumValue, t.initialValue = e.initialValue, t } function cLe(e) { let t = new fMe; t.name = e.name; let n = e.stages, i = n.length, o = new Array(i); for (let r = 0; r < i; r++) { let s = aLe(n[r]); o[r] = s } return t.stages = o, t } function lLe(e) { let n = y(e.extensions, y.EMPTY_OBJECT).AGI_articulations; if (!l(n)) return []; let i = n.articulations; if (!l(i)) return []; let o = i.length, r = new Array(o); for (let s = 0; s < o; s++) { let a = cLe(i[s]); r[s] = a } return r } function uLe(e) { let t; return l(e.scenes) && l(e.scene) && (t = e.scenes[e.scene].nodes), t = y(t, e.nodes), t = l(t) ? t : [], t } function fLe(e, t) { let n = new hMe, i = uLe(e); return n.nodes = i.map(function (o) { return t[o] }), n } var dLe = new h; function hLe(e, t, n, i, o, r) {
        let s = t.asset.version; if (s !== "1.0" && s !== "2.0") {
            let D = e._gltfResource.url; throw new fe(`Failed to load ${D}: 
Unsupported glTF version: ${s}`)
        } let a = t.extensionsRequired; l(a) && (tn.checkSupportedExtensions(a), e._hasKhrMeshQuantization = a.includes("KHR_mesh_quantization")); let c = y(t.extensions, y.EMPTY_OBJECT), u = c.EXT_structural_metadata, f = c.EXT_feature_metadata, d = c.CESIUM_RTC; if (l(f)) { let D = f.featureTables, P = f.featureTextures, B = l(D) ? D : [], R = l(P) ? P : []; e._sortedPropertyTableIds = Object.keys(B).sort(), e._sortedFeatureTextureIds = Object.keys(R).sort() } let p = QMe(e, t, n, i), g = eLe(e, t, p), m = sLe(e, t, p), A = lLe(t), C = fLe(t, p), x = new mMe, T = new dMe, b = t.asset.copyright; if (l(b)) { let D = b.split(";").map(function (P) { return new Xt(P.trim()) }); T.credits = D } if (x.asset = T, x.scene = C, x.nodes = p, x.skins = g, x.animations = m, x.articulations = A, x.upAxis = e._upAxis, x.forwardAxis = e._forwardAxis, l(d)) { let D = h.fromArray(d.center, 0, dLe); x.transform = F.fromTranslation(D, x.transform) } if (e._components = x, l(u) || l(f)) { let P = tLe(e, t, u, f, n, i).promise.then(function (B) { e.isDestroyed() || (x.structuralMetadata = B.structuralMetadata) }); e._loaderPromises.push(P) } let S = []; S.push.apply(S, e._loaderPromises), e._incrementallyLoadTextures || S.push.apply(S, e._texturesPromises), Promise.all(S).then(function () { e.isDestroyed() || (e._state = Jo.POST_PROCESSING) }).catch(o), Promise.all(e._texturesPromises).then(function () { e.isDestroyed() || (e._textureState = Jo.PROCESSED) }).catch(r)
    } function mLe(e) { let t = e._textureLoaders, n = t.length; for (let i = 0; i < n; ++i)ao.unload(t[i]); e._textureLoaders.length = 0 } function G$(e) { let t = e._bufferViewLoaders, n = t.length; for (let i = 0; i < n; ++i)ao.unload(t[i]); e._bufferViewLoaders.length = 0 } function pLe(e) { let t = e._geometryLoaders, n = t.length; for (let i = 0; i < n; ++i)ao.unload(t[i]); e._geometryLoaders.length = 0 } function _Le(e) { let t = e._postProcessBuffers, n = t.length; for (let i = 0; i < n; i++) { let o = t[i]; o.isDestroyed() || o.destroy() } t.length = 0 } function gLe(e) { l(e._structuralMetadataLoader) && (e._structuralMetadataLoader.destroy(), e._structuralMetadataLoader = void 0) } Em.prototype.isUnloaded = function () { return this._state === Jo.UNLOADED }; Em.prototype.unload = function () { l(this._gltfJsonLoader) && ao.unload(this._gltfJsonLoader), this._gltfJsonLoader = void 0, mLe(this), G$(this), pLe(this), _Le(this), gLe(this), this._components = void 0, this._typedArray = void 0, this._state = Jo.UNLOADED }; var h_ = Em; function m8(e, t, n) { let i = e._gl; i.framebufferTexture2D(i.FRAMEBUFFER, t, n._target, n._texture, 0) } function PR(e, t, n) { let i = e._gl; i.framebufferRenderbuffer(i.FRAMEBUFFER, t, i.RENDERBUFFER, n._getRenderbuffer()) } function Tf(e) { e = y(e, y.EMPTY_OBJECT); let n = e.context._gl, i = Ut.maximumColorAttachments; this._gl = n, this._framebuffer = n.createFramebuffer(), this._colorTextures = [], this._colorRenderbuffers = [], this._activeColorAttachments = [], this._depthTexture = void 0, this._depthRenderbuffer = void 0, this._stencilRenderbuffer = void 0, this._depthStencilTexture = void 0, this._depthStencilRenderbuffer = void 0, this.destroyAttachments = y(e.destroyAttachments, !0); let o = l(e.depthTexture) || l(e.depthRenderbuffer), r = l(e.depthStencilTexture) || l(e.depthStencilRenderbuffer); this._bind(); let s, a, c, u, f; if (l(e.colorTextures)) { let d = e.colorTextures; for (u = this._colorTextures.length = this._activeColorAttachments.length = d.length, c = 0; c < u; ++c)s = d[c], f = this._gl.COLOR_ATTACHMENT0 + c, m8(this, f, s), this._activeColorAttachments[c] = f, this._colorTextures[c] = s } if (l(e.colorRenderbuffers)) { let d = e.colorRenderbuffers; for (u = this._colorRenderbuffers.length = this._activeColorAttachments.length = d.length, c = 0; c < u; ++c)a = d[c], f = this._gl.COLOR_ATTACHMENT0 + c, PR(this, f, a), this._activeColorAttachments[c] = f, this._colorRenderbuffers[c] = a } l(e.depthTexture) && (s = e.depthTexture, m8(this, this._gl.DEPTH_ATTACHMENT, s), this._depthTexture = s), l(e.depthRenderbuffer) && (a = e.depthRenderbuffer, PR(this, this._gl.DEPTH_ATTACHMENT, a), this._depthRenderbuffer = a), l(e.stencilRenderbuffer) && (a = e.stencilRenderbuffer, PR(this, this._gl.STENCIL_ATTACHMENT, a), this._stencilRenderbuffer = a), l(e.depthStencilTexture) && (s = e.depthStencilTexture, m8(this, this._gl.DEPTH_STENCIL_ATTACHMENT, s), this._depthStencilTexture = s), l(e.depthStencilRenderbuffer) && (a = e.depthStencilRenderbuffer, PR(this, this._gl.DEPTH_STENCIL_ATTACHMENT, a), this._depthStencilRenderbuffer = a), this._unBind() } Object.defineProperties(Tf.prototype, { status: { get: function () { this._bind(); let e = this._gl.checkFramebufferStatus(this._gl.FRAMEBUFFER); return this._unBind(), e } }, numberOfColorAttachments: { get: function () { return this._activeColorAttachments.length } }, depthTexture: { get: function () { return this._depthTexture } }, depthRenderbuffer: { get: function () { return this._depthRenderbuffer } }, stencilRenderbuffer: { get: function () { return this._stencilRenderbuffer } }, depthStencilTexture: { get: function () { return this._depthStencilTexture } }, depthStencilRenderbuffer: { get: function () { return this._depthStencilRenderbuffer } }, hasDepthAttachment: { get: function () { return !!(this.depthTexture || this.depthRenderbuffer || this.depthStencilTexture || this.depthStencilRenderbuffer) } } }); Tf.prototype._bind = function () { let e = this._gl; e.bindFramebuffer(e.FRAMEBUFFER, this._framebuffer) }; Tf.prototype._unBind = function () { let e = this._gl; e.bindFramebuffer(e.FRAMEBUFFER, null) }; Tf.prototype.bindDraw = function () { let e = this._gl; e.bindFramebuffer(e.DRAW_FRAMEBUFFER, this._framebuffer) }; Tf.prototype.bindRead = function () { let e = this._gl; e.bindFramebuffer(e.READ_FRAMEBUFFER, this._framebuffer) }; Tf.prototype._getActiveColorAttachments = function () { return this._activeColorAttachments }; Tf.prototype.getColorTexture = function (e) { return this._colorTextures[e] }; Tf.prototype.getColorRenderbuffer = function (e) { return this._colorRenderbuffers[e] }; Tf.prototype.isDestroyed = function () { return !1 }; Tf.prototype.destroy = function () { if (this.destroyAttachments) { let e = 0, t = this._colorTextures, n = t.length; for (; e < n; ++e) { let o = t[e]; l(o) && o.destroy() } let i = this._colorRenderbuffers; for (n = i.length, e = 0; e < n; ++e) { let o = i[e]; l(o) && o.destroy() } this._depthTexture = this._depthTexture && this._depthTexture.destroy(), this._depthRenderbuffer = this._depthRenderbuffer && this._depthRenderbuffer.destroy(), this._stencilRenderbuffer = this._stencilRenderbuffer && this._stencilRenderbuffer.destroy(), this._depthStencilTexture = this._depthStencilTexture && this._depthStencilTexture.destroy(), this._depthStencilRenderbuffer = this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy() } return this._gl.deleteFramebuffer(this._framebuffer), le(this) }; var Js = Tf; function tx(e) { e = y(e, y.EMPTY_OBJECT); let t = e.context, n = e.width, i = e.height; this._width = n, this._height = i; let o = e.colorRenderbuffers, r = e.colorTextures; if (l(o) !== l(r)) throw new ye("Both color renderbuffer and texture attachments must be provided."); let s = e.depthStencilRenderbuffer, a = e.depthStencilTexture; if (l(s) !== l(a)) throw new ye("Both depth-stencil renderbuffer and texture attachments must be provided."); this._renderFramebuffer = new Js({ context: t, colorRenderbuffers: o, depthStencilRenderbuffer: s, destroyAttachments: e.destroyAttachments }), this._colorFramebuffer = new Js({ context: t, colorTextures: r, depthStencilTexture: a, destroyAttachments: e.destroyAttachments }) } tx.prototype.getRenderFramebuffer = function () { return this._renderFramebuffer }; tx.prototype.getColorFramebuffer = function () { return this._colorFramebuffer }; tx.prototype.blitFramebuffers = function (e, t) { this._renderFramebuffer.bindRead(), this._colorFramebuffer.bindDraw(); let n = e._gl, i = 0; this._colorFramebuffer._colorTextures.length > 0 && (i |= n.COLOR_BUFFER_BIT), l(this._colorFramebuffer.depthStencilTexture) && (i |= n.DEPTH_BUFFER_BIT | (t ? n.STENCIL_BUFFER_BIT : 0)), n.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, i, n.NEAREST), n.bindFramebuffer(n.READ_FRAMEBUFFER, null), n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null) }; tx.prototype.isDestroyed = function () { return !1 }; tx.prototype.destroy = function () { return this._renderFramebuffer.destroy(), this._colorFramebuffer.destroy(), le(this) }; var IR = tx; var kc = { RGBA4: te.RGBA4, RGBA8: te.RGBA8, RGBA16F: te.RGBA16F, RGBA32F: te.RGBA32F, RGB5_A1: te.RGB5_A1, RGB565: te.RGB565, DEPTH_COMPONENT16: te.DEPTH_COMPONENT16, STENCIL_INDEX8: te.STENCIL_INDEX8, DEPTH_STENCIL: te.DEPTH_STENCIL, DEPTH24_STENCIL8: te.DEPTH24_STENCIL8, validate: function (e) { return e === kc.RGBA4 || e === kc.RGBA8 || e === kc.RGBA16F || e === kc.RGBA32F || e === kc.RGB5_A1 || e === kc.RGB565 || e === kc.DEPTH_COMPONENT16 || e === kc.STENCIL_INDEX8 || e === kc.DEPTH_STENCIL || e === kc.DEPTH24_STENCIL8 }, getColorFormat: function (e) { return e === te.FLOAT ? kc.RGBA32F : e === te.HALF_FLOAT_OES ? kc.RGBA16F : kc.RGBA8 } }, Uc = Object.freeze(kc); function SS(e) { e = y(e, y.EMPTY_OBJECT); let n = e.context._gl, i = Ut.maximumRenderbufferSize, o = y(e.format, Uc.RGBA4), r = l(e.width) ? e.width : n.drawingBufferWidth, s = l(e.height) ? e.height : n.drawingBufferHeight, a = y(e.numSamples, 1); this._gl = n, this._format = o, this._width = r, this._height = s, this._renderbuffer = this._gl.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, this._renderbuffer), a > 1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, a, o, r, s) : n.renderbufferStorage(n.RENDERBUFFER, o, r, s), n.bindRenderbuffer(n.RENDERBUFFER, null) } Object.defineProperties(SS.prototype, { format: { get: function () { return this._format } }, width: { get: function () { return this._width } }, height: { get: function () { return this._height } } }); SS.prototype._getRenderbuffer = function () { return this._renderbuffer }; SS.prototype.isDestroyed = function () { return !1 }; SS.prototype.destroy = function () { return this._gl.deleteRenderbuffer(this._renderbuffer), le(this) }; var hu = SS; function Zr(e) { e = y(e, y.EMPTY_OBJECT), this._numSamples = y(e.numSamples, 1), this._colorAttachmentsLength = y(e.colorAttachmentsLength, 1), this._color = y(e.color, !0), this._depth = y(e.depth, !1), this._depthStencil = y(e.depthStencil, !1), this._supportsDepthTexture = y(e.supportsDepthTexture, !1), this._createColorAttachments = y(e.createColorAttachments, !0), this._createDepthAttachments = y(e.createDepthAttachments, !0), this._pixelDatatype = e.pixelDatatype, this._pixelFormat = e.pixelFormat, this._width = void 0, this._height = void 0, this._framebuffer = void 0, this._multisampleFramebuffer = void 0, this._colorTextures = void 0, this._color && (this._colorTextures = new Array(this._colorAttachmentsLength), this._colorRenderbuffers = new Array(this._colorAttachmentsLength)), this._colorRenderbuffer = void 0, this._depthStencilRenderbuffer = void 0, this._depthStencilTexture = void 0, this._depthRenderbuffer = void 0, this._depthTexture = void 0, this._attachmentsDirty = !1 } Object.defineProperties(Zr.prototype, { framebuffer: { get: function () { return this._numSamples > 1 ? this._multisampleFramebuffer.getRenderFramebuffer() : this._framebuffer } }, numSamples: { get: function () { return this._numSamples } }, status: { get: function () { return this.framebuffer.status } } }); Zr.prototype.isDirty = function (e, t, n, i, o) { n = y(n, 1); let r = this._width !== e || this._height !== t, s = this._numSamples !== n, a = l(i) && this._pixelDatatype !== i || l(o) && this._pixelFormat !== o, c = n === 1 ? l(this._framebuffer) : l(this._multisampleFramebuffer); return this._attachmentsDirty || r || s || a || !c || this._color && !l(this._colorTextures[0]) }; Zr.prototype.update = function (e, t, n, i, o, r) { if (i = e.msaa ? y(i, 1) : 1, o = y(o, this._color ? y(this._pixelDatatype, Ye.UNSIGNED_BYTE) : void 0), r = y(r, this._color ? y(this._pixelFormat, ht.RGBA) : void 0), this.isDirty(t, n, i, o, r)) { if (this.destroy(), this._width = t, this._height = n, this._numSamples = i, this._pixelDatatype = o, this._pixelFormat = r, this._attachmentsDirty = !1, this._color && this._createColorAttachments) { for (let s = 0; s < this._colorAttachmentsLength; ++s)if (this._colorTextures[s] = new Rt({ context: e, width: t, height: n, pixelFormat: r, pixelDatatype: o, sampler: dn.NEAREST }), this._numSamples > 1) { let a = Uc.getColorFormat(o); this._colorRenderbuffers[s] = new hu({ context: e, width: t, height: n, format: a, numSamples: this._numSamples }) } } this._depthStencil && this._createDepthAttachments && (this._supportsDepthTexture && e.depthTexture ? (this._depthStencilTexture = new Rt({ context: e, width: t, height: n, pixelFormat: ht.DEPTH_STENCIL, pixelDatatype: Ye.UNSIGNED_INT_24_8, sampler: dn.NEAREST }), this._numSamples > 1 && (this._depthStencilRenderbuffer = new hu({ context: e, width: t, height: n, format: Uc.DEPTH24_STENCIL8, numSamples: this._numSamples }))) : this._depthStencilRenderbuffer = new hu({ context: e, width: t, height: n, format: Uc.DEPTH_STENCIL })), this._depth && this._createDepthAttachments && (this._supportsDepthTexture && e.depthTexture ? this._depthTexture = new Rt({ context: e, width: t, height: n, pixelFormat: ht.DEPTH_COMPONENT, pixelDatatype: Ye.UNSIGNED_INT, sampler: dn.NEAREST }) : this._depthRenderbuffer = new hu({ context: e, width: t, height: n, format: Uc.DEPTH_COMPONENT16 })), this._numSamples > 1 ? this._multisampleFramebuffer = new IR({ context: e, width: this._width, height: this._height, colorTextures: this._colorTextures, colorRenderbuffers: this._colorRenderbuffers, depthStencilTexture: this._depthStencilTexture, depthStencilRenderbuffer: this._depthStencilRenderbuffer, destroyAttachments: !1 }) : this._framebuffer = new Js({ context: e, colorTextures: this._colorTextures, depthTexture: this._depthTexture, depthRenderbuffer: this._depthRenderbuffer, depthStencilTexture: this._depthStencilTexture, depthStencilRenderbuffer: this._depthStencilRenderbuffer, destroyAttachments: !1 }) } }; Zr.prototype.getColorTexture = function (e) { return e = y(e, 0), this._colorTextures[e] }; Zr.prototype.setColorTexture = function (e, t) { t = y(t, 0), this._attachmentsDirty = e !== this._colorTextures[t], this._colorTextures[t] = e }; Zr.prototype.getColorRenderbuffer = function (e) { return e = y(e, 0), this._colorRenderbuffers[e] }; Zr.prototype.setColorRenderbuffer = function (e, t) { t = y(t, 0), this._attachmentsDirty = e !== this._colorRenderbuffers[t], this._colorRenderbuffers[t] = e }; Zr.prototype.getDepthRenderbuffer = function () { return this._depthRenderbuffer }; Zr.prototype.setDepthRenderbuffer = function (e) { this._attachmentsDirty = e !== this._depthRenderbuffer, this._depthRenderbuffer = e }; Zr.prototype.getDepthTexture = function () { return this._depthTexture }; Zr.prototype.setDepthTexture = function (e) { this._attachmentsDirty = e !== this._depthTexture, this._depthTexture = e }; Zr.prototype.getDepthStencilRenderbuffer = function () { return this._depthStencilRenderbuffer }; Zr.prototype.setDepthStencilRenderbuffer = function (e) { this._attachmentsDirty = e !== this._depthStencilRenderbuffer, this._depthStencilRenderbuffer = e }; Zr.prototype.getDepthStencilTexture = function () { return this._depthStencilTexture }; Zr.prototype.setDepthStencilTexture = function (e) { this._attachmentsDirty = e !== this._depthStencilTexture, this._depthStencilTexture = e }; Zr.prototype.prepareTextures = function (e, t) { this._numSamples > 1 && this._multisampleFramebuffer.blitFramebuffers(e, t) }; Zr.prototype.clear = function (e, t, n) { let i = t.framebuffer; t.framebuffer = this.framebuffer, t.execute(e, n), t.framebuffer = i }; Zr.prototype.destroyFramebuffer = function () { this._framebuffer = this._framebuffer && this._framebuffer.destroy(), this._multisampleFramebuffer = this._multisampleFramebuffer && this._multisampleFramebuffer.destroy() }; Zr.prototype.destroy = function () { if (this._color) { let e, t = this._colorTextures.length; for (e = 0; e < t; ++e) { let n = this._colorTextures[e]; this._createColorAttachments && l(n) && !n.isDestroyed() && (this._colorTextures[e].destroy(), this._colorTextures[e] = void 0), l(n) && n.isDestroyed() && (this._colorTextures[e] = void 0); let i = this._colorRenderbuffers[e]; this._createColorAttachments && l(i) && !i.isDestroyed() && (this._colorRenderbuffers[e].destroy(), this._colorRenderbuffers[e] = void 0), l(i) && i.isDestroyed() && (this._colorRenderbuffers[e] = void 0) } } this._depthStencil && (this._createDepthAttachments && (this._depthStencilTexture = this._depthStencilTexture && this._depthStencilTexture.destroy(), this._depthStencilRenderbuffer = this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy()), l(this._depthStencilTexture) && this._depthStencilTexture.isDestroyed() && (this._depthStencilTexture = void 0), l(this._depthStencilRenderbuffer) && this._depthStencilRenderbuffer.isDestroyed() && (this._depthStencilRenderbuffer = void 0)), this._depth && (this._createDepthAttachments && (this._depthTexture = this._depthTexture && this._depthTexture.destroy(), this._depthRenderbuffer = this._depthRenderbuffer && this._depthRenderbuffer.destroy()), l(this._depthTexture) && this._depthTexture.isDestroyed() && (this._depthTexture = void 0), l(this._depthRenderbuffer) && this._depthRenderbuffer.isDestroyed() && (this._depthRenderbuffer = void 0)), this.destroyFramebuffer() }; var si = Zr; var OR = `#extension GL_EXT_frag_depth : enable
uniform sampler2D u_pointCloud_colorGBuffer;
uniform sampler2D u_pointCloud_depthGBuffer;
uniform vec2 u_distanceAndEdlStrength;
varying vec2 v_textureCoordinates;
vec2 neighborContribution(float log2Depth, vec2 offset)
{
float dist = u_distanceAndEdlStrength.x;
vec2 texCoordOrig = v_textureCoordinates + offset * dist;
vec2 texCoord0 = v_textureCoordinates + offset * floor(dist);
vec2 texCoord1 = v_textureCoordinates + offset * ceil(dist);
float depthOrLogDepth0 = czm_unpackDepth(texture2D(u_pointCloud_depthGBuffer, texCoord0));
float depthOrLogDepth1 = czm_unpackDepth(texture2D(u_pointCloud_depthGBuffer, texCoord1));
if (depthOrLogDepth0 == 0.0 || depthOrLogDepth1 == 0.0) {
return vec2(0.0);
}
float depthMix = mix(depthOrLogDepth0, depthOrLogDepth1, fract(dist));
vec4 eyeCoordinate = czm_windowToEyeCoordinates(texCoordOrig, depthMix);
return vec2(max(0.0, log2Depth - log2(-eyeCoordinate.z / eyeCoordinate.w)), 1.0);
}
void main()
{
float depthOrLogDepth = czm_unpackDepth(texture2D(u_pointCloud_depthGBuffer, v_textureCoordinates));
vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, depthOrLogDepth);
eyeCoordinate /= eyeCoordinate.w;
float log2Depth = log2(-eyeCoordinate.z);
if (depthOrLogDepth == 0.0)
{
discard;
}
vec4 color = texture2D(u_pointCloud_colorGBuffer, v_textureCoordinates);
vec2 texelSize = 1.0 / czm_viewport.zw;
vec2 responseAndCount = vec2(0.0);
responseAndCount += neighborContribution(log2Depth, vec2(-texelSize.x, 0.0));
responseAndCount += neighborContribution(log2Depth, vec2(+texelSize.x, 0.0));
responseAndCount += neighborContribution(log2Depth, vec2(0.0, -texelSize.y));
responseAndCount += neighborContribution(log2Depth, vec2(0.0, +texelSize.y));
float response = responseAndCount.x / responseAndCount.y;
float strength = u_distanceAndEdlStrength.y;
float shade = exp(-response * 300.0 * strength);
color.rgb *= shade;
gl_FragColor = vec4(color);
gl_FragDepthEXT = depthOrLogDepth;
}
`; function nx() { this._framebuffer = new si({ colorAttachmentsLength: 2, depth: !0, supportsDepthTexture: !0 }), this._drawCommand = void 0, this._clearCommand = void 0, this._strength = 1, this._radius = 1 } Object.defineProperties(nx.prototype, { framebuffer: { get: function () { return this._framebuffer.framebuffer } }, colorGBuffer: { get: function () { return this._framebuffer.getColorTexture(0) } }, depthGBuffer: { get: function () { return this._framebuffer.getColorTexture(1) } } }); function yLe(e) { e._framebuffer.destroy(), e._drawCommand = void 0, e._clearCommand = void 0 } var p8 = new H; function ALe(e, t) { let n = new Ue({ defines: ["LOG_DEPTH_WRITE"], sources: [OR] }), i = { u_pointCloud_colorGBuffer: function () { return e.colorGBuffer }, u_pointCloud_depthGBuffer: function () { return e.depthGBuffer }, u_distanceAndEdlStrength: function () { return p8.x = e._radius, p8.y = e._strength, p8 } }, o = Ve.fromCache({ blending: an.ALPHA_BLEND, depthMask: !0, depthTest: { enabled: !0 }, stencilTest: vt.setCesium3DTileBit(), stencilMask: vt.CESIUM_3D_TILE_MASK }); e._drawCommand = t.createViewportQuadCommand(n, { uniformMap: i, renderState: o, pass: xe.CESIUM_3D_TILE, owner: e }), e._clearCommand = new ti({ framebuffer: e.framebuffer, color: new U(0, 0, 0, 0), depth: 1, renderState: Ve.fromCache(), pass: xe.CESIUM_3D_TILE, owner: e }) } function CLe(e, t) { let n = t.drawingBufferWidth, i = t.drawingBufferHeight; e._framebuffer.update(t, n, i), ALe(e, t) } function W$(e) { return e.drawBuffers && e.fragmentDepth } nx.isSupported = W$; function xLe(e, t) {
        let n = e.shaderCache.getDerivedShaderProgram(t, "EC"); if (!l(n)) {
            let i = t._attributeLocations, o = t.fragmentShaderSource.clone(); o.sources = o.sources.map(function (r) { return r = Ue.replaceMain(r, "czm_point_cloud_post_process_main"), r = r.replace(/gl_FragColor/g, "gl_FragData[0]"), r }), o.sources.unshift(`#extension GL_EXT_draw_buffers : enable 
`), o.sources.push(`void main() 
{ 
    czm_point_cloud_post_process_main(); 
#ifdef LOG_DEPTH
    czm_writeLogDepth();
    gl_FragData[1] = czm_packDepth(gl_FragDepthEXT); 
#else
    gl_FragData[1] = czm_packDepth(gl_FragCoord.z);
#endif
}`), n = e.shaderCache.createDerivedShaderProgram(t, "EC", { vertexShaderSource: t.vertexShaderSource, fragmentShaderSource: o, attributeLocations: i })
        } return n
    } nx.prototype.update = function (e, t, n, i) { if (!W$(e.context)) return; this._strength = n.eyeDomeLightingStrength, this._radius = n.eyeDomeLightingRadius * e.pixelRatio, CLe(this, e.context); let o, r = e.commandList, s = r.length; for (o = t; o < s; ++o) { let u = r[o]; if (u.primitiveType !== Oe.POINTS || u.pass === xe.TRANSLUCENT) continue; let f, d, p = u.derivedCommands.pointCloudProcessor; l(p) && (f = p.command, d = p.originalShaderProgram), (!l(f) || u.dirty || d !== u.shaderProgram || f.framebuffer !== this.framebuffer) && (f = $e.shallowClone(u, f), f.framebuffer = this.framebuffer, f.shaderProgram = xLe(e.context, u.shaderProgram), f.castShadows = !1, f.receiveShadows = !1, l(p) || (p = { command: f, originalShaderProgram: u.shaderProgram }, u.derivedCommands.pointCloudProcessor = p), p.originalShaderProgram = u.shaderProgram), r[o] = f } let a = this._clearCommand, c = this._drawCommand; c.boundingVolume = i, r.push(c), r.push(a) }; nx.prototype.isDestroyed = function () { return !1 }; nx.prototype.destroy = function () { return yLe(this), le(this) }; var m_ = nx; function j$(e) { let t = y(e, {}); this.attenuation = y(t.attenuation, !1), this.geometricErrorScale = y(t.geometricErrorScale, 1), this.maximumAttenuation = t.maximumAttenuation, this.baseResolution = t.baseResolution, this.eyeDomeLighting = y(t.eyeDomeLighting, !0), this.eyeDomeLightingStrength = y(t.eyeDomeLightingStrength, 1), this.eyeDomeLightingRadius = y(t.eyeDomeLightingRadius, 1), this.backFaceCulling = y(t.backFaceCulling, !1), this.normalShading = y(t.normalShading, !0) } j$.isSupported = function (e) { return m_.isSupported(e.context) }; var bm = j$; var Zs = {}, TLe = new se(0, 0, 0, 1), wa = new se, ELe = new Ge, _8 = new H, g8 = new H; Zs.wgs84ToWindowCoordinates = function (e, t, n) { return Zs.wgs84WithEyeOffsetToWindowCoordinates(e, t, h.ZERO, n) }; var q$ = new se, Y$ = new h; function wS(e, t, n, i) { let o = n.viewMatrix, r = F.multiplyByVector(o, se.fromElements(e.x, e.y, e.z, 1, q$), q$), s = h.multiplyComponents(t, h.normalize(r, Y$), Y$); return r.x += t.x + s.x, r.y += t.y + s.y, r.z += s.z, F.multiplyByVector(n.frustum.projectionMatrix, r, i) } var bLe = new he(Math.PI, I.PI_OVER_TWO), SLe = new h, wLe = new h; Zs.wgs84WithEyeOffsetToWindowCoordinates = function (e, t, n, i) { let o = e.frameState, r = Zs.computeActualWgs84Position(o, t, TLe); if (!l(r)) return; let s = e.canvas, a = ELe; a.x = 0, a.y = 0, a.width = s.clientWidth, a.height = s.clientHeight; let c = e.camera, u = !1; if (o.mode === ee.SCENE2D) { let f = e.mapProjection, d = bLe, p = f.project(d, SLe), g = h.clone(c.position, wLe), m = c.frustum.clone(), A = F.computeViewportTransformation(a, 0, 1, new F), C = c.frustum.projectionMatrix, x = c.positionWC.y, T = h.fromElements(I.sign(x) * p.x - x, 0, -c.positionWC.x), b = It.pointToGLWindowCoordinates(C, A, T); if (x === 0 || b.x <= 0 || b.x >= s.clientWidth) u = !0; else { if (b.x > s.clientWidth * .5) { a.width = b.x, c.frustum.right = p.x - x, wa = wS(r, n, c, wa), Zs.clipToGLWindowCoordinates(a, wa, _8), a.x += b.x, c.position.x = -c.position.x; let S = c.frustum.right; c.frustum.right = -c.frustum.left, c.frustum.left = -S, wa = wS(r, n, c, wa), Zs.clipToGLWindowCoordinates(a, wa, g8) } else { a.x += b.x, a.width -= b.x, c.frustum.left = -p.x - x, wa = wS(r, n, c, wa), Zs.clipToGLWindowCoordinates(a, wa, _8), a.x = a.x - a.width, c.position.x = -c.position.x; let S = c.frustum.left; c.frustum.left = -c.frustum.right, c.frustum.right = -S, wa = wS(r, n, c, wa), Zs.clipToGLWindowCoordinates(a, wa, g8) } h.clone(g, c.position), c.frustum = m.clone(), i = H.clone(_8, i), (i.x < 0 || i.x > s.clientWidth) && (i.x = g8.x) } } if (o.mode !== ee.SCENE2D || u) { if (wa = wS(r, n, c, wa), wa.z < 0 && !(c.frustum instanceof Zt) && !(c.frustum instanceof wr)) return; i = Zs.clipToGLWindowCoordinates(a, wa, i) } return i.y = s.clientHeight - i.y, i }; Zs.wgs84ToDrawingBufferCoordinates = function (e, t, n) { if (n = Zs.wgs84ToWindowCoordinates(e, t, n), !!l(n)) return Zs.transformWindowToDrawingBuffer(e, n, n) }; var Sm = new h, DLe = new he; Zs.computeActualWgs84Position = function (e, t, n) { let i = e.mode; if (i === ee.SCENE3D) return h.clone(t, n); let o = e.mapProjection, r = o.ellipsoid.cartesianToCartographic(t, DLe); if (!l(r)) return; if (o.project(r, Sm), i === ee.COLUMBUS_VIEW) return h.fromElements(Sm.z, Sm.x, Sm.y, n); if (i === ee.SCENE2D) return h.fromElements(0, Sm.x, Sm.y, n); let s = e.morphTime; return h.fromElements(I.lerp(Sm.z, t.x, s), I.lerp(Sm.x, t.y, s), I.lerp(Sm.y, t.z, s), n) }; var X$ = new h, K$ = new h, J$ = new F; Zs.clipToGLWindowCoordinates = function (e, t, n) { return h.divideByScalar(t, t.w, X$), F.computeViewportTransformation(e, 0, 1, J$), F.multiplyByPoint(J$, X$, K$), H.fromCartesian3(K$, n) }; Zs.transformWindowToDrawingBuffer = function (e, t, n) { let i = e.canvas, o = e.drawingBufferWidth / i.clientWidth, r = e.drawingBufferHeight / i.clientHeight; return H.fromElements(t.x * o, t.y * r, n) }; var vLe = new se, Z$ = new se; Zs.drawingBufferToWgs84Coordinates = function (e, t, n, i) { let r = e.context.uniformState, s = r.currentFrustum, a = s.x, c = s.y; if (e.frameState.useLogDepth) { let g = n * r.log2FarDepthFromNearPlusOne, m = Math.pow(2, g) - 1; n = c * (1 - a / (m + a)) / (c - a) } let u = e.view.passState.viewport, f = se.clone(se.UNIT_W, vLe); f.x = (t.x - u.x) / u.width * 2 - 1, f.y = (t.y - u.y) / u.height * 2 - 1, f.z = n * 2 - 1, f.w = 1; let d, p = e.camera.frustum; if (!l(p.fovy)) l(p._offCenterFrustum) && (p = p._offCenterFrustum), d = Z$, d.x = (f.x * (p.right - p.left) + p.left + p.right) * .5, d.y = (f.y * (p.top - p.bottom) + p.bottom + p.top) * .5, d.z = (f.z * (a - c) - a - c) * .5, d.w = 1, d = F.multiplyByVector(r.inverseView, d, d); else { d = F.multiplyByVector(r.inverseViewProjection, f, Z$); let g = 1 / d.w; h.multiplyByScalar(d, g, d) } return h.fromCartesian4(d, i) }; var ji = Zs; var PLe = { LEFT: -1, NONE: 0, RIGHT: 1 }, zc = Object.freeze(PLe); var ix = {}; ix._deprecationWarning = Jr; var wm = Uint32Array.BYTES_PER_ELEMENT; ix.parse = function (e, t) { let n = y(t, 0); t = n; let i = new Uint8Array(e), o = new DataView(e); t += wm; let r = o.getUint32(t, !0); if (r !== 1) throw new fe(`Only Batched 3D Model version 1 is supported.  Version ${r} is not.`); t += wm; let s = o.getUint32(t, !0); t += wm; let a = o.getUint32(t, !0); t += wm; let c = o.getUint32(t, !0); t += wm; let u = o.getUint32(t, !0); t += wm; let f = o.getUint32(t, !0); t += wm; let d; u >= 570425344 ? (t -= wm * 2, d = a, u = c, f = 0, a = 0, c = 0, ix._deprecationWarning("b3dm-legacy-header", "This b3dm header is using the legacy format [batchLength] [batchTableByteLength]. The new format is [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength] from https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel.")) : f >= 570425344 && (t -= wm, d = u, u = a, f = c, a = 0, c = 0, ix._deprecationWarning("b3dm-legacy-header", "This b3dm header is using the legacy format [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]. The new format is [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength] from https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel.")); let p; a === 0 ? p = { BATCH_LENGTH: y(d, 0) } : (p = Ko(i, t, a), t += a); let g = new Uint8Array(e, t, c); t += c; let m, A; u > 0 && (m = Ko(i, t, u), t += u, f > 0 && (A = new Uint8Array(e, t, f), A = new Uint8Array(A), t += f)); let C = n + s - t; if (C === 0) throw new fe("glTF byte length must be greater than 0."); let x; return t % 4 === 0 ? x = new Uint8Array(e, t, C) : (ix._deprecationWarning("b3dm-glb-unaligned", "The embedded glb is not aligned to a 4-byte boundary."), x = new Uint8Array(i.subarray(t, t + C))), { batchLength: d, featureTableJson: p, featureTableBinary: g, batchTableJson: m, batchTableBinary: A, gltf: x } }; var BR = ix; function DS(e, t) { this.json = e, this.buffer = t, this._cachedTypedArrays = {}, this.featuresLength = 0 } function Q$(e, t, n, i, o, r) { let s = e._cachedTypedArrays, a = s[t]; return l(a) || (a = Y.createArrayBufferView(n, e.buffer.buffer, e.buffer.byteOffset + r, o * i), s[t] = a), a } function ILe(e, t, n, i) { let o = e._cachedTypedArrays, r = o[t]; return l(r) || (r = Y.createTypedArray(n, i), o[t] = r), r } DS.prototype.getGlobalProperty = function (e, t, n) { let i = this.json[e]; if (!!l(i)) return l(i.byteOffset) ? (t = y(t, Y.UNSIGNED_INT), n = y(n, 1), Q$(this, e, t, n, 1, i.byteOffset)) : i }; DS.prototype.hasProperty = function (e) { return l(this.json[e]) }; DS.prototype.getPropertyArray = function (e, t, n) { let i = this.json[e]; if (!!l(i)) return l(i.byteOffset) ? (l(i.componentType) && (t = Y.fromName(i.componentType)), Q$(this, e, t, n, this.featuresLength, i.byteOffset)) : ILe(this, e, t, i) }; DS.prototype.getProperty = function (e, t, n, i, o) { let r = this.json[e]; if (!l(r)) return; let s = this.getPropertyArray(e, t, n); if (n === 1) return s[i]; for (let a = 0; a < n; ++a)o[a] = s[n * i + a]; return o }; var Yd = DS; function y8(e) { let t = e.count, n = e.batchTable, i = e.binaryBody, o = y(e.parseAsPropertyAttributes, !1), r = e.customAttributeOutput, s = OLe(n), a; l(s.jsonProperties) && (a = new f_({ count: t, properties: s.jsonProperties })); let c; l(s.hierarchy) && (c = new UC({ extension: s.hierarchy, binaryBody: i })); let u = Wd.BATCH_TABLE_CLASS_NAME, f = s.binaryProperties, d, p, g; if (o) { let C = RLe(t, u, f, i, r); g = C.transcodedSchema, p = [new ZC({ propertyAttribute: C.propertyAttributeJson, class: C.transcodedClass })] } else { let C = BLe(t, u, f, i); g = C.transcodedSchema; let x = C.featureTableJson; d = new Af({ count: x.count, properties: x.properties, class: C.transcodedClass, bufferViews: C.bufferViewsTypedArrays }), p = [] } let m = []; if (l(d) || l(a) || l(c)) { let C = new Vc({ id: 0, name: "Batch Table", count: t, metadataTable: d, jsonMetadataTable: a, batchTableHierarchy: c }); m.push(C) } let A = { schema: g, propertyTables: m, propertyAttributes: p, extensions: s.extensions, extras: s.extras }; return new ba(A) } function OLe(e) { let t = e.HIERARCHY, n = e.extras, i = e.extensions, o; l(t) ? (y8._deprecationWarning("batchTableHierarchyExtension", "The batch table HIERARCHY property has been moved to an extension. Use extensions.3DTILES_batch_table_hierarchy instead."), o = t) : l(i) && (o = i["3DTILES_batch_table_hierarchy"]); let r, s = {}; for (let a in e) { if (!e.hasOwnProperty(a) || a === "HIERARCHY" || a === "extensions" || a === "extras") continue; let c = e[a]; Array.isArray(c) ? (r = l(r) ? r : {}, r[a] = c) : s[a] = c } return { binaryProperties: s, jsonProperties: r, hierarchy: o, extras: n, extensions: i } } function BLe(e, t, n, i) { let o = {}, r = {}, s = {}, a = 0; for (let d in n) { if (!n.hasOwnProperty(d)) continue; if (!l(i)) throw new fe(`Property ${d} requires a batch table binary.`); let p = n[d], g = cu(p); r[d] = { bufferView: a }, o[d] = $$(p), s[a] = g.createArrayBufferView(i.buffer, i.byteOffset + p.byteOffset, e), a++ } let c = { classes: {} }; c.classes[t] = { properties: o }; let u = new jd(c); return { featureTableJson: { class: t, count: e, properties: r }, bufferViewsTypedArrays: s, transcodedSchema: u, transcodedClass: u.classes[t] } } function RLe(e, t, n, i, o) { let r = {}, s = {}, a = 0; for (let d in n) { if (!n.hasOwnProperty(d)) continue; let p = n[d]; if (!l(i) && !l(p.typedArray)) throw new fe(`Property ${d} requires a batch table binary.`); let g = tn.sanitizeGlslIdentifier(d); (g === "" || r.hasOwnProperty(g)) && (g = `property_${a}`, a++); let m = $$(p); m.name = d, r[g] = m; let A = g.toUpperCase(); A.startsWith("_") || (A = `_${A}`); let C = p.typedArray; l(C) || (C = cu(p).createArrayBufferView(i.buffer, i.byteOffset + p.byteOffset, e)); let x = new Dt.Attribute; x.name = A, x.count = e, x.type = p.type, x.componentDatatype = Y.fromTypedArray(C), x.typedArray = C, o.push(x), s[g] = { attribute: A } } let c = { classes: {} }; c.classes[t] = { properties: r }; let u = new jd(c); return { class: t, propertyAttributeJson: { properties: s }, transcodedSchema: u, transcodedClass: u.classes[t] } } function $$(e) { let t = MLe(e.componentType); return { type: e.type, componentType: t } } function MLe(e) { switch (e) { case "BYTE": return "INT8"; case "UNSIGNED_BYTE": return "UINT8"; case "SHORT": return "INT16"; case "UNSIGNED_SHORT": return "UINT16"; case "INT": return "INT32"; case "UNSIGNED_INT": return "UINT32"; case "FLOAT": return "FLOAT32"; case "DOUBLE": return "FLOAT64" } } y8._deprecationWarning = Jr; var p_ = y8; var U0 = { UNLOADED: 0, LOADING: 1, PROCESSING: 2, READY: 3, FAILED: 4 }, LLe = Dt.FeatureIdAttribute; function __(e) { e = y(e, y.EMPTY_OBJECT); let t = e.b3dmResource, n = e.baseResource, i = e.arrayBuffer, o = y(e.byteOffset, 0), r = y(e.releaseGltfJson, !1), s = y(e.asynchronous, !0), a = y(e.incrementallyLoadTextures, !0), c = y(e.upAxis, Do.Y), u = y(e.forwardAxis, Do.X), f = y(e.loadAttributesAsTypedArray, !1), d = y(e.loadAttributesFor2D, !1), p = y(e.loadIndicesForWireframe, !1), g = y(e.loadPrimitiveOutline, !0), m = y(e.loadForClassification, !1); n = l(n) ? n : t.clone(), this._b3dmResource = t, this._baseResource = n, this._arrayBuffer = i, this._byteOffset = o, this._releaseGltfJson = r, this._asynchronous = s, this._incrementallyLoadTextures = a, this._upAxis = c, this._forwardAxis = u, this._loadAttributesAsTypedArray = f, this._loadAttributesFor2D = d, this._loadIndicesForWireframe = p, this._loadPrimitiveOutline = g, this._loadForClassification = m, this._state = U0.UNLOADED, this._promise = void 0, this._gltfLoader = void 0, this._batchLength = 0, this._propertyTable = void 0, this._batchTable = void 0, this._components = void 0, this._transform = F.IDENTITY } l(Object.create) && (__.prototype = Object.create(Zi.prototype), __.prototype.constructor = __); Object.defineProperties(__.prototype, { promise: { get: function () { return this._promise } }, texturesLoadedPromise: { get: function () { return this._gltfLoader.texturesLoadedPromise } }, cacheKey: { get: function () { } }, components: { get: function () { return this._components } } }); __.prototype.load = function () { let e = BR.parse(this._arrayBuffer, this._byteOffset), t = e.batchLength, n = e.featureTableJson, i = e.featureTableBinary, o = e.batchTableJson, r = e.batchTableBinary, s = new Yd(n, i); t = s.getGlobalProperty("BATCH_LENGTH"), this._batchLength = t; let a = s.getGlobalProperty("RTC_CENTER", Y.FLOAT, 3); l(a) && (this._transform = F.fromTranslation(h.fromArray(a))), this._batchTable = { json: o, binary: r }; let c = new h_({ typedArray: e.gltf, upAxis: this._upAxis, forwardAxis: this._forwardAxis, gltfResource: this._b3dmResource, baseResource: this._baseResource, releaseGltfJson: this._releaseGltfJson, incrementallyLoadTextures: this._incrementallyLoadTextures, loadAttributesAsTypedArray: this._loadAttributesAsTypedArray, loadAttributesFor2D: this._loadAttributesFor2D, loadIndicesForWireframe: this._loadIndicesForWireframe, loadPrimitiveOutline: this._loadPrimitiveOutline, loadForClassification: this._loadForClassification, renameBatchIdSemantic: !0 }); this._gltfLoader = c, this._state = U0.LOADING; let u = this; return c.load(), this._promise = c.promise.then(function () { if (u.isDestroyed()) return; let f = c.components; return f.transform = F.multiplyTransformation(u._transform, f.transform, f.transform), NLe(u, f), u._components = f, u._arrayBuffer = void 0, u._state = U0.READY, u }).catch(function (f) { if (!u.isDestroyed()) return FLe(u, f) }), this._promise }; function FLe(e, t) { e.unload(), e._state = U0.FAILED; let n = "Failed to load b3dm"; return t = e.getError(n, t), Promise.reject(t) } __.prototype.process = function (e) { this._state === U0.LOADING && (this._state = U0.PROCESSING), this._state === U0.PROCESSING && this._gltfLoader.process(e) }; function NLe(e, t) { let n = e._batchTable, i = e._batchLength; if (i === 0) return; let o; if (l(n.json)) o = p_({ count: i, batchTable: n.json, binaryBody: n.binary }); else { let a = new Vc({ name: Wd.BATCH_TABLE_CLASS_NAME, count: i }); o = new ba({ schema: {}, propertyTables: [a] }) } let r = t.scene.nodes, s = r.length; for (let a = 0; a < s; a++)eee(r[a]); t.structuralMetadata = o } function eee(e) { let t = e.children.length; for (let i = 0; i < t; i++)eee(e.children[i]); let n = e.primitives.length; for (let i = 0; i < n; i++) { let o = e.primitives[i], r = tn.getAttributeBySemantic(o, xt.FEATURE_ID); if (l(r)) { r.setIndex = 0; let s = new LLe; s.propertyTableId = 0, s.setIndex = 0, s.positionalLabel = "featureId_0", o.featureIds.push(s) } } } __.prototype.unload = function () { l(this._gltfLoader) && this._gltfLoader.unload(), this._components = void 0, this._arrayBuffer = void 0 }; var RR = __; function g_(e) { e = y(e, y.EMPTY_OBJECT), this._geoJson = e.geoJson, this._promise = void 0, this._process = function (t, n) { }, this._components = void 0 } l(Object.create) && (g_.prototype = Object.create(Zi.prototype), g_.prototype.constructor = g_); Object.defineProperties(g_.prototype, { promise: { get: function () { return this._promise } }, cacheKey: { get: function () { } }, components: { get: function () { return this._components } } }); g_.prototype.load = function () { let e = this, t = new Promise(function (n) { e._process = function (i, o) { l(i._components) || (i._components = JLe(i._geoJson, o), i._geoJson = void 0, n(i)) } }); return this._promise = t, t }; g_.prototype.process = function (e) { this._process(this, e) }; function VLe() { this.lines = void 0, this.points = void 0, this.properties = void 0 } function kLe() { this.features = [] } function A8(e) { let t = e[0], n = e[1], i = y(e[2], 0); return new h(t, n, i) } function C8(e) { let t = e.length, n = new Array(t); for (let o = 0; o < t; o++)n[o] = A8(e[o]); return [n] } function ULe(e) { let t = e.length, n = new Array(t); for (let i = 0; i < t; i++)n[i] = C8(e[i])[0]; return n } function tee(e) { let t = e.length, n = new Array(t); for (let i = 0; i < t; i++)n[i] = C8(e[i])[0]; return n } function zLe(e) { let t = e.length, n = []; for (let i = 0; i < t; i++)Array.prototype.push.apply(n, tee(e[i])); return n } function HLe(e) { return [A8(e)] } function GLe(e) { let t = e.length, n = new Array(t); for (let i = 0; i < t; i++)n[i] = A8(e[i]); return n } var WLe = { LineString: C8, MultiLineString: ULe, MultiPolygon: zLe, Polygon: tee, MultiPoint: GLe, Point: HLe }, jLe = { LineString: Oe.LINES, MultiLineString: Oe.LINES, MultiPolygon: Oe.LINES, Polygon: Oe.LINES, MultiPoint: Oe.POINTS, Point: Oe.POINTS }; function nee(e, t) { if (!l(e.geometry)) return; let n = e.geometry.type, i = WLe[n], o = jLe[n], r = e.geometry.coordinates; if (!l(i) || !l(r)) return; let s = new VLe; o === Oe.LINES ? s.lines = i(r) : o === Oe.POINTS && (s.points = i(r)), s.properties = e.properties, t.features.push(s) } function qLe(e, t) { let n = e.features, i = n.length; for (let o = 0; o < i; o++)nee(n[o], t) } var YLe = { FeatureCollection: qLe, Feature: nee }, MR = new h; function XLe(e, t, n) { let i = 0, o = 0, r = e.length; for (let M = 0; M < r; M++) { let L = e[M]; if (l(L.lines)) { let _ = L.lines.length; for (let E = 0; E < _; E++) { let w = L.lines[E]; i += w.length, o += (w.length - 1) * 2 } } } let s = new Float32Array(i * 3), a = new Float32Array(i), c = Me.createTypedArray(i, o), u = Me.fromTypedArray(c), f = new h(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), d = new h(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY), p = 0, g = 0; for (let M = 0; M < r; M++) { let L = e[M]; if (!l(L.lines)) continue; let _ = L.lines.length; for (let E = 0; E < _; E++) { let w = L.lines[E], v = w.length; for (let O = 0; O < v; O++) { let V = w[O], z = h.fromDegrees(V.x, V.y, V.z, ie.WGS84, MR), k = F.multiplyByPoint(t, z, MR); h.minimumByComponent(f, k, f), h.maximumByComponent(d, k, d), h.pack(k, s, p * 3), a[p] = M, O < v - 1 && (c[g * 2] = p, c[g * 2 + 1] = p + 1, g++), p++ } } } let m = ct.createVertexBuffer({ typedArray: s, context: n.context, usage: Re.STATIC_DRAW }); m.vertexArrayDestroyable = !1; let A = ct.createVertexBuffer({ typedArray: a, context: n.context, usage: Re.STATIC_DRAW }); A.vertexArrayDestroyable = !1; let C = ct.createIndexBuffer({ typedArray: c, context: n.context, usage: Re.STATIC_DRAW, indexDatatype: u }); C.vertexArrayDestroyable = !1; let x = new Dt.Attribute; x.semantic = xt.POSITION, x.componentDatatype = Y.FLOAT, x.type = en.VEC3, x.count = i, x.min = f, x.max = d, x.buffer = m; let T = new Dt.Attribute; T.semantic = xt.FEATURE_ID, T.setIndex = 0, T.componentDatatype = Y.FLOAT, T.type = en.SCALAR, T.count = i, T.buffer = A; let b = [x, T], S = new Dt.Material; S.unlit = !0; let D = new Dt.Indices; D.indexDatatype = u, D.count = c.length, D.buffer = C; let P = new Dt.FeatureIdAttribute; P.featureCount = r, P.propertyTableId = 0, P.setIndex = 0, P.positionalLabel = "featureId_0"; let B = [P], R = new Dt.Primitive; return R.attributes = b, R.indices = D, R.featureIds = B, R.primitiveType = Oe.LINES, R.material = S, R } function KLe(e, t, n) { let i = 0, o = e.length; for (let b = 0; b < o; b++) { let S = e[b]; l(S.points) && (i += S.points.length) } let r = new Float32Array(i * 3), s = new Float32Array(i), a = new h(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), c = new h(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY), u = 0; for (let b = 0; b < o; b++) { let S = e[b]; if (!l(S.points)) continue; let D = S.points.length; for (let P = 0; P < D; P++) { let B = S.points[P], R = h.fromDegrees(B.x, B.y, B.z, ie.WGS84, MR), M = F.multiplyByPoint(t, R, MR); h.minimumByComponent(a, M, a), h.maximumByComponent(c, M, c), h.pack(M, r, u * 3), s[u] = b, u++ } } let f = ct.createVertexBuffer({ typedArray: r, context: n.context, usage: Re.STATIC_DRAW }); f.vertexArrayDestroyable = !1; let d = ct.createVertexBuffer({ typedArray: s, context: n.context, usage: Re.STATIC_DRAW }); d.vertexArrayDestroyable = !1; let p = new Dt.Attribute; p.semantic = xt.POSITION, p.componentDatatype = Y.FLOAT, p.type = en.VEC3, p.count = i, p.min = a, p.max = c, p.buffer = f; let g = new Dt.Attribute; g.semantic = xt.FEATURE_ID, g.setIndex = 0, g.componentDatatype = Y.FLOAT, g.type = en.SCALAR, g.count = i, g.buffer = d; let m = [p, g], A = new Dt.Material; A.unlit = !0; let C = new Dt.FeatureIdAttribute; C.featureCount = o, C.propertyTableId = 0, C.setIndex = 0, C.positionalLabel = "featureId_0"; let x = [C], T = new Dt.Primitive; return T.attributes = m, T.featureIds = x, T.primitiveType = Oe.POINTS, T.material = A, T } function JLe(e, t) { let n = new kLe, i = YLe[e.type]; l(i) && i(e, n); let o = n.features, r = o.length; if (r === 0) throw new fe("GeoJSON must have at least one feature"); let s = {}; for (let M = 0; M < r; M++) { let L = o[M], _ = y(L.properties, y.EMPTY_OBJECT); for (let E in _) _.hasOwnProperty(E) && (l(s[E]) || (s[E] = new Array(r))) } for (let M = 0; M < r; M++) { let L = o[M]; for (let _ in s) if (s.hasOwnProperty(_)) { let E = y(L.properties[_], ""); s[_][M] = E } } let a = new f_({ count: r, properties: s }), u = [new Vc({ id: 0, count: r, jsonMetadataTable: a })], f = new jd({}), d = new ba({ schema: f, propertyTables: u }), p = new h(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), g = new h(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY), m = !1, A = !1; for (let M = 0; M < r; M++) { let L = o[M]; if (l(L.lines)) { m = !0; let _ = L.lines.length; for (let E = 0; E < _; E++) { let w = L.lines[E], v = w.length; for (let O = 0; O < v; O++)h.minimumByComponent(p, w[O], p), h.maximumByComponent(g, w[O], g) } } if (l(L.points)) { A = !0; let _ = L.points.length; for (let E = 0; E < _; E++) { let w = L.points[E]; h.minimumByComponent(p, w, p), h.maximumByComponent(g, w, g) } } } let C = h.midpoint(p, g, new h), x = h.fromDegrees(C.x, C.y, C.z, ie.WGS84, new h), T = It.eastNorthUpToFixedFrame(x, ie.WGS84, new F), b = F.inverseTransformation(T, new F), S = []; m && S.push(XLe(o, b, t)), A && S.push(KLe(o, b, t)); let D = new Dt.Node; D.index = 0, D.primitives = S; let P = [D], B = new Dt.Scene; B.nodes = P; let R = new Dt.Components; return R.scene = B, R.nodes = P, R.transform = T, R.structuralMetadata = d, R } g_.prototype.unload = function () { this._components = void 0 }; var LR = g_; var FR = {}; FR._deprecationWarning = Jr; var y_ = Uint32Array.BYTES_PER_ELEMENT; FR.parse = function (e, t) { let n = y(t, 0); t = n; let i = new Uint8Array(e), o = new DataView(e); t += y_; let r = o.getUint32(t, !0); if (r !== 1) throw new fe(`Only Instanced 3D Model version 1 is supported. Version ${r} is not.`); t += y_; let s = o.getUint32(t, !0); t += y_; let a = o.getUint32(t, !0); if (a === 0) throw new fe("featureTableJsonByteLength is zero, the feature table must be defined."); t += y_; let c = o.getUint32(t, !0); t += y_; let u = o.getUint32(t, !0); t += y_; let f = o.getUint32(t, !0); t += y_; let d = o.getUint32(t, !0); if (d !== 1 && d !== 0) throw new fe(`Only glTF format 0 (uri) or 1 (embedded) are supported. Format ${d} is not.`); t += y_; let p = Ko(i, t, a); t += a; let g = new Uint8Array(e, t, c); t += c; let m, A; u > 0 && (m = Ko(i, t, u), t += u, f > 0 && (A = new Uint8Array(e, t, f), A = new Uint8Array(A), t += f)); let C = n + s - t; if (C === 0) throw new fe("glTF byte length must be greater than 0."); let x; return t % 4 === 0 ? x = new Uint8Array(e, t, C) : (FR._deprecationWarning("i3dm-glb-unaligned", "The embedded glb is not aligned to a 4-byte boundary."), x = new Uint8Array(i.subarray(t, t + C))), { gltfFormat: d, featureTableJson: p, featureTableBinary: g, batchTableJson: m, batchTableBinary: A, gltf: x } }; var NR = FR; var Ef = { NOT_LOADED: 0, LOADING: 1, PROCESSING: 2, POST_PROCESSING: 3, READY: 4, FAILED: 5, UNLOADED: 6 }, VR = Dt.Attribute, ZLe = Dt.FeatureIdAttribute, oee = Dt.Instances; function Dm(e) { e = y(e, y.EMPTY_OBJECT); let t = e.i3dmResource, n = e.arrayBuffer, i = e.baseResource, o = y(e.byteOffset, 0), r = y(e.releaseGltfJson, !1), s = y(e.asynchronous, !0), a = y(e.incrementallyLoadTextures, !0), c = y(e.upAxis, Do.Y), u = y(e.forwardAxis, Do.X), f = y(e.loadAttributesAsTypedArray, !1), d = y(e.loadIndicesForWireframe, !1), p = y(e.loadPrimitiveOutline, !0); i = l(i) ? i : t.clone(), this._i3dmResource = t, this._baseResource = i, this._arrayBuffer = n, this._byteOffset = o, this._releaseGltfJson = r, this._asynchronous = s, this._incrementallyLoadTextures = a, this._upAxis = c, this._forwardAxis = u, this._loadAttributesAsTypedArray = f, this._loadIndicesForWireframe = d, this._loadPrimitiveOutline = p, this._state = Ef.NOT_LOADED, this._promise = void 0, this._gltfLoader = void 0, this._gltfLoaderPromise = void 0, this._process = function (g, m) { }, this._postProcess = function (g, m) { }, this._buffers = [], this._components = void 0, this._transform = F.IDENTITY, this._batchTable = void 0, this._featureTable = void 0, this._instancesLength = 0 } l(Object.create) && (Dm.prototype = Object.create(Zi.prototype), Dm.prototype.constructor = Dm); Object.defineProperties(Dm.prototype, { promise: { get: function () { return this._promise } }, texturesLoadedPromise: { get: function () { return this._gltfLoader.texturesLoadedPromise } }, cacheKey: { get: function () { } }, components: { get: function () { return this._components } } }); Dm.prototype.load = function () { let e = NR.parse(this._arrayBuffer, this._byteOffset), t = e.featureTableJson, n = e.featureTableBinary, i = e.batchTableJson, o = e.batchTableBinary, r = e.gltfFormat, s = new Yd(t, n); this._featureTable = s; let a = s.getGlobalProperty("INSTANCES_LENGTH"); if (s.featuresLength = a, !l(a)) throw new fe("Feature table global property: INSTANCES_LENGTH must be defined"); this._instancesLength = a; let c = s.getGlobalProperty("RTC_CENTER", Y.FLOAT, 3); l(c) && (this._transform = F.fromTranslation(h.fromArray(c))), this._batchTable = { json: i, binary: o }; let u = { upAxis: this._upAxis, forwardAxis: this._forwardAxis, releaseGltfJson: this._releaseGltfJson, incrementallyLoadTextures: this._incrementallyLoadTextures, loadAttributesAsTypedArray: this._loadAttributesAsTypedArray, loadIndicesForWireframe: this._loadIndicesForWireframe, loadPrimitiveOutline: this._loadPrimitiveOutline }; if (r === 0) { let g = pl(e.gltf); g = g.replace(/[\s\0]+$/, ""); let m = this._baseResource.getDerivedResource({ url: g }); u.gltfResource = m, u.baseResource = m } else u.gltfResource = this._i3dmResource, u.typedArray = e.gltf; let f = new h_(u); this._gltfLoader = f, this._state = Ef.LOADING, f.load(); let d = this, p = new Promise(function (g) { d._process = function (m, A) { m._gltfLoader.process(A) }, d._postProcess = function (m, A) { let x = m._gltfLoader.components; x.transform = F.multiplyTransformation(m._transform, x.transform, x.transform), tFe(m, x, A), $Le(m, x), m._components = x, m._arrayBuffer = void 0, m._state = Ef.READY, g(m) } }); return this._promise = f.promise.then(function () { if (!d.isDestroyed()) return d._state = Ef.POST_PROCESSING, p }).catch(function (g) { if (!d.isDestroyed()) return QLe(d, g) }), this._promise }; function QLe(e, t) { e.unload(), e._state = Ef.FAILED; let n = "Failed to load i3dm"; return t = e.getError(n, t), Promise.reject(t) } Dm.prototype.process = function (e) { this._state === Ef.LOADING && (this._state = Ef.PROCESSING), this._state === Ef.PROCESSING && this._process(this, e), this._state === Ef.POST_PROCESSING && this._postProcess(this, e) }; function $Le(e, t) { let n = e._batchTable, i = e._instancesLength; if (i === 0) return; let o; if (l(n.json)) o = p_({ count: i, batchTable: n.json, binaryBody: n.binary }); else { let r = new Vc({ name: Wd.BATCH_TABLE_CLASS_NAME, count: i }); o = new ba({ schema: {}, propertyTables: [r] }) } t.structuralMetadata = o } var kR = new h, x8 = new Array(4), eFe = new F; function tFe(e, t, n) { let i, o = e._featureTable, r = e._instancesLength; if (r === 0) return; let s = o.getGlobalProperty("RTC_CENTER", Y.FLOAT, 3), a = o.getGlobalProperty("EAST_NORTH_UP"), c = o.hasProperty("NORMAL_UP") || o.hasProperty("NORMAL_UP_OCT32P") || a, u = o.hasProperty("SCALE") || o.hasProperty("SCALE_NON_UNIFORM"), f = iFe(o, r), d; c && (d = new Float32Array(4 * r)); let p; u && (p = new Float32Array(3 * r)); let g = new Float32Array(r), m = h.unpackArray(f), A = new h, C = new h, x = new h, T = new h, b = new Q, S = new Be, D = new Array(4), P = new h, B = new Array(3), R = new F; if (!l(s)) { let k = re.fromPoints(m); for (i = 0; i < m.length; i++)h.subtract(m[i], k.center, kR), f[3 * i + 0] = kR.x, f[3 * i + 1] = kR.y, f[3 * i + 2] = kR.z; let G = F.fromTranslation(k.center, eFe); t.transform = F.multiplyTransformation(G, t.transform, t.transform) } for (i = 0; i < r; i++) { A = h.clone(m[i]), l(s) && h.add(A, h.unpack(s), A), c && (oFe(o, a, i, S, A, x, C, T, b, R), Be.pack(S, D, 0), d[4 * i + 0] = D[0], d[4 * i + 1] = D[1], d[4 * i + 2] = D[2], d[4 * i + 3] = D[3]), u && (rFe(o, i, P), h.pack(P, B, 0), p[3 * i + 0] = B[0], p[3 * i + 1] = B[1], p[3 * i + 2] = B[2]); let k = o.getProperty("BATCH_ID", Y.UNSIGNED_SHORT, 1, i); l(k) || (k = i), g[i] = k } let M = new oee; M.transformInWorldSpace = !0; let L = e._buffers, _ = new VR; if (_.name = "Instance Translation", _.semantic = Ur.TRANSLATION, _.componentDatatype = Y.FLOAT, _.type = en.VEC3, _.count = r, _.typedArray = f, !c) { let k = ct.createVertexBuffer({ context: n.context, typedArray: f, usage: Re.STATIC_DRAW }); k.vertexArrayDestroyable = !1, L.push(k), _.buffer = k } if (M.attributes.push(_), c) { let k = new VR; k.name = "Instance Rotation", k.semantic = Ur.ROTATION, k.componentDatatype = Y.FLOAT, k.type = en.VEC4, k.count = r, k.typedArray = d, M.attributes.push(k) } if (u) { let k = new VR; if (k.name = "Instance Scale", k.semantic = Ur.SCALE, k.componentDatatype = Y.FLOAT, k.type = en.VEC3, k.count = r, c) k.typedArray = p; else { let G = ct.createVertexBuffer({ context: n.context, typedArray: p, usage: Re.STATIC_DRAW }); G.vertexArrayDestroyable = !1, L.push(G), k.buffer = G } M.attributes.push(k) } let E = new VR; E.name = "Instance Feature ID", E.setIndex = 0, E.semantic = Ur.FEATURE_ID, E.componentDatatype = Y.FLOAT, E.type = en.SCALAR, E.count = r; let w = ct.createVertexBuffer({ context: n.context, typedArray: g, usage: Re.STATIC_DRAW }); w.vertexArrayDestroyable = !1, L.push(w), E.buffer = w, M.attributes.push(E); let v = new ZLe; v.propertyTableId = 0, v.setIndex = 0, v.positionalLabel = "instanceFeatureId_0", M.featureIds.push(v); let O = t.nodes, V = O.length, z = !1; for (i = 0; i < V; i++) { let k = O[i]; k.primitives.length > 0 && (k.instances = z ? nFe(M) : M, z = !0) } } function nFe(e) { let t = new oee; t.transformInWorldSpace = e.transformInWorldSpace; let n = e.attributes, i = n.length; for (let o = 0; o < i; o++) { let r = tt(n[o], !1); t.attributes.push(r) } return t.featureIds = e.featureIds, t } function iFe(e, t) { if (e.hasProperty("POSITION")) return e.getPropertyArray("POSITION", Y.FLOAT, 3); if (e.hasProperty("POSITION_QUANTIZED")) { let n = e.getPropertyArray("POSITION_QUANTIZED", Y.UNSIGNED_SHORT, 3), i = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", Y.FLOAT, 3); if (!l(i)) throw new fe("Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions."); let o = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", Y.FLOAT, 3); if (!l(o)) throw new fe("Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions."); let r = new Float32Array(n.length); for (let s = 0; s < n.length / 3; s++)for (let a = 0; a < 3; a++) { let c = 3 * s + a; r[c] = n[c] / 65535 * o[a] + i[a] } return r } else throw new fe("Either POSITION or POSITION_QUANTIZED must be defined for each instance.") } var iee = new Array(4); function oFe(e, t, n, i, o, r, s, a, c, u) { let f = e.getProperty("NORMAL_UP", Y.FLOAT, 3, n, x8), d = e.getProperty("NORMAL_RIGHT", Y.FLOAT, 3, n, iee), p = !1; if (l(f)) { if (!l(d)) throw new fe("To define a custom orientation, both NORMAL_UP and NORMAL_RIGHT must be defined."); h.unpack(f, 0, r), h.unpack(d, 0, s), p = !0 } else { let g = e.getProperty("NORMAL_UP_OCT32P", Y.UNSIGNED_SHORT, 2, n, x8), m = e.getProperty("NORMAL_RIGHT_OCT32P", Y.UNSIGNED_SHORT, 2, n, iee); if (l(g)) { if (!l(m)) throw new fe("To define a custom orientation with oct-encoded vectors, both NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P must be defined."); kn.octDecodeInRange(g[0], g[1], 65535, r), kn.octDecodeInRange(m[0], m[1], 65535, s), p = !0 } else t ? (It.eastNorthUpToFixedFrame(o, ie.WGS84, u), F.getMatrix3(u, c)) : Q.clone(Q.IDENTITY, c) } p && (h.cross(s, r, a), h.normalize(a, a), Q.setColumn(c, 0, s, c), Q.setColumn(c, 1, r, c), Q.setColumn(c, 2, a, c)), Be.fromRotationMatrix(c, i) } function rFe(e, t, n) { n = h.fromElements(1, 1, 1, n); let i = e.getProperty("SCALE", Y.FLOAT, 1, t); l(i) && h.multiplyByScalar(n, i, n); let o = e.getProperty("SCALE_NON_UNIFORM", Y.FLOAT, 3, t, x8); l(o) && (n.x *= o[0], n.y *= o[1], n.z *= o[2]) } function sFe(e) { let t = e._buffers, n = t.length; for (let i = 0; i < n; i++) { let o = t[i]; o.isDestroyed() || o.destroy() } t.length = 0 } Dm.prototype.isUnloaded = function () { return this._state === Ef.UNLOADED }; Dm.prototype.unload = function () { l(this._gltfLoader) && this._gltfLoader.unload(), sFe(this), this._components = void 0, this._arrayBuffer = void 0, this._state = Ef.UNLOADED }; var UR = Dm; var aFe = { STOPPED: 0, ANIMATING: 1 }, Xd = Object.freeze(aFe); function ox() { this.times = void 0, this.points = void 0, ye.throwInstantiationError() } ox.getPointType = function (e) { if (typeof e == "number") return Number; if (e instanceof h) return h; if (e instanceof Be) return Be }; ox.prototype.evaluate = ye.throwInstantiationError; ox.prototype.findTimeInterval = function (e, t) { let n = this.times, i = n.length; if (t = y(t, 0), e >= n[t]) { if (t + 1 < i && e < n[t + 1]) return t; if (t + 2 < i && e < n[t + 2]) return t + 1 } else if (t - 1 >= 0 && e >= n[t - 1]) return t - 1; let o; if (e > n[t]) for (o = t; o < i - 1 && !(e >= n[o] && e < n[o + 1]); ++o); else for (o = t - 1; o >= 0 && !(e >= n[o] && e < n[o + 1]); --o); return o === i - 1 && (o = i - 2), o }; ox.prototype.wrapTime = function (e) { let t = this.times, n = t[t.length - 1], i = t[0], o = n - i, r; return e < i && (r = Math.floor((i - e) / o) + 1, e += r * o), e > n && (r = Math.floor((e - n) / o) + 1, e -= r * o), e }; ox.prototype.clampTime = function (e) { let t = this.times; return I.clamp(e, t[0], t[t.length - 1]) }; var Qi = ox; function rx(e) { this._value = e, this._valueType = Qi.getPointType(e) } Object.defineProperties(rx.prototype, { value: { get: function () { return this._value } } }); rx.prototype.findTimeInterval = function (e) { }; rx.prototype.wrapTime = function (e) { return 0 }; rx.prototype.clampTime = function (e) { return 0 }; rx.prototype.evaluate = function (e, t) { let n = this._value, i = this._valueType; return i === Number ? n : i.clone(n, t) }; var zR = rx; function sx(e) { e = y(e, y.EMPTY_OBJECT); let t = e.points, n = e.times; this._times = n, this._points = t, this._pointType = Qi.getPointType(t[0]), this._lastTimeIndex = 0 } Object.defineProperties(sx.prototype, { times: { get: function () { return this._times } }, points: { get: function () { return this._points } } }); sx.prototype.findTimeInterval = Qi.prototype.findTimeInterval; sx.prototype.wrapTime = Qi.prototype.wrapTime; sx.prototype.clampTime = Qi.prototype.clampTime; sx.prototype.evaluate = function (e, t) { let n = this.points, i = this.times, o = this._lastTimeIndex = this.findTimeInterval(e, this._lastTimeIndex), r = (e - i[o]) / (i[o + 1] - i[o]); return this._pointType === Number ? (1 - r) * n[o] + r * n[o + 1] : (l(t) || (t = new h), h.lerp(n[o], n[o + 1], r, t)) }; var z0 = sx; var ree = {}; ree.solve = function (e, t, n, i) { let o = new Array(n.length), r = new Array(i.length), s = new Array(i.length), a; for (a = 0; a < r.length; a++)r[a] = new h, s[a] = new h; o[0] = n[0] / t[0], r[0] = h.multiplyByScalar(i[0], 1 / t[0], r[0]); let c; for (a = 1; a < o.length; ++a)c = 1 / (t[a] - o[a - 1] * e[a - 1]), o[a] = n[a] * c, r[a] = h.subtract(i[a], h.multiplyByScalar(r[a - 1], e[a - 1], r[a]), r[a]), r[a] = h.multiplyByScalar(r[a], c, r[a]); for (c = 1 / (t[a] - o[a - 1] * e[a - 1]), r[a] = h.subtract(i[a], h.multiplyByScalar(r[a - 1], e[a - 1], r[a]), r[a]), r[a] = h.multiplyByScalar(r[a], c, r[a]), s[s.length - 1] = r[r.length - 1], a = s.length - 2; a >= 0; --a)s[a] = h.subtract(r[a], h.multiplyByScalar(s[a + 1], o[a], s[a]), s[a]); return s }; var vS = ree; var see = [], aee = [], cee = [], lee = []; function cFe(e, t, n) { let i = see, o = cee, r = aee, s = lee; i.length = o.length = e.length - 1, r.length = s.length = e.length; let a; i[0] = r[0] = 1, o[0] = 0; let c = s[0]; for (l(c) || (c = s[0] = new h), h.clone(t, c), a = 1; a < i.length - 1; ++a)i[a] = o[a] = 1, r[a] = 4, c = s[a], l(c) || (c = s[a] = new h), h.subtract(e[a + 1], e[a - 1], c), h.multiplyByScalar(c, 3, c); return i[a] = 0, o[a] = 1, r[a] = 4, c = s[a], l(c) || (c = s[a] = new h), h.subtract(e[a + 1], e[a - 1], c), h.multiplyByScalar(c, 3, c), r[a + 1] = 1, c = s[a + 1], l(c) || (c = s[a + 1] = new h), h.clone(n, c), vS.solve(i, r, o, s) } function lFe(e) { let t = see, n = cee, i = aee, o = lee; t.length = n.length = e.length - 1, i.length = o.length = e.length; let r; t[0] = n[0] = 1, i[0] = 2; let s = o[0]; for (l(s) || (s = o[0] = new h), h.subtract(e[1], e[0], s), h.multiplyByScalar(s, 3, s), r = 1; r < t.length; ++r)t[r] = n[r] = 1, i[r] = 4, s = o[r], l(s) || (s = o[r] = new h), h.subtract(e[r + 1], e[r - 1], s), h.multiplyByScalar(s, 3, s); return i[r] = 2, s = o[r], l(s) || (s = o[r] = new h), h.subtract(e[r], e[r - 1], s), h.multiplyByScalar(s, 3, s), vS.solve(t, i, n, o) } function Hc(e) { e = y(e, y.EMPTY_OBJECT); let t = e.points, n = e.times, i = e.inTangents, o = e.outTangents; this._times = n, this._points = t, this._pointType = Qi.getPointType(t[0]), this._inTangents = i, this._outTangents = o, this._lastTimeIndex = 0 } Object.defineProperties(Hc.prototype, { times: { get: function () { return this._times } }, points: { get: function () { return this._points } }, inTangents: { get: function () { return this._inTangents } }, outTangents: { get: function () { return this._outTangents } } }); Hc.createC1 = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.times, n = e.points, i = e.tangents, o = i.slice(0, i.length - 1), r = i.slice(1, i.length); return new Hc({ times: t, points: n, inTangents: r, outTangents: o }) }; Hc.createNaturalCubic = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.times, n = e.points; if (n.length < 3) return new z0({ points: n, times: t }); let i = lFe(n), o = i.slice(0, i.length - 1), r = i.slice(1, i.length); return new Hc({ times: t, points: n, inTangents: r, outTangents: o }) }; Hc.createClampedCubic = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.times, n = e.points, i = e.firstTangent, o = e.lastTangent, r = Qi.getPointType(n[0]); if (n.length < 3) return new z0({ points: n, times: t }); let s = cFe(n, i, o), a = s.slice(0, s.length - 1), c = s.slice(1, s.length); return new Hc({ times: t, points: n, inTangents: c, outTangents: a }) }; Hc.hermiteCoefficientMatrix = new F(2, -3, 0, 1, -2, 3, 0, 0, 1, -2, 1, 0, 1, -1, 0, 0); Hc.prototype.findTimeInterval = Qi.prototype.findTimeInterval; var uFe = new se, ax = new h; Hc.prototype.wrapTime = Qi.prototype.wrapTime; Hc.prototype.clampTime = Qi.prototype.clampTime; Hc.prototype.evaluate = function (e, t) { let n = this.points, i = this.times, o = this.inTangents, r = this.outTangents; this._lastTimeIndex = this.findTimeInterval(e, this._lastTimeIndex); let s = this._lastTimeIndex, a = i[s + 1] - i[s], c = (e - i[s]) / a, u = uFe; u.z = c, u.y = c * c, u.x = u.y * c, u.w = 1; let f = F.multiplyByVector(Hc.hermiteCoefficientMatrix, u, u); f.z *= a, f.w *= a; let d = this._pointType; return d === Number ? n[s] * f.x + n[s + 1] * f.y + r[s] * f.z + o[s] * f.w : (l(t) || (t = new d), t = d.multiplyByScalar(n[s], f.x, t), d.multiplyByScalar(n[s + 1], f.y, ax), d.add(t, ax, t), d.multiplyByScalar(r[s], f.z, ax), d.add(t, ax, t), d.multiplyByScalar(o[s], f.w, ax), d.add(t, ax, t)) }; var H0 = Hc; function cx(e) { e = y(e, y.EMPTY_OBJECT); let t = e.points, n = e.times; this._times = n, this._points = t, this._pointType = Qi.getPointType(t[0]), this._lastTimeIndex = 0 } Object.defineProperties(cx.prototype, { times: { get: function () { return this._times } }, points: { get: function () { return this._points } } }); cx.prototype.findTimeInterval = Qi.prototype.findTimeInterval; cx.prototype.wrapTime = Qi.prototype.wrapTime; cx.prototype.clampTime = Qi.prototype.clampTime; cx.prototype.evaluate = function (e, t) { let n = this.points; this._lastTimeIndex = this.findTimeInterval(e, this._lastTimeIndex); let i = this._lastTimeIndex, o = this._pointType; return o === Number ? n[i] : (l(t) || (t = new o), o.clone(n[i], t)) }; var HR = cx; function fFe(e) { let t = e.points, n = e.times; return function (i, o) { l(o) || (o = new Be); let r = e._lastTimeIndex = e.findTimeInterval(i, e._lastTimeIndex), s = (i - n[r]) / (n[r + 1] - n[r]), a = t[r], c = t[r + 1]; return Be.fastSlerp(a, c, s, o) } } function lx(e) { e = y(e, y.EMPTY_OBJECT); let t = e.points, n = e.times; this._times = n, this._points = t, this._evaluateFunction = fFe(this), this._lastTimeIndex = 0 } Object.defineProperties(lx.prototype, { times: { get: function () { return this._times } }, points: { get: function () { return this._points } } }); lx.prototype.findTimeInterval = Qi.prototype.findTimeInterval; lx.prototype.wrapTime = Qi.prototype.wrapTime; lx.prototype.clampTime = Qi.prototype.clampTime; lx.prototype.evaluate = function (e, t) { return this._evaluateFunction(e, t) }; var GR = lx; var G0 = Dt.AnimatedPropertyType; function E8(e) { e = y(e, y.EMPTY_OBJECT); let t = e.channel, n = e.runtimeAnimation, i = e.runtimeNode; this._channel = t, this._runtimeAnimation = n, this._runtimeNode = i, this._splines = [], this._path = void 0, mFe(this) } Object.defineProperties(E8.prototype, { channel: { get: function () { return this._channel } }, runtimeAnimation: { get: function () { return this._runtimeAnimation } }, runtimeNode: { get: function () { return this._runtimeNode } }, splines: { get: function () { return this._splines } } }); function dFe(e, t) { let n = [], i = [], o = [], r = t.length; for (let s = 0; s < r; s += 3)i.push(t[s]), n.push(t[s + 1]), o.push(t[s + 2]); return i.splice(0, 1), o.length = o.length - 1, new H0({ times: e, points: n, inTangents: i, outTangents: o }) } function uee(e, t, n, i) { if (e.length === 1 && t.length === 1) return new zR(t[0]); switch (n) { case qd.STEP: return new HR({ times: e, points: t }); case qd.CUBICSPLINE: return dFe(e, t); case qd.LINEAR: return i === G0.ROTATION ? new GR({ times: e, points: t }) : new z0({ times: e, points: t }) } } function hFe(e, t, n, i, o) { let r = []; if (i === G0.WEIGHTS) { let a = t.length / o, c, u; for (c = 0; c < o; c++) { let f = new Array(a), d = c; if (n === qd.CUBICSPLINE) for (u = 0; u < a; u += 3)f[u] = t[d], f[u + 1] = t[d + o], f[u + 2] = t[d + 2 * o], d += o * 3; else for (u = 0; u < a; u++)f[u] = t[d], d += o; r.push(uee(e, f, n, i)) } } else r.push(uee(e, t, n, i)); return r } var T8; function mFe(e) { let t = e._channel, n = t.sampler, i = n.input, o = n.output, r = n.interpolation, a = t.target.path, c = e._runtimeNode, u = l(c.morphWeights) ? c.morphWeights.length : 1, f = hFe(i, o, r, a, u); switch (e._splines = f, e._path = a, a) { case G0.TRANSLATION: case G0.SCALE: T8 = new h; break; case G0.ROTATION: T8 = new Be; break; case G0.WEIGHTS: break } } E8.prototype.animate = function (e) { let t = this._splines, n = this._path, i = this._runtimeAnimation.model, o = this._runtimeNode; if (n === G0.WEIGHTS) { let r = o.morphWeights, s = r.length; for (let a = 0; a < s; a++) { let c = t[a], u = i.clampAnimations ? c.clampTime(e) : c.wrapTime(e); r[a] = c.evaluate(u) } } else { if (o.userAnimated) return; { let r = t[0], s = i.clampAnimations ? r.clampTime(e) : r.wrapTime(e); o[n] = r.evaluate(s, T8) } } }; var WR = E8; function b8(e, t, n) { this._animation = t, this._name = t.name, this._runtimeChannels = void 0, this._startTime = $.clone(n.startTime), this._delay = y(n.delay, 0), this._stopTime = $.clone(n.stopTime), this.removeOnStop = y(n.removeOnStop, !1), this._multiplier = y(n.multiplier, 1), this._reverse = y(n.reverse, !1), this._loop = y(n.loop, ic.NONE), this._animationTime = n.animationTime, this._prevAnimationDelta = void 0, this.start = new _e, this.update = new _e, this.stop = new _e, this._state = Xd.STOPPED, this._computedStartTime = void 0, this._duration = void 0; let i = this; this._raiseStartEvent = function () { i.start.raiseEvent(e, i) }, this._updateEventTime = 0, this._raiseUpdateEvent = function () { i.update.raiseEvent(e, i, i._updateEventTime) }, this._raiseStopEvent = function () { i.stop.raiseEvent(e, i) }, this._model = e, this._localStartTime = void 0, this._localStopTime = void 0, pFe(this) } Object.defineProperties(b8.prototype, { animation: { get: function () { return this._animation } }, name: { get: function () { return this._name } }, runtimeChannels: { get: function () { return this._runtimeChannels } }, model: { get: function () { return this._model } }, localStartTime: { get: function () { return this._localStartTime } }, localStopTime: { get: function () { return this._localStopTime } }, startTime: { get: function () { return this._startTime } }, delay: { get: function () { return this._delay } }, stopTime: { get: function () { return this._stopTime } }, multiplier: { get: function () { return this._multiplier } }, reverse: { get: function () { return this._reverse } }, loop: { get: function () { return this._loop } }, animationTime: { get: function () { return this._animationTime } } }); function pFe(e) { let t = Number.MAX_VALUE, n = -Number.MAX_VALUE, i = e._model.sceneGraph, r = e._animation.channels, s = r.length, a = []; for (let c = 0; c < s; c++) { let u = r[c], f = u.target; if (!l(f)) continue; let d = f.node.index, p = i._runtimeNodes[d], g = new WR({ channel: u, runtimeAnimation: e, runtimeNode: p }), m = u.sampler.input; t = Math.min(t, m[0]), n = Math.max(n, m[m.length - 1]), a.push(g) } e._runtimeChannels = a, e._localStartTime = t, e._localStopTime = n } b8.prototype.animate = function (e) { let t = this._runtimeChannels, n = t.length; for (let i = 0; i < n; i++)t[i].animate(e) }; var jR = b8; function vm(e) { this.animationAdded = new _e, this.animationRemoved = new _e, this.animateWhilePaused = !1, this._model = e, this._runtimeAnimations = [], this._previousTime = void 0 } Object.defineProperties(vm.prototype, { length: { get: function () { return this._runtimeAnimations.length } }, model: { get: function () { return this._model } } }); function S8(e, t, n) { let i = e._model, o = new jR(i, t, n); return e._runtimeAnimations.push(o), e.animationAdded.raiseEvent(i, o), o } vm.prototype.add = function (e) { e = y(e, y.EMPTY_OBJECT); let n = this._model.sceneGraph.components.animations, i = e.index; if (l(i)) return S8(this, n[i], e); let o = n.length; for (let r = 0; r < o; ++r)if (n[r].name === e.name) { i = r; break } return S8(this, n[i], e) }; vm.prototype.addAll = function (e) { e = y(e, y.EMPTY_OBJECT); let n = this._model.sceneGraph.components.animations, i = [], o = n.length; for (let r = 0; r < o; ++r) { let s = S8(this, n[r], e); i.push(s) } return i }; vm.prototype.remove = function (e) { if (!l(e)) return !1; let t = this._runtimeAnimations, n = t.indexOf(e); return n !== -1 ? (t.splice(n, 1), this.animationRemoved.raiseEvent(this._model, e), !0) : !1 }; vm.prototype.removeAll = function () { let e = this._model, t = this._runtimeAnimations, n = t.length; this._runtimeAnimations.length = 0; for (let i = 0; i < n; ++i)this.animationRemoved.raiseEvent(e, t[i]) }; vm.prototype.contains = function (e) { return l(e) ? this._runtimeAnimations.indexOf(e) !== -1 : !1 }; vm.prototype.get = function (e) { return this._runtimeAnimations[e] }; var qR = []; function _Fe(e, t, n) { return function () { e.animationRemoved.raiseEvent(t, n) } } vm.prototype.update = function (e) { let t = this._runtimeAnimations, n = t.length; if (n === 0) return this._previousTime = void 0, !1; if (!this.animateWhilePaused && $.equals(e.time, this._previousTime)) return !1; this._previousTime = $.clone(e.time, this._previousTime); let i = !1, o = e.time, r = this._model; for (let s = 0; s < n; ++s) { let a = t[s]; l(a._computedStartTime) || (a._computedStartTime = $.addSeconds(y(a.startTime, o), a.delay, new $)), l(a._duration) || (a._duration = a.localStopTime * (1 / a.multiplier)); let c = a._computedStartTime, u = a._duration, f = a.stopTime, d = $.lessThanOrEquals(c, o), p = l(f) && $.greaterThan(o, f), g = 0; if (u !== 0) { let C = $.secondsDifference(p ? f : o, c); g = l(a._animationTime) ? a._animationTime(u, C) : C / u } let m = a.loop === ic.REPEAT || a.loop === ic.MIRRORED_REPEAT, A = (d || m && !l(a.startTime)) && (g <= 1 || m) && !p; if (g === a._prevAnimationDelta) { let C = a._state === Xd.STOPPED; if (A !== C) continue } if (a._prevAnimationDelta = g, A || a._state === Xd.ANIMATING) { if (A && a._state === Xd.STOPPED && (a._state = Xd.ANIMATING, a.start.numberOfListeners > 0 && e.afterRender.push(a._raiseStartEvent)), a.loop === ic.REPEAT) g = g - Math.floor(g); else if (a.loop === ic.MIRRORED_REPEAT) { let x = Math.floor(g), T = g - x; g = x % 2 === 1 ? 1 - T : T } a.reverse && (g = 1 - g); let C = g * u * a.multiplier; C = I.clamp(C, a.localStartTime, a.localStopTime), a.animate(C), a.update.numberOfListeners > 0 && (a._updateEventTime = C, e.afterRender.push(a._raiseUpdateEvent)), i = !0, A || (a._state = Xd.STOPPED, a.stop.numberOfListeners > 0 && e.afterRender.push(a._raiseStopEvent), a.removeOnStop && qR.push(a)) } } n = qR.length; for (let s = 0; s < n; ++s) { let a = qR[s]; t.splice(t.indexOf(a), 1), e.afterRender.push(_Fe(this, r, a)) } return qR.length = 0, i }; var YR = vm; function W0(e) { this._model = e.model, this._featureTable = e.featureTable, this._featureId = e.featureId, this._color = void 0 } Object.defineProperties(W0.prototype, { show: { get: function () { return this._featureTable.getShow(this._featureId) }, set: function (e) { this._featureTable.setShow(this._featureId, e) } }, color: { get: function () { return l(this._color) || (this._color = new U), this._featureTable.getColor(this._featureId, this._color) }, set: function (e) { this._featureTable.setColor(this._featureId, e) } }, primitive: { get: function () { return this._model } }, featureTable: { get: function () { return this._featureTable } }, featureId: { get: function () { return this._featureId } } }); W0.prototype.hasProperty = function (e) { return this._featureTable.hasProperty(this._featureId, e) }; W0.prototype.getProperty = function (e) { return this._featureTable.getProperty(this._featureId, e) }; W0.prototype.getPropertyInherited = function (e) { return this._featureTable.hasPropertyBySemantic(this._featureId, e) ? this._featureTable.getPropertyBySemantic(this._featureId, e) : this._featureTable.getProperty(this._featureId, e) }; W0.prototype.getPropertyIds = function (e) { return this._featureTable.getPropertyIds(e) }; W0.prototype.setProperty = function (e, t) { return this._featureTable.setProperty(this._featureId, e, t) }; var XR = W0; var PS = { ALL_OPAQUE: 0, ALL_TRANSLUCENT: 1, OPAQUE_AND_TRANSLUCENT: 2 }; PS.getStyleCommandsNeeded = function (e, t) { return t === 0 ? PS.ALL_OPAQUE : t === e ? PS.ALL_TRANSLUCENT : PS.OPAQUE_AND_TRANSLUCENT }; var Kd = Object.freeze(PS); var A_ = { GLTF: "GLTF", TILE_GLTF: "TILE_GLTF", TILE_B3DM: "B3DM", TILE_I3DM: "I3DM", TILE_PNTS: "PNTS", TILE_GEOJSON: "TILE_GEOJSON" }; A_.is3DTiles = function (e) { switch (e) { case A_.TILE_GLTF: case A_.TILE_B3DM: case A_.TILE_I3DM: case A_.TILE_PNTS: case A_.TILE_GEOJSON: return !0; case A_.GLTF: return !1 } }; var ar = Object.freeze(A_); function _r(e) { let t = e.model, n = e.propertyTable; this._propertyTable = n, this._model = t, this._features = void 0, this._featuresLength = 0, this._batchTexture = void 0, this._styleCommandsNeededDirty = !1, this._styleCommandsNeeded = Kd.ALL_OPAQUE, gFe(this) } Object.defineProperties(_r.prototype, { batchTexture: { get: function () { return this._batchTexture } }, featuresLength: { get: function () { return this._featuresLength } }, batchTextureByteLength: { get: function () { return l(this._batchTexture) ? this._batchTexture.byteLength : 0 } }, styleCommandsNeededDirty: { get: function () { return this._styleCommandsNeededDirty } } }); function gFe(e) { let t = e._model, n = ar.is3DTiles(t.type), i = e._propertyTable.count; if (i === 0) return; let o, r = new Array(i); if (n) { let s = t.content; for (o = 0; o < i; o++)r[o] = new xs(s, o) } else for (o = 0; o < i; o++)r[o] = new XR({ model: t, featureId: o, featureTable: e }); e._features = r, e._featuresLength = i, e._batchTexture = new Nc({ featuresLength: i, owner: e, statistics: n ? t.content.tileset.statistics : void 0 }) } _r.prototype.update = function (e) { this._styleCommandsNeededDirty = !1, this._batchTexture.update(void 0, e); let t = Kd.getStyleCommandsNeeded(this._featuresLength, this._batchTexture.translucentFeaturesLength); this._styleCommandsNeeded !== t && (this._styleCommandsNeededDirty = !0, this._styleCommandsNeeded = t) }; _r.prototype.setShow = function (e, t) { this._batchTexture.setShow(e, t) }; _r.prototype.setAllShow = function (e) { this._batchTexture.setAllShow(e) }; _r.prototype.getShow = function (e) { return this._batchTexture.getShow(e) }; _r.prototype.setColor = function (e, t) { this._batchTexture.setColor(e, t) }; _r.prototype.setAllColor = function (e) { this._batchTexture.setAllColor(e) }; _r.prototype.getColor = function (e, t) { return this._batchTexture.getColor(e, t) }; _r.prototype.getPickColor = function (e) { return this._batchTexture.getPickColor(e) }; _r.prototype.getFeature = function (e) { return this._features[e] }; _r.prototype.hasProperty = function (e, t) { return this._propertyTable.hasProperty(e, t) }; _r.prototype.hasPropertyBySemantic = function (e, t) { return this._propertyTable.hasPropertyBySemantic(e, t) }; _r.prototype.getProperty = function (e, t) { return this._propertyTable.getProperty(e, t) }; _r.prototype.getPropertyBySemantic = function (e, t) { return this._propertyTable.getPropertyBySemantic(e, t) }; _r.prototype.getPropertyIds = function (e) { return this._propertyTable.getPropertyIds(e) }; _r.prototype.setProperty = function (e, t, n) { return this._propertyTable.setProperty(e, t, n) }; _r.prototype.isClass = function (e, t) { return this._propertyTable.isClass(e, t) }; _r.prototype.isExactClass = function (e, t) { return this._propertyTable.isExactClass(e, t) }; _r.prototype.getExactClassName = function (e) { return this._propertyTable.getExactClassName(e) }; var yFe = new U; _r.prototype.applyStyle = function (e) { if (!l(e)) { this.setAllColor(Nc.DEFAULT_COLOR_VALUE), this.setAllShow(Nc.DEFAULT_SHOW_VALUE); return } for (let t = 0; t < this._featuresLength; t++) { let n = this.getFeature(t), i = l(e.color) ? y(e.color.evaluateColor(n, yFe), Nc.DEFAULT_COLOR_VALUE) : Nc.DEFAULT_COLOR_VALUE, o = l(e.show) ? y(e.show.evaluate(n), Nc.DEFAULT_SHOW_VALUE) : Nc.DEFAULT_SHOW_VALUE; this.setColor(t, i), this.setShow(t, o) } }; _r.prototype.isDestroyed = function () { return !1 }; _r.prototype.destroy = function (e) { this._batchTexture = this._batchTexture && this._batchTexture.destroy(), le(this) }; var KR = _r; var JR = `#if defined(HAS_NORMALS) && !defined(HAS_TANGENTS) && !defined(LIGHTING_UNLIT)
#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif
#endif
czm_modelMaterial defaultModelMaterial()
{
czm_modelMaterial material;
material.diffuse = vec3(0.0);
material.specular = vec3(1.0);
material.roughness = 1.0;
material.occlusion = 1.0;
material.normalEC = vec3(0.0, 0.0, 1.0);
material.emissive = vec3(0.0);
material.alpha = 1.0;
return material;
}
vec4 handleAlpha(vec3 color, float alpha)
{
#ifdef ALPHA_MODE_MASK
if (alpha < u_alphaCutoff) {
discard;
}
#endif
return vec4(color, alpha);
}
SelectedFeature selectedFeature;
void main()
{
#ifdef HAS_MODEL_SPLITTER
modelSplitterStage();
#endif
czm_modelMaterial material = defaultModelMaterial();
ProcessedAttributes attributes;
geometryStage(attributes);
FeatureIds featureIds;
featureIdStage(featureIds, attributes);
Metadata metadata;
MetadataClass metadataClass;
MetadataStatistics metadataStatistics;
metadataStage(metadata, metadataClass, metadataStatistics, attributes);
#ifdef HAS_SELECTED_FEATURE_ID
selectedFeatureIdStage(selectedFeature, featureIds);
#endif
#ifndef CUSTOM_SHADER_REPLACE_MATERIAL
materialStage(material, attributes, selectedFeature);
#endif
#ifdef HAS_CUSTOM_FRAGMENT_SHADER
customShaderStage(material, attributes, featureIds, metadata, metadataClass, metadataStatistics);
#endif
lightingStage(material, attributes);
#ifdef HAS_SELECTED_FEATURE_ID
cpuStylingStage(material, selectedFeature);
#endif
#ifdef HAS_MODEL_COLOR
modelColorStage(material);
#endif
#ifdef HAS_PRIMITIVE_OUTLINE
primitiveOutlineStage(material);
#endif
vec4 color = handleAlpha(material.diffuse, material.alpha);
#ifdef HAS_CLIPPING_PLANES
modelClippingPlanesStage(color);
#endif
#if defined(HAS_SILHOUETTE) && defined(HAS_NORMALS)
silhouetteStage(color);
#endif
gl_FragColor = color;
}
`; var ZR = `precision highp float;
czm_modelVertexOutput defaultVertexOutput(vec3 positionMC) {
czm_modelVertexOutput vsOutput;
vsOutput.positionMC = positionMC;
vsOutput.pointSize = 1.0;
return vsOutput;
}
void main()
{
ProcessedAttributes attributes;
initializeAttributes(attributes);
#ifdef USE_DEQUANTIZATION
dequantizationStage(attributes);
#endif
#ifdef HAS_MORPH_TARGETS
morphTargetsStage(attributes);
#endif
#ifdef HAS_SKINNING
skinningStage(attributes);
#endif
#ifdef HAS_PRIMITIVE_OUTLINE
primitiveOutlineStage();
#endif
#ifdef HAS_BITANGENTS
attributes.bitangentMC = normalize(cross(attributes.normalMC, attributes.tangentMC) * attributes.tangentSignMC);
#endif
FeatureIds featureIds;
featureIdStage(featureIds, attributes);
#ifdef HAS_SELECTED_FEATURE_ID
SelectedFeature feature;
selectedFeatureIdStage(feature, featureIds);
cpuStylingStage(attributes.positionMC, feature);
#endif
#if defined(USE_2D_POSITIONS) || defined(USE_2D_INSTANCING)
mat4 modelView = czm_modelView3D;
mat3 normal = czm_normal3D;
#else
mat4 modelView = czm_modelView;
mat3 normal = czm_normal;
#endif
#ifdef HAS_INSTANCING
#ifdef USE_LEGACY_INSTANCING
mat4 instanceModelView;
mat3 instanceModelViewInverseTranspose;
legacyInstancingStage(attributes, instanceModelView, instanceModelViewInverseTranspose);
modelView = instanceModelView;
normal = instanceModelViewInverseTranspose;
#else
instancingStage(attributes);
#endif
#ifdef USE_PICKING
v_pickColor = a_pickColor;
#endif
#endif
Metadata metadata;
MetadataClass metadataClass;
MetadataStatistics metadataStatistics;
metadataStage(metadata, metadataClass, metadataStatistics, attributes);
#ifdef HAS_CUSTOM_VERTEX_SHADER
czm_modelVertexOutput vsOutput = defaultVertexOutput(attributes.positionMC);
customShaderStage(vsOutput, attributes, featureIds, metadata, metadataClass, metadataStatistics);
#endif
vec4 positionClip = geometryStage(attributes, modelView, normal);
#ifdef HAS_SILHOUETTE
silhouetteStage(attributes, positionClip);
#endif
#ifdef HAS_POINT_CLOUD_SHOW_STYLE
float show = pointCloudShowStylingStage(attributes, metadata);
#else
float show = 1.0;
#endif
#ifdef HAS_POINT_CLOUD_BACK_FACE_CULLING
show *= pointCloudBackFaceCullingStage();
#endif
#ifdef HAS_POINT_CLOUD_COLOR_STYLE
v_pointCloudColor = pointCloudColorStylingStage(attributes, metadata);
#endif
#ifdef PRIMITIVE_TYPE_POINTS
#ifdef HAS_CUSTOM_VERTEX_SHADER
gl_PointSize = vsOutput.pointSize;
#elif defined(HAS_POINT_CLOUD_POINT_SIZE_STYLE) || defined(HAS_POINT_CLOUD_ATTENUATION)
gl_PointSize = pointCloudPointSizeStylingStage(attributes, metadata);
#else
gl_PointSize = 1.0;
#endif
gl_PointSize *= show;
#endif
gl_Position = show * positionClip;
}
`; function D8(e) { e = y(e, y.EMPTY_OBJECT); let t = e.command, n = e.primitiveRenderResources, i = n.model; this._command = t, this._model = i, this._runtimePrimitive = n.runtimePrimitive, this._modelMatrix = t.modelMatrix, this._boundingVolume = t.boundingVolume, this._cullFace = t.renderState.cull.face; let o = i.classificationType; this._classificationType = o, this._classifiesTerrain = o !== Ln.CESIUM_3D_TILE, this._classifies3DTiles = o !== Ln.TERRAIN, this._useDebugWireframe = i._enableDebugWireframe && i.debugWireframe, this._pickId = n.pickId, this._commandListTerrain = [], this._commandList3DTiles = [], this._commandListIgnoreShow = [], this._commandListDebugWireframe = [], this._commandListTerrainPicking = [], this._commandList3DTilesPicking = [], TFe(this) } function AFe(e) { return { colorMask: { red: !1, green: !1, blue: !1, alpha: !1 }, stencilTest: { enabled: !0, frontFunction: e, frontOperation: { fail: lt.KEEP, zFail: lt.DECREMENT_WRAP, zPass: lt.KEEP }, backFunction: e, backOperation: { fail: lt.KEEP, zFail: lt.INCREMENT_WRAP, zPass: lt.KEEP }, reference: vt.CESIUM_3D_TILE_MASK, mask: vt.CESIUM_3D_TILE_MASK }, stencilMask: vt.CLASSIFICATION_MASK, depthTest: { enabled: !0, func: Ja.LESS_OR_EQUAL }, depthMask: !1 } } var CFe = { stencilTest: { enabled: !0, frontFunction: Fn.NOT_EQUAL, frontOperation: { fail: lt.ZERO, zFail: lt.ZERO, zPass: lt.ZERO }, backFunction: Fn.NOT_EQUAL, backOperation: { fail: lt.ZERO, zFail: lt.ZERO, zPass: lt.ZERO }, reference: 0, mask: vt.CLASSIFICATION_MASK }, stencilMask: vt.CLASSIFICATION_MASK, depthTest: { enabled: !1 }, depthMask: !1, blending: an.PRE_MULTIPLIED_ALPHA_BLEND }, xFe = { stencilTest: { enabled: !0, frontFunction: Fn.NOT_EQUAL, frontOperation: { fail: lt.ZERO, zFail: lt.ZERO, zPass: lt.ZERO }, backFunction: Fn.NOT_EQUAL, backOperation: { fail: lt.ZERO, zFail: lt.ZERO, zPass: lt.ZERO }, reference: 0, mask: vt.CLASSIFICATION_MASK }, stencilMask: vt.CLASSIFICATION_MASK, depthTest: { enabled: !1 }, depthMask: !1 }, hee = []; function TFe(e) { let t = e._command, n = hee; if (e._useDebugWireframe) { t.pass = xe.OPAQUE, n.length = 0, n.push(t), e._commandListDebugWireframe = IS(e, n, e._commandListDebugWireframe); let r = e._commandListDebugWireframe, s = r.length; for (let a = 0; a < s; a++) { let c = r[a]; c.count *= 2, c.offset *= 2 } return } let o = e.model.allowPicking; if (e._classifiesTerrain) { let r = xe.TERRAIN_CLASSIFICATION, s = w8(t, r), a = fee(t, r); n.length = 0, n.push(s, a), e._commandListTerrain = IS(e, n, e._commandListTerrain), o && (e._commandListTerrainPicking = dee(e, n, e._commandListTerrainPicking)) } if (e._classifies3DTiles) { let r = xe.CESIUM_3D_TILE_CLASSIFICATION, s = w8(t, r), a = fee(t, r); n.length = 0, n.push(s, a), e._commandList3DTiles = IS(e, n, e._commandList3DTiles), o && (e._commandList3DTilesPicking = dee(e, n, e._commandList3DTilesPicking)) } } function IS(e, t, n) { let i = e._runtimePrimitive, o = i.batchLengths, r = i.batchOffsets, s = o.length, a = t.length; for (let c = 0; c < s; c++) { let u = o[c], f = r[c]; for (let d = 0; d < a; d++) { let p = t[d], g = $e.shallowClone(p); g.count = u, g.offset = f, n.push(g) } } return n } function w8(e, t) { let n = $e.shallowClone(e); n.cull = !1, n.pass = t; let i = t === xe.TERRAIN_CLASSIFICATION ? Fn.ALWAYS : Fn.EQUAL, o = AFe(i); return n.renderState = Ve.fromCache(o), n } function fee(e, t) { let n = $e.shallowClone(e); return n.cull = !1, n.pass = t, n.renderState = Ve.fromCache(CFe), n } var EFe = []; function dee(e, t, n) { let i = Ve.fromCache(xFe), o = t[0], r = t[1], s = $e.shallowClone(o); s.cull = !0, s.pickOnly = !0; let a = $e.shallowClone(r); a.cull = !0, a.pickOnly = !0, a.renderState = i, a.pickId = e._pickId; let c = EFe; return c.length = 0, c.push(s, a), IS(e, c, n) } Object.defineProperties(D8.prototype, { command: { get: function () { return this._command } }, runtimePrimitive: { get: function () { return this._runtimePrimitive } }, batchLengths: { get: function () { return this._runtimePrimitive.batchLengths } }, batchOffsets: { get: function () { return this._runtimePrimitive.batchOffsets } }, model: { get: function () { return this._model } }, classificationType: { get: function () { return this._classificationType } }, modelMatrix: { get: function () { return this._modelMatrix }, set: function (e) { this._modelMatrix = F.clone(e, this._modelMatrix); let t = this._runtimePrimitive.boundingSphere; this._boundingVolume = re.transform(t, this._modelMatrix, this._boundingVolume) } }, boundingVolume: { get: function () { return this._boundingVolume } }, cullFace: { get: function () { return this._cullFace }, set: function (e) { this._cullFace = e } } }); D8.prototype.pushCommands = function (e, t) { let n = e.passes; if (n.render) { if (this._useDebugWireframe) { t.push.apply(t, this._commandListDebugWireframe); return } if (this._classifiesTerrain && t.push.apply(t, this._commandListTerrain), this._classifies3DTiles && t.push.apply(t, this._commandList3DTiles), e.invertClassification && this._classifies3DTiles) { if (this._commandListIgnoreShow.length === 0) { let o = xe.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW, r = w8(this._command, o), s = hee; s.length = 0, s.push(r), this._commandListIgnoreShow = IS(this, s, this._commandListIgnoreShow) } t.push.apply(t, this._commandListIgnoreShow) } } return n.pick && (this._classifiesTerrain && t.push.apply(t, this._commandListTerrainPicking), this._classifies3DTiles && t.push.apply(t, this._commandList3DTilesPicking)), t }; var QR = D8; function $R(e) { e = y(e, y.EMPTY_OBJECT); let t = e.command, n = e.primitiveRenderResources, i = n.model; this._model = i; let o = n.runtimePrimitive; this._runtimePrimitive = o; let r = t.pass === xe.TRANSLUCENT, a = !o.primitive.material.doubleSided && !r, c = n.hasSilhouette, u = !r && !c, f = n.hasSkipLevelOfDetail && !r, d = c; this._command = t, this._modelMatrix = F.clone(t.modelMatrix), this._boundingVolume = re.clone(t.boundingVolume), this._modelMatrix2D = new F, this._boundingVolume2D = new re, this._modelMatrix2DDirty = !1, this._backFaceCulling = t.renderState.cull.enabled, this._cullFace = t.renderState.cull.face, this._shadows = i.shadows, this._debugShowBoundingVolume = t.debugShowBoundingVolume, this._usesBackFaceCulling = a, this._needsTranslucentCommand = u, this._needsSkipLevelOfDetailCommands = f, this._needsSilhouetteCommands = d, this._originalCommand = void 0, this._translucentCommand = void 0, this._skipLodBackfaceCommand = void 0, this._skipLodStencilCommand = void 0, this._silhouetteModelCommand = void 0, this._silhouetteColorCommand = void 0, this._derivedCommands = [], this._has2DCommands = !1, bFe(this) } function Pm(e) { this.command = e.command, this.updateShadows = e.updateShadows, this.updateBackFaceCulling = e.updateBackFaceCulling, this.updateCullFace = e.updateCullFace, this.updateDebugShowBoundingVolume = e.updateDebugShowBoundingVolume, this.is2D = y(e.is2D, !1), this.derivedCommand2D = void 0 } Pm.clone = function (e) { return new Pm({ command: e.command, updateShadows: e.updateShadows, updateBackFaceCulling: e.updateBackFaceCulling, updateCullFace: e.updateCullFace, updateDebugShowBoundingVolume: e.updateDebugShowBoundingVolume, is2D: e.is2D, derivedCommand2D: e.derivedCommand2D }) }; function bFe(e) { let t = e._command; t.modelMatrix = e._modelMatrix, t.boundingVolume = e._boundingVolume; let n = e._model, i = e._usesBackFaceCulling, o = e._derivedCommands; e._originalCommand = new Pm({ command: t, updateShadows: !0, updateBackFaceCulling: i, updateCullFace: i, updateDebugShowBoundingVolume: !0, is2D: !1 }), o.push(e._originalCommand), e._needsTranslucentCommand && (e._translucentCommand = new Pm({ command: OFe(t), updateShadows: !0, updateBackFaceCulling: !1, updateCullFace: !1, updateDebugShowBoundingVolume: !0 }), o.push(e._translucentCommand)), e._needsSkipLevelOfDetailCommands && (e._skipLodBackfaceCommand = new Pm({ command: NFe(t), updateShadows: !1, updateBackFaceCulling: !1, updateCullFace: i, updateDebugShowBoundingVolume: !1 }), e._skipLodStencilCommand = new Pm({ command: VFe(t, n), updateShadows: !0, updateBackFaceCulling: i, updateCullFace: i, updateDebugShowBoundingVolume: !0 }), o.push(e._skipLodBackfaceCommand), o.push(e._skipLodStencilCommand)), e._needsSilhouetteCommands && (e._silhouetteModelCommand = new Pm({ command: BFe(t, n), updateShadows: !0, updateBackFaceCulling: i, updateCullFace: i, updateDebugShowBoundingVolume: !0 }), e._silhouetteColorCommand = new Pm({ command: RFe(t, n), updateShadows: !1, updateBackFaceCulling: !1, updateCullFace: !1, updateDebugShowBoundingVolume: !1 }), o.push(e._silhouetteModelCommand), o.push(e._silhouetteColorCommand)) } Object.defineProperties($R.prototype, { command: { get: function () { return this._command } }, runtimePrimitive: { get: function () { return this._runtimePrimitive } }, model: { get: function () { return this._model } }, primitiveType: { get: function () { return this._command.primitiveType } }, modelMatrix: { get: function () { return this._modelMatrix }, set: function (e) { this._modelMatrix = F.clone(e, this._modelMatrix), this._modelMatrix2DDirty = !0, this._boundingVolume = re.transform(this.runtimePrimitive.boundingSphere, this._modelMatrix, this._boundingVolume) } }, boundingVolume: { get: function () { return this._boundingVolume } }, shadows: { get: function () { return this._shadows }, set: function (e) { this._shadows = e, wFe(this) } }, backFaceCulling: { get: function () { return this._backFaceCulling }, set: function (e) { this._backFaceCulling !== e && (this._backFaceCulling = e, DFe(this)) } }, cullFace: { get: function () { return this._cullFace }, set: function (e) { this._cullFace !== e && (this._cullFace = e, vFe(this)) } }, debugShowBoundingVolume: { get: function () { return this._debugShowBoundingVolume }, set: function (e) { this._debugShowBoundingVolume !== e && (this._debugShowBoundingVolume = e, PFe(this)) } } }); function SFe(e, t) { let n = e._modelMatrix; e._modelMatrix2D = F.clone(n, e._modelMatrix2D), e._modelMatrix2D[13] -= I.sign(n[13]) * 2 * I.PI * t.mapProjection.ellipsoid.maximumRadius, e._boundingVolume2D = re.transform(e.runtimePrimitive.boundingSphere, e._modelMatrix2D, e._boundingVolume2D) } function wFe(e) { let t = e.shadows, n = hn.castShadows(t), i = hn.receiveShadows(t), o = e._derivedCommands, r = o.length; for (let s = 0; s < r; ++s) { let a = o[s]; if (a.updateShadows) { let c = a.command; c.castShadows = n, c.receiveShadows = i } } } function DFe(e) { let t = e.backFaceCulling, n = e._derivedCommands, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; if (r.updateBackFaceCulling) { let s = r.command, a = tt(s.renderState, !0); a.cull.enabled = t, s.renderState = Ve.fromCache(a) } } } function vFe(e) { let t = e.cullFace, n = e._derivedCommands, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; if (r.updateCullFace) { let s = r.command, a = tt(s.renderState, !0); a.cull.face = t, s.renderState = Ve.fromCache(a) } } } function PFe(e) { let t = e.debugShowBoundingVolume, n = e._derivedCommands, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; if (r.updateDebugShowBoundingVolume) { let s = r.command; s.debugShowBoundingVolume = t } } } $R.prototype.pushCommands = function (e, t) { let n = mee(this, e); n && !this._has2DCommands && (IFe(this), this._has2DCommands = !0, this._modelMatrix2DDirty = !0), this._modelMatrix2DDirty && (SFe(this, e), this._modelMatrix2DDirty = !1); let i = this.model.styleCommandsNeeded; if (!(this._needsTranslucentCommand && l(i) && (i !== Kd.ALL_OPAQUE && fx(t, this._translucentCommand, n), i === Kd.ALL_TRANSLUCENT))) { if (this._needsSkipLevelOfDetailCommands) { let o = this._model.content, r = o.tileset, s = o.tile, a = r._hasMixedContent, c = s._finalResolution; if (a) { c || fx(r._backfaceCommands, this._skipLodBackfaceCommand, n), MFe(this, s, n), fx(t, this._skipLodStencilCommand, n); return } } if (this._needsSilhouetteCommands) { fx(t, this._silhouetteModelCommand, n); return } return fx(t, this._originalCommand, n), t } }; $R.prototype.pushSilhouetteCommands = function (e, t) { let n = mee(this, e); return fx(t, this._silhouetteColorCommand, n), t }; function fx(e, t, n) { e.push(t.command), n && e.push(t.derivedCommand2D.command) } function mee(e, t) { if (t.mode !== ee.SCENE2D || e.model._projectTo2D) return !1; let i = e.model.sceneGraph._boundingSphere2D, o = i.center.y - i.radius, r = i.center.y + i.radius, s = t.mapProjection.ellipsoid.maximumRadius * I.PI; return o < s && r > s || o < -s && r > -s } function ux(e, t) { if (!l(t)) return; let n = Pm.clone(t), i = $e.shallowClone(t.command); return i.modelMatrix = e._modelMatrix2D, i.boundingVolume = e._boundingVolume2D, n.command = i, n.updateShadows = !1, n.is2D = !0, t.derivedCommand2D = n, e._derivedCommands.push(n), n } function IFe(e) { ux(e, e._originalCommand), ux(e, e._translucentCommand), ux(e, e._skipLodBackfaceCommand), ux(e, e._skipLodStencilCommand), ux(e, e._silhouetteModelCommand), ux(e, e._silhouetteColorCommand) } function OFe(e) { let t = $e.shallowClone(e); t.pass = xe.TRANSLUCENT; let n = tt(e.renderState, !0); return n.cull.enabled = !1, n.depthMask = !1, n.blending = an.ALPHA_BLEND, t.renderState = Ve.fromCache(n), t } function BFe(e, t) { let n = t._silhouetteId % 255, i = $e.shallowClone(e), o = tt(e.renderState, !0); return o.stencilTest = { enabled: !0, frontFunction: te.ALWAYS, backFunction: te.ALWAYS, reference: n, mask: -1, frontOperation: { fail: te.KEEP, zFail: te.KEEP, zPass: te.REPLACE }, backOperation: { fail: te.KEEP, zFail: te.KEEP, zPass: te.REPLACE } }, t.isInvisible() && (o.colorMask = { red: !1, green: !1, blue: !1, alpha: !1 }), i.renderState = Ve.fromCache(o), i } function RFe(e, t) { let n = t._silhouetteId % 255, i = $e.shallowClone(e), o = tt(e.renderState, !0); o.cull.enabled = !1, (e.pass === xe.TRANSLUCENT || t.silhouetteColor.alpha < 1) && (i.pass = xe.TRANSLUCENT, o.depthMask = !1, o.blending = an.ALPHA_BLEND), o.stencilTest = { enabled: !0, frontFunction: te.NOTEQUAL, backFunction: te.NOTEQUAL, reference: n, mask: -1, frontOperation: { fail: te.KEEP, zFail: te.KEEP, zPass: te.KEEP }, backOperation: { fail: te.KEEP, zFail: te.KEEP, zPass: te.KEEP } }; let s = tt(e.uniformMap); return s.model_silhouettePass = function () { return !0 }, i.renderState = Ve.fromCache(o), i.uniformMap = s, i.castShadows = !1, i.receiveShadows = !1, i } function MFe(e, t, n) { let i = e._skipLodStencilCommand, o = i.command, r = t._selectionDepth, s = LFe(o); if (r !== s) { let a = FFe(r), c = tt(o.renderState, !0); c.stencilTest.reference = a, o.renderState = Ve.fromCache(c), n && (i.derivedCommand2D.renderState = c) } } function LFe(e) { return (e.renderState.stencilTest.reference & vt.SKIP_LOD_MASK) >>> vt.SKIP_LOD_BIT_SHIFT } function FFe(e) { return vt.CESIUM_3D_TILE_MASK | e << vt.SKIP_LOD_BIT_SHIFT } function NFe(e) { let t = $e.shallowClone(e), n = tt(e.renderState, !0); n.cull.enabled = !0, n.cull.face = gi.FRONT, n.colorMask = { red: !1, green: !1, blue: !1, alpha: !1 }, n.polygonOffset = { enabled: !0, factor: 5, units: 5 }; let i = tt(t.uniformMap), o = new H(5, 5); return i.u_polygonOffset = function () { return o }, t.renderState = Ve.fromCache(n), t.uniformMap = i, t.castShadows = !1, t.receiveShadows = !1, t } function VFe(e) { let t = $e.shallowClone(e), n = tt(e.renderState, !0); return n.stencilTest.enabled = !0, n.stencilTest.mask = vt.SKIP_LOD_MASK, n.stencilTest.reference = vt.CESIUM_3D_TILE_MASK, n.stencilTest.frontFunction = Fn.GREATER_OR_EQUAL, n.stencilTest.frontOperation.zPass = lt.REPLACE, n.stencilTest.backFunction = Fn.GREATER_OR_EQUAL, n.stencilTest.backOperation.zPass = lt.REPLACE, n.stencilMask = vt.CESIUM_3D_TILE_MASK | vt.SKIP_LOD_MASK, t.renderState = Ve.fromCache(n), t } var eM = $R; function kFe(e, t) { let n = e.shaderBuilder; n.addVertexLines(ZR), n.addFragmentLines(JR); let i = UFe(e), o = new Qn({ context: t.context, indexBuffer: i, attributes: e.attributes }), r = e.model; r._pipelineResources.push(o); let s = n.buildShaderProgram(t.context); r._pipelineResources.push(s); let a = e.alphaOptions.pass, c = r.sceneGraph, u = F.multiplyTransformation(c.computedModelMatrix, e.runtimeNode.computedTransform, new F), f; t.mode !== ee.SCENE3D && !t.scene3DOnly && r._projectTo2D ? f = e.runtimePrimitive.boundingSphere2D : f = re.transform(e.boundingSphere, u, e.boundingSphere); let d = tt(Ve.fromCache(e.renderStateOptions), !0); d.cull.face = tn.getCullFace(u, e.primitiveType), d = Ve.fromCache(d); let p = l(r.classificationType), g = p ? !1 : hn.castShadows(r.shadows), m = p ? !1 : hn.receiveShadows(r.shadows), A = p ? void 0 : e.pickId, C = new $e({ boundingVolume: f, modelMatrix: u, uniformMap: e.uniformMap, renderState: d, vertexArray: o, shaderProgram: s, cull: r.cull, pass: a, count: e.count, owner: r, pickId: A, instanceCount: e.instanceCount, primitiveType: e.primitiveType, debugShowBoundingVolume: r.debugShowBoundingVolume, castShadows: g, receiveShadows: m }); return p ? new QR({ primitiveRenderResources: e, command: C }) : new eM({ primitiveRenderResources: e, command: C }) } function UFe(e) { let t = e.wireframeIndexBuffer; if (l(t)) return t; let n = e.indices; if (!!l(n)) return n.buffer } var tM = kFe; var j0 = { VERTEX: 0, FRAGMENT: 1, BOTH: 2 }; j0.includesVertexShader = function (e) { return e === j0.VERTEX || e === j0.BOTH }; j0.includesFragmentShader = function (e) { return e === j0.FRAGMENT || e === j0.BOTH }; var Te = Object.freeze(j0); var pee = { name: "TilesetPipelineStage" }; pee.process = function (e, t, n) { if (t.hasSkipLevelOfDetail(n)) { e.shaderBuilder.addDefine("POLYGON_OFFSET", void 0, Te.FRAGMENT); let r = { u_polygonOffset: function () { return H.ZERO } }; e.uniformMap = yt(r, e.uniformMap), e.hasSkipLevelOfDetail = !0 } let i = e.renderStateOptions; i.stencilTest = vt.setCesium3DTileBit(), i.stencilMask = vt.CESIUM_3D_TILE_MASK }; var nM = pee; var iM = `vec3 proceduralIBL(
vec3 positionEC,
vec3 normalEC,
vec3 lightDirectionEC,
vec3 lightColorHdr,
czm_pbrParameters pbrParameters
) {
vec3 v = -positionEC;
vec3 positionWC = vec3(czm_inverseView * vec4(positionEC, 1.0));
vec3 vWC = -normalize(positionWC);
vec3 l = normalize(lightDirectionEC);
vec3 n = normalEC;
vec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n)));
float NdotL = clamp(dot(n, l), 0.001, 1.0);
float NdotV = abs(dot(n, v)) + 0.001;
float vertexRadius = length(positionWC);
float horizonDotNadir = 1.0 - min(1.0, czm_ellipsoidRadii.x / vertexRadius);
float reflectionDotNadir = dot(r, normalize(positionWC));
r.x = -r.x;
r = -normalize(czm_temeToPseudoFixed * r);
r.x = -r.x;
vec3 diffuseColor = pbrParameters.diffuseColor;
float roughness = pbrParameters.roughness;
vec3 specularColor = pbrParameters.f0;
float inverseRoughness = 1.04 - roughness;
inverseRoughness *= inverseRoughness;
vec3 sceneSkyBox = textureCube(czm_environmentMap, r).rgb * inverseRoughness;
float atmosphereHeight = 0.05;
float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir);
float blendRegionOffset = roughness * -1.0;
float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999);
float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999);
float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999);
float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir);
vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight);
vec3 nadirColor = belowHorizonColor * 0.5;
vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5);
vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75);
vec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight);
vec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9);
float diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight;
float diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25));
vec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0);
float notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8);
vec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough);
specularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness);
specularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness);
#ifdef USE_SUN_LUMINANCE
float LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * l), vWC), 0.001, 1.0);
float S = acos(LdotZenith);
float NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), vWC), 0.001, 1.0);
float gamma = acos(NdotL);
float numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(NdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith)));
float denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith,2.0)) * (1.0 - exp(-0.32));
float luminance = model_luminanceAtZenith * (numerator / denominator);
#endif
vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;
vec3 iblColor = (diffuseIrradiance * diffuseColor * model_iblFactor.x) + (specularIrradiance * czm_srgbToLinear(specularColor * brdfLut.x + brdfLut.y) * model_iblFactor.y);
float maximumComponent = max(max(lightColorHdr.x, lightColorHdr.y), lightColorHdr.z);
vec3 lightColor = lightColorHdr / max(maximumComponent, 1.0);
iblColor *= lightColor;
#ifdef USE_SUN_LUMINANCE
iblColor *= luminance;
#endif
return iblColor;
}
vec3 textureIBL(
vec3 positionEC,
vec3 normalEC,
vec3 lightDirectionEC,
czm_pbrParameters pbrParameters
) {
vec3 diffuseColor = pbrParameters.diffuseColor;
float roughness = pbrParameters.roughness;
vec3 specularColor = pbrParameters.f0;
vec3 v = -positionEC;
vec3 n = normalEC;
vec3 l = normalize(lightDirectionEC);
vec3 h = normalize(v + l);
float NdotV = abs(dot(n, v)) + 0.001;
float VdotH = clamp(dot(v, h), 0.0, 1.0);
const mat3 yUpToZUp = mat3(
-1.0, 0.0, 0.0,
0.0, 0.0, -1.0,
0.0, 1.0, 0.0
);
vec3 cubeDir = normalize(yUpToZUp * model_iblReferenceFrameMatrix * normalize(reflect(-v, n)));
#ifdef DIFFUSE_IBL
#ifdef CUSTOM_SPHERICAL_HARMONICS
vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, model_sphericalHarmonicCoefficients);
#else
vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, czm_sphericalHarmonicCoefficients);
#endif
#else
vec3 diffuseIrradiance = vec3(0.0);
#endif
#ifdef SPECULAR_IBL
vec3 r0 = specularColor.rgb;
float reflectance = max(max(r0.r, r0.g), r0.b);
vec3 r90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));
vec3 F = fresnelSchlick2(r0, r90, VdotH);
vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;
#ifdef CUSTOM_SPECULAR_IBL
vec3 specularIBL = czm_sampleOctahedralProjection(model_specularEnvironmentMaps, model_specularEnvironmentMapsSize, cubeDir, roughness * model_specularEnvironmentMapsMaximumLOD, model_specularEnvironmentMapsMaximumLOD);
#else
vec3 specularIBL = czm_sampleOctahedralProjection(czm_specularEnvironmentMaps, czm_specularEnvironmentMapSize, cubeDir,  roughness * czm_specularEnvironmentMapsMaximumLOD, czm_specularEnvironmentMapsMaximumLOD);
#endif
specularIBL *= F * brdfLut.x + brdfLut.y;
#else
vec3 specularIBL = vec3(0.0);
#endif
return diffuseColor * diffuseIrradiance + specularColor * specularIBL;
}
vec3 imageBasedLightingStage(
vec3 positionEC,
vec3 normalEC,
vec3 lightDirectionEC,
vec3 lightColorHdr,
czm_pbrParameters pbrParameters
) {
#if defined(DIFFUSE_IBL) || defined(SPECULAR_IBL)
return textureIBL(
positionEC,
normalEC,
lightDirectionEC,
pbrParameters
);
#else
return proceduralIBL(
positionEC,
normalEC,
lightDirectionEC,
lightColorHdr,
pbrParameters
);
#endif
}
`; var _ee = { name: "ImageBasedLightingPipelineStage" }; _ee.process = function (e, t, n) { let i = t.imageBasedLighting, o = e.shaderBuilder; o.addDefine("USE_IBL_LIGHTING", void 0, Te.FRAGMENT), o.addUniform("vec2", "model_iblFactor", Te.FRAGMENT), Vd.isSupported(n.context) && ((i.useSphericalHarmonics || i.useSpecularEnvironmentMaps || i.enabled) && o.addUniform("mat3", "model_iblReferenceFrameMatrix", Te.FRAGMENT), l(i.sphericalHarmonicCoefficients) ? (o.addDefine("DIFFUSE_IBL", void 0, Te.FRAGMENT), o.addDefine("CUSTOM_SPHERICAL_HARMONICS", void 0, Te.FRAGMENT), o.addUniform("vec3", "model_sphericalHarmonicCoefficients[9]", Te.FRAGMENT)) : i.useDefaultSphericalHarmonics && o.addDefine("DIFFUSE_IBL", void 0, Te.FRAGMENT), l(i.specularEnvironmentMapAtlas) && i.specularEnvironmentMapAtlas.ready ? (o.addDefine("SPECULAR_IBL", void 0, Te.FRAGMENT), o.addDefine("CUSTOM_SPECULAR_IBL", void 0, Te.FRAGMENT), o.addUniform("sampler2D", "model_specularEnvironmentMaps", Te.FRAGMENT), o.addUniform("vec2", "model_specularEnvironmentMapsSize", Te.FRAGMENT), o.addUniform("float", "model_specularEnvironmentMapsMaximumLOD", Te.FRAGMENT)) : t.useDefaultSpecularMaps && o.addDefine("SPECULAR_IBL", void 0, Te.FRAGMENT)), l(i.luminanceAtZenith) && (o.addDefine("USE_SUN_LUMINANCE", void 0, Te.FRAGMENT), o.addUniform("float", "model_luminanceAtZenith", Te.FRAGMENT)), o.addFragmentLines(iM); let r = { model_iblFactor: function () { return i.imageBasedLightingFactor }, model_iblReferenceFrameMatrix: function () { return t._iblReferenceFrameMatrix }, model_luminanceAtZenith: function () { return i.luminanceAtZenith }, model_sphericalHarmonicCoefficients: function () { return i.sphericalHarmonicCoefficients }, model_specularEnvironmentMaps: function () { return i.specularEnvironmentMapAtlas.texture }, model_specularEnvironmentMapsSize: function () { return i.specularEnvironmentMapAtlas.texture.dimensions }, model_specularEnvironmentMapsMaximumLOD: function () { return i.specularEnvironmentMapAtlas.maximumMipmapLevel } }; e.uniformMap = yt(r, e.uniformMap) }; var oM = _ee; var zFe = I.EPSILON16; function P8(e) { e = y(e, y.EMPTY_OBJECT); let t = e.stage, n = e.runtimeArticulation; this._stage = t, this._runtimeArticulation = n, this._name = t.name, this._type = t.type, this._minimumValue = t.minimumValue, this._maximumValue = t.maximumValue, this._currentValue = t.initialValue } Object.defineProperties(P8.prototype, { stage: { get: function () { return this._stage } }, runtimeArticulation: { get: function () { return this._runtimeArticulation } }, name: { get: function () { return this._name } }, type: { get: function () { return this._type } }, minimumValue: { get: function () { return this._minimumValue } }, maximumValue: { get: function () { return this._maximumValue } }, currentValue: { get: function () { return this._currentValue }, set: function (e) { e = I.clamp(e, this.minimumValue, this.maximumValue), I.equalsEpsilon(this._currentValue, e, zFe) || (this._currentValue = e, this.runtimeArticulation._dirty = !0) } } }); var HFe = new h, v8 = new Q; P8.prototype.applyStageToMatrix = function (e) { let t = this.type, n = this.currentValue, i = HFe, o; switch (t) { case rc.XROTATE: o = Q.fromRotationX(I.toRadians(n), v8), e = F.multiplyByMatrix3(e, o, e); break; case rc.YROTATE: o = Q.fromRotationY(I.toRadians(n), v8), e = F.multiplyByMatrix3(e, o, e); break; case rc.ZROTATE: o = Q.fromRotationZ(I.toRadians(n), v8), e = F.multiplyByMatrix3(e, o, e); break; case rc.XTRANSLATE: i.x = n, i.y = 0, i.z = 0, e = F.multiplyByTranslation(e, i, e); break; case rc.YTRANSLATE: i.x = 0, i.y = n, i.z = 0, e = F.multiplyByTranslation(e, i, e); break; case rc.ZTRANSLATE: i.x = 0, i.y = 0, i.z = n, e = F.multiplyByTranslation(e, i, e); break; case rc.XSCALE: i.x = n, i.y = 1, i.z = 1, e = F.multiplyByScale(e, i, e); break; case rc.YSCALE: i.x = 1, i.y = n, i.z = 1, e = F.multiplyByScale(e, i, e); break; case rc.ZSCALE: i.x = 1, i.y = 1, i.z = n, e = F.multiplyByScale(e, i, e); break; case rc.UNIFORMSCALE: e = F.multiplyByUniformScale(e, n, e); break; default: break }return e }; var rM = P8; function sM(e) { e = y(e, y.EMPTY_OBJECT); let t = e.articulation, n = e.sceneGraph; this._articulation = t, this._sceneGraph = n, this._name = t.name, this._runtimeStages = [], this._runtimeStagesByName = {}, this._runtimeNodes = [], this._dirty = !0, GFe(this) } Object.defineProperties(sM.prototype, { articulation: { get: function () { return this._articulation } }, sceneGraph: { get: function () { return this._sceneGraph } }, name: { get: function () { return this._name } }, runtimeStages: { get: function () { return this._runtimeStages } }, runtimeNodes: { get: function () { return this._runtimeNodes } } }); function GFe(e) { let n = e.articulation.stages, i = n.length, o = e._runtimeStages, r = e._runtimeStagesByName; for (let s = 0; s < i; s++) { let a = n[s], c = new rM({ stage: a, runtimeArticulation: e }); o.push(c); let u = a.name; r[u] = c } } sM.prototype.setArticulationStage = function (e, t) { let n = this._runtimeStagesByName[e]; l(n) && (n.currentValue = t) }; var WFe = new F, jFe = new F; sM.prototype.apply = function () { if (!this._dirty) return; this._dirty = !1; let e = F.clone(F.IDENTITY, WFe), t, n = this._runtimeStages, i = n.length; for (t = 0; t < i; t++)e = n[t].applyStageToMatrix(e); let o = this._runtimeNodes, r = o.length; for (t = 0; t < r; t++) { let s = o[t], a = F.multiplyTransformation(s.originalTransform, e, jFe); s.transform = a } }; var aM = sM; var cM = `void modelColorStage(inout czm_modelMaterial material)
{
material.diffuse = mix(material.diffuse, model_color.rgb, model_colorBlend);
float highlight = ceil(model_colorBlend);
material.diffuse *= mix(model_color.rgb, vec3(1.0), highlight);
material.alpha *= model_color.a;
}
`; var dx = { name: "ModelColorPipelineStage", COLOR_UNIFORM_NAME: "model_color", COLOR_BLEND_UNIFORM_NAME: "model_colorBlend" }; dx.process = function (e, t, n) { let i = e.shaderBuilder; i.addDefine("HAS_MODEL_COLOR", void 0, Te.FRAGMENT), i.addFragmentLines(cM); let o = {}, r = t.color; r.alpha === 0 && !t.hasSilhouette(n) && (e.renderStateOptions.colorMask = { red: !1, green: !1, blue: !1, alpha: !1 }), r.alpha < 1 && (e.alphaOptions.pass = xe.TRANSLUCENT), i.addUniform("vec4", dx.COLOR_UNIFORM_NAME, Te.FRAGMENT), o[dx.COLOR_UNIFORM_NAME] = function () { return t.color }, i.addUniform("float", dx.COLOR_BLEND_UNIFORM_NAME, Te.FRAGMENT), o[dx.COLOR_BLEND_UNIFORM_NAME] = function () { return oc.getColorBlend(t.colorBlendMode, t.colorBlendAmount) }, e.uniformMap = yt(o, e.uniformMap) }; var q0 = dx; var lM = `#ifdef USE_CLIPPING_PLANES_FLOAT_TEXTURE
vec4 getClippingPlane(
highp sampler2D packedClippingPlanes,
int clippingPlaneNumber,
mat4 transform
) {
int pixY = clippingPlaneNumber / CLIPPING_PLANES_TEXTURE_WIDTH;
int pixX = clippingPlaneNumber - (pixY * CLIPPING_PLANES_TEXTURE_WIDTH);
float pixelWidth = 1.0 / float(CLIPPING_PLANES_TEXTURE_WIDTH);
float pixelHeight = 1.0 / float(CLIPPING_PLANES_TEXTURE_HEIGHT);
float u = (float(pixX) + 0.5) * pixelWidth;
float v = (float(pixY) + 0.5) * pixelHeight;
vec4 plane = texture2D(packedClippingPlanes, vec2(u, v));
return czm_transformPlane(plane, transform);
}
#else
vec4 getClippingPlane(
highp sampler2D packedClippingPlanes,
int clippingPlaneNumber,
mat4 transform
) {
int clippingPlaneStartIndex = clippingPlaneNumber * 2;
int pixY = clippingPlaneStartIndex / CLIPPING_PLANES_TEXTURE_WIDTH;
int pixX = clippingPlaneStartIndex - (pixY * CLIPPING_PLANES_TEXTURE_WIDTH);
float pixelWidth = 1.0 / float(CLIPPING_PLANES_TEXTURE_WIDTH);
float pixelHeight = 1.0 / float(CLIPPING_PLANES_TEXTURE_HEIGHT);
float u = (float(pixX) + 0.5) * pixelWidth;
float v = (float(pixY) + 0.5) * pixelHeight;
vec4 oct32 = texture2D(packedClippingPlanes, vec2(u, v)) * 255.0;
vec2 oct = vec2(oct32.x * 256.0 + oct32.y, oct32.z * 256.0 + oct32.w);
vec4 plane;
plane.xyz = czm_octDecode(oct, 65535.0);
plane.w = czm_unpackFloat(texture2D(packedClippingPlanes, vec2(u + pixelWidth, v)));
return czm_transformPlane(plane, transform);
}
#endif
float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix) {
vec4 position = czm_windowToEyeCoordinates(fragCoord);
vec3 clipNormal = vec3(0.0);
vec3 clipPosition = vec3(0.0);
float pixelWidth = czm_metersPerPixel(position);
#ifdef UNION_CLIPPING_REGIONS
float clipAmount;
#else
float clipAmount = 0.0;
bool clipped = true;
#endif
for (int i = 0; i < CLIPPING_PLANES_LENGTH; ++i) {
vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);
clipNormal = clippingPlane.xyz;
clipPosition = -clippingPlane.w * clipNormal;
float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;
#ifdef UNION_CLIPPING_REGIONS
clipAmount = czm_branchFreeTernary(i == 0, amount, min(amount, clipAmount));
if (amount <= 0.0) {
discard;
}
#else
clipAmount = max(amount, clipAmount);
clipped = clipped && (amount <= 0.0);
#endif
}
#ifndef UNION_CLIPPING_REGIONS
if (clipped) {
discard;
}
#endif
return clipAmount;
}
void modelClippingPlanesStage(inout vec4 color)
{
float clipDistance = clip(gl_FragCoord, model_clippingPlanes, model_clippingPlanesMatrix);
vec4 clippingPlanesEdgeColor = vec4(1.0);
clippingPlanesEdgeColor.rgb = model_clippingPlanesEdgeStyle.rgb;
float clippingPlanesEdgeWidth = model_clippingPlanesEdgeStyle.a;
if (clipDistance > 0.0 && clipDistance < clippingPlanesEdgeWidth) {
color = clippingPlanesEdgeColor;
}
}
`; var gee = { name: "ModelClippingPlanesPipelineStage" }, qFe = new H; gee.process = function (e, t, n) { let i = t.clippingPlanes, o = n.context, r = e.shaderBuilder; r.addDefine("HAS_CLIPPING_PLANES", void 0, Te.FRAGMENT), r.addDefine("CLIPPING_PLANES_LENGTH", i.length, Te.FRAGMENT), i.unionClippingRegions && r.addDefine("UNION_CLIPPING_REGIONS", void 0, Te.FRAGMENT), Ks.useFloatTexture(o) && r.addDefine("USE_CLIPPING_PLANES_FLOAT_TEXTURE", void 0, Te.FRAGMENT); let s = Ks.getTextureResolution(i, o, qFe); r.addDefine("CLIPPING_PLANES_TEXTURE_WIDTH", s.x, Te.FRAGMENT), r.addDefine("CLIPPING_PLANES_TEXTURE_HEIGHT", s.y, Te.FRAGMENT), r.addUniform("sampler2D", "model_clippingPlanes", Te.FRAGMENT), r.addUniform("vec4", "model_clippingPlanesEdgeStyle", Te.FRAGMENT), r.addUniform("mat4", "model_clippingPlanesMatrix", Te.FRAGMENT), r.addFragmentLines(lM); let a = { model_clippingPlanes: function () { return i.texture }, model_clippingPlanesEdgeStyle: function () { let c = U.clone(i.edgeColor); return c.alpha = i.edgeWidth, c }, model_clippingPlanesMatrix: function () { return t._clippingPlanesMatrix } }; e.uniformMap = yt(a, e.uniformMap) }; var uM = gee; function yee(e, t) { this._model = e, this._runtimeNode = t } Object.defineProperties(yee.prototype, { name: { get: function () { return this._runtimeNode._name } }, id: { get: function () { return this._runtimeNode._id } }, show: { get: function () { return this._runtimeNode.show }, set: function (e) { this._runtimeNode.show = e } }, matrix: { get: function () { return this._runtimeNode.transform }, set: function (e) { l(e) ? (this._runtimeNode.transform = e, this._runtimeNode.userAnimated = !0, this._model._userAnimationDirty = !0) : (this._runtimeNode.transform = this.originalMatrix, this._runtimeNode.userAnimated = !1) } }, originalMatrix: { get: function () { return this._runtimeNode.originalTransform } } }); var fM = yee; var dM = `mat4 getInstancingTransform()
{
mat4 instancingTransform;
#ifdef HAS_INSTANCE_MATRICES
instancingTransform = mat4(
a_instancingTransformRow0.x, a_instancingTransformRow1.x, a_instancingTransformRow2.x, 0.0,
a_instancingTransformRow0.y, a_instancingTransformRow1.y, a_instancingTransformRow2.y, 0.0,
a_instancingTransformRow0.z, a_instancingTransformRow1.z, a_instancingTransformRow2.z, 0.0,
a_instancingTransformRow0.w, a_instancingTransformRow1.w, a_instancingTransformRow2.w, 1.0
);
#else
vec3 translation = vec3(0.0, 0.0, 0.0);
vec3 scale = vec3(1.0, 1.0, 1.0);
#ifdef HAS_INSTANCE_TRANSLATION
translation = a_instanceTranslation;
#endif
#ifdef HAS_INSTANCE_SCALE
scale = a_instanceScale;
#endif
instancingTransform = mat4(
scale.x, 0.0, 0.0, 0.0,
0.0, scale.y, 0.0, 0.0,
0.0, 0.0, scale.z, 0.0,
translation.x, translation.y, translation.z, 1.0
);
#endif
return instancingTransform;
}
#ifdef USE_2D_INSTANCING
mat4 getInstancingTransform2D()
{
mat4 instancingTransform2D;
#ifdef HAS_INSTANCE_MATRICES
instancingTransform2D = mat4(
a_instancingTransform2DRow0.x, a_instancingTransform2DRow1.x, a_instancingTransform2DRow2.x, 0.0,
a_instancingTransform2DRow0.y, a_instancingTransform2DRow1.y, a_instancingTransform2DRow2.y, 0.0,
a_instancingTransform2DRow0.z, a_instancingTransform2DRow1.z, a_instancingTransform2DRow2.z, 0.0,
a_instancingTransform2DRow0.w, a_instancingTransform2DRow1.w, a_instancingTransform2DRow2.w, 1.0
);
#else
vec3 translation2D = vec3(0.0, 0.0, 0.0);
vec3 scale = vec3(1.0, 1.0, 1.0);
#ifdef HAS_INSTANCE_TRANSLATION
translation2D = a_instanceTranslation2D;
#endif
#ifdef HAS_INSTANCE_SCALE
scale = a_instanceScale;
#endif
instancingTransform2D = mat4(
scale.x, 0.0, 0.0, 0.0,
0.0, scale.y, 0.0, 0.0,
0.0, 0.0, scale.z, 0.0,
translation2D.x, translation2D.y, translation2D.z, 1.0
);
#endif
return instancingTransform2D;
}
#endif
`; var hM = `void instancingStage(inout ProcessedAttributes attributes)
{
vec3 positionMC = attributes.positionMC;
mat4 instancingTransform = getInstancingTransform();
attributes.positionMC = (instancingTransform * vec4(positionMC, 1.0)).xyz;
#ifdef HAS_NORMALS
vec3 normalMC = attributes.normalMC;
attributes.normalMC = (instancingTransform * vec4(normalMC, 0.0)).xyz;
#endif
#ifdef USE_2D_INSTANCING
mat4 instancingTransform2D = getInstancingTransform2D();
attributes.position2D = (instancingTransform2D * vec4(positionMC, 1.0)).xyz;
#endif
}
`; var mM = `void legacyInstancingStage(
inout ProcessedAttributes attributes,
out mat4 instanceModelView,
out mat3 instanceModelViewInverseTranspose)
{
vec3 positionMC = attributes.positionMC;
mat4 instancingTransform = getInstancingTransform();
mat4 instanceModel = instancingTransform * u_instance_nodeTransform;
instanceModelView = u_instance_modifiedModelView;
instanceModelViewInverseTranspose = mat3(u_instance_modifiedModelView * instanceModel);
attributes.positionMC = (instanceModel * vec4(positionMC, 1.0)).xyz;
#ifdef USE_2D_INSTANCING
mat4 instancingTransform2D = getInstancingTransform2D();
attributes.position2D = (instancingTransform2D * vec4(positionMC, 1.0)).xyz;
#endif
}
`; var pM = new F, YFe = new F, XFe = new F, Cee = { name: "InstancingPipelineStage", _getInstanceTransformsAsMatrices: See, _transformsToTypedArray: O8 }; Cee.process = function (e, t, n) { let i = t.instances, o = i.attributes[0].count, r = e.shaderBuilder; r.addDefine("HAS_INSTANCING"), r.addVertexLines(dM); let s = e.model, a = s.sceneGraph, c = e.runtimeNode, u = n.mode !== ee.SCENE3D && !n.scene3DOnly && s._projectTo2D, f = []; lNe(e, n, i, f, u), dNe(e, n, i, f); let d = {}; if (i.transformInWorldSpace ? (r.addDefine("USE_LEGACY_INSTANCING", void 0, Te.VERTEX), r.addUniform("mat4", "u_instance_modifiedModelView", Te.VERTEX), r.addUniform("mat4", "u_instance_nodeTransform", Te.VERTEX), d.u_instance_modifiedModelView = function () { let p = F.multiplyTransformation(s.modelMatrix, a.components.transform, pM); return u ? F.multiplyTransformation(n.context.uniformState.view3D, p, pM) : (n.mode !== ee.SCENE3D && (p = It.basisTo2D(n.mapProjection, p, pM)), F.multiplyTransformation(n.context.uniformState.view, p, pM)) }, d.u_instance_nodeTransform = function () { return F.multiplyTransformation(a.axisCorrectionMatrix, c.computedTransform, YFe) }, r.addVertexLines(mM)) : r.addVertexLines(hM), u) { r.addDefine("USE_2D_INSTANCING", void 0, Te.VERTEX), r.addUniform("mat4", "u_modelView2D", Te.VERTEX); let p = n.context, g = F.fromTranslation(c.instancingReferencePoint2D, new F); d.u_modelView2D = function () { return F.multiplyTransformation(p.uniformState.view, g, XFe) } } e.uniformMap = yt(d, e.uniformMap), e.instanceCount = o, e.attributes.push.apply(e.attributes, f) }; var OS = new F, KFe = new h; function JFe(e, t, n, i, o) { let r = F.multiplyTransformation(t, e, OS); return r = F.multiplyTransformation(r, n, OS), o = It.basisTo2D(i.mapProjection, r, o), o } function ZFe(e, t, n, i, o) { let r = F.fromTranslation(e, OS), s = F.multiplyTransformation(t, r, OS); s = F.multiplyTransformation(s, n, OS); let a = F.getTranslation(s, KFe); return o = ji.computeActualWgs84Position(i, a, o), o } function xee(e, t, n) { let i = e.model, o = i.sceneGraph; e.runtimeNode.node.instances.transformInWorldSpace ? (t = F.multiplyTransformation(i.modelMatrix, o.components.transform, t), n = F.multiplyTransformation(o.axisCorrectionMatrix, e.runtimeNode.computedTransform, n)) : (t = F.clone(o.computedModelMatrix, t), t = F.multiplyTransformation(t, e.runtimeNode.computedTransform, t), n = F.clone(F.IDENTITY, n)) } var Tee = new F, Eee = new F, QFe = new F, $Fe = new h; function eNe(e, t, n, i) { let o = Tee, r = Eee; xee(t, o, r); let a = t.runtimeNode.instancingReferencePoint2D, c = e.length; for (let u = 0; u < c; u++) { let f = e[u], d = JFe(f, o, r, n, QFe), p = F.getTranslation(d, $Fe), g = h.subtract(p, a, p); i[u] = F.setTranslation(d, g, i[u]) } return i } function tNe(e, t, n, i) { let o = Tee, r = Eee; xee(t, o, r); let a = t.runtimeNode.instancingReferencePoint2D, c = e.length; for (let u = 0; u < c; u++) { let f = e[u], d = ZFe(f, o, r, n, f); i[u] = h.subtract(d, a, i[u]) } return i } var nNe = new h, iNe = new h; function bee(e, t) { let n = e.runtimeNode, i = e.model.sceneGraph.computedModelMatrix, o = F.multiplyByPoint(i, n.instancingTranslationMin, nNe), r = ji.computeActualWgs84Position(t, o, o), s = F.multiplyByPoint(i, n.instancingTranslationMax, iNe), a = ji.computeActualWgs84Position(t, s, s); n.instancingReferencePoint2D = h.lerp(r, a, .5, new h) } function O8(e) { let n = e.length, i = new Float32Array(n * 12); for (let o = 0; o < n; o++) { let r = e[o], s = 12 * o; i[s + 0] = r[0], i[s + 1] = r[4], i[s + 2] = r[8], i[s + 3] = r[12], i[s + 4] = r[1], i[s + 5] = r[5], i[s + 6] = r[9], i[s + 7] = r[13], i[s + 8] = r[2], i[s + 9] = r[6], i[s + 10] = r[10], i[s + 11] = r[14] } return i } function oNe(e) { let n = e.length, i = new Float32Array(n * 3); for (let o = 0; o < n; o++) { let r = e[o], s = 3 * o; i[s + 0] = r[0], i[s + 1] = r[4], i[s + 2] = r[8] } return i } var rNe = new h, sNe = new Be, aNe = new h; function See(e, t, n) { let i = new Array(t), o = tn.getAttributeBySemantic(e, Ur.TRANSLATION), r = tn.getAttributeBySemantic(e, Ur.ROTATION), s = tn.getAttributeBySemantic(e, Ur.SCALE), a = new h(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), c = new h(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), u = l(o), f = l(r), d = l(s), p = u ? o.typedArray : new Float32Array(t * 3), g = f ? r.typedArray : new Float32Array(t * 4); f && r.normalized && (g = kn.dequantize(g, r.componentDatatype, r.type, t)); let m; d ? m = s.typedArray : (m = new Float32Array(t * 3), m.fill(1)); for (let C = 0; C < t; C++) { let x = new h(p[C * 3], p[C * 3 + 1], p[C * 3 + 2], rNe); h.maximumByComponent(a, x, a), h.minimumByComponent(c, x, c); let T = new Be(g[C * 4], g[C * 4 + 1], g[C * 4 + 2], f ? g[C * 4 + 3] : 1, sNe), b = new h(m[C * 3], m[C * 3 + 1], m[C * 3 + 2], aNe), S = F.fromTranslationQuaternionRotationScale(x, T, b, new F); i[C] = S } let A = n.runtimeNode; return A.instancingTranslationMin = c, A.instancingTranslationMax = a, u && (o.typedArray = void 0), f && (r.typedArray = void 0), d && (s.typedArray = void 0), i } function cNe(e, t, n) { let i = new Array(t), o = e.typedArray, r = new h(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), s = new h(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE); for (let c = 0; c < t; c++) { let u = new h(o[c * 3], o[c * 3 + 1], o[c * 3 + 2]); i[c] = u, h.minimumByComponent(r, u, r), h.maximumByComponent(s, u, s) } let a = n.runtimeNode; return a.instancingTranslationMin = r, a.instancingTranslationMax = s, e.typedArray = void 0, i } function B8(e, t) { let n = ct.createVertexBuffer({ context: t.context, typedArray: e, usage: Re.STATIC_DRAW }); return n.vertexArrayDestroyable = !1, n } function lNe(e, t, n, i, o) { let r = tn.getAttributeBySemantic(n, Ur.ROTATION); l(r) ? uNe(e, n, i, t, o) : fNe(e, n, i, t, o) } function uNe(e, t, n, i, o) { let r = e.shaderBuilder, s = t.attributes[0].count, a = e.model, c = e.runtimeNode; r.addDefine("HAS_INSTANCE_MATRICES"); let u = "Transform", f, d = c.instancingTransformsBuffer; if (!l(d)) { f = See(t, s, e); let A = O8(f); d = B8(A, i), a._modelResources.push(d), c.instancingTransformsBuffer = d } if (Aee(e, d, n, u), !o) return; let p = tt(i); p.mode = ee.COLUMBUS_VIEW, bee(e, p); let g = c.instancingTransformsBuffer2D; if (!l(g)) { let A = eNe(f, e, p, f), C = O8(A); g = B8(C, i), a._modelResources.push(g), c.instancingTransformsBuffer2D = g } Aee(e, g, n, "Transform2D") } function fNe(e, t, n, i, o) { let r = e.shaderBuilder, s = e.runtimeNode, a = tn.getAttributeBySemantic(t, Ur.TRANSLATION), c = tn.getAttributeBySemantic(t, Ur.SCALE); if (l(c)) { r.addDefine("HAS_INSTANCE_SCALE"); let x = "Scale"; I8(e, c.buffer, c.byteOffset, c.byteStride, n, x) } if (!l(a)) return; let u, f = a.typedArray; l(f) ? u = cNe(a, a.count, e) : l(s.instancingTranslationMin) || (s.instancingTranslationMin = a.min, s.instancingTranslationMax = a.max), r.addDefine("HAS_INSTANCE_TRANSLATION"); let d = "Translation"; if (I8(e, a.buffer, a.byteOffset, a.byteStride, n, d), !o) return; let p = tt(i); p.mode = ee.COLUMBUS_VIEW, bee(e, p); let g = s.instancingTranslationBuffer2D; if (!l(g)) { let x = tNe(u, e, p, u), T = oNe(x); g = B8(T, i), e.model._modelResources.push(g), s.instancingTranslationBuffer2D = g } I8(e, g, 0, void 0, n, "Translation2D") } function Aee(e, t, n, i) { let r = Y.getSizeInBytes(Y.FLOAT), s = r * 12, a = [{ index: e.attributeIndex++, vertexBuffer: t, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, normalize: !1, offsetInBytes: 0, strideInBytes: s, instanceDivisor: 1 }, { index: e.attributeIndex++, vertexBuffer: t, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, normalize: !1, offsetInBytes: r * 4, strideInBytes: s, instanceDivisor: 1 }, { index: e.attributeIndex++, vertexBuffer: t, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, normalize: !1, offsetInBytes: r * 8, strideInBytes: s, instanceDivisor: 1 }], c = e.shaderBuilder; c.addAttribute("vec4", `a_instancing${i}Row0`), c.addAttribute("vec4", `a_instancing${i}Row1`), c.addAttribute("vec4", `a_instancing${i}Row2`), n.push.apply(n, a) } function I8(e, t, n, i, o, r) { o.push({ index: e.attributeIndex++, vertexBuffer: t, componentsPerAttribute: 3, componentDatatype: Y.FLOAT, normalize: !1, offsetInBytes: n, strideInBytes: i, instanceDivisor: 1 }), e.shaderBuilder.addAttribute("vec3", `a_instance${r}`) } function dNe(e, t, n, i) { let o = n.attributes, r = e.shaderBuilder; for (let s = 0; s < o.length; s++) { let a = o[s]; a.semantic === Ur.FEATURE_ID && (a.setIndex >= e.featureIdVertexAttributeSetIndex && (e.featureIdVertexAttributeSetIndex = a.setIndex + 1), i.push({ index: e.attributeIndex++, vertexBuffer: a.buffer, componentsPerAttribute: en.getNumberOfComponents(a.type), componentDatatype: a.componentDatatype, normalize: !1, offsetInBytes: a.byteOffset, strideInBytes: a.byteStride, instanceDivisor: 1 }), r.addAttribute("float", `a_instanceFeatureId_${a.setIndex}`)) } } var _M = Cee; var R8 = {}; R8.name = "ModelMatrixUpdateStage"; R8.update = function (e, t, n) { let i = n.mode !== ee.SCENE3D; if (!(i && t._model._projectTo2D) && e._transformDirty) { let o = i ? t._computedModelMatrix2D : t._computedModelMatrix; wee(e, t, o, e.transformToRoot), e._transformDirty = !1 } }; function wee(e, t, n, i) { let o; i = F.multiplyTransformation(i, e.transform, new F), e.updateComputedTransform(); let r = e.runtimePrimitives.length; for (o = 0; o < r; o++) { let c = e.runtimePrimitives[o].drawCommand; c.modelMatrix = F.multiplyTransformation(n, i, c.modelMatrix), c.cullFace = tn.getCullFace(c.modelMatrix, c.primitiveType) } let s = e.children.length; for (o = 0; o < s; o++) { let a = t._runtimeNodes[e.children[o]]; a._transformToRoot = F.clone(i, a._transformToRoot), wee(a, t, n, i), a._transformDirty = !1 } } var gM = R8; var Dee = { name: "NodeStatisticsPipelineStage", _countInstancingAttributes: vee, _countGeneratedBuffers: Pee }; Dee.process = function (e, t, n) { let i = e.model.statistics, o = t.instances, r = e.runtimeNode; vee(i, o), Pee(i, r) }; function vee(e, t) { if (!l(t)) return; let n = t.attributes, i = n.length; for (let o = 0; o < i; o++) { let r = n[o]; l(r.buffer) && e.addBuffer(r.buffer, !1) } } function Pee(e, t) { l(t.instancingTransformsBuffer) && e.addBuffer(t.instancingTransformsBuffer, !1), l(t.instancingTransformsBuffer2D) && e.addBuffer(t.instancingTransformsBuffer2D, !1), l(t.instancingTranslationBuffer2D) && e.addBuffer(t.instancingTranslationBuffer2D, !1) } var yM = Dee; function hx(e) { e = y(e, y.EMPTY_OBJECT); let t = e.node, n = e.transform, i = e.transformToRoot, o = e.sceneGraph, r = e.children; this._node = t, this._name = t.name, this._id = t.index, this._sceneGraph = o, this._children = r, this._originalTransform = F.clone(n, this._originalTransform), this._transform = F.clone(n, this._transform), this._transformToRoot = F.clone(i, this._transformToRoot), this._computedTransform = new F, this._transformDirty = !1, this._transformParameters = void 0, this._morphWeights = [], this._runtimeSkin = void 0, this._computedJointMatrices = [], this.show = !0, this.userAnimated = !1, this.pipelineStages = [], this.runtimePrimitives = [], this.updateStages = [], this.instancingTranslationMin = void 0, this.instancingTranslationMax = void 0, this.instancingTransformsBuffer = void 0, this.instancingTransformsBuffer2D = void 0, this.instancingTranslationBuffer2D = void 0, this.instancingReferencePoint2D = void 0, hNe(this) } Object.defineProperties(hx.prototype, { node: { get: function () { return this._node } }, sceneGraph: { get: function () { return this._sceneGraph } }, children: { get: function () { return this._children } }, transform: { get: function () { return this._transform }, set: function (e) { this._transformDirty = !0, this._transform = F.clone(e, this._transform) } }, transformToRoot: { get: function () { return this._transformToRoot } }, computedTransform: { get: function () { return this._computedTransform } }, originalTransform: { get: function () { return this._originalTransform } }, translation: { get: function () { return l(this._transformParameters) ? this._transformParameters.translation : void 0 }, set: function (e) { let t = this._transformParameters, n = t.translation; h.equals(n, e) || (t.translation = h.clone(e, t.translation), M8(this, t)) } }, rotation: { get: function () { return l(this._transformParameters) ? this._transformParameters.rotation : void 0 }, set: function (e) { let t = this._transformParameters, n = t.rotation; Be.equals(n, e) || (t.rotation = Be.clone(e, t.rotation), M8(this, t)) } }, scale: { get: function () { return l(this._transformParameters) ? this._transformParameters.scale : void 0 }, set: function (e) { let t = this._transformParameters, n = t.scale; h.equals(n, e) || (t.scale = h.clone(e, t.scale), M8(this, t)) } }, morphWeights: { get: function () { return this._morphWeights }, set: function (e) { let t = e.length; for (let n = 0; n < t; n++)this._morphWeights[n] = e[n] } }, runtimeSkin: { get: function () { return this._runtimeSkin } }, computedJointMatrices: { get: function () { return this._computedJointMatrices } } }); function hNe(e) { let t = e.transform, n = e.transformToRoot, i = e._computedTransform; e._computedTransform = F.multiply(n, t, i); let o = e.node; l(o.matrix) || (e._transformParameters = new D0(o.translation, o.rotation, o.scale)), l(o.morphWeights) && (e._morphWeights = o.morphWeights.slice()); let r = o.articulationName; if (l(r)) { let c = e.sceneGraph._runtimeArticulations[r]; l(c) && c.runtimeNodes.push(e) } } function M8(e, t) { e._transformDirty = !0, e._transform = F.fromTranslationRotationScale(t, e._transform) } hx.prototype.getChild = function (e) { return this.sceneGraph._runtimeNodes[this.children[e]] }; hx.prototype.configurePipeline = function () { let e = this.node, t = this.pipelineStages; t.length = 0; let n = this.updateStages; n.length = 0, l(e.instances) && t.push(_M), t.push(yM), n.push(gM) }; hx.prototype.updateComputedTransform = function () { this._computedTransform = F.multiply(this._transformToRoot, this._transform, this._computedTransform) }; hx.prototype.updateJointMatrices = function () { let e = this._runtimeSkin; if (!l(e)) return; e.updateJointMatrices(); let t = this._computedJointMatrices, n = e.jointMatrices, i = n.length; for (let o = 0; o < i; o++) { l(t[o]) || (t[o] = new F); let r = F.multiplyTransformation(this.transformToRoot, this.transform, t[o]), s = F.inverseTransformation(r, t[o]); t[o] = F.multiplyTransformation(s, n[o], t[o]) } }; var AM = hx; var Iee = { name: "AlphaPipelineStage" }; Iee.process = function (e, t, n) { let i = e.alphaOptions, o = e.model; i.pass = y(i.pass, o.opaquePass); let r = e.renderStateOptions; i.pass === xe.TRANSLUCENT && (r.cull.enabled = !1, r.depthMask = !1, r.blending = an.ALPHA_BLEND); let s = e.shaderBuilder, a = e.uniformMap; l(i.alphaCutoff) && (s.addDefine("ALPHA_MODE_MASK", void 0, Te.FRAGMENT), s.addUniform("float", "u_alphaCutoff", Te.FRAGMENT), a.u_alphaCutoff = function () { return i.alphaCutoff }) }; var CM = Iee; var Oee = { name: "BatchTexturePipelineStage" }; Oee.process = function (e, t, n) { let i = e.shaderBuilder, o = {}, r = e.model, s = r.featureTables[r.featureTableId], a = s.featuresLength; i.addUniform("int", "model_featuresLength"), o.model_featuresLength = function () { return a }; let c = s.batchTexture; i.addUniform("sampler2D", "model_batchTexture"), o.model_batchTexture = function () { return y(c.batchTexture, c.defaultTexture) }, i.addUniform("vec4", "model_textureStep"), o.model_textureStep = function () { return c.textureStep }, c.textureDimensions.y > 1 && (i.addDefine("MULTILINE_BATCH_TEXTURE"), i.addUniform("vec2", "model_textureDimensions"), o.model_textureDimensions = function () { return c.textureDimensions }), e.uniformMap = yt(o, e.uniformMap) }; var xM = Oee; var Bee = { name: "ClassificationPipelineStage" }; Bee.process = function (e, t, n) { e.shaderBuilder.addDefine("HAS_CLASSIFICATION", void 0, Te.BOTH); let o = e.runtimePrimitive; l(o.batchLengths) || mNe(t, o) }; function mNe(e, t) { let n = tn.getAttributeBySemantic(e, xt.POSITION); if (!l(n)) throw new fe("Primitives must have a position attribute to be used for classification."); let i, o = e.indices, r = l(o); r && (i = o.typedArray, o.typedArray = void 0); let s = r ? o.count : n.count, a = tn.getAttributeBySemantic(e, xt.FEATURE_ID, 0); if (!l(a)) { t.batchLengths = [s], t.batchOffsets = [0]; return } let c = a.typedArray; a.typedArray = void 0; let u = [], f = [0], d = r ? i[0] : 0, p = c[d], g = 0; for (let A = 1; A < s; A++) { let C = r ? i[A] : A, x = c[C]; if (x !== p) { let T = A - g, b = A; u.push(T), f.push(b), g = b, p = x } } let m = s - g; u.push(m), t.batchLengths = u, t.batchOffsets = f } var TM = Bee; var EM = `void filterByPassType(inout vec3 positionMC, vec4 featureColor)
{
bool styleTranslucent = (featureColor.a != 1.0);
if (czm_pass == czm_passTranslucent && !styleTranslucent && !model_commandTranslucent)
{
#ifdef HAS_SILHOUETTE
positionMC *= float(model_silhouettePass);
#else
positionMC *= 0.0;
#endif
}
else if (czm_pass != czm_passTranslucent && styleTranslucent)
{
positionMC *= 0.0;
}
}
void cpuStylingStage(inout vec3 positionMC, inout SelectedFeature feature)
{
float show = ceil(feature.color.a);
positionMC *= show;
#if defined(HAS_SELECTED_FEATURE_ID_ATTRIBUTE) && !defined(HAS_CLASSIFICATION)
filterByPassType(positionMC, feature.color);
#endif
}
`; var bM = `void filterByPassType(vec4 featureColor)
{
bool styleTranslucent = (featureColor.a != 1.0);
if (czm_pass == czm_passTranslucent && !styleTranslucent && !model_commandTranslucent)
{
#ifdef HAS_SILHOUETTE
if(!model_silhouettePass) {
discard;
}
#else
discard;
#endif
}
else if (czm_pass != czm_passTranslucent && styleTranslucent)
{
discard;
}
}
void cpuStylingStage(inout czm_modelMaterial material, SelectedFeature feature)
{
vec4 featureColor = feature.color;
if (featureColor.a == 0.0)
{
discard;
}
#if defined(HAS_SELECTED_FEATURE_ID_TEXTURE) && !defined(HAS_CLASSIFICATION)
filterByPassType(featureColor);
#endif
featureColor = czm_gammaCorrect(featureColor);
#ifdef HAS_CLASSIFICATION
material.diffuse = featureColor.rgb * featureColor.a;
#else
float highlight = ceil(model_colorBlend);
material.diffuse *= mix(featureColor.rgb, vec3(1.0), highlight);
#endif
material.alpha *= featureColor.a;
}
`; var Ree = { name: "CPUStylingPipelineStage" }; Ree.process = function (e, t, n) { let i = e.model, o = e.shaderBuilder; o.addVertexLines(EM), o.addFragmentLines(bM), o.addDefine("USE_CPU_STYLING", void 0, Te.BOTH), l(i.color) || (o.addUniform("float", q0.COLOR_BLEND_UNIFORM_NAME, Te.FRAGMENT), e.uniformMap[q0.COLOR_BLEND_UNIFORM_NAME] = function () { return oc.getColorBlend(i.colorBlendMode, i.colorBlendAmount) }), o.addUniform("bool", "model_commandTranslucent", Te.BOTH), e.uniformMap.model_commandTranslucent = function () { return e.alphaOptions.pass === xe.TRANSLUCENT } }; var SM = Ree; var Mee = { MODIFY_MATERIAL: "MODIFY_MATERIAL", REPLACE_MATERIAL: "REPLACE_MATERIAL" }; Mee.getDefineName = function (e) { return `CUSTOM_SHADER_${e}` }; var C_ = Object.freeze(Mee); var wM = `void customShaderStage(
inout czm_modelVertexOutput vsOutput,
inout ProcessedAttributes attributes,
FeatureIds featureIds,
Metadata metadata,
MetadataClass metadataClass,
MetadataStatistics metadataStatistics
) {
VertexInput vsInput;
initializeInputStruct(vsInput, attributes);
vsInput.featureIds = featureIds;
vsInput.metadata = metadata;
vsInput.metadataClass = metadataClass;
vsInput.metadataStatistics = metadataStatistics;
vertexMain(vsInput, vsOutput);
attributes.positionMC = vsOutput.positionMC;
}
`; var DM = `void customShaderStage(
inout czm_modelMaterial material,
ProcessedAttributes attributes,
FeatureIds featureIds,
Metadata metadata,
MetadataClass metadataClass,
MetadataStatistics metadataStatistics
) {
FragmentInput fsInput;
initializeInputStruct(fsInput, attributes);
fsInput.featureIds = featureIds;
fsInput.metadata = metadata;
fsInput.metadataClass = metadataClass;
fsInput.metadataStatistics = metadataStatistics;
fragmentMain(fsInput, material);
}
`; var vM = `void featureIdStage(out FeatureIds featureIds, ProcessedAttributes attributes) {
initializeFeatureIds(featureIds, attributes);
initializeFeatureIdAliases(featureIds);
}
`; var PM = `void featureIdStage(out FeatureIds featureIds, ProcessedAttributes attributes)
{
initializeFeatureIds(featureIds, attributes);
initializeFeatureIdAliases(featureIds);
setFeatureIdVaryings();
}
`; var Ci = { name: "FeatureIdPipelineStage", STRUCT_ID_FEATURE_IDS_VS: "FeatureIdsVS", STRUCT_ID_FEATURE_IDS_FS: "FeatureIdsFS", STRUCT_NAME_FEATURE_IDS: "FeatureIds", FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS: "initializeFeatureIdsVS", FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS: "initializeFeatureIdsFS", FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS: "initializeFeatureIdAliasesVS", FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS: "initializeFeatureIdAliasesFS", FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS: "void initializeFeatureIds(out FeatureIds featureIds, ProcessedAttributes attributes)", FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES: "void initializeFeatureIdAliases(inout FeatureIds featureIds)", FUNCTION_ID_SET_FEATURE_ID_VARYINGS: "setFeatureIdVaryings", FUNCTION_SIGNATURE_SET_FEATURE_ID_VARYINGS: "void setFeatureIdVaryings()" }; Ci.process = function (e, t, n) { let i = e.shaderBuilder; pNe(i); let o = e.runtimeNode.node.instances; l(o) && _Ne(e, o, n), gNe(e, t, n), i.addVertexLines(PM), i.addFragmentLines(vM) }; function pNe(e) { e.addStruct(Ci.STRUCT_ID_FEATURE_IDS_VS, Ci.STRUCT_NAME_FEATURE_IDS, Te.VERTEX), e.addStruct(Ci.STRUCT_ID_FEATURE_IDS_FS, Ci.STRUCT_NAME_FEATURE_IDS, Te.FRAGMENT), e.addFunction(Ci.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS, Ci.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS, Te.VERTEX), e.addFunction(Ci.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS, Ci.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS, Te.FRAGMENT), e.addFunction(Ci.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS, Ci.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES, Te.VERTEX), e.addFunction(Ci.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS, Ci.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES, Te.FRAGMENT), e.addFunction(Ci.FUNCTION_ID_SET_FEATURE_ID_VARYINGS, Ci.FUNCTION_SIGNATURE_SET_FEATURE_ID_VARYINGS, Te.VERTEX) } function _Ne(e, t, n) { let i = t.featureIds, o = t.attributes[0].count; for (let r = 0; r < i.length; r++) { let s = i[r], a = s.positionalLabel; s instanceof Dt.FeatureIdAttribute ? yNe(e, s, a) : Lee(e, s, a, o, 1, n); let c = s.label; l(c) && Fee(e, a, c, Te.BOTH) } } function gNe(e, t, n) { let i = t.featureIds, r = tn.getAttributeBySemantic(t, xt.POSITION).count; for (let s = 0; s < i.length; s++) { let a = i[s], c = a.positionalLabel, u = Te.BOTH; a instanceof Dt.FeatureIdAttribute ? ANe(e, a, c) : a instanceof Dt.FeatureIdImplicitRange ? Lee(e, a, c, r, void 0, n) : (CNe(e, a, c, s, n), u = Te.FRAGMENT); let f = a.label; l(f) && Fee(e, c, f, u) } } function yNe(e, t, n) { let i = e.shaderBuilder; i.addStructField(Ci.STRUCT_ID_FEATURE_IDS_VS, "int", n), i.addStructField(Ci.STRUCT_ID_FEATURE_IDS_FS, "int", n); let o = t.setIndex, r = n.replace(/_\d+$/, "_"), s = `a_${r}${o}`, a = `v_${r}${o}`, c = `featureIds.${n} = int(czm_round(${s}));`, u = `featureIds.${n} = int(czm_round(${a}));`; i.addFunctionLines(Ci.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS, [c]), i.addFunctionLines(Ci.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS, [u]), i.addVarying("float", a), i.addFunctionLines(Ci.FUNCTION_ID_SET_FEATURE_ID_VARYINGS, [`${a} = ${s};`]) } function ANe(e, t, n) { let i = e.shaderBuilder; i.addStructField(Ci.STRUCT_ID_FEATURE_IDS_VS, "int", n), i.addStructField(Ci.STRUCT_ID_FEATURE_IDS_FS, "int", n); let o = t.setIndex, r = n.replace(/_\d+$/, "_"), s = [`featureIds.${n} = int(czm_round(attributes.${r}${o}));`]; i.addFunctionLines(Ci.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS, s), i.addFunctionLines(Ci.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS, s) } function Lee(e, t, n, i, o, r) { xNe(e, t, i, o, r); let s = e.shaderBuilder, a = `a_implicit_${n}`; s.addAttribute("float", a); let c = `v_implicit_${n}`; s.addVarying("float", c), s.addStructField(Ci.STRUCT_ID_FEATURE_IDS_VS, "int", n), s.addStructField(Ci.STRUCT_ID_FEATURE_IDS_FS, "int", n), s.addFunctionLines(Ci.FUNCTION_ID_SET_FEATURE_ID_VARYINGS, [`${c} = ${a};`]), s.addFunctionLines(Ci.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS, [`featureIds.${n} = int(czm_round(${a}));`]), s.addFunctionLines(Ci.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS, [`featureIds.${n} = int(czm_round(${c}));`]) } function CNe(e, t, n, i, o) { let r = `u_featureIdTexture_${i}`, s = e.uniformMap, a = t.textureReader; s[r] = function () { return y(a.texture, o.context.defaultTexture) }; let c = a.channels, u = e.shaderBuilder; u.addStructField(Ci.STRUCT_ID_FEATURE_IDS_FS, "int", n), u.addUniform("sampler2D", r, Te.FRAGMENT); let f = `v_texCoord_${a.texCoord}`, d = `texture2D(${r}, ${f}).${c}`, p = `featureIds.${n} = czm_unpackUint(${d});`; u.addFunctionLines(Ci.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS, [p]) } function Fee(e, t, n, i) { let o = e.shaderBuilder, r = Te.includesVertexShader(i); r && o.addStructField(Ci.STRUCT_ID_FEATURE_IDS_VS, "int", n), o.addStructField(Ci.STRUCT_ID_FEATURE_IDS_FS, "int", n); let s = [`featureIds.${n} = featureIds.${t};`]; r && o.addFunctionLines(Ci.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS, s), o.addFunctionLines(Ci.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS, s) } function xNe(e, t, n, i, o) { let r = e.model, s, a; if (l(t.repeat)) { let u = TNe(t, n); s = ct.createVertexBuffer({ context: o.context, typedArray: u, usage: Re.STATIC_DRAW }), s.vertexArrayDestroyable = !1, r._pipelineResources.push(s); let f = !1; r.statistics.addBuffer(s, f) } else a = [t.offset]; let c = { index: e.attributeIndex++, instanceDivisor: i, value: a, vertexBuffer: s, normalize: !1, componentsPerAttribute: 1, componentDatatype: Y.FLOAT, strideInBytes: Y.getSizeInBytes(Y.FLOAT), offsetInBytes: 0 }; e.attributes.push(c) } function TNe(e, t) { let n = e.offset, i = e.repeat, o = new Float32Array(t); for (let r = 0; r < t; r++)o[r] = n + Math.floor(r / i); return o } var Y0 = Ci; var IM = `void metadataStage(
out Metadata metadata,
out MetadataClass metadataClass,
out MetadataStatistics metadataStatistics,
ProcessedAttributes attributes
)
{
initializeMetadata(metadata, metadataClass, metadataStatistics, attributes);
}
`; var OM = `void metadataStage(
out Metadata metadata,
out MetadataClass metadataClass,
out MetadataStatistics metadataStatistics,
ProcessedAttributes attributes
)
{
initializeMetadata(metadata, metadataClass, metadataStatistics, attributes);
setMetadataVaryings();
}
`; var li = { name: "MetadataPipelineStage", STRUCT_ID_METADATA_VS: "MetadataVS", STRUCT_ID_METADATA_FS: "MetadataFS", STRUCT_NAME_METADATA: "Metadata", STRUCT_ID_METADATA_CLASS_VS: "MetadataClassVS", STRUCT_ID_METADATA_CLASS_FS: "MetadataClassFS", STRUCT_NAME_METADATA_CLASS: "MetadataClass", STRUCT_ID_METADATA_STATISTICS_VS: "MetadataStatisticsVS", STRUCT_ID_METADATA_STATISTICS_FS: "MetadataStatisticsFS", STRUCT_NAME_METADATA_STATISTICS: "MetadataStatistics", FUNCTION_ID_INITIALIZE_METADATA_VS: "initializeMetadataVS", FUNCTION_ID_INITIALIZE_METADATA_FS: "initializeMetadataFS", FUNCTION_SIGNATURE_INITIALIZE_METADATA: "void initializeMetadata(out Metadata metadata, out MetadataClass metadataClass, out MetadataStatistics metadataStatistics, ProcessedAttributes attributes)", FUNCTION_ID_SET_METADATA_VARYINGS: "setMetadataVaryings", FUNCTION_SIGNATURE_SET_METADATA_VARYINGS: "void setMetadataVaryings()", METADATA_CLASS_FIELDS: [{ specName: "noData", shaderName: "noData" }, { specName: "default", shaderName: "defaultValue" }, { specName: "min", shaderName: "minValue" }, { specName: "max", shaderName: "maxValue" }], METADATA_STATISTICS_FIELDS: [{ specName: "min", shaderName: "minValue" }, { specName: "max", shaderName: "maxValue" }, { specName: "mean", shaderName: "mean", type: "float" }, { specName: "median", shaderName: "median" }, { specName: "standardDeviation", shaderName: "standardDeviation", type: "float" }, { specName: "variance", shaderName: "variance", type: "float" }, { specName: "sum", shaderName: "sum" }] }; li.process = function (e, t, n) { let { shaderBuilder: i, model: o } = e, { structuralMetadata: r = {}, content: s } = o, a = s?.tileset.metadataExtension?.statistics, c = ENe(r.propertyAttributes, t, a), u = SNe(r.propertyTextures, a), f = c.concat(u); DNe(i, f), INe(i), i.addVertexLines(OM), i.addFragmentLines(IM); for (let d = 0; d < c.length; d++) { let p = c[d]; ONe(e, p) } for (let d = 0; d < u.length; d++) { let p = u[d]; RNe(e, p) } }; function ENe(e, t, n) { return l(e) ? e.flatMap(i => bNe(i, t, n)) : [] } function bNe(e, t, n) { let { getAttributeByName: i, getAttributeInfo: o, sanitizeGlslIdentifier: r } = tn, s = e.class.id, a = n?.classes[s], c = Object.entries(e.properties), u = new Array(c.length); for (let f = 0; f < c.length; f++) { let [d, p] = c[f], g = i(t, p.attribute), { glslType: m, variableName: A } = o(g); u[f] = { metadataVariable: r(d), property: p, type: p.classProperty.type, glslType: m, variableName: A, propertyStatistics: a?.properties[d], shaderDestination: Te.BOTH } } return u } function SNe(e, t) { return l(e) ? e.flatMap(n => wNe(n, t)) : [] } function wNe(e, t) { let { sanitizeGlslIdentifier: n } = tn, i = e.class.id, o = t?.classes[i], r = Object.entries(e.properties).filter(([a, c]) => c.isGpuCompatible()), s = new Array(r.length); for (let a = 0; a < r.length; a++) { let [c, u] = r[a]; s[a] = { metadataVariable: n(c), property: u, type: u.classProperty.type, glslType: u.getGlslType(), propertyStatistics: o?.properties[c], shaderDestination: Te.FRAGMENT } } return s } function DNe(e, t) { let n = new Set, i = new Set; for (let a = 0; a < t.length; a++) { let { type: c, glslType: u, propertyStatistics: f } = t[a]; n.add(u), !!l(f) && c !== Dn.ENUM && i.add(u) } let o = li.METADATA_CLASS_FIELDS; for (let a of n) { let c = `${a}MetadataClass`; s(c, a, o) } let r = li.METADATA_STATISTICS_FIELDS; for (let a of i) { let c = `${a}MetadataStatistics`; s(c, a, r) } function s(a, c, u) { e.addStruct(a, a, Te.BOTH); for (let f = 0; f < u.length; f++) { let { shaderName: d } = u[f], p = u[f].type === "float" ? PNe(c) : c; e.addStructField(a, p, d) } } } var vNe = { int: "float", ivec2: "vec2", ivec3: "vec3", ivec4: "vec4" }; function PNe(e) { let t = vNe[e]; return l(t) ? t : e } function INe(e) { e.addStruct(li.STRUCT_ID_METADATA_VS, li.STRUCT_NAME_METADATA, Te.VERTEX), e.addStruct(li.STRUCT_ID_METADATA_FS, li.STRUCT_NAME_METADATA, Te.FRAGMENT), e.addStruct(li.STRUCT_ID_METADATA_CLASS_VS, li.STRUCT_NAME_METADATA_CLASS, Te.VERTEX), e.addStruct(li.STRUCT_ID_METADATA_CLASS_FS, li.STRUCT_NAME_METADATA_CLASS, Te.FRAGMENT), e.addStruct(li.STRUCT_ID_METADATA_STATISTICS_VS, li.STRUCT_NAME_METADATA_STATISTICS, Te.VERTEX), e.addStruct(li.STRUCT_ID_METADATA_STATISTICS_FS, li.STRUCT_NAME_METADATA_STATISTICS, Te.FRAGMENT), e.addFunction(li.FUNCTION_ID_INITIALIZE_METADATA_VS, li.FUNCTION_SIGNATURE_INITIALIZE_METADATA, Te.VERTEX), e.addFunction(li.FUNCTION_ID_INITIALIZE_METADATA_FS, li.FUNCTION_SIGNATURE_INITIALIZE_METADATA, Te.FRAGMENT), e.addFunction(li.FUNCTION_ID_SET_METADATA_VARYINGS, li.FUNCTION_SIGNATURE_SET_METADATA_VARYINGS, Te.VERTEX) } function ONe(e, t) { BNe(e, t), Nee(e.shaderBuilder, t), Vee(e.shaderBuilder, t) } function BNe(e, t) { let { shaderBuilder: n } = e, { metadataVariable: i, property: o, glslType: r } = t, s = Uee({ valueExpression: `attributes.${t.variableName}`, renderResources: e, glslType: r, metadataVariable: i, shaderDestination: Te.BOTH, property: o }); n.addStructField(li.STRUCT_ID_METADATA_VS, r, i), n.addStructField(li.STRUCT_ID_METADATA_FS, r, i); let a = `metadata.${i} = ${s};`; n.addFunctionLines(li.FUNCTION_ID_INITIALIZE_METADATA_VS, [a]), n.addFunctionLines(li.FUNCTION_ID_INITIALIZE_METADATA_FS, [a]) } function RNe(e, t) { MNe(e, t), Nee(e.shaderBuilder, t), Vee(e.shaderBuilder, t) } function MNe(e, t) { let { shaderBuilder: n, uniformMap: i } = e, { metadataVariable: o, glslType: r, property: s } = t, { texCoord: a, channels: c, index: u, texture: f } = s.textureReader, d = `u_propertyTexture_${u}`; i.hasOwnProperty(d) || (n.addUniform("sampler2D", d, Te.FRAGMENT), i[d] = () => f), n.addStructField(li.STRUCT_ID_METADATA_FS, r, o); let p = `attributes.texCoord_${a}`, g = `texture2D(${d}, ${p}).${c}`, m = s.unpackInShader(g), A = Uee({ valueExpression: m, renderResources: e, glslType: r, metadataVariable: o, shaderDestination: Te.FRAGMENT, property: s }), C = `metadata.${o} = ${A};`; n.addFunctionLines(li.FUNCTION_ID_INITIALIZE_METADATA_FS, [C]) } function Nee(e, t) { let { classProperty: n } = t.property, { metadataVariable: i, glslType: o, shaderDestination: r } = t, s = kee(li.METADATA_CLASS_FIELDS, n, `metadataClass.${i}`, o), a = `${o}MetadataClass`; e.addStructField(li.STRUCT_ID_METADATA_CLASS_FS, a, i), e.addFunctionLines(li.FUNCTION_ID_INITIALIZE_METADATA_FS, s), Te.includesVertexShader(r) && (e.addStructField(li.STRUCT_ID_METADATA_CLASS_VS, a, i), e.addFunctionLines(li.FUNCTION_ID_INITIALIZE_METADATA_VS, s)) } function Vee(e, t) { let { propertyStatistics: n } = t; if (!l(n)) return; let { metadataVariable: i, type: o, glslType: r } = t; if (o === Dn.ENUM) return; let s = li.METADATA_STATISTICS_FIELDS, a = `metadataStatistics.${i}`, c = kee(s, n, a, r), u = `${r}MetadataStatistics`; e.addStructField(li.STRUCT_ID_METADATA_STATISTICS_FS, u, i), e.addFunctionLines(li.FUNCTION_ID_INITIALIZE_METADATA_FS, c), Te.includesVertexShader(t.shaderDestination) && (e.addStructField(li.STRUCT_ID_METADATA_STATISTICS_VS, u, i), e.addFunctionLines(li.FUNCTION_ID_INITIALIZE_METADATA_VS, c)) } function kee(e, t, n, i) { return l(t) ? e.map(o).filter(l) : []; function o(r) { let s = t[r.specName]; if (l(s)) return `${n}.${r.shaderName} = ${i}(${s});` } } function Uee(e) { let { valueExpression: t, property: n } = e; if (!n.hasValueTransform) return t; let i = e.metadataVariable, o = `u_${i}_offset`, r = `u_${i}_scale`, { shaderBuilder: s, uniformMap: a } = e.renderResources, { glslType: c, shaderDestination: u } = e; s.addUniform(c, o, u), s.addUniform(c, r, u); let { offset: f, scale: d } = n; return a[o] = () => f, a[r] = () => d, `czm_valueTransform(${o}, ${r}, ${t})` } var bf = li; var LNe = { INHERIT: 0, OPAQUE: 1, TRANSLUCENT: 2 }, X0 = Object.freeze(LNe); var Es = { name: "CustomShaderPipelineStage", STRUCT_ID_ATTRIBUTES_VS: "AttributesVS", STRUCT_ID_ATTRIBUTES_FS: "AttributesFS", STRUCT_NAME_ATTRIBUTES: "Attributes", STRUCT_ID_VERTEX_INPUT: "VertexInput", STRUCT_NAME_VERTEX_INPUT: "VertexInput", STRUCT_ID_FRAGMENT_INPUT: "FragmentInput", STRUCT_NAME_FRAGMENT_INPUT: "FragmentInput", FUNCTION_ID_INITIALIZE_INPUT_STRUCT_VS: "initializeInputStructVS", FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_VS: "void initializeInputStruct(out VertexInput vsInput, ProcessedAttributes attributes)", FUNCTION_ID_INITIALIZE_INPUT_STRUCT_FS: "initializeInputStructFS", FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_FS: "void initializeInputStruct(out FragmentInput fsInput, ProcessedAttributes attributes)", _oneTimeWarning: Pt }; Es.process = function (e, t, n) { let i = e.shaderBuilder, o = e.model.customShader; l(o.lightingModel) && (e.lightingOptions.lightingModel = o.lightingModel); let r = e.alphaOptions; o.translucencyMode === X0.TRANSLUCENT ? r.pass = xe.TRANSLUCENT : o.translucencyMode === X0.OPAQUE && (r.pass = void 0); let s = GNe(o, t); if (!s.customShaderEnabled) return; if (YNe(i, o, s), s.shouldComputePositionWC && i.addDefine("COMPUTE_POSITION_WC_CUSTOM_SHADER", void 0, Te.BOTH), l(o.vertexShaderText) && i.addDefine("HAS_CUSTOM_VERTEX_SHADER", void 0, Te.VERTEX), l(o.fragmentShaderText)) { i.addDefine("HAS_CUSTOM_FRAGMENT_SHADER", void 0, Te.FRAGMENT); let u = C_.getDefineName(o.mode); i.addDefine(u, void 0, Te.FRAGMENT) } let a = o.uniforms; for (let u in a) if (a.hasOwnProperty(u)) { let f = a[u]; i.addUniform(f.type, u) } let c = o.varyings; for (let u in c) if (c.hasOwnProperty(u)) { let f = c[u]; i.addVarying(f, u) } e.uniformMap = yt(e.uniformMap, o.uniformMap) }; function FNe(e) { let t = {}; for (let n = 0; n < e.length; n++) { let i = e[n], o = tn.getAttributeInfo(i); t[o.variableName] = o } return t } var NNe = { position: "vec3", normal: "vec3", tangent: "vec3", bitangent: "vec3", texCoord: "vec2", color: "vec4", joints: "ivec4", weights: "vec4" }, VNe = { position: "vec3(0.0)", normal: "vec3(0.0, 0.0, 1.0)", tangent: "vec3(1.0, 0.0, 0.0)", bitangent: "vec3(0.0, 1.0, 0.0)", texCoord: "vec2(0.0)", color: "vec4(1.0)", joints: "ivec4(0)", weights: "vec4(0.0)" }; function zee(e) { let t = e.replace(/_[0-9]+$/, ""); t = t.replace(/(MC|EC)$/, ""); let n = NNe[t], i = VNe[t]; if (!!l(n)) return { attributeField: [n, e], value: i } } function kNe(e, t, n) { let i = Hee(t, e.usedVariablesVertex.attributeSet, !1), o = i.addToShader, r = i.missingAttributes, s, a, c = [], u = []; for (s in o) if (o.hasOwnProperty(s)) { let d = [o[s].glslType, s]; c.push(d), a = `vsInput.attributes.${s} = attributes.${s};`, u.push(a) } for (let f = 0; f < r.length; f++) { s = r[f]; let d = zee(s); if (!l(d)) { Es._oneTimeWarning("CustomShaderPipelineStage.incompatiblePrimitiveVS", `Primitive is missing attribute ${s}, disabling custom vertex shader`); return } c.push(d.attributeField), a = `vsInput.attributes.${s} = ${d.value};`, u.push(a) } n.enabled = !0, n.attributeFields = c, n.initializationLines = u } function UNe(e) { let t = [], n = [], i = e.usedVariablesFragment.attributeSet; return i.hasOwnProperty("positionWC") && (t.push(["vec3", "positionWC"]), n.push("fsInput.attributes.positionWC = attributes.positionWC;")), i.hasOwnProperty("positionEC") && (t.push(["vec3", "positionEC"]), n.push("fsInput.attributes.positionEC = attributes.positionEC;")), { attributeFields: t, initializationLines: n } } function zNe(e, t, n) { let i = Hee(t, e.usedVariablesFragment.attributeSet, !0), o = i.addToShader, r = i.missingAttributes, s, a, c = [], u = []; for (s in o) if (o.hasOwnProperty(s)) { let p = [o[s].glslType, s]; c.push(p), a = `fsInput.attributes.${s} = attributes.${s};`, u.push(a) } for (let d = 0; d < r.length; d++) { s = r[d]; let p = zee(s); if (!l(p)) { Es._oneTimeWarning("CustomShaderPipelineStage.incompatiblePrimitiveFS", `Primitive is missing attribute ${s}, disabling custom fragment shader.`); return } c.push(p.attributeField), a = `fsInput.attributes.${s} = ${p.value};`, u.push(a) } let f = UNe(e); n.enabled = !0, n.attributeFields = c.concat(f.attributeFields), n.initializationLines = f.initializationLines.concat(u) } var HNe = { positionWC: !0, positionEC: !0 }; function Hee(e, t, n) { let i, o, r = {}; for (o in e) if (e.hasOwnProperty(o)) { let a = e[o]; i = o, n && o === "normalMC" ? i = "normalEC" : n && o === "tangentMC" && (i = "tangentEC"), t.hasOwnProperty(i) && (r[i] = a) } let s = []; for (o in t) if (t.hasOwnProperty(o)) { if (HNe.hasOwnProperty(o)) continue; i = o, n && o === "normalEC" ? i = "normalMC" : n && o === "tangentEC" && (i = "tangentMC"), e.hasOwnProperty(i) || s.push(o) } return { addToShader: r, missingAttributes: s } } function GNe(e, t) { let n = { enabled: !1 }, i = { enabled: !1 }, o = FNe(t.attributes); l(e.vertexShaderText) && kNe(e, o, n), l(e.fragmentShaderText) && zNe(e, o, i); let s = e.usedVariablesFragment.attributeSet.hasOwnProperty("positionWC") && i.enabled; return { vertexLines: n, fragmentLines: i, vertexLinesEnabled: n.enabled, fragmentLinesEnabled: i.enabled, customShaderEnabled: n.enabled || i.enabled, shouldComputePositionWC: s } } function WNe(e, t) { let n, i = Es.STRUCT_ID_ATTRIBUTES_VS; e.addStruct(i, Es.STRUCT_NAME_ATTRIBUTES, Te.VERTEX); let o = t.attributeFields; for (n = 0; n < o.length; n++) { let a = o[n], c = a[0], u = a[1]; e.addStructField(i, c, u) } i = Es.STRUCT_ID_VERTEX_INPUT, e.addStruct(i, Es.STRUCT_NAME_VERTEX_INPUT, Te.VERTEX), e.addStructField(i, Es.STRUCT_NAME_ATTRIBUTES, "attributes"), e.addStructField(i, Y0.STRUCT_NAME_FEATURE_IDS, "featureIds"), e.addStructField(i, bf.STRUCT_NAME_METADATA, "metadata"), e.addStructField(i, bf.STRUCT_NAME_METADATA_CLASS, "metadataClass"), e.addStructField(i, bf.STRUCT_NAME_METADATA_STATISTICS, "metadataStatistics"); let r = Es.FUNCTION_ID_INITIALIZE_INPUT_STRUCT_VS; e.addFunction(r, Es.FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_VS, Te.VERTEX); let s = t.initializationLines; e.addFunctionLines(r, s) } function jNe(e, t) { let n, i = Es.STRUCT_ID_ATTRIBUTES_FS; e.addStruct(i, Es.STRUCT_NAME_ATTRIBUTES, Te.FRAGMENT); let o, r, s, a = t.attributeFields; for (n = 0; n < a.length; n++)o = a[n], r = o[0], s = o[1], e.addStructField(i, r, s); i = Es.STRUCT_ID_FRAGMENT_INPUT, e.addStruct(i, Es.STRUCT_NAME_FRAGMENT_INPUT, Te.FRAGMENT), e.addStructField(i, Es.STRUCT_NAME_ATTRIBUTES, "attributes"), e.addStructField(i, Y0.STRUCT_NAME_FEATURE_IDS, "featureIds"), e.addStructField(i, bf.STRUCT_NAME_METADATA, "metadata"), e.addStructField(i, bf.STRUCT_NAME_METADATA_CLASS, "metadataClass"), e.addStructField(i, bf.STRUCT_NAME_METADATA_STATISTICS, "metadataStatistics"); let c = Es.FUNCTION_ID_INITIALIZE_INPUT_STRUCT_FS; e.addFunction(c, Es.FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_FS, Te.FRAGMENT); let u = t.initializationLines; e.addFunctionLines(c, u) } var qNe = []; function YNe(e, t, n) { let i = n.vertexLines, o = qNe; i.enabled && (WNe(e, i), o.length = 0, o.push("#line 0", t.vertexShaderText, wM), e.addVertexLines(o)); let r = n.fragmentLines; r.enabled && (jNe(e, r), o.length = 0, o.push("#line 0", t.fragmentShaderText, DM), e.addFragmentLines(o)) } var BM = Es; var BS = { name: "DequantizationPipelineStage", FUNCTION_ID_DEQUANTIZATION_STAGE_VS: "dequantizationStage", FUNCTION_SIGNATURE_DEQUANTIZATION_STAGE_VS: "void dequantizationStage(inout ProcessedAttributes attributes)" }; BS.process = function (e, t, n) { let i = e.shaderBuilder, o = e.model, r = l(o.classificationType); i.addDefine("USE_DEQUANTIZATION", void 0, Te.VERTEX), i.addFunction(BS.FUNCTION_ID_DEQUANTIZATION_STAGE_VS, BS.FUNCTION_SIGNATURE_DEQUANTIZATION_STAGE_VS, Te.VERTEX); let s = t.attributes; for (let a = 0; a < s.length; a++) { let c = s[a], u = c.quantization; if (!l(u)) continue; let f = c.semantic === xt.POSITION, d = c.semantic === xt.TEXCOORD; if (r && !f && !d) continue; let p = tn.getAttributeInfo(c); KNe(i, p), XNe(e, p) } }; function XNe(e, t) { let n = e.shaderBuilder, i = e.uniformMap, o = t.variableName, r = t.attribute.quantization; if (r.octEncoded) { let s = `model_normalizationRange_${o}`; n.addUniform("float", s, Te.VERTEX), i[s] = function () { return r.normalizationRange } } else { let s = `model_quantizedVolumeOffset_${o}`, a = `model_quantizedVolumeStepSize_${o}`, c = t.glslType; n.addUniform(c, s, Te.VERTEX), n.addUniform(c, a, Te.VERTEX); let u = r.quantizedVolumeOffset, f = r.quantizedVolumeStepSize; /^color_\d+$/.test(o) && (u = Gee(u, 0), f = Gee(f, 1)), i[s] = function () { return u }, i[a] = function () { return f } } } function Gee(e, t) { return e instanceof se ? e : new se(e.x, e.y, e.z, t) } function KNe(e, t) { let n = t.variableName, i = t.attribute.quantization, o; i.octEncoded ? o = JNe(n, i) : o = ZNe(n), e.addFunctionLines(BS.FUNCTION_ID_DEQUANTIZATION_STAGE_VS, [o]) } function JNe(e, t) { let n = `attributes.${e}`, i = `a_quantized_${e}`, o = `model_normalizationRange_${e}`, r = t.octEncodedZXY ? ".zxy" : ".xyz"; return `${n} = czm_octDecode(${i}, ${o})${r};` } function ZNe(e) { let t = `attributes.${e}`, n = `a_quantized_${e}`, i = `model_quantizedVolumeOffset_${e}`, o = `model_quantizedVolumeStepSize_${e}`; return `${t} = ${i} + ${n} * ${o};` } var RM = BS; var MM = `void geometryStage(out ProcessedAttributes attributes)
{
attributes.positionMC = v_positionMC;
attributes.positionEC = v_positionEC;
#ifdef COMPUTE_POSITION_WC_CUSTOM_SHADER
attributes.positionWC = v_positionWC;
#endif
#ifdef HAS_NORMALS
attributes.normalEC = normalize(v_normalEC);
#endif
#ifdef HAS_TANGENTS
attributes.tangentEC = normalize(v_tangentEC);
#endif
#ifdef HAS_BITANGENTS
attributes.bitangentEC = normalize(v_bitangentEC);
#endif
setDynamicVaryings(attributes);
}
`; var LM = `vec4 geometryStage(inout ProcessedAttributes attributes, mat4 modelView, mat3 normal)
{
vec4 computedPosition;
vec3 positionMC = attributes.positionMC;
v_positionMC = positionMC;
v_positionEC = (modelView * vec4(positionMC, 1.0)).xyz;
#if defined(USE_2D_POSITIONS) || defined(USE_2D_INSTANCING)
vec3 position2D = attributes.position2D;
vec3 positionEC = (u_modelView2D * vec4(position2D, 1.0)).xyz;
computedPosition = czm_projection * vec4(positionEC, 1.0);
#else
computedPosition = czm_projection * vec4(v_positionEC, 1.0);
#endif
#if defined(COMPUTE_POSITION_WC_CUSTOM_SHADER) || defined(COMPUTE_POSITION_WC_STYLE)
v_positionWC = (czm_model * vec4(positionMC, 1.0)).xyz;
#endif
#ifdef HAS_NORMALS
v_normalEC = normalize(normal * attributes.normalMC);
#endif
#ifdef HAS_TANGENTS
v_tangentEC = normalize(normal * attributes.tangentMC);
#endif
#ifdef HAS_BITANGENTS
v_bitangentEC = normalize(normal * attributes.bitangentMC);
#endif
setDynamicVaryings(attributes);
return computedPosition;
}
`; var RS = `vec2 computeSt(float featureId)
{
float stepX = model_textureStep.x;
float centerX = model_textureStep.y;
#ifdef MULTILINE_BATCH_TEXTURE
float stepY = model_textureStep.z;
float centerY = model_textureStep.w;
float xId = mod(featureId, model_textureDimensions.x);
float yId = floor(featureId / model_textureDimensions.x);
return vec2(centerX + (xId * stepX), centerY + (yId * stepY));
#else
return vec2(centerX + (featureId * stepX), 0.5);
#endif
}
void selectedFeatureIdStage(out SelectedFeature feature, FeatureIds featureIds)
{
int featureId = featureIds.SELECTED_FEATURE_ID;
if (featureId < model_featuresLength)
{
vec2 featureSt = computeSt(float(featureId));
feature.id = featureId;
feature.st = featureSt;
feature.color = texture2D(model_batchTexture, featureSt);
}
else
{
feature.id = model_featuresLength + 1;
feature.st = vec2(0.0);
feature.color = vec4(1.0);
}
#ifdef HAS_NULL_FEATURE_ID
if (featureId == model_nullFeatureId) {
feature.id = featureId;
feature.st = vec2(0.0);
feature.color = vec4(1.0);
}
#endif
}
`; var MS = { name: "SelectedFeatureIdPipelineStage", STRUCT_ID_SELECTED_FEATURE: "SelectedFeature", STRUCT_NAME_SELECTED_FEATURE: "SelectedFeature", FUNCTION_ID_FEATURE_VARYINGS_VS: "updateFeatureStructVS", FUNCTION_ID_FEATURE_VARYINGS_FS: "updateFeatureStructFS", FUNCTION_SIGNATURE_UPDATE_FEATURE: "void updateFeatureStruct(inout SelectedFeature feature)" }; MS.process = function (e, t, n) { let i = e.shaderBuilder; e.hasPropertyTable = !0; let o = e.model, r = e.runtimeNode.node, s = QNe(o, r, t), a = s.shaderDestination; i.addDefine("HAS_SELECTED_FEATURE_ID", void 0, a), i.addDefine("SELECTED_FEATURE_ID", s.variableName, a), i.addDefine(s.featureIdDefine, void 0, a), $Ne(i); let c = s.featureIds.nullFeatureId, u = e.uniformMap; l(c) && (i.addDefine("HAS_NULL_FEATURE_ID", void 0, a), i.addUniform("int", "model_nullFeatureId", a), u.model_nullFeatureId = function () { return c }), s.shaderDestination === Te.BOTH && i.addVertexLines(RS), i.addFragmentLines(RS) }; function Wee(e) { return e instanceof Dt.FeatureIdTexture ? "HAS_SELECTED_FEATURE_ID_TEXTURE" : "HAS_SELECTED_FEATURE_ID_ATTRIBUTE" } function jee(e) { return e instanceof Dt.FeatureIdTexture ? Te.FRAGMENT : Te.BOTH } function QNe(e, t, n) { let i, o; return l(t.instances) && (o = tn.getFeatureIdsByLabel(t.instances.featureIds, e.instanceFeatureIdLabel), l(o)) ? (i = y(o.label, o.positionalLabel), { featureIds: o, variableName: i, shaderDestination: jee(o), featureIdDefine: Wee(o) }) : (o = tn.getFeatureIdsByLabel(n.featureIds, e.featureIdLabel), i = y(o.label, o.positionalLabel), { featureIds: o, variableName: i, shaderDestination: jee(o), featureIdDefine: Wee(o) }) } function $Ne(e) { e.addStructField(MS.STRUCT_ID_SELECTED_FEATURE, "int", "id"), e.addStructField(MS.STRUCT_ID_SELECTED_FEATURE, "vec2", "st"), e.addStructField(MS.STRUCT_ID_SELECTED_FEATURE, "vec4", "color") } var K0 = MS; var fs = { name: "GeometryPipelineStage", STRUCT_ID_PROCESSED_ATTRIBUTES_VS: "ProcessedAttributesVS", STRUCT_ID_PROCESSED_ATTRIBUTES_FS: "ProcessedAttributesFS", STRUCT_NAME_PROCESSED_ATTRIBUTES: "ProcessedAttributes", FUNCTION_ID_INITIALIZE_ATTRIBUTES: "initializeAttributes", FUNCTION_SIGNATURE_INITIALIZE_ATTRIBUTES: "void initializeAttributes(out ProcessedAttributes attributes)", FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS: "setDynamicVaryingsVS", FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS: "setDynamicVaryingsFS", FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS: "void setDynamicVaryings(inout ProcessedAttributes attributes)" }; fs.process = function (e, t, n) { let i = e.shaderBuilder, o = e.model; i.addStruct(fs.STRUCT_ID_PROCESSED_ATTRIBUTES_VS, "ProcessedAttributes", Te.VERTEX), i.addStruct(fs.STRUCT_ID_PROCESSED_ATTRIBUTES_FS, "ProcessedAttributes", Te.FRAGMENT), i.addStruct(K0.STRUCT_ID_SELECTED_FEATURE, K0.STRUCT_NAME_SELECTED_FEATURE, Te.BOTH), i.addFunction(fs.FUNCTION_ID_INITIALIZE_ATTRIBUTES, fs.FUNCTION_SIGNATURE_INITIALIZE_ATTRIBUTES, Te.VERTEX), i.addVarying("vec3", "v_positionWC"), i.addVarying("vec3", "v_positionEC"), i.addStructField(fs.STRUCT_ID_PROCESSED_ATTRIBUTES_FS, "vec3", "positionWC"), i.addStructField(fs.STRUCT_ID_PROCESSED_ATTRIBUTES_FS, "vec3", "positionEC"), i.addFunction(fs.FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS, fs.FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS, Te.VERTEX), i.addFunction(fs.FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS, fs.FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS, Te.FRAGMENT), o.type === ar.TILE_PNTS && i.addDefine("HAS_SRGB_COLOR", void 0, Te.FRAGMENT); let s = n.mode !== ee.SCENE3D && !n.scene3DOnly && o._projectTo2D, a = l(e.runtimeNode.node.instances), c = s && !a, u = t.attributes.length; for (let f = 0; f < u; f++) { let d = t.attributes[f], p = en.getAttributeLocationCount(d.type), g = d.semantic === xt.POSITION, m; p > 1 ? (m = e.attributeIndex, e.attributeIndex += p) : g && !c ? m = 0 : m = e.attributeIndex++, e2e(e, d, m, p, s, a) } l2e(i, t.attributes), t.primitiveType === Oe.POINTS && i.addDefine("PRIMITIVE_TYPE_POINTS"), i.addVertexLines(LM), i.addFragmentLines(MM) }; function e2e(e, t, n, i, o, r) { let s = e.shaderBuilder, a = tn.getAttributeInfo(t), c = o && !r; i > 1 ? i2e(e, t, n, i) : n2e(e, t, n, c), r2e(s, a, c), o2e(s, a), l(t.semantic) && t2e(s, t), s2e(s, a, o), a2e(s, a, c), c2e(s, a) } function t2e(e, t) { let n = t.semantic, i = t.setIndex; switch (n) { case xt.NORMAL: e.addDefine("HAS_NORMALS"); break; case xt.TANGENT: e.addDefine("HAS_TANGENTS"); break; case xt.FEATURE_ID: e.addDefine(`HAS${n}_${i}`); break; case xt.TEXCOORD: case xt.COLOR: e.addDefine(`HAS_${n}_${i}`) } } function n2e(e, t, n, i) { let o = t.quantization, r, s; l(o) ? (r = o.type, s = o.componentDatatype) : (r = t.type, s = t.componentDatatype); let a = t.semantic, c = t.setIndex; a === xt.FEATURE_ID && c >= e.featureIdVertexAttributeSetIndex && (e.featureIdVertexAttributeSetIndex = c + 1); let u = a === xt.POSITION, f = u ? 0 : n, d = en.getNumberOfComponents(r), p = { index: f, value: l(t.buffer) ? void 0 : t.constant, vertexBuffer: t.buffer, count: t.count, componentsPerAttribute: d, componentDatatype: s, offsetInBytes: t.byteOffset, strideInBytes: t.byteStride, normalize: t.normalized }; if (e.attributes.push(p), !u || !i) return; let g = e.runtimePrimitive.positionBuffer2D, m = { index: n, vertexBuffer: g, count: t.count, componentsPerAttribute: d, componentDatatype: Y.FLOAT, offsetInBytes: 0, strideInBytes: void 0, normalize: t.normalized }; e.attributes.push(m) } function i2e(e, t, n, i) { let o = t.quantization, r, s; l(o) ? (r = o.type, s = o.componentDatatype) : (r = t.type, s = t.componentDatatype); let a = t.normalized, u = en.getNumberOfComponents(r) / i, f = Y.getSizeInBytes(s), d = u * f, p = t.byteStride; for (let g = 0; g < i; g++) { let m = t.byteOffset + g * d, A = { index: n + g, vertexBuffer: t.buffer, componentsPerAttribute: u, componentDatatype: s, offsetInBytes: m, strideInBytes: p, normalize: a }; e.attributes.push(A) } } function o2e(e, t) { let n = t.variableName, i = `v_${n}`, o; n === "normalMC" ? (i = "v_normalEC", o = t.glslType) : n === "tangentMC" ? (o = "vec3", i = "v_tangentEC") : o = t.glslType, e.addVarying(o, i) } function r2e(e, t, n) { let i = t.attribute.semantic, o = t.variableName, r, s; t.isQuantized ? (r = `a_quantized_${o}`, s = t.quantizedGlslType) : (r = `a_${o}`, s = t.glslType); let a = i === xt.POSITION; a ? e.setPositionAttribute(s, r) : e.addAttribute(s, r), a && n && e.addAttribute("vec3", "a_position2D") } function s2e(e, t, n) { let i = fs.STRUCT_ID_PROCESSED_ATTRIBUTES_VS, o = fs.STRUCT_ID_PROCESSED_ATTRIBUTES_FS, r = t.variableName; r === "tangentMC" ? (e.addStructField(i, "vec3", "tangentMC"), e.addStructField(i, "float", "tangentSignMC"), e.addStructField(o, "vec3", "tangentEC")) : r === "normalMC" ? (e.addStructField(i, "vec3", "normalMC"), e.addStructField(o, "vec3", "normalEC")) : (e.addStructField(i, t.glslType, r), e.addStructField(o, t.glslType, r)), r === "positionMC" && n && e.addStructField(i, "vec3", "position2D") } function a2e(e, t, n) { let i = fs.FUNCTION_ID_INITIALIZE_ATTRIBUTES, o = t.variableName; if (o === "positionMC" && n) { let a = "attributes.position2D = a_position2D;"; e.addFunctionLines(i, [a]) } if (t.isQuantized) return; let s = []; o === "tangentMC" ? (s.push("attributes.tangentMC = a_tangentMC.xyz;"), s.push("attributes.tangentSignMC = a_tangentMC.w;")) : s.push(`attributes.${o} = a_${o};`), e.addFunctionLines(i, s) } function c2e(e, t) { let n = t.attribute.semantic, i = t.attribute.setIndex; if (l(n) && !l(i)) return; let o = fs.FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS, r = t.variableName, s = `v_${r} = attributes.${r};`; e.addFunctionLines(o, [s]), o = fs.FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS, s = `attributes.${r} = v_${r};`, e.addFunctionLines(o, [s]) } function l2e(e, t) { let n = !1, i = !1; for (let o = 0; o < t.length; o++) { let r = t[o]; r.semantic === xt.NORMAL ? n = !0 : r.semantic === xt.TANGENT && (i = !0) } !n || !i || (e.addDefine("HAS_BITANGENTS"), e.addVarying("vec3", "v_bitangentEC"), e.addStructField(fs.STRUCT_ID_PROCESSED_ATTRIBUTES_VS, "vec3", "bitangentMC"), e.addStructField(fs.STRUCT_ID_PROCESSED_ATTRIBUTES_FS, "vec3", "bitangentEC")) } var FM = fs; var NM = `#ifdef LIGHTING_PBR
vec3 computePbrLighting(czm_modelMaterial inputMaterial, ProcessedAttributes attributes)
{
czm_pbrParameters pbrParameters;
pbrParameters.diffuseColor = inputMaterial.diffuse;
pbrParameters.f0 = inputMaterial.specular;
pbrParameters.roughness = inputMaterial.roughness;
#ifdef USE_CUSTOM_LIGHT_COLOR
vec3 lightColorHdr = model_lightColorHdr;
#else
vec3 lightColorHdr = czm_lightColorHdr;
#endif
vec3 color = inputMaterial.diffuse;
#ifdef HAS_NORMALS
color = czm_pbrLighting(
attributes.positionEC,
inputMaterial.normalEC,
czm_lightDirectionEC,
lightColorHdr,
pbrParameters
);
#ifdef USE_IBL_LIGHTING
color += imageBasedLightingStage(
attributes.positionEC,
inputMaterial.normalEC,
czm_lightDirectionEC,
lightColorHdr,
pbrParameters
);
#endif
#endif
color *= inputMaterial.occlusion;
color += inputMaterial.emissive;
#ifndef HDR
color = czm_acesTonemapping(color);
#endif
return color;
}
#endif
void lightingStage(inout czm_modelMaterial material, ProcessedAttributes attributes)
{
vec3 color = vec3(0.0);
#ifdef LIGHTING_PBR
color = computePbrLighting(material, attributes);
#else // unlit
color = material.diffuse;
#endif
#ifdef HAS_POINT_CLOUD_COLOR_STYLE
color = czm_gammaCorrect(color);
#elif !defined(HDR)
color = czm_linearToSrgb(color);
#endif
material.diffuse = color;
}
`; var u2e = { UNLIT: 0, PBR: 1 }, Im = Object.freeze(u2e); var qee = { name: "LightingPipelineStage" }; qee.process = function (e, t) { let n = e.model, i = e.lightingOptions, o = e.shaderBuilder; if (l(n.lightColor)) { o.addDefine("USE_CUSTOM_LIGHT_COLOR", void 0, Te.FRAGMENT), o.addUniform("vec3", "model_lightColorHdr", Te.FRAGMENT); let s = e.uniformMap; s.model_lightColorHdr = function () { return n.lightColor } } i.lightingModel === Im.PBR ? o.addDefine("LIGHTING_PBR", void 0, Te.FRAGMENT) : o.addDefine("LIGHTING_UNLIT", void 0, Te.FRAGMENT), o.addFragmentLines(NM) }; var VM = qee; var kM = `bool isDefaultStyleColor(vec3 color)
{
return all(greaterThan(color, vec3(1.0 - czm_epsilon3)));
}
vec3 blend(vec3 sourceColor, vec3 styleColor, float styleColorBlend)
{
vec3 blendColor = mix(sourceColor, styleColor, styleColorBlend);
vec3 color = isDefaultStyleColor(styleColor.rgb) ? sourceColor : blendColor;
return color;
}
vec2 computeTextureTransform(vec2 texCoord, mat3 textureTransform)
{
return vec2(textureTransform * vec3(texCoord, 1.0));
}
#ifdef HAS_NORMALS
vec3 computeNormal(ProcessedAttributes attributes)
{
vec3 ng = attributes.normalEC;
vec3 normal = ng;
#if defined(HAS_NORMAL_TEXTURE) && !defined(HAS_WIREFRAME)
vec2 normalTexCoords = TEXCOORD_NORMAL;
#ifdef HAS_NORMAL_TEXTURE_TRANSFORM
normalTexCoords = computeTextureTransform(normalTexCoords, u_normalTextureTransform);
#endif
#ifdef HAS_BITANGENTS
vec3 t = attributes.tangentEC;
vec3 b = attributes.bitangentEC;
mat3 tbn = mat3(t, b, ng);
vec3 n = texture2D(u_normalTexture, normalTexCoords).rgb;
normal = normalize(tbn * (2.0 * n - 1.0));
#elif defined(GL_OES_standard_derivatives)
vec3 positionEC = attributes.positionEC;
vec3 pos_dx = dFdx(positionEC);
vec3 pos_dy = dFdy(positionEC);
vec3 tex_dx = dFdx(vec3(normalTexCoords,0.0));
vec3 tex_dy = dFdy(vec3(normalTexCoords,0.0));
vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);
t = normalize(t - ng * dot(ng, t));
vec3 b = normalize(cross(ng, t));
mat3 tbn = mat3(t, b, ng);
vec3 n = texture2D(u_normalTexture, normalTexCoords).rgb;
normal = normalize(tbn * (2.0 * n - 1.0));
#endif
#endif
#ifdef HAS_DOUBLE_SIDED_MATERIAL
if (czm_backFacing()) {
normal = -normal;
}
#endif
return normal;
}
#endif
void materialStage(inout czm_modelMaterial material, ProcessedAttributes attributes, SelectedFeature feature)
{
#ifdef HAS_NORMALS
material.normalEC = computeNormal(attributes);
#endif
vec4 baseColorWithAlpha = vec4(1.0);
#ifdef HAS_BASE_COLOR_TEXTURE
vec2 baseColorTexCoords = TEXCOORD_BASE_COLOR;
#ifdef HAS_BASE_COLOR_TEXTURE_TRANSFORM
baseColorTexCoords = computeTextureTransform(baseColorTexCoords, u_baseColorTextureTransform);
#endif
baseColorWithAlpha = czm_srgbToLinear(texture2D(u_baseColorTexture, baseColorTexCoords));
#ifdef HAS_BASE_COLOR_FACTOR
baseColorWithAlpha *= u_baseColorFactor;
#endif
#elif defined(HAS_BASE_COLOR_FACTOR)
baseColorWithAlpha = u_baseColorFactor;
#endif
#ifdef HAS_POINT_CLOUD_COLOR_STYLE
baseColorWithAlpha = v_pointCloudColor;
#elif defined(HAS_COLOR_0)
vec4 color = attributes.color_0;
#ifdef HAS_SRGB_COLOR
color = czm_srgbToLinear(color);
#endif
baseColorWithAlpha *= color;
#endif
material.diffuse = baseColorWithAlpha.rgb;
material.alpha = baseColorWithAlpha.a;
#ifdef USE_CPU_STYLING
material.diffuse = blend(material.diffuse, feature.color.rgb, model_colorBlend);
#endif
#ifdef HAS_OCCLUSION_TEXTURE
vec2 occlusionTexCoords = TEXCOORD_OCCLUSION;
#ifdef HAS_OCCLUSION_TEXTURE_TRANSFORM
occlusionTexCoords = computeTextureTransform(occlusionTexCoords, u_occlusionTextureTransform);
#endif
material.occlusion = texture2D(u_occlusionTexture, occlusionTexCoords).r;
#endif
#ifdef HAS_EMISSIVE_TEXTURE
vec2 emissiveTexCoords = TEXCOORD_EMISSIVE;
#ifdef HAS_EMISSIVE_TEXTURE_TRANSFORM
emissiveTexCoords = computeTextureTransform(emissiveTexCoords, u_emissiveTextureTransform);
#endif
vec3 emissive = czm_srgbToLinear(texture2D(u_emissiveTexture, emissiveTexCoords).rgb);
#ifdef HAS_EMISSIVE_FACTOR
emissive *= u_emissiveFactor;
#endif
material.emissive = emissive;
#elif defined(HAS_EMISSIVE_FACTOR)
material.emissive = u_emissiveFactor;
#endif
#if defined(LIGHTING_PBR) && defined(USE_SPECULAR_GLOSSINESS)
#ifdef HAS_SPECULAR_GLOSSINESS_TEXTURE
vec2 specularGlossinessTexCoords = TEXCOORD_SPECULAR_GLOSSINESS;
#ifdef HAS_SPECULAR_GLOSSINESS_TEXTURE_TRANSFORM
specularGlossinessTexCoords = computeTextureTransform(specularGlossinessTexCoords, u_specularGlossinessTextureTransform);
#endif
vec4 specularGlossiness = czm_srgbToLinear(texture2D(u_specularGlossinessTexture, specularGlossinessTexCoords));
vec3 specular = specularGlossiness.rgb;
float glossiness = specularGlossiness.a;
#ifdef HAS_SPECULAR_FACTOR
specular *= u_specularFactor;
#endif
#ifdef HAS_GLOSSINESS_FACTOR
glossiness *= u_glossinessFactor;
#endif
#else
#ifdef HAS_SPECULAR_FACTOR
vec3 specular = clamp(u_specularFactor, vec3(0.0), vec3(1.0));
#else
vec3 specular = vec3(1.0);
#endif
#ifdef HAS_GLOSSINESS_FACTOR
float glossiness = clamp(u_glossinessFactor, 0.0, 1.0);
#else
float glossiness = 1.0;
#endif
#endif
#ifdef HAS_DIFFUSE_TEXTURE
vec2 diffuseTexCoords = TEXCOORD_DIFFUSE;
#ifdef HAS_DIFFUSE_TEXTURE_TRANSFORM
diffuseTexCoords = computeTextureTransform(diffuseTexCoords, u_diffuseTextureTransform);
#endif
vec4 diffuse = czm_srgbToLinear(texture2D(u_diffuseTexture, diffuseTexCoords));
#ifdef HAS_DIFFUSE_FACTOR
diffuse *= u_diffuseFactor;
#endif
#elif defined(HAS_DIFFUSE_FACTOR)
vec4 diffuse = clamp(u_diffuseFactor, vec4(0.0), vec4(1.0));
#else
vec4 diffuse = vec4(1.0);
#endif
czm_pbrParameters parameters = czm_pbrSpecularGlossinessMaterial(
diffuse.rgb,
specular,
glossiness
);
material.diffuse = parameters.diffuseColor;
material.alpha = diffuse.a;
material.specular = parameters.f0;
material.roughness = parameters.roughness;
#elif defined(LIGHTING_PBR)
#ifdef HAS_METALLIC_ROUGHNESS_TEXTURE
vec2 metallicRoughnessTexCoords = TEXCOORD_METALLIC_ROUGHNESS;
#ifdef HAS_METALLIC_ROUGHNESS_TEXTURE_TRANSFORM
metallicRoughnessTexCoords = computeTextureTransform(metallicRoughnessTexCoords, u_metallicRoughnessTextureTransform);
#endif
vec3 metallicRoughness = texture2D(u_metallicRoughnessTexture, metallicRoughnessTexCoords).rgb;
float metalness = clamp(metallicRoughness.b, 0.0, 1.0);
float roughness = clamp(metallicRoughness.g, 0.04, 1.0);
#ifdef HAS_METALLIC_FACTOR
metalness *= u_metallicFactor;
#endif
#ifdef HAS_ROUGHNESS_FACTOR
roughness *= u_roughnessFactor;
#endif
#else
#ifdef HAS_METALLIC_FACTOR
float metalness = clamp(u_metallicFactor, 0.0, 1.0);
#else
float metalness = 1.0;
#endif
#ifdef HAS_ROUGHNESS_FACTOR
float roughness = clamp(u_roughnessFactor, 0.04, 1.0);
#else
float roughness = 1.0;
#endif
#endif
czm_pbrParameters parameters = czm_pbrMetallicRoughnessMaterial(
material.diffuse,
metalness,
roughness
);
material.diffuse = parameters.diffuseColor;
material.specular = parameters.f0;
material.roughness = parameters.roughness;
#endif
}
`; var f2e = Dt.Material, L8 = Dt.MetallicRoughness, F8 = Dt.SpecularGlossiness, Yee = { name: "MaterialPipelineStage", _processTexture: x_, _processTextureTransform: Xee }; Yee.process = function (e, t, n) { let i = t.material, o = e.model, r = l(o.classificationType), s = r, a = e.uniformMap, c = e.shaderBuilder, u = n.context.defaultTexture, f = n.context.defaultNormalTexture, d = n.context.defaultEmissiveTexture; d2e(i, a, c, u, f, d, s), l(i.specularGlossiness) ? h2e(i, a, c, u, s) : m2e(i, a, c, u, s); let p = tn.getAttributeBySemantic(t, xt.NORMAL), g = e.lightingOptions; i.unlit || !p || r ? g.lightingModel = Im.UNLIT : g.lightingModel = Im.PBR; let m = o.backFaceCulling && !i.doubleSided; e.renderStateOptions.cull.enabled = m; let A = e.alphaOptions; i.alphaMode === xm.BLEND ? A.pass = xe.TRANSLUCENT : i.alphaMode === xm.MASK && (A.alphaCutoff = i.alphaCutoff), c.addFragmentLines(kM), i.doubleSided && c.addDefine("HAS_DOUBLE_SIDED_MATERIAL", void 0, Te.BOTH) }; function Xee(e, t, n, i, o) { let r = `HAS_${o}_TEXTURE_TRANSFORM`; e.addDefine(r, void 0, Te.FRAGMENT); let s = `${i}Transform`; e.addUniform("mat3", s, Te.FRAGMENT), t[s] = function () { return n.transform } } function x_(e, t, n, i, o, r) { e.addUniform("sampler2D", i, Te.FRAGMENT), t[i] = function () { return y(n.texture, r) }; let s = `HAS_${o}_TEXTURE`; e.addDefine(s, void 0, Te.FRAGMENT); let c = `v_texCoord_${n.texCoord}`, u = `TEXCOORD_${o}`; e.addDefine(u, c, Te.FRAGMENT); let f = n.transform; l(f) && !Q.equals(f, Q.IDENTITY) && Xee(e, t, n, i, o) } function d2e(e, t, n, i, o, r, s) { let a = e.emissiveTexture; l(a) && !s && x_(n, t, a, "u_emissiveTexture", "EMISSIVE", r); let c = e.emissiveFactor; l(c) && !h.equals(c, f2e.DEFAULT_EMISSIVE_FACTOR) && (n.addUniform("vec3", "u_emissiveFactor", Te.FRAGMENT), t.u_emissiveFactor = function () { return e.emissiveFactor }, n.addDefine("HAS_EMISSIVE_FACTOR", void 0, Te.FRAGMENT)); let u = e.normalTexture; l(u) && !s && x_(n, t, u, "u_normalTexture", "NORMAL", o); let f = e.occlusionTexture; l(f) && !s && x_(n, t, f, "u_occlusionTexture", "OCCLUSION", i) } function h2e(e, t, n, i, o) { let r = e.specularGlossiness; n.addDefine("USE_SPECULAR_GLOSSINESS", void 0, Te.FRAGMENT); let s = r.diffuseTexture; l(s) && !o && x_(n, t, s, "u_diffuseTexture", "DIFFUSE", i); let a = r.diffuseFactor; l(a) && !se.equals(a, F8.DEFAULT_DIFFUSE_FACTOR) && (n.addUniform("vec4", "u_diffuseFactor", Te.FRAGMENT), t.u_diffuseFactor = function () { return r.diffuseFactor }, n.addDefine("HAS_DIFFUSE_FACTOR", void 0, Te.FRAGMENT)); let c = r.specularGlossinessTexture; l(c) && !o && x_(n, t, c, "u_specularGlossinessTexture", "SPECULAR_GLOSSINESS", i); let u = r.specularFactor; l(u) && !h.equals(u, F8.DEFAULT_SPECULAR_FACTOR) && (n.addUniform("vec3", "u_specularFactor", Te.FRAGMENT), t.u_specularFactor = function () { return r.specularFactor }, n.addDefine("HAS_SPECULAR_FACTOR", void 0, Te.FRAGMENT)); let f = r.glossinessFactor; l(f) && f !== F8.DEFAULT_GLOSSINESS_FACTOR && (n.addUniform("float", "u_glossinessFactor", Te.FRAGMENT), t.u_glossinessFactor = function () { return r.glossinessFactor }, n.addDefine("HAS_GLOSSINESS_FACTOR", void 0, Te.FRAGMENT)) } function m2e(e, t, n, i, o) { let r = e.metallicRoughness; n.addDefine("USE_METALLIC_ROUGHNESS", void 0, Te.FRAGMENT); let s = r.baseColorTexture; l(s) && !o && x_(n, t, s, "u_baseColorTexture", "BASE_COLOR", i); let a = r.baseColorFactor; l(a) && !se.equals(a, L8.DEFAULT_BASE_COLOR_FACTOR) && (n.addUniform("vec4", "u_baseColorFactor", Te.FRAGMENT), t.u_baseColorFactor = function () { return r.baseColorFactor }, n.addDefine("HAS_BASE_COLOR_FACTOR", void 0, Te.FRAGMENT)); let c = r.metallicRoughnessTexture; l(c) && !o && x_(n, t, c, "u_metallicRoughnessTexture", "METALLIC_ROUGHNESS", i); let u = r.metallicFactor; l(u) && u !== L8.DEFAULT_METALLIC_FACTOR && (n.addUniform("float", "u_metallicFactor", Te.FRAGMENT), t.u_metallicFactor = function () { return r.metallicFactor }, n.addDefine("HAS_METALLIC_FACTOR", void 0, Te.FRAGMENT)); let f = r.roughnessFactor; l(f) && f !== L8.DEFAULT_ROUGHNESS_FACTOR && (n.addUniform("float", "u_roughnessFactor", Te.FRAGMENT), t.u_roughnessFactor = function () { return r.roughnessFactor }, n.addDefine("HAS_ROUGHNESS_FACTOR", void 0, Te.FRAGMENT)) } var UM = Yee; var zM = `void morphTargetsStage(inout ProcessedAttributes attributes)
{
vec3 positionMC = attributes.positionMC;
attributes.positionMC = getMorphedPosition(positionMC);
#ifdef HAS_NORMALS
vec3 normalMC = attributes.normalMC;
attributes.normalMC = getMorphedNormal(normalMC);
#endif
#ifdef HAS_TANGENTS
vec3 tangentMC = attributes.tangentMC;
attributes.tangentMC = getMorphedTangent(tangentMC);
#endif
}
`; var Qs = { name: "MorphTargetsPipelineStage", FUNCTION_ID_GET_MORPHED_POSITION: "getMorphedPosition", FUNCTION_SIGNATURE_GET_MORPHED_POSITION: "vec3 getMorphedPosition(in vec3 position)", FUNCTION_ID_GET_MORPHED_NORMAL: "getMorphedNormal", FUNCTION_SIGNATURE_GET_MORPHED_NORMAL: "vec3 getMorphedNormal(in vec3 normal)", FUNCTION_ID_GET_MORPHED_TANGENT: "getMorphedTangent", FUNCTION_SIGNATURE_GET_MORPHED_TANGENT: "vec3 getMorphedTangent(in vec3 tangent)" }; Qs.process = function (e, t) { let n = e.shaderBuilder; n.addDefine("HAS_MORPH_TARGETS", void 0, Te.VERTEX), C2e(n); let i = t.morphTargets.length; for (let a = 0; a < i; a++) { let c = t.morphTargets[a].attributes, u = c.length; for (let f = 0; f < u; f++) { let d = c[f], p = d.semantic; p !== xt.POSITION && p !== xt.NORMAL && p !== xt.TANGENT || (_2e(e, d, e.attributeIndex, a), e.attributeIndex++) } } x2e(n); let r = e.runtimeNode.morphWeights.length; n.addUniform("float", `u_morphWeights[${r}]`, Te.VERTEX), n.addVertexLines(zM); let s = { u_morphWeights: function () { return e.runtimeNode.morphWeights } }; e.uniformMap = yt(s, e.uniformMap) }; var p2e = { attributeString: void 0, functionId: void 0 }; function _2e(e, t, n, i) { let o = e.shaderBuilder; g2e(e, t, n); let r = y2e(t, p2e); A2e(o, r, i) } function g2e(e, t, n) { let i = { index: n, value: l(t.buffer) ? void 0 : t.constant, vertexBuffer: t.buffer, componentsPerAttribute: en.getNumberOfComponents(t.type), componentDatatype: t.componentDatatype, offsetInBytes: t.byteOffset, strideInBytes: t.byteStride, normalize: t.normalized }; e.attributes.push(i) } function y2e(e, t) { switch (e.semantic) { case xt.POSITION: t.attributeString = "Position", t.functionId = Qs.FUNCTION_ID_GET_MORPHED_POSITION; break; case xt.NORMAL: t.attributeString = "Normal", t.functionId = Qs.FUNCTION_ID_GET_MORPHED_NORMAL; break; case xt.TANGENT: t.attributeString = "Tangent", t.functionId = Qs.FUNCTION_ID_GET_MORPHED_TANGENT; break; default: break }return t } function A2e(e, t, n) { let i = t.attributeString, o = `a_target${i}_${n}`, r = `morphed${i} += u_morphWeights[${n}] * a_target${i}_${n};`; e.addAttribute("vec3", o), e.addFunctionLines(t.functionId, [r]) } function C2e(e) { e.addFunction(Qs.FUNCTION_ID_GET_MORPHED_POSITION, Qs.FUNCTION_SIGNATURE_GET_MORPHED_POSITION, Te.VERTEX); let t = "vec3 morphedPosition = position;"; e.addFunctionLines(Qs.FUNCTION_ID_GET_MORPHED_POSITION, [t]), e.addFunction(Qs.FUNCTION_ID_GET_MORPHED_NORMAL, Qs.FUNCTION_SIGNATURE_GET_MORPHED_NORMAL, Te.VERTEX); let n = "vec3 morphedNormal = normal;"; e.addFunctionLines(Qs.FUNCTION_ID_GET_MORPHED_NORMAL, [n]), e.addFunction(Qs.FUNCTION_ID_GET_MORPHED_TANGENT, Qs.FUNCTION_SIGNATURE_GET_MORPHED_TANGENT, Te.VERTEX); let i = "vec3 morphedTangent = tangent;"; e.addFunctionLines(Qs.FUNCTION_ID_GET_MORPHED_TANGENT, [i]) } function x2e(e) { let t = "return morphedPosition;"; e.addFunctionLines(Qs.FUNCTION_ID_GET_MORPHED_POSITION, [t]); let n = "return morphedNormal;"; e.addFunctionLines(Qs.FUNCTION_ID_GET_MORPHED_NORMAL, [n]); let i = "return morphedTangent;"; e.addFunctionLines(Qs.FUNCTION_ID_GET_MORPHED_TANGENT, [i]) } var HM = Qs; var Kee = { name: "PickingPipelineStage" }; Kee.process = function (e, t, n) { let i = n.context, o = e.runtimeNode, r = e.shaderBuilder, s = e.model, a = o.node.instances; if (e.hasPropertyTable) T2e(e, t, a, i); else if (l(a)) E2e(e, i); else { let c = Jee(e), u = i.createPickId(c); s._pipelineResources.push(u), s._pickIds.push(u), r.addUniform("vec4", "czm_pickColor", Te.FRAGMENT); let f = e.uniformMap; f.czm_pickColor = function () { return u.color }, e.pickId = "czm_pickColor" } }; function Jee(e, t) { let n = e.model; if (l(n.pickObject)) return n.pickObject; let i = { model: n, node: e.runtimeNode, primitive: e.runtimePrimitive }, o; if (ar.is3DTiles(n.type)) { let r = n.content; o = { content: r, primitive: r.tileset, detail: i } } else o = { primitive: n, detail: i }; return o.id = n.id, l(t) && (o.instanceId = t), o } function T2e(e, t, n) { let i = e.model, o, r, s = i.featureIdLabel, a = i.instanceFeatureIdLabel; l(i.featureTableId) ? o = i.featureTableId : l(n) ? (r = tn.getFeatureIdsByLabel(n.featureIds, a), o = r.propertyTableId) : (r = tn.getFeatureIdsByLabel(t.featureIds, s), o = r.propertyTableId); let c = i.featureTables[o]; e.shaderBuilder.addUniform("sampler2D", "model_pickTexture", Te.FRAGMENT); let f = c.batchTexture; e.uniformMap.model_pickTexture = function () { return y(f.pickTexture, f.defaultTexture) }, e.pickId = "((selectedFeature.id < int(model_featuresLength)) ? texture2D(model_pickTexture, selectedFeature.st) : vec4(0.0))" } function E2e(e, t) { let n = e.instanceCount, i = new Array(n), o = new Uint8Array(n * 4), r = e.model, s = r._pipelineResources; for (let d = 0; d < n; d++) { let p = Jee(e, d), g = t.createPickId(p); s.push(g), i[d] = g; let m = g.color; o[d * 4 + 0] = U.floatToByte(m.red), o[d * 4 + 1] = U.floatToByte(m.green), o[d * 4 + 2] = U.floatToByte(m.blue), o[d * 4 + 3] = U.floatToByte(m.alpha) } r._pickIds = i; let a = ct.createVertexBuffer({ context: t, typedArray: o, usage: Re.STATIC_DRAW }); a.vertexArrayDestroyable = !1; let c = !1; r.statistics.addBuffer(a, c), s.push(a); let u = { index: e.attributeIndex++, vertexBuffer: a, componentsPerAttribute: 4, componentDatatype: Y.UNSIGNED_BYTE, normalize: !0, offsetInBytes: 0, strideInBytes: 0, instanceDivisor: 1 }; e.attributes.push(u); let f = e.shaderBuilder; f.addDefine("USE_PICKING", void 0, Te.BOTH), f.addAttribute("vec4", "a_pickColor"), f.addVarying("vec4", "v_pickColor"), e.pickId = "v_pickColor" } var GM = Kee; var b2e = { ADD: 0, REPLACE: 1 }, vr = Object.freeze(b2e); var WM = `float getPointSizeFromAttenuation(vec3 positionEC) {
float pointSize = model_pointCloudParameters.x;
float geometricError = model_pointCloudParameters.y;
float depthMultiplier = model_pointCloudParameters.z;
float depth = -positionEC.z;
return min((geometricError / depth) * depthMultiplier, pointSize);
}
#ifdef HAS_POINT_CLOUD_SHOW_STYLE
float pointCloudShowStylingStage(in ProcessedAttributes attributes, in Metadata metadata) {
float tiles3d_tileset_time = model_pointCloudParameters.w;
return float(getShowFromStyle(attributes, metadata, tiles3d_tileset_time));
}
#endif
#ifdef HAS_POINT_CLOUD_COLOR_STYLE
vec4 pointCloudColorStylingStage(in ProcessedAttributes attributes, in Metadata metadata) {
float tiles3d_tileset_time = model_pointCloudParameters.w;
return getColorFromStyle(attributes, metadata, tiles3d_tileset_time);
}
#endif
#ifdef HAS_POINT_CLOUD_POINT_SIZE_STYLE
float pointCloudPointSizeStylingStage(in ProcessedAttributes attributes, in Metadata metadata) {
float tiles3d_tileset_time = model_pointCloudParameters.w;
return float(getPointSizeFromStyle(attributes, metadata, tiles3d_tileset_time));
}
#elif defined(HAS_POINT_CLOUD_ATTENUATION)
float pointCloudPointSizeStylingStage(in ProcessedAttributes attributes, in Metadata metadata) {
return getPointSizeFromAttenuation(v_positionEC);
}
#endif
#ifdef HAS_POINT_CLOUD_BACK_FACE_CULLING
float pointCloudBackFaceCullingStage() {
#if defined(HAS_NORMALS) && !defined(HAS_DOUBLE_SIDED_MATERIAL)
return step(-v_normalEC.z, 0.0);
#else
return 1.0;
#endif
}
#endif
`; var S2e = new se, Qee = { name: "PointCloudStylingPipelineStage" }; Qee.process = function (e, t, n) { let i = e.shaderBuilder, o = e.model, r = o.style, s = o.structuralMetadata, a = l(s) ? s.propertyAttributes : void 0, c = l(o.featureTableId) && o.featureTables[o.featureTableId].featuresLength > 0, u = !l(a) && c; if (l(r) && !u) { let A = P2e(a), C = I2e(r, A); O2e(i, C); let T = B2e(C).indexOf("normalMC") >= 0, b = tn.getAttributeBySemantic(t, xt.NORMAL); if (T && !b) throw new fe("Style references the NORMAL semantic but the point cloud does not have normals"); i.addDefine("COMPUTE_POSITION_WC_STYLE", void 0, Te.VERTEX), C.styleTranslucent && (e.alphaOptions.pass = xe.TRANSLUCENT) } let f = o.pointCloudShading; f.attenuation && i.addDefine("HAS_POINT_CLOUD_ATTENUATION", void 0, Te.VERTEX), f.backFaceCulling && i.addDefine("HAS_POINT_CLOUD_BACK_FACE_CULLING", void 0, Te.VERTEX); let d, p, g; ar.is3DTiles(o.type) && (p = !0, d = o.content, g = d.tile.refine === vr.ADD), i.addUniform("vec4", "model_pointCloudParameters", Te.VERTEX), i.addVertexLines(WM); let m = e.uniformMap; m.model_pointCloudParameters = function () { let A = S2e, C = 1; p && (C = g ? 5 : d.tileset.maximumScreenSpaceError), A.x = y(f.maximumAttenuation, C), A.x *= n.pixelRatio; let x = w2e(e, t, f, d); A.y = x * f.geometricErrorScale; let T = n.context, b = n.camera.frustum, S; return n.mode === ee.SCENE2D || b instanceof Zt ? S = Number.POSITIVE_INFINITY : S = T.drawingBufferHeight / n.camera.frustum.sseDenominator, A.z = S, p && (A.w = d.tileset.timeSinceLoad), A } }; var Zee = new h; function w2e(e, t, n, i) { if (l(i)) { let f = i.tile.geometricError; if (f > 0) return f } if (l(n.baseResolution)) return n.baseResolution; let o = tn.getAttributeBySemantic(t, xt.POSITION), r = o.count, s = e.runtimeNode.transform, a = h.subtract(o.max, o.min, Zee); a = F.multiplyByPointAsVector(s, a, Zee); let c = a.x * a.y * a.z; return I.cbrt(c / r) } var D2e = { colorStyleFunction: void 0, showStyleFunction: void 0, pointSizeStyleFunction: void 0, styleTranslucent: !1 }, v2e = { POSITION: "attributes.positionMC", POSITION_ABSOLUTE: "v_positionWC", COLOR: "attributes.color_0", NORMAL: "attributes.normalMC" }; function P2e(e) { let t = tt(v2e); if (!l(e)) return t; for (let n = 0; n < e.length; n++) { let o = e[n].properties; for (let r in o) o.hasOwnProperty(r) && (t[r] = `metadata.${r}`) } return t } var N8 = "ProcessedAttributes attributes, Metadata metadata, float tiles3d_tileset_time"; function I2e(e, t) { let n = D2e, i = { translucent: !1 }; return n.colorStyleFunction = e.getColorShaderFunction(`getColorFromStyle(${N8})`, t, i), n.showStyleFunction = e.getShowShaderFunction(`getShowFromStyle(${N8})`, t, i), n.pointSizeStyleFunction = e.getPointSizeShaderFunction(`getPointSizeFromStyle(${N8})`, t, i), n.styleTranslucent = l(n.colorStyleFunction) && i.translucent, n } function O2e(e, t) { let n = t.colorStyleFunction; l(n) && (e.addDefine("HAS_POINT_CLOUD_COLOR_STYLE", void 0, Te.BOTH), e.addVertexLines(n), e.addVarying("vec4", "v_pointCloudColor")); let i = t.showStyleFunction; l(i) && (e.addDefine("HAS_POINT_CLOUD_SHOW_STYLE", void 0, Te.VERTEX), e.addVertexLines(i)); let o = t.pointSizeStyleFunction; l(o) && (e.addDefine("HAS_POINT_CLOUD_POINT_SIZE_STYLE", void 0, Te.VERTEX), e.addVertexLines(o)) } function V8(e, t) { let n = /attributes\.(\w+)/g, i = n.exec(e); for (; i !== null;) { let o = i[1]; t.indexOf(o) === -1 && t.push(o), i = n.exec(e) } } function B2e(e) { let t = e.colorStyleFunction, n = e.showStyleFunction, i = e.pointSizeStyleFunction, o = []; return l(t) && V8(t, o), l(n) && V8(n, o), l(i) && V8(i, o), o } var jM = Qee; var qM = `void primitiveOutlineStage() {
v_outlineCoordinates = a_outlineCoordinates;
}
`; var YM = `void primitiveOutlineStage(inout czm_modelMaterial material) {
if (!model_showOutline) {
return;
}
float outlineX =
texture2D(model_outlineTexture, vec2(v_outlineCoordinates.x, 0.5)).r;
float outlineY =
texture2D(model_outlineTexture, vec2(v_outlineCoordinates.y, 0.5)).r;
float outlineZ =
texture2D(model_outlineTexture, vec2(v_outlineCoordinates.z, 0.5)).r;
float outlineness = max(outlineX, max(outlineY, outlineZ));
material.diffuse = mix(material.diffuse, model_outlineColor.rgb, model_outlineColor.a * outlineness);
}
`; var $ee = { name: "PrimitiveOutlinePipelineStage" }; $ee.process = function (e, t, n) { let i = e.shaderBuilder, o = e.uniformMap; i.addDefine("HAS_PRIMITIVE_OUTLINE", void 0, Te.BOTH), i.addAttribute("vec3", "a_outlineCoordinates"), i.addVarying("vec3", "v_outlineCoordinates"); let r = t.outlineCoordinates, s = { index: e.attributeIndex++, vertexBuffer: r.buffer, componentsPerAttribute: en.getNumberOfComponents(r.type), componentDatatype: r.componentDatatype, offsetInBytes: r.byteOffset, strideInBytes: r.byteStride, normalize: r.normalized }; e.attributes.push(s), i.addUniform("sampler2D", "model_outlineTexture", Te.FRAGMENT); let a = $C.createTexture(n.context); o.model_outlineTexture = function () { return a }; let c = e.model; i.addUniform("vec4", "model_outlineColor", Te.FRAGMENT), o.model_outlineColor = function () { return c.outlineColor }, i.addUniform("bool", "model_showOutline", Te.FRAGMENT), o.model_showOutline = function () { return c.showOutline }, i.addVertexLines(qM), i.addFragmentLines(YM) }; var XM = $ee; var ete = { name: "PrimitiveStatisticsPipelineStage", _countGeometry: tte, _count2DPositions: nte, _countMorphTargetAttributes: ite, _countMaterialTextures: ote, _countFeatureIdTextures: rte, _countBinaryMetadata: ste }; ete.process = function (e, t, n) { let i = e.model, o = i.statistics; tte(o, t), nte(o, e.runtimePrimitive), ite(o, t), ote(o, t.material), rte(o, t.featureIds), ste(o, i) }; function tte(e, t) { let n = l(t.indices) ? t.indices.count : tn.getAttributeBySemantic(t, "POSITION").count, i = t.primitiveType; i === Oe.POINTS ? e.pointsLength += n : Oe.isTriangles(i) && (e.trianglesLength += R2e(i, n)); let o = t.attributes, r = o.length; for (let c = 0; c < r; c++) { let u = o[c]; if (l(u.buffer)) { let f = l(u.typedArray); e.addBuffer(u.buffer, f) } } let s = t.outlineCoordinates; l(s) && l(s.buffer) && e.addBuffer(s.buffer, !1); let a = t.indices; if (l(a) && l(a.buffer)) { let c = l(a.typedArray); e.addBuffer(a.buffer, c) } } function R2e(e, t) { switch (e) { case Oe.TRIANGLES: return t / 3; case Oe.TRIANGLE_STRIP: case Oe.TRIANGLE_FAN: return Math.max(t - 2, 0); default: return 0 } } function nte(e, t) { let n = t.positionBuffer2D; l(n) && e.addBuffer(n, !0) } function ite(e, t) { let n = t.morphTargets; if (!l(n)) return; let i = !1, o = n.length; for (let r = 0; r < o; r++) { let s = n[r].attributes, a = s.length; for (let c = 0; c < a; c++) { let u = s[c]; l(u.buffer) && e.addBuffer(u.buffer, i) } } } function ote(e, t) { let n = M2e(t), i = n.length; for (let o = 0; o < i; o++) { let r = n[o]; l(r) && l(r.texture) && e.addTexture(r.texture) } } function M2e(e) { let t = e.metallicRoughness, n = [e.emissiveTexture, e.normalTexture, e.occlusionTexture, t.baseColorTexture, t.metallicRoughnessTexture], i = e.specularGlossiness; return l(i) && (n.push(i.diffuseTexture), n.push(i.specularGlossinessTexture)), n } function rte(e, t) { let n = t.length; for (let i = 0; i < n; i++) { let o = t[i]; if (o instanceof Dt.FeatureIdTexture) { let r = o.textureReader; l(r.texture) && e.addTexture(r.texture) } } } function ste(e, t) { let n = t.structuralMetadata; l(n) && (L2e(e, n), e.propertyTablesByteLength += n.propertyTablesByteLength); let i = t.featureTables; if (!l(i)) return; let o = i.length; for (let r = 0; r < o; r++) { let s = i[r]; e.addBatchTexture(s.batchTexture) } } function L2e(e, t) { let n = t.propertyTextures; if (!l(n)) return; let i = n.length; for (let o = 0; o < i; o++) { let s = n[o].properties; for (let a in s) if (s.hasOwnProperty(a)) { let u = s[a].textureReader; l(u.texture) && e.addTexture(u.texture) } } } var KM = ete; var F2e = new F, N2e = new F, ate = { name: "SceneMode2DPipelineStage" }; ate.process = function (e, t, n) { let i = tn.getAttributeBySemantic(t, xt.POSITION), o = e.shaderBuilder, r = e.model, s = r.sceneGraph.computedModelMatrix, a = e.runtimeNode.computedTransform, c = F.multiplyTransformation(s, a, F2e), u = U2e(e, c, n), f = e.runtimePrimitive; f.boundingSphere2D = u; let d = e.runtimeNode.node.instances; if (l(d)) return; if (l(i.typedArray)) { let A = G2e(i, c, u, n); f.positionBuffer2D = A, r._modelResources.push(A), i.typedArray = void 0 } o.addDefine("USE_2D_POSITIONS", void 0, Te.VERTEX), o.addUniform("mat4", "u_modelView2D", Te.VERTEX); let p = F.fromTranslation(u.center, new F), g = n.context, m = { u_modelView2D: function () { return F.multiplyTransformation(g.uniformState.view, p, N2e) } }; e.uniformMap = yt(m, e.uniformMap) }; var V2e = new h, k2e = new h; function U2e(e, t, n) { let i = F.multiplyByPoint(t, e.positionMin, V2e), o = ji.computeActualWgs84Position(n, i, i), r = F.multiplyByPoint(t, e.positionMax, k2e), s = ji.computeActualWgs84Position(n, r, r); return re.fromCornerPoints(o, s, new re) } var cte = new h; function z2e(e, t) { let n = e.length, i = new Float32Array(n), o = t.quantizedVolumeOffset, r = t.quantizedVolumeStepSize; for (let s = 0; s < n; s += 3) { let a = h.fromArray(e, s, cte), c = h.multiplyComponents(a, r, a), u = h.add(c, o, c); i[s] = u.x, i[s + 1] = u.y, i[s + 2] = u.z } return i } function H2e(e, t, n, i) { let o; l(e.quantization) ? o = z2e(e.typedArray, e.quantization) : o = e.typedArray.slice(); let r = e.byteOffset / Float32Array.BYTES_PER_ELEMENT, s = o.length, a = l(e.byteStride) ? e.byteStride / Float32Array.BYTES_PER_ELEMENT : 3; for (let c = r; c < s; c += a) { let u = h.fromArray(o, c, cte); if (isNaN(u.x) || isNaN(u.y) || isNaN(u.z)) continue; let f = F.multiplyByPoint(t, u, u), d = ji.computeActualWgs84Position(i, f, f), p = h.subtract(d, n, d); o[c] = p.x, o[c + 1] = p.y, o[c + 2] = p.z } return o } function G2e(e, t, n, i) { let o = tt(i); o.mode = ee.COLUMBUS_VIEW; let r = n.center, s = H2e(e, t, r, o), a = ct.createVertexBuffer({ context: i.context, typedArray: s, usage: Re.STATIC_DRAW }); return a.vertexArrayDestroyable = !1, a } var JM = ate; var ZM = `void skinningStage(inout ProcessedAttributes attributes)
{
mat4 skinningMatrix = getSkinningMatrix();
mat3 skinningMatrixMat3 = mat3(skinningMatrix);
vec4 positionMC = vec4(attributes.positionMC, 1.0);
attributes.positionMC = vec3(skinningMatrix * positionMC);
#ifdef HAS_NORMALS
vec3 normalMC = attributes.normalMC;
attributes.normalMC = skinningMatrixMat3 * normalMC;
#endif
#ifdef HAS_TANGENTS
vec3 tangentMC = attributes.tangentMC;
attributes.tangentMC = skinningMatrixMat3 * tangentMC;
#endif
}
`; var J0 = { name: "SkinningPipelineStage", FUNCTION_ID_GET_SKINNING_MATRIX: "getSkinningMatrix", FUNCTION_SIGNATURE_GET_SKINNING_MATRIX: "mat4 getSkinningMatrix()" }; J0.process = function (e, t) { let n = e.shaderBuilder; n.addDefine("HAS_SKINNING", void 0, Te.VERTEX), j2e(n, t); let i = e.runtimeNode, o = i.computedJointMatrices; n.addUniform("mat4", `u_jointMatrices[${o.length}]`, Te.VERTEX), n.addVertexLines(ZM); let r = { u_jointMatrices: function () { return i.computedJointMatrices } }; e.uniformMap = yt(r, e.uniformMap) }; function W2e(e) { let t = -1, n = e.attributes, i = n.length; for (let o = 0; o < i; o++) { let r = n[o]; (r.semantic === xt.JOINTS || r.semantic === xt.WEIGHTS) && (t = Math.max(t, r.setIndex)) } return t } function j2e(e, t) { e.addFunction(J0.FUNCTION_ID_GET_SKINNING_MATRIX, J0.FUNCTION_SIGNATURE_GET_SKINNING_MATRIX, Te.VERTEX); let n = "mat4 skinnedMatrix = mat4(0);"; e.addFunctionLines(J0.FUNCTION_ID_GET_SKINNING_MATRIX, [n]); let i, o, r = ["x", "y", "z", "w"], s = W2e(t); for (i = 0; i <= s; i++)for (o = 0; o <= 3; o++) { let c = r[o], u = `skinnedMatrix += a_weights_${i}.${c} * u_jointMatrices[int(a_joints_${i}.${c})];`; e.addFunctionLines(J0.FUNCTION_ID_GET_SKINNING_MATRIX, [u]) } let a = "return skinnedMatrix;"; e.addFunctionLines(J0.FUNCTION_ID_GET_SKINNING_MATRIX, [a]) } var QM = J0; var k8 = {}; function q2e(e) { let t = Me.createTypedArray(e, e * 2), n = e, i = 0; for (let o = 0; o < n; o += 3)t[i++] = o, t[i++] = o + 1, t[i++] = o + 1, t[i++] = o + 2, t[i++] = o + 2, t[i++] = o; return t } function Y2e(e, t) { let n = t.length, i = Me.createTypedArray(e, n * 2), o = 0; for (let r = 0; r < n; r += 3) { let s = t[r], a = t[r + 1], c = t[r + 2]; i[o++] = s, i[o++] = a, i[o++] = a, i[o++] = c, i[o++] = c, i[o++] = s } return i } function X2e(e) { let t = e - 2, n = 2 + t * 4, i = Me.createTypedArray(e, n), o = 0; i[o++] = 0, i[o++] = 1; for (let r = 0; r < t; r++)i[o++] = r + 1, i[o++] = r + 2, i[o++] = r + 2, i[o++] = r; return i } function K2e(e, t) { let i = t.length - 2, o = 2 + i * 4, r = Me.createTypedArray(e, o), s = 0; r[s++] = t[0], r[s++] = t[1]; for (let a = 0; a < i; a++) { let c = t[a], u = t[a + 1], f = t[a + 2]; r[s++] = u, r[s++] = f, r[s++] = f, r[s++] = c } return r } function J2e(e) { let t = e - 2, n = 2 + t * 4, i = Me.createTypedArray(e, n), o = 0; i[o++] = 0, i[o++] = 1; for (let r = 0; r < t; r++)i[o++] = r + 1, i[o++] = r + 2, i[o++] = r + 2, i[o++] = 0; return i } function Z2e(e, t) { let i = t.length - 2, o = 2 + i * 4, r = Me.createTypedArray(e, o), s = 0, a = t[0]; r[s++] = a, r[s++] = t[1]; for (let c = 0; c < i; c++) { let u = t[c + 1], f = t[c + 2]; r[s++] = u, r[s++] = f, r[s++] = f, r[s++] = a } return r } k8.createWireframeIndices = function (e, t, n) { let i = l(n); if (e === Oe.TRIANGLES) return i ? Y2e(t, n) : q2e(t); if (e === Oe.TRIANGLE_STRIP) return i ? K2e(t, n) : X2e(t); if (e === Oe.TRIANGLE_FAN) return i ? Z2e(t, n) : J2e(t) }; k8.getWireframeIndicesCount = function (e, t) { if (e === Oe.TRIANGLES) return t * 2; if (e === Oe.TRIANGLE_STRIP || e === Oe.TRIANGLE_FAN) { let n = t - 2; return 2 + n * 4 } return t }; var LS = k8; var lte = { name: "WireframePipelineStage" }; lte.process = function (e, t, n) { e.shaderBuilder.addDefine("HAS_WIREFRAME", void 0, Te.FRAGMENT); let o = e.model, r = Q2e(t, e.indices, n); o._pipelineResources.push(r), e.wireframeIndexBuffer = r; let s = !1; o.statistics.addBuffer(r, s); let a = e.primitiveType, c = e.count; e.primitiveType = Oe.LINES, e.count = LS.getWireframeIndicesCount(a, c) }; function Q2e(e, t, n) { let o = tn.getAttributeBySemantic(e, xt.POSITION).count, r = n.context.webgl2, s; if (l(t)) { let f = t.buffer, d = t.count; l(f) && r ? (s = f.sizeInBytes === d ? new Uint8Array(d) : Me.createTypedArray(o, d), f.getBufferData(s)) : s = t.typedArray } let a = e.primitiveType, c = LS.createWireframeIndices(a, o, s), u = Me.fromSizeInBytes(c.BYTES_PER_ELEMENT); return ct.createIndexBuffer({ context: n.context, typedArray: c, usage: Re.STATIC_DRAW, indexDatatype: u }) } var $M = lte; function ute(e) { e = y(e, y.EMPTY_OBJECT); let t = e.primitive, n = e.node, i = e.model; this.primitive = t, this.node = n, this.model = i, this.pipelineStages = [], this.drawCommand = void 0, this.boundingSphere = void 0, this.boundingSphere2D = void 0, this.positionBuffer2D = void 0, this.batchLengths = void 0, this.batchOffsets = void 0, this.updateStages = [] } ute.prototype.configurePipeline = function (e) { let t = this.pipelineStages; t.length = 0; let n = this.primitive, i = this.node, o = this.model, r = o.customShader, s = o.style, a = e.context.webgl2, u = e.mode !== ee.SCENE3D && !e.scene3DOnly && o._projectTo2D, f = l(n.morphTargets) && n.morphTargets.length > 0, d = l(i.skin), p = l(r), m = !(p && l(r.fragmentShaderText)) || r.mode !== C_.REPLACE_MATERIAL, A = tn.hasQuantizedAttributes(n.attributes), C = o.debugWireframe && Oe.isTriangles(n.primitiveType) && (o._enableDebugWireframe || a), x = o.pointCloudShading, T = l(x) && x.attenuation, b = l(x) && x.backFaceCulling, S = n.primitiveType === Oe.POINTS && (l(s) || T || b), D = o._enableShowOutline && l(n.outlineCoordinates), P = $2e(o, i, n), B = l(o.classificationType); u && t.push(JM), t.push(FM), C && t.push($M), B && t.push(TM), f && t.push(HM), d && t.push(QM), S && t.push(jM), A && t.push(RM), m && t.push(UM), t.push(Y0), t.push(bf), P.hasPropertyTable && (t.push(K0), t.push(xM), t.push(SM)), p && t.push(BM), t.push(VM), o.allowPicking && t.push(GM), D && t.push(XM), t.push(CM), t.push(KM) }; function $2e(e, t, n) { let i; return l(t.instances) && (i = tn.getFeatureIdsByLabel(t.instances.featureIds, e.instanceFeatureIdLabel), l(i)) ? { hasFeatureIds: !0, hasPropertyTable: l(i.propertyTableId) } : (i = tn.getFeatureIdsByLabel(n.featureIds, e.featureIdLabel), l(i) ? { hasFeatureIds: !0, hasPropertyTable: l(i.propertyTableId) } : { hasFeatureIds: !1, hasPropertyTable: !1 }) } var eL = ute; function U8(e) { e = y(e, y.EMPTY_OBJECT), this._sceneGraph = e.sceneGraph; let t = e.skin; this._skin = t, this._inverseBindMatrices = void 0, this._joints = [], this._jointMatrices = [], e3e(this) } Object.defineProperties(U8.prototype, { skin: { get: function () { return this._skin } }, sceneGraph: { get: function () { return this._sceneGraph } }, inverseBindMatrices: { get: function () { return this._inverseBindMatrices } }, joints: { get: function () { return this._joints } }, jointMatrices: { get: function () { return this._jointMatrices } } }); function e3e(e) { let t = e.skin, n = t.inverseBindMatrices; e._inverseBindMatrices = n; let i = t.joints, o = i.length, r = e.sceneGraph._runtimeNodes, s = e.joints, a = e._jointMatrices; for (let c = 0; c < o; c++) { let u = i[c].index, f = r[u]; s.push(f); let d = n[c], p = fte(f, d, new F); a.push(p) } } function fte(e, t, n) { let i = F.multiplyTransformation(e.transformToRoot, e.transform, n); return n = F.multiplyTransformation(i, t, n), n } U8.prototype.updateJointMatrices = function () { let e = this._jointMatrices, t = e.length; for (let n = 0; n < t; n++) { let i = this.joints[n], o = this.inverseBindMatrices[n]; e[n] = fte(i, o, e[n]) } }; var tL = U8; function t3e() { this.pass = void 0, this.alphaCutoff = void 0 } var nL = t3e; function z8(e) { this.name = e, this.fields = [] } z8.prototype.addField = function (e, t) { let n = `    ${e} ${t};`; this.fields.push(n) }; z8.prototype.generateGlslLines = function () { let e = this.fields; return e.length === 0 && (e = ["    float _empty;"]), [].concat(`struct ${this.name}`, "{", e, "};") }; var iL = z8; function H8(e) { this.signature = e, this.body = [] } H8.prototype.addLines = function (e) { let t = this.body; if (Array.isArray(e)) { let n = e.length; for (let i = 0; i < n; i++)t.push(`    ${e[i]}`) } else t.push(`    ${e}`) }; H8.prototype.generateGlslLines = function () { return [].concat(this.signature, "{", this.body, "}") }; var oL = H8; function sc() { this._positionAttributeLine = void 0, this._nextAttributeLocation = 1, this._attributeLocations = {}, this._attributeLines = [], this._structs = {}, this._functions = {}, this._vertexShaderParts = { defineLines: [], uniformLines: [], shaderLines: [], varyingLines: [], structIds: [], functionIds: [] }, this._fragmentShaderParts = { defineLines: [], uniformLines: [], shaderLines: [], varyingLines: [], structIds: [], functionIds: [] } } Object.defineProperties(sc.prototype, { attributeLocations: { get: function () { return this._attributeLocations } } }); sc.prototype.addDefine = function (e, t, n) { n = y(n, Te.BOTH); let i = e; l(t) && (i += ` ${t.toString()}`), Te.includesVertexShader(n) && this._vertexShaderParts.defineLines.push(i), Te.includesFragmentShader(n) && this._fragmentShaderParts.defineLines.push(i) }; sc.prototype.addStruct = function (e, t, n) { this._structs[e] = new iL(t), Te.includesVertexShader(n) && this._vertexShaderParts.structIds.push(e), Te.includesFragmentShader(n) && this._fragmentShaderParts.structIds.push(e) }; sc.prototype.addStructField = function (e, t, n) { this._structs[e].addField(t, n) }; sc.prototype.addFunction = function (e, t, n) { this._functions[e] = new oL(t), Te.includesVertexShader(n) && this._vertexShaderParts.functionIds.push(e), Te.includesFragmentShader(n) && this._fragmentShaderParts.functionIds.push(e) }; sc.prototype.addFunctionLines = function (e, t) { this._functions[e].addLines(t) }; sc.prototype.addUniform = function (e, t, n) { n = y(n, Te.BOTH); let i = `uniform ${e} ${t};`; Te.includesVertexShader(n) && this._vertexShaderParts.uniformLines.push(i), Te.includesFragmentShader(n) && this._fragmentShaderParts.uniformLines.push(i) }; sc.prototype.setPositionAttribute = function (e, t) { return this._positionAttributeLine = `attribute ${e} ${t};`, this._attributeLocations[t] = 0, 0 }; sc.prototype.addAttribute = function (e, t) { let n = `attribute ${e} ${t};`; this._attributeLines.push(n); let i = this._nextAttributeLocation; return this._attributeLocations[t] = i, this._nextAttributeLocation += i3e(e), i }; sc.prototype.addVarying = function (e, t) { let n = `varying ${e} ${t};`; this._vertexShaderParts.varyingLines.push(n), this._fragmentShaderParts.varyingLines.push(n) }; sc.prototype.addVertexLines = function (e) { let t = this._vertexShaderParts.shaderLines; Array.isArray(e) ? t.push.apply(t, e) : t.push(e) }; sc.prototype.addFragmentLines = function (e) { let t = this._fragmentShaderParts.shaderLines; Array.isArray(e) ? t.push.apply(t, e) : t.push(e) }; sc.prototype.buildShaderProgram = function (e) {
        let t = l(this._positionAttributeLine) ? [this._positionAttributeLine] : [], n = n3e(this), i = o3e(this), o = t.concat(this._attributeLines, this._vertexShaderParts.uniformLines, this._vertexShaderParts.varyingLines, n.vertexLines, i.vertexLines, this._vertexShaderParts.shaderLines).join(`
`), r = new Ue({ defines: this._vertexShaderParts.defineLines, sources: [o] }), s = this._fragmentShaderParts.uniformLines.concat(this._fragmentShaderParts.varyingLines, n.fragmentLines, i.fragmentLines, this._fragmentShaderParts.shaderLines).join(`
`), a = new Ue({ defines: this._fragmentShaderParts.defineLines, sources: [s] }); return qt.fromCache({ context: e, vertexShaderSource: r, fragmentShaderSource: a, attributeLocations: this._attributeLocations })
    }; sc.prototype.clone = function () { return tt(this, !0) }; function n3e(e) { let t = [], n = [], i, o = e._vertexShaderParts.structIds, r, s, a; for (i = 0; i < o.length; i++)r = o[i], s = e._structs[r], a = s.generateGlslLines(), t.push.apply(t, a); for (o = e._fragmentShaderParts.structIds, i = 0; i < o.length; i++)r = o[i], s = e._structs[r], a = s.generateGlslLines(), n.push.apply(n, a); return { vertexLines: t, fragmentLines: n } } function i3e(e) { switch (e) { case "mat2": return 2; case "mat3": return 3; case "mat4": return 4; default: return 1 } } function o3e(e) { let t = [], n = [], i, o = e._vertexShaderParts.functionIds, r, s, a; for (i = 0; i < o.length; i++)r = o[i], s = e._functions[r], a = s.generateGlslLines(), t.push.apply(t, a); for (o = e._fragmentShaderParts.functionIds, i = 0; i < o.length; i++)r = o[i], s = e._functions[r], a = s.generateGlslLines(), n.push.apply(n, a); return { vertexLines: t, fragmentLines: n } } var rL = sc; function r3e(e) { this.shaderBuilder = new rL, this.model = e, this.uniformMap = {}, this.alphaOptions = new nL, this.renderStateOptions = Ve.getState(Ve.fromCache({ depthTest: { enabled: !0, func: Ja.LESS_OR_EQUAL } })), this.hasSilhouette = !1, this.hasSkipLevelOfDetail = !1 } var sL = r3e; var aL = `void silhouetteStage(inout vec4 color) {
if(model_silhouettePass) {
color = czm_gammaCorrect(model_silhouetteColor);
}
}
`; var cL = `void silhouetteStage(in ProcessedAttributes attributes, inout vec4 positionClip) {
#ifdef HAS_NORMALS
if(model_silhouettePass) {
vec3 normal = normalize(czm_normal3D * attributes.normalMC);
normal.x *= czm_projection[0][0];
normal.y *= czm_projection[1][1];
positionClip.xy += normal.xy * positionClip.w * model_silhouetteSize * czm_pixelRatio / czm_viewport.z;
}
#endif
}
`; var lL = { name: "ModelSilhouettePipelineStage" }; lL.silhouettesLength = 0; lL.process = function (e, t, n) { l(t._silhouetteId) || (t._silhouetteId = ++lL.silhouettesLength); let i = e.shaderBuilder; i.addDefine("HAS_SILHOUETTE", void 0, Te.BOTH), i.addVertexLines(cL), i.addFragmentLines(aL), i.addUniform("vec4", "model_silhouetteColor", Te.FRAGMENT), i.addUniform("float", "model_silhouetteSize", Te.VERTEX), i.addUniform("bool", "model_silhouettePass", Te.BOTH); let o = { model_silhouetteColor: function () { return t.silhouetteColor }, model_silhouetteSize: function () { return t.silhouetteSize }, model_silhouettePass: function () { return !1 } }; e.uniformMap = yt(o, e.uniformMap), e.hasSilhouette = !0 }; var uL = lL; var fL = `void modelSplitterStage()
{
#ifndef SHADOW_MAP
if (model_splitDirection < 0.0 && gl_FragCoord.x > czm_splitPosition) discard;
if (model_splitDirection > 0.0 && gl_FragCoord.x < czm_splitPosition) discard;
#endif
}
`; var dL = { name: "ModelSplitterPipelineStage", SPLIT_DIRECTION_UNIFORM_NAME: "model_splitDirection" }; dL.process = function (e, t, n) { let i = e.shaderBuilder; i.addDefine("HAS_MODEL_SPLITTER", void 0, Te.FRAGMENT), i.addFragmentLines(fL); let o = {}; i.addUniform("float", dL.SPLIT_DIRECTION_UNIFORM_NAME, Te.FRAGMENT), o[dL.SPLIT_DIRECTION_UNIFORM_NAME] = function () { return t.splitDirection }, e.uniformMap = yt(o, e.uniformMap) }; var hL = dL; function s3e(e, t) { this.model = e.model, this.shaderBuilder = e.shaderBuilder.clone(), this.uniformMap = tt(e.uniformMap), this.alphaOptions = tt(e.alphaOptions), this.renderStateOptions = tt(e.renderStateOptions, !0), this.hasSilhouette = e.hasSilhouette, this.hasSkipLevelOfDetail = e.hasSkipLevelOfDetail, this.runtimeNode = t, this.attributes = [], this.attributeIndex = 1, this.featureIdVertexAttributeSetIndex = 0, this.instanceCount = 0 } var mL = s3e; function a3e(e) { e = y(e, y.EMPTY_OBJECT), this.lightingModel = y(e.lightingModel, Im.UNLIT) } var pL = a3e; function c3e(e, t) { this.model = e.model, this.runtimeNode = e.runtimeNode, this.attributes = e.attributes.slice(), this.attributeIndex = e.attributeIndex, this.featureIdVertexAttributeSetIndex = e.featureIdVertexAttributeSetIndex, this.uniformMap = tt(e.uniformMap), this.alphaOptions = tt(e.alphaOptions), this.renderStateOptions = tt(e.renderStateOptions, !0), this.hasSilhouette = e.hasSilhouette, this.hasSkipLevelOfDetail = e.hasSkipLevelOfDetail, this.shaderBuilder = e.shaderBuilder.clone(), this.instanceCount = e.instanceCount, this.runtimePrimitive = t; let n = t.primitive; this.count = l(n.indices) ? n.indices.count : tn.getAttributeBySemantic(n, "POSITION").count, this.hasPropertyTable = !1, this.indices = n.indices, this.wireframeIndexBuffer = void 0, this.primitiveType = n.primitiveType; let i = tn.getPositionMinMax(n, this.runtimeNode.instancingTranslationMin, this.runtimeNode.instancingTranslationMax); this.positionMin = h.clone(i.min, new h), this.positionMax = h.clone(i.max, new h), this.boundingSphere = re.fromCornerPoints(this.positionMin, this.positionMax, new re), this.lightingOptions = new pL, this.pickId = void 0 } var _L = c3e; function xl(e) { e = y(e, y.EMPTY_OBJECT); let t = e.modelComponents; this._model = e.model, this._components = t, this._pipelineStages = [], this._updateStages = [], this._runtimeNodes = [], this._rootNodes = [], this._skinnedNodes = [], this._runtimeSkins = [], this.modelPipelineStages = [], this._boundingSphere = void 0, this._boundingSphere2D = void 0, this._computedModelMatrix = F.clone(F.IDENTITY), this._computedModelMatrix2D = F.clone(F.IDENTITY), this._axisCorrectionMatrix = tn.getAxisCorrectionMatrix(t.upAxis, t.forwardAxis, new F), this._runtimeArticulations = {}, l3e(this) } Object.defineProperties(xl.prototype, { components: { get: function () { return this._components } }, computedModelMatrix: { get: function () { return this._computedModelMatrix } }, axisCorrectionMatrix: { get: function () { return this._axisCorrectionMatrix } }, boundingSphere: { get: function () { return this._boundingSphere } } }); function l3e(e) { let t = e._components, n = t.scene, o = e._model.modelMatrix; dte(e, o); let r = t.articulations, s = r.length, a = e._runtimeArticulations; for (let T = 0; T < s; T++) { let b = r[T], S = new aM({ articulation: b, sceneGraph: e }), D = S.name; a[D] = S } let c = t.nodes, u = c.length; e._runtimeNodes = new Array(u); let d = n.nodes.length, p = F.IDENTITY; for (let T = 0; T < d; T++) { let b = n.nodes[T], S = hte(e, b, p); e._rootNodes.push(S) } let g = t.skins, m = e._runtimeSkins, A = g.length; for (let T = 0; T < A; T++) { let b = g[T]; m.push(new tL({ skin: b, sceneGraph: e })) } let C = e._skinnedNodes, x = C.length; for (let T = 0; T < x; T++) { let b = C[T], S = e._runtimeNodes[b], P = c[b].skin.index; S._runtimeSkin = m[P], S.updateJointMatrices() } e.applyArticulations() } function dte(e, t) { let n = e._components, i = e._model; e._computedModelMatrix = F.multiplyTransformation(t, n.transform, e._computedModelMatrix), e._computedModelMatrix = F.multiplyTransformation(e._computedModelMatrix, e._axisCorrectionMatrix, e._computedModelMatrix), e._computedModelMatrix = F.multiplyByUniformScale(e._computedModelMatrix, i.computedScale, e._computedModelMatrix) } var u3e = new h; function f3e(e, t) { let n = e._computedModelMatrix, i = F.getTranslation(n, u3e); if (!h.equals(i, h.ZERO)) e._computedModelMatrix2D = It.basisTo2D(t.mapProjection, n, e._computedModelMatrix2D); else { let o = e.boundingSphere.center, r = It.wgs84To2DModelMatrix(t.mapProjection, o, e._computedModelMatrix2D); e._computedModelMatrix2D = F.multiply(r, n, e._computedModelMatrix2D) } e._boundingSphere2D = re.transform(e._boundingSphere, e._computedModelMatrix2D, e._boundingSphere2D) } function hte(e, t, n) { let i = [], o = tn.getNodeTransform(t), r = t.children.length; for (let f = 0; f < r; f++) { let d = t.children[f], p = F.multiplyTransformation(n, o, new F), g = hte(e, d, p); i.push(g) } let s = new AM({ node: t, transform: o, transformToRoot: n, children: i, sceneGraph: e }), a = t.primitives.length; for (let f = 0; f < a; f++)s.runtimePrimitives.push(new eL({ primitive: t.primitives[f], node: t, model: e._model })); let c = t.index; e._runtimeNodes[c] = s, l(t.skin) && e._skinnedNodes.push(c); let u = t.name; if (l(u)) { let f = e._model, d = new fM(f, s); f._nodesByName[u] = d } return c } var d3e = new h, h3e = new h, m3e = new h, p3e = new h; xl.prototype.buildDrawCommands = function (e) { let t = this._model, n = new sL(t); t.statistics.clear(), this.configurePipeline(e); let i = this.modelPipelineStages, o, r, s; for (o = 0; o < i.length; o++)i[o].process(n, t, e); let a = h.fromElements(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, d3e), c = h.fromElements(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, h3e); for (o = 0; o < this._runtimeNodes.length; o++) { let u = this._runtimeNodes[o]; if (!l(u)) continue; u.configurePipeline(); let f = u.pipelineStages, d = new mL(n, u); for (r = 0; r < f.length; r++)f[r].process(d, u.node, e); let p = u.computedTransform; for (r = 0; r < u.runtimePrimitives.length; r++) { let g = u.runtimePrimitives[r]; g.configurePipeline(e); let m = g.pipelineStages, A = new _L(d, g); for (s = 0; s < m.length; s++)m[s].process(A, g.primitive, e); g.boundingSphere = re.clone(A.boundingSphere, new re); let C = F.multiplyByPoint(p, A.positionMin, m3e), x = F.multiplyByPoint(p, A.positionMax, p3e); h.minimumByComponent(a, C, a), h.maximumByComponent(c, x, c); let T = tM(A, e); g.drawCommand = T } } this._boundingSphere = re.fromCornerPoints(a, c, new re), this._boundingSphere = re.transformWithoutScale(this._boundingSphere, this._axisCorrectionMatrix, this._boundingSphere), this._boundingSphere = re.transform(this._boundingSphere, this._components.transform, this._boundingSphere), t._boundingSphere = re.transform(this._boundingSphere, t.modelMatrix, t._boundingSphere), t._initialRadius = t._boundingSphere.radius, t._boundingSphere.radius *= t._clampedScale }; xl.prototype.configurePipeline = function (e) { let t = this.modelPipelineStages; t.length = 0; let n = this._model; l(n.color) && t.push(q0), !l(n.classificationType) && (n.imageBasedLighting.enabled && t.push(oM), n.isClippingEnabled() && t.push(uM), n.hasSilhouette(e) && t.push(uL), l(n.splitDirection) && n.splitDirection !== zc.NONE && t.push(hL), ar.is3DTiles(n.type) && t.push(nM)) }; xl.prototype.update = function (e, t) { let n, i, o; for (n = 0; n < this._runtimeNodes.length; n++) { let r = this._runtimeNodes[n]; if (!l(r)) continue; for (i = 0; i < r.updateStages.length; i++)r.updateStages[i].update(r, this, e); let s = e.mode !== ee.SCENE3D && this._model._projectTo2D; for (t && !s && this.updateJointMatrices(), i = 0; i < r.runtimePrimitives.length; i++) { let a = r.runtimePrimitives[i]; for (o = 0; o < a.updateStages.length; o++)a.updateStages[o].update(a, this) } } }; xl.prototype.updateModelMatrix = function (e, t) { dte(this, e), t.mode !== ee.SCENE3D && f3e(this, t); let n = this._rootNodes; for (let i = 0; i < n.length; i++) { let o = this._runtimeNodes[n[i]]; o._transformDirty = !0 } }; xl.prototype.updateJointMatrices = function () { let e = this._skinnedNodes, t = e.length; for (let n = 0; n < t; n++) { let i = e[n]; this._runtimeNodes[i].updateJointMatrices() } }; function mte(e, t, n, i, o) { if (n && !t.show) return; let r = t.children.length; for (let c = 0; c < r; c++) { let u = t.getChild(c); mte(e, u, n, i, o) } let s = t.runtimePrimitives, a = s.length; for (let c = 0; c < a; c++) { let u = s[c]; i(u, o) } } function gL(e, t, n, i) { let o = e._rootNodes, r = o.length; for (let s = 0; s < r; s++) { let a = o[s], c = e._runtimeNodes[a]; mte(e, c, t, n, i) } } var _3e = { backFaceCulling: void 0 }; xl.prototype.updateBackFaceCulling = function (e) { let t = _3e; t.backFaceCulling = e, gL(this, !1, g3e, t) }; function g3e(e, t) { let n = e.drawCommand; n.backFaceCulling = t.backFaceCulling } var y3e = { shadowMode: void 0 }; xl.prototype.updateShadows = function (e) { let t = y3e; t.shadowMode = e, gL(this, !1, A3e, t) }; function A3e(e, t) { let n = e.drawCommand; n.shadows = t.shadowMode } var C3e = { debugShowBoundingVolume: void 0 }; xl.prototype.updateShowBoundingVolume = function (e) { let t = C3e; t.debugShowBoundingVolume = e, gL(this, !1, x3e, t) }; function x3e(e, t) { let n = e.drawCommand; n.debugShowBoundingVolume = t.debugShowBoundingVolume } var pte = [], T3e = { frameState: void 0, hasSilhouette: void 0 }; xl.prototype.pushDrawCommands = function (e) { let t = pte; t.length = 0; let n = T3e; n.hasSilhouette = this._model.hasSilhouette(e), n.frameState = e, gL(this, !0, E3e, n), e.commandList.push.apply(e.commandList, t) }; function E3e(e, t) { let n = t.frameState, i = t.hasSilhouette, o = n.passes, r = pte, s = e.drawCommand; s.pushCommands(n, n.commandList), i && !o.pick && s.pushSilhouetteCommands(n, r) } xl.prototype.setArticulationStage = function (e, t) { let n = e.split(" "); if (n.length !== 2) return; let i = n[0], o = n[1], r = this._runtimeArticulations[i]; l(r) && r.setArticulationStage(o, t) }; xl.prototype.applyArticulations = function () { let e = this._runtimeArticulations; for (let t in e) e.hasOwnProperty(t) && e[t].apply() }; var yL = xl; function mx() { this.pointsLength = 0, this.trianglesLength = 0, this.geometryByteLength = 0, this.texturesByteLength = 0, this.propertyTablesByteLength = 0, this._bufferIdSet = {}, this._textureIdSet = {}, this._batchTextureIdMap = new Ct } Object.defineProperties(mx.prototype, { batchTexturesByteLength: { get: function () { let e = this._batchTextureIdMap.length, t = this._batchTextureIdMap.values, n = 0; for (let i = 0; i < e; i++)n += t[i].byteLength; return n } } }); mx.prototype.clear = function () { this.pointsLength = 0, this.trianglesLength = 0, this.geometryByteLength = 0, this.texturesByteLength = 0, this.propertyTablesByteLength = 0, this._bufferIdSet = {}, this._textureIdSet = {}, this._batchTextureIdMap.removeAll() }; mx.prototype.addBuffer = function (e, t) { if (!this._bufferIdSet.hasOwnProperty(e._id)) { let n = t ? 2 : 1; this.geometryByteLength += e.sizeInBytes * n } this._bufferIdSet[e._id] = !0 }; mx.prototype.addTexture = function (e) { this._textureIdSet.hasOwnProperty(e._id) || (this.texturesByteLength += e.sizeInBytes), this._textureIdSet[e._id] = !0 }; mx.prototype.addBatchTexture = function (e) { this._batchTextureIdMap.contains(e._id) || this._batchTextureIdMap.set(e._id, e) }; var AL = mx; var Ate = po(eP(), 1); var _te = {}, Z0 = Uint32Array.BYTES_PER_ELEMENT; _te.parse = function (e, t) { t = y(t, 0); let n = new Uint8Array(e), i = new DataView(e); t += Z0; let o = i.getUint32(t, !0); if (o !== 1) throw new fe(`Only Point Cloud tile version 1 is supported.  Version ${o} is not.`); t += Z0, t += Z0; let r = i.getUint32(t, !0); if (r === 0) throw new fe("Feature table must have a byte length greater than zero"); t += Z0; let s = i.getUint32(t, !0); t += Z0; let a = i.getUint32(t, !0); t += Z0; let c = i.getUint32(t, !0); t += Z0; let u = Ko(n, t, r); t += r; let f = new Uint8Array(e, t, s); t += s; let d, p; a > 0 && (d = Ko(n, t, a), t += a, c > 0 && (p = new Uint8Array(e, t, c), t += c)); let g = new Yd(u, f), m = g.getGlobalProperty("POINTS_LENGTH"); if (g.featuresLength = m, !l(m)) throw new fe("Feature table global property: POINTS_LENGTH must be defined"); let A = g.getGlobalProperty("RTC_CENTER", Y.FLOAT, 3); l(A) && (A = h.unpack(A)); let C = b3e(g, d); if (C.rtcCenter = A, C.pointsLength = m, !C.hasPositions) { let x = S3e(g); C.positions = x, C.hasPositions = C.hasPositions || l(x) } if (!C.hasPositions) throw new fe("Either POSITION or POSITION_QUANTIZED must be defined."); if (!C.hasNormals) { let x = D3e(g); C.normals = x, C.hasNormals = C.hasNormals || l(x) } if (!C.hasColors) { let x = w3e(g); C.colors = x, C.hasColors = C.hasColors || l(x), C.hasConstantColor = l(C.constantColor), C.isTranslucent = l(x) && x.isTranslucent } if (!C.hasBatchIds) { let x = v3e(g); C.batchIds = x, C.hasBatchIds = C.hasBatchIds || l(x) } if (C.hasBatchIds) { let x = g.getGlobalProperty("BATCH_LENGTH"); if (!l(x)) throw new fe("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined."); C.batchLength = x } return l(p) && (p = new Uint8Array(p), C.batchTableJson = d, C.batchTableBinary = p), C }; function b3e(e, t) { let n = e.json, i, o, r, s = l(n.extensions) ? n.extensions["3DTILES_draco_point_compression"] : void 0, a = l(t) && l(t.extensions) ? t.extensions["3DTILES_draco_point_compression"] : void 0; l(a) && (r = a.properties); let c, u, f, d, p; if (l(s)) { o = s.properties; let m = s.byteOffset, A = s.byteLength; if (!l(o) || !l(m) || !l(A)) throw new fe("Draco properties, byteOffset, and byteLength must be defined"); i = e.buffer.slice(m, m + A), c = l(o.POSITION), u = l(o.RGB) || l(o.RGBA), f = l(o.NORMAL), d = l(o.BATCH_ID), p = l(o.RGBA) } let g; return l(i) && (g = { buffer: i, featureTableProperties: o, batchTableProperties: r, properties: yt(o, r), dequantizeInShader: !0 }), { draco: g, hasPositions: c, hasColors: u, isTranslucent: p, hasNormals: f, hasBatchIds: d } } function S3e(e) { let t = e.json, n; if (l(t.POSITION)) return n = e.getPropertyArray("POSITION", Y.FLOAT, 3), { name: xt.POSITION, semantic: xt.POSITION, typedArray: n, isQuantized: !1, componentDatatype: Y.FLOAT, type: en.VEC3 }; if (l(t.POSITION_QUANTIZED)) { n = e.getPropertyArray("POSITION_QUANTIZED", Y.UNSIGNED_SHORT, 3); let i = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", Y.FLOAT, 3); if (!l(i)) throw new fe("Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions."); let o = (1 << 16) - 1, r = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", Y.FLOAT, 3); if (!l(r)) throw new fe("Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions."); return { name: xt.POSITION, semantic: xt.POSITION, typedArray: n, isQuantized: !0, componentDatatype: Y.FLOAT, type: en.VEC3, quantizedRange: o, quantizedVolumeOffset: h.unpack(r), quantizedVolumeScale: h.unpack(i), quantizedComponentDatatype: Y.UNSIGNED_SHORT, quantizedType: en.VEC3 } } } function w3e(e) { let t = e.json, n; if (l(t.RGBA)) return n = e.getPropertyArray("RGBA", Y.UNSIGNED_BYTE, 4), { name: xt.COLOR, semantic: xt.COLOR, setIndex: 0, typedArray: n, componentDatatype: Y.UNSIGNED_BYTE, type: en.VEC4, normalized: !0, isRGB565: !1, isTranslucent: !0 }; if (l(t.RGB)) return n = e.getPropertyArray("RGB", Y.UNSIGNED_BYTE, 3), { name: "COLOR", semantic: xt.COLOR, setIndex: 0, typedArray: n, componentDatatype: Y.UNSIGNED_BYTE, type: en.VEC3, normalized: !0, isRGB565: !1, isTranslucent: !1 }; if (l(t.RGB565)) return n = e.getPropertyArray("RGB565", Y.UNSIGNED_SHORT, 1), { name: "COLOR", semantic: xt.COLOR, setIndex: 0, typedArray: n, componentDatatype: Y.FLOAT, type: en.VEC3, normalized: !1, isRGB565: !0, isTranslucent: !1 }; if (l(t.CONSTANT_RGBA)) { let i = e.getGlobalProperty("CONSTANT_RGBA", Y.UNSIGNED_BYTE, 4), o = i[3], r = U.fromBytes(i[0], i[1], i[2], o), s = o < 255; return { name: xt.COLOR, semantic: xt.COLOR, setIndex: 0, constantColor: r, componentDatatype: Y.FLOAT, type: en.VEC4, isQuantized: !1, isTranslucent: s } } } function D3e(e) { let t = e.json, n; if (l(t.NORMAL)) return n = e.getPropertyArray("NORMAL", Y.FLOAT, 3), { name: xt.NORMAL, semantic: xt.NORMAL, typedArray: n, octEncoded: !1, octEncodedZXY: !1, componentDatatype: Y.FLOAT, type: en.VEC3 }; if (l(t.NORMAL_OCT16P)) { n = e.getPropertyArray("NORMAL_OCT16P", Y.UNSIGNED_BYTE, 2); let i = 8; return { name: xt.NORMAL, semantic: xt.NORMAL, typedArray: n, octEncoded: !0, octEncodedZXY: !1, quantizedRange: (1 << i) - 1, quantizedType: en.VEC2, quantizedComponentDatatype: Y.UNSIGNED_BYTE, componentDatatype: Y.FLOAT, type: en.VEC3 } } } function v3e(e) { let t = e.json; if (l(t.BATCH_ID)) { let n = e.getPropertyArray("BATCH_ID", Y.UNSIGNED_SHORT, 1); return { name: xt.FEATURE_ID, semantic: xt.FEATURE_ID, setIndex: 0, typedArray: n, componentDatatype: Y.fromTypedArray(n), type: en.SCALAR } } } var px = _te; var P3e = Dt.Components, I3e = Dt.Scene, O3e = Dt.Node, B3e = Dt.Primitive, R3e = Dt.Attribute, gte = Dt.Quantization, M3e = Dt.FeatureIdAttribute, L3e = Dt.Material, F3e = Dt.MetallicRoughness; function T_(e) { e = y(e, y.EMPTY_OBJECT); let t = e.arrayBuffer, n = y(e.byteOffset, 0); this._arrayBuffer = t, this._byteOffset = n, this._loadAttributesFor2D = y(e.loadAttributesFor2D, !1), this._parsedContent = void 0, this._decodePromise = void 0, this._decodedAttributes = void 0, this._promise = void 0, this._process = function (i) { }, this._state = kt.UNLOADED, this._buffers = [], this._components = void 0, this._transform = F.IDENTITY } l(Object.create) && (T_.prototype = Object.create(Zi.prototype), T_.prototype.constructor = T_); Object.defineProperties(T_.prototype, { promise: { get: function () { return this._promise } }, cacheKey: { get: function () { } }, components: { get: function () { return this._components } }, transform: { get: function () { return this._transform } } }); T_.prototype.load = function () { this._parsedContent = px.parse(this._arrayBuffer, this._byteOffset), this._state = kt.PROCESSING; let e = this; this._promise = new Promise(function (t, n) { e._process = function (i) { if (e._state === kt.PROCESSING) { if (l(e._decodePromise)) return; let o = N3e(e, i.context); l(o) && o.then(t).catch(n) } } }) }; T_.prototype.process = function (e) { this._process(e) }; function N3e(e, t) { let i = e._parsedContent.draco, o; if (l(i) ? o = i_.decodePointCloud(i, t) : o = Promise.resolve(), !!l(o)) return e._decodePromise = o, o.then(function (r) { if (!e.isDestroyed()) return l(r) && V3e(e, i, r), K3e(e, t), e._state = kt.READY, e }).catch(function (r) { e.unload(), e._state = kt.FAILED; let s = "Failed to load Draco pnts"; return Promise.reject(e.getError(s, r)) }) } function V3e(e, t, n) { e._state = kt.READY; let i = e._parsedContent, o; if (l(n.POSITION)) { if (o = { name: "POSITION", semantic: xt.POSITION, typedArray: n.POSITION.array, componentDatatype: Y.FLOAT, type: en.VEC3, isQuantized: !1 }, l(n.POSITION.data.quantization)) { let a = n.POSITION.data.quantization, c = a.range, u = h.fromElements(c, c, c), f = h.unpack(a.minValues), d = (1 << a.quantizationBits) - 1; o.isQuantized = !0, o.quantizedRange = d, o.quantizedVolumeOffset = f, o.quantizedVolumeScale = u, o.quantizedComponentDatatype = d <= 255 ? Y.UNSIGNED_BYTE : Y.UNSIGNED_SHORT, o.quantizedType = en.VEC3 } i.positions = o } if (l(n.NORMAL)) { if (o = { name: "NORMAL", semantic: xt.NORMAL, typedArray: n.NORMAL.array, componentDatatype: Y.FLOAT, type: en.VEC3, isQuantized: !1, octEncoded: !1, octEncodedZXY: !1 }, l(n.NORMAL.data.quantization)) { let a = (1 << n.NORMAL.data.quantization.quantizationBits) - 1; o.quantizedRange = a, o.octEncoded = !0, o.octEncodedZXY = !0, o.quantizedComponentDatatype = Y.UNSIGNED_BYTE, o.quantizedType = en.VEC2 } i.normals = o } if (l(n.RGBA) ? i.colors = { name: "COLOR", semantic: xt.COLOR, setIndex: 0, typedArray: n.RGBA.array, componentDatatype: Y.UNSIGNED_BYTE, type: en.VEC4, normalized: !0, isTranslucent: !0 } : l(n.RGB) && (i.colors = { name: "COLOR", semantic: xt.COLOR, setIndex: 0, typedArray: n.RGB.array, componentDatatype: Y.UNSIGNED_BYTE, type: en.VEC3, normalized: !0, isTranslucent: !1 }), l(n.BATCH_ID)) { let a = n.BATCH_ID.array; i.batchIds = { name: "_FEATURE_ID", semantic: xt.FEATURE_ID, setIndex: 0, typedArray: a, componentDatatype: Y.fromTypedArray(a), type: en.SCALAR } } let r = i.batchTableJson, s = t.batchTableProperties; for (let a in s) if (s.hasOwnProperty(a)) { let c = n[a]; l(r) || (r = {}), i.hasDracoBatchTable = !0; let u = c.data; r[a] = { byteOffset: u.byteOffset, type: k3e(u.componentsPerAttribute), componentType: U3e(u.componentDatatype), typedArray: c.array } } i.batchTableJson = r } function k3e(e) { switch (e) { case 1: return "SCALAR"; case 2: return "VEC2"; case 3: return "VEC3"; case 4: return "VEC4" } } function U3e(e) { switch (e) { case te.BYTE: return "BYTE"; case te.UNSIGNED_BYTE: return "UNSIGNED_BYTE"; case te.SHORT: return "SHORT"; case te.UNSIGNED_SHORT: return "UNSIGNED_SHORT"; case te.INT: return "INT"; case te.UNSIGNED_INT: return "UNSIGNED_INT"; case te.DOUBLE: return "DOUBLE"; case te.FLOAT: return "FLOAT" } } function FS(e, t, n) { let i = t.typedArray, o; if (t.octEncoded && (o = new gte, o.octEncoded = t.octEncoded, o.octEncodedZXY = t.octEncodedZXY, o.normalizationRange = t.quantizedRange, o.type = t.quantizedType, o.componentDatatype = t.quantizedComponentDatatype), t.isQuantized) { o = new gte; let a = t.quantizedRange; o.normalizationRange = a, o.quantizedVolumeOffset = h.ZERO; let c = t.quantizedVolumeScale; o.quantizedVolumeDimensions = c, o.quantizedVolumeStepSize = h.divideByScalar(c, a, new h), o.componentDatatype = t.quantizedComponentDatatype, o.type = t.quantizedType } let r = new R3e; if (r.name = t.name, r.semantic = t.semantic, r.setIndex = t.setIndex, r.componentDatatype = t.componentDatatype, r.type = t.type, r.normalized = y(t.normalized, !1), r.min = t.min, r.max = t.max, r.quantization = o, t.isRGB565 && (i = kn.decodeRGB565(i)), l(t.constantColor)) { let a = new Array(4); r.constant = U.pack(t.constantColor, a) } else { let a = ct.createVertexBuffer({ typedArray: i, context: n, usage: Re.STATIC_DRAW }); a.vertexArrayDestroyable = !1, e._buffers.push(a), r.buffer = a } let s = e._loadAttributesFor2D; return r.semantic === xt.POSITION && s && (r.typedArray = i), r } var yte, CL; function z3e(e) { if (!l(CL)) { yte = new Ate.default(0), CL = new Array(e); for (let t = 0; t < e; ++t)CL[t] = yte.random() } return CL } var H3e = new h, G3e = new h, W3e = new h; function j3e(e) { let t = e.typedArray, n = 20, i = t.length / 3, o = Math.min(i, n), r = z3e(n), s = Number.MAX_VALUE, a = -Number.MAX_VALUE, c = h.fromElements(s, s, s, H3e), u = h.fromElements(a, a, a, G3e), f, d, p; if (e.isQuantized) c = h.ZERO, u = e.quantizedVolumeScale; else for (f = 0; f < o; ++f)d = Math.floor(r[f] * i), p = h.unpack(t, d * 3, W3e), h.minimumByComponent(c, p, c), h.maximumByComponent(u, p, u); e.min = h.clone(c), e.max = h.clone(u) } var q3e = { name: xt.COLOR, semantic: xt.COLOR, setIndex: 0, constantColor: U.DARKGRAY, componentDatatype: Y.FLOAT, type: en.VEC4, isQuantized: !1, isTranslucent: !1 }; function Y3e(e, t, n) { let i = [], o, r = t.positions; return l(r) && (j3e(r), o = FS(e, r, n), o.count = t.pointsLength, i.push(o)), l(t.normals) && (o = FS(e, t.normals, n), i.push(o)), l(t.colors) ? (o = FS(e, t.colors, n), i.push(o)) : (o = FS(e, q3e, n), i.push(o)), l(t.batchIds) && (o = FS(e, t.batchIds, n), i.push(o)), i } function X3e(e, t) { let n = e.batchLength, i = e.pointsLength, o = e.batchTableBinary, r = !l(e.batchIds); if (l(o) || e.hasDracoBatchTable) { let s = y(n, i); return p_({ count: s, batchTable: e.batchTableJson, binaryBody: o, parseAsPropertyAttributes: r, customAttributeOutput: t }) } return new ba({ schema: {}, propertyTables: [] }) } function K3e(e, t) { let n = e._parsedContent, i = new F3e; i.metallicFactor = 0, i.roughnessFactor = .9; let o = new L3e; o.metallicRoughness = i; let r = n.colors; l(r) && r.isTranslucent && (o.alphaMode = xm.BLEND); let s = !l(n.normals); o.unlit = s; let a = new B3e; if (a.attributes = Y3e(e, n, t), a.primitiveType = Oe.POINTS, a.material = o, l(n.batchIds)) { let g = new M3e; g.propertyTableId = 0, g.setIndex = 0, g.positionalLabel = "featureId_0", a.featureIds.push(g) } let c = new O3e; c.index = 0, c.primitives = [a]; let u = new I3e; u.nodes = [c], u.upAxis = Do.Z, u.forwardAxis = Do.X; let f = new P3e; f.scene = u, f.nodes = [c]; let d = []; f.structuralMetadata = X3e(n, d), d.length > 0 && J3e(e, a, d, t), l(n.rtcCenter) && (f.transform = F.multiplyByTranslation(f.transform, n.rtcCenter, f.transform)); let p = n.positions; l(p) && p.isQuantized && (f.transform = F.multiplyByTranslation(f.transform, p.quantizedVolumeOffset, f.transform)), e._components = f, e._parsedContent = void 0, e._arrayBuffer = void 0 } function J3e(e, t, n, i) { let o = t.attributes, r = n.length; for (let s = 0; s < r; s++) { let a = n[s], c = ct.createVertexBuffer({ typedArray: a.typedArray, context: i, usage: Re.STATIC_DRAW }); c.vertexArrayDestroyable = !1, e._buffers.push(c), a.buffer = c, a.typedArray = void 0, o.push(a) } t.propertyAttributeIds = [0] } T_.prototype.unload = function () { let e = this._buffers; for (let t = 0; t < e.length; t++)e[t].destroy(); e.length = 0, this._components = void 0, this._parsedContent = void 0, this._arrayBuffer = void 0 }; var xL = T_; function go(e) { e = y(e, y.EMPTY_OBJECT), this._loader = e.loader, this._resource = e.resource, this.type = y(e.type, ar.GLTF), this.modelMatrix = F.clone(y(e.modelMatrix, F.IDENTITY)), this._modelMatrix = F.clone(this.modelMatrix), this._scale = y(e.scale, 1), this._minimumPixelSize = y(e.minimumPixelSize, 0), this._maximumScale = e.maximumScale, this._clampedScale = l(this._maximumScale) ? Math.min(this._scale, this._maximumScale) : this._scale, this._computedScale = this._clampedScale, this._updateModelMatrix = !1, this.referenceMatrix = void 0, this._iblReferenceFrameMatrix = Q.clone(Q.IDENTITY), this._resourcesLoaded = !1, this._drawCommandsBuilt = !1, this._ready = !1, this._customShader = e.customShader, this._content = e.content, this._texturesLoaded = !1, this._defaultTexture = void 0, this._activeAnimations = new YR(this), this._clampAnimations = y(e.clampAnimations, !0), this._userAnimationDirty = !1, this._id = e.id, this._idDirty = !1, this._color = U.clone(e.color), this._colorBlendMode = y(e.colorBlendMode, oc.HIGHLIGHT), this._colorBlendAmount = y(e.colorBlendAmount, .5); let t = y(e.silhouetteColor, U.RED); this._silhouetteColor = U.clone(t), this._silhouetteSize = y(e.silhouetteSize, 0), this._silhouetteDirty = !1, this._silhouetteId = void 0, this._cull = y(e.cull, !0), this._opaquePass = y(e.opaquePass, xe.OPAQUE), this._allowPicking = y(e.allowPicking, !0), this._show = y(e.show, !0), this._style = void 0, this._styleDirty = !1, this._styleCommandsNeeded = void 0; let n = y(e.featureIdLabel, "featureId_0"); typeof n == "number" && (n = `featureId_${n}`), this._featureIdLabel = n; let i = y(e.instanceFeatureIdLabel, "instanceFeatureId_0"); typeof i == "number" && (i = `instanceFeatureId_${i}`), this._instanceFeatureIdLabel = i, this._featureTables = [], this._featureTableId = void 0, this._featureTableIdDirty = !0, this._pipelineResources = [], this._modelResources = [], this._pickIds = [], this._boundingSphere = new re, this._initialRadius = void 0, this._heightReference = y(e.heightReference, ze.NONE), this._heightDirty = this._heightReference !== ze.NONE, this._removeUpdateHeightCallback = void 0, this._clampedModelMatrix = void 0; let o = e.scene; l(o) && l(o.terrainProviderChanged) && (this._terrainProviderChangedCallback = o.terrainProviderChanged.addEventListener(function () { this._heightDirty = !0 }, this)), this._scene = o, this._distanceDisplayCondition = e.distanceDisplayCondition; let r = new bm(e.pointCloudShading); this._pointCloudShading = r, this._attenuation = r.attenuation, this._pointCloudBackFaceCulling = r.backFaceCulling; let s = e.clippingPlanes; l(s) && s.owner === void 0 ? Ks.setOwner(s, this, "_clippingPlanes") : this._clippingPlanes = s, this._clippingPlanesState = 0, this._clippingPlanesMatrix = F.clone(F.IDENTITY), this._lightColor = h.clone(e.lightColor), this._imageBasedLighting = l(e.imageBasedLighting) ? e.imageBasedLighting : new VC, this._shouldDestroyImageBasedLighting = !l(e.imageBasedLighting), this._backFaceCulling = y(e.backFaceCulling, !0), this._backFaceCullingDirty = !1, this._shadows = y(e.shadows, hn.ENABLED), this._shadowsDirty = !1, this._debugShowBoundingVolumeDirty = !1, this._debugShowBoundingVolume = y(e.debugShowBoundingVolume, !1), this._enableDebugWireframe = y(e.enableDebugWireframe, !1), this._enableShowOutline = y(e.enableShowOutline, !0), this._debugWireframe = y(e.debugWireframe, !1), this._debugWireframe === !0 && this._enableDebugWireframe === !1 && this.type === ar.GLTF && Pt("model-debug-wireframe-ignored", "enableDebugWireframe must be set to true in Model.fromGltf, otherwise debugWireframe will be ignored."); let a = e.credit; typeof a == "string" && (a = new Xt(a)), this._credit = a, this._resourceCredits = [], this._gltfCredits = [], this._showCreditsOnScreen = y(e.showCreditsOnScreen, !1), this._showCreditsOnScreenDirty = !0, this._splitDirection = y(e.splitDirection, zc.NONE), this._enableShowOutline = y(e.enableShowOutline, !0), this.showOutline = y(e.showOutline, !0), this.outlineColor = y(e.outlineColor, U.BLACK), this._classificationType = e.classificationType, this._statistics = new AL, this._sceneMode = void 0, this._projectTo2D = y(e.projectTo2D, !1), this._skipLevelOfDetail = !1, this._ignoreCommands = y(e.ignoreCommands, !1), this._completeLoad = function (c, u) { }, this._texturesLoadedPromise = void 0, this._readyPromise = $3e(this), this._sceneGraph = void 0, this._nodesByName = {}, this.pickObject = e.pickObject } function Z3e(e, t) { let n = e._featureTables, i = t.propertyTables, o = i.length; for (let r = 0; r < o; r++) { let s = i[r], a = new KR({ model: e, propertyTable: s }); n.push(a) } return n } function Q3e(e, t) { let n = t._featureIdLabel, i = t._instanceFeatureIdLabel, o, r, s, a; for (o = 0; o < e.nodes.length; o++)if (a = e.nodes[o], l(a.instances) && (s = tn.getFeatureIdsByLabel(a.instances.featureIds, i), l(s) && l(s.propertyTableId))) return s.propertyTableId; for (o = 0; o < e.nodes.length; o++)for (a = e.nodes[o], r = 0; r < a.primitives.length; r++) { let c = a.primitives[r], u = tn.getFeatureIdsByLabel(c.featureIds, n); if (l(u)) return u.propertyTableId } if (t._featureTables.length === 1) return 0 } function W8(e, t) { if (!l(e) && !l(t)) return !1; if (l(e) !== l(t)) return !0; let n = e.alpha, i = t.alpha; return Math.floor(n) !== Math.floor(i) || Math.ceil(n) !== Math.ceil(i) } function $3e(e) { let t = e._loader, n = e._resource; t.load(); let i = t.promise.then(function (s) { if (!l(s)) return; let a = s.components; if (!l(a)) { if (s.isUnloaded()) return; throw new fe("Failed to load model.") } let c = a.structuralMetadata; l(c) && c.propertyTableCount > 0 && Z3e(e, c); let u = new yL({ model: e, modelComponents: a }); e._sceneGraph = u, e._gltfCredits = u.components.asset.credits; let f = e._resource.credits; if (l(f)) { let d = f.length; for (let p = 0; p < d; p++)e._resourceCredits.push(f[p]) } e._resourcesLoaded = !0 }), o = y(t.texturesLoadedPromise, Promise.resolve()); e._texturesLoadedPromise = o.then(function () { !l(e) || e.isDestroyed() || (e._texturesLoaded = !0, t._incrementallyLoadTextures && e.resetDrawCommands()) }).catch(tn.getFailedLoadFunction(e, "model", n)); let r = new Promise(function (s, a) { e._completeLoad = function (c, u) { u.afterRender.push(function () { c._ready = !0, s(c) }) } }); return i.then(function () { return r }).catch(tn.getFailedLoadFunction(e, "model", n)) } Object.defineProperties(go.prototype, { ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } }, texturesLoadedPromise: { get: function () { return this._texturesLoadedPromise } }, loader: { get: function () { return this._loader } }, statistics: { get: function () { return this._statistics } }, activeAnimations: { get: function () { return this._activeAnimations } }, clampAnimations: { get: function () { return this._clampAnimations }, set: function (e) { this._clampAnimations = e } }, cull: { get: function () { return this._cull } }, opaquePass: { get: function () { return this._opaquePass } }, pointCloudShading: { get: function () { return this._pointCloudShading }, set: function (e) { e !== this._pointCloudShading && this.resetDrawCommands(), this._pointCloudShading = e } }, customShader: { get: function () { return this._customShader }, set: function (e) { e !== this._customShader && this.resetDrawCommands(), this._customShader = e } }, sceneGraph: { get: function () { return this._sceneGraph } }, content: { get: function () { return this._content } }, heightReference: { get: function () { return this._heightReference }, set: function (e) { e !== this._heightReference && (this._heightDirty = !0), this._heightReference = e } }, distanceDisplayCondition: { get: function () { return this._distanceDisplayCondition }, set: function (e) { this._distanceDisplayCondition = bt.clone(e, this._distanceDisplayCondition) } }, structuralMetadata: { get: function () { return this._sceneGraph.components.structuralMetadata } }, featureTableId: { get: function () { return this._featureTableId }, set: function (e) { this._featureTableId = e } }, featureTables: { get: function () { return this._featureTables }, set: function (e) { this._featureTables = e } }, id: { get: function () { return this._id }, set: function (e) { e !== this._id && (this._idDirty = !0), this._id = e } }, allowPicking: { get: function () { return this._allowPicking } }, style: { get: function () { return this._style }, set: function (e) { this._style = e, this._styleDirty = !0 } }, color: { get: function () { return this._color }, set: function (e) { W8(e, this._color) && this.resetDrawCommands(), this._color = U.clone(e, this._color) } }, colorBlendMode: { get: function () { return this._colorBlendMode }, set: function (e) { this._colorBlendMode = e } }, colorBlendAmount: { get: function () { return this._colorBlendAmount }, set: function (e) { this._colorBlendAmount = e } }, silhouetteColor: { get: function () { return this._silhouetteColor }, set: function (e) { if (!U.equals(e, this._silhouetteColor)) { let t = W8(e, this._silhouetteColor); this._silhouetteDirty = this._silhouetteDirty || t } this._silhouetteColor = U.clone(e, this._silhouetteColor) } }, silhouetteSize: { get: function () { return this._silhouetteSize }, set: function (e) { if (e !== this._silhouetteSize) { let t = this._silhouetteSize, n = e > 0 && t === 0 || e === 0 && t > 0; this._silhouetteDirty = this._silhouetteDirty || n, this._backFaceCullingDirty = this._backFaceCullingDirty || n } this._silhouetteSize = e } }, boundingSphere: { get: function () { let e = l(this._clampedModelMatrix) ? this._clampedModelMatrix : this.modelMatrix; return Tte(this, e), this._boundingSphere } }, debugShowBoundingVolume: { get: function () { return this._debugShowBoundingVolume }, set: function (e) { this._debugShowBoundingVolume !== e && (this._debugShowBoundingVolumeDirty = !0), this._debugShowBoundingVolume = e } }, debugWireframe: { get: function () { return this._debugWireframe }, set: function (e) { this._debugWireframe !== e && this.resetDrawCommands(), this._debugWireframe = e, this._debugWireframe === !0 && this._enableDebugWireframe === !1 && this.type === ar.GLTF && Pt("model-debug-wireframe-ignored", "enableDebugWireframe must be set to true in Model.fromGltf, otherwise debugWireframe will be ignored.") } }, show: { get: function () { return this._show }, set: function (e) { this._show = e } }, featureIdLabel: { get: function () { return this._featureIdLabel }, set: function (e) { typeof e == "number" && (e = `featureId_${e}`), e !== this._featureIdLabel && (this._featureTableIdDirty = !0), this._featureIdLabel = e } }, instanceFeatureIdLabel: { get: function () { return this._instanceFeatureIdLabel }, set: function (e) { typeof e == "number" && (e = `instanceFeatureId_${e}`), e !== this._instanceFeatureIdLabel && (this._featureTableIdDirty = !0), this._instanceFeatureIdLabel = e } }, clippingPlanes: { get: function () { return this._clippingPlanes }, set: function (e) { e !== this._clippingPlanes && (Ks.setOwner(e, this, "_clippingPlanes"), this.resetDrawCommands()) } }, lightColor: { get: function () { return this._lightColor }, set: function (e) { l(e) !== l(this._lightColor) && this.resetDrawCommands(), this._lightColor = h.clone(e, this._lightColor) } }, imageBasedLighting: { get: function () { return this._imageBasedLighting }, set: function (e) { e !== this._imageBasedLighting && (this._shouldDestroyImageBasedLighting && !this._imageBasedLighting.isDestroyed() && this._imageBasedLighting.destroy(), this._imageBasedLighting = e, this._shouldDestroyImageBasedLighting = !1, this.resetDrawCommands()) } }, backFaceCulling: { get: function () { return this._backFaceCulling }, set: function (e) { e !== this._backFaceCulling && (this._backFaceCullingDirty = !0), this._backFaceCulling = e } }, scale: { get: function () { return this._scale }, set: function (e) { e !== this._scale && (this._updateModelMatrix = !0), this._scale = e } }, computedScale: { get: function () { return this._computedScale } }, minimumPixelSize: { get: function () { return this._minimumPixelSize }, set: function (e) { e !== this._minimumPixelSize && (this._updateModelMatrix = !0), this._minimumPixelSize = e } }, maximumScale: { get: function () { return this._maximumScale }, set: function (e) { e !== this._maximumScale && (this._updateModelMatrix = !0), this._maximumScale = e } }, shadows: { get: function () { return this._shadows }, set: function (e) { e !== this._shadows && (this._shadowsDirty = !0), this._shadows = e } }, credit: { get: function () { return this._credit } }, showCreditsOnScreen: { get: function () { return this._showCreditsOnScreen }, set: function (e) { this._showCreditsOnScreen !== e && (this._showCreditsOnScreenDirty = !0), this._showCreditsOnScreen = e } }, splitDirection: { get: function () { return this._splitDirection }, set: function (e) { this._splitDirection !== e && this.resetDrawCommands(), this._splitDirection = e } }, classificationType: { get: function () { return this._classificationType } }, pickIds: { get: function () { return this._pickIds } }, styleCommandsNeeded: { get: function () { return this._styleCommandsNeeded } } }); go.prototype.getNode = function (e) { return this._nodesByName[e] }; go.prototype.setArticulationStage = function (e, t) { this._sceneGraph.setArticulationStage(e, t) }; go.prototype.applyArticulations = function () { this._sceneGraph.applyArticulations() }; go.prototype.makeStyleDirty = function () { this._styleDirty = !0 }; go.prototype.resetDrawCommands = function () { this._drawCommandsBuilt = !1 }; var eVe = new F, tVe = new Q, nVe = new F; go.prototype.update = function (e) { if (iVe(this, e), oVe(this, e), rVe(this, e), !this._resourcesLoaded || e.mode === ee.MORPHING) return; sVe(this), aVe(this), cVe(this, e), lVe(this), uVe(this, e), fVe(this, e), dVe(this, e), hVe(this, e), this._defaultTexture = e.context.defaultTexture, mVe(this, e), pVe(this, e), _Ve(this), gVe(this, e), CVe(this, e); let t = this; if (!t._ready) { t._completeLoad(t, e); return } AVe(this), xVe(this, e), TVe(this), EVe(this, e) }; function iVe(e, t) { (!e._resourcesLoaded || !e._texturesLoaded) && e._loader.process(t) } function oVe(e, t) { l(e._customShader) && e._customShader.update(t) } function rVe(e, t) { e._imageBasedLighting.update(t), e._imageBasedLighting.shouldRegenerateShaders && e.resetDrawCommands() } function sVe(e) { if (!e._featureTableIdDirty) return; e._featureTableIdDirty = !1; let t = e._sceneGraph.components, n = t.structuralMetadata; l(n) && n.propertyTableCount > 0 && (e.featureTableId = Q3e(t, e), e._styleDirty = !0, e.resetDrawCommands()) } function aVe(e) { e._styleDirty && (e.applyStyle(e._style), e._styleDirty = !1) } function cVe(e, t) { let n = e._featureTables, i = n.length, o = !1; for (let r = 0; r < i; r++)n[r].update(t), n[r].styleCommandsNeededDirty && (o = !0); o && xte(e) } function xte(e) { let t = e.featureTables[e.featureTableId]; e._styleCommandsNeeded = Kd.getStyleCommandsNeeded(t.featuresLength, t.batchTexture.translucentFeaturesLength) } function lVe(e) { let t = e.pointCloudShading; t.attenuation !== e._attenuation && (e.resetDrawCommands(), e._attenuation = t.attenuation), t.backFaceCulling !== e._pointCloudBackFaceCulling && (e.resetDrawCommands(), e._pointCloudBackFaceCulling = t.backFaceCulling) } function uVe(e, t) { e._silhouetteDirty && (Ete(t) && e.resetDrawCommands(), e._silhouetteDirty = !1) } function fVe(e, t) { let n = e.hasSkipLevelOfDetail(t); n !== e._skipLevelOfDetail && (e.resetDrawCommands(), e._skipLevelOfDetail = n) } function dVe(e, t) { let n = 0; e.isClippingEnabled() && (e._clippingPlanes.owner === e && e._clippingPlanes.update(t), n = e._clippingPlanes.clippingPlanesState), n !== e._clippingPlanesState && (e.resetDrawCommands(), e._clippingPlanesState = n) } function hVe(e, t) { t.mode !== e._sceneMode && (e._projectTo2D ? e.resetDrawCommands() : e._updateModelMatrix = !0, e._sceneMode = t.mode) } function mVe(e, t) { e._drawCommandsBuilt || (e.destroyPipelineResources(), e._sceneGraph.buildDrawCommands(t), e._drawCommandsBuilt = !0) } function pVe(e, t) { F.equals(e.modelMatrix, e._modelMatrix) || (e._updateModelMatrix = !0, e._modelMatrix = F.clone(e.modelMatrix, e._modelMatrix)) } var mu = new h, TL = new he; function _Ve(e) { if (!e._updateModelMatrix && !e._heightDirty && e._minimumPixelSize === 0) return; l(e._removeUpdateHeightCallback) && (e._removeUpdateHeightCallback(), e._removeUpdateHeightCallback = void 0); let t = e._scene; if (!l(t) || !l(t.globe) || e.heightReference === ze.NONE) { e._clampedModelMatrix = void 0; return } let n = t.globe, i = n.ellipsoid, o = e.modelMatrix; mu.x = o[12], mu.y = o[13], mu.z = o[14]; let r = i.cartesianToCartographic(mu); l(e._clampedModelMatrix) || (e._clampedModelMatrix = F.clone(o, new F)); let s = n._surface; e._removeUpdateHeightCallback = s.updateHeight(r, Cte(e, i, r)); let a = n.getHeight(r); if (l(a)) { let c = Cte(e, i, r); he.clone(r, TL), TL.height = a, i.cartographicToCartesian(TL, mu), c(mu) } e._heightDirty = !1, e._updateModelMatrix = !0 } function gVe(e, t) { if (!e._updateModelMatrix && e._minimumPixelSize === 0) return; let n = l(e._clampedModelMatrix) ? e._clampedModelMatrix : e.modelMatrix; Tte(e, n), yVe(e, n, t) } function Tte(e, t) { e._boundingSphere = re.transform(e._sceneGraph.boundingSphere, t, e._boundingSphere), e._clampedScale = l(e._maximumScale) ? Math.min(e._scale, e._maximumScale) : e._scale, e._boundingSphere.radius = e._initialRadius * e._clampedScale } function yVe(e, t, n) { let i = e.scale; if (e.minimumPixelSize !== 0 && !e._projectTo2D) { let o = n.context, r = Math.max(o.drawingBufferWidth, o.drawingBufferHeight); mu.x = t[12], mu.y = t[13], mu.z = t[14], e._sceneMode !== ee.SCENE3D && ji.computeActualWgs84Position(n, mu, mu); let s = e._boundingSphere.radius, a = bVe(mu, s, n), c = 1 / a; Math.min(c * (2 * s), r) < e.minimumPixelSize && (i = e.minimumPixelSize * a / (2 * e._initialRadius)) } e._computedScale = l(e.maximumScale) ? Math.min(e.maximumScale, i) : i } function AVe(e) { if (!e._idDirty) return; e._idDirty = !1; let t = e._id, n = e._pickIds, i = n.length; for (let o = 0; o < i; ++o)n[o].object.id = t } function CVe(e, t) { let n = l(e._clampedModelMatrix) ? e._clampedModelMatrix : e.modelMatrix, i = y(e.referenceMatrix, n), o = t.context, r = e._imageBasedLighting; if (r.useSphericalHarmonicCoefficients || r.useSpecularEnvironmentMaps) { let s = tVe, a = eVe; a = F.multiply(o.uniformState.view3D, i, a), s = F.getMatrix3(a, s), s = Q.getRotation(s, s), e._iblReferenceFrameMatrix = Q.transpose(s, e._iblReferenceFrameMatrix) } if (e.isClippingEnabled()) { let s = nVe; s = F.multiply(o.uniformState.view3D, i, s), s = F.multiply(s, e._clippingPlanes.modelMatrix, s), e._clippingPlanesMatrix = F.inverseTranspose(s, e._clippingPlanesMatrix) } } function xVe(e, t) { let n = e._sceneGraph; if (e._updateModelMatrix || e._minimumPixelSize !== 0) { let o = l(e._clampedModelMatrix) ? e._clampedModelMatrix : e.modelMatrix; n.updateModelMatrix(o, t), e._updateModelMatrix = !1 } e._backFaceCullingDirty && (n.updateBackFaceCulling(e._backFaceCulling), e._backFaceCullingDirty = !1), e._shadowsDirty && (n.updateShadows(e._shadows), e._shadowsDirty = !1), e._debugShowBoundingVolumeDirty && (n.updateShowBoundingVolume(e._debugShowBoundingVolume), e._debugShowBoundingVolumeDirty = !1); let i = !1; l(e.classificationType) || (i = e._userAnimationDirty || e._activeAnimations.update(t)), n.update(t, i), e._userAnimationDirty = !1 } function TVe(e) { if (!e._showCreditsOnScreenDirty) return; e._showCreditsOnScreenDirty = !1; let t = e._showCreditsOnScreen; l(e._credit) && (e._credit.showOnScreen = t); let n = e._resourceCredits, i = n.length; for (let s = 0; s < i; s++)n[s].showOnScreen = t; let o = e._gltfCredits, r = o.length; for (let s = 0; s < r; s++)o[s].showOnScreen = t } function EVe(e, t) { let n = wVe(e, t), i = e.isInvisible(), o = e.hasSilhouette(t), r = e._show && e._computedScale !== 0 && n && (!i || o), s = t.passes, a = s.render || s.pick && e.allowPicking; r && !e._ignoreCommands && a && (DVe(e, t), e._sceneGraph.pushDrawCommands(t)) } var G8 = new re; function bVe(e, t, n) { return G8.center = e, G8.radius = t, n.camera.getPixelSize(G8, n.context.drawingBufferWidth, n.context.drawingBufferHeight) } function Cte(e, t, n) { return function (i) { if (e.heightReference === ze.RELATIVE_TO_GROUND) { let r = t.cartesianToCartographic(i, TL); r.height += n.height, t.cartographicToCartesian(r, i) } let o = e._clampedModelMatrix; F.clone(e.modelMatrix, o), o[12] = i.x, o[13] = i.y, o[14] = i.z, e._heightDirty = !0 } } var SVe = new h; function wVe(e, t) { let n = e.distanceDisplayCondition; if (!l(n)) return !0; let i = n.near * n.near, o = n.far * n.far, r; if (t.mode === ee.SCENE2D) { let a = (t.camera.frustum.right - t.camera.frustum.left) * .5; r = a * a } else { let s = F.getTranslation(e.modelMatrix, SVe); ji.computeActualWgs84Position(t, s, s), r = h.distanceSquared(s, t.camera.positionWC) } return r >= i && r <= o } function DVe(e, t) { let n = t.creditDisplay, i = e._credit; l(i) && n.addCredit(i); let o = e._resourceCredits, r = o.length; for (let c = 0; c < r; c++)n.addCredit(o[c]); let s = e._gltfCredits, a = s.length; for (let c = 0; c < a; c++)n.addCredit(s[c]) } go.prototype.isTranslucent = function () { let e = this.color; return l(e) && e.alpha > 0 && e.alpha < 1 }; go.prototype.isInvisible = function () { let e = this.color; return l(e) && e.alpha === 0 }; function Ete(e) { return e.context.stencilBuffer } go.prototype.hasSilhouette = function (e) { return Ete(e) && this._silhouetteSize > 0 && this._silhouetteColor.alpha > 0 && !l(this._classificationType) }; function vVe(e) { return e.context.stencilBuffer } go.prototype.hasSkipLevelOfDetail = function (e) { if (!ar.is3DTiles(this.type)) return !1; let n = this._content.tileset; return vVe(e) && n.skipLevelOfDetail }; go.prototype.isClippingEnabled = function () { let e = this._clippingPlanes; return l(e) && e.enabled && e.length !== 0 }; go.prototype.isDestroyed = function () { return !1 }; go.prototype.destroy = function () { let e = this._loader; l(e) && e.destroy(); let t = this._featureTables; if (l(t)) { let i = t.length; for (let o = 0; o < i; o++)t[o].destroy() } this.destroyPipelineResources(), this.destroyModelResources(), l(this._removeUpdateHeightCallback) && (this._removeUpdateHeightCallback(), this._removeUpdateHeightCallback = void 0), l(this._terrainProviderChangedCallback) && (this._terrainProviderChangedCallback(), this._terrainProviderChangedCallback = void 0); let n = this._clippingPlanes; l(n) && !n.isDestroyed() && n.owner === this && n.destroy(), this._clippingPlanes = void 0, this._shouldDestroyImageBasedLighting && !this._imageBasedLighting.isDestroyed() && this._imageBasedLighting.destroy(), this._imageBasedLighting = void 0, le(this) }; go.prototype.destroyPipelineResources = function () { let e = this._pipelineResources; for (let t = 0; t < e.length; t++)e[t].destroy(); this._pipelineResources.length = 0, this._pickIds.length = 0 }; go.prototype.destroyModelResources = function () { let e = this._modelResources; for (let t = 0; t < e.length; t++)e[t].destroy(); this._modelResources.length = 0 }; go.fromGltf = function (e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.url, e.gltf), n = { releaseGltfJson: e.releaseGltfJson, asynchronous: e.asynchronous, incrementallyLoadTextures: e.incrementallyLoadTextures, upAxis: e.upAxis, forwardAxis: e.forwardAxis, loadAttributesFor2D: e.projectTo2D, loadIndicesForWireframe: e.enableDebugWireframe, loadPrimitiveOutline: e.enableShowOutline, loadForClassification: l(e.classificationType) }, i = y(e.basePath, ""), o = Pe.createIfNeeded(i); l(t.asset) ? (n.gltfJson = t, n.baseResource = o, n.gltfResource = o) : t instanceof Uint8Array ? (n.typedArray = t, n.baseResource = o, n.gltfResource = o) : n.gltfResource = Pe.createIfNeeded(t); let r = new h_(n), a = l(e.content) ? ar.TILE_GLTF : ar.GLTF, c = NS(r, a, e); return c.resource = n.gltfResource, new go(c) }; go.fromB3dm = function (e) { let t = { b3dmResource: e.resource, arrayBuffer: e.arrayBuffer, byteOffset: e.byteOffset, releaseGltfJson: e.releaseGltfJson, asynchronous: e.asynchronous, incrementallyLoadTextures: e.incrementallyLoadTextures, upAxis: e.upAxis, forwardAxis: e.forwardAxis, loadAttributesFor2D: e.projectTo2D, loadIndicesForWireframe: e.enableDebugWireframe, loadPrimitiveOutline: e.enableShowOutline, loadForClassification: l(e.classificationType) }, n = new RR(t), i = NS(n, ar.TILE_B3DM, e); return new go(i) }; go.fromPnts = function (e) { let t = { arrayBuffer: e.arrayBuffer, byteOffset: e.byteOffset, loadAttributesFor2D: e.projectTo2D }, n = new xL(t), i = NS(n, ar.TILE_PNTS, e); return new go(i) }; go.fromI3dm = function (e) { let t = { i3dmResource: e.resource, arrayBuffer: e.arrayBuffer, byteOffset: e.byteOffset, releaseGltfJson: e.releaseGltfJson, asynchronous: e.asynchronous, incrementallyLoadTextures: e.incrementallyLoadTextures, upAxis: e.upAxis, forwardAxis: e.forwardAxis, loadAttributesFor2D: e.projectTo2D, loadIndicesForWireframe: e.enableDebugWireframe, loadPrimitiveOutline: e.enableShowOutline }, n = new UR(t), i = NS(n, ar.TILE_I3DM, e); return new go(i) }; go.fromGeoJson = function (e) { let t = { geoJson: e.geoJson }, n = new LR(t), i = NS(n, ar.TILE_GEOJSON, e); return new go(i) }; go.prototype.applyColorAndShow = function (e) { let t = this._color, n = l(e) && l(e.color), i = l(e) && l(e.show); this._color = n ? e.color.evaluateColor(void 0, this._color) : U.clone(U.WHITE, this._color), this._show = i ? e.show.evaluate(void 0) : !0, W8(t, this._color) && this.resetDrawCommands() }; go.prototype.applyStyle = function (e) { let t = this.type === ar.TILE_PNTS, n = l(this.featureTableId) && this.featureTables[this.featureTableId].featuresLength > 0, i = l(this.structuralMetadata) ? this.structuralMetadata.propertyAttributes : void 0, o = l(i) && l(i[0]); if (t && (!n || o)) { this.resetDrawCommands(); return } n ? (this.featureTables[this.featureTableId].applyStyle(e), xte(this, e)) : (this.applyColorAndShow(e), this._styleCommandsNeeded = void 0) }; function NS(e, t, n) { return { loader: e, type: t, resource: n.resource, show: n.show, modelMatrix: n.modelMatrix, scale: n.scale, minimumPixelSize: n.minimumPixelSize, maximumScale: n.maximumScale, id: n.id, allowPicking: n.allowPicking, clampAnimations: n.clampAnimations, shadows: n.shadows, debugShowBoundingVolume: n.debugShowBoundingVolume, enableDebugWireframe: n.enableDebugWireframe, debugWireframe: n.debugWireframe, cull: n.cull, opaquePass: n.opaquePass, customShader: n.customShader, content: n.content, heightReference: n.heightReference, scene: n.scene, distanceDisplayCondition: n.distanceDisplayCondition, color: n.color, colorBlendAmount: n.colorBlendAmount, colorBlendMode: n.colorBlendMode, silhouetteColor: n.silhouetteColor, silhouetteSize: n.silhouetteSize, enableShowOutline: n.enableShowOutline, showOutline: n.showOutline, outlineColor: n.outlineColor, clippingPlanes: n.clippingPlanes, lightColor: n.lightColor, imageBasedLighting: n.imageBasedLighting, backFaceCulling: n.backFaceCulling, credit: n.credit, showCreditsOnScreen: n.showCreditsOnScreen, splitDirection: n.splitDirection, projectTo2D: n.projectTo2D, featureIdLabel: n.featureIdLabel, instanceFeatureIdLabel: n.instanceFeatureIdLabel, pointCloudShading: n.pointCloudShading, classificationType: n.classificationType, pickObject: n.pickObject } } var Jd = go; function ds(e, t, n) { this._tileset = e, this._tile = t, this._resource = n, this._model = void 0, this._readyPromise = void 0, this._metadata = void 0, this._group = void 0 } Object.defineProperties(ds.prototype, { featuresLength: { get: function () { let e = this._model, t = e.featureTables, n = e.featureTableId; return l(t) && l(t[n]) ? t[n].featuresLength : 0 } }, pointsLength: { get: function () { return this._model.statistics.pointsLength } }, trianglesLength: { get: function () { return this._model.statistics.trianglesLength } }, geometryByteLength: { get: function () { return this._model.statistics.geometryByteLength } }, texturesByteLength: { get: function () { return this._model.statistics.texturesByteLength } }, batchTableByteLength: { get: function () { let e = this._model.statistics; return e.propertyTablesByteLength + e.batchTexturesByteLength } }, innerContents: { get: function () { } }, readyPromise: { get: function () { return this._readyPromise } }, tileset: { get: function () { return this._tileset } }, tile: { get: function () { return this._tile } }, url: { get: function () { return this._resource.getUrlComponent(!0) } }, batchTable: { get: function () { let e = this._model, t = e.featureTables, n = e.featureTableId; if (l(t) && l(t[n])) return t[n] } }, metadata: { get: function () { return this._metadata }, set: function (e) { this._metadata = e } }, group: { get: function () { return this._group }, set: function (e) { this._group = e } } }); ds.prototype.getFeature = function (e) { let t = this._model, n = t.featureTableId; return t.featureTables[n].getFeature(e) }; ds.prototype.hasProperty = function (e, t) { let n = this._model, i = n.featureTableId; return l(i) ? n.featureTables[i].hasProperty(e, t) : !1 }; ds.prototype.applyDebugSettings = function (e, t) { t = e ? t : U.WHITE, this.featuresLength === 0 ? this._model.color = t : l(this.batchTable) && this.batchTable.setAllColor(t) }; ds.prototype.applyStyle = function (e) { this._model.style = e }; ds.prototype.update = function (e, t) { let n = this._model, i = this._tile; n.colorBlendAmount = e.colorBlendAmount, n.colorBlendMode = e.colorBlendMode, n.modelMatrix = i.computedTransform, n.customShader = e.customShader, n.featureIdLabel = e.featureIdLabel, n.instanceFeatureIdLabel = e.instanceFeatureIdLabel, n.lightColor = e.lightColor, n.imageBasedLighting = e.imageBasedLighting, n.backFaceCulling = e.backFaceCulling, n.shadows = e.shadows, n.showCreditsOnScreen = e.showCreditsOnScreen, n.splitDirection = e.splitDirection, n.debugWireframe = e.debugWireframe, n.showOutline = e.showOutline, n.outlineColor = e.outlineColor, n.pointCloudShading = e.pointCloudShading; let o = e.clippingPlanes; n.referenceMatrix = e.clippingPlanesOriginMatrix, l(o) && i.clippingPlanesDirty && (n._clippingPlanes = o.enabled && i._isClipped ? o : void 0), l(o) && l(n._clippingPlanes) && n._clippingPlanes !== o && (n._clippingPlanes = o, n._clippingPlanesState = 0), n.update(t) }; ds.prototype.isDestroyed = function () { return !1 }; ds.prototype.destroy = function () { return this._model = this._model && this._model.destroy(), le(this) }; ds.fromGltf = function (e, t, n, i) { let o = new ds(e, t, n), s = VS(e, t, o, { gltf: i, basePath: n }), a = e.vectorClassificationOnly ? void 0 : e.classificationType; s.classificationType = a; let c = Jd.fromGltf(s); return o._model = c, o._readyPromise = c.readyPromise.then(function (u) { return u.activeAnimations.addAll({ loop: ic.REPEAT }), u }), o }; ds.fromB3dm = function (e, t, n, i, o) { let r = new ds(e, t, n), a = VS(e, t, r, { arrayBuffer: i, byteOffset: o, resource: n }), c = e.vectorClassificationOnly ? void 0 : e.classificationType; a.classificationType = c; let u = Jd.fromB3dm(a); return r._model = u, r._readyPromise = u.readyPromise.then(function (f) { return f.activeAnimations.addAll({ loop: ic.REPEAT }), f }), r }; ds.fromI3dm = function (e, t, n, i, o) { let r = new ds(e, t, n), a = VS(e, t, r, { arrayBuffer: i, byteOffset: o, resource: n }), c = Jd.fromI3dm(a); return r._model = c, r._readyPromise = c.readyPromise.then(function (u) { return u.activeAnimations.addAll({ loop: ic.REPEAT }), u }), r }; ds.fromPnts = function (e, t, n, i, o) { let r = new ds(e, t, n), a = VS(e, t, r, { arrayBuffer: i, byteOffset: o, resource: n }), c = Jd.fromPnts(a); return r._model = c, r._readyPromise = c.readyPromise, r }; ds.fromGeoJson = function (e, t, n, i) { let o = new ds(e, t, n), s = VS(e, t, o, { geoJson: i, resource: n }), a = Jd.fromGeoJson(s); return o._model = a, o._readyPromise = a.readyPromise, o }; function VS(e, t, n, i) { let o = { cull: !1, releaseGltfJson: !0, opaquePass: xe.CESIUM_3D_TILE, modelMatrix: t.computedTransform, upAxis: e._modelUpAxis, forwardAxis: e._modelForwardAxis, incrementallyLoadTextures: !1, customShader: e.customShader, content: n, colorBlendMode: e.colorBlendMode, colorBlendAmount: e.colorBlendAmount, lightColor: e.lightColor, imageBasedLighting: e.imageBasedLighting, featureIdLabel: e.featureIdLabel, instanceFeatureIdLabel: e.instanceFeatureIdLabel, pointCloudShading: e.pointCloudShading, clippingPlanes: e.clippingPlanes, backFaceCulling: e.backFaceCulling, shadows: e.shadows, showCreditsOnScreen: e.showCreditsOnScreen, splitDirection: e.splitDirection, enableDebugWireframe: e._enableDebugWireframe, debugWireframe: e.debugWireframe, projectTo2D: e._projectTo2D, enableShowOutline: e._enableShowOutline, showOutline: e.showOutline, outlineColor: e.outlineColor }; return yt(i, o) } var Om = ds; function Bm(e, t, n, i) { this._tileset = e, this._tile = t, this._resource = n, this.featurePropertiesDirty = !1, this._metadata = void 0, this._group = void 0, this._readyPromise = PVe(this, i) } Object.defineProperties(Bm.prototype, { featuresLength: { get: function () { return 0 } }, pointsLength: { get: function () { return 0 } }, trianglesLength: { get: function () { return 0 } }, geometryByteLength: { get: function () { return 0 } }, texturesByteLength: { get: function () { return 0 } }, batchTableByteLength: { get: function () { return 0 } }, innerContents: { get: function () { } }, readyPromise: { get: function () { return this._readyPromise } }, tileset: { get: function () { return this._tileset } }, tile: { get: function () { return this._tile } }, url: { get: function () { return this._resource.getUrlComponent(!0) } }, batchTable: { get: function () { } }, metadata: { get: function () { return this._metadata }, set: function (e) { this._metadata = e } }, group: { get: function () { return this._group }, set: function (e) { this._group = e } } }); function PVe(e, t) { return e._tileset.loadTileset(e._resource, t, e._tile), Promise.resolve(e) } Bm.prototype.hasProperty = function (e, t) { return !1 }; Bm.prototype.getFeature = function (e) { }; Bm.prototype.applyDebugSettings = function (e, t) { }; Bm.prototype.applyStyle = function (e) { }; Bm.prototype.update = function (e, t) { }; Bm.prototype.isDestroyed = function () { return !1 }; Bm.prototype.destroy = function () { return le(this) }; var EL = Bm; function hs(e, t, n, i) { let o = hs._verifyAttributes(t); n = y(n, 0); let r = [], s = {}, a, c, u = o.length; for (let d = 0; d < u; ++d) { let p = o[d]; if (p.vertexBuffer) { r.push(p); continue } c = p.usage, a = s[c], l(a) || (a = s[c] = []), a.push(p) } function f(d, p) { return Y.getSizeInBytes(p.componentDatatype) - Y.getSizeInBytes(d.componentDatatype) } this._allBuffers = []; for (c in s) if (s.hasOwnProperty(c)) { a = s[c], a.sort(f); let d = hs._vertexSizeInBytes(a), p = a[0].usage, g = { vertexSizeInBytes: d, vertexBuffer: void 0, usage: p, needsCommit: !1, arrayBuffer: void 0, arrayViews: hs._createArrayViews(a, d) }; this._allBuffers.push(g) } this._size = 0, this._instanced = y(i, !1), this._precreated = r, this._context = e, this.writers = void 0, this.va = void 0, this.resize(n) } hs._verifyAttributes = function (e) { let t = []; for (let i = 0; i < e.length; ++i) { let o = e[i], r = { index: y(o.index, i), enabled: y(o.enabled, !0), componentsPerAttribute: o.componentsPerAttribute, componentDatatype: y(o.componentDatatype, Y.FLOAT), normalize: y(o.normalize, !1), vertexBuffer: o.vertexBuffer, usage: y(o.usage, Re.STATIC_DRAW) }; t.push(r) } let n = new Array(t.length); for (let i = 0; i < t.length; ++i) { let r = t[i].index; n[r] = !0 } return t }; hs._vertexSizeInBytes = function (e) { let t = 0, n = e.length; for (let s = 0; s < n; ++s) { let a = e[s]; t += a.componentsPerAttribute * Y.getSizeInBytes(a.componentDatatype) } let i = n > 0 ? Y.getSizeInBytes(e[0].componentDatatype) : 0, o = i > 0 ? t % i : 0; return t += o === 0 ? 0 : i - o, t }; hs._createArrayViews = function (e, t) { let n = [], i = 0, o = e.length; for (let r = 0; r < o; ++r) { let s = e[r], a = s.componentDatatype; n.push({ index: s.index, enabled: s.enabled, componentsPerAttribute: s.componentsPerAttribute, componentDatatype: a, normalize: s.normalize, offsetInBytes: i, vertexSizeInComponentType: t / Y.getSizeInBytes(a), view: void 0 }), i += s.componentsPerAttribute * Y.getSizeInBytes(a) } return n }; hs.prototype.resize = function (e) { this._size = e; let t = this._allBuffers; this.writers = []; for (let n = 0, i = t.length; n < i; ++n) { let o = t[n]; hs._resize(o, this._size), hs._appendWriters(this.writers, o) } j8(this) }; hs._resize = function (e, t) { if (e.vertexSizeInBytes > 0) { let n = new ArrayBuffer(t * e.vertexSizeInBytes); if (l(e.arrayBuffer)) { let r = new Uint8Array(n), s = new Uint8Array(e.arrayBuffer), a = s.length; for (let c = 0; c < a; ++c)r[c] = s[c] } let i = e.arrayViews, o = i.length; for (let r = 0; r < o; ++r) { let s = i[r]; s.view = Y.createArrayBufferView(s.componentDatatype, n, s.offsetInBytes) } e.arrayBuffer = n } }; var IVe = [function (e, t, n) { return function (i, o) { t[i * n] = o, e.needsCommit = !0 } }, function (e, t, n) { return function (i, o, r) { let s = i * n; t[s] = o, t[s + 1] = r, e.needsCommit = !0 } }, function (e, t, n) { return function (i, o, r, s) { let a = i * n; t[a] = o, t[a + 1] = r, t[a + 2] = s, e.needsCommit = !0 } }, function (e, t, n) { return function (i, o, r, s, a) { let c = i * n; t[c] = o, t[c + 1] = r, t[c + 2] = s, t[c + 3] = a, e.needsCommit = !0 } }]; hs._appendWriters = function (e, t) { let n = t.arrayViews, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; e[r.index] = IVe[r.componentsPerAttribute - 1](t, r.view, r.vertexSizeInComponentType) } }; hs.prototype.commit = function (e) { let t = !1, n = this._allBuffers, i, o, r; for (o = 0, r = n.length; o < r; ++o)i = n[o], t = OVe(this, i) || t; if (t || !l(this.va)) { j8(this); let s = this.va = [], a = I.SIXTY_FOUR_KILOBYTES - 4, c = l(e) && !this._instanced ? Math.ceil(this._size / a) : 1; for (let u = 0; u < c; ++u) { let f = []; for (o = 0, r = n.length; o < r; ++o) { i = n[o]; let d = u * (i.vertexSizeInBytes * a); hs._appendAttributes(f, i, d, this._instanced) } f = f.concat(this._precreated), s.push({ va: new Qn({ context: this._context, attributes: f, indexBuffer: e }), indicesCount: 1.5 * (u !== c - 1 ? a : this._size % a) }) } } }; function OVe(e, t) { if (t.needsCommit && t.vertexSizeInBytes > 0) { t.needsCommit = !1; let n = t.vertexBuffer, i = e._size * t.vertexSizeInBytes, o = l(n); if (!o || n.sizeInBytes < i) return o && n.destroy(), t.vertexBuffer = ct.createVertexBuffer({ context: e._context, typedArray: t.arrayBuffer, usage: t.usage }), t.vertexBuffer.vertexArrayDestroyable = !1, !0; t.vertexBuffer.copyFromArrayView(t.arrayBuffer) } return !1 } hs._appendAttributes = function (e, t, n, i) { let o = t.arrayViews, r = o.length; for (let s = 0; s < r; ++s) { let a = o[s]; e.push({ index: a.index, enabled: a.enabled, componentsPerAttribute: a.componentsPerAttribute, componentDatatype: a.componentDatatype, normalize: a.normalize, vertexBuffer: t.vertexBuffer, offsetInBytes: n + a.offsetInBytes, strideInBytes: t.vertexSizeInBytes, instanceDivisor: i ? 1 : 0 }) } }; hs.prototype.subCommit = function (e, t) { let n = this._allBuffers; for (let i = 0, o = n.length; i < o; ++i)BVe(n[i], e, t) }; function BVe(e, t, n) { if (e.needsCommit && e.vertexSizeInBytes > 0) { let i = e.vertexSizeInBytes * t, o = e.vertexSizeInBytes * n; e.vertexBuffer.copyFromArrayView(new Uint8Array(e.arrayBuffer, i, o), i) } } hs.prototype.endSubCommits = function () { let e = this._allBuffers; for (let t = 0, n = e.length; t < n; ++t)e[t].needsCommit = !1 }; function j8(e) { let t = e.va; if (!l(t)) return; let n = t.length; for (let i = 0; i < n; ++i)t[i].va.destroy(); e.va = void 0 } hs.prototype.isDestroyed = function () { return !1 }; hs.prototype.destroy = function () { let e = this._allBuffers; for (let t = 0, n = e.length; t < n; ++t) { let i = e[t]; i.vertexBuffer = i.vertexBuffer && i.vertexBuffer.destroy() } return j8(this), le(this) }; var E_ = hs; var bL = `#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif
uniform sampler2D u_atlas;
#ifdef VECTOR_TILE
uniform vec4 u_highlightColor;
#endif
varying vec2 v_textureCoordinates;
varying vec4 v_pickColor;
varying vec4 v_color;
#ifdef SDF
varying vec4 v_outlineColor;
varying float v_outlineWidth;
#endif
#ifdef FRAGMENT_DEPTH_CHECK
varying vec4 v_textureCoordinateBounds;
varying vec4 v_originTextureCoordinateAndTranslate;
varying vec4 v_compressed;
varying mat2 v_rotationMatrix;
const float SHIFT_LEFT12 = 4096.0;
const float SHIFT_LEFT1 = 2.0;
const float SHIFT_RIGHT12 = 1.0 / 4096.0;
const float SHIFT_RIGHT1 = 1.0 / 2.0;
float getGlobeDepth(vec2 adjustedST, vec2 depthLookupST, bool applyTranslate, vec2 dimensions, vec2 imageSize)
{
vec2 lookupVector = imageSize * (depthLookupST - adjustedST);
lookupVector = v_rotationMatrix * lookupVector;
vec2 labelOffset = (dimensions - imageSize) * (depthLookupST - vec2(0.0, v_originTextureCoordinateAndTranslate.y));
vec2 translation = v_originTextureCoordinateAndTranslate.zw;
if (applyTranslate)
{
translation += (dimensions * v_originTextureCoordinateAndTranslate.xy * vec2(1.0, 0.0));
}
vec2 st = ((lookupVector - translation + labelOffset) + gl_FragCoord.xy) / czm_viewport.zw;
float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, st));
if (logDepthOrDepth == 0.0)
{
return 0.0;
}
vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);
return eyeCoordinate.z / eyeCoordinate.w;
}
#endif
#ifdef SDF
float getDistance(vec2 position)
{
return texture2D(u_atlas, position).r;
}
vec4 getSDFColor(vec2 position, float outlineWidth, vec4 outlineColor, float smoothing)
{
float distance = getDistance(position);
if (outlineWidth > 0.0)
{
float outlineEdge = clamp(SDF_EDGE - outlineWidth, 0.0, SDF_EDGE);
float outlineFactor = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);
vec4 sdfColor = mix(outlineColor, v_color, outlineFactor);
float alpha = smoothstep(outlineEdge - smoothing, outlineEdge + smoothing, distance);
return vec4(sdfColor.rgb, sdfColor.a * alpha);
}
else
{
float alpha = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);
return vec4(v_color.rgb, v_color.a * alpha);
}
}
#endif
void main()
{
vec4 color = texture2D(u_atlas, v_textureCoordinates);
#ifdef SDF
float outlineWidth = v_outlineWidth;
vec4 outlineColor = v_outlineColor;
float distance = getDistance(v_textureCoordinates);
#ifdef GL_OES_standard_derivatives
float smoothing = fwidth(distance);
vec2 sampleOffset = 0.354 * vec2(dFdx(v_textureCoordinates) + dFdy(v_textureCoordinates));
vec4 center = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);
vec4 color1 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);
vec4 color2 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);
vec4 color3 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);
vec4 color4 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);
color = (center + color1 + color2 + color3 + color4)/5.0;
#else
float smoothing = 1.0/32.0;
color = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);
#endif
color = czm_gammaCorrect(color);
#else
color = czm_gammaCorrect(color);
color *= czm_gammaCorrect(v_color);
#endif
#if !defined(OPAQUE) && !defined(TRANSLUCENT)
if (color.a < 0.005)
{
discard;
}
#else
#ifdef OPAQUE
if (color.a < 0.995)
{
discard;
}
#else
if (color.a >= 0.995)
{
discard;
}
#endif
#endif
#ifdef VECTOR_TILE
color *= u_highlightColor;
#endif
gl_FragColor = color;
#ifdef LOG_DEPTH
czm_writeLogDepth();
#endif
#ifdef FRAGMENT_DEPTH_CHECK
float temp = v_compressed.y;
temp = temp * SHIFT_RIGHT1;
float temp2 = (temp - floor(temp)) * SHIFT_LEFT1;
bool enableDepthTest = temp2 != 0.0;
bool applyTranslate = floor(temp) != 0.0;
if (enableDepthTest) {
temp = v_compressed.z;
temp = temp * SHIFT_RIGHT12;
vec2 dimensions;
dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;
dimensions.x = floor(temp);
temp = v_compressed.w;
temp = temp * SHIFT_RIGHT12;
vec2 imageSize;
imageSize.y = (temp - floor(temp)) * SHIFT_LEFT12;
imageSize.x = floor(temp);
vec2 adjustedST = v_textureCoordinates - v_textureCoordinateBounds.xy;
adjustedST = adjustedST / vec2(v_textureCoordinateBounds.z - v_textureCoordinateBounds.x, v_textureCoordinateBounds.w - v_textureCoordinateBounds.y);
float epsilonEyeDepth = v_compressed.x + czm_epsilon1;
float globeDepth1 = getGlobeDepth(adjustedST, v_originTextureCoordinateAndTranslate.xy, applyTranslate, dimensions, imageSize);
if (globeDepth1 != 0.0 && globeDepth1 > epsilonEyeDepth)
{
float globeDepth2 = getGlobeDepth(adjustedST, vec2(0.0, 1.0), applyTranslate, dimensions, imageSize);
if (globeDepth2 != 0.0 && globeDepth2 > epsilonEyeDepth)
{
float globeDepth3 = getGlobeDepth(adjustedST, vec2(1.0, 1.0), applyTranslate, dimensions, imageSize);
if (globeDepth3 != 0.0 && globeDepth3 > epsilonEyeDepth)
{
discard;
}
}
}
}
#endif
}
`; var SL = `#ifdef INSTANCED
attribute vec2 direction;
#endif
attribute vec4 positionHighAndScale;
attribute vec4 positionLowAndRotation;
attribute vec4 compressedAttribute0;
attribute vec4 compressedAttribute1;
attribute vec4 compressedAttribute2;
attribute vec4 eyeOffset;
attribute vec4 scaleByDistance;
attribute vec4 pixelOffsetScaleByDistance;
attribute vec4 compressedAttribute3;
attribute vec2 sdf;
#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)
attribute vec4 textureCoordinateBoundsOrLabelTranslate;
#endif
#ifdef VECTOR_TILE
attribute float a_batchId;
#endif
varying vec2 v_textureCoordinates;
#ifdef FRAGMENT_DEPTH_CHECK
varying vec4 v_textureCoordinateBounds;
varying vec4 v_originTextureCoordinateAndTranslate;
varying vec4 v_compressed;
varying mat2 v_rotationMatrix;
#endif
varying vec4 v_pickColor;
varying vec4 v_color;
#ifdef SDF
varying vec4 v_outlineColor;
varying float v_outlineWidth;
#endif
const float UPPER_BOUND = 32768.0;
const float SHIFT_LEFT16 = 65536.0;
const float SHIFT_LEFT12 = 4096.0;
const float SHIFT_LEFT8 = 256.0;
const float SHIFT_LEFT7 = 128.0;
const float SHIFT_LEFT5 = 32.0;
const float SHIFT_LEFT3 = 8.0;
const float SHIFT_LEFT2 = 4.0;
const float SHIFT_LEFT1 = 2.0;
const float SHIFT_RIGHT12 = 1.0 / 4096.0;
const float SHIFT_RIGHT8 = 1.0 / 256.0;
const float SHIFT_RIGHT7 = 1.0 / 128.0;
const float SHIFT_RIGHT5 = 1.0 / 32.0;
const float SHIFT_RIGHT3 = 1.0 / 8.0;
const float SHIFT_RIGHT2 = 1.0 / 4.0;
const float SHIFT_RIGHT1 = 1.0 / 2.0;
vec4 addScreenSpaceOffset(vec4 positionEC, vec2 imageSize, float scale, vec2 direction, vec2 origin, vec2 translate, vec2 pixelOffset, vec3 alignedAxis, bool validAlignedAxis, float rotation, bool sizeInMeters, out mat2 rotationMatrix, out float mpp)
{
vec2 halfSize = imageSize * scale * 0.5;
halfSize *= ((direction * 2.0) - 1.0);
vec2 originTranslate = origin * abs(halfSize);
#if defined(ROTATION) || defined(ALIGNED_AXIS)
if (validAlignedAxis || rotation != 0.0)
{
float angle = rotation;
if (validAlignedAxis)
{
vec4 projectedAlignedAxis = czm_modelViewProjection * vec4(alignedAxis, 0.0);
angle += sign(-projectedAlignedAxis.x) * acos(sign(projectedAlignedAxis.y) * (projectedAlignedAxis.y * projectedAlignedAxis.y) /
(projectedAlignedAxis.x * projectedAlignedAxis.x + projectedAlignedAxis.y * projectedAlignedAxis.y));
}
float cosTheta = cos(angle);
float sinTheta = sin(angle);
rotationMatrix = mat2(cosTheta, sinTheta, -sinTheta, cosTheta);
halfSize = rotationMatrix * halfSize;
}
else
{
rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);
}
#endif
mpp = czm_metersPerPixel(positionEC);
positionEC.xy += (originTranslate + halfSize) * czm_branchFreeTernary(sizeInMeters, 1.0, mpp);
positionEC.xy += (translate + pixelOffset) * mpp;
return positionEC;
}
#ifdef VERTEX_DEPTH_CHECK
float getGlobeDepth(vec4 positionEC)
{
vec4 posWC = czm_eyeToWindowCoordinates(positionEC);
float globeDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, posWC.xy / czm_viewport.zw));
if (globeDepth == 0.0)
{
return 0.0;
}
vec4 eyeCoordinate = czm_windowToEyeCoordinates(posWC.xy, globeDepth);
return eyeCoordinate.z / eyeCoordinate.w;
}
#endif
void main()
{
vec3 positionHigh = positionHighAndScale.xyz;
vec3 positionLow = positionLowAndRotation.xyz;
float scale = positionHighAndScale.w;
#if defined(ROTATION) || defined(ALIGNED_AXIS)
float rotation = positionLowAndRotation.w;
#else
float rotation = 0.0;
#endif
float compressed = compressedAttribute0.x;
vec2 pixelOffset;
pixelOffset.x = floor(compressed * SHIFT_RIGHT7);
compressed -= pixelOffset.x * SHIFT_LEFT7;
pixelOffset.x -= UPPER_BOUND;
vec2 origin;
origin.x = floor(compressed * SHIFT_RIGHT5);
compressed -= origin.x * SHIFT_LEFT5;
origin.y = floor(compressed * SHIFT_RIGHT3);
compressed -= origin.y * SHIFT_LEFT3;
#ifdef FRAGMENT_DEPTH_CHECK
vec2 depthOrigin = origin.xy;
#endif
origin -= vec2(1.0);
float show = floor(compressed * SHIFT_RIGHT2);
compressed -= show * SHIFT_LEFT2;
#ifdef INSTANCED
vec2 textureCoordinatesBottomLeft = czm_decompressTextureCoordinates(compressedAttribute0.w);
vec2 textureCoordinatesRange = czm_decompressTextureCoordinates(eyeOffset.w);
vec2 textureCoordinates = textureCoordinatesBottomLeft + direction * textureCoordinatesRange;
#else
vec2 direction;
direction.x = floor(compressed * SHIFT_RIGHT1);
direction.y = compressed - direction.x * SHIFT_LEFT1;
vec2 textureCoordinates = czm_decompressTextureCoordinates(compressedAttribute0.w);
#endif
float temp = compressedAttribute0.y  * SHIFT_RIGHT8;
pixelOffset.y = -(floor(temp) - UPPER_BOUND);
vec2 translate;
translate.y = (temp - floor(temp)) * SHIFT_LEFT16;
temp = compressedAttribute0.z * SHIFT_RIGHT8;
translate.x = floor(temp) - UPPER_BOUND;
translate.y += (temp - floor(temp)) * SHIFT_LEFT8;
translate.y -= UPPER_BOUND;
temp = compressedAttribute1.x * SHIFT_RIGHT8;
float temp2 = floor(compressedAttribute2.w * SHIFT_RIGHT2);
vec2 imageSize = vec2(floor(temp), temp2);
#ifdef FRAGMENT_DEPTH_CHECK
float labelHorizontalOrigin = floor(compressedAttribute2.w - (temp2 * SHIFT_LEFT2));
float applyTranslate = 0.0;
if (labelHorizontalOrigin != 0.0)
{
applyTranslate = 1.0;
labelHorizontalOrigin -= 2.0;
depthOrigin.x = labelHorizontalOrigin + 1.0;
}
depthOrigin = vec2(1.0) - (depthOrigin * 0.5);
#endif
#ifdef EYE_DISTANCE_TRANSLUCENCY
vec4 translucencyByDistance;
translucencyByDistance.x = compressedAttribute1.z;
translucencyByDistance.z = compressedAttribute1.w;
translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;
temp = compressedAttribute1.y * SHIFT_RIGHT8;
translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;
#endif
#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)
temp = compressedAttribute3.w;
temp = temp * SHIFT_RIGHT12;
vec2 dimensions;
dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;
dimensions.x = floor(temp);
#endif
#ifdef ALIGNED_AXIS
vec3 alignedAxis = czm_octDecode(floor(compressedAttribute1.y * SHIFT_RIGHT8));
temp = compressedAttribute2.z * SHIFT_RIGHT5;
bool validAlignedAxis = (temp - floor(temp)) * SHIFT_LEFT1 > 0.0;
#else
vec3 alignedAxis = vec3(0.0);
bool validAlignedAxis = false;
#endif
vec4 pickColor;
vec4 color;
temp = compressedAttribute2.y;
temp = temp * SHIFT_RIGHT8;
pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
temp = floor(temp) * SHIFT_RIGHT8;
pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
pickColor.r = floor(temp);
temp = compressedAttribute2.x;
temp = temp * SHIFT_RIGHT8;
color.b = (temp - floor(temp)) * SHIFT_LEFT8;
temp = floor(temp) * SHIFT_RIGHT8;
color.g = (temp - floor(temp)) * SHIFT_LEFT8;
color.r = floor(temp);
temp = compressedAttribute2.z * SHIFT_RIGHT8;
bool sizeInMeters = floor((temp - floor(temp)) * SHIFT_LEFT7) > 0.0;
temp = floor(temp) * SHIFT_RIGHT8;
pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;
pickColor /= 255.0;
color.a = floor(temp);
color /= 255.0;
vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
vec4 positionEC = czm_modelViewRelativeToEye * p;
#if defined(FRAGMENT_DEPTH_CHECK) || defined(VERTEX_DEPTH_CHECK)
float eyeDepth = positionEC.z;
#endif
positionEC = czm_eyeOffset(positionEC, eyeOffset.xyz);
positionEC.xyz *= show;
#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(EYE_DISTANCE_PIXEL_OFFSET) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE)
float lengthSq;
if (czm_sceneMode == czm_sceneMode2D)
{
lengthSq = czm_eyeHeight2D.y;
}
else
{
lengthSq = dot(positionEC.xyz, positionEC.xyz);
}
#endif
#ifdef EYE_DISTANCE_SCALING
float distanceScale = czm_nearFarScalar(scaleByDistance, lengthSq);
scale *= distanceScale;
translate *= distanceScale;
if (scale == 0.0)
{
positionEC.xyz = vec3(0.0);
}
#endif
float translucency = 1.0;
#ifdef EYE_DISTANCE_TRANSLUCENCY
translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);
if (translucency == 0.0)
{
positionEC.xyz = vec3(0.0);
}
#endif
#ifdef EYE_DISTANCE_PIXEL_OFFSET
float pixelOffsetScale = czm_nearFarScalar(pixelOffsetScaleByDistance, lengthSq);
pixelOffset *= pixelOffsetScale;
#endif
#ifdef DISTANCE_DISPLAY_CONDITION
float nearSq = compressedAttribute3.x;
float farSq = compressedAttribute3.y;
if (lengthSq < nearSq || lengthSq > farSq)
{
positionEC.xyz = vec3(0.0);
}
#endif
mat2 rotationMatrix;
float mpp;
#ifdef DISABLE_DEPTH_DISTANCE
float disableDepthTestDistance = compressedAttribute3.z;
#endif
#ifdef VERTEX_DEPTH_CHECK
if (lengthSq < disableDepthTestDistance) {
float depthsilon = 10.0;
vec2 labelTranslate = textureCoordinateBoundsOrLabelTranslate.xy;
vec4 pEC1 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
float globeDepth1 = getGlobeDepth(pEC1);
if (globeDepth1 != 0.0 && pEC1.z + depthsilon < globeDepth1)
{
vec4 pEC2 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0, 1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
float globeDepth2 = getGlobeDepth(pEC2);
if (globeDepth2 != 0.0 && pEC2.z + depthsilon < globeDepth2)
{
vec4 pEC3 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
float globeDepth3 = getGlobeDepth(pEC3);
if (globeDepth3 != 0.0 && pEC3.z + depthsilon < globeDepth3)
{
positionEC.xyz = vec3(0.0);
}
}
}
}
#endif
positionEC = addScreenSpaceOffset(positionEC, imageSize, scale, direction, origin, translate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
gl_Position = czm_projection * positionEC;
v_textureCoordinates = textureCoordinates;
#ifdef LOG_DEPTH
czm_vertexLogDepth();
#endif
#ifdef DISABLE_DEPTH_DISTANCE
if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0)
{
disableDepthTestDistance = czm_minimumDisableDepthTestDistance;
}
if (disableDepthTestDistance != 0.0)
{
float zclip = gl_Position.z / gl_Position.w;
bool clipped = (zclip < -1.0 || zclip > 1.0);
if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance)))
{
gl_Position.z = -gl_Position.w;
#ifdef LOG_DEPTH
v_depthFromNearPlusOne = 1.0;
#endif
}
}
#endif
#ifdef FRAGMENT_DEPTH_CHECK
if (sizeInMeters) {
translate /= mpp;
dimensions /= mpp;
imageSize /= mpp;
}
#if defined(ROTATION) || defined(ALIGNED_AXIS)
v_rotationMatrix = rotationMatrix;
#else
v_rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);
#endif
float enableDepthCheck = 0.0;
if (lengthSq < disableDepthTestDistance)
{
enableDepthCheck = 1.0;
}
float dw = floor(clamp(dimensions.x, 0.0, SHIFT_LEFT12));
float dh = floor(clamp(dimensions.y, 0.0, SHIFT_LEFT12));
float iw = floor(clamp(imageSize.x, 0.0, SHIFT_LEFT12));
float ih = floor(clamp(imageSize.y, 0.0, SHIFT_LEFT12));
v_compressed.x = eyeDepth;
v_compressed.y = applyTranslate * SHIFT_LEFT1 + enableDepthCheck;
v_compressed.z = dw * SHIFT_LEFT12 + dh;
v_compressed.w = iw * SHIFT_LEFT12 + ih;
v_originTextureCoordinateAndTranslate.xy = depthOrigin;
v_originTextureCoordinateAndTranslate.zw = translate;
v_textureCoordinateBounds = textureCoordinateBoundsOrLabelTranslate;
#endif
#ifdef SDF
vec4 outlineColor;
float outlineWidth;
temp = sdf.x;
temp = temp * SHIFT_RIGHT8;
outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
temp = floor(temp) * SHIFT_RIGHT8;
outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
outlineColor.r = floor(temp);
temp = sdf.y;
temp = temp * SHIFT_RIGHT8;
float temp3 = (temp - floor(temp)) * SHIFT_LEFT8;
temp = floor(temp) * SHIFT_RIGHT8;
outlineWidth = (temp - floor(temp)) * SHIFT_LEFT8;
outlineColor.a = floor(temp);
outlineColor /= 255.0;
v_outlineWidth = outlineWidth / 255.0;
v_outlineColor = outlineColor;
v_outlineColor.a *= translucency;
#endif
v_pickColor = pickColor;
v_color = color;
v_color.a *= translucency;
}
`; function ui(e, t) { e = y(e, y.EMPTY_OBJECT); let n = e.translucencyByDistance, i = e.pixelOffsetScaleByDistance, o = e.scaleByDistance, r = e.distanceDisplayCondition; l(n) && (n = wt.clone(n)), l(i) && (i = wt.clone(i)), l(o) && (o = wt.clone(o)), l(r) && (r = bt.clone(r)), this._show = y(e.show, !0), this._position = h.clone(y(e.position, h.ZERO)), this._actualPosition = h.clone(this._position), this._pixelOffset = H.clone(y(e.pixelOffset, H.ZERO)), this._translate = new H(0, 0), this._eyeOffset = h.clone(y(e.eyeOffset, h.ZERO)), this._heightReference = y(e.heightReference, ze.NONE), this._verticalOrigin = y(e.verticalOrigin, Sn.CENTER), this._horizontalOrigin = y(e.horizontalOrigin, ai.CENTER), this._scale = y(e.scale, 1), this._color = U.clone(y(e.color, U.WHITE)), this._rotation = y(e.rotation, 0), this._alignedAxis = h.clone(y(e.alignedAxis, h.ZERO)), this._width = e.width, this._height = e.height, this._scaleByDistance = o, this._translucencyByDistance = n, this._pixelOffsetScaleByDistance = i, this._sizeInMeters = y(e.sizeInMeters, !1), this._distanceDisplayCondition = r, this._disableDepthTestDistance = e.disableDepthTestDistance, this._id = e.id, this._collection = y(e.collection, t), this._pickId = void 0, this._pickPrimitive = y(e._pickPrimitive, this), this._billboardCollection = t, this._dirty = !1, this._index = -1, this._batchIndex = void 0, this._imageIndex = -1, this._imageIndexPromise = void 0, this._imageId = void 0, this._image = void 0, this._imageSubRegion = void 0, this._imageWidth = void 0, this._imageHeight = void 0, this._labelDimensions = void 0, this._labelHorizontalOrigin = void 0, this._labelTranslate = void 0; let s = e.image, a = e.imageId; l(s) && (l(a) || (typeof s == "string" ? a = s : l(s.src) ? a = s.src : a = Nn()), this._imageId = a, this._image = s), l(e.imageSubRegion) && (this._imageId = a, this._imageSubRegion = e.imageSubRegion), l(this._billboardCollection._textureAtlas) && this._loadImage(), this._actualClampedPosition = void 0, this._removeCallbackFunc = void 0, this._mode = ee.SCENE3D, this._clusterShow = !0, this._outlineColor = U.clone(y(e.outlineColor, U.BLACK)), this._outlineWidth = y(e.outlineWidth, 0), this._updateClamping() } var bte = ui.SHOW_INDEX = 0, DL = ui.POSITION_INDEX = 1, Pte = ui.PIXEL_OFFSET_INDEX = 2, RVe = ui.EYE_OFFSET_INDEX = 3, MVe = ui.HORIZONTAL_ORIGIN_INDEX = 4, LVe = ui.VERTICAL_ORIGIN_INDEX = 5, FVe = ui.SCALE_INDEX = 6, vL = ui.IMAGE_INDEX_INDEX = 7, Ste = ui.COLOR_INDEX = 8, NVe = ui.ROTATION_INDEX = 9, VVe = ui.ALIGNED_AXIS_INDEX = 10, kVe = ui.SCALE_BY_DISTANCE_INDEX = 11, UVe = ui.TRANSLUCENCY_BY_DISTANCE_INDEX = 12, zVe = ui.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX = 13, HVe = ui.DISTANCE_DISPLAY_CONDITION = 14, GVe = ui.DISABLE_DEPTH_DISTANCE = 15; ui.TEXTURE_COORDINATE_BOUNDS = 16; var wte = ui.SDF_INDEX = 17; ui.NUMBER_OF_PROPERTIES = 18; function Po(e, t) { let n = e._billboardCollection; l(n) && (n._updateBillboard(e, t), e._dirty = !0) } Object.defineProperties(ui.prototype, { show: { get: function () { return this._show }, set: function (e) { this._show !== e && (this._show = e, Po(this, bte)) } }, position: { get: function () { return this._position }, set: function (e) { let t = this._position; h.equals(t, e) || (h.clone(e, t), h.clone(e, this._actualPosition), this._updateClamping(), Po(this, DL)) } }, heightReference: { get: function () { return this._heightReference }, set: function (e) { let t = this._heightReference; e !== t && (this._heightReference = e, this._updateClamping(), Po(this, DL)) } }, pixelOffset: { get: function () { return this._pixelOffset }, set: function (e) { let t = this._pixelOffset; H.equals(t, e) || (H.clone(e, t), Po(this, Pte)) } }, scaleByDistance: { get: function () { return this._scaleByDistance }, set: function (e) { let t = this._scaleByDistance; wt.equals(t, e) || (this._scaleByDistance = wt.clone(e, t), Po(this, kVe)) } }, translucencyByDistance: { get: function () { return this._translucencyByDistance }, set: function (e) { let t = this._translucencyByDistance; wt.equals(t, e) || (this._translucencyByDistance = wt.clone(e, t), Po(this, UVe)) } }, pixelOffsetScaleByDistance: { get: function () { return this._pixelOffsetScaleByDistance }, set: function (e) { let t = this._pixelOffsetScaleByDistance; wt.equals(t, e) || (this._pixelOffsetScaleByDistance = wt.clone(e, t), Po(this, zVe)) } }, eyeOffset: { get: function () { return this._eyeOffset }, set: function (e) { let t = this._eyeOffset; h.equals(t, e) || (h.clone(e, t), Po(this, RVe)) } }, horizontalOrigin: { get: function () { return this._horizontalOrigin }, set: function (e) { this._horizontalOrigin !== e && (this._horizontalOrigin = e, Po(this, MVe)) } }, verticalOrigin: { get: function () { return this._verticalOrigin }, set: function (e) { this._verticalOrigin !== e && (this._verticalOrigin = e, Po(this, LVe)) } }, scale: { get: function () { return this._scale }, set: function (e) { this._scale !== e && (this._scale = e, Po(this, FVe)) } }, color: { get: function () { return this._color }, set: function (e) { let t = this._color; U.equals(t, e) || (U.clone(e, t), Po(this, Ste)) } }, rotation: { get: function () { return this._rotation }, set: function (e) { this._rotation !== e && (this._rotation = e, Po(this, NVe)) } }, alignedAxis: { get: function () { return this._alignedAxis }, set: function (e) { let t = this._alignedAxis; h.equals(t, e) || (h.clone(e, t), Po(this, VVe)) } }, width: { get: function () { return y(this._width, this._imageWidth) }, set: function (e) { this._width !== e && (this._width = e, Po(this, vL)) } }, height: { get: function () { return y(this._height, this._imageHeight) }, set: function (e) { this._height !== e && (this._height = e, Po(this, vL)) } }, sizeInMeters: { get: function () { return this._sizeInMeters }, set: function (e) { this._sizeInMeters !== e && (this._sizeInMeters = e, Po(this, Ste)) } }, distanceDisplayCondition: { get: function () { return this._distanceDisplayCondition }, set: function (e) { bt.equals(e, this._distanceDisplayCondition) || (this._distanceDisplayCondition = bt.clone(e, this._distanceDisplayCondition), Po(this, HVe)) } }, disableDepthTestDistance: { get: function () { return this._disableDepthTestDistance }, set: function (e) { this._disableDepthTestDistance !== e && (this._disableDepthTestDistance = e, Po(this, GVe)) } }, id: { get: function () { return this._id }, set: function (e) { this._id = e, l(this._pickId) && (this._pickId.object.id = e) } }, pickPrimitive: { get: function () { return this._pickPrimitive }, set: function (e) { this._pickPrimitive = e, l(this._pickId) && (this._pickId.object.primitive = e) } }, pickId: { get: function () { return this._pickId } }, image: { get: function () { return this._imageId }, set: function (e) { l(e) ? typeof e == "string" ? this.setImage(e, e) : e instanceof Pe ? this.setImage(e.url, e) : l(e.src) ? this.setImage(e.src, e) : this.setImage(Nn(), e) : (this._imageIndex = -1, this._imageSubRegion = void 0, this._imageId = void 0, this._image = void 0, this._imageIndexPromise = void 0, Po(this, vL)) } }, ready: { get: function () { return this._imageIndex !== -1 } }, _clampedPosition: { get: function () { return this._actualClampedPosition }, set: function (e) { this._actualClampedPosition = h.clone(e, this._actualClampedPosition), Po(this, DL) } }, clusterShow: { get: function () { return this._clusterShow }, set: function (e) { this._clusterShow !== e && (this._clusterShow = e, Po(this, bte)) } }, outlineColor: { get: function () { return this._outlineColor }, set: function (e) { let t = this._outlineColor; U.equals(t, e) || (U.clone(e, t), Po(this, wte)) } }, outlineWidth: { get: function () { return this._outlineWidth }, set: function (e) { this._outlineWidth !== e && (this._outlineWidth = e, Po(this, wte)) } } }); ui.prototype.getPickId = function (e) { return l(this._pickId) || (this._pickId = e.createPickId({ primitive: this._pickPrimitive, collection: this._collection, id: this._id })), this._pickId }; ui.prototype._updateClamping = function () { ui._updateClamping(this._billboardCollection, this) }; var kS = new he, Dte = new h; ui._updateClamping = function (e, t) { let n = e._scene; if (!l(n) || !l(n.globe)) return; let i = n.globe, o = i.ellipsoid, r = i._surface, s = n.frameState.mode, a = s !== t._mode; if (t._mode = s, (t._heightReference === ze.NONE || a) && l(t._removeCallbackFunc) && (t._removeCallbackFunc(), t._removeCallbackFunc = void 0, t._clampedPosition = void 0), t._heightReference === ze.NONE || !l(t._position)) return; let c = o.cartesianToCartographic(t._position); if (!l(c)) { t._actualClampedPosition = void 0; return } l(t._removeCallbackFunc) && t._removeCallbackFunc(); function u(d) { if (t._heightReference === ze.RELATIVE_TO_GROUND) if (t._mode === ee.SCENE3D) { let p = o.cartesianToCartographic(d, kS); p.height += c.height, o.cartographicToCartesian(p, d) } else d.x += c.height; t._clampedPosition = h.clone(d, t._clampedPosition) } t._removeCallbackFunc = r.updateHeight(c, u), he.clone(c, kS); let f = i.getHeight(c); l(f) && (kS.height = f), o.cartographicToCartesian(kS, Dte), u(Dte) }; ui.prototype._loadImage = function () { let e = this._billboardCollection._textureAtlas, t = this._imageId, n = this._image, i = this._imageSubRegion, o, r = this; function s(a) { if (r._imageId !== t || r._image !== n || !Ge.equals(r._imageSubRegion, i)) return; let c = e.textureCoordinates[a]; r._imageWidth = e.texture.width * c.width, r._imageHeight = e.texture.height * c.height, r._imageIndex = a, r._ready = !0, r._image = void 0, r._imageIndexPromise = void 0, Po(r, vL) } if (l(n)) { let a = e.getImageIndex(t); if (l(a)) { s(a); return } o = e.addImage(t, n) } l(i) && (o = e.addSubRegion(t, i)), this._imageIndexPromise = o, l(o) && o.then(s).catch(function (a) { console.error(`Error loading image for billboard: ${a}`), r._imageIndexPromise = void 0 }) }; ui.prototype.setImage = function (e, t) { this._imageId !== e && (this._imageIndex = -1, this._imageSubRegion = void 0, this._imageId = e, this._image = t, l(this._billboardCollection._textureAtlas) && this._loadImage()) }; ui.prototype.setImageSubRegion = function (e, t) { this._imageId === e && Ge.equals(this._imageSubRegion, t) || (this._imageIndex = -1, this._imageId = e, this._imageSubRegion = Ge.clone(t), l(this._billboardCollection._textureAtlas) && this._loadImage()) }; ui.prototype._setTranslate = function (e) { let t = this._translate; H.equals(t, e) || (H.clone(e, t), Po(this, Pte)) }; ui.prototype._getActualPosition = function () { return l(this._clampedPosition) ? this._clampedPosition : this._actualPosition }; ui.prototype._setActualPosition = function (e) { l(this._clampedPosition) || h.clone(e, this._actualPosition), Po(this, DL) }; var vte = new se; ui._computeActualPosition = function (e, t, n, i) { return l(e._clampedPosition) ? (n.mode !== e._mode && e._updateClamping(), e._clampedPosition) : n.mode === ee.SCENE3D ? t : (F.multiplyByPoint(i, t, vte), ji.computeActualWgs84Position(n, vte)) }; var Ite = new h; ui._computeScreenSpacePosition = function (e, t, n, i, o, r) { let s = F.multiplyByPoint(e, t, Ite), a = ji.wgs84WithEyeOffsetToWindowCoordinates(o, s, n, r); if (!!l(a)) return H.add(a, i, a), a }; var wL = new H(0, 0); ui.prototype.computeScreenSpacePosition = function (e, t) { let n = this._billboardCollection; l(t) || (t = new H), H.clone(this._pixelOffset, wL), H.add(wL, this._translate, wL); let i = n.modelMatrix, o = this._position; if (l(this._clampedPosition) && (o = this._clampedPosition, e.mode !== ee.SCENE3D)) { let s = e.mapProjection, a = s.ellipsoid, c = s.unproject(o, kS); o = a.cartographicToCartesian(c, Ite), i = F.IDENTITY } return ui._computeScreenSpacePosition(i, o, this._eyeOffset, wL, e, t) }; ui.getScreenSpaceBoundingBox = function (e, t, n) { let i = e.width, o = e.height, r = e.scale; i *= r, o *= r; let s = t.x; e.horizontalOrigin === ai.RIGHT ? s -= i : e.horizontalOrigin === ai.CENTER && (s -= i * .5); let a = t.y; return e.verticalOrigin === Sn.BOTTOM || e.verticalOrigin === Sn.BASELINE ? a -= o : e.verticalOrigin === Sn.CENTER && (a -= o * .5), l(n) || (n = new Ge), n.x = s, n.y = a, n.width = i, n.height = o, n }; ui.prototype.equals = function (e) { return this === e || l(e) && this._id === e._id && h.equals(this._position, e._position) && this._imageId === e._imageId && this._show === e._show && this._scale === e._scale && this._verticalOrigin === e._verticalOrigin && this._horizontalOrigin === e._horizontalOrigin && this._heightReference === e._heightReference && Ge.equals(this._imageSubRegion, e._imageSubRegion) && U.equals(this._color, e._color) && H.equals(this._pixelOffset, e._pixelOffset) && H.equals(this._translate, e._translate) && h.equals(this._eyeOffset, e._eyeOffset) && wt.equals(this._scaleByDistance, e._scaleByDistance) && wt.equals(this._translucencyByDistance, e._translucencyByDistance) && wt.equals(this._pixelOffsetScaleByDistance, e._pixelOffsetScaleByDistance) && bt.equals(this._distanceDisplayCondition, e._distanceDisplayCondition) && this._disableDepthTestDistance === e._disableDepthTestDistance }; ui.prototype._destroy = function () { l(this._customData) && (this._billboardCollection._scene.globe._surface.removeTileCustomData(this._customData), this._customData = void 0), l(this._removeCallbackFunc) && (this._removeCallbackFunc(), this._removeCallbackFunc = void 0), this.image = void 0, this._pickId = this._pickId && this._pickId.destroy(), this._billboardCollection = void 0 }; var co = ui; var WVe = { OPAQUE: 0, TRANSLUCENT: 1, OPAQUE_AND_TRANSLUCENT: 2 }, xo = Object.freeze(WVe); var jVe = { FONT_SIZE: 48, PADDING: 10, RADIUS: 8, CUTOFF: .25 }, bs = Object.freeze(jVe); function Rm(e, t, n, i, o) { this.bottomLeft = y(e, H.ZERO), this.topRight = y(t, H.ZERO), this.childNode1 = n, this.childNode2 = i, this.imageIndex = o } var qVe = new H(16, 16); function b_(e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.borderWidthInPixels, 1), n = y(e.initialSize, qVe); this._context = e.context, this._pixelFormat = y(e.pixelFormat, ht.RGBA), this._borderWidthInPixels = t, this._textureCoordinates = [], this._guid = Nn(), this._idHash = {}, this._indexHash = {}, this._initialSize = n, this._root = void 0 } Object.defineProperties(b_.prototype, { borderWidthInPixels: { get: function () { return this._borderWidthInPixels } }, textureCoordinates: { get: function () { return this._textureCoordinates } }, texture: { get: function () { return l(this._texture) || (this._texture = new Rt({ context: this._context, width: this._initialSize.x, height: this._initialSize.y, pixelFormat: this._pixelFormat })), this._texture } }, numberOfImages: { get: function () { return this._textureCoordinates.length } }, guid: { get: function () { return this._guid } } }); function YVe(e, t) { let n = e._context, i = e.numberOfImages, o = 2, r = e._borderWidthInPixels; if (i > 0) { let s = e._texture.width, a = e._texture.height, c = o * (s + t.width + r), u = o * (a + t.height + r), f = s / c, d = a / u, p = new Rm(new H(s + r, r), new H(c, a)), g = new Rm(new H, new H(c, a), e._root, p), m = new Rm(new H(r, a + r), new H(c, u)), A = new Rm(new H, new H(c, u), g, m); for (let T = 0; T < e._textureCoordinates.length; T++) { let b = e._textureCoordinates[T]; l(b) && (b.x *= f, b.y *= d, b.width *= f, b.height *= d) } let C = new Rt({ context: e._context, width: c, height: u, pixelFormat: e._pixelFormat }), x = new Js({ context: n, colorTextures: [e._texture], destroyAttachments: !1 }); x._bind(), C.copyFromFramebuffer(0, 0, 0, 0, c, u), x._unBind(), x.destroy(), e._texture = e._texture && e._texture.destroy(), e._texture = C, e._root = A } else { let s = o * (t.width + 2 * r), a = o * (t.height + 2 * r); s < e._initialSize.x && (s = e._initialSize.x), a < e._initialSize.y && (a = e._initialSize.y), e._texture = e._texture && e._texture.destroy(), e._texture = new Rt({ context: e._context, width: s, height: a, pixelFormat: e._pixelFormat }), e._root = new Rm(new H(r, r), new H(s, a)) } } function PL(e, t, n) { if (!!l(t)) { if (!l(t.childNode1) && !l(t.childNode2)) { if (l(t.imageIndex)) return; let i = t.topRight.x - t.bottomLeft.x, o = t.topRight.y - t.bottomLeft.y, r = i - n.width, s = o - n.height; if (r < 0 || s < 0) return; if (r === 0 && s === 0) return t; if (r > s) { t.childNode1 = new Rm(new H(t.bottomLeft.x, t.bottomLeft.y), new H(t.bottomLeft.x + n.width, t.topRight.y)); let a = t.bottomLeft.x + n.width + e._borderWidthInPixels; a < t.topRight.x && (t.childNode2 = new Rm(new H(a, t.bottomLeft.y), new H(t.topRight.x, t.topRight.y))) } else { t.childNode1 = new Rm(new H(t.bottomLeft.x, t.bottomLeft.y), new H(t.topRight.x, t.bottomLeft.y + n.height)); let a = t.bottomLeft.y + n.height + e._borderWidthInPixels; a < t.topRight.y && (t.childNode2 = new Rm(new H(t.bottomLeft.x, a), new H(t.topRight.x, t.topRight.y))) } return PL(e, t.childNode1, n) } return PL(e, t.childNode1, n) || PL(e, t.childNode2, n) } } function Ote(e, t, n) { let i = PL(e, e._root, t); if (l(i)) { i.imageIndex = n; let o = e._texture.width, r = e._texture.height, s = i.topRight.x - i.bottomLeft.x, a = i.topRight.y - i.bottomLeft.y, c = i.bottomLeft.x / o, u = i.bottomLeft.y / r, f = s / o, d = a / r; e._textureCoordinates[n] = new Ge(c, u, f, d), e._texture.copyFrom({ source: t, xOffset: i.bottomLeft.x, yOffset: i.bottomLeft.y }) } else YVe(e, t), Ote(e, t, n); e._guid = Nn() } function Bte(e, t) { if (!l(e) || e.isDestroyed()) return -1; let n = e.numberOfImages; return Ote(e, t, n), n } b_.prototype.getImageIndex = function (e) { return this._indexHash[e] }; b_.prototype.addImageSync = function (e, t) { let n = this._indexHash[e]; return l(n) || (n = Bte(this, t), this._idHash[e] = Promise.resolve(n), this._indexHash[e] = n), n }; b_.prototype.addImage = function (e, t) { let n = this._idHash[e]; if (l(n)) return n; typeof t == "function" ? t = t(e) : (typeof t == "string" || t instanceof Pe) && (t = Pe.createIfNeeded(t).fetchImage()); let i = this; return n = Promise.resolve(t).then(function (o) { let r = Bte(i, o); return i._indexHash[e] = r, r }), this._idHash[e] = n, n }; b_.prototype.addSubRegion = function (e, t) { let n = this._idHash[e]; if (!l(n)) throw new fe(`image with id "${e}" not found in the atlas.`); let i = this; return Promise.resolve(n).then(function (o) { if (o === -1) return -1; let r = i._texture.width, s = i._texture.height, a = i.numberOfImages, c = i._textureCoordinates[o], u = c.x + t.x / r, f = c.y + t.y / s, d = t.width / r, p = t.height / s; return i._textureCoordinates.push(new Ge(u, f, d, p)), i._guid = Nn(), a }) }; b_.prototype.isDestroyed = function () { return !1 }; b_.prototype.destroy = function () { return this._texture = this._texture && this._texture.destroy(), le(this) }; var Q0 = b_; var XVe = co.SHOW_INDEX, zS = co.POSITION_INDEX, Rte = co.PIXEL_OFFSET_INDEX, Mte = co.EYE_OFFSET_INDEX, KVe = co.HORIZONTAL_ORIGIN_INDEX, JVe = co.VERTICAL_ORIGIN_INDEX, ZVe = co.SCALE_INDEX, US = co.IMAGE_INDEX_INDEX, Lte = co.COLOR_INDEX, QVe = co.ROTATION_INDEX, $Ve = co.ALIGNED_AXIS_INDEX, Fte = co.SCALE_BY_DISTANCE_INDEX, Nte = co.TRANSLUCENCY_BY_DISTANCE_INDEX, Vte = co.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX, kte = co.DISTANCE_DISPLAY_CONDITION, eke = co.DISABLE_DEPTH_DISTANCE, tke = co.TEXTURE_COORDINATE_BOUNDS, Ute = co.SDF_INDEX, Q8 = co.NUMBER_OF_PROPERTIES, lo, nke = { positionHighAndScale: 0, positionLowAndRotation: 1, compressedAttribute0: 2, compressedAttribute1: 3, compressedAttribute2: 4, eyeOffset: 5, scaleByDistance: 6, pixelOffsetScaleByDistance: 7, compressedAttribute3: 8, textureCoordinateBoundsOrLabelTranslate: 9, a_batchId: 10, sdf: 11 }, ike = { direction: 0, positionHighAndScale: 1, positionLowAndRotation: 2, compressedAttribute0: 3, compressedAttribute1: 4, compressedAttribute2: 5, eyeOffset: 6, scaleByDistance: 7, pixelOffsetScaleByDistance: 8, compressedAttribute3: 9, textureCoordinateBoundsOrLabelTranslate: 10, a_batchId: 11, sdf: 12 }; function gu(e) { e = y(e, y.EMPTY_OBJECT), this._scene = e.scene, this._batchTable = e.batchTable, this._textureAtlas = void 0, this._textureAtlasGUID = void 0, this._destroyTextureAtlas = !0, this._sp = void 0, this._spTranslucent = void 0, this._rsOpaque = void 0, this._rsTranslucent = void 0, this._vaf = void 0, this._billboards = [], this._billboardsToUpdate = [], this._billboardsToUpdateIndex = 0, this._billboardsRemoved = !1, this._createVertexArray = !1, this._shaderRotation = !1, this._compiledShaderRotation = !1, this._shaderAlignedAxis = !1, this._compiledShaderAlignedAxis = !1, this._shaderScaleByDistance = !1, this._compiledShaderScaleByDistance = !1, this._shaderTranslucencyByDistance = !1, this._compiledShaderTranslucencyByDistance = !1, this._shaderPixelOffsetScaleByDistance = !1, this._compiledShaderPixelOffsetScaleByDistance = !1, this._shaderDistanceDisplayCondition = !1, this._compiledShaderDistanceDisplayCondition = !1, this._shaderDisableDepthDistance = !1, this._compiledShaderDisableDepthDistance = !1, this._shaderClampToGround = !1, this._compiledShaderClampToGround = !1, this._propertiesChanged = new Uint32Array(Q8), this._maxSize = 0, this._maxEyeOffset = 0, this._maxScale = 1, this._maxPixelOffset = 0, this._allHorizontalCenter = !0, this._allVerticalCenter = !0, this._allSizedInMeters = !0, this._baseVolume = new re, this._baseVolumeWC = new re, this._baseVolume2D = new re, this._boundingVolume = new re, this._boundingVolumeDirty = !1, this._colorCommands = [], this.show = y(e.show, !0), this.modelMatrix = F.clone(y(e.modelMatrix, F.IDENTITY)), this._modelMatrix = F.clone(F.IDENTITY), this.debugShowBoundingVolume = y(e.debugShowBoundingVolume, !1), this.debugShowTextureAtlas = y(e.debugShowTextureAtlas, !1), this.blendOption = y(e.blendOption, xo.OPAQUE_AND_TRANSLUCENT), this._blendOption = void 0, this._mode = ee.SCENE3D, this._buffersUsage = [Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW], this._highlightColor = U.clone(U.WHITE); let t = this; this._uniforms = { u_atlas: function () { return t._textureAtlas.texture }, u_highlightColor: function () { return t._highlightColor } }; let n = this._scene; l(n) && l(n.terrainProviderChanged) && (this._removeCallbackFunc = n.terrainProviderChanged.addEventListener(function () { let i = this._billboards, o = i.length; for (let r = 0; r < o; ++r)l(i[r]) && i[r]._updateClamping() }, this)) } Object.defineProperties(gu.prototype, { length: { get: function () { return $8(this), this._billboards.length } }, textureAtlas: { get: function () { return this._textureAtlas }, set: function (e) { this._textureAtlas !== e && (this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy(), this._textureAtlas = e, this._createVertexArray = !0) } }, destroyTextureAtlas: { get: function () { return this._destroyTextureAtlas }, set: function (e) { this._destroyTextureAtlas = e } } }); function zte(e) { let t = e.length; for (let n = 0; n < t; ++n)e[n] && e[n]._destroy() } gu.prototype.add = function (e) { let t = new co(e, this); return t._index = this._billboards.length, this._billboards.push(t), this._createVertexArray = !0, t }; gu.prototype.remove = function (e) { return this.contains(e) ? (this._billboards[e._index] = void 0, this._billboardsRemoved = !0, this._createVertexArray = !0, e._destroy(), !0) : !1 }; gu.prototype.removeAll = function () { zte(this._billboards), this._billboards = [], this._billboardsToUpdate = [], this._billboardsToUpdateIndex = 0, this._billboardsRemoved = !1, this._createVertexArray = !0 }; function $8(e) { if (e._billboardsRemoved) { e._billboardsRemoved = !1; let t = [], n = e._billboards, i = n.length; for (let o = 0, r = 0; o < i; ++o) { let s = n[o]; l(s) && (s._index = r++, t.push(s)) } e._billboards = t } } gu.prototype._updateBillboard = function (e, t) { e._dirty || (this._billboardsToUpdate[this._billboardsToUpdateIndex++] = e), ++this._propertiesChanged[t] }; gu.prototype.contains = function (e) { return l(e) && e._billboardCollection === this }; gu.prototype.get = function (e) { return $8(this), this._billboards[e] }; var q8; function oke(e) { let n = e.cache.billboardCollection_indexBufferBatched; if (l(n)) return n; let i = 16384 * 6 - 6, o = new Uint16Array(i); for (let r = 0, s = 0; r < i; r += 6, s += 4)o[r] = s, o[r + 1] = s + 1, o[r + 2] = s + 2, o[r + 3] = s + 0, o[r + 4] = s + 2, o[r + 5] = s + 3; return n = ct.createIndexBuffer({ context: e, typedArray: o, usage: Re.STATIC_DRAW, indexDatatype: Me.UNSIGNED_SHORT }), n.vertexArrayDestroyable = !1, e.cache.billboardCollection_indexBufferBatched = n, n } function rke(e) { let t = e.cache.billboardCollection_indexBufferInstanced; return l(t) || (t = ct.createIndexBuffer({ context: e, typedArray: new Uint16Array([0, 1, 2, 0, 2, 3]), usage: Re.STATIC_DRAW, indexDatatype: Me.UNSIGNED_SHORT }), t.vertexArrayDestroyable = !1, e.cache.billboardCollection_indexBufferInstanced = t), t } function ske(e) { let t = e.cache.billboardCollection_vertexBufferInstanced; return l(t) || (t = ct.createVertexBuffer({ context: e, typedArray: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), usage: Re.STATIC_DRAW }), t.vertexArrayDestroyable = !1, e.cache.billboardCollection_vertexBufferInstanced = t), t } gu.prototype.computeNewBuffersUsage = function () { let e = this._buffersUsage, t = !1, n = this._propertiesChanged; for (let i = 0; i < Q8; ++i) { let o = n[i] === 0 ? Re.STATIC_DRAW : Re.STREAM_DRAW; t = t || e[i] !== o, e[i] = o } return t }; function ake(e, t, n, i, o, r) { let s = [{ index: lo.positionHighAndScale, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: n[zS] }, { index: lo.positionLowAndRotation, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: n[zS] }, { index: lo.compressedAttribute0, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: n[Rte] }, { index: lo.compressedAttribute1, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: n[Nte] }, { index: lo.compressedAttribute2, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: n[Lte] }, { index: lo.eyeOffset, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: n[Mte] }, { index: lo.scaleByDistance, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: n[Fte] }, { index: lo.pixelOffsetScaleByDistance, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: n[Vte] }, { index: lo.compressedAttribute3, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: n[kte] }, { index: lo.textureCoordinateBoundsOrLabelTranslate, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: n[tke] }]; i && s.push({ index: lo.direction, componentsPerAttribute: 2, componentDatatype: Y.FLOAT, vertexBuffer: ske(e) }), l(o) && s.push({ index: lo.a_batchId, componentsPerAttribute: 1, componentDatatype: Y.FLOAT, bufferUsage: Re.STATIC_DRAW }), r && s.push({ index: lo.sdf, componentsPerAttribute: 2, componentDatatype: Y.FLOAT, usage: n[Ute] }); let a = i ? t : 4 * t; return new E_(e, s, a, i) } var Y8 = new Vn; function Hte(e, t, n, i, o) { let r, s = i[lo.positionHighAndScale], a = i[lo.positionLowAndRotation], c = o._getActualPosition(); e._mode === ee.SCENE3D && (re.expand(e._baseVolume, c, e._baseVolume), e._boundingVolumeDirty = !0), Vn.fromCartesian(c, Y8); let u = o.scale, f = o.rotation; f !== 0 && (e._shaderRotation = !0), e._maxScale = Math.max(e._maxScale, u); let d = Y8.high, p = Y8.low; e._instanced ? (r = o._index, s(r, d.x, d.y, d.z, u), a(r, p.x, p.y, p.z, f)) : (r = o._index * 4, s(r + 0, d.x, d.y, d.z, u), s(r + 1, d.x, d.y, d.z, u), s(r + 2, d.x, d.y, d.z, u), s(r + 3, d.x, d.y, d.z, u), a(r + 0, p.x, p.y, p.z, f), a(r + 1, p.x, p.y, p.z, f), a(r + 2, p.x, p.y, p.z, f), a(r + 3, p.x, p.y, p.z, f)) } var _u = new H, pu = 32768, _x = 65536, X8 = 4096, Zd = 256, cke = 128, lke = 32, uke = 8, Gte = 4, fke = 1 / 256, Wte = 0, jte = 2, qte = 3, Yte = 1; function Xte(e, t, n, i, o) { let r, s = i[lo.compressedAttribute0], a = o.pixelOffset, c = a.x, u = a.y, f = o._translate, d = f.x, p = f.y; e._maxPixelOffset = Math.max(e._maxPixelOffset, Math.abs(c + d), Math.abs(-u + p)); let g = o.horizontalOrigin, m = o._verticalOrigin, A = o.show && o.clusterShow; o.color.alpha === 0 && (A = !1), m === Sn.BASELINE && (m = Sn.BOTTOM), e._allHorizontalCenter = e._allHorizontalCenter && g === ai.CENTER, e._allVerticalCenter = e._allVerticalCenter && m === Sn.CENTER; let C = 0, x = 0, T = 0, b = 0, S = o._imageIndex; if (S !== -1) { let z = n[S]; C = z.x, x = z.y, T = z.width, b = z.height } let D = C + T, P = x + b, B = Math.floor(I.clamp(c, -pu, pu) + pu) * cke; B += (g + 1) * lke, B += (m + 1) * uke, B += (A ? 1 : 0) * Gte; let R = Math.floor(I.clamp(u, -pu, pu) + pu) * Zd, M = Math.floor(I.clamp(d, -pu, pu) + pu) * Zd, L = (I.clamp(p, -pu, pu) + pu) * fke, _ = Math.floor(L), E = Math.floor((L - _) * Zd); R += _, M += E, _u.x = C, _u.y = x; let w = kn.compressTextureCoordinates(_u); _u.x = D; let v = kn.compressTextureCoordinates(_u); _u.y = P; let O = kn.compressTextureCoordinates(_u); _u.x = C; let V = kn.compressTextureCoordinates(_u); e._instanced ? (r = o._index, s(r, B, R, M, w)) : (r = o._index * 4, s(r + 0, B + Wte, R, M, w), s(r + 1, B + jte, R, M, v), s(r + 2, B + qte, R, M, O), s(r + 3, B + Yte, R, M, V)) } function Kte(e, t, n, i, o) { let r, s = i[lo.compressedAttribute1], a = o.alignedAxis; h.equals(a, h.ZERO) || (e._shaderAlignedAxis = !0); let c = 0, u = 1, f = 1, d = 1, p = o.translucencyByDistance; l(p) && (c = p.near, u = p.nearValue, f = p.far, d = p.farValue, (u !== 1 || d !== 1) && (e._shaderTranslucencyByDistance = !0)); let g = 0, m = o._imageIndex; m !== -1 && (g = n[m].width); let A = e._textureAtlas.texture.width, C = Math.round(y(o.width, A * g)); e._maxSize = Math.max(e._maxSize, C); let x = I.clamp(C, 0, _x), T = 0; Math.abs(h.magnitudeSquared(a) - 1) < I.EPSILON6 && (T = kn.octEncodeFloat(a)), u = I.clamp(u, 0, 1), u = u === 1 ? 255 : u * 255 | 0, x = x * Zd + u, d = I.clamp(d, 0, 1), d = d === 1 ? 255 : d * 255 | 0, T = T * Zd + d, e._instanced ? (r = o._index, s(r, x, T, c, f)) : (r = o._index * 4, s(r + 0, x, T, c, f), s(r + 1, x, T, c, f), s(r + 2, x, T, c, f), s(r + 3, x, T, c, f)) } function J8(e, t, n, i, o) { let r, s = i[lo.compressedAttribute2], a = o.color, c = l(e._batchTable) ? U.WHITE : o.getPickId(t.context).color, u = o.sizeInMeters ? 1 : 0, f = Math.abs(h.magnitudeSquared(o.alignedAxis) - 1) < I.EPSILON6 ? 1 : 0; e._allSizedInMeters = e._allSizedInMeters && u === 1; let d = 0, p = o._imageIndex; p !== -1 && (d = n[p].height); let g = e._textureAtlas.texture.dimensions, m = Math.round(y(o.height, g.y * d)); e._maxSize = Math.max(e._maxSize, m); let A = y(o._labelHorizontalOrigin, -2); A += 2; let C = m * Gte + A, x = U.floatToByte(a.red), T = U.floatToByte(a.green), b = U.floatToByte(a.blue), S = x * _x + T * Zd + b; x = U.floatToByte(c.red), T = U.floatToByte(c.green), b = U.floatToByte(c.blue); let D = x * _x + T * Zd + b, P = U.floatToByte(a.alpha) * _x + U.floatToByte(c.alpha) * Zd; P += u * 2 + f, e._instanced ? (r = o._index, s(r, S, D, P, C)) : (r = o._index * 4, s(r + 0, S, D, P, C), s(r + 1, S, D, P, C), s(r + 2, S, D, P, C), s(r + 3, S, D, P, C)) } function Z8(e, t, n, i, o) { let r, s = i[lo.eyeOffset], a = o.eyeOffset, c = a.z; if (o._heightReference !== ze.NONE && (c *= 1.005), e._maxEyeOffset = Math.max(e._maxEyeOffset, Math.abs(a.x), Math.abs(a.y), Math.abs(c)), e._instanced) { let u = 0, f = 0, d = o._imageIndex; if (d !== -1) { let g = n[d]; u = g.width, f = g.height } _u.x = u, _u.y = f; let p = kn.compressTextureCoordinates(_u); r = o._index, s(r, a.x, a.y, c, p) } else r = o._index * 4, s(r + 0, a.x, a.y, c, 0), s(r + 1, a.x, a.y, c, 0), s(r + 2, a.x, a.y, c, 0), s(r + 3, a.x, a.y, c, 0) } function Jte(e, t, n, i, o) { let r, s = i[lo.scaleByDistance], a = 0, c = 1, u = 1, f = 1, d = o.scaleByDistance; l(d) && (a = d.near, c = d.nearValue, u = d.far, f = d.farValue, (c !== 1 || f !== 1) && (e._shaderScaleByDistance = !0)), e._instanced ? (r = o._index, s(r, a, c, u, f)) : (r = o._index * 4, s(r + 0, a, c, u, f), s(r + 1, a, c, u, f), s(r + 2, a, c, u, f), s(r + 3, a, c, u, f)) } function Zte(e, t, n, i, o) { let r, s = i[lo.pixelOffsetScaleByDistance], a = 0, c = 1, u = 1, f = 1, d = o.pixelOffsetScaleByDistance; l(d) && (a = d.near, c = d.nearValue, u = d.far, f = d.farValue, (c !== 1 || f !== 1) && (e._shaderPixelOffsetScaleByDistance = !0)), e._instanced ? (r = o._index, s(r, a, c, u, f)) : (r = o._index * 4, s(r + 0, a, c, u, f), s(r + 1, a, c, u, f), s(r + 2, a, c, u, f), s(r + 3, a, c, u, f)) } function Qte(e, t, n, i, o) { let r, s = i[lo.compressedAttribute3], a = 0, c = Number.MAX_VALUE, u = o.distanceDisplayCondition; l(u) && (a = u.near, c = u.far, a *= a, c *= c, e._shaderDistanceDisplayCondition = !0); let f = o.disableDepthTestDistance, d = o.heightReference === ze.CLAMP_TO_GROUND && t.context.depthTexture; l(f) || (f = d ? 5e3 : 0), f *= f, (d || f > 0) && (e._shaderDisableDepthDistance = !0, f === Number.POSITIVE_INFINITY && (f = -1)); let p, g; if (l(o._labelDimensions)) g = o._labelDimensions.x, p = o._labelDimensions.y; else { let x = 0, T = 0, b = o._imageIndex; if (b !== -1) { let D = n[b]; x = D.height, T = D.width } p = Math.round(y(o.height, e._textureAtlas.texture.dimensions.y * x)); let S = e._textureAtlas.texture.width; g = Math.round(y(o.width, S * T)) } let m = Math.floor(I.clamp(g, 0, X8)), A = Math.floor(I.clamp(p, 0, X8)), C = m * X8 + A; e._instanced ? (r = o._index, s(r, a, c, f, C)) : (r = o._index * 4, s(r + 0, a, c, f, C), s(r + 1, a, c, f, C), s(r + 2, a, c, f, C), s(r + 3, a, c, f, C)) } function $te(e, t, n, i, o) { if (o.heightReference === ze.CLAMP_TO_GROUND) { let m = e._scene, A = t.context, C = t.globeTranslucencyState.translucent, x = l(m.globe) && m.globe.depthTestAgainstTerrain; e._shaderClampToGround = A.depthTexture && !C && x } let r, s = i[lo.textureCoordinateBoundsOrLabelTranslate]; if (Ut.maximumVertexTextureImageUnits > 0) { let m = 0, A = 0; l(o._labelTranslate) && (m = o._labelTranslate.x, A = o._labelTranslate.y), e._instanced ? (r = o._index, s(r, m, A, 0, 0)) : (r = o._index * 4, s(r + 0, m, A, 0, 0), s(r + 1, m, A, 0, 0), s(r + 2, m, A, 0, 0), s(r + 3, m, A, 0, 0)); return } let a = 0, c = 0, u = 0, f = 0, d = o._imageIndex; if (d !== -1) { let m = n[d]; a = m.x, c = m.y, u = m.width, f = m.height } let p = a + u, g = c + f; e._instanced ? (r = o._index, s(r, a, c, p, g)) : (r = o._index * 4, s(r + 0, a, c, p, g), s(r + 1, a, c, p, g), s(r + 2, a, c, p, g), s(r + 3, a, c, p, g)) } function dke(e, t, n, i, o) { if (!l(e._batchTable)) return; let r = i[lo.a_batchId], s = o._batchIndex, a; e._instanced ? (a = o._index, r(a, s)) : (a = o._index * 4, r(a + 0, s), r(a + 1, s), r(a + 2, s), r(a + 3, s)) } function ene(e, t, n, i, o) { if (!e._sdf) return; let r, s = i[lo.sdf], a = o.outlineColor, c = o.outlineWidth, u = U.floatToByte(a.red), f = U.floatToByte(a.green), d = U.floatToByte(a.blue), p = u * _x + f * Zd + d, g = c / bs.RADIUS, m = U.floatToByte(a.alpha) * _x + U.floatToByte(g) * Zd; e._instanced ? (r = o._index, s(r, p, m)) : (r = o._index * 4, s(r + 0, p + Wte, m), s(r + 1, p + jte, m), s(r + 2, p + qte, m), s(r + 3, p + Yte, m)) } function hke(e, t, n, i, o) { Hte(e, t, n, i, o), Xte(e, t, n, i, o), Kte(e, t, n, i, o), J8(e, t, n, i, o), Z8(e, t, n, i, o), Jte(e, t, n, i, o), Zte(e, t, n, i, o), Qte(e, t, n, i, o), $te(e, t, n, i, o), dke(e, t, n, i, o), ene(e, t, n, i, o) } function K8(e, t, n, i, o, r) { let s; i.mode === ee.SCENE3D ? (s = e._baseVolume, e._boundingVolumeDirty = !0) : s = e._baseVolume2D; let a = []; for (let c = 0; c < n; ++c) { let u = t[c], f = u.position, d = co._computeActualPosition(u, f, i, o); l(d) && (u._setActualPosition(d), r ? a.push(d) : re.expand(s, d, s)) } r && re.fromPoints(a, s) } function mke(e, t) { let n = t.mode, i = e._billboards, o = e._billboardsToUpdate, r = e._modelMatrix; e._createVertexArray || e._mode !== n || n !== ee.SCENE3D && !F.equals(r, e.modelMatrix) ? (e._mode = n, F.clone(e.modelMatrix, r), e._createVertexArray = !0, (n === ee.SCENE3D || n === ee.SCENE2D || n === ee.COLUMBUS_VIEW) && K8(e, i, i.length, t, r, !0)) : n === ee.MORPHING ? K8(e, i, i.length, t, r, !0) : (n === ee.SCENE2D || n === ee.COLUMBUS_VIEW) && K8(e, o, e._billboardsToUpdateIndex, t, r, !1) } function pke(e, t, n) { let i = 1; (!e._allSizedInMeters || e._maxPixelOffset !== 0) && (i = t.camera.getPixelSize(n, t.context.drawingBufferWidth, t.context.drawingBufferHeight)); let o = i * e._maxScale * e._maxSize * 2; e._allHorizontalCenter && e._allVerticalCenter && (o *= .5); let r = i * e._maxPixelOffset + e._maxEyeOffset; n.radius += o + r } function _ke(e, t) {
        let n = `uniform sampler2D billboard_texture; 
varying vec2 v_textureCoordinates; 
void main() 
{ 
    gl_FragColor = texture2D(billboard_texture, v_textureCoordinates); 
} 
`, i = t.createViewportQuadCommand(n, { uniformMap: { billboard_texture: function () { return e._textureAtlas.texture } } }); return i.pass = xe.OVERLAY, i
    } var gke = []; gu.prototype.update = function (e) { if ($8(this), !this.show) return; let t = this._billboards, n = t.length, i = e.context; this._instanced = i.instancedArrays, lo = this._instanced ? ike : nke, q8 = this._instanced ? rke : oke; let o = this._textureAtlas; if (!l(o)) { o = this._textureAtlas = new Q0({ context: i }); for (let R = 0; R < n; ++R)t[R]._loadImage() } let r = o.textureCoordinates; if (r.length === 0) return; mke(this, e), t = this._billboards, n = t.length; let s = this._billboardsToUpdate, a = this._billboardsToUpdateIndex, c = this._propertiesChanged, u = o.guid, f = this._createVertexArray || this._textureAtlasGUID !== u; this._textureAtlasGUID = u; let d, p = e.passes, g = p.pick; if (f || !g && this.computeNewBuffersUsage()) { this._createVertexArray = !1; for (let R = 0; R < Q8; ++R)c[R] = 0; if (this._vaf = this._vaf && this._vaf.destroy(), n > 0) { this._vaf = ake(i, n, this._buffersUsage, this._instanced, this._batchTable, this._sdf), d = this._vaf.writers; for (let R = 0; R < n; ++R) { let M = this._billboards[R]; M._dirty = !1, hke(this, e, r, d, M) } this._vaf.commit(q8(i)) } this._billboardsToUpdateIndex = 0 } else if (a > 0) { let R = gke; R.length = 0, (c[zS] || c[QVe] || c[ZVe]) && R.push(Hte), (c[US] || c[Rte] || c[KVe] || c[JVe] || c[XVe]) && (R.push(Xte), this._instanced && R.push(Z8)), (c[US] || c[$Ve] || c[Nte]) && (R.push(Kte), R.push(J8)), (c[US] || c[Lte]) && R.push(J8), c[Mte] && R.push(Z8), c[Fte] && R.push(Jte), c[Vte] && R.push(Zte), (c[kte] || c[eke] || c[US] || c[zS]) && R.push(Qte), (c[US] || c[zS]) && R.push($te), c[Ute] && R.push(ene); let M = R.length; if (d = this._vaf.writers, a / n > .1) { for (let L = 0; L < a; ++L) { let _ = s[L]; _._dirty = !1; for (let E = 0; E < M; ++E)R[E](this, e, r, d, _) } this._vaf.commit(q8(i)) } else { for (let L = 0; L < a; ++L) { let _ = s[L]; _._dirty = !1; for (let E = 0; E < M; ++E)R[E](this, e, r, d, _); this._instanced ? this._vaf.subCommit(_._index, 1) : this._vaf.subCommit(_._index * 4, 4) } this._vaf.endSubCommits() } this._billboardsToUpdateIndex = 0 } if (a > n * 1.5 && (s.length = n), !l(this._vaf) || !l(this._vaf.va)) return; this._boundingVolumeDirty && (this._boundingVolumeDirty = !1, re.transform(this._baseVolume, this.modelMatrix, this._baseVolumeWC)); let m, A = F.IDENTITY; e.mode === ee.SCENE3D ? (A = this.modelMatrix, m = re.clone(this._baseVolumeWC, this._boundingVolume)) : m = re.clone(this._baseVolume2D, this._boundingVolume), pke(this, e, m); let C = this._blendOption !== this.blendOption; if (this._blendOption = this.blendOption, C) { this._blendOption === xo.OPAQUE || this._blendOption === xo.OPAQUE_AND_TRANSLUCENT ? this._rsOpaque = Ve.fromCache({ depthTest: { enabled: !0, func: te.LESS }, depthMask: !0 }) : this._rsOpaque = void 0; let R = this._blendOption === xo.TRANSLUCENT; this._blendOption === xo.TRANSLUCENT || this._blendOption === xo.OPAQUE_AND_TRANSLUCENT ? this._rsTranslucent = Ve.fromCache({ depthTest: { enabled: !0, func: R ? te.LEQUAL : te.LESS }, depthMask: R, blending: an.ALPHA_BLEND }) : this._rsTranslucent = void 0 } this._shaderDisableDepthDistance = this._shaderDisableDepthDistance || e.minimumDisableDepthTestDistance !== 0; let x, T, b, S, D, P = Ut.maximumVertexTextureImageUnits > 0; if (C || this._shaderRotation !== this._compiledShaderRotation || this._shaderAlignedAxis !== this._compiledShaderAlignedAxis || this._shaderScaleByDistance !== this._compiledShaderScaleByDistance || this._shaderTranslucencyByDistance !== this._compiledShaderTranslucencyByDistance || this._shaderPixelOffsetScaleByDistance !== this._compiledShaderPixelOffsetScaleByDistance || this._shaderDistanceDisplayCondition !== this._compiledShaderDistanceDisplayCondition || this._shaderDisableDepthDistance !== this._compiledShaderDisableDepthDistance || this._shaderClampToGround !== this._compiledShaderClampToGround || this._sdf !== this._compiledSDF) { x = SL, T = bL, D = [], l(this._batchTable) && (D.push("VECTOR_TILE"), x = this._batchTable.getVertexShaderCallback(!1, "a_batchId", void 0)(x), T = this._batchTable.getFragmentShaderCallback(!1, void 0)(T)), b = new Ue({ defines: D, sources: [x] }), this._instanced && b.defines.push("INSTANCED"), this._shaderRotation && b.defines.push("ROTATION"), this._shaderAlignedAxis && b.defines.push("ALIGNED_AXIS"), this._shaderScaleByDistance && b.defines.push("EYE_DISTANCE_SCALING"), this._shaderTranslucencyByDistance && b.defines.push("EYE_DISTANCE_TRANSLUCENCY"), this._shaderPixelOffsetScaleByDistance && b.defines.push("EYE_DISTANCE_PIXEL_OFFSET"), this._shaderDistanceDisplayCondition && b.defines.push("DISTANCE_DISPLAY_CONDITION"), this._shaderDisableDepthDistance && b.defines.push("DISABLE_DEPTH_DISTANCE"), this._shaderClampToGround && (P ? b.defines.push("VERTEX_DEPTH_CHECK") : b.defines.push("FRAGMENT_DEPTH_CHECK")); let R = 1 - bs.CUTOFF; this._sdf && b.defines.push("SDF"); let M = l(this._batchTable) ? "VECTOR_TILE" : ""; this._blendOption === xo.OPAQUE_AND_TRANSLUCENT && (S = new Ue({ defines: ["OPAQUE", M], sources: [T] }), this._shaderClampToGround && (P ? S.defines.push("VERTEX_DEPTH_CHECK") : S.defines.push("FRAGMENT_DEPTH_CHECK")), this._sdf && (S.defines.push("SDF"), S.defines.push(`SDF_EDGE ${R}`)), this._sp = qt.replaceCache({ context: i, shaderProgram: this._sp, vertexShaderSource: b, fragmentShaderSource: S, attributeLocations: lo }), S = new Ue({ defines: ["TRANSLUCENT", M], sources: [T] }), this._shaderClampToGround && (P ? S.defines.push("VERTEX_DEPTH_CHECK") : S.defines.push("FRAGMENT_DEPTH_CHECK")), this._sdf && (S.defines.push("SDF"), S.defines.push(`SDF_EDGE ${R}`)), this._spTranslucent = qt.replaceCache({ context: i, shaderProgram: this._spTranslucent, vertexShaderSource: b, fragmentShaderSource: S, attributeLocations: lo })), this._blendOption === xo.OPAQUE && (S = new Ue({ defines: [M], sources: [T] }), this._shaderClampToGround && (P ? S.defines.push("VERTEX_DEPTH_CHECK") : S.defines.push("FRAGMENT_DEPTH_CHECK")), this._sdf && (S.defines.push("SDF"), S.defines.push(`SDF_EDGE ${R}`)), this._sp = qt.replaceCache({ context: i, shaderProgram: this._sp, vertexShaderSource: b, fragmentShaderSource: S, attributeLocations: lo })), this._blendOption === xo.TRANSLUCENT && (S = new Ue({ defines: [M], sources: [T] }), this._shaderClampToGround && (P ? S.defines.push("VERTEX_DEPTH_CHECK") : S.defines.push("FRAGMENT_DEPTH_CHECK")), this._sdf && (S.defines.push("SDF"), S.defines.push(`SDF_EDGE ${R}`)), this._spTranslucent = qt.replaceCache({ context: i, shaderProgram: this._spTranslucent, vertexShaderSource: b, fragmentShaderSource: S, attributeLocations: lo })), this._compiledShaderRotation = this._shaderRotation, this._compiledShaderAlignedAxis = this._shaderAlignedAxis, this._compiledShaderScaleByDistance = this._shaderScaleByDistance, this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance, this._compiledShaderPixelOffsetScaleByDistance = this._shaderPixelOffsetScaleByDistance, this._compiledShaderDistanceDisplayCondition = this._shaderDistanceDisplayCondition, this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance, this._compiledShaderClampToGround = this._shaderClampToGround, this._compiledSDF = this._sdf } let B = e.commandList; if (p.render || p.pick) { let R = this._colorCommands, M = this._blendOption === xo.OPAQUE, L = this._blendOption === xo.OPAQUE_AND_TRANSLUCENT, _ = this._vaf.va, E = _.length, w = this._uniforms, v; l(this._batchTable) ? (w = this._batchTable.getUniformMapCallback()(w), v = this._batchTable.getPickId()) : v = "v_pickColor", R.length = E; let O = L ? E * 2 : E; for (let V = 0; V < O; ++V) { let z = R[V]; l(z) || (z = R[V] = new $e); let k = M || L && V % 2 === 0; z.pass = k || !L ? xe.OPAQUE : xe.TRANSLUCENT, z.owner = this; let G = L ? Math.floor(V / 2) : V; z.boundingVolume = m, z.modelMatrix = A, z.count = _[G].indicesCount, z.shaderProgram = k ? this._sp : this._spTranslucent, z.uniformMap = w, z.vertexArray = _[G].va, z.renderState = k ? this._rsOpaque : this._rsTranslucent, z.debugShowBoundingVolume = this.debugShowBoundingVolume, z.pickId = v, this._instanced && (z.count = 6, z.instanceCount = n), B.push(z) } this.debugShowTextureAtlas && (l(this.debugCommand) || (this.debugCommand = _ke(this, e.context)), B.push(this.debugCommand)) } }; gu.prototype.isDestroyed = function () { return !1 }; gu.prototype.destroy = function () { return l(this._removeCallbackFunc) && (this._removeCallbackFunc(), this._removeCallbackFunc = void 0), this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy(), this._sp = this._sp && this._sp.destroy(), this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy(), this._vaf = this._vaf && this._vaf.destroy(), zte(this._billboards), le(this) }; var yu = gu; function yke(e, t, n, i, o) { return function () { let r = document.createElement("canvas"), s = o + 2 * i; r.height = r.width = s; let a = r.getContext("2d"); return a.clearRect(0, 0, s, s), i !== 0 && (a.beginPath(), a.arc(s / 2, s / 2, s / 2, 0, 2 * Math.PI, !0), a.closePath(), a.fillStyle = n, a.fill(), e < 1 && (a.save(), a.globalCompositeOperation = "destination-out", a.beginPath(), a.arc(s / 2, s / 2, o / 2, 0, 2 * Math.PI, !0), a.closePath(), a.fillStyle = "black", a.fill(), a.restore())), a.beginPath(), a.arc(s / 2, s / 2, o / 2, 0, 2 * Math.PI, !0), a.closePath(), a.fillStyle = t, a.fill(), r } } var gx = yke; function Ss(e, t, n, i, o) { this._content = e, this._billboard = n, this._label = i, this._polyline = o, this._batchId = t, this._billboardImage = void 0, this._billboardColor = void 0, this._billboardOutlineColor = void 0, this._billboardOutlineWidth = void 0, this._billboardSize = void 0, this._pointSize = void 0, this._color = void 0, this._pointSize = void 0, this._pointOutlineColor = void 0, this._pointOutlineWidth = void 0, this._heightOffset = void 0, this._pickIds = new Array(3), yx(this) } var Ake = new he; Object.defineProperties(Ss.prototype, { show: { get: function () { return this._label.show }, set: function (e) { this._label.show = e, this._billboard.show = e, this._polyline.show = e } }, color: { get: function () { return this._color }, set: function (e) { this._color = U.clone(e, this._color), yx(this) } }, pointSize: { get: function () { return this._pointSize }, set: function (e) { this._pointSize = e, yx(this) } }, pointOutlineColor: { get: function () { return this._pointOutlineColor }, set: function (e) { this._pointOutlineColor = U.clone(e, this._pointOutlineColor), yx(this) } }, pointOutlineWidth: { get: function () { return this._pointOutlineWidth }, set: function (e) { this._pointOutlineWidth = e, yx(this) } }, labelColor: { get: function () { return this._label.fillColor }, set: function (e) { this._label.fillColor = e, this._polyline.show = this._label.show && e.alpha > 0 } }, labelOutlineColor: { get: function () { return this._label.outlineColor }, set: function (e) { this._label.outlineColor = e } }, labelOutlineWidth: { get: function () { return this._label.outlineWidth }, set: function (e) { this._label.outlineWidth = e } }, font: { get: function () { return this._label.font }, set: function (e) { this._label.font = e } }, labelStyle: { get: function () { return this._label.style }, set: function (e) { this._label.style = e } }, labelText: { get: function () { return this._label.text }, set: function (e) { l(e) || (e = ""), this._label.text = e } }, backgroundColor: { get: function () { return this._label.backgroundColor }, set: function (e) { this._label.backgroundColor = e } }, backgroundPadding: { get: function () { return this._label.backgroundPadding }, set: function (e) { this._label.backgroundPadding = e } }, backgroundEnabled: { get: function () { return this._label.showBackground }, set: function (e) { this._label.showBackground = e } }, scaleByDistance: { get: function () { return this._label.scaleByDistance }, set: function (e) { this._label.scaleByDistance = e, this._billboard.scaleByDistance = e } }, translucencyByDistance: { get: function () { return this._label.translucencyByDistance }, set: function (e) { this._label.translucencyByDistance = e, this._billboard.translucencyByDistance = e } }, distanceDisplayCondition: { get: function () { return this._label.distanceDisplayCondition }, set: function (e) { this._label.distanceDisplayCondition = e, this._polyline.distanceDisplayCondition = e, this._billboard.distanceDisplayCondition = e } }, heightOffset: { get: function () { return this._heightOffset }, set: function (e) { let t = y(this._heightOffset, 0), n = this._content.tileset.ellipsoid, i = n.cartesianToCartographic(this._billboard.position, Ake); i.height = i.height - t + e; let o = n.cartographicToCartesian(i); this._billboard.position = o, this._label.position = this._billboard.position, this._polyline.positions = [this._polyline.positions[0], o], this._heightOffset = e } }, anchorLineEnabled: { get: function () { return this._polyline.show }, set: function (e) { this._polyline.show = e } }, anchorLineColor: { get: function () { return this._polyline.material.uniforms.color }, set: function (e) { this._polyline.material.uniforms.color = U.clone(e, this._polyline.material.uniforms.color) } }, image: { get: function () { return this._billboardImage }, set: function (e) { let t = this._billboardImage !== e; this._billboardImage = e, t && yx(this) } }, disableDepthTestDistance: { get: function () { return this._label.disableDepthTestDistance }, set: function (e) { this._label.disableDepthTestDistance = e, this._billboard.disableDepthTestDistance = e } }, horizontalOrigin: { get: function () { return this._billboard.horizontalOrigin }, set: function (e) { this._billboard.horizontalOrigin = e } }, verticalOrigin: { get: function () { return this._billboard.verticalOrigin }, set: function (e) { this._billboard.verticalOrigin = e } }, labelHorizontalOrigin: { get: function () { return this._label.horizontalOrigin }, set: function (e) { this._label.horizontalOrigin = e } }, labelVerticalOrigin: { get: function () { return this._label.verticalOrigin }, set: function (e) { this._label.verticalOrigin = e } }, content: { get: function () { return this._content } }, tileset: { get: function () { return this._content.tileset } }, primitive: { get: function () { return this._content.tileset } }, pickIds: { get: function () { let e = this._pickIds; return e[0] = this._billboard.pickId, e[1] = this._label.pickId, e[2] = this._polyline.pickId, e } } }); Ss.defaultColor = U.WHITE; Ss.defaultPointOutlineColor = U.BLACK; Ss.defaultPointOutlineWidth = 0; Ss.defaultPointSize = 8; function yx(e) { let t = e._billboard; if (l(e._billboardImage) && e._billboardImage !== t.image) { t.image = e._billboardImage; return } if (l(e._billboardImage)) return; let n = y(e._color, Ss.defaultColor), i = y(e._pointOutlineColor, Ss.defaultPointOutlineColor), o = y(e._pointOutlineWidth, Ss.defaultPointOutlineWidth), r = y(e._pointSize, Ss.defaultPointSize), s = e._billboardColor, a = e._billboardOutlineColor, c = e._billboardOutlineWidth, u = e._billboardSize; if (U.equals(n, s) && U.equals(i, a) && o === c && r === u) return; e._billboardColor = U.clone(n, e._billboardColor), e._billboardOutlineColor = U.clone(i, e._billboardOutlineColor), e._billboardOutlineWidth = o, e._billboardSize = r; let f = n.alpha, d = n.toCssColorString(), p = i.toCssColorString(), g = JSON.stringify([d, r, p, o]); t.setImage(g, gx(f, d, p, o, r)) } Ss.prototype.hasProperty = function (e) { return this._content.batchTable.hasProperty(this._batchId, e) }; Ss.prototype.getPropertyIds = function (e) { return this._content.batchTable.getPropertyIds(this._batchId, e) }; Ss.prototype.getProperty = function (e) { return this._content.batchTable.getProperty(this._batchId, e) }; Ss.prototype.getPropertyInherited = function (e) { return xs.getPropertyInherited(this._content, this._batchId, e) }; Ss.prototype.setProperty = function (e, t) { this._content.batchTable.setProperty(this._batchId, e, t), this._content.featurePropertiesDirty = !0 }; Ss.prototype.isExactClass = function (e) { return this._content.batchTable.isExactClass(this._batchId, e) }; Ss.prototype.isClass = function (e) { return this._content.batchTable.isClass(this._batchId, e) }; Ss.prototype.getExactClassName = function () { return this._content.batchTable.getExactClassName(this._batchId) }; var S_ = Ss; function Cke(e, t, n, i, o) { let r = e.measureText(t); if (!!/\S/.test(t)) { let a = document.defaultView.getComputedStyle(e.canvas).getPropertyValue("font-size").replace("px", ""), c = document.createElement("canvas"), u = 100, f = r.width + u | 0, d = 3 * a, p = d / 2; c.width = f, c.height = d; let g = c.getContext("2d"); g.font = n, g.fillStyle = "white", g.fillRect(0, 0, c.width + 1, c.height + 1), i && (g.strokeStyle = "black", g.lineWidth = e.lineWidth, g.strokeText(t, u / 2, p)), o && (g.fillStyle = "black", g.fillText(t, u / 2, p)); let m = g.getImageData(0, 0, f, d).data, A = m.length, C = f * 4, x, T, b, S; for (x = 0; x < A; ++x)if (m[x] !== 255) { b = x / C | 0; break } for (x = A - 1; x >= 0; --x)if (m[x] !== 255) { S = x / C | 0; break } let D = -1; for (x = 0; x < f && D === -1; ++x)for (T = 0; T < d; ++T) { let P = x * 4 + T * C; if (m[P] !== 255 || m[P + 1] !== 255 || m[P + 2] !== 255 || m[P + 3] !== 255) { D = x; break } } return { width: r.width, height: S - b, ascent: p - b, descent: S - p, minx: D - u / 2 } } return { width: r.width, height: 0, ascent: 0, descent: 0, minx: 0 } } var $0; function xke(e, t) { if (e === "") return; t = y(t, y.EMPTY_OBJECT); let n = y(t.font, "10px sans-serif"), i = y(t.stroke, !1), o = y(t.fill, !0), r = y(t.strokeWidth, 1), s = y(t.backgroundColor, U.TRANSPARENT), a = y(t.padding, 0), c = a * 2, u = document.createElement("canvas"); u.width = 1, u.height = 1, u.style.font = n; let f = u.getContext("2d"); l($0) || (l(f.imageSmoothingEnabled) ? $0 = "imageSmoothingEnabled" : l(f.mozImageSmoothingEnabled) ? $0 = "mozImageSmoothingEnabled" : l(f.webkitImageSmoothingEnabled) ? $0 = "webkitImageSmoothingEnabled" : l(f.msImageSmoothingEnabled) && ($0 = "msImageSmoothingEnabled")), f.font = n, f.lineJoin = "round", f.lineWidth = r, f[$0] = !1, u.style.visibility = "hidden", document.body.appendChild(u); let d = Cke(f, e, n, i, o); u.dimensions = d, document.body.removeChild(u), u.style.visibility = ""; let p = -d.minx, g = Math.ceil(d.width) + p + c, m = d.height + c, A = m - d.ascent + a, C = m - A + c; if (u.width = g, u.height = m, f.font = n, f.lineJoin = "round", f.lineWidth = r, f[$0] = !1, s !== U.TRANSPARENT && (f.fillStyle = s.toCssColorString(), f.fillRect(0, 0, u.width, u.height)), i) { let x = y(t.strokeColor, U.BLACK); f.strokeStyle = x.toCssColorString(), f.strokeText(e, p + a, C) } if (o) { let x = y(t.fillColor, U.WHITE); f.fillStyle = x.toCssColorString(), f.fillText(e, p + a, C) } return u } var Ax = xke; var fne = po(one(), 1); var Eke = { FILL: 0, OUTLINE: 1, FILL_AND_OUTLINE: 2 }, Fo = Object.freeze(Eke); var rne = {}, sne = 0, bke = 256, Ske = new U(.165, .165, .165, .8), wke = new H(7, 5), zr = Object.freeze({ LTR: 0, RTL: 1, WEAK: 2, BRACKETS: 3 }); function ey(e) { !e._rebindAllGlyphs && !e._repositionAllGlyphs && e._labelCollection._labelsToUpdate.push(e), e._rebindAllGlyphs = !0 } function GS(e) { !e._rebindAllGlyphs && !e._repositionAllGlyphs && e._labelCollection._labelsToUpdate.push(e), e._repositionAllGlyphs = !0 } function WS(e, t) { return document.defaultView.getComputedStyle(e, null).getPropertyValue(t) } function cne(e) { let t = rne[e._font]; if (!l(t)) { let n = document.createElement("div"); n.style.position = "absolute", n.style.opacity = 0, n.style.font = e._font, document.body.appendChild(n); let i = parseFloat(WS(n, "line-height")); isNaN(i) && (i = void 0), t = { family: WS(n, "font-family"), size: WS(n, "font-size").replace("px", ""), style: WS(n, "font-style"), weight: WS(n, "font-weight"), lineHeight: i }, document.body.removeChild(n), sne < bke && (rne[e._font] = t, sne++) } e._fontFamily = t.family, e._fontSize = t.size, e._fontStyle = t.style, e._fontWeight = t.weight, e._lineHeight = t.lineHeight } function Mm(e, t) { e = y(e, y.EMPTY_OBJECT); let n = e.translucencyByDistance, i = e.pixelOffsetScaleByDistance, o = e.scaleByDistance, r = e.distanceDisplayCondition; l(n) && (n = wt.clone(n)), l(i) && (i = wt.clone(i)), l(o) && (o = wt.clone(o)), l(r) && (r = bt.clone(r)), this._renderedText = void 0, this._text = void 0, this._show = y(e.show, !0), this._font = y(e.font, "30px sans-serif"), this._fillColor = U.clone(y(e.fillColor, U.WHITE)), this._outlineColor = U.clone(y(e.outlineColor, U.BLACK)), this._outlineWidth = y(e.outlineWidth, 1), this._showBackground = y(e.showBackground, !1), this._backgroundColor = U.clone(y(e.backgroundColor, Ske)), this._backgroundPadding = H.clone(y(e.backgroundPadding, wke)), this._style = y(e.style, Fo.FILL), this._verticalOrigin = y(e.verticalOrigin, Sn.BASELINE), this._horizontalOrigin = y(e.horizontalOrigin, ai.LEFT), this._pixelOffset = H.clone(y(e.pixelOffset, H.ZERO)), this._eyeOffset = h.clone(y(e.eyeOffset, h.ZERO)), this._position = h.clone(y(e.position, h.ZERO)), this._scale = y(e.scale, 1), this._id = e.id, this._translucencyByDistance = n, this._pixelOffsetScaleByDistance = i, this._scaleByDistance = o, this._heightReference = y(e.heightReference, ze.NONE), this._distanceDisplayCondition = r, this._disableDepthTestDistance = e.disableDepthTestDistance, this._labelCollection = t, this._glyphs = [], this._backgroundBillboard = void 0, this._batchIndex = void 0, this._rebindAllGlyphs = !0, this._repositionAllGlyphs = !0, this._actualClampedPosition = void 0, this._removeCallbackFunc = void 0, this._mode = void 0, this._clusterShow = !0, this.text = y(e.text, ""), this._relativeSize = 1, cne(this), this._updateClamping() } Object.defineProperties(Mm.prototype, { show: { get: function () { return this._show }, set: function (e) { if (this._show !== e) { this._show = e; let t = this._glyphs; for (let i = 0, o = t.length; i < o; i++) { let r = t[i].billboard; l(r) && (r.show = e) } let n = this._backgroundBillboard; l(n) && (n.show = e) } } }, position: { get: function () { return this._position }, set: function (e) { let t = this._position; if (!h.equals(t, e)) { h.clone(e, t); let n = this._glyphs; for (let o = 0, r = n.length; o < r; o++) { let s = n[o].billboard; l(s) && (s.position = e) } let i = this._backgroundBillboard; l(i) && (i.position = e), this._updateClamping() } } }, heightReference: { get: function () { return this._heightReference }, set: function (e) { if (e !== this._heightReference) { this._heightReference = e; let t = this._glyphs; for (let i = 0, o = t.length; i < o; i++) { let r = t[i].billboard; l(r) && (r.heightReference = e) } let n = this._backgroundBillboard; l(n) && (n.heightReference = e), GS(this), this._updateClamping() } } }, text: { get: function () { return this._text }, set: function (e) { if (this._text !== e) { this._text = e; let t = e.replace(/\u00ad/g, ""); this._renderedText = Mm.enableRightToLeftDetection ? Bke(t) : t, ey(this) } } }, font: { get: function () { return this._font }, set: function (e) { this._font !== e && (this._font = e, ey(this), cne(this)) } }, fillColor: { get: function () { return this._fillColor }, set: function (e) { let t = this._fillColor; U.equals(t, e) || (U.clone(e, t), ey(this)) } }, outlineColor: { get: function () { return this._outlineColor }, set: function (e) { let t = this._outlineColor; U.equals(t, e) || (U.clone(e, t), ey(this)) } }, outlineWidth: { get: function () { return this._outlineWidth }, set: function (e) { this._outlineWidth !== e && (this._outlineWidth = e, ey(this)) } }, showBackground: { get: function () { return this._showBackground }, set: function (e) { this._showBackground !== e && (this._showBackground = e, ey(this)) } }, backgroundColor: { get: function () { return this._backgroundColor }, set: function (e) { let t = this._backgroundColor; if (!U.equals(t, e)) { U.clone(e, t); let n = this._backgroundBillboard; l(n) && (n.color = t) } } }, backgroundPadding: { get: function () { return this._backgroundPadding }, set: function (e) { let t = this._backgroundPadding; H.equals(t, e) || (H.clone(e, t), GS(this)) } }, style: { get: function () { return this._style }, set: function (e) { this._style !== e && (this._style = e, ey(this)) } }, pixelOffset: { get: function () { return this._pixelOffset }, set: function (e) { let t = this._pixelOffset; if (!H.equals(t, e)) { H.clone(e, t); let n = this._glyphs; for (let o = 0, r = n.length; o < r; o++) { let s = n[o]; l(s.billboard) && (s.billboard.pixelOffset = e) } let i = this._backgroundBillboard; l(i) && (i.pixelOffset = e) } } }, translucencyByDistance: { get: function () { return this._translucencyByDistance }, set: function (e) { let t = this._translucencyByDistance; if (!wt.equals(t, e)) { this._translucencyByDistance = wt.clone(e, t); let n = this._glyphs; for (let o = 0, r = n.length; o < r; o++) { let s = n[o]; l(s.billboard) && (s.billboard.translucencyByDistance = e) } let i = this._backgroundBillboard; l(i) && (i.translucencyByDistance = e) } } }, pixelOffsetScaleByDistance: { get: function () { return this._pixelOffsetScaleByDistance }, set: function (e) { let t = this._pixelOffsetScaleByDistance; if (!wt.equals(t, e)) { this._pixelOffsetScaleByDistance = wt.clone(e, t); let n = this._glyphs; for (let o = 0, r = n.length; o < r; o++) { let s = n[o]; l(s.billboard) && (s.billboard.pixelOffsetScaleByDistance = e) } let i = this._backgroundBillboard; l(i) && (i.pixelOffsetScaleByDistance = e) } } }, scaleByDistance: { get: function () { return this._scaleByDistance }, set: function (e) { let t = this._scaleByDistance; if (!wt.equals(t, e)) { this._scaleByDistance = wt.clone(e, t); let n = this._glyphs; for (let o = 0, r = n.length; o < r; o++) { let s = n[o]; l(s.billboard) && (s.billboard.scaleByDistance = e) } let i = this._backgroundBillboard; l(i) && (i.scaleByDistance = e) } } }, eyeOffset: { get: function () { return this._eyeOffset }, set: function (e) { let t = this._eyeOffset; if (!h.equals(t, e)) { h.clone(e, t); let n = this._glyphs; for (let o = 0, r = n.length; o < r; o++) { let s = n[o]; l(s.billboard) && (s.billboard.eyeOffset = e) } let i = this._backgroundBillboard; l(i) && (i.eyeOffset = e) } } }, horizontalOrigin: { get: function () { return this._horizontalOrigin }, set: function (e) { this._horizontalOrigin !== e && (this._horizontalOrigin = e, GS(this)) } }, verticalOrigin: { get: function () { return this._verticalOrigin }, set: function (e) { if (this._verticalOrigin !== e) { this._verticalOrigin = e; let t = this._glyphs; for (let i = 0, o = t.length; i < o; i++) { let r = t[i]; l(r.billboard) && (r.billboard.verticalOrigin = e) } let n = this._backgroundBillboard; l(n) && (n.verticalOrigin = e), GS(this) } } }, scale: { get: function () { return this._scale }, set: function (e) { if (this._scale !== e) { this._scale = e; let t = this._glyphs; for (let i = 0, o = t.length; i < o; i++) { let r = t[i]; l(r.billboard) && (r.billboard.scale = e * this._relativeSize) } let n = this._backgroundBillboard; l(n) && (n.scale = e * this._relativeSize), GS(this) } } }, totalScale: { get: function () { return this._scale * this._relativeSize } }, distanceDisplayCondition: { get: function () { return this._distanceDisplayCondition }, set: function (e) { if (!bt.equals(e, this._distanceDisplayCondition)) { this._distanceDisplayCondition = bt.clone(e, this._distanceDisplayCondition); let t = this._glyphs; for (let i = 0, o = t.length; i < o; i++) { let r = t[i]; l(r.billboard) && (r.billboard.distanceDisplayCondition = e) } let n = this._backgroundBillboard; l(n) && (n.distanceDisplayCondition = e) } } }, disableDepthTestDistance: { get: function () { return this._disableDepthTestDistance }, set: function (e) { if (this._disableDepthTestDistance !== e) { this._disableDepthTestDistance = e; let t = this._glyphs; for (let i = 0, o = t.length; i < o; i++) { let r = t[i]; l(r.billboard) && (r.billboard.disableDepthTestDistance = e) } let n = this._backgroundBillboard; l(n) && (n.disableDepthTestDistance = e) } } }, id: { get: function () { return this._id }, set: function (e) { if (this._id !== e) { this._id = e; let t = this._glyphs; for (let i = 0, o = t.length; i < o; i++) { let r = t[i]; l(r.billboard) && (r.billboard.id = e) } let n = this._backgroundBillboard; l(n) && (n.id = e) } } }, pickId: { get: function () { if (!(this._glyphs.length === 0 || !l(this._glyphs[0].billboard))) return this._glyphs[0].billboard.pickId } }, _clampedPosition: { get: function () { return this._actualClampedPosition }, set: function (e) { this._actualClampedPosition = h.clone(e, this._actualClampedPosition); let t = this._glyphs; for (let i = 0, o = t.length; i < o; i++) { let r = t[i]; l(r.billboard) && (r.billboard._clampedPosition = e) } let n = this._backgroundBillboard; l(n) && (n._clampedPosition = e) } }, clusterShow: { get: function () { return this._clusterShow }, set: function (e) { if (this._clusterShow !== e) { this._clusterShow = e; let t = this._glyphs; for (let i = 0, o = t.length; i < o; i++) { let r = t[i]; l(r.billboard) && (r.billboard.clusterShow = e) } let n = this._backgroundBillboard; l(n) && (n.clusterShow = e) } } } }); Mm.prototype._updateClamping = function () { co._updateClamping(this._labelCollection, this) }; Mm.prototype.computeScreenSpacePosition = function (e, t) { l(t) || (t = new H); let i = this._labelCollection.modelMatrix, o = l(this._actualClampedPosition) ? this._actualClampedPosition : this._position; return co._computeScreenSpacePosition(i, o, this._eyeOffset, this._pixelOffset, e, t) }; Mm.getScreenSpaceBoundingBox = function (e, t, n) { let i = 0, o = 0, r = 0, s = 0, a = e.totalScale, c = e._backgroundBillboard; if (l(c)) i = t.x + c._translate.x, o = t.y - c._translate.y, r = c.width * a, s = c.height * a, e.verticalOrigin === Sn.BOTTOM || e.verticalOrigin === Sn.BASELINE ? o -= s : e.verticalOrigin === Sn.CENTER && (o -= s * .5); else { i = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY; let u = 0, f = 0, d = e._glyphs, p = d.length; for (let g = 0; g < p; ++g) { let m = d[g], A = m.billboard; if (!l(A)) continue; let C = t.x + A._translate.x, x = t.y - A._translate.y, T = m.dimensions.width * a, b = m.dimensions.height * a; e.verticalOrigin === Sn.BOTTOM || e.verticalOrigin === Sn.BASELINE ? x -= b : e.verticalOrigin === Sn.CENTER && (x -= b * .5), e._verticalOrigin === Sn.TOP ? x += bs.PADDING * a : (e._verticalOrigin === Sn.BOTTOM || e._verticalOrigin === Sn.BASELINE) && (x -= bs.PADDING * a), i = Math.min(i, C), o = Math.min(o, x), u = Math.max(u, C + T), f = Math.max(f, x + b) } r = u - i, s = f - o } return l(n) || (n = new Ge), n.x = i, n.y = o, n.width = r, n.height = s, n }; Mm.prototype.equals = function (e) { return this === e || l(e) && this._show === e._show && this._scale === e._scale && this._outlineWidth === e._outlineWidth && this._showBackground === e._showBackground && this._style === e._style && this._verticalOrigin === e._verticalOrigin && this._horizontalOrigin === e._horizontalOrigin && this._heightReference === e._heightReference && this._renderedText === e._renderedText && this._font === e._font && h.equals(this._position, e._position) && U.equals(this._fillColor, e._fillColor) && U.equals(this._outlineColor, e._outlineColor) && U.equals(this._backgroundColor, e._backgroundColor) && H.equals(this._backgroundPadding, e._backgroundPadding) && H.equals(this._pixelOffset, e._pixelOffset) && h.equals(this._eyeOffset, e._eyeOffset) && wt.equals(this._translucencyByDistance, e._translucencyByDistance) && wt.equals(this._pixelOffsetScaleByDistance, e._pixelOffsetScaleByDistance) && wt.equals(this._scaleByDistance, e._scaleByDistance) && bt.equals(this._distanceDisplayCondition, e._distanceDisplayCondition) && this._disableDepthTestDistance === e._disableDepthTestDistance && this._id === e._id }; Mm.prototype.isDestroyed = function () { return !1 }; Mm.enableRightToLeftDetection = !1; function Dke(e, t) { let n = /[a-zA-Z0-9]/, i = /[()[\]{}<>]/, o = [], r = "", s = zr.LTR, a = "", c = e.length; for (let u = 0; u < c; ++u) { let f = e.charAt(u); t.test(f) ? a = zr.RTL : n.test(f) ? a = zr.LTR : i.test(f) ? a = zr.BRACKETS : a = zr.WEAK, u === 0 && (s = a), s === a && a !== zr.BRACKETS ? r += f : (r !== "" && o.push({ Type: s, Word: r }), s = a, r = f) } return o.push({ Type: a, Word: r }), o } function vke(e) { return e.split("").reverse().join("") } function jS(e, t, n) { return e.slice(0, t) + n + e.slice(t) } function Pke(e) { switch (e) { case "(": return ")"; case ")": return "("; case "[": return "]"; case "]": return "["; case "{": return "}"; case "}": return "{"; case "<": return ">"; case ">": return "<" } } var Ike = "\u05D0-\u05EA", Oke = "\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF", ane = new RegExp(`[${Ike}${Oke}]`); function Bke(e) {
        let t = e.split(`
`), n = ""; for (let i = 0; i < t.length; i++) {
            let o = t[i], r = ane.test(o.charAt(0)), s = Dke(o, ane), a = 0, c = ""; for (let u = 0; u < s.length; ++u) { let f = s[u], d = f.Type === zr.BRACKETS ? Pke(f.Word) : vke(f.Word); r ? f.Type === zr.RTL ? (c = d + c, a = 0) : f.Type === zr.LTR ? (c = jS(c, a, f.Word), a += f.Word.length) : (f.Type === zr.WEAK || f.Type === zr.BRACKETS) && (f.Type === zr.WEAK && s[u - 1].Type === zr.BRACKETS ? c = d + c : s[u - 1].Type === zr.RTL ? (c = d + c, a = 0) : s.length > u + 1 ? s[u + 1].Type === zr.RTL ? (c = d + c, a = 0) : (c = jS(c, a, f.Word), a += f.Word.length) : c = jS(c, 0, d)) : f.Type === zr.RTL ? c = jS(c, a, d) : f.Type === zr.LTR ? (c += f.Word, a = c.length) : (f.Type === zr.WEAK || f.Type === zr.BRACKETS) && (u > 0 && s[u - 1].Type === zr.RTL ? s.length > u + 1 ? s[u + 1].Type === zr.RTL ? c = jS(c, a, d) : (c += f.Word, a = c.length) : c += f.Word : (c += f.Word, a = c.length)) } n += c, i < t.length - 1 && (n += `
`)
        } return n
    } var ty = Mm; var dne = po(lne(), 1); function Mke() { this.textureInfo = void 0, this.dimensions = void 0, this.billboard = void 0 } function Lke(e, t, n) { this.labelCollection = e, this.index = t, this.dimensions = n } var Fke = 1.2, hne = "ID_WHITE_PIXEL", e5 = new H(4, 4), Nke = new Ge(1, 1, 1, 1); function Vke(e) { let t = document.createElement("canvas"); t.width = e5.x, t.height = e5.y; let n = t.getContext("2d"); n.fillStyle = "#fff", n.fillRect(0, 0, t.width, t.height), e.addImage(hne, t) } var Au = {}; function kke(e, t, n, i, o, r, s) { return Au.font = t, Au.fillColor = n, Au.strokeColor = i, Au.strokeWidth = o, Au.padding = bs.PADDING, s === Sn.CENTER ? Au.textBaseline = "middle" : s === Sn.TOP ? Au.textBaseline = "top" : Au.textBaseline = "bottom", Au.fill = r === Fo.FILL || r === Fo.FILL_AND_OUTLINE, Au.stroke = r === Fo.OUTLINE || r === Fo.FILL_AND_OUTLINE, Au.backgroundColor = U.BLACK, Ax(e, Au) } function t5(e, t) { t.textureInfo = void 0, t.dimensions = void 0; let n = t.billboard; l(n) && (n.show = !1, n.image = void 0, l(n._removeCallbackFunc) && (n._removeCallbackFunc(), n._removeCallbackFunc = void 0), e._spareBillboards.push(n), t.billboard = void 0) } function Uke(e, t, n, i) { i.index = e.addImageSync(t, n) } var zke = new dne.default; function Hke(e, t) {
        let n = t._renderedText, i = zke.splitGraphemes(n), o = i.length, r = t._glyphs, s = r.length, a, c, u; if (t._relativeSize = t._fontSize / bs.FONT_SIZE, o < s) for (c = o; c < s; ++c)t5(e, r[c]); r.length = o; let f = t._showBackground && n.split(`
`).join("").length > 0, d = t._backgroundBillboard, p = e._backgroundBillboardCollection; f ? (l(d) || (d = p.add({ collection: e, image: hne, imageSubRegion: Nke }), t._backgroundBillboard = d), d.color = t._backgroundColor, d.show = t._show, d.position = t._position, d.eyeOffset = t._eyeOffset, d.pixelOffset = t._pixelOffset, d.horizontalOrigin = ai.LEFT, d.verticalOrigin = t._verticalOrigin, d.heightReference = t._heightReference, d.scale = t.totalScale, d.pickPrimitive = t, d.id = t._id, d.translucencyByDistance = t._translucencyByDistance, d.pixelOffsetScaleByDistance = t._pixelOffsetScaleByDistance, d.scaleByDistance = t._scaleByDistance, d.distanceDisplayCondition = t._distanceDisplayCondition, d.disableDepthTestDistance = t._disableDepthTestDistance) : l(d) && (p.remove(d), t._backgroundBillboard = d = void 0); let g = e._glyphTextureCache; for (u = 0; u < o; ++u) { let m = i[u], A = t._verticalOrigin, C = JSON.stringify([m, t._fontFamily, t._fontStyle, t._fontWeight, +A]), x = g[C]; if (!l(x)) { let T = `${t._fontStyle} ${t._fontWeight} ${bs.FONT_SIZE}px ${t._fontFamily}`, b = kke(m, T, U.WHITE, U.WHITE, 0, Fo.FILL, A); if (x = new Lke(e, -1, b.dimensions), g[C] = x, b.width > 0 && b.height > 0) { let S = (0, fne.default)(b, { cutoff: bs.CUTOFF, radius: bs.RADIUS }), D = b.getContext("2d"), P = b.width, B = b.height, R = D.getImageData(0, 0, P, B); for (let M = 0; M < P; M++)for (let L = 0; L < B; L++) { let _ = L * P + M, E = S[_] * 255, w = _ * 4; R.data[w + 0] = E, R.data[w + 1] = E, R.data[w + 2] = E, R.data[w + 3] = E } D.putImageData(R, 0, 0), m !== " " && Uke(e._textureAtlas, C, b, x) } } if (a = r[u], l(a) ? x.index === -1 ? t5(e, a) : l(a.textureInfo) && (a.textureInfo = void 0) : (a = new Mke, r[u] = a), a.textureInfo = x, a.dimensions = x.dimensions, x.index !== -1) { let T = a.billboard, b = e._spareBillboards; l(T) || (b.length > 0 ? T = b.pop() : (T = e._billboardCollection.add({ collection: e }), T._labelDimensions = new H, T._labelTranslate = new H), a.billboard = T), T.show = t._show, T.position = t._position, T.eyeOffset = t._eyeOffset, T.pixelOffset = t._pixelOffset, T.horizontalOrigin = ai.LEFT, T.verticalOrigin = t._verticalOrigin, T.heightReference = t._heightReference, T.scale = t.totalScale, T.pickPrimitive = t, T.id = t._id, T.image = C, T.translucencyByDistance = t._translucencyByDistance, T.pixelOffsetScaleByDistance = t._pixelOffsetScaleByDistance, T.scaleByDistance = t._scaleByDistance, T.distanceDisplayCondition = t._distanceDisplayCondition, T.disableDepthTestDistance = t._disableDepthTestDistance, T._batchIndex = t._batchIndex, T.outlineColor = t.outlineColor, t.style === Fo.FILL_AND_OUTLINE ? (T.color = t._fillColor, T.outlineWidth = t.outlineWidth) : t.style === Fo.FILL ? (T.color = t._fillColor, T.outlineWidth = 0) : t.style === Fo.OUTLINE && (T.color = U.TRANSPARENT, T.outlineWidth = t.outlineWidth) } } t._repositionAllGlyphs = !0
    } function une(e, t, n) { return t === ai.CENTER ? -e / 2 : t === ai.RIGHT ? -(e + n.x) : n.x } var Zo = new H, Gke = new H; function Wke(e) {
        let t = e._glyphs, n = e._renderedText, i, o, r = 0, s = 0, a = [], c = Number.NEGATIVE_INFINITY, u = 0, f = 1, d, p = t.length, g = e._backgroundBillboard, m = H.clone(l(g) ? e._backgroundPadding : H.ZERO, Gke); for (m.x /= e._relativeSize, m.y /= e._relativeSize, d = 0; d < p; ++d)n.charAt(d) === `
`? (a.push(r), ++f, r = 0) : (i = t[d], o = i.dimensions, u = Math.max(u, o.height - o.descent), c = Math.max(c, o.descent), r += o.width - o.minx, d < p - 1 && (r += t[d + 1].dimensions.minx), s = Math.max(s, r)); a.push(r); let A = u + c, C = e.totalScale, x = e._horizontalOrigin, T = e._verticalOrigin, b = 0, S = a[b], D = une(S, x, m), P = (l(e._lineHeight) ? e._lineHeight : Fke * e._fontSize) / e._relativeSize, B = P * (f - 1), R = s, M = A + B; l(g) && (R += m.x * 2, M += m.y * 2, g._labelHorizontalOrigin = x), Zo.x = D * C, Zo.y = 0; let L = !0, _ = 0; for (d = 0; d < p; ++d)if (n.charAt(d) === `
`) ++b, _ += P, S = a[b], D = une(S, x, m), Zo.x = D * C, L = !0; else if (i = t[d], o = i.dimensions, T === Sn.TOP ? (Zo.y = o.height - u - m.y, Zo.y += bs.PADDING) : T === Sn.CENTER ? Zo.y = (B + o.height - u) / 2 : T === Sn.BASELINE ? (Zo.y = B, Zo.y -= bs.PADDING) : (Zo.y = B + c + m.y, Zo.y -= bs.PADDING), Zo.y = (Zo.y - o.descent - _) * C, L && (Zo.x -= bs.PADDING * C, L = !1), l(i.billboard) && (i.billboard._setTranslate(Zo), i.billboard._labelDimensions.x = R, i.billboard._labelDimensions.y = M, i.billboard._labelHorizontalOrigin = x), d < p - 1) { let E = t[d + 1]; Zo.x += (o.width - o.minx + E.dimensions.minx) * C } if (l(g) && n.split(`
`).join("").length > 0 && (x === ai.CENTER ? D = -s / 2 - m.x : x === ai.RIGHT ? D = -(s + m.x * 2) : D = 0, Zo.x = D * C, T === Sn.TOP ? Zo.y = A - u - c : T === Sn.CENTER ? Zo.y = (A - u) / 2 - c : T === Sn.BASELINE ? Zo.y = -m.y - c : Zo.y = 0, Zo.y = Zo.y * C, g.width = R, g.height = M, g._setTranslate(Zo), g._labelTranslate = H.clone(Zo, g._labelTranslate)), e.heightReference === ze.CLAMP_TO_GROUND) for (d = 0; d < p; ++d) { i = t[d]; let E = i.billboard; l(E) && (E._labelTranslate = H.clone(Zo, E._labelTranslate)) }
    } function mne(e, t) { let n = t._glyphs; for (let i = 0, o = n.length; i < o; ++i)t5(e, n[i]); l(t._backgroundBillboard) && (e._backgroundBillboardCollection.remove(t._backgroundBillboard), t._backgroundBillboard = void 0), t._labelCollection = void 0, l(t._removeCallbackFunc) && t._removeCallbackFunc(), le(t) } function Qd(e) { e = y(e, y.EMPTY_OBJECT), this._scene = e.scene, this._batchTable = e.batchTable, this._textureAtlas = void 0, this._backgroundTextureAtlas = void 0, this._backgroundBillboardCollection = new yu({ scene: this._scene }), this._backgroundBillboardCollection.destroyTextureAtlas = !1, this._billboardCollection = new yu({ scene: this._scene, batchTable: this._batchTable }), this._billboardCollection.destroyTextureAtlas = !1, this._billboardCollection._sdf = !0, this._spareBillboards = [], this._glyphTextureCache = {}, this._labels = [], this._labelsToUpdate = [], this._totalGlyphCount = 0, this._highlightColor = U.clone(U.WHITE), this.show = y(e.show, !0), this.modelMatrix = F.clone(y(e.modelMatrix, F.IDENTITY)), this.debugShowBoundingVolume = y(e.debugShowBoundingVolume, !1), this.blendOption = y(e.blendOption, xo.OPAQUE_AND_TRANSLUCENT) } Object.defineProperties(Qd.prototype, { length: { get: function () { return this._labels.length } } }); Qd.prototype.add = function (e) { let t = new ty(e, this); return this._labels.push(t), this._labelsToUpdate.push(t), t }; Qd.prototype.remove = function (e) { if (l(e) && e._labelCollection === this) { let t = this._labels.indexOf(e); if (t !== -1) return this._labels.splice(t, 1), mne(this, e), !0 } return !1 }; Qd.prototype.removeAll = function () { let e = this._labels; for (let t = 0, n = e.length; t < n; ++t)mne(this, e[t]); e.length = 0 }; Qd.prototype.contains = function (e) { return l(e) && e._labelCollection === this }; Qd.prototype.get = function (e) { return this._labels[e] }; Qd.prototype.update = function (e) { if (!this.show) return; let t = this._billboardCollection, n = this._backgroundBillboardCollection; t.modelMatrix = this.modelMatrix, t.debugShowBoundingVolume = this.debugShowBoundingVolume, n.modelMatrix = this.modelMatrix, n.debugShowBoundingVolume = this.debugShowBoundingVolume; let i = e.context; l(this._textureAtlas) || (this._textureAtlas = new Q0({ context: i }), t.textureAtlas = this._textureAtlas), l(this._backgroundTextureAtlas) || (this._backgroundTextureAtlas = new Q0({ context: i, initialSize: e5 }), n.textureAtlas = this._backgroundTextureAtlas, Vke(this._backgroundTextureAtlas)); let o = this._labelsToUpdate.length; for (let s = 0; s < o; ++s) { let a = this._labelsToUpdate[s]; if (a.isDestroyed()) continue; let c = a._glyphs.length; a._rebindAllGlyphs && (Hke(this, a), a._rebindAllGlyphs = !1), a._repositionAllGlyphs && (Wke(a), a._repositionAllGlyphs = !1); let u = a._glyphs.length - c; this._totalGlyphCount += u } let r = n.length > 0 ? xo.TRANSLUCENT : this.blendOption; t.blendOption = r, n.blendOption = r, t._highlightColor = this._highlightColor, n._highlightColor = this._highlightColor, this._labelsToUpdate.length = 0, n.update(e), t.update(e) }; Qd.prototype.isDestroyed = function () { return !1 }; Qd.prototype.destroy = function () { return this.removeAll(), this._billboardCollection = this._billboardCollection.destroy(), this._textureAtlas = this._textureAtlas && this._textureAtlas.destroy(), this._backgroundBillboardCollection = this._backgroundBillboardCollection.destroy(), this._backgroundTextureAtlas = this._backgroundTextureAtlas && this._backgroundTextureAtlas.destroy(), le(this) }; var Lm = Qd; var OL = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;
attribute vec3 position2DHigh;
attribute vec3 position2DLow;
attribute vec3 prevPosition3DHigh;
attribute vec3 prevPosition3DLow;
attribute vec3 prevPosition2DHigh;
attribute vec3 prevPosition2DLow;
attribute vec3 nextPosition3DHigh;
attribute vec3 nextPosition3DLow;
attribute vec3 nextPosition2DHigh;
attribute vec3 nextPosition2DLow;
attribute vec4 texCoordExpandAndBatchIndex;
varying vec2  v_st;
varying float v_width;
varying vec4 v_pickColor;
varying float v_polylineAngle;
void main()
{
float texCoord = texCoordExpandAndBatchIndex.x;
float expandDir = texCoordExpandAndBatchIndex.y;
bool usePrev = texCoordExpandAndBatchIndex.z < 0.0;
float batchTableIndex = texCoordExpandAndBatchIndex.w;
vec2 widthAndShow = batchTable_getWidthAndShow(batchTableIndex);
float width = widthAndShow.x + 0.5;
float show = widthAndShow.y;
if (width < 1.0)
{
show = 0.0;
}
vec4 pickColor = batchTable_getPickColor(batchTableIndex);
vec4 p, prev, next;
if (czm_morphTime == 1.0)
{
p = czm_translateRelativeToEye(position3DHigh.xyz, position3DLow.xyz);
prev = czm_translateRelativeToEye(prevPosition3DHigh.xyz, prevPosition3DLow.xyz);
next = czm_translateRelativeToEye(nextPosition3DHigh.xyz, nextPosition3DLow.xyz);
}
else if (czm_morphTime == 0.0)
{
p = czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy);
prev = czm_translateRelativeToEye(prevPosition2DHigh.zxy, prevPosition2DLow.zxy);
next = czm_translateRelativeToEye(nextPosition2DHigh.zxy, nextPosition2DLow.zxy);
}
else
{
p = czm_columbusViewMorph(
czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy),
czm_translateRelativeToEye(position3DHigh.xyz, position3DLow.xyz),
czm_morphTime);
prev = czm_columbusViewMorph(
czm_translateRelativeToEye(prevPosition2DHigh.zxy, prevPosition2DLow.zxy),
czm_translateRelativeToEye(prevPosition3DHigh.xyz, prevPosition3DLow.xyz),
czm_morphTime);
next = czm_columbusViewMorph(
czm_translateRelativeToEye(nextPosition2DHigh.zxy, nextPosition2DLow.zxy),
czm_translateRelativeToEye(nextPosition3DHigh.xyz, nextPosition3DLow.xyz),
czm_morphTime);
}
#ifdef DISTANCE_DISPLAY_CONDITION
vec3 centerHigh = batchTable_getCenterHigh(batchTableIndex);
vec4 centerLowAndRadius = batchTable_getCenterLowAndRadius(batchTableIndex);
vec3 centerLow = centerLowAndRadius.xyz;
float radius = centerLowAndRadius.w;
vec2 distanceDisplayCondition = batchTable_getDistanceDisplayCondition(batchTableIndex);
float lengthSq;
if (czm_sceneMode == czm_sceneMode2D)
{
lengthSq = czm_eyeHeight2D.y;
}
else
{
vec4 center = czm_translateRelativeToEye(centerHigh.xyz, centerLow.xyz);
lengthSq = max(0.0, dot(center.xyz, center.xyz) - radius * radius);
}
float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x;
float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y;
if (lengthSq < nearSq || lengthSq > farSq)
{
show = 0.0;
}
#endif
float polylineAngle;
vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, polylineAngle);
gl_Position = czm_viewportOrthographic * positionWC * show;
v_st.s = texCoord;
v_st.t = czm_writeNonPerspective(clamp(expandDir, 0.0, 1.0), gl_Position.w);
v_width = width;
v_pickColor = pickColor;
v_polylineAngle = polylineAngle;
}
`; var ac = {}; ac.numberOfPoints = function (e, t, n) { let i = h.distance(e, t); return Math.ceil(i / n) }; ac.numberOfPointsRhumbLine = function (e, t, n) { let i = Math.pow(e.longitude - t.longitude, 2) + Math.pow(e.latitude - t.latitude, 2); return Math.max(1, Math.ceil(Math.sqrt(i / (n * n)))) }; var jke = new he; ac.extractHeights = function (e, t) { let n = e.length, i = new Array(n); for (let o = 0; o < n; o++) { let r = e[o]; i[o] = t.cartesianToCartographic(r, jke).height } return i }; var qke = new F, Yke = new h, pne = new h, Xke = new nn(h.UNIT_X, 0), _ne = new h, Kke = new nn(h.UNIT_X, 0), Jke = new h, Zke = new h, i5 = []; function yne(e, t, n) { let i = i5; i.length = e; let o; if (t === n) { for (o = 0; o < e; o++)i[o] = t; return i } let s = (n - t) / e; for (o = 0; o < e; o++) { let a = t + o * s; i[o] = a } return i } var RL = new he, BL = new he, w_ = new h, o5 = new h, Qke = new h, n5 = new mf, qS = new ga; function $ke(e, t, n, i, o, r, s, a) { let c = i.scaleToGeodeticSurface(e, o5), u = i.scaleToGeodeticSurface(t, Qke), f = ac.numberOfPoints(e, t, n), d = i.cartesianToCartographic(c, RL), p = i.cartesianToCartographic(u, BL), g = yne(f, o, r); n5.setEndPoints(d, p); let m = n5.surfaceDistance / f, A = a; d.height = o; let C = i.cartographicToCartesian(d, w_); h.pack(C, s, A), A += 3; for (let x = 1; x < f; x++) { let T = n5.interpolateUsingSurfaceDistance(x * m, BL); T.height = g[x], C = i.cartographicToCartesian(T, w_), h.pack(C, s, A), A += 3 } return A } function eUe(e, t, n, i, o, r, s, a) { let c = i.cartesianToCartographic(e, RL), u = i.cartesianToCartographic(t, BL), f = ac.numberOfPointsRhumbLine(c, u, n); c.height = 0, u.height = 0; let d = yne(f, o, r); qS.ellipsoid.equals(i) || (qS = new ga(void 0, void 0, i)), qS.setEndPoints(c, u); let p = qS.surfaceDistance / f, g = a; c.height = o; let m = i.cartographicToCartesian(c, w_); h.pack(m, s, g), g += 3; for (let A = 1; A < f; A++) { let C = qS.interpolateUsingSurfaceDistance(A * p, BL); C.height = d[A], m = i.cartographicToCartesian(C, w_), h.pack(m, s, g), g += 3 } return g } ac.wrapLongitude = function (e, t) { let n = [], i = []; if (l(e) && e.length > 0) { t = y(t, F.IDENTITY); let o = F.inverseTransformation(t, qke), r = F.multiplyByPoint(o, h.ZERO, Yke), s = h.normalize(F.multiplyByPointAsVector(o, h.UNIT_Y, pne), pne), a = nn.fromPointNormal(r, s, Xke), c = h.normalize(F.multiplyByPointAsVector(o, h.UNIT_X, _ne), _ne), u = nn.fromPointNormal(r, c, Kke), f = 1; n.push(h.clone(e[0])); let d = n[0], p = e.length; for (let g = 1; g < p; ++g) { let m = e[g]; if (nn.getPointDistance(u, d) < 0 || nn.getPointDistance(u, m) < 0) { let A = Gi.lineSegmentPlane(d, m, a, Jke); if (l(A)) { let C = h.multiplyByScalar(s, 5e-9, Zke); nn.getPointDistance(a, d) < 0 && h.negate(C, C), n.push(h.add(A, C, new h)), i.push(f + 1), h.negate(C, C), n.push(h.add(A, C, new h)), f = 1 } } n.push(h.clone(e[g])), f++, d = m } i.push(f) } return { positions: n, lengths: i } }; ac.generateArc = function (e) { l(e) || (e = {}); let t = e.positions, n = t.length, i = y(e.ellipsoid, ie.WGS84), o = y(e.height, 0), r = Array.isArray(o); if (n < 1) return []; if (n === 1) { let A = i.scaleToGeodeticSurface(t[0], o5); if (o = r ? o[0] : o, o !== 0) { let C = i.geodeticSurfaceNormal(A, w_); h.multiplyByScalar(C, o, C), h.add(A, C, A) } return [A.x, A.y, A.z] } let s = e.minDistance; if (!l(s)) { let A = y(e.granularity, I.RADIANS_PER_DEGREE); s = I.chordLength(A, i.maximumRadius) } let a = 0, c; for (c = 0; c < n - 1; c++)a += ac.numberOfPoints(t[c], t[c + 1], s); let u = (a + 1) * 3, f = new Array(u), d = 0; for (c = 0; c < n - 1; c++) { let A = t[c], C = t[c + 1], x = r ? o[c] : o, T = r ? o[c + 1] : o; d = $ke(A, C, s, i, x, T, f, d) } i5.length = 0; let p = t[n - 1], g = i.cartesianToCartographic(p, RL); g.height = r ? o[n - 1] : o; let m = i.cartographicToCartesian(g, w_); return h.pack(m, f, u - 3), f }; var gne = new he, tUe = new he; ac.generateRhumbArc = function (e) { l(e) || (e = {}); let t = e.positions, n = t.length, i = y(e.ellipsoid, ie.WGS84), o = y(e.height, 0), r = Array.isArray(o); if (n < 1) return []; if (n === 1) { let x = i.scaleToGeodeticSurface(t[0], o5); if (o = r ? o[0] : o, o !== 0) { let T = i.geodeticSurfaceNormal(x, w_); h.multiplyByScalar(T, o, T), h.add(x, T, x) } return [x.x, x.y, x.z] } let s = y(e.granularity, I.RADIANS_PER_DEGREE), a = 0, c, u = i.cartesianToCartographic(t[0], gne), f; for (c = 0; c < n - 1; c++)f = i.cartesianToCartographic(t[c + 1], tUe), a += ac.numberOfPointsRhumbLine(u, f, s), u = he.clone(f, gne); let d = (a + 1) * 3, p = new Array(d), g = 0; for (c = 0; c < n - 1; c++) { let x = t[c], T = t[c + 1], b = r ? o[c] : o, S = r ? o[c + 1] : o; g = eUe(x, T, s, i, b, S, p, g) } i5.length = 0; let m = t[n - 1], A = i.cartesianToCartographic(m, RL); A.height = r ? o[n - 1] : o; let C = i.cartographicToCartesian(A, w_); return h.pack(C, p, d - 3), p }; ac.generateCartesianArc = function (e) { let t = ac.generateArc(e), n = t.length / 3, i = new Array(n); for (let o = 0; o < n; o++)i[o] = h.unpack(t, o * 3); return i }; ac.generateCartesianRhumbArc = function (e) { let t = ac.generateRhumbArc(e), n = t.length / 3, i = new Array(n); for (let o = 0; o < n; o++)i[o] = h.unpack(t, o * 3); return i }; var xi = ac; function Tl(e, t) { e = y(e, y.EMPTY_OBJECT), this._show = y(e.show, !0), this._width = y(e.width, 1), this._loop = y(e.loop, !1), this._distanceDisplayCondition = e.distanceDisplayCondition, this._material = e.material, l(this._material) || (this._material = Ki.fromType(Ki.ColorType, { color: new U(1, 1, 1, 1) })); let n = e.positions; l(n) || (n = []), this._positions = n, this._actualPositions = _o(n, h.equalsEpsilon), this._loop && this._actualPositions.length > 2 && (this._actualPositions === this._positions && (this._actualPositions = n.slice()), this._actualPositions.push(h.clone(this._actualPositions[0]))), this._length = this._actualPositions.length, this._id = e.id; let i; l(t) && (i = F.clone(t.modelMatrix)), this._modelMatrix = i, this._segments = xi.wrapLongitude(this._actualPositions, i), this._actualLength = void 0, this._propertiesChanged = new Uint32Array(Cne), this._polylineCollection = t, this._dirty = !1, this._pickId = void 0, this._boundingVolume = re.fromPoints(this._actualPositions), this._boundingVolumeWC = re.transform(this._boundingVolume, this._modelMatrix), this._boundingVolume2D = new re } var Ane = Tl.POSITION_INDEX = 0, nUe = Tl.SHOW_INDEX = 1, iUe = Tl.WIDTH_INDEX = 2, oUe = Tl.MATERIAL_INDEX = 3, YS = Tl.POSITION_SIZE_INDEX = 4, rUe = Tl.DISTANCE_DISPLAY_CONDITION = 5, Cne = Tl.NUMBER_OF_PROPERTIES = 6; function Fm(e, t) { ++e._propertiesChanged[t]; let n = e._polylineCollection; l(n) && (n._updatePolyline(e, t), e._dirty = !0) } Object.defineProperties(Tl.prototype, { show: { get: function () { return this._show }, set: function (e) { e !== this._show && (this._show = e, Fm(this, nUe)) } }, positions: { get: function () { return this._positions }, set: function (e) { let t = _o(e, h.equalsEpsilon); this._loop && t.length > 2 && (t === e && (t = e.slice()), t.push(h.clone(t[0]))), (this._actualPositions.length !== t.length || this._actualPositions.length !== this._length) && Fm(this, YS), this._positions = e, this._actualPositions = t, this._length = t.length, this._boundingVolume = re.fromPoints(this._actualPositions, this._boundingVolume), this._boundingVolumeWC = re.transform(this._boundingVolume, this._modelMatrix, this._boundingVolumeWC), Fm(this, Ane), this.update() } }, material: { get: function () { return this._material }, set: function (e) { this._material !== e && (this._material = e, Fm(this, oUe)) } }, width: { get: function () { return this._width }, set: function (e) { let t = this._width; e !== t && (this._width = e, Fm(this, iUe)) } }, loop: { get: function () { return this._loop }, set: function (e) { if (e !== this._loop) { let t = this._actualPositions; e ? t.length > 2 && !h.equals(t[0], t[t.length - 1]) && (t.length === this._positions.length && (this._actualPositions = t = this._positions.slice()), t.push(h.clone(t[0]))) : t.length > 2 && h.equals(t[0], t[t.length - 1]) && (t.length - 1 === this._positions.length ? this._actualPositions = this._positions : t.pop()), this._loop = e, Fm(this, YS) } } }, id: { get: function () { return this._id }, set: function (e) { this._id = e, l(this._pickId) && (this._pickId.object.id = e) } }, pickId: { get: function () { return this._pickId } }, isDestroyed: { get: function () { return !l(this._polylineCollection) } }, distanceDisplayCondition: { get: function () { return this._distanceDisplayCondition }, set: function (e) { bt.equals(e, this._distanceDisplayCondition) || (this._distanceDisplayCondition = bt.clone(e, this._distanceDisplayCondition), Fm(this, rUe)) } } }); Tl.prototype.update = function () { let e = F.IDENTITY; l(this._polylineCollection) && (e = this._polylineCollection.modelMatrix); let t = this._segments.positions.length, n = this._segments.lengths, i = this._propertiesChanged[Ane] > 0 || this._propertiesChanged[YS] > 0; if ((!F.equals(e, this._modelMatrix) || i) && (this._segments = xi.wrapLongitude(this._actualPositions, e), this._boundingVolumeWC = re.transform(this._boundingVolume, e, this._boundingVolumeWC)), this._modelMatrix = F.clone(e, this._modelMatrix), this._segments.positions.length !== t) Fm(this, YS); else { let o = n.length; for (let r = 0; r < o; ++r)if (n[r] !== this._segments.lengths[r]) { Fm(this, YS); break } } }; Tl.prototype.getPickId = function (e) { return l(this._pickId) || (this._pickId = e.createPickId({ primitive: this, collection: this._polylineCollection, id: this._id })), this._pickId }; Tl.prototype._clean = function () { this._dirty = !1; let e = this._propertiesChanged; for (let t = 0; t < Cne - 1; ++t)e[t] = 0 }; Tl.prototype._destroy = function () { this._pickId = this._pickId && this._pickId.destroy(), this._material = this._material && this._material.destroy(), this._polylineCollection = void 0 }; var Sf = Tl; var sUe = Sf.SHOW_INDEX, aUe = Sf.WIDTH_INDEX, s5 = Sf.POSITION_INDEX, cUe = Sf.MATERIAL_INDEX, xne = Sf.POSITION_SIZE_INDEX, lUe = Sf.DISTANCE_DISPLAY_CONDITION, vne = Sf.NUMBER_OF_PROPERTIES, Gc = { texCoordExpandAndBatchIndex: 0, position3DHigh: 1, position3DLow: 2, position2DHigh: 3, position2DLow: 4, prevPosition3DHigh: 5, prevPosition3DLow: 6, prevPosition2DHigh: 7, prevPosition2DLow: 8, nextPosition3DHigh: 9, nextPosition3DLow: 10, nextPosition2DHigh: 11, nextPosition2DLow: 12 }; function wf(e) { e = y(e, y.EMPTY_OBJECT), this.show = y(e.show, !0), this.modelMatrix = F.clone(y(e.modelMatrix, F.IDENTITY)), this._modelMatrix = F.clone(F.IDENTITY), this.debugShowBoundingVolume = y(e.debugShowBoundingVolume, !1), this._opaqueRS = void 0, this._translucentRS = void 0, this._colorCommands = [], this._polylinesUpdated = !1, this._polylinesRemoved = !1, this._createVertexArray = !1, this._propertiesChanged = new Uint32Array(vne), this._polylines = [], this._polylineBuckets = {}, this._positionBufferUsage = { bufferUsage: Re.STATIC_DRAW, frameCount: 0 }, this._mode = void 0, this._polylinesToUpdate = [], this._vertexArrays = [], this._positionBuffer = void 0, this._texCoordExpandAndBatchIndexBuffer = void 0, this._batchTable = void 0, this._createBatchTable = !1, this._useHighlightColor = !1, this._highlightColor = U.clone(U.WHITE); let t = this; this._uniformMap = { u_highlightColor: function () { return t._highlightColor } } } Object.defineProperties(wf.prototype, { length: { get: function () { return a5(this), this._polylines.length } } }); wf.prototype.add = function (e) { let t = new Sf(e, this); return t._index = this._polylines.length, this._polylines.push(t), this._createVertexArray = !0, this._createBatchTable = !0, t }; wf.prototype.remove = function (e) { if (this.contains(e)) { if (this._polylinesRemoved = !0, this._createVertexArray = !0, this._createBatchTable = !0, l(e._bucket)) { let t = e._bucket; t.shaderProgram = t.shaderProgram && t.shaderProgram.destroy() } return e._destroy(), !0 } return !1 }; wf.prototype.removeAll = function () { c5(this), Rne(this), this._polylineBuckets = {}, this._polylinesRemoved = !1, this._polylines.length = 0, this._polylinesToUpdate.length = 0, this._createVertexArray = !0 }; wf.prototype.contains = function (e) { return l(e) && e._polylineCollection === this }; wf.prototype.get = function (e) { return a5(this), this._polylines[e] }; function uUe(e, t) { l(e._batchTable) && e._batchTable.destroy(); let n = [{ functionName: "batchTable_getWidthAndShow", componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 2 }, { functionName: "batchTable_getPickColor", componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 4, normalize: !0 }, { functionName: "batchTable_getCenterHigh", componentDatatype: Y.FLOAT, componentsPerAttribute: 3 }, { functionName: "batchTable_getCenterLowAndRadius", componentDatatype: Y.FLOAT, componentsPerAttribute: 4 }, { functionName: "batchTable_getDistanceDisplayCondition", componentDatatype: Y.FLOAT, componentsPerAttribute: 2 }]; e._batchTable = new fC(t, n, e._polylines.length) } var Pne = new Vn, Ine = new se, One = new H; wf.prototype.update = function (e) { if (a5(this), this._polylines.length === 0 || !this.show) return; _Ue(this, e); let t = e.context, n = e.mapProjection, i, o = this._propertiesChanged; if (this._createBatchTable) { if (Ut.maximumVertexTextureImageUnits === 0) throw new fe("Vertex texture fetch support is required to render polylines. The maximum number of vertex texture image units must be greater than zero."); uUe(this, t), this._createBatchTable = !1 } if (this._createVertexArray || dUe(this)) bne(this, t, n); else if (this._polylinesUpdated) { let c = this._polylinesToUpdate; if (this._mode !== ee.SCENE3D) { let u = c.length; for (let f = 0; f < u; ++f)i = c[f], i.update() } if (o[xne] || o[cUe]) bne(this, t, n); else { let u = c.length, f = this._polylineBuckets; for (let d = 0; d < u; ++d) { i = c[d], o = i._propertiesChanged; let p = i._bucket, g = 0; for (let m in f) if (f.hasOwnProperty(m)) { if (f[m] === p) { o[s5] && p.writeUpdate(g, i, this._positionBuffer, n); break } g += f[m].lengthOfPositions } if ((o[sUe] || o[aUe]) && this._batchTable.setBatchedAttribute(i._index, 0, new H(i._width, i._show)), this._batchTable.attributes.length > 2) { if (o[s5] || o[xne]) { let m = e.mode === ee.SCENE2D ? i._boundingVolume2D : i._boundingVolumeWC, A = Vn.fromCartesian(m.center, Pne), C = se.fromElements(A.low.x, A.low.y, A.low.z, m.radius, Ine); this._batchTable.setBatchedAttribute(i._index, 2, A.high), this._batchTable.setBatchedAttribute(i._index, 3, C) } if (o[lUe]) { let m = One; m.x = 0, m.y = Number.MAX_VALUE; let A = i.distanceDisplayCondition; l(A) && (m.x = A.near, m.y = A.far), this._batchTable.setBatchedAttribute(i._index, 4, m) } } i._clean() } } c.length = 0, this._polylinesUpdated = !1 } o = this._propertiesChanged; for (let c = 0; c < vne; ++c)o[c] = 0; let r = F.IDENTITY; e.mode === ee.SCENE3D && (r = this.modelMatrix); let s = e.passes, a = e.morphTime !== 0; if ((!l(this._opaqueRS) || this._opaqueRS.depthTest.enabled !== a) && (this._opaqueRS = Ve.fromCache({ depthMask: a, depthTest: { enabled: a } })), (!l(this._translucentRS) || this._translucentRS.depthTest.enabled !== a) && (this._translucentRS = Ve.fromCache({ blending: an.ALPHA_BLEND, depthMask: !a, depthTest: { enabled: a } })), this._batchTable.update(e), s.render || s.pick) { let c = this._colorCommands; fUe(this, e, c, r) } }; var XS = new re, Tne = new re; function fUe(e, t, n, i) { let o = t.context, r = t.commandList, s = n.length, a = 0, c = !0, u = e._vertexArrays, f = e.debugShowBoundingVolume, p = e._batchTable.getUniformMapCallback(), g = u.length; for (let m = 0; m < g; ++m) { let A = u[m], C = A.buckets, x = C.length; for (let T = 0; T < x; ++T) { let b = C[T], S = b.offset, D = b.bucket.shaderProgram, P = b.bucket.polylines, B = P.length, R, M, L = 0, _, E; for (let w = 0; w < B; ++w) { let v = P[w], O = mUe(v._material); if (O !== R) { if (l(R) && L > 0) { let G = M.isTranslucent(); a >= s ? (_ = new $e({ owner: e }), n.push(_)) : _ = n[a], ++a, E = yt(p(M._uniforms), e._uniformMap), _.boundingVolume = re.clone(XS, _.boundingVolume), _.modelMatrix = i, _.shaderProgram = D, _.vertexArray = A.va, _.renderState = G ? e._translucentRS : e._opaqueRS, _.pass = G ? xe.TRANSLUCENT : xe.OPAQUE, _.debugShowBoundingVolume = f, _.pickId = "v_pickColor", _.uniformMap = E, _.count = L, _.offset = S, S += L, L = 0, c = !0, r.push(_) } M = v._material, M.update(o), R = O } let V = v._locatorBuckets, z = V.length; for (let G = 0; G < z; ++G) { let N = V[G]; N.locator === b && (L += N.count) } let k; t.mode === ee.SCENE3D ? k = v._boundingVolumeWC : t.mode === ee.COLUMBUS_VIEW ? k = v._boundingVolume2D : t.mode === ee.SCENE2D ? l(v._boundingVolume2D) && (k = re.clone(v._boundingVolume2D, Tne), k.center.x = 0) : l(v._boundingVolumeWC) && l(v._boundingVolume2D) && (k = re.union(v._boundingVolumeWC, v._boundingVolume2D, Tne)), c ? (c = !1, re.clone(k, XS)) : re.union(k, XS, XS) } l(R) && L > 0 && (a >= s ? (_ = new $e({ owner: e }), n.push(_)) : _ = n[a], ++a, E = yt(p(M._uniforms), e._uniformMap), _.boundingVolume = re.clone(XS, _.boundingVolume), _.modelMatrix = i, _.shaderProgram = D, _.vertexArray = A.va, _.renderState = M.isTranslucent() ? e._translucentRS : e._opaqueRS, _.pass = M.isTranslucent() ? xe.TRANSLUCENT : xe.OPAQUE, _.debugShowBoundingVolume = f, _.pickId = "v_pickColor", _.uniformMap = E, _.count = L, _.offset = S, c = !0, r.push(_)), R = void 0 } } n.length = a } wf.prototype.isDestroyed = function () { return !1 }; wf.prototype.destroy = function () { return Bne(this), c5(this), Rne(this), this._batchTable = this._batchTable && this._batchTable.destroy(), le(this) }; function dUe(e) { let t = !1, n = e._propertiesChanged, i = e._positionBufferUsage; return n[s5] ? (i.bufferUsage !== Re.STREAM_DRAW && (t = !0, i.bufferUsage = Re.STREAM_DRAW), i.frameCount = 100) : i.bufferUsage !== Re.STATIC_DRAW && (i.frameCount === 0 ? (t = !0, i.bufferUsage = Re.STATIC_DRAW) : i.frameCount--), t } var Ene = [0, 0, 0]; function bne(e, t, n) { e._createVertexArray = !1, c5(e), Bne(e), pUe(e); let i = [[]], o = i[0], r = e._batchTable, s = e._useHighlightColor, a = [0], c = 0, u = [[]], f = 0, d = e._polylineBuckets, p, g; for (p in d) d.hasOwnProperty(p) && (g = d[p], g.updateShader(t, r, s), f += g.lengthOfPositions); if (f > 0) { let m = e._mode, A = new Float32Array(6 * f * 3), C = new Float32Array(f * 4), x, T = 0, b = 0, S = 0; for (p in d) if (d.hasOwnProperty(p)) { g = d[p], g.write(A, C, T, b, S, r, t, n), m === ee.MORPHING && (l(x) || (x = new Float32Array(6 * f * 3)), g.writeForMorph(x, T)); let E = g.lengthOfPositions; T += 6 * E * 3, b += E * 4, S += E * 4, c = g.updateIndices(i, a, u, c) } let D = e._positionBufferUsage.bufferUsage, P = Re.STATIC_DRAW; e._positionBuffer = ct.createVertexBuffer({ context: t, typedArray: A, usage: D }); let B; l(x) && (B = ct.createVertexBuffer({ context: t, typedArray: x, usage: D })), e._texCoordExpandAndBatchIndexBuffer = ct.createVertexBuffer({ context: t, typedArray: C, usage: P }); let R = 3 * Float32Array.BYTES_PER_ELEMENT, M = 4 * Float32Array.BYTES_PER_ELEMENT, L = 0, _ = i.length; for (let E = 0; E < _; ++E)if (o = i[E], o.length > 0) { let w = new Uint16Array(o), v = ct.createIndexBuffer({ context: t, typedArray: w, usage: Re.STATIC_DRAW, indexDatatype: Me.UNSIGNED_SHORT }); L += a[E]; let O = 6 * (E * (R * I.SIXTY_FOUR_KILOBYTES) - L * R), V = R + O, z = R + V, k = R + z, G = R + k, N = R + G, X = E * (M * I.SIXTY_FOUR_KILOBYTES) - L * M, q = [{ index: Gc.position3DHigh, componentsPerAttribute: 3, componentDatatype: Y.FLOAT, offsetInBytes: O, strideInBytes: 6 * R }, { index: Gc.position3DLow, componentsPerAttribute: 3, componentDatatype: Y.FLOAT, offsetInBytes: V, strideInBytes: 6 * R }, { index: Gc.position2DHigh, componentsPerAttribute: 3, componentDatatype: Y.FLOAT, offsetInBytes: O, strideInBytes: 6 * R }, { index: Gc.position2DLow, componentsPerAttribute: 3, componentDatatype: Y.FLOAT, offsetInBytes: V, strideInBytes: 6 * R }, { index: Gc.prevPosition3DHigh, componentsPerAttribute: 3, componentDatatype: Y.FLOAT, offsetInBytes: z, strideInBytes: 6 * R }, { index: Gc.prevPosition3DLow, componentsPerAttribute: 3, componentDatatype: Y.FLOAT, offsetInBytes: k, strideInBytes: 6 * R }, { index: Gc.prevPosition2DHigh, componentsPerAttribute: 3, componentDatatype: Y.FLOAT, offsetInBytes: z, strideInBytes: 6 * R }, { index: Gc.prevPosition2DLow, componentsPerAttribute: 3, componentDatatype: Y.FLOAT, offsetInBytes: k, strideInBytes: 6 * R }, { index: Gc.nextPosition3DHigh, componentsPerAttribute: 3, componentDatatype: Y.FLOAT, offsetInBytes: G, strideInBytes: 6 * R }, { index: Gc.nextPosition3DLow, componentsPerAttribute: 3, componentDatatype: Y.FLOAT, offsetInBytes: N, strideInBytes: 6 * R }, { index: Gc.nextPosition2DHigh, componentsPerAttribute: 3, componentDatatype: Y.FLOAT, offsetInBytes: G, strideInBytes: 6 * R }, { index: Gc.nextPosition2DLow, componentsPerAttribute: 3, componentDatatype: Y.FLOAT, offsetInBytes: N, strideInBytes: 6 * R }, { index: Gc.texCoordExpandAndBatchIndex, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, vertexBuffer: e._texCoordExpandAndBatchIndexBuffer, offsetInBytes: X }], J, W, K, Z; m === ee.SCENE3D ? (W = e._positionBuffer, J = "vertexBuffer", K = Ene, Z = "value") : m === ee.SCENE2D || m === ee.COLUMBUS_VIEW ? (W = Ene, J = "value", K = e._positionBuffer, Z = "vertexBuffer") : (W = B, J = "vertexBuffer", K = e._positionBuffer, Z = "vertexBuffer"), q[0][J] = W, q[1][J] = W, q[2][Z] = K, q[3][Z] = K, q[4][J] = W, q[5][J] = W, q[6][Z] = K, q[7][Z] = K, q[8][J] = W, q[9][J] = W, q[10][Z] = K, q[11][Z] = K; let de = new Qn({ context: t, attributes: q, indexBuffer: v }); e._vertexArrays.push({ va: de, buckets: u[E] }) } } } function hUe(e, t) { return t instanceof Rt ? t.id : t } var ML = []; function mUe(e) { let t = Ki._uniformList[e.type], n = t.length; ML.length = 2 * n; let i = 0; for (let o = 0; o < n; ++o) { let r = t[o]; ML[i] = r, ML[i + 1] = e._uniforms[r](), i += 2 } return `${e.type}:${JSON.stringify(ML, hUe)}` } function pUe(e) { let t = e._mode, n = e._modelMatrix, i = e._polylineBuckets = {}, o = e._polylines, r = o.length; for (let s = 0; s < r; ++s) { let a = o[s]; if (a._actualPositions.length > 1) { a.update(); let c = a.material, u = i[c.type]; l(u) || (u = i[c.type] = new $d(c, t, n)), u.addPolyline(a) } } } function _Ue(e, t) { let n = t.mode; (e._mode !== n || !F.equals(e._modelMatrix, e.modelMatrix)) && (e._mode = n, e._modelMatrix = F.clone(e.modelMatrix), e._createVertexArray = !0) } function a5(e) { if (e._polylinesRemoved) { e._polylinesRemoved = !1; let t = [], n = [], i = 0, o, r = e._polylines.length; for (let s = 0; s < r; ++s)o = e._polylines[s], o.isDestroyed || (o._index = i++, n.push(o), t.push(o)); e._polylines = t, e._polylinesToUpdate = n } } function c5(e) { let t = e._polylines, n = t.length; for (let i = 0; i < n; ++i)if (!t[i].isDestroyed) { let o = t[i]._bucket; l(o) && (o.shaderProgram = o.shaderProgram && o.shaderProgram.destroy()) } } function Bne(e) { let t = e._vertexArrays.length; for (let n = 0; n < t; ++n)e._vertexArrays[n].va.destroy(); e._vertexArrays.length = 0 } wf.prototype._updatePolyline = function (e, t) { this._polylinesUpdated = !0, e._dirty || this._polylinesToUpdate.push(e), ++this._propertiesChanged[t] }; function Rne(e) { let t = e._polylines, n = t.length; for (let i = 0; i < n; ++i)t[i].isDestroyed || t[i]._destroy() } function r5(e, t, n) { this.count = e, this.offset = t, this.bucket = n } function $d(e, t, n) { this.polylines = [], this.lengthOfPositions = 0, this.material = e, this.shaderProgram = void 0, this.mode = t, this.modelMatrix = n } $d.prototype.addPolyline = function (e) { this.polylines.push(e), e._actualLength = this.getPolylinePositionsLength(e), this.lengthOfPositions += e._actualLength, e._bucket = this }; $d.prototype.updateShader = function (e, t, n) {
        if (l(this.shaderProgram)) return; let i = ["DISTANCE_DISPLAY_CONDITION"]; n && i.push("VECTOR_TILE"), this.material.shaderSource.search(/varying\s+float\s+v_polylineAngle;/g) !== -1 && i.push("POLYLINE_DASH"), Nt.isInternetExplorer() || i.push("CLIP_POLYLINE"); let o = new Ue({
            defines: i, sources: [`varying vec4 v_pickColor;
`, this.material.shaderSource, TC]
        }), r = t.getVertexShaderCallback()(OL), s = new Ue({ defines: i, sources: [ru, r] }); this.shaderProgram = qt.fromCache({ context: e, vertexShaderSource: s, fragmentShaderSource: o, attributeLocations: Gc })
    }; function Mne(e) { return h.dot(h.UNIT_X, e._boundingVolume.center) < 0 || e._boundingVolume.intersectPlane(nn.ORIGIN_ZX_PLANE) === Kt.INTERSECTING } $d.prototype.getPolylinePositionsLength = function (e) { let t; if (this.mode === ee.SCENE3D || !Mne(e)) return t = e._actualPositions.length, t * 4 - 4; let n = 0, i = e._segments.lengths; t = i.length; for (let o = 0; o < t; ++o)n += i[o] * 4 - 4; return n }; var Qr = new h, Cu = new h, xu = new h, LL = new h, gUe = new se, yUe = new H; $d.prototype.write = function (e, t, n, i, o, r, s, a) { let c = this.mode, u = a.ellipsoid.maximumRadius * I.PI, f = this.polylines, d = f.length; for (let p = 0; p < d; ++p) { let g = f[p], m = g.width, A = g.show && m > 0, C = g._index, x = this.getSegments(g, a), T = x.positions, b = x.lengths, S = T.length, D = g.getPickId(s).color, P = 0, B = 0, R; for (let z = 0; z < S; ++z) { z === 0 ? g._loop ? R = T[S - 2] : (R = LL, h.subtract(T[0], T[1], R), h.add(T[0], R, R)) : R = T[z - 1], h.clone(R, Cu), h.clone(T[z], Qr), z === S - 1 ? g._loop ? R = T[1] : (R = LL, h.subtract(T[S - 1], T[S - 2], R), h.add(T[S - 1], R, R)) : R = T[z + 1], h.clone(R, xu); let k = b[P]; z === B + k && (B += k, ++P); let G = z - B === 0, N = z === B + b[P] - 1; c === ee.SCENE2D && (Cu.z = 0, Qr.z = 0, xu.z = 0), (c === ee.SCENE2D || c === ee.MORPHING) && (G || N) && u - Math.abs(Qr.x) < 1 && ((Qr.x < 0 && Cu.x > 0 || Qr.x > 0 && Cu.x < 0) && h.clone(Qr, Cu), (Qr.x < 0 && xu.x > 0 || Qr.x > 0 && xu.x < 0) && h.clone(Qr, xu)); let X = G ? 2 : 0, q = N ? 2 : 4; for (let J = X; J < q; ++J) { Vn.writeElements(Qr, e, n), Vn.writeElements(Cu, e, n + 6), Vn.writeElements(xu, e, n + 12); let W = J - 2 < 0 ? -1 : 1; t[o] = z / (S - 1), t[o + 1] = 2 * (J % 2) - 1, t[o + 2] = W, t[o + 3] = C, n += 6 * 3, o += 4 } } let M = gUe; M.x = U.floatToByte(D.red), M.y = U.floatToByte(D.green), M.z = U.floatToByte(D.blue), M.w = U.floatToByte(D.alpha); let L = yUe; L.x = m, L.y = A ? 1 : 0; let _ = c === ee.SCENE2D ? g._boundingVolume2D : g._boundingVolumeWC, E = Vn.fromCartesian(_.center, Pne), w = E.high, v = se.fromElements(E.low.x, E.low.y, E.low.z, _.radius, Ine), O = One; O.x = 0, O.y = Number.MAX_VALUE; let V = g.distanceDisplayCondition; l(V) && (O.x = V.near, O.y = V.far), r.setBatchedAttribute(C, 0, L), r.setBatchedAttribute(C, 1, M), r.attributes.length > 2 && (r.setBatchedAttribute(C, 2, w), r.setBatchedAttribute(C, 3, v), r.setBatchedAttribute(C, 4, O)) } }; var AUe = new h, CUe = new h, xUe = new h, Sne = new h; $d.prototype.writeForMorph = function (e, t) { let n = this.modelMatrix, i = this.polylines, o = i.length; for (let r = 0; r < o; ++r) { let s = i[r], a = s._segments.positions, c = s._segments.lengths, u = a.length, f = 0, d = 0; for (let p = 0; p < u; ++p) { let g; p === 0 ? s._loop ? g = a[u - 2] : (g = Sne, h.subtract(a[0], a[1], g), h.add(a[0], g, g)) : g = a[p - 1], g = F.multiplyByPoint(n, g, CUe); let m = F.multiplyByPoint(n, a[p], AUe), A; p === u - 1 ? s._loop ? A = a[1] : (A = Sne, h.subtract(a[u - 1], a[u - 2], A), h.add(a[u - 1], A, A)) : A = a[p + 1], A = F.multiplyByPoint(n, A, xUe); let C = c[f]; p === d + C && (d += C, ++f); let x = p - d === 0, T = p === d + c[f] - 1, b = x ? 2 : 0, S = T ? 2 : 4; for (let D = b; D < S; ++D)Vn.writeElements(m, e, t), Vn.writeElements(g, e, t + 6), Vn.writeElements(A, e, t + 12), t += 6 * 3 } } }; var TUe = new Array(1); $d.prototype.updateIndices = function (e, t, n, i) { let o = n.length - 1, r = new r5(0, i, this); n[o].push(r); let s = 0, a = e[e.length - 1], c = 0; a.length > 0 && (c = a[a.length - 1] + 1); let u = this.polylines, f = u.length; for (let d = 0; d < f; ++d) { let p = u[d]; p._locatorBuckets = []; let g; if (this.mode === ee.SCENE3D) { g = TUe; let A = p._actualPositions.length; if (A > 0) g[0] = A; else continue } else g = p._segments.lengths; let m = g.length; if (m > 0) { let A = 0; for (let C = 0; C < m; ++C) { let x = g[C] - 1; for (let T = 0; T < x; ++T)c + 4 > I.SIXTY_FOUR_KILOBYTES && (p._locatorBuckets.push({ locator: r, count: A }), A = 0, t.push(4), a = [], e.push(a), c = 0, r.count = s, s = 0, i = 0, r = new r5(0, 0, this), n[++o] = [r]), a.push(c, c + 2, c + 1), a.push(c + 1, c + 2, c + 3), A += 6, s += 6, i += 6, c += 4 } p._locatorBuckets.push({ locator: r, count: A }), c + 4 > I.SIXTY_FOUR_KILOBYTES && (t.push(0), a = [], e.push(a), c = 0, r.count = s, i = 0, s = 0, r = new r5(0, 0, this), n[++o] = [r]) } p._clean() } return r.count = s, i }; $d.prototype.getPolylineStartIndex = function (e) { let t = this.polylines, n = 0, i = t.length; for (let o = 0; o < i; ++o) { let r = t[o]; if (r === e) break; n += r._actualLength } return n }; var Cx = { positions: void 0, lengths: void 0 }, wne = new Array(1), EUe = new h, bUe = new he; $d.prototype.getSegments = function (e, t) { let n = e._actualPositions; if (this.mode === ee.SCENE3D) return wne[0] = n.length, Cx.positions = n, Cx.lengths = wne, Cx; Mne(e) && (n = e._segments.positions); let i = t.ellipsoid, o = [], r = this.modelMatrix, s = n.length, a, c = EUe; for (let u = 0; u < s; ++u)a = n[u], c = F.multiplyByPoint(r, a, c), o.push(t.project(i.cartesianToCartographic(c, bUe))); if (o.length > 0) { e._boundingVolume2D = re.fromPoints(o, e._boundingVolume2D); let u = e._boundingVolume2D.center; e._boundingVolume2D.center = new h(u.z, u.x, u.y) } return Cx.positions = o, Cx.lengths = e._segments.lengths, Cx }; var Dne; $d.prototype.writeUpdate = function (e, t, n, i) { let o = this.mode, r = i.ellipsoid.maximumRadius * I.PI, s = t._actualLength; if (s) { e += this.getPolylineStartIndex(t); let a = Dne, c = 6 * s * 3; !l(a) || a.length < c ? a = Dne = new Float32Array(c) : a.length > c && (a = new Float32Array(a.buffer, 0, c)); let u = this.getSegments(t, i), f = u.positions, d = u.lengths, p = 0, g = 0, m = 0, A; s = f.length; for (let C = 0; C < s; ++C) { C === 0 ? t._loop ? A = f[s - 2] : (A = LL, h.subtract(f[0], f[1], A), h.add(f[0], A, A)) : A = f[C - 1], h.clone(A, Cu), h.clone(f[C], Qr), C === s - 1 ? t._loop ? A = f[1] : (A = LL, h.subtract(f[s - 1], f[s - 2], A), h.add(f[s - 1], A, A)) : A = f[C + 1], h.clone(A, xu); let x = d[g]; C === m + x && (m += x, ++g); let T = C - m === 0, b = C === m + d[g] - 1; o === ee.SCENE2D && (Cu.z = 0, Qr.z = 0, xu.z = 0), (o === ee.SCENE2D || o === ee.MORPHING) && (T || b) && r - Math.abs(Qr.x) < 1 && ((Qr.x < 0 && Cu.x > 0 || Qr.x > 0 && Cu.x < 0) && h.clone(Qr, Cu), (Qr.x < 0 && xu.x > 0 || Qr.x > 0 && xu.x < 0) && h.clone(Qr, xu)); let S = T ? 2 : 0, D = b ? 2 : 4; for (let P = S; P < D; ++P)Vn.writeElements(Qr, a, p), Vn.writeElements(Cu, a, p + 6), Vn.writeElements(xu, a, p + 12), p += 6 * 3 } n.copyFromArrayView(a, 6 * 3 * Float32Array.BYTES_PER_ELEMENT * e) } }; var D_ = wf; function v_(e) { this._positions = e.positions, this._batchTable = e.batchTable, this._batchIds = e.batchIds, this._rectangle = e.rectangle, this._minHeight = e.minimumHeight, this._maxHeight = e.maximumHeight, this._billboardCollection = new yu({ batchTable: e.batchTable }), this._labelCollection = new Lm({ batchTable: e.batchTable }), this._polylineCollection = new D_, this._polylineCollection._useHighlightColor = !0, this._verticesPromise = void 0, this._packedBuffer = void 0, this._ready = !1, this._update = function (t, n) { }, this._readyPromise = FUe(this) } Object.defineProperties(v_.prototype, { pointsLength: { get: function () { return this._billboardCollection.length } }, texturesByteLength: { get: function () { let e = this._billboardCollection.textureAtlas.texture.sizeInBytes, t = this._labelCollection._textureAtlas.texture.sizeInBytes; return e + t } }, readyPromise: { get: function () { return this._readyPromise } } }); function SUe(e, t) { let n = e._rectangle, i = e._minHeight, o = e._maxHeight, r = 2 + ce.packedLength + ie.packedLength, s = new Float64Array(r), a = 0; return s[a++] = i, s[a++] = o, ce.pack(n, s, a), a += ce.packedLength, ie.pack(t, s, a), s } var wUe = new yi("createVectorTilePoints", 5), DUe = new h; function vUe(e, t) { let n; if (!l(e._verticesPromise)) { n = e._positions; let i = e._packedBuffer; l(i) || (n = e._positions = n.slice(), e._batchIds = e._batchIds.slice(), i = e._packedBuffer = SUe(e, t)); let o = [n.buffer, i.buffer], r = { positions: n.buffer, packedBuffer: i.buffer }, s = e._verticesPromise = wUe.scheduleTask(r, o); return l(s) ? s.then(function (a) { e._positions = new Float64Array(a.positions); let c = e._billboardCollection, u = e._labelCollection, f = e._polylineCollection; n = e._positions; let d = e._batchIds, p = n.length / 3; for (let g = 0; g < p; ++g) { let m = d[g], A = h.unpack(n, g * 3, DUe), C = c.add(); C.position = A, C._batchIndex = m; let x = u.add(); x.text = " ", x.position = A, x._batchIndex = m; let T = f.add(); T.positions = [h.clone(A), h.clone(A)] } e._positions = void 0, e._packedBuffer = void 0, e._ready = !0 }) : void 0 } } v_.prototype.createFeatures = function (e, t) { let n = this._billboardCollection, i = this._labelCollection, o = this._polylineCollection, r = this._batchIds, s = r.length; for (let a = 0; a < s; ++a) { let c = r[a], u = n.get(a), f = i.get(a), d = o.get(a); t[c] = new S_(e, c, u, f, d) } }; v_.prototype.applyDebugSettings = function (e, t) { e ? (U.clone(t, this._billboardCollection._highlightColor), U.clone(t, this._labelCollection._highlightColor), U.clone(t, this._polylineCollection._highlightColor)) : (U.clone(U.WHITE, this._billboardCollection._highlightColor), U.clone(U.WHITE, this._labelCollection._highlightColor), U.clone(U.WHITE, this._polylineCollection._highlightColor)) }; function PUe(e, t) { let n = e._batchIds, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o], s = t[r]; s.show = !0, s.pointSize = S_.defaultPointSize, s.color = S_.defaultColor, s.pointOutlineColor = S_.defaultPointOutlineColor, s.pointOutlineWidth = S_.defaultPointOutlineWidth, s.labelColor = U.WHITE, s.labelOutlineColor = U.WHITE, s.labelOutlineWidth = 1, s.font = "30px sans-serif", s.labelStyle = Fo.FILL, s.labelText = void 0, s.backgroundColor = new U(.165, .165, .165, .8), s.backgroundPadding = new H(7, 5), s.backgroundEnabled = !1, s.scaleByDistance = void 0, s.translucencyByDistance = void 0, s.distanceDisplayCondition = void 0, s.heightOffset = 0, s.anchorLineEnabled = !1, s.anchorLineColor = U.WHITE, s.image = void 0, s.disableDepthTestDistance = 0, s.horizontalOrigin = ai.CENTER, s.verticalOrigin = Sn.CENTER, s.labelHorizontalOrigin = ai.RIGHT, s.labelVerticalOrigin = Sn.BASELINE } } var IUe = new U, OUe = new U, BUe = new U, RUe = new U, MUe = new U, LUe = new U, KS = new wt, JS = new wt, l5 = new bt; v_.prototype.applyStyle = function (e, t) { if (!l(e)) { PUe(this, t); return } let n = this._batchIds, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o], s = t[r]; if (l(e.show) && (s.show = e.show.evaluate(s)), l(e.pointSize) && (s.pointSize = e.pointSize.evaluate(s)), l(e.color) && (s.color = e.color.evaluateColor(s, IUe)), l(e.pointOutlineColor) && (s.pointOutlineColor = e.pointOutlineColor.evaluateColor(s, OUe)), l(e.pointOutlineWidth) && (s.pointOutlineWidth = e.pointOutlineWidth.evaluate(s)), l(e.labelColor) && (s.labelColor = e.labelColor.evaluateColor(s, BUe)), l(e.labelOutlineColor) && (s.labelOutlineColor = e.labelOutlineColor.evaluateColor(s, RUe)), l(e.labelOutlineWidth) && (s.labelOutlineWidth = e.labelOutlineWidth.evaluate(s)), l(e.font) && (s.font = e.font.evaluate(s)), l(e.labelStyle) && (s.labelStyle = e.labelStyle.evaluate(s)), l(e.labelText) ? s.labelText = e.labelText.evaluate(s) : s.labelText = void 0, l(e.backgroundColor) && (s.backgroundColor = e.backgroundColor.evaluateColor(s, MUe)), l(e.backgroundPadding) && (s.backgroundPadding = e.backgroundPadding.evaluate(s)), l(e.backgroundEnabled) && (s.backgroundEnabled = e.backgroundEnabled.evaluate(s)), l(e.scaleByDistance)) { let a = e.scaleByDistance.evaluate(s); KS.near = a.x, KS.nearValue = a.y, KS.far = a.z, KS.farValue = a.w, s.scaleByDistance = KS } else s.scaleByDistance = void 0; if (l(e.translucencyByDistance)) { let a = e.translucencyByDistance.evaluate(s); JS.near = a.x, JS.nearValue = a.y, JS.far = a.z, JS.farValue = a.w, s.translucencyByDistance = JS } else s.translucencyByDistance = void 0; if (l(e.distanceDisplayCondition)) { let a = e.distanceDisplayCondition.evaluate(s); l5.near = a.x, l5.far = a.y, s.distanceDisplayCondition = l5 } else s.distanceDisplayCondition = void 0; l(e.heightOffset) && (s.heightOffset = e.heightOffset.evaluate(s)), l(e.anchorLineEnabled) && (s.anchorLineEnabled = e.anchorLineEnabled.evaluate(s)), l(e.anchorLineColor) && (s.anchorLineColor = e.anchorLineColor.evaluateColor(s, LUe)), l(e.image) ? s.image = e.image.evaluate(s) : s.image = void 0, l(e.disableDepthTestDistance) && (s.disableDepthTestDistance = e.disableDepthTestDistance.evaluate(s)), l(e.horizontalOrigin) && (s.horizontalOrigin = e.horizontalOrigin.evaluate(s)), l(e.verticalOrigin) && (s.verticalOrigin = e.verticalOrigin.evaluate(s)), l(e.labelHorizontalOrigin) && (s.labelHorizontalOrigin = e.labelHorizontalOrigin.evaluate(s)), l(e.labelVerticalOrigin) && (s.labelVerticalOrigin = e.labelVerticalOrigin.evaluate(s)) } }; function FUe(e) { return new Promise(function (t, n) { e._update = function (i, o) { let r = vUe(i, o.mapProjection.ellipsoid); i._ready && (i._polylineCollection.update(o), i._billboardCollection.update(o), i._labelCollection.update(o)), l(r) && r.then(function () { t() }).catch(function (s) { n(s) }) } }) } v_.prototype.update = function (e) { this._update(this, e) }; v_.prototype.isDestroyed = function () { return !1 }; v_.prototype.destroy = function () { return this._billboardCollection = this._billboardCollection && this._billboardCollection.destroy(), this._labelCollection = this._labelCollection && this._labelCollection.destroy(), this._polylineCollection = this._polylineCollection && this._polylineCollection.destroy(), le(this) }; var FL = v_; function Nm(e) { this._batchTable = e.batchTable, this._batchIds = e.batchIds, this._positions = e.positions, this._counts = e.counts, this._indices = e.indices, this._indexCounts = e.indexCounts, this._indexOffsets = void 0, this._batchTableColors = void 0, this._packedBuffer = void 0, this._batchedPositions = void 0, this._transferrableBatchIds = void 0, this._vertexBatchIds = void 0, this._ellipsoid = y(e.ellipsoid, ie.WGS84), this._minimumHeight = e.minimumHeight, this._maximumHeight = e.maximumHeight, this._polygonMinimumHeights = e.polygonMinimumHeights, this._polygonMaximumHeights = e.polygonMaximumHeights, this._center = y(e.center, h.ZERO), this._rectangle = e.rectangle, this._center = void 0, this._boundingVolume = e.boundingVolume, this._boundingVolumes = void 0, this._batchedIndices = void 0, this._ready = !1, this._update = function (t, n) { }, this._readyPromise = GUe(this), this._verticesPromise = void 0, this._primitive = void 0, this.debugWireframe = !1, this.forceRebatch = !1, this.classificationType = Ln.BOTH } Object.defineProperties(Nm.prototype, { trianglesLength: { get: function () { return l(this._primitive) ? this._primitive.trianglesLength : 0 } }, geometryByteLength: { get: function () { return l(this._primitive) ? this._primitive.geometryByteLength : 0 } }, readyPromise: { get: function () { return this._readyPromise } } }); function NUe(e) { let t = new Float64Array(3 + h.packedLength + ie.packedLength + ce.packedLength), n = 0; return t[n++] = e._indices.BYTES_PER_ELEMENT, t[n++] = e._minimumHeight, t[n++] = e._maximumHeight, h.pack(e._center, t, n), n += h.packedLength, ie.pack(e._ellipsoid, t, n), n += ie.packedLength, ce.pack(e._rectangle, t, n), t } function VUe(e, t) { let n = 1, i = t[n++], o = e._boundingVolumes = new Array(i); for (let a = 0; a < i; ++a)o[a] = di.unpack(t, n), n += di.packedLength; let r = t[n++], s = e._batchedIndices = new Array(r); for (let a = 0; a < r; ++a) { let c = U.unpack(t, n); n += U.packedLength; let u = t[n++], f = t[n++], d = t[n++], p = new Array(d); for (let g = 0; g < d; ++g)p[g] = t[n++]; s[a] = new mm({ color: c, offset: u, count: f, batchIds: p }) } } var kUe = new yi("createVectorTilePolygons", 5), UUe = new U; function zUe(e) { if (!l(e._primitive) && !l(e._verticesPromise)) { let t = e._positions, n = e._counts, i = e._indexCounts, o = e._indices, r = e._transferrableBatchIds, s = e._batchTableColors, a = e._packedBuffer; if (!l(s)) { t = e._positions = e._positions.slice(), n = e._counts = e._counts.slice(), i = e._indexCounts = e._indexCounts.slice(), o = e._indices = e._indices.slice(), e._center = e._ellipsoid.cartographicToCartesian(ce.center(e._rectangle)), r = e._transferrableBatchIds = new Uint32Array(e._batchIds), s = e._batchTableColors = new Uint32Array(r.length); let g = e._batchTable, m = s.length; for (let A = 0; A < m; ++A) { let C = g.getColor(A, UUe); s[A] = C.toRgba() } a = e._packedBuffer = NUe(e) } let c = [t.buffer, n.buffer, i.buffer, o.buffer, r.buffer, s.buffer, a.buffer], u = { packedBuffer: a.buffer, positions: t.buffer, counts: n.buffer, indexCounts: i.buffer, indices: o.buffer, batchIds: r.buffer, batchTableColors: s.buffer }, f = e._polygonMinimumHeights, d = e._polygonMaximumHeights; l(f) && l(d) && (f = f.slice(), d = d.slice(), c.push(f.buffer, d.buffer), u.minimumHeights = f, u.maximumHeights = d); let p = e._verticesPromise = kUe.scheduleTask(u, c); return l(p) ? p.then(function (g) { e._positions = void 0, e._counts = void 0, e._polygonMinimumHeights = void 0, e._polygonMaximumHeights = void 0; let m = new Float64Array(g.packedBuffer), A = m[0]; VUe(e, m), e._indices = Me.getSizeInBytes(A) === 2 ? new Uint16Array(g.indices) : new Uint32Array(g.indices), e._indexOffsets = new Uint32Array(g.indexOffsets), e._indexCounts = new Uint32Array(g.indexCounts), e._batchedPositions = new Float32Array(g.positions), e._vertexBatchIds = new Uint16Array(g.batchIds), e._ready = !0 }) : void 0 } } function HUe(e) { e._ready && !l(e._primitive) && (e._primitive = new zC({ batchTable: e._batchTable, positions: e._batchedPositions, batchIds: e._batchIds, vertexBatchIds: e._vertexBatchIds, indices: e._indices, indexOffsets: e._indexOffsets, indexCounts: e._indexCounts, batchedIndices: e._batchedIndices, boundingVolume: e._boundingVolume, boundingVolumes: e._boundingVolumes, center: e._center }), e._batchTable = void 0, e._batchIds = void 0, e._positions = void 0, e._counts = void 0, e._indices = void 0, e._indexCounts = void 0, e._indexOffsets = void 0, e._batchTableColors = void 0, e._packedBuffer = void 0, e._batchedPositions = void 0, e._transferrableBatchIds = void 0, e._vertexBatchIds = void 0, e._ellipsoid = void 0, e._minimumHeight = void 0, e._maximumHeight = void 0, e._polygonMinimumHeights = void 0, e._polygonMaximumHeights = void 0, e._center = void 0, e._rectangle = void 0, e._boundingVolume = void 0, e._boundingVolumes = void 0, e._batchedIndices = void 0, e._verticesPromise = void 0) } Nm.prototype.createFeatures = function (e, t) { this._primitive.createFeatures(e, t) }; Nm.prototype.applyDebugSettings = function (e, t) { this._primitive.applyDebugSettings(e, t) }; Nm.prototype.applyStyle = function (e, t) { this._primitive.applyStyle(e, t) }; Nm.prototype.updateCommands = function (e, t) { this._primitive.updateCommands(e, t) }; function GUe(e) { return new Promise(function (t, n) { e._update = function (i, o) { let r = zUe(i); i._ready && (i._primitive.debugWireframe = i.debugWireframe, i._primitive.forceRebatch = i.forceRebatch, i._primitive.classificationType = i.classificationType, i._primitive.update(o)), l(r) && r.then(function () { HUe(i), t(i) }).catch(function (s) { n(s) }) } }) } Nm.prototype.update = function (e) { this._update(this, e) }; Nm.prototype.isDestroyed = function () { return !1 }; Nm.prototype.destroy = function () { return this._primitive = this._primitive && this._primitive.destroy(), le(this) }; var NL = Nm; var VL = `attribute vec4 currentPosition;
attribute vec4 previousPosition;
attribute vec4 nextPosition;
attribute vec2 expandAndWidth;
attribute float a_batchId;
uniform mat4 u_modifiedModelView;
void main()
{
float expandDir = expandAndWidth.x;
float width = abs(expandAndWidth.y) + 0.5;
bool usePrev = expandAndWidth.y < 0.0;
vec4 p = u_modifiedModelView * currentPosition;
vec4 prev = u_modifiedModelView * previousPosition;
vec4 next = u_modifiedModelView * nextPosition;
float angle;
vec4 positionWC = getPolylineWindowCoordinatesEC(p, prev, next, expandDir, width, usePrev, angle);
gl_Position = czm_viewportOrthographic * positionWC;
}
`; function Df(e) { this._positions = e.positions, this._widths = e.widths, this._counts = e.counts, this._batchIds = e.batchIds, this._ellipsoid = y(e.ellipsoid, ie.WGS84), this._minimumHeight = e.minimumHeight, this._maximumHeight = e.maximumHeight, this._center = e.center, this._rectangle = e.rectangle, this._boundingVolume = e.boundingVolume, this._batchTable = e.batchTable, this._va = void 0, this._sp = void 0, this._rs = void 0, this._uniformMap = void 0, this._command = void 0, this._transferrableBatchIds = void 0, this._packedBuffer = void 0, this._keepDecodedPositions = e.keepDecodedPositions, this._decodedPositions = void 0, this._decodedPositionOffsets = void 0, this._currentPositions = void 0, this._previousPositions = void 0, this._nextPositions = void 0, this._expandAndWidth = void 0, this._vertexBatchIds = void 0, this._indices = void 0, this._constantColor = U.clone(U.WHITE), this._highlightColor = this._constantColor, this._trianglesLength = 0, this._geometryByteLength = 0, this._ready = !1, this._update = function (t, n) { }, this._readyPromise = i4e(this), this._verticesPromise = void 0 } Object.defineProperties(Df.prototype, { trianglesLength: { get: function () { return this._trianglesLength } }, geometryByteLength: { get: function () { return this._geometryByteLength } }, readyPromise: { get: function () { return this._readyPromise } } }); function WUe(e) { let t = e._rectangle, n = e._minimumHeight, i = e._maximumHeight, o = e._ellipsoid, r = e._center, s = 2 + ce.packedLength + ie.packedLength + h.packedLength, a = new Float64Array(s), c = 0; return a[c++] = n, a[c++] = i, ce.pack(t, a, c), c += ce.packedLength, ie.pack(o, a, c), c += ie.packedLength, h.pack(r, a, c), a } var jUe = new yi("createVectorTilePolylines", 5), xx = { previousPosition: 0, currentPosition: 1, nextPosition: 2, expandAndWidth: 3, a_batchId: 4 }; function qUe(e, t) { if (!l(e._va) && !l(e._verticesPromise)) { let n = e._positions, i = e._widths, o = e._counts, r = e._transferrableBatchIds, s = e._packedBuffer; l(s) || (n = e._positions = n.slice(), i = e._widths = i.slice(), o = e._counts = o.slice(), r = e._transferrableBatchIds = e._batchIds.slice(), s = e._packedBuffer = WUe(e)); let a = [n.buffer, i.buffer, o.buffer, r.buffer, s.buffer], c = { positions: n.buffer, widths: i.buffer, counts: o.buffer, batchIds: r.buffer, packedBuffer: s.buffer, keepDecodedPositions: e._keepDecodedPositions }, u = e._verticesPromise = jUe.scheduleTask(c, a); return l(u) ? u.then(function (f) { e._keepDecodedPositions && (e._decodedPositions = new Float64Array(f.decodedPositions), e._decodedPositionOffsets = new Uint32Array(f.decodedPositionOffsets)), e._currentPositions = new Float32Array(f.currentPositions), e._previousPositions = new Float32Array(f.previousPositions), e._nextPositions = new Float32Array(f.nextPositions), e._expandAndWidth = new Float32Array(f.expandAndWidth), e._vertexBatchIds = new Uint16Array(f.batchIds); let d = f.indexDatatype; e._indices = d === Me.UNSIGNED_SHORT ? new Uint16Array(f.indices) : new Uint32Array(f.indices), e._ready = !0 }) : void 0 } } function YUe(e, t) { if (e._ready && !l(e._va)) { let n = e._currentPositions, i = e._previousPositions, o = e._nextPositions, r = e._expandAndWidth, s = e._vertexBatchIds, a = e._indices, c = i.byteLength + n.byteLength + o.byteLength; c += r.byteLength + s.byteLength + a.byteLength, e._trianglesLength = a.length / 3, e._geometryByteLength = c; let u = ct.createVertexBuffer({ context: t, typedArray: i, usage: Re.STATIC_DRAW }), f = ct.createVertexBuffer({ context: t, typedArray: n, usage: Re.STATIC_DRAW }), d = ct.createVertexBuffer({ context: t, typedArray: o, usage: Re.STATIC_DRAW }), p = ct.createVertexBuffer({ context: t, typedArray: r, usage: Re.STATIC_DRAW }), g = ct.createVertexBuffer({ context: t, typedArray: s, usage: Re.STATIC_DRAW }), m = ct.createIndexBuffer({ context: t, typedArray: a, usage: Re.STATIC_DRAW, indexDatatype: a.BYTES_PER_ELEMENT === 2 ? Me.UNSIGNED_SHORT : Me.UNSIGNED_INT }), A = [{ index: xx.previousPosition, vertexBuffer: u, componentDatatype: Y.FLOAT, componentsPerAttribute: 3 }, { index: xx.currentPosition, vertexBuffer: f, componentDatatype: Y.FLOAT, componentsPerAttribute: 3 }, { index: xx.nextPosition, vertexBuffer: d, componentDatatype: Y.FLOAT, componentsPerAttribute: 3 }, { index: xx.expandAndWidth, vertexBuffer: p, componentDatatype: Y.FLOAT, componentsPerAttribute: 2 }, { index: xx.a_batchId, vertexBuffer: g, componentDatatype: Y.UNSIGNED_SHORT, componentsPerAttribute: 1 }]; e._va = new Qn({ context: t, attributes: A, indexBuffer: m }), e._positions = void 0, e._widths = void 0, e._counts = void 0, e._ellipsoid = void 0, e._minimumHeight = void 0, e._maximumHeight = void 0, e._rectangle = void 0, e._transferrableBatchIds = void 0, e._packedBuffer = void 0, e._currentPositions = void 0, e._previousPositions = void 0, e._nextPositions = void 0, e._expandAndWidth = void 0, e._vertexBatchIds = void 0, e._indices = void 0 } } var ZS = new F, Lne = new h; function XUe(e, t) { l(e._uniformMap) || (e._uniformMap = { u_modifiedModelView: function () { let n = t.uniformState.view; return F.clone(n, ZS), F.multiplyByPoint(ZS, e._center, Lne), F.setTranslation(ZS, Lne, ZS), ZS }, u_highlightColor: function () { return e._highlightColor } }) } function KUe(e) { if (l(e._rs)) return; let t = { enabled: !0, factor: -5, units: -5 }; e._rs = Ve.fromCache({ blending: an.ALPHA_BLEND, depthMask: !1, depthTest: { enabled: !0 }, polygonOffset: t }) } var JUe = `uniform vec4 u_highlightColor; 
void main()
{
    gl_FragColor = u_highlightColor;
}
`; function ZUe(e, t) { if (l(e._sp)) return; let n = e._batchTable, i = n.getVertexShaderCallback(!1, "a_batchId", void 0)(VL), o = n.getFragmentShaderCallback(!1, void 0, !1)(JUe), r = new Ue({ defines: ["VECTOR_TILE", Nt.isInternetExplorer() ? "" : "CLIP_POLYLINE"], sources: [ru, i] }), s = new Ue({ defines: ["VECTOR_TILE"], sources: [o] }); e._sp = qt.fromCache({ context: t, vertexShaderSource: r, fragmentShaderSource: s, attributeLocations: xx }) } function QUe(e, t) { if (!l(e._command)) { let n = e._batchTable.getUniformMapCallback()(e._uniformMap); e._command = new $e({ owner: e, vertexArray: e._va, renderState: e._rs, shaderProgram: e._sp, uniformMap: n, boundingVolume: e._boundingVolume, pass: xe.TRANSLUCENT, pickId: e._batchTable.getPickId() }) } t.commandList.push(e._command) } Df.getPolylinePositions = function (e, t) { let n = e._batchIds, i = e._decodedPositions, o = e._decodedPositionOffsets; if (!l(n) || !l(i)) return; let r, s, a = n.length, c = 0, u = 0; for (r = 0; r < a; ++r)n[r] === t && (c += o[r + 1] - o[r]); if (c === 0) return; let f = new Float64Array(c * 3); for (r = 0; r < a; ++r)if (n[r] === t) { let d = o[r], p = o[r + 1] - d; for (s = 0; s < p; ++s) { let g = (d + s) * 3; f[u++] = i[g], f[u++] = i[g + 1], f[u++] = i[g + 2] } } return f }; Df.prototype.getPositions = function (e) { return Df.getPolylinePositions(this, e) }; Df.prototype.createFeatures = function (e, t) { let n = this._batchIds, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; t[r] = new xs(e, r) } }; Df.prototype.applyDebugSettings = function (e, t) { this._highlightColor = e ? t : this._constantColor }; function $Ue(e, t) { let n = e._batchIds, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o], s = t[r]; s.show = !0, s.color = U.WHITE } } var e4e = new U, t4e = U.WHITE, n4e = !0; Df.prototype.applyStyle = function (e, t) { if (!l(e)) { $Ue(this, t); return } let n = this._batchIds, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o], s = t[r]; s.color = l(e.color) ? e.color.evaluateColor(s, e4e) : t4e, s.show = l(e.show) ? e.show.evaluate(s) : n4e } }; function i4e(e) { return new Promise(function (t, n) { e._update = function (i, o) { let r = o.context, s = qUe(i, r); if (XUe(i, r), ZUe(i, r), KUe(i), i._ready) { let a = o.passes; (a.render || a.pick) && QUe(i, o) } !l(s) || s.then(function () { YUe(i, r), t() }).catch(function (a) { n(a) }) } }) } Df.prototype.update = function (e) { this._update(this, e) }; Df.prototype.isDestroyed = function () { return !1 }; Df.prototype.destroy = function () { return this._va = this._va && this._va.destroy(), this._sp = this._sp && this._sp.destroy(), le(this) }; var Tx = Df; var kL = `attribute vec3 startEllipsoidNormal;
attribute vec3 endEllipsoidNormal;
attribute vec4 startPositionAndHeight;
attribute vec4 endPositionAndHeight;
attribute vec4 startFaceNormalAndVertexCorner;
attribute vec4 endFaceNormalAndHalfWidth;
attribute float a_batchId;
uniform mat4 u_modifiedModelView;
uniform vec2 u_minimumMaximumVectorHeights;
varying vec4 v_startPlaneEC;
varying vec4 v_endPlaneEC;
varying vec4 v_rightPlaneEC;
varying float v_halfWidth;
varying vec3 v_volumeUpEC;
void main()
{
float isEnd = floor(startFaceNormalAndVertexCorner.w * 0.251);
float isTop = floor(startFaceNormalAndVertexCorner.w * mix(0.51, 0.19, isEnd));
vec3 forward = endPositionAndHeight.xyz - startPositionAndHeight.xyz;
vec3 right = normalize(cross(forward, startEllipsoidNormal));
vec4 position = vec4(startPositionAndHeight.xyz, 1.0);
position.xyz += forward * isEnd;
v_volumeUpEC = czm_normal * normalize(cross(right, forward));
float offset;
vec3 ellipsoidNormal = mix(startEllipsoidNormal, endEllipsoidNormal, isEnd);
offset = mix(startPositionAndHeight.w, endPositionAndHeight.w, isEnd);
offset = mix(u_minimumMaximumVectorHeights.y, u_minimumMaximumVectorHeights.x, isTop) - offset;
position.xyz += offset * ellipsoidNormal;
position = u_modifiedModelView * position;
right = czm_normal * right;
vec3 scratchNormal = mix(-startFaceNormalAndVertexCorner.xyz, endFaceNormalAndHalfWidth.xyz, isEnd);
scratchNormal = cross(scratchNormal, mix(startEllipsoidNormal, endEllipsoidNormal, isEnd));
vec3 miterPushNormal = czm_normal * normalize(scratchNormal);
offset = 2.0 * endFaceNormalAndHalfWidth.w * max(0.0, czm_metersPerPixel(position));
offset = offset / dot(miterPushNormal, right);
position.xyz += miterPushNormal * (offset * sign(0.5 - mod(startFaceNormalAndVertexCorner.w, 2.0)));
gl_Position = czm_depthClamp(czm_projection * position);
position = u_modifiedModelView * vec4(startPositionAndHeight.xyz, 1.0);
vec3 startNormalEC = czm_normal * startFaceNormalAndVertexCorner.xyz;
v_startPlaneEC = vec4(startNormalEC, -dot(startNormalEC, position.xyz));
v_rightPlaneEC = vec4(right, -dot(right, position.xyz));
position = u_modifiedModelView * vec4(endPositionAndHeight.xyz, 1.0);
vec3 endNormalEC = czm_normal * endFaceNormalAndHalfWidth.xyz;
v_endPlaneEC = vec4(endNormalEC, -dot(endNormalEC, position.xyz));
v_halfWidth = endFaceNormalAndHalfWidth.w;
}
`; var UL = `#ifdef GL_EXT_frag_depth
#extension GL_EXT_frag_depth : enable
#endif
varying vec4 v_startPlaneEC;
varying vec4 v_endPlaneEC;
varying vec4 v_rightPlaneEC;
varying float v_halfWidth;
varying vec3 v_volumeUpEC;
uniform vec4 u_highlightColor;
void main()
{
float logDepthOrDepth = czm_branchFreeTernary(czm_sceneMode == czm_sceneMode2D, gl_FragCoord.z, czm_unpackDepth(texture2D(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw)));
if (logDepthOrDepth == 0.0) {
#ifdef DEBUG_SHOW_VOLUME
gl_FragColor = vec4(0.0, 0.0, 1.0, 0.5);
return;
#else // DEBUG_SHOW_VOLUME
discard;
#endif // DEBUG_SHOW_VOLUME
}
vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);
eyeCoordinate /= eyeCoordinate.w;
float halfMaxWidth = v_halfWidth * czm_metersPerPixel(eyeCoordinate);
halfMaxWidth += halfMaxWidth * (1.0 - dot(-normalize(eyeCoordinate.xyz), v_volumeUpEC));
float widthwiseDistance = czm_planeDistance(v_rightPlaneEC, eyeCoordinate.xyz);
float distanceFromStart = czm_planeDistance(v_startPlaneEC, eyeCoordinate.xyz);
float distanceFromEnd = czm_planeDistance(v_endPlaneEC, eyeCoordinate.xyz);
if (abs(widthwiseDistance) > halfMaxWidth || distanceFromStart < 0.0 || distanceFromEnd < 0.0) {
#ifdef DEBUG_SHOW_VOLUME
gl_FragColor = vec4(logDepthOrDepth, 0.0, 0.0, 0.5);
return;
#else // DEBUG_SHOW_VOLUME
discard;
#endif // DEBUG_SHOW_VOLUME
}
gl_FragColor = u_highlightColor;
czm_writeDepthClamp();
}
`; function Vm(e) { this._positions = e.positions, this._widths = e.widths, this._counts = e.counts, this._batchIds = e.batchIds, this._ellipsoid = y(e.ellipsoid, ie.WGS84), this._minimumHeight = e.minimumHeight, this._maximumHeight = e.maximumHeight, this._center = e.center, this._rectangle = e.rectangle, this._batchTable = e.batchTable, this._va = void 0, this._sp = void 0, this._rs = void 0, this._uniformMap = void 0, this._command = void 0, this._transferrableBatchIds = void 0, this._packedBuffer = void 0, this._minimumMaximumVectorHeights = new H(oi._defaultMinTerrainHeight, oi._defaultMaxTerrainHeight), this._boundingVolume = di.fromRectangle(e.rectangle, oi._defaultMinTerrainHeight, oi._defaultMaxTerrainHeight, this._ellipsoid), this._classificationType = e.classificationType, this._keepDecodedPositions = e.keepDecodedPositions, this._decodedPositions = void 0, this._decodedPositionOffsets = void 0, this._startEllipsoidNormals = void 0, this._endEllipsoidNormals = void 0, this._startPositionAndHeights = void 0, this._startFaceNormalAndVertexCornerIds = void 0, this._endPositionAndHeights = void 0, this._endFaceNormalAndHalfWidths = void 0, this._vertexBatchIds = void 0, this._indices = void 0, this._constantColor = U.clone(U.WHITE), this._highlightColor = this._constantColor, this._trianglesLength = 0, this._geometryByteLength = 0, this._ready = !1, this._update = function (t, n) { }, this._readyPromise = g4e(this), this._verticesPromise = void 0 } Object.defineProperties(Vm.prototype, { trianglesLength: { get: function () { return this._trianglesLength } }, geometryByteLength: { get: function () { return this._geometryByteLength } }, readyPromise: { get: function () { return this._readyPromise } } }); function o4e(e, t, n) { let i = oi.getMinimumMaximumHeights(t, n), o = i.minimumTerrainHeight, r = i.maximumTerrainHeight, s = e._minimumMaximumVectorHeights; s.x = o, s.y = r; let a = e._boundingVolume, c = e._rectangle; di.fromRectangle(c, o, r, n, a) } function r4e(e) { let t = e._rectangle, n = e._minimumHeight, i = e._maximumHeight, o = e._ellipsoid, r = e._center, s = 2 + ce.packedLength + ie.packedLength + h.packedLength, a = new Float64Array(s), c = 0; return a[c++] = n, a[c++] = i, ce.pack(t, a, c), c += ce.packedLength, ie.pack(o, a, c), c += ie.packedLength, h.pack(r, a, c), a } var s4e = new yi("createVectorTileClampedPolylines"), P_ = { startEllipsoidNormal: 0, endEllipsoidNormal: 1, startPositionAndHeight: 2, endPositionAndHeight: 3, startFaceNormalAndVertexCorner: 4, endFaceNormalAndHalfWidth: 5, a_batchId: 6 }; function a4e(e, t) { if (!l(e._va) && !l(e._verticesPromise)) { let n = e._positions, i = e._widths, o = e._counts, r = e._transferrableBatchIds, s = e._packedBuffer; l(s) || (n = e._positions = n.slice(), i = e._widths = i.slice(), o = e._counts = o.slice(), r = e._transferrableBatchIds = e._batchIds.slice(), s = e._packedBuffer = r4e(e)); let a = [n.buffer, i.buffer, o.buffer, r.buffer, s.buffer], c = { positions: n.buffer, widths: i.buffer, counts: o.buffer, batchIds: r.buffer, packedBuffer: s.buffer, keepDecodedPositions: e._keepDecodedPositions }, u = e._verticesPromise = s4e.scheduleTask(c, a); return l(u) ? u.then(function (f) { e._keepDecodedPositions && (e._decodedPositions = new Float64Array(f.decodedPositions), e._decodedPositionOffsets = new Uint32Array(f.decodedPositionOffsets)), e._startEllipsoidNormals = new Float32Array(f.startEllipsoidNormals), e._endEllipsoidNormals = new Float32Array(f.endEllipsoidNormals), e._startPositionAndHeights = new Float32Array(f.startPositionAndHeights), e._startFaceNormalAndVertexCornerIds = new Float32Array(f.startFaceNormalAndVertexCornerIds), e._endPositionAndHeights = new Float32Array(f.endPositionAndHeights), e._endFaceNormalAndHalfWidths = new Float32Array(f.endFaceNormalAndHalfWidths), e._vertexBatchIds = new Uint16Array(f.vertexBatchIds); let d = f.indexDatatype; e._indices = d === Me.UNSIGNED_SHORT ? new Uint16Array(f.indices) : new Uint32Array(f.indices), e._ready = !0 }) : void 0 } } function c4e(e, t) { if (e._ready && !l(e._va)) { let n = e._startEllipsoidNormals, i = e._endEllipsoidNormals, o = e._startPositionAndHeights, r = e._endPositionAndHeights, s = e._startFaceNormalAndVertexCornerIds, a = e._endFaceNormalAndHalfWidths, c = e._vertexBatchIds, u = e._indices, f = n.byteLength + i.byteLength; f += o.byteLength + r.byteLength, f += s.byteLength + a.byteLength, f += c.byteLength + u.byteLength, e._trianglesLength = u.length / 3, e._geometryByteLength = f; let d = ct.createVertexBuffer({ context: t, typedArray: n, usage: Re.STATIC_DRAW }), p = ct.createVertexBuffer({ context: t, typedArray: i, usage: Re.STATIC_DRAW }), g = ct.createVertexBuffer({ context: t, typedArray: o, usage: Re.STATIC_DRAW }), m = ct.createVertexBuffer({ context: t, typedArray: r, usage: Re.STATIC_DRAW }), A = ct.createVertexBuffer({ context: t, typedArray: s, usage: Re.STATIC_DRAW }), C = ct.createVertexBuffer({ context: t, typedArray: a, usage: Re.STATIC_DRAW }), x = ct.createVertexBuffer({ context: t, typedArray: c, usage: Re.STATIC_DRAW }), T = ct.createIndexBuffer({ context: t, typedArray: u, usage: Re.STATIC_DRAW, indexDatatype: u.BYTES_PER_ELEMENT === 2 ? Me.UNSIGNED_SHORT : Me.UNSIGNED_INT }), b = [{ index: P_.startEllipsoidNormal, vertexBuffer: d, componentDatatype: Y.FLOAT, componentsPerAttribute: 3 }, { index: P_.endEllipsoidNormal, vertexBuffer: p, componentDatatype: Y.FLOAT, componentsPerAttribute: 3 }, { index: P_.startPositionAndHeight, vertexBuffer: g, componentDatatype: Y.FLOAT, componentsPerAttribute: 4 }, { index: P_.endPositionAndHeight, vertexBuffer: m, componentDatatype: Y.FLOAT, componentsPerAttribute: 4 }, { index: P_.startFaceNormalAndVertexCorner, vertexBuffer: A, componentDatatype: Y.FLOAT, componentsPerAttribute: 4 }, { index: P_.endFaceNormalAndHalfWidth, vertexBuffer: C, componentDatatype: Y.FLOAT, componentsPerAttribute: 4 }, { index: P_.a_batchId, vertexBuffer: x, componentDatatype: Y.UNSIGNED_SHORT, componentsPerAttribute: 1 }]; e._va = new Qn({ context: t, attributes: b, indexBuffer: T }), e._positions = void 0, e._widths = void 0, e._counts = void 0, e._ellipsoid = void 0, e._minimumHeight = void 0, e._maximumHeight = void 0, e._rectangle = void 0, e._transferrableBatchIds = void 0, e._packedBuffer = void 0, e._startEllipsoidNormals = void 0, e._endEllipsoidNormals = void 0, e._startPositionAndHeights = void 0, e._startFaceNormalAndVertexCornerIds = void 0, e._endPositionAndHeights = void 0, e._endFaceNormalAndHalfWidths = void 0, e._vertexBatchIds = void 0, e._indices = void 0 } } var QS = new F, Fne = new h; function l4e(e, t) { l(e._uniformMap) || (e._uniformMap = { u_modifiedModelView: function () { let n = t.uniformState.view; return F.clone(n, QS), F.multiplyByPoint(QS, e._center, Fne), F.setTranslation(QS, Fne, QS), QS }, u_highlightColor: function () { return e._highlightColor }, u_minimumMaximumVectorHeights: function () { return e._minimumMaximumVectorHeights } }) } function Nne(e) { return Ve.fromCache({ cull: { enabled: !0, face: gi.FRONT }, blending: an.PRE_MULTIPLIED_ALPHA_BLEND, depthMask: !1, stencilTest: { enabled: e, frontFunction: Fn.EQUAL, frontOperation: { fail: lt.KEEP, zFail: lt.KEEP, zPass: lt.KEEP }, backFunction: Fn.EQUAL, backOperation: { fail: lt.KEEP, zFail: lt.KEEP, zPass: lt.KEEP }, reference: vt.CESIUM_3D_TILE_MASK, mask: vt.CESIUM_3D_TILE_MASK } }) } function u4e(e) { l(e._rs) || (e._rs = Nne(!1), e._rs3DTiles = Nne(!0)) } function f4e(e, t) { if (l(e._sp)) return; let n = e._batchTable, i = n.getVertexShaderCallback(!1, "a_batchId", void 0)(kL), o = n.getFragmentShaderCallback(!1, void 0, !0)(UL), r = new Ue({ defines: ["VECTOR_TILE", Nt.isInternetExplorer() ? "" : "CLIP_POLYLINE"], sources: [ru, i] }), s = new Ue({ defines: ["VECTOR_TILE"], sources: [o] }); e._sp = qt.fromCache({ context: t, vertexShaderSource: r, fragmentShaderSource: s, attributeLocations: P_ }) } function d4e(e, t) { let n = e._command; if (!l(e._command)) { let o = e._batchTable.getUniformMapCallback()(e._uniformMap); n = e._command = new $e({ owner: e, vertexArray: e._va, renderState: e._rs, shaderProgram: e._sp, uniformMap: o, boundingVolume: e._boundingVolume, pass: xe.TERRAIN_CLASSIFICATION, pickId: e._batchTable.getPickId() }); let r = $e.shallowClone(n, n.derivedCommands.tileset); r.renderState = e._rs3DTiles, r.pass = xe.CESIUM_3D_TILE_CLASSIFICATION, n.derivedCommands.tileset = r } let i = e._classificationType; (i === Ln.TERRAIN || i === Ln.BOTH) && t.commandList.push(n), (i === Ln.CESIUM_3D_TILE || i === Ln.BOTH) && t.commandList.push(n.derivedCommands.tileset) } Vm.prototype.getPositions = function (e) { return Tx.getPolylinePositions(this, e) }; Vm.prototype.createFeatures = function (e, t) { let n = this._batchIds, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; t[r] = new xs(e, r) } }; Vm.prototype.applyDebugSettings = function (e, t) { this._highlightColor = e ? t : this._constantColor }; function h4e(e, t) { let n = e._batchIds, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o], s = t[r]; s.show = !0, s.color = U.WHITE } } var m4e = new U, p4e = U.WHITE, _4e = !0; Vm.prototype.applyStyle = function (e, t) { if (!l(e)) { h4e(this, t); return } let n = this._batchIds, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o], s = t[r]; s.color = l(e.color) ? e.color.evaluateColor(s, m4e) : p4e, s.show = l(e.show) ? e.show.evaluate(s) : _4e } }; function g4e(e) { return oi.initialize().then(function () { return o4e(e, e._rectangle, e._ellipsoid), new Promise(function (t, n) { e._update = function (i, o) { let r = o.context, s = a4e(i, r); if (l4e(i, r), f4e(i, r), u4e(i), i._ready) { let a = o.passes; (a.render || a.pick) && d4e(i, o) } !l(s) || s.then(function () { c4e(i, r), t(i) }).catch(function (a) { n(a) }) } }) }) } Vm.prototype.update = function (e) { this._update(this, e) }; Vm.prototype.isDestroyed = function () { return !1 }; Vm.prototype.destroy = function () { return this._va = this._va && this._va.destroy(), this._sp = this._sp && this._sp.destroy(), le(this) }; var zL = Vm; var u5 = 32767, y4e = new he, A4e = new h; function C4e(e, t, n, i, o) { let r = e.length / 3, s = e.subarray(0, r), a = e.subarray(r, 2 * r), c = e.subarray(2 * r, 3 * r); kn.zigZagDeltaDecode(s, a, c); let u = new Float64Array(e.length); for (let f = 0; f < r; ++f) { let d = s[f], p = a[f], g = c[f], m = I.lerp(t.west, t.east, d / u5), A = I.lerp(t.south, t.north, p / u5), C = I.lerp(n, i, g / u5), x = he.fromRadians(m, A, C, y4e), T = o.cartographicToCartesian(x, A4e); h.pack(T, u, f * 3) } return u } var HL = C4e; function eh(e, t, n, i, o) { this._tileset = e, this._tile = t, this._resource = n, this._polygons = void 0, this._polylines = void 0, this._points = void 0, this._metadata = void 0, this._batchTable = void 0, this._features = void 0, this.featurePropertiesDirty = !1, this._group = void 0, S4e(this, i, o) } Object.defineProperties(eh.prototype, { featuresLength: { get: function () { return l(this._batchTable) ? this._batchTable.featuresLength : 0 } }, pointsLength: { get: function () { return l(this._points) ? this._points.pointsLength : 0 } }, trianglesLength: { get: function () { let e = 0; return l(this._polygons) && (e += this._polygons.trianglesLength), l(this._polylines) && (e += this._polylines.trianglesLength), e } }, geometryByteLength: { get: function () { let e = 0; return l(this._polygons) && (e += this._polygons.geometryByteLength), l(this._polylines) && (e += this._polylines.geometryByteLength), e } }, texturesByteLength: { get: function () { return l(this._points) ? this._points.texturesByteLength : 0 } }, batchTableByteLength: { get: function () { return l(this._batchTable) ? this._batchTable.batchTableByteLength : 0 } }, innerContents: { get: function () { } }, readyPromise: { get: function () { let e = l(this._points) ? this._points.readyPromise : void 0, t = l(this._polygons) ? this._polygons.readyPromise : void 0, n = l(this._polylines) ? this._polylines.readyPromise : void 0, i = this; return Promise.all([e, t, n]).then(function () { return i }) } }, tileset: { get: function () { return this._tileset } }, tile: { get: function () { return this._tile } }, url: { get: function () { return this._resource.getUrlComponent(!0) } }, metadata: { get: function () { return this._metadata }, set: function (e) { this._metadata = e } }, batchTable: { get: function () { return this._batchTable } }, group: { get: function () { return this._group }, set: function (e) { this._group = e } } }); function x4e(e) { return function (t, n) { l(e._polygons) && e._polygons.updateCommands(t, n) } } function T4e(e, t) { let n, i, o, r, s = y(e.POLYGONS_LENGTH, 0), a = y(e.POLYLINES_LENGTH, 0), c = y(e.POINTS_LENGTH, 0); if (s > 0 && l(e.POLYGON_BATCH_IDS)) { let p = t.byteOffset + e.POLYGON_BATCH_IDS.byteOffset; n = new Uint16Array(t.buffer, p, s) } if (a > 0 && l(e.POLYLINE_BATCH_IDS)) { let p = t.byteOffset + e.POLYLINE_BATCH_IDS.byteOffset; i = new Uint16Array(t.buffer, p, a) } if (c > 0 && l(e.POINT_BATCH_IDS)) { let p = t.byteOffset + e.POINT_BATCH_IDS.byteOffset; o = new Uint16Array(t.buffer, p, c) } let u = l(n) || l(i) || l(o), f = s > 0 && !l(n) || a > 0 && !l(i) || c > 0 && !l(o); if (u && f) throw new fe("If one group of batch ids is defined, then all batch ids must be defined."); if (!l(n) && !l(i) && !l(o)) { let p = 0; if (!l(n) && s > 0) for (n = new Uint16Array(s), r = 0; r < s; ++r)n[r] = p++; if (!l(i) && a > 0) for (i = new Uint16Array(a), r = 0; r < a; ++r)i[r] = p++; if (!l(o) && c > 0) for (o = new Uint16Array(c), r = 0; r < c; ++r)o[r] = p++ } return { polygons: n, polylines: i, points: o } } var vf = Uint32Array.BYTES_PER_ELEMENT; function E4e(e) { return new Tx(e) } function b4e(e) { return new zL(e) } function S4e(e, t, n) { n = y(n, 0); let i = new Uint8Array(t), o = new DataView(t); n += vf; let r = o.getUint32(n, !0); if (r !== 1) throw new fe(`Only Vector tile version 1 is supported.  Version ${r} is not.`); n += vf; let s = o.getUint32(n, !0); if (n += vf, s === 0) return Promise.resolve(e); let a = o.getUint32(n, !0); if (n += vf, a === 0) throw new fe("Feature table must have a byte length greater than zero"); let c = o.getUint32(n, !0); n += vf; let u = o.getUint32(n, !0); n += vf; let f = o.getUint32(n, !0); n += vf; let d = o.getUint32(n, !0); n += vf; let p = o.getUint32(n, !0); n += vf; let g = o.getUint32(n, !0); n += vf; let m = o.getUint32(n, !0); n += vf; let A = Ko(i, n, a); n += a; let C = new Uint8Array(t, n, c); n += c; let x, T; u > 0 && (x = Ko(i, n, u), n += u, f > 0 && (T = new Uint8Array(t, n, f), T = new Uint8Array(T), n += f)); let b = y(A.POLYGONS_LENGTH, 0), S = y(A.POLYLINES_LENGTH, 0), D = y(A.POINTS_LENGTH, 0), P = b + S + D, B = new Xp(e, P, x, T, x4e(e)); if (e._batchTable = B, P === 0) return; let R = new Yd(A, C), M = R.getGlobalProperty("REGION"); if (!l(M)) throw new fe("Feature table global property: REGION must be defined"); let L = ce.unpack(M), _ = M[4], E = M[5], w = e._tile.computedTransform, v = R.getGlobalProperty("RTC_CENTER", Y.FLOAT, 3); l(v) ? (v = h.unpack(v), F.multiplyByPoint(w, v, v)) : (v = ce.center(L), v.height = I.lerp(_, E, .5), v = ie.WGS84.cartographicToCartesian(v)); let O = T4e(A, C); if (n += (4 - n % 4) % 4, b > 0) { R.featuresLength = b; let V = y(R.getPropertyArray("POLYGON_COUNTS", Y.UNSIGNED_INT, 1), R.getPropertyArray("POLYGON_COUNT", Y.UNSIGNED_INT, 1)); if (!l(V)) throw new fe("Feature table property: POLYGON_COUNTS must be defined when POLYGONS_LENGTH is greater than 0"); let z = y(R.getPropertyArray("POLYGON_INDEX_COUNTS", Y.UNSIGNED_INT, 1), R.getPropertyArray("POLYGON_INDEX_COUNT", Y.UNSIGNED_INT, 1)); if (!l(z)) throw new fe("Feature table property: POLYGON_INDEX_COUNTS must be defined when POLYGONS_LENGTH is greater than 0"); let k = V.reduce(function (W, K) { return W + K * 2 }, 0), G = z.reduce(function (W, K) { return W + K }, 0), N = new Uint32Array(t, n, G); n += d; let X = new Uint16Array(t, n, k); n += p; let q, J; l(A.POLYGON_MINIMUM_HEIGHTS) && l(A.POLYGON_MAXIMUM_HEIGHTS) && (q = R.getPropertyArray("POLYGON_MINIMUM_HEIGHTS", Y.FLOAT, 1), J = R.getPropertyArray("POLYGON_MAXIMUM_HEIGHTS", Y.FLOAT, 1)), e._polygons = new NL({ positions: X, counts: V, indexCounts: z, indices: N, minimumHeight: _, maximumHeight: E, polygonMinimumHeights: q, polygonMaximumHeights: J, center: v, rectangle: L, boundingVolume: e.tile.boundingVolume.boundingVolume, batchTable: B, batchIds: O.polygons, modelMatrix: w }) } if (S > 0) { R.featuresLength = S; let V = y(R.getPropertyArray("POLYLINE_COUNTS", Y.UNSIGNED_INT, 1), R.getPropertyArray("POLYLINE_COUNT", Y.UNSIGNED_INT, 1)); if (!l(V)) throw new fe("Feature table property: POLYLINE_COUNTS must be defined when POLYLINES_LENGTH is greater than 0"); let z = R.getPropertyArray("POLYLINE_WIDTHS", Y.UNSIGNED_SHORT, 1); if (!l(z)) { z = new Uint16Array(S); for (let J = 0; J < S; ++J)z[J] = 2 } let k = V.reduce(function (J, W) { return J + W * 3 }, 0), G = new Uint16Array(t, n, k); n += g; let N = e._tileset, X = N.examineVectorLinesFunction; if (l(X)) { let J = HL(new Uint16Array(G), L, _, E, ie.WGS84); w4e(J, V, O.polylines, B, e.url, X) } let q = E4e; l(N.classificationType) && (q = b4e), e._polylines = q({ positions: G, widths: z, counts: V, batchIds: O.polylines, minimumHeight: _, maximumHeight: E, center: v, rectangle: L, boundingVolume: e.tile.boundingVolume.boundingVolume, batchTable: B, classificationType: N.classificationType, keepDecodedPositions: N.vectorKeepDecodedPositions }) } if (D > 0) { let V = new Uint16Array(t, n, D * 3); n += m, e._points = new FL({ positions: V, batchIds: O.points, minimumHeight: _, maximumHeight: E, rectangle: L, batchTable: B }) } return Promise.resolve(e) } function f5(e) { let t = e.featuresLength; if (!l(e._features) && t > 0) { let n = new Array(t); l(e._polygons) && e._polygons.createFeatures(e, n), l(e._polylines) && e._polylines.createFeatures(e, n), l(e._points) && e._points.createFeatures(e, n), e._features = n } } eh.prototype.hasProperty = function (e, t) { return this._batchTable.hasProperty(e, t) }; eh.prototype.getFeature = function (e) { return l(this._features) || f5(this), this._features[e] }; eh.prototype.applyDebugSettings = function (e, t) { l(this._polygons) && this._polygons.applyDebugSettings(e, t), l(this._polylines) && this._polylines.applyDebugSettings(e, t), l(this._points) && this._points.applyDebugSettings(e, t) }; eh.prototype.applyStyle = function (e) { l(this._features) || f5(this), l(this._polygons) && this._polygons.applyStyle(e, this._features), l(this._polylines) && this._polylines.applyStyle(e, this._features), l(this._points) && this._points.applyStyle(e, this._features) }; eh.prototype.update = function (e, t) { let n = !0; l(this._polygons) && (this._polygons.classificationType = this._tileset.classificationType, this._polygons.debugWireframe = this._tileset.debugWireframe, this._polygons.update(t), n = n && this._polygons._ready), l(this._polylines) && (this._polylines.update(t), n = n && this._polylines._ready), l(this._points) && (this._points.update(t), n = n && this._points._ready), l(this._batchTable) && n && (l(this._features) || f5(this), this._batchTable.update(e, t)) }; eh.prototype.getPolylinePositions = function (e) { let t = this._polylines; if (!!l(t)) return t.getPositions(e) }; eh.prototype.isDestroyed = function () { return !1 }; eh.prototype.destroy = function () { return this._polygons = this._polygons && this._polygons.destroy(), this._polylines = this._polylines && this._polylines.destroy(), this._points = this._points && this._points.destroy(), this._batchTable = this._batchTable && this._batchTable.destroy(), le(this) }; function w4e(e, t, n, i, o, r) { let s = t.length, a = 0; for (let c = 0; c < s; c++) { let u = t[c] * 3, f = e.slice(a, a + u); a += u, r(f, n[c], o, i) } } var GL = eh; var Vne = { b3dm: function (e, t, n, i, o) { return Om.fromB3dm(e, t, n, i, o) }, pnts: function (e, t, n, i, o) { return Om.fromPnts(e, t, n, i, o) }, i3dm: function (e, t, n, i, o) { return Om.fromI3dm(e, t, n, i, o) }, cmpt: function (e, t, n, i, o) { return new IB(e, t, n, i, o, Vne) }, externalTileset: function (e, t, n, i) { return new EL(e, t, n, i) }, geom: function (e, t, n, i, o) { return new UB(e, t, n, i, o) }, vctr: function (e, t, n, i, o) { return new GL(e, t, n, i, o) }, subt: function (e, t, n, i, o) { return new CS(e, t, n, void 0, i, o) }, subtreeJson: function (e, t, n, i) { return new CS(e, t, n, i) }, glb: function (e, t, n, i, o) { if (i.byteLength < 12) throw new fe("Invalid glb content"); let a = new DataView(i, o).getUint32(8, !0), c = new Uint8Array(i, o, a); return Om.fromGltf(e, t, n, c) }, gltf: function (e, t, n, i) { return Om.fromGltf(e, t, n, i) }, geoJson: function (e, t, n, i) { return Om.fromGeoJson(e, t, n, i) } }, Ex = Vne; var D4e = { UNLOADED: 0, LOADING: 1, PROCESSING: 2, READY: 3, EXPIRED: 4, FAILED: 5 }, To = Object.freeze(D4e); var th = { BATCHED_3D_MODEL: "b3dm", INSTANCED_3D_MODEL: "i3dm", COMPOSITE: "cmpt", POINT_CLOUD: "pnts", VECTOR: "vctr", GEOMETRY: "geom", GLTF: "gltf", GLTF_BINARY: "glb", IMPLICIT_SUBTREE: "subt", IMPLICIT_SUBTREE_JSON: "subtreeJson", EXTERNAL_TILESET: "externalTileset", MULTIPLE_CONTENT: "multipleContent", GEOJSON: "geoJson" }; th.isBinaryFormat = function (e) { switch (e) { case th.BATCHED_3D_MODEL: case th.INSTANCED_3D_MODEL: case th.COMPOSITE: case th.POINT_CLOUD: case th.VECTOR: case th.GEOMETRY: case th.IMPLICIT_SUBTREE: case th.GLTF_BINARY: return !0; default: return !1 } }; var ws = Object.freeze(th); var v4e = { NOT_COMPUTED: -1, USE_OPTIMIZATION: 1, SKIP_OPTIMIZATION: 0 }, Pf = Object.freeze(v4e); function kne() { } var $S = { stack: new su, stackMaximumLength: 0 }; kne.selectTiles = function (e, t) { e._selectedTiles.length = 0, e._requestedTiles.length = 0, e._hasMixedContent = !1; let n = !0, i = e.root; if (i.updateVisibility(t), !Une(i)) return n; let o = $S.stack; for (o.push(e.root); o.length > 0;) { $S.stackMaximumLength = Math.max($S.stackMaximumLength, o.length); let r = o.pop(), s = r.refine === vr.ADD, a = r.refine === vr.REPLACE, c = I4e(e, r); c && O4e(e, r, o, t), (s || a && !c) && (B4e(e, r), R4e(e, r, t), L4e(e, r, t), !zne(r) && !r.contentAvailable && (n = !1)), M4e(e) } return $S.stack.trim($S.stackMaximumLength), n }; function Une(e) { return e._visible && e._inRequestVolume } function zne(e) { return e.hasEmptyContent || e.hasTilesetContent || e.hasImplicitContent } function P4e(e) { return !zne(e) && e.contentUnloaded } function I4e(e, t) { return t.children.length === 0 ? !1 : t.hasTilesetContent || t.hasImplicitContent ? !t.contentExpired : (t.hasEmptyContent, !0) } function O4e(e, t, n, i) { let o = t.children, r = o.length; for (let s = 0; s < r; ++s) { let a = o[s]; a.updateVisibility(i), Une(a) && n.push(a) } } function B4e(e, t) { (P4e(t) || t.contentExpired) && (t._priority = 0, e._requestedTiles.push(t)) } function R4e(e, t, n) { t._touchedFrame !== n.frameNumber && (e._cache.touch(t), t._touchedFrame = n.frameNumber) } function M4e(e) { ++e.statistics.visited } function L4e(e, t, n) { t.contentAvailable && t.contentVisibility(n) !== Kt.OUTSIDE && e._selectedTiles.push(t) } var ew = kne; function Hne() { } function iy(e) { return e._visible && e._inRequestVolume } var tw = { stack: new su, stackMaximumLength: 0 }, nw = { stack: new su, stackMaximumLength: 0 }, iw = { stack: new su, stackMaximumLength: 0 }, nh = { stack: new su, stackMaximumLength: 0, ancestorStack: new su, ancestorStackMaximumLength: 0 }, F4e = 2; Hne.selectTiles = function (e, t) { if (e._requestedTiles.length = 0, e.debugFreezeFrame) return; e._selectedTiles.length = 0, e._selectedTilesToStyle.length = 0, e._emptyTiles.length = 0, e._hasMixedContent = !1; let n = e.root; if (qL(e, n, t), !iy(n) || n.getScreenSpaceError(t, !0) <= e._maximumScreenSpaceError) return; rw(e) ? e.immediatelyLoadDesiredLevelOfDetail ? V4e(e, n, t) : k4e(e, n, t) : N4e(e, n, t), tw.stack.trim(tw.stackMaximumLength), nw.stack.trim(nw.stackMaximumLength), iw.stack.trim(iw.stackMaximumLength), nh.stack.trim(nh.stackMaximumLength), nh.ancestorStack.trim(nh.ancestorStackMaximumLength); let i = e._requestedTiles, o = i.length; for (let r = 0; r < o; ++r)i[r].updatePriority() }; function N4e(e, t, n) { let i = e._maximumScreenSpaceError, o = e._maximumScreenSpaceError; h5(e, t, i, o, n) } function V4e(e, t, n) { let i = Number.MAX_VALUE, o = e._maximumScreenSpaceError; h5(e, t, i, o, n), qne(e, t, n) } function k4e(e, t, n) { let i = Math.max(e.baseScreenSpaceError, e.maximumScreenSpaceError), o = e.maximumScreenSpaceError; h5(e, t, i, o, n), qne(e, t, n) } function rw(e) { return e._skipLevelOfDetail } function U4e(e, t) { e._emptyTiles.push(t) } function ow(e, t, n) { if (t.contentVisibility(n) !== Kt.OUTSIDE) { let i = t.content; i.featurePropertiesDirty ? (i.featurePropertiesDirty = !1, t.lastStyleTime = 0, e._selectedTilesToStyle.push(t)) : t._selectedFrame < n.frameNumber - 1 && e._selectedTilesToStyle.push(t), t._selectedFrame = n.frameNumber, e._selectedTiles.push(t) } } function z4e(e, t, n) { let i = iw.stack; for (i.push(t); i.length > 0;) { iw.stackMaximumLength = Math.max(iw.stackMaximumLength, i.length); let r = i.pop().children, s = r.length; for (let a = 0; a < s; ++a) { let c = r[a]; iy(c) && (c.contentAvailable ? (qL(e, c, n), jL(e, c, n), ow(e, c, n)) : c._depth - t._depth < F4e && i.push(c)) } } } function WL(e, t, n) { if (!rw(e)) { t.contentAvailable && ow(e, t, n); return } let i = t.contentAvailable ? t : t._ancestorWithContentAvailable; l(i) ? i._shouldSelect = !0 : z4e(e, t, n) } function H4e(e, t, n) { ++e._statistics.visited, t._visitedFrame = n.frameNumber } function jL(e, t, n) { t._touchedFrame !== n.frameNumber && (e._cache.touch(t), t._touchedFrame = n.frameNumber) } function G4e(e, t) { e._maximumPriority.distance = Math.max(t._priorityHolder._distanceToCamera, e._maximumPriority.distance), e._minimumPriority.distance = Math.min(t._priorityHolder._distanceToCamera, e._minimumPriority.distance), e._maximumPriority.depth = Math.max(t._depth, e._maximumPriority.depth), e._minimumPriority.depth = Math.min(t._depth, e._minimumPriority.depth), e._maximumPriority.foveatedFactor = Math.max(t._priorityHolder._foveatedFactor, e._maximumPriority.foveatedFactor), e._minimumPriority.foveatedFactor = Math.min(t._priorityHolder._foveatedFactor, e._minimumPriority.foveatedFactor), e._maximumPriority.reverseScreenSpaceError = Math.max(t._priorityReverseScreenSpaceError, e._maximumPriority.reverseScreenSpaceError), e._minimumPriority.reverseScreenSpaceError = Math.min(t._priorityReverseScreenSpaceError, e._minimumPriority.reverseScreenSpaceError) } function W4e(e, t, n) { if (!e._cullRequestsWhileMoving) return !0; let i = t.boundingSphere, o = Math.max(i.radius * 2, 1), r = n.camera, s = r.positionWCDeltaMagnitude !== 0 ? r.positionWCDeltaMagnitude : r.positionWCDeltaMagnitudeLastFrame; return e.cullRequestsWhileMovingMultiplier * s / o < 1 } function ny(e, t, n) { if (t._requestedFrame === n.frameNumber || !jne(t) && !t.contentExpired || !W4e(e, t, n)) return; let i = n.camera.timeSinceMoved < e.foveatedTimeDelay; t.priorityDeferred && i || (t._requestedFrame = n.frameNumber, e._requestedTiles.push(t)) } function Gne(e, t, n) { t._updatedVisibilityFrame !== e._updatedVisibilityFrame && (t.updateVisibility(n), t._updatedVisibilityFrame = e._updatedVisibilityFrame) } function j4e(e, t, n) { let i = !1, o = t.children, r = o.length; for (let s = 0; s < r; ++s) { let a = o[s]; Gne(e, a, n), i = i || iy(a) } return i } function q4e(e, t, n) { let i = t.parent; return !l(i) || i.hasTilesetContent || i.hasImplicitContent || i.refine !== vr.ADD ? !1 : t.getScreenSpaceError(n, !0) <= e._maximumScreenSpaceError } function Wne(e, t, n) { if (Gne(e, t, n), !iy(t)) return; let i = t.children.length > 0; if ((t.hasTilesetContent || t.hasImplicitContent) && i) { let s = t.children[0]; Wne(e, s, n), t._visible = s._visible; return } if (q4e(e, t, n)) { t._visible = !1; return } let o = t.refine === vr.REPLACE, r = t._optimChildrenWithinParent === Pf.USE_OPTIMIZATION; if (o && r && i && !j4e(e, t, n)) { ++e._statistics.numberOfTilesCulledWithChildrenUnion, t._visible = !1; return } } function qL(e, t, n) { Wne(e, t, n), t.updateExpiration(), t._wasMinPriorityChild = !1, t._priorityHolder = t, G4e(e, t), t._shouldSelect = !1, t._finalResolution = !0 } function Y4e(e, t) { e._ancestorWithContent = void 0, e._ancestorWithContentAvailable = void 0; let n = e.parent; if (l(n)) { let i = !jne(n) || n._requestedFrame === t.frameNumber; e._ancestorWithContent = i ? n : n._ancestorWithContent, e._ancestorWithContentAvailable = n.contentAvailable ? n : n._ancestorWithContentAvailable } } function sw(e) { return e.hasEmptyContent || e.hasTilesetContent || e.hasImplicitContent } function jne(e) { return !sw(e) && e.contentUnloaded } function X4e(e, t) { let n = t._ancestorWithContent; return !e.immediatelyLoadDesiredLevelOfDetail && (t._priorityProgressiveResolutionScreenSpaceErrorLeaf || l(n) && t._screenSpaceError < n._screenSpaceError / e.skipScreenSpaceErrorFactor && t._depth > n._depth + e.skipLevels) } function K4e(e, t) { return t._distanceToCamera === 0 && e._distanceToCamera === 0 ? t._centerZDepth - e._centerZDepth : t._distanceToCamera - e._distanceToCamera } function J4e(e, t, n, i) { let o, r = t.refine === vr.REPLACE, s = t.children, a = s.length; for (o = 0; o < a; ++o)qL(e, s[o], i); s.sort(K4e); let c = !rw(e) && r && !sw(t), u = !0, f = !1, d = -1, p = Number.MAX_VALUE, g; for (o = 0; o < a; ++o)if (g = s[o], iy(g) ? (n.push(g), g._foveatedFactor < p && (d = o, p = g._foveatedFactor), f = !0) : (c || e.loadSiblings) && (g._foveatedFactor < p && (d = o, p = g._foveatedFactor), ny(e, g, i), jL(e, g, i)), c) { let m; g._inRequestVolume ? sw(g) ? m = Q4e(e, g, i) : m = g.contentAvailable : m = !1, u = u && m } if (f || (u = !1), d !== -1 && !rw(e) && r) { let m = s[d]; m._wasMinPriorityChild = !0; let A = (t._wasMinPriorityChild || t === e.root) && p <= t._priorityHolder._foveatedFactor ? t._priorityHolder : t; for (A._foveatedFactor = Math.min(m._foveatedFactor, A._foveatedFactor), A._distanceToCamera = Math.min(m._distanceToCamera, A._distanceToCamera), o = 0; o < a; ++o)g = s[o], g._priorityHolder = A } return u } function Z4e(e, t, n) { return rw(e) ? e.immediatelyLoadDesiredLevelOfDetail ? !1 : l(t._ancestorWithContent) ? t._screenSpaceError === 0 ? t.parent._screenSpaceError > n : t._screenSpaceError > n : !0 : !0 } function d5(e, t) { return t.children.length === 0 ? !1 : t.hasTilesetContent || t.hasImplicitContent ? !t.contentExpired : t._screenSpaceError > e._maximumScreenSpaceError } function h5(e, t, n, i, o) { let r = tw.stack; for (r.push(t); r.length > 0;) { tw.stackMaximumLength = Math.max(tw.stackMaximumLength, r.length); let s = r.pop(); Y4e(s, o); let a = Z4e(e, s, n), c = s.refine === vr.ADD, u = s.refine === vr.REPLACE, f = s.parent, d = !l(f) || f._refines, p = !1; d5(e, s) && (p = J4e(e, s, r, o) && d); let g = !p && d; sw(s) ? (U4e(e, s, o), ny(e, s, o), g && WL(e, s, o)) : c ? (WL(e, s, o), ny(e, s, o)) : u && (a ? (ny(e, s, o), g && WL(e, s, o)) : g ? (WL(e, s, o), ny(e, s, o)) : X4e(e, s) && ny(e, s, o)), H4e(e, s, o), jL(e, s, o), s._refines = p } } function Q4e(e, t, n) { let i = !0, o = nw.stack; for (o.push(t); o.length > 0;) { nw.stackMaximumLength = Math.max(nw.stackMaximumLength, o.length); let r = o.pop(), s = r.children, a = s.length, c = sw(r), u = c && d5(e, r), f = c && r.children.length === 0; if (!u && !r.contentAvailable && !f && (i = !1), qL(e, r, n), iy(r) || (ny(e, r, n), jL(e, r, n)), u) for (let d = 0; d < a; ++d) { let p = s[d]; o.push(p) } } return i } function qne(e, t, n) { let i = nh.stack, o = nh.ancestorStack, r; for (i.push(t); i.length > 0 || o.length > 0;) { if (nh.stackMaximumLength = Math.max(nh.stackMaximumLength, i.length), nh.ancestorStackMaximumLength = Math.max(nh.ancestorStackMaximumLength, o.length), o.length > 0) { let p = o.peek(); if (p._stackLength === i.length) { o.pop(), p !== r && (p._finalResolution = !1), ow(e, p, n); continue } } let s = i.pop(); if (!l(s)) continue; let a = s.refine === vr.ADD, c = s._shouldSelect, u = s.children, f = u.length, d = d5(e, s); if (c) if (a) ow(e, s, n); else { if (s._selectionDepth = o.length, s._selectionDepth > 0 && (e._hasMixedContent = !0), r = s, !d) { ow(e, s, n); continue } o.push(s), s._stackLength = i.length } if (d) for (let p = 0; p < f; ++p) { let g = u[p]; iy(g) && i.push(g) } } } var km = Hne; var If = { RENDER: 0, PICK: 1, SHADOW: 2, PRELOAD: 3, PRELOAD_FLIGHT: 4, REQUEST_RENDER_MODE_DEFER_CHECK: 5, MOST_DETAILED_PRELOAD: 6, MOST_DETAILED_PICK: 7, NUMBER_OF_PASSES: 8 }, Um = new Array(If.NUMBER_OF_PASSES); Um[If.RENDER] = Object.freeze({ traversal: km, isRender: !0, requestTiles: !0, ignoreCommands: !1 }); Um[If.PICK] = Object.freeze({ traversal: km, isRender: !1, requestTiles: !1, ignoreCommands: !1 }); Um[If.SHADOW] = Object.freeze({ traversal: km, isRender: !1, requestTiles: !0, ignoreCommands: !1 }); Um[If.PRELOAD] = Object.freeze({ traversal: km, isRender: !1, requestTiles: !0, ignoreCommands: !0 }); Um[If.PRELOAD_FLIGHT] = Object.freeze({ traversal: km, isRender: !1, requestTiles: !0, ignoreCommands: !0 }); Um[If.REQUEST_RENDER_MODE_DEFER_CHECK] = Object.freeze({ traversal: km, isRender: !1, requestTiles: !0, ignoreCommands: !0 }); Um[If.MOST_DETAILED_PRELOAD] = Object.freeze({ traversal: ew, isRender: !1, requestTiles: !0, ignoreCommands: !0 }); Um[If.MOST_DETAILED_PICK] = Object.freeze({ traversal: ew, isRender: !1, requestTiles: !1, ignoreCommands: !1 }); If.getPassOptions = function (e) { return Um[e] }; var Qo = Object.freeze(If); function zm(e, t) { this._tileset = e, this._tile = t, this.featurePropertiesDirty = !1 } Object.defineProperties(zm.prototype, { featuresLength: { get: function () { return 0 } }, pointsLength: { get: function () { return 0 } }, trianglesLength: { get: function () { return 0 } }, geometryByteLength: { get: function () { return 0 } }, texturesByteLength: { get: function () { return 0 } }, batchTableByteLength: { get: function () { return 0 } }, innerContents: { get: function () { } }, readyPromise: { get: function () { } }, tileset: { get: function () { return this._tileset } }, tile: { get: function () { return this._tile } }, url: { get: function () { } }, metadata: { get: function () { }, set: function (e) { } }, batchTable: { get: function () { } }, group: { get: function () { }, set: function (e) { } } }); zm.prototype.hasProperty = function (e, t) { return !1 }; zm.prototype.getFeature = function (e) { }; zm.prototype.applyDebugSettings = function (e, t) { }; zm.prototype.applyStyle = function (e) { }; zm.prototype.update = function (e, t) { }; zm.prototype.isDestroyed = function () { return !1 }; zm.prototype.destroy = function () { return le(this) }; var aw = zm; function Hm(e) { e = y(e, y.EMPTY_OBJECT); let t = e.content, n = e.class; this._class = n, this._properties = t.properties, this._extensions = t.extensions, this._extras = t.extras } Object.defineProperties(Hm.prototype, { class: { get: function () { return this._class } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); Hm.prototype.hasProperty = function (e) { return Rn.hasProperty(e, this._properties, this._class) }; Hm.prototype.hasPropertyBySemantic = function (e) { return Rn.hasPropertyBySemantic(e, this._properties, this._class) }; Hm.prototype.getPropertyIds = function (e) { return Rn.getPropertyIds(this._properties, this._class, e) }; Hm.prototype.getProperty = function (e) { return Rn.getProperty(e, this._properties, this._class) }; Hm.prototype.setProperty = function (e, t) { return Rn.setProperty(e, t, this._properties, this._class) }; Hm.prototype.getPropertyBySemantic = function (e) { return Rn.getPropertyBySemantic(e, this._properties, this._class) }; Hm.prototype.setPropertyBySemantic = function (e, t) { return Rn.setPropertyBySemantic(e, t, this._properties, this._class) }; var YL = Hm; function m5(e, t) { let n = Mi(t, "3DTILES_metadata") ? t.extensions["3DTILES_metadata"] : t.metadata; if (!l(n)) return; if (!l(e.schema)) { m5._oneTimeWarning("findContentMetadata-missing-root-schema", "Could not find a metadata schema for content metadata. For tilesets that contain external tilesets, make sure the schema is added to the root tileset.json."); return } let i = y(e.schema.classes, y.EMPTY_OBJECT); if (l(n.class)) { let o = i[n.class]; return new YL({ content: n, class: o }) } } m5._oneTimeWarning = Pt; var bx = m5; function $4e(e, t) { let n = e.metadataExtension; if (!l(n)) return; let i = n.groups, o = Mi(t, "3DTILES_metadata") ? t.extensions["3DTILES_metadata"].group : t.group; if (typeof o == "number") return i[o]; let r = n.groupIds.findIndex(function (s) { return s === o }); return r >= 0 ? i[r] : void 0 } var Sx = $4e; function Gm(e) { e = y(e, y.EMPTY_OBJECT); let t = e.tile, n = e.class; this._class = n, this._properties = t.properties, this._extensions = t.extensions, this._extras = t.extras } Object.defineProperties(Gm.prototype, { class: { get: function () { return this._class } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); Gm.prototype.hasProperty = function (e) { return Rn.hasProperty(e, this._properties, this._class) }; Gm.prototype.hasPropertyBySemantic = function (e) { return Rn.hasPropertyBySemantic(e, this._properties, this._class) }; Gm.prototype.getPropertyIds = function (e) { return Rn.getPropertyIds(this._properties, this._class, e) }; Gm.prototype.getProperty = function (e) { return Rn.getProperty(e, this._properties, this._class) }; Gm.prototype.setProperty = function (e, t) { return Rn.setProperty(e, t, this._properties, this._class) }; Gm.prototype.getPropertyBySemantic = function (e) { return Rn.getPropertyBySemantic(e, this._properties, this._class) }; Gm.prototype.setPropertyBySemantic = function (e, t) { return Rn.setPropertyBySemantic(e, t, this._properties, this._class) }; var XL = Gm; function p5(e, t) { let n = Mi(t, "3DTILES_metadata") ? t.extensions["3DTILES_metadata"] : t.metadata; if (!l(n)) return; if (!l(e.schema)) { p5._oneTimeWarning("findTileMetadata-missing-root-schema", "Could not find a metadata schema for tile metadata. For tilesets that contain external tilesets, make sure the schema is added to the root tileset.json."); return } let i = y(e.schema.classes, y.EMPTY_OBJECT); if (l(n.class)) { let o = i[n.class]; return new XL({ tile: n, class: o }) } } p5._oneTimeWarning = Pt; var KL = p5; function eze(e) { let t = new Uint8Array(e), n = zd(t); if (n === "glTF" && (n = "glb"), ws.isBinaryFormat(n)) return { contentType: n, binaryPayload: t }; let i = tze(t); if (l(i.root)) return { contentType: ws.EXTERNAL_TILESET, jsonPayload: i }; if (l(i.asset)) return { contentType: ws.GLTF, jsonPayload: i }; if (l(i.tileAvailability)) return { contentType: ws.IMPLICIT_SUBTREE_JSON, jsonPayload: i }; if (l(i.type)) return { contentType: ws.GEOJSON, jsonPayload: i }; throw new fe("Invalid tile content.") } function tze(e) { let t; try { t = Ko(e) } catch { throw new fe("Invalid tile content.") } return t } var wx = eze; function Of(e, t, n, i) { this._tileset = e, this._tile = t, this._tilesetResource = n, this._contents = [], this._contentsCreated = !1; let o = l(i.contents) ? i.contents : i.content; this._innerContentHeaders = o, this._requestsInFlight = 0, this._cancelCount = 0; let r = this._innerContentHeaders.length; this._arrayFetchPromises = new Array(r), this._requests = new Array(r), this._innerContentResources = new Array(r), this._serverKeys = new Array(r); for (let s = 0; s < r; s++) { let a = n.getDerivedResource({ url: o[s].uri }), c = Ya.getServerKey(a.getUrlComponent()); this._innerContentResources[s] = a, this._serverKeys[s] = c } this._contentsFetchedPromise = void 0 } Object.defineProperties(Of.prototype, { featurePropertiesDirty: { get: function () { let e = this._contents, t = e.length; for (let n = 0; n < t; ++n)if (e[n].featurePropertiesDirty) return !0; return !1 }, set: function (e) { let t = this._contents, n = t.length; for (let i = 0; i < n; ++i)t[i].featurePropertiesDirty = e } }, featuresLength: { get: function () { return 0 } }, pointsLength: { get: function () { return 0 } }, trianglesLength: { get: function () { return 0 } }, geometryByteLength: { get: function () { return 0 } }, texturesByteLength: { get: function () { return 0 } }, batchTableByteLength: { get: function () { return 0 } }, innerContents: { get: function () { return this._contents } }, readyPromise: { get: function () { if (!this._contentsCreated) return; let e = this._contents.map(function (n) { return n.readyPromise }), t = this; return Promise.all(e).then(function () { return t }) } }, tileset: { get: function () { return this._tileset } }, tile: { get: function () { return this._tile } }, url: { get: function () { } }, metadata: { get: function () { }, set: function () { } }, batchTable: { get: function () { } }, group: { get: function () { }, set: function () { } }, innerContentUrls: { get: function () { return this._innerContentHeaders.map(function (e) { return e.uri }) } }, contentsFetchedPromise: { get: function () { return this._contentsFetchedPromise } } }); function _5(e, t) { e._requestsInFlight += t, e.tileset.statistics.numberOfPendingRequests += t } function nze(e, t) { e._cancelCount++, e._tile._contentState = t; let n = e.tileset.statistics; n.numberOfPendingRequests -= e._requestsInFlight, n.numberOfAttemptedRequests += e._requestsInFlight, e._requestsInFlight = 0; let i = e._innerContentHeaders.length; e._arrayFetchPromises = new Array(i) } Of.prototype.requestInnerContents = function () { if (!ize(this._serverKeys)) return this._serverKeys.length; let e = this._innerContentHeaders; _5(this, e.length); for (let t = 0; t < e.length; t++)this._arrayFetchPromises[t] = oze(this, t, this._cancelCount, this._tile._contentState); return this._contentsFetchedPromise = rze(this), 0 }; function ize(e) { let t = {}; for (let n = 0; n < e.length; n++) { let i = e[n]; l(t[i]) ? t[i]++ : t[i] = 1 } for (let n in t) if (t.hasOwnProperty(n) && !Ya.serverHasOpenSlots(n, t[n])) return !1; return Ya.heapHasOpenSlots(e.length) } function oze(e, t, n, i) { let o = e._innerContentResources[t].clone(), r = e.tile, s = function () { return r._priority }, a = e._serverKeys[t], c = new jo({ throttle: !0, throttleByServer: !0, type: Xr.TILES3D, priorityFunction: s, serverKey: a }); o.request = c, e._requests[t] = c; let u = o.fetchArrayBuffer(); return l(u) ? u.then(function (f) { if (!(n < e._cancelCount)) return _5(e, -1), f }).catch(function (f) { if (!(n < e._cancelCount)) { if (o.request.state === ri.CANCELLED) { nze(e, i); return } _5(e, -1), Yne(e, t, f) } }) : Promise.resolve(void 0) } function rze(e) { let t = e._cancelCount; return Promise.all(e._arrayFetchPromises).then(function (n) { if (t < e._cancelCount) return; let i = n.map(function (o, r) { if (!!l(o)) return sze(e, o, r) }); e._contentsCreated = !0, e._contents = i.filter(l) }) } function sze(e, t, n) { let i = wx(t); if (i.contentType === ws.EXTERNAL_TILESET) { let d = new fe("External tilesets are disallowed inside multiple contents"); return Yne(e, n, d) } e._disableSkipLevelOfDetail = e._disableSkipLevelOfDetail || i.contentType === ws.GEOMETRY || i.contentType === ws.VECTOR; let o = e._tileset, r = e._innerContentResources[n], s = e._tile, a, c = Ex[i.contentType]; l(i.binaryPayload) ? a = c(o, s, r, i.binaryPayload.buffer, 0) : a = c(o, s, r, i.jsonPayload); let u = e._innerContentHeaders[n]; if (s.hasImplicitContentMetadata) { let d = s.implicitSubtree, p = s.implicitCoordinates; a.metadata = d.getContentMetadataView(p, n) } else s.hasImplicitContent || (a.metadata = bx(o, u)); let f = Sx(o, u); return l(f) && (a.group = new kC({ metadata: f })), a } function Yne(e, t, n) { let i = e._tileset, o = e._innerContentResources[t].url, r = l(n.message) ? n.message : n.toString(); i.tileFailed.numberOfListeners > 0 ? i.tileFailed.raiseEvent({ url: o, message: r }) : (console.log(`A content failed to load: ${o}`), console.log(`Error: ${r}`)) } Of.prototype.cancelRequests = function () { for (let e = 0; e < this._requests.length; e++) { let t = this._requests[e]; l(t) && t.cancel() } }; Of.prototype.hasProperty = function (e, t) { return !1 }; Of.prototype.getFeature = function (e) { }; Of.prototype.applyDebugSettings = function (e, t) { let n = this._contents, i = n.length; for (let o = 0; o < i; ++o)n[o].applyDebugSettings(e, t) }; Of.prototype.applyStyle = function (e) { let t = this._contents, n = t.length; for (let i = 0; i < n; ++i)t[i].applyStyle(e) }; Of.prototype.update = function (e, t) { let n = this._contents, i = n.length; for (let o = 0; o < i; ++o)n[o].update(e, t) }; Of.prototype.isDestroyed = function () { return !1 }; Of.prototype.destroy = function () { let e = this._contents, t = e.length; for (let n = 0; n < t; ++n)e[n].destroy(); return le(this) }; var JL = Of; var nie = po(Qne(), 1); var Tze = new h, Eze = new h, I_ = {}; I_.computeArea2D = function (e) { let t = e.length, n = 0; for (let i = t - 1, o = 0; o < t; i = o++) { let r = e[i], s = e[o]; n += r.x * s.y - s.x * r.y } return n * .5 }; I_.computeWindingOrder2D = function (e) { return I_.computeArea2D(e) > 0 ? Kr.COUNTER_CLOCKWISE : Kr.CLOCKWISE }; I_.triangulate = function (e, t) { let n = H.packArray(e); return (0, nie.default)(n, t, 2) }; var iie = new h, oie = new h, rie = new h, $ne = new h, eie = new h, tie = new h, Wm = new h, sie = new H, aie = new H, cie = new H, vx = new H; I_.computeSubdivision = function (e, t, n, i, o) { o = y(o, I.RADIANS_PER_DEGREE); let r = l(i), s = n.slice(0), a, c = t.length, u = new Array(c * 3), f = new Array(c * 2), d = 0, p = 0; for (a = 0; a < c; a++) { let b = t[a]; if (u[d++] = b.x, u[d++] = b.y, u[d++] = b.z, r) { let S = i[a]; f[p++] = S.x, f[p++] = S.y } } let g = [], m = {}, A = e.maximumRadius, C = I.chordLength(o, A), x = C * C; for (; s.length > 0;) { let b = s.pop(), S = s.pop(), D = s.pop(), P = h.fromArray(u, D * 3, iie), B = h.fromArray(u, S * 3, oie), R = h.fromArray(u, b * 3, rie), M, L, _; r && (M = H.fromArray(f, D * 2, sie), L = H.fromArray(f, S * 2, aie), _ = H.fromArray(f, b * 2, cie)); let E = h.multiplyByScalar(h.normalize(P, $ne), A, $ne), w = h.multiplyByScalar(h.normalize(B, eie), A, eie), v = h.multiplyByScalar(h.normalize(R, tie), A, tie), O = h.magnitudeSquared(h.subtract(E, w, Wm)), V = h.magnitudeSquared(h.subtract(w, v, Wm)), z = h.magnitudeSquared(h.subtract(v, E, Wm)), k = Math.max(O, V, z), G, N, X; k > x ? O === k ? (G = `${Math.min(D, S)} ${Math.max(D, S)}`, a = m[G], l(a) || (N = h.add(P, B, Wm), h.multiplyByScalar(N, .5, N), u.push(N.x, N.y, N.z), a = u.length / 3 - 1, m[G] = a, r && (X = H.add(M, L, vx), H.multiplyByScalar(X, .5, X), f.push(X.x, X.y))), s.push(D, a, b), s.push(a, S, b)) : V === k ? (G = `${Math.min(S, b)} ${Math.max(S, b)}`, a = m[G], l(a) || (N = h.add(B, R, Wm), h.multiplyByScalar(N, .5, N), u.push(N.x, N.y, N.z), a = u.length / 3 - 1, m[G] = a, r && (X = H.add(L, _, vx), H.multiplyByScalar(X, .5, X), f.push(X.x, X.y))), s.push(S, a, D), s.push(a, b, D)) : z === k && (G = `${Math.min(b, D)} ${Math.max(b, D)}`, a = m[G], l(a) || (N = h.add(R, P, Wm), h.multiplyByScalar(N, .5, N), u.push(N.x, N.y, N.z), a = u.length / 3 - 1, m[G] = a, r && (X = H.add(_, M, vx), H.multiplyByScalar(X, .5, X), f.push(X.x, X.y))), s.push(b, a, S), s.push(a, D, S)) : (g.push(D), g.push(S), g.push(b)) } let T = { attributes: { position: new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: u }) }, indices: g, primitiveType: Oe.TRIANGLES }; return r && (T.attributes.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: f })), new st(T) }; var bze = new he, Sze = new he, wze = new he, x5 = new he; I_.computeRhumbLineSubdivision = function (e, t, n, i, o) { o = y(o, I.RADIANS_PER_DEGREE); let r = l(i), s = n.slice(0), a, c = t.length, u = new Array(c * 3), f = new Array(c * 2), d = 0, p = 0; for (a = 0; a < c; a++) { let D = t[a]; if (u[d++] = D.x, u[d++] = D.y, u[d++] = D.z, r) { let P = i[a]; f[p++] = P.x, f[p++] = P.y } } let g = [], m = {}, A = e.maximumRadius, C = I.chordLength(o, A), x = new ga(void 0, void 0, e), T = new ga(void 0, void 0, e), b = new ga(void 0, void 0, e); for (; s.length > 0;) { let D = s.pop(), P = s.pop(), B = s.pop(), R = h.fromArray(u, B * 3, iie), M = h.fromArray(u, P * 3, oie), L = h.fromArray(u, D * 3, rie), _, E, w; r && (_ = H.fromArray(f, B * 2, sie), E = H.fromArray(f, P * 2, aie), w = H.fromArray(f, D * 2, cie)); let v = e.cartesianToCartographic(R, bze), O = e.cartesianToCartographic(M, Sze), V = e.cartesianToCartographic(L, wze); x.setEndPoints(v, O); let z = x.surfaceDistance; T.setEndPoints(O, V); let k = T.surfaceDistance; b.setEndPoints(V, v); let G = b.surfaceDistance, N = Math.max(z, k, G), X, q, J, W, K; N > C ? z === N ? (X = `${Math.min(B, P)} ${Math.max(B, P)}`, a = m[X], l(a) || (q = x.interpolateUsingFraction(.5, x5), J = (v.height + O.height) * .5, W = h.fromRadians(q.longitude, q.latitude, J, e, Wm), u.push(W.x, W.y, W.z), a = u.length / 3 - 1, m[X] = a, r && (K = H.add(_, E, vx), H.multiplyByScalar(K, .5, K), f.push(K.x, K.y))), s.push(B, a, D), s.push(a, P, D)) : k === N ? (X = `${Math.min(P, D)} ${Math.max(P, D)}`, a = m[X], l(a) || (q = T.interpolateUsingFraction(.5, x5), J = (O.height + V.height) * .5, W = h.fromRadians(q.longitude, q.latitude, J, e, Wm), u.push(W.x, W.y, W.z), a = u.length / 3 - 1, m[X] = a, r && (K = H.add(E, w, vx), H.multiplyByScalar(K, .5, K), f.push(K.x, K.y))), s.push(P, a, B), s.push(a, D, B)) : G === N && (X = `${Math.min(D, B)} ${Math.max(D, B)}`, a = m[X], l(a) || (q = b.interpolateUsingFraction(.5, x5), J = (V.height + v.height) * .5, W = h.fromRadians(q.longitude, q.latitude, J, e, Wm), u.push(W.x, W.y, W.z), a = u.length / 3 - 1, m[X] = a, r && (K = H.add(w, _, vx), H.multiplyByScalar(K, .5, K), f.push(K.x, K.y))), s.push(D, a, P), s.push(a, B, P)) : (g.push(B), g.push(P), g.push(D)) } let S = { attributes: { position: new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: u }) }, indices: g, primitiveType: Oe.TRIANGLES }; return r && (S.attributes.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: f })), new st(S) }; I_.scaleToGeodeticHeight = function (e, t, n, i) { n = y(n, ie.WGS84); let o = Tze, r = Eze; if (t = y(t, 0), i = y(i, !0), l(e)) { let s = e.length; for (let a = 0; a < s; a += 3)h.fromArray(e, a, r), i && (r = n.scaleToGeodeticSurface(r, r)), t !== 0 && (o = n.geodeticSurfaceNormal(r, o), h.multiplyByScalar(o, t, o), h.add(r, o, r)), e[a] = r.x, e[a + 1] = r.y, e[a + 2] = r.z } return e }; var ni = I_; var lie = Math.cos, uie = Math.sin, Dze = Math.sqrt, E5 = {}; E5.computePosition = function (e, t, n, i, o, r, s) { let a = t.radiiSquared, c = e.nwCorner, u = e.boundingRectangle, f = c.latitude - e.granYCos * i + o * e.granXSin, d = lie(f), p = uie(f), g = a.z * p, m = c.longitude + i * e.granYSin + o * e.granXCos, A = d * lie(m), C = d * uie(m), x = a.x * A, T = a.y * C, b = Dze(x * A + T * C + g * p); if (r.x = x / b, r.y = T / b, r.z = g / b, n) { let S = e.stNwCorner; l(S) ? (f = S.latitude - e.stGranYCos * i + o * e.stGranXSin, m = S.longitude + i * e.stGranYSin + o * e.stGranXCos, s.x = (m - e.stWest) * e.lonScalar, s.y = (f - e.stSouth) * e.latScalar) : (s.x = (m - u.west) * e.lonScalar, s.y = (f - u.south) * e.latScalar) } }; var vze = new qi, Tu = new h, Pze = new he, tF = new h, T5 = new _i; function fie(e, t, n, i, o, r, s) { let a = Math.cos(t), c = i * a, u = n * a, f = Math.sin(t), d = i * f, p = n * f; Tu = T5.project(e, Tu), Tu = h.subtract(Tu, tF, Tu); let g = qi.fromRotation(t, vze); Tu = qi.multiplyByVector(g, Tu, Tu), Tu = h.add(Tu, tF, Tu), e = T5.unproject(Tu, e), r -= 1, s -= 1; let m = e.latitude, A = m + r * p, C = m - c * s, x = m - c * s + r * p, T = Math.max(m, A, C, x), b = Math.min(m, A, C, x), S = e.longitude, D = S + r * u, P = S + s * d, B = S + s * d + r * u, R = Math.max(S, D, P, B), M = Math.min(S, D, P, B); return { north: T, south: b, east: R, west: M, granYCos: c, granYSin: d, granXCos: u, granXSin: p, nwCorner: e } } E5.computeOptions = function (e, t, n, i, o, r, s) { let a = e.east, c = e.west, u = e.north, f = e.south, d = !1, p = !1; u === I.PI_OVER_TWO && (d = !0), f === -I.PI_OVER_TWO && (p = !0); let g, m = u - f; c > a ? g = I.TWO_PI - c + a : g = a - c; let A = Math.ceil(g / t) + 1, C = Math.ceil(m / t) + 1, x = g / (A - 1), T = m / (C - 1), b = ce.northwest(e, r), S = ce.center(e, Pze); (n !== 0 || i !== 0) && (S.longitude < b.longitude && (S.longitude += I.TWO_PI), tF = T5.project(S, tF)); let D = T, P = x, B = 0, R = 0, M = ce.clone(e, o), L = { granYCos: D, granYSin: B, granXCos: P, granXSin: R, nwCorner: b, boundingRectangle: M, width: A, height: C, northCap: d, southCap: p }; if (n !== 0) { let _ = fie(b, n, x, T, S, A, C); u = _.north, f = _.south, a = _.east, c = _.west, L.granYCos = _.granYCos, L.granYSin = _.granYSin, L.granXCos = _.granXCos, L.granXSin = _.granXSin, M.north = u, M.south = f, M.east = a, M.west = c } if (i !== 0) { n = n - i; let _ = ce.northwest(M, s), E = fie(_, n, x, T, S, A, C); L.stGranYCos = E.granYCos, L.stGranXCos = E.granXCos, L.stGranYSin = E.granYSin, L.stGranXSin = E.granXSin, L.stNwCorner = _, L.stWest = E.west, L.stSouth = E.south } return L }; var ms = E5; var Ize = new re, Oze = new re, Bze = new h, Rze = new ce; function die(e, t) { let n = e._ellipsoid, i = t.height, o = t.width, r = t.northCap, s = t.southCap, a = i, c = 2, u = 0, f = 4; r && (c -= 1, a -= 1, u += 1, f -= 2), s && (c -= 1, a -= 1, u += 1, f -= 2), u += c * o + 2 * a - f; let d = new Float64Array(u * 3), p = 0, g = 0, m, A = Bze; if (r) ms.computePosition(t, n, !1, g, 0, A), d[p++] = A.x, d[p++] = A.y, d[p++] = A.z; else for (m = 0; m < o; m++)ms.computePosition(t, n, !1, g, m, A), d[p++] = A.x, d[p++] = A.y, d[p++] = A.z; for (m = o - 1, g = 1; g < i; g++)ms.computePosition(t, n, !1, g, m, A), d[p++] = A.x, d[p++] = A.y, d[p++] = A.z; if (g = i - 1, !s) for (m = o - 2; m >= 0; m--)ms.computePosition(t, n, !1, g, m, A), d[p++] = A.x, d[p++] = A.y, d[p++] = A.z; for (m = 0, g = i - 2; g > 0; g--)ms.computePosition(t, n, !1, g, m, A), d[p++] = A.x, d[p++] = A.y, d[p++] = A.z; let C = d.length / 3 * 2, x = Me.createTypedArray(d.length / 3, C), T = 0; for (let S = 0; S < d.length / 3 - 1; S++)x[T++] = S, x[T++] = S + 1; x[T++] = d.length / 3 - 1, x[T++] = 0; let b = new st({ attributes: new sn, primitiveType: Oe.LINES }); return b.attributes.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: d }), b.indices = x, b } function Mze(e, t) { let n = e._surfaceHeight, i = e._extrudedHeight, o = e._ellipsoid, r = i, s = n, a = die(e, t), c = t.height, u = t.width, f = ni.scaleToGeodeticHeight(a.attributes.position.values, s, o, !1), d = f.length, p = new Float64Array(d * 2); p.set(f); let g = ni.scaleToGeodeticHeight(a.attributes.position.values, r, o); p.set(g, d), a.attributes.position.values = p; let m = t.northCap, A = t.southCap, C = 4; m && (C -= 1), A && (C -= 1); let x = (p.length / 3 + C) * 2, T = Me.createTypedArray(p.length / 3, x); d = p.length / 6; let b = 0; for (let D = 0; D < d - 1; D++)T[b++] = D, T[b++] = D + 1, T[b++] = D + d, T[b++] = D + d + 1; T[b++] = d - 1, T[b++] = 0, T[b++] = d + d - 1, T[b++] = d, T[b++] = 0, T[b++] = d; let S; if (m) S = c - 1; else { let D = u - 1; T[b++] = D, T[b++] = D + d, S = u + c - 2 } if (T[b++] = S, T[b++] = S + d, !A) { let D = u + S - 1; T[b++] = D, T[b] = D + d } return a.indices = T, a } function Ix(e) { e = y(e, y.EMPTY_OBJECT); let t = e.rectangle, n = y(e.granularity, I.RADIANS_PER_DEGREE), i = y(e.ellipsoid, ie.WGS84), o = y(e.rotation, 0), r = y(e.height, 0), s = y(e.extrudedHeight, r); this._rectangle = ce.clone(t), this._granularity = n, this._ellipsoid = i, this._surfaceHeight = Math.max(r, s), this._rotation = o, this._extrudedHeight = Math.min(r, s), this._offsetAttribute = e.offsetAttribute, this._workerName = "createRectangleOutlineGeometry" } Ix.packedLength = ce.packedLength + ie.packedLength + 5; Ix.pack = function (e, t, n) { return n = y(n, 0), ce.pack(e._rectangle, t, n), n += ce.packedLength, ie.pack(e._ellipsoid, t, n), n += ie.packedLength, t[n++] = e._granularity, t[n++] = e._surfaceHeight, t[n++] = e._rotation, t[n++] = e._extrudedHeight, t[n] = y(e._offsetAttribute, -1), t }; var hie = new ce, mie = ie.clone(ie.UNIT_SPHERE), Px = { rectangle: hie, ellipsoid: mie, granularity: void 0, height: void 0, rotation: void 0, extrudedHeight: void 0, offsetAttribute: void 0 }; Ix.unpack = function (e, t, n) { t = y(t, 0); let i = ce.unpack(e, t, hie); t += ce.packedLength; let o = ie.unpack(e, t, mie); t += ie.packedLength; let r = e[t++], s = e[t++], a = e[t++], c = e[t++], u = e[t]; return l(n) ? (n._rectangle = ce.clone(i, n._rectangle), n._ellipsoid = ie.clone(o, n._ellipsoid), n._surfaceHeight = s, n._rotation = a, n._extrudedHeight = c, n._offsetAttribute = u === -1 ? void 0 : u, n) : (Px.granularity = r, Px.height = s, Px.rotation = a, Px.extrudedHeight = c, Px.offsetAttribute = u === -1 ? void 0 : u, new Ix(Px)) }; var Lze = new he; Ix.createGeometry = function (e) { let t = e._rectangle, n = e._ellipsoid, i = ms.computeOptions(t, e._granularity, e._rotation, 0, Rze, Lze), o, r; if (I.equalsEpsilon(t.north, t.south, I.EPSILON10) || I.equalsEpsilon(t.east, t.west, I.EPSILON10)) return; let s = e._surfaceHeight, a = e._extrudedHeight, c = !I.equalsEpsilon(s, a, 0, I.EPSILON2), u; if (c) { if (o = Mze(e, i), l(e._offsetAttribute)) { let p = o.attributes.position.values.length / 3, g = new Uint8Array(p); e._offsetAttribute === Qt.TOP ? g = g.fill(1, 0, p / 2) : (u = e._offsetAttribute === Qt.NONE ? 0 : 1, g = g.fill(u)), o.attributes.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: g }) } let f = re.fromRectangle3D(t, n, s, Oze), d = re.fromRectangle3D(t, n, a, Ize); r = re.union(f, d) } else { if (o = die(e, i), o.attributes.position.values = ni.scaleToGeodeticHeight(o.attributes.position.values, s, n, !1), l(e._offsetAttribute)) { let f = o.attributes.position.values.length; u = e._offsetAttribute === Qt.NONE ? 0 : 1; let d = new Uint8Array(f / 3).fill(u); o.attributes.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: d }) } r = re.fromRectangle3D(t, n, s) } return new st({ attributes: o.attributes, indices: o.indices, primitiveType: Oe.LINES, boundingSphere: r, offsetAttribute: e._offsetAttribute }) }; var Ox = Ix; function Rx(e) { this.rectangle = ce.clone(e.rectangle), this.minimumHeight = y(e.minimumHeight, 0), this.maximumHeight = y(e.maximumHeight, 0), this.southwestCornerCartesian = new h, this.northeastCornerCartesian = new h, this.westNormal = new h, this.southNormal = new h, this.eastNormal = new h, this.northNormal = new h; let t = y(e.ellipsoid, ie.WGS84); Uze(this, e.rectangle, t), this._orientedBoundingBox = void 0, this._boundingSphere = void 0, y(e.computeBoundingVolumes, !0) && this.computeBoundingVolumes(t) } Object.defineProperties(Rx.prototype, { boundingVolume: { get: function () { return this._orientedBoundingBox } }, boundingSphere: { get: function () { return this._boundingSphere } } }); Rx.prototype.computeBoundingVolumes = function (e) { this._orientedBoundingBox = di.fromRectangle(this.rectangle, this.minimumHeight, this.maximumHeight, e), this._boundingSphere = re.fromOrientedBoundingBox(this._orientedBoundingBox) }; var pie = new h, nF = new h, _ie = new h, Fze = new h, Nze = new h, Vze = new h, kze = new h, Eu = new he, gie = new nn(h.UNIT_X, 0), Bx = new En; function Uze(e, t, n) { n.cartographicToCartesian(ce.southwest(t), e.southwestCornerCartesian), n.cartographicToCartesian(ce.northeast(t), e.northeastCornerCartesian), Eu.longitude = t.west, Eu.latitude = (t.south + t.north) * .5, Eu.height = 0; let i = n.cartographicToCartesian(Eu, Vze), o = h.cross(i, h.UNIT_Z, Fze); h.normalize(o, e.westNormal), Eu.longitude = t.east; let r = n.cartographicToCartesian(Eu, kze), s = h.cross(h.UNIT_Z, r, pie); h.normalize(s, e.eastNormal); let a = h.subtract(i, r, pie); h.magnitude(a) === 0 && (a = h.clone(o, a)); let c = h.normalize(a, Nze), u = t.south, f; if (u > 0) { Eu.longitude = (t.west + t.east) * .5, Eu.latitude = u; let A = n.cartographicToCartesian(Eu, Bx.origin); h.clone(c, Bx.direction); let C = nn.fromPointNormal(e.southwestCornerCartesian, e.westNormal, gie); Gi.rayPlane(Bx, C, e.southwestCornerCartesian), f = n.geodeticSurfaceNormal(A, nF) } else f = n.geodeticSurfaceNormalCartographic(ce.southeast(t), nF); let d = h.cross(f, a, _ie); h.normalize(d, e.southNormal); let p = t.north, g; if (p < 0) { Eu.longitude = (t.west + t.east) * .5, Eu.latitude = p; let A = n.cartographicToCartesian(Eu, Bx.origin); h.negate(c, Bx.direction); let C = nn.fromPointNormal(e.northeastCornerCartesian, e.eastNormal, gie); Gi.rayPlane(Bx, C, e.northeastCornerCartesian), g = n.geodeticSurfaceNormal(A, nF) } else g = n.geodeticSurfaceNormalCartographic(ce.northwest(t), nF); let m = h.cross(a, g, _ie); h.normalize(m, e.northNormal) } var zze = new h, Hze = new h, Gze = new h(0, -1, 0), Wze = new h(0, 0, -1), yie = new h; function jze(e, t) { let n = t.camera, i = n.positionWC, o = n.positionCartographic, r = 0; if (!ce.contains(e.rectangle, o)) { let u = e.southwestCornerCartesian, f = e.northeastCornerCartesian, d = e.westNormal, p = e.southNormal, g = e.eastNormal, m = e.northNormal; t.mode !== ee.SCENE3D && (u = t.mapProjection.project(ce.southwest(e.rectangle), zze), u.z = u.y, u.y = u.x, u.x = 0, f = t.mapProjection.project(ce.northeast(e.rectangle), Hze), f.z = f.y, f.y = f.x, f.x = 0, d = Gze, g = h.UNIT_Y, p = Wze, m = h.UNIT_Z); let A = h.subtract(i, u, yie), C = h.dot(A, d), x = h.dot(A, p), T = h.subtract(i, f, yie), b = h.dot(T, g), S = h.dot(T, m); C > 0 ? r += C * C : b > 0 && (r += b * b), x > 0 ? r += x * x : S > 0 && (r += S * S) } let s, a, c; if (t.mode === ee.SCENE3D ? (s = o.height, a = e.minimumHeight, c = e.maximumHeight) : (s = i.x, a = 0, c = 0), s > c) { let u = s - c; r += u * u } else if (s < a) { let u = a - s; r += u * u } return Math.sqrt(r) } Rx.prototype.distanceToCamera = function (e) { let t = jze(this, e); if (e.mode === ee.SCENE3D && l(this._orientedBoundingBox)) { let n = Math.sqrt(this._orientedBoundingBox.distanceSquaredTo(e.camera.positionWC)); return Math.max(t, n) } return t }; Rx.prototype.intersectPlane = function (e) { return this._orientedBoundingBox.intersectPlane(e) }; Rx.prototype.createDebugVolume = function (e) { let t = new F.clone(F.IDENTITY), n = new Ox({ rectangle: this.rectangle, height: this.minimumHeight, extrudedHeight: this.maximumHeight }), i = new At({ geometry: n, id: "outline", modelMatrix: t, attributes: { color: Bt.fromColor(e) } }); return new xn({ geometryInstances: i, appearance: new $t({ translucent: !1, flat: !0 }), asynchronous: !1 }) }; var Bf = Rx; var fw = {}, qze = new h, Aie = new h, Cie = new h, xie = new h, Tie = new di; fw.validOutline = function (e) { let n = di.fromPoints(e, Tie).halfAxes, i = Q.getColumn(n, 0, Aie), o = Q.getColumn(n, 1, Cie), r = Q.getColumn(n, 2, xie), s = h.magnitude(i), a = h.magnitude(o), c = h.magnitude(r); return !(s === 0 && (a === 0 || c === 0) || a === 0 && c === 0) }; fw.computeProjectTo2DArguments = function (e, t, n, i) { let o = di.fromPoints(e, Tie), r = o.halfAxes, s = Q.getColumn(r, 0, Aie), a = Q.getColumn(r, 1, Cie), c = Q.getColumn(r, 2, xie), u = h.magnitude(s), f = h.magnitude(a), d = h.magnitude(c), p = Math.min(u, f, d); if (u === 0 && (f === 0 || d === 0) || f === 0 && d === 0) return !1; let g, m; return (p === f || p === d) && (g = s), p === u ? g = a : p === d && (m = a), (p === u || p === f) && (m = c), h.normalize(g, n), h.normalize(m, i), h.clone(o.center, t), !0 }; function Eie(e, t, n, i, o) { let r = h.subtract(e, t, qze), s = h.dot(n, r), a = h.dot(i, r); return H.fromElements(s, a, o) } fw.createProjectPointsTo2DFunction = function (e, t, n) { return function (i) { let o = new Array(i.length); for (let r = 0; r < i.length; r++)o[r] = Eie(i[r], e, t, n); return o } }; fw.createProjectPointTo2DFunction = function (e, t, n) { return function (i, o) { return Eie(i, e, t, n, o) } }; var O_ = fw; function B_() { this._array = [], this._offset = 0, this._length = 0 } Object.defineProperties(B_.prototype, { length: { get: function () { return this._length } } }); B_.prototype.enqueue = function (e) { this._array.push(e), this._length++ }; B_.prototype.dequeue = function () { if (this._length === 0) return; let e = this._array, t = this._offset, n = e[t]; return e[t] = void 0, t++, t > 10 && t * 2 > e.length && (this._array = e.slice(t), t = 0), this._offset = t, this._length--, n }; B_.prototype.peek = function () { if (this._length !== 0) return this._array[this._offset] }; B_.prototype.contains = function (e) { return this._array.indexOf(e) !== -1 }; B_.prototype.clear = function () { this._array.length = this._offset = this._length = 0 }; B_.prototype.sort = function (e) { this._offset > 0 && (this._array = this._array.slice(this._offset), this._offset = 0), this._array.sort(e) }; var ry = B_; var $o = {}; $o.computeHierarchyPackedLength = function (e, t) { let n = 0, i = [e]; for (; i.length > 0;) { let o = i.pop(); if (!l(o)) continue; n += 2; let r = o.positions, s = o.holes; if (l(r) && r.length > 0 && (n += r.length * t.packedLength), l(s)) { let a = s.length; for (let c = 0; c < a; ++c)i.push(s[c]) } } return n }; $o.packPolygonHierarchy = function (e, t, n, i) { let o = [e]; for (; o.length > 0;) { let r = o.pop(); if (!l(r)) continue; let s = r.positions, a = r.holes; if (t[n++] = l(s) ? s.length : 0, t[n++] = l(a) ? a.length : 0, l(s)) { let c = s.length; for (let u = 0; u < c; ++u, n += i.packedLength)i.pack(s[u], t, n) } if (l(a)) { let c = a.length; for (let u = 0; u < c; ++u)o.push(a[u]) } } return n }; $o.unpackPolygonHierarchy = function (e, t, n) { let i = e[t++], o = e[t++], r = new Array(i), s = o > 0 ? new Array(o) : void 0; for (let a = 0; a < i; ++a, t += n.packedLength)r[a] = n.unpack(e, t); for (let a = 0; a < o; ++a)s[a] = $o.unpackPolygonHierarchy(e, t, n), t = s[a].startingIndex, delete s[a].startingIndex; return { positions: r, holes: s, startingIndex: t } }; var sy = new H; function Die(e, t, n, i) { return H.subtract(t, e, sy), H.multiplyByScalar(sy, n / i, sy), H.add(e, sy, sy), [sy.x, sy.y] } var R_ = new h; function Yze(e, t, n, i) { return h.subtract(t, e, R_), h.multiplyByScalar(R_, n / i, R_), h.add(e, R_, R_), [R_.x, R_.y, R_.z] } $o.subdivideLineCount = function (e, t, n) { let o = h.distance(e, t) / n, r = Math.max(0, Math.ceil(I.log2(o))); return Math.pow(2, r) }; var b5 = new he, S5 = new he, Xze = new he, Kze = new h, bie = new ga; $o.subdivideRhumbLineCount = function (e, t, n, i) { let o = e.cartesianToCartographic(t, b5), r = e.cartesianToCartographic(n, S5), a = new ga(o, r, e).surfaceDistance / i, c = Math.max(0, Math.ceil(I.log2(a))); return Math.pow(2, c) }; $o.subdivideTexcoordLine = function (e, t, n, i, o, r) { let s = $o.subdivideLineCount(n, i, o), a = H.distance(e, t), c = a / s, u = r; u.length = s * 2; let f = 0; for (let d = 0; d < s; d++) { let p = Die(e, t, d * c, a); u[f++] = p[0], u[f++] = p[1] } return u }; $o.subdivideLine = function (e, t, n, i) { let o = $o.subdivideLineCount(e, t, n), r = h.distance(e, t), s = r / o; l(i) || (i = []); let a = i; a.length = o * 3; let c = 0; for (let u = 0; u < o; u++) { let f = Yze(e, t, u * s, r); a[c++] = f[0], a[c++] = f[1], a[c++] = f[2] } return a }; $o.subdivideTexcoordRhumbLine = function (e, t, n, i, o, r, s) { let a = n.cartesianToCartographic(i, b5), c = n.cartesianToCartographic(o, S5); bie.setEndPoints(a, c); let u = bie.surfaceDistance / r, f = Math.max(0, Math.ceil(I.log2(u))), d = Math.pow(2, f), p = H.distance(e, t), g = p / d, m = s; m.length = d * 2; let A = 0; for (let C = 0; C < d; C++) { let x = Die(e, t, C * g, p); m[A++] = x[0], m[A++] = x[1] } return m }; $o.subdivideRhumbLine = function (e, t, n, i, o) { let r = e.cartesianToCartographic(t, b5), s = e.cartesianToCartographic(n, S5), a = new ga(r, s, e), c = a.surfaceDistance / i, u = Math.max(0, Math.ceil(I.log2(c))), f = Math.pow(2, u), d = a.surfaceDistance / f; l(o) || (o = []); let p = o; p.length = f * 3; let g = 0; for (let m = 0; m < f; m++) { let A = a.interpolateUsingSurfaceDistance(m * d, Xze), C = e.cartographicToCartesian(A, Kze); p[g++] = C.x, p[g++] = C.y, p[g++] = C.z } return p }; var Jze = new h, Zze = new h, Qze = new h, $ze = new h; $o.scaleToGeodeticHeightExtruded = function (e, t, n, i, o) { i = y(i, ie.WGS84); let r = Jze, s = Zze, a = Qze, c = $ze; if (l(e) && l(e.attributes) && l(e.attributes.position)) { let u = e.attributes.position.values, f = u.length / 2; for (let d = 0; d < f; d += 3)h.fromArray(u, d, a), i.geodeticSurfaceNormal(a, r), c = i.scaleToGeodeticSurface(a, c), s = h.multiplyByScalar(r, n, s), s = h.add(c, s, s), u[d + f] = s.x, u[d + 1 + f] = s.y, u[d + 2 + f] = s.z, o && (c = h.clone(a, c)), s = h.multiplyByScalar(r, t, s), s = h.add(c, s, s), u[d] = s.x, u[d + 1] = s.y, u[d + 2] = s.z } return e }; $o.polygonOutlinesFromHierarchy = function (e, t, n) { let i = [], o = new ry; o.enqueue(e); let r, s, a; for (; o.length !== 0;) { let c = o.dequeue(), u = c.positions; if (t) for (a = u.length, r = 0; r < a; r++)n.scaleToGeodeticSurface(u[r], u[r]); if (u = _o(u, h.equalsEpsilon, !0), u.length < 3) continue; let f = c.holes ? c.holes.length : 0; for (r = 0; r < f; r++) { let d = c.holes[r], p = d.positions; if (t) for (a = p.length, s = 0; s < a; ++s)n.scaleToGeodeticSurface(p[s], p[s]); if (p = _o(p, h.equalsEpsilon, !0), p.length < 3) continue; i.push(p); let g = 0; for (l(d.holes) && (g = d.holes.length), s = 0; s < g; s++)o.enqueue(d.holes[s]) } i.push(u) } return i }; $o.polygonsFromHierarchy = function (e, t, n, i, o) { let r = [], s = [], a = new ry; for (a.enqueue(e); a.length !== 0;) { let c = a.dequeue(), u = c.positions, f = c.holes, d, p; if (i) for (p = u.length, d = 0; d < p; d++)o.scaleToGeodeticSurface(u[d], u[d]); if (t || (u = _o(u, h.equalsEpsilon, !0)), u.length < 3) continue; let g = n(u); if (!l(g)) continue; let m = [], A = ni.computeWindingOrder2D(g); A === Kr.CLOCKWISE && (g.reverse(), u = u.slice().reverse()); let C = u.slice(), x = l(f) ? f.length : 0, T = [], b; for (d = 0; d < x; d++) { let S = f[d], D = S.positions; if (i) for (p = D.length, b = 0; b < p; ++b)o.scaleToGeodeticSurface(D[b], D[b]); if (t || (D = _o(D, h.equalsEpsilon, !0)), D.length < 3) continue; let P = n(D); if (!l(P)) continue; A = ni.computeWindingOrder2D(P), A === Kr.CLOCKWISE && (P.reverse(), D = D.slice().reverse()), T.push(D), m.push(C.length), C = C.concat(D), g = g.concat(P); let B = 0; for (l(S.holes) && (B = S.holes.length), b = 0; b < B; b++)a.enqueue(S.holes[b]) } r.push({ outerRing: u, holes: T }), s.push({ positions: C, positions2D: g, holes: m }) } return { hierarchy: r, polygons: s } }; var eHe = new H, tHe = new h, nHe = new Be, iHe = new Q; $o.computeBoundingRectangle = function (e, t, n, i, o) { let r = Be.fromAxisAngle(e, i, nHe), s = Q.fromQuaternion(r, iHe), a = Number.POSITIVE_INFINITY, c = Number.NEGATIVE_INFINITY, u = Number.POSITIVE_INFINITY, f = Number.NEGATIVE_INFINITY, d = n.length; for (let p = 0; p < d; ++p) { let g = h.clone(n[p], tHe); Q.multiplyByVector(s, g, g); let m = t(g, eHe); l(m) && (a = Math.min(a, m.x), c = Math.max(c, m.x), u = Math.min(u, m.y), f = Math.max(f, m.y)) } return o.x = a, o.y = u, o.width = c - a, o.height = f - u, o }; $o.createGeometryFromPositions = function (e, t, n, i, o, r, s) { let a = ni.triangulate(t.positions2D, t.holes); a.length < 3 && (a = [0, 1, 2]); let c = t.positions, u = l(n), f = u ? n.positions : void 0; if (o) { let d = c.length, p = new Array(d * 3), g = 0; for (let C = 0; C < d; C++) { let x = c[C]; p[g++] = x.x, p[g++] = x.y, p[g++] = x.z } let m = { attributes: { position: new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: p }) }, indices: a, primitiveType: Oe.TRIANGLES }; u && (m.attributes.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: H.packArray(f) })); let A = new st(m); return r.normal ? Bn.computeNormal(A) : A } if (s === Yt.GEODESIC) return ni.computeSubdivision(e, c, a, f, i); if (s === Yt.RHUMB) return ni.computeRhumbLineSubdivision(e, c, a, f, i) }; var Sie = [], wie = [], oHe = new h, rHe = new h; $o.computeWallGeometry = function (e, t, n, i, o, r) { let s, a, c, u, f, d, p, g, m, A = e.length, C = 0, x = 0, T = l(t), b = T ? t.positions : void 0; if (o) for (a = A * 3 * 2, s = new Array(a * 2), T && (m = A * 2 * 2, g = new Array(m * 2)), c = 0; c < A; c++)u = e[c], f = e[(c + 1) % A], s[C] = s[C + a] = u.x, ++C, s[C] = s[C + a] = u.y, ++C, s[C] = s[C + a] = u.z, ++C, s[C] = s[C + a] = f.x, ++C, s[C] = s[C + a] = f.y, ++C, s[C] = s[C + a] = f.z, ++C, T && (d = b[c], p = b[(c + 1) % A], g[x] = g[x + m] = d.x, ++x, g[x] = g[x + m] = d.y, ++x, g[x] = g[x + m] = p.x, ++x, g[x] = g[x + m] = p.y, ++x); else { let R = I.chordLength(i, n.maximumRadius), M = 0; if (r === Yt.GEODESIC) for (c = 0; c < A; c++)M += $o.subdivideLineCount(e[c], e[(c + 1) % A], R); else if (r === Yt.RHUMB) for (c = 0; c < A; c++)M += $o.subdivideRhumbLineCount(n, e[c], e[(c + 1) % A], R); for (a = (M + A) * 3, s = new Array(a * 2), T && (m = (M + A) * 2, g = new Array(m * 2)), c = 0; c < A; c++) { u = e[c], f = e[(c + 1) % A]; let L, _; T && (d = b[c], p = b[(c + 1) % A]), r === Yt.GEODESIC ? (L = $o.subdivideLine(u, f, R, wie), T && (_ = $o.subdivideTexcoordLine(d, p, u, f, R, Sie))) : r === Yt.RHUMB && (L = $o.subdivideRhumbLine(n, u, f, R, wie), T && (_ = $o.subdivideTexcoordRhumbLine(d, p, n, u, f, R, Sie))); let E = L.length; for (let w = 0; w < E; ++w, ++C)s[C] = L[w], s[C + a] = L[w]; if (s[C] = f.x, s[C + a] = f.x, ++C, s[C] = f.y, s[C + a] = f.y, ++C, s[C] = f.z, s[C + a] = f.z, ++C, T) { let w = _.length; for (let v = 0; v < w; ++v, ++x)g[x] = _[v], g[x + m] = _[v]; g[x] = p.x, g[x + m] = p.x, ++x, g[x] = p.y, g[x + m] = p.y, ++x } } } A = s.length; let S = Me.createTypedArray(A / 3, A - e.length * 6), D = 0; for (A /= 6, c = 0; c < A; c++) { let R = c, M = R + 1, L = R + A, _ = L + 1; u = h.fromArray(s, R * 3, oHe), f = h.fromArray(s, M * 3, rHe), !h.equalsEpsilon(u, f, I.EPSILON10, I.EPSILON10) && (S[D++] = R, S[D++] = L, S[D++] = M, S[D++] = M, S[D++] = L, S[D++] = _) } let P = { attributes: new sn({ position: new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: s }) }), indices: S, primitiveType: Oe.TRIANGLES }; return T && (P.attributes.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: g })), new st(P) }; var Un = $o; function sHe(e) { let t = e.length, n = new Float64Array(t * 3), i = Me.createTypedArray(t, t * 2), o = 0, r = 0; for (let a = 0; a < t; a++) { let c = e[a]; n[o++] = c.x, n[o++] = c.y, n[o++] = c.z, i[r++] = a, i[r++] = (a + 1) % t } let s = new sn({ position: new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: n }) }); return new st({ attributes: s, indices: i, primitiveType: Oe.LINES }) } function ay(e) { e = y(e, y.EMPTY_OBJECT); let t = e.polygonHierarchy; this._polygonHierarchy = t, this._workerName = "createCoplanarPolygonOutlineGeometry", this.packedLength = Un.computeHierarchyPackedLength(t, h) + 1 } ay.fromPositions = function (e) { e = y(e, y.EMPTY_OBJECT); let t = { polygonHierarchy: { positions: e.positions } }; return new ay(t) }; ay.pack = function (e, t, n) { return n = y(n, 0), n = Un.packPolygonHierarchy(e._polygonHierarchy, t, n, h), t[n] = e.packedLength, t }; var aHe = { polygonHierarchy: {} }; ay.unpack = function (e, t, n) { t = y(t, 0); let i = Un.unpackPolygonHierarchy(e, t, h); t = i.startingIndex, delete i.startingIndex; let o = e[t]; return l(n) || (n = new ay(aHe)), n._polygonHierarchy = i, n.packedLength = o, n }; ay.createGeometry = function (e) { let t = e._polygonHierarchy, n = t.positions; if (n = _o(n, h.equalsEpsilon, !0), n.length < 3 || !O_.validOutline(n)) return; let o = Un.polygonOutlinesFromHierarchy(t, !1); if (o.length === 0) return; let r = []; for (let c = 0; c < o.length; c++) { let u = new At({ geometry: sHe(o[c]) }); r.push(u) } let s = Bn.combineInstances(r)[0], a = re.fromPoints(t.positions); return new st({ attributes: s.attributes, indices: s.indices, primitiveType: s.primitiveType, boundingSphere: a }) }; var Rf = ay; var iF = new he; function dw(e) { let t = e_.fromToken(e.token), n = y(e.minimumHeight, 0), i = y(e.maximumHeight, 0), o = y(e.ellipsoid, ie.WGS84); this.s2Cell = t, this.minimumHeight = n, this.maximumHeight = i, this.ellipsoid = o; let r = _He(t, n, i, o); this._boundingPlanes = r; let s = CHe(r); this._vertices = s, this._edgeNormals = new Array(6), this._edgeNormals[0] = R5(r[0], s.slice(0, 4)); let a; for (a = 0; a < 4; a++)this._edgeNormals[0][a] = h.negate(this._edgeNormals[0][a], this._edgeNormals[0][a]); for (this._edgeNormals[1] = R5(r[1], s.slice(4, 8)), a = 0; a < 4; a++)this._edgeNormals[2 + a] = R5(r[2 + a], [s[a % 4], s[(a + 1) % 4], s[4 + (a + 1) % 4], s[4 + a]]); for (this._planeVertices = [this._vertices.slice(0, 4), this._vertices.slice(4, 8)], a = 0; a < 4; a++)this._planeVertices.push([this._vertices[a % 4], this._vertices[(a + 1) % 4], this._vertices[4 + (a + 1) % 4], this._vertices[4 + a]]); let c = t.getCenter(); iF = o.cartesianToCartographic(c, iF), iF.height = (i + n) / 2, this.center = o.cartographicToCartesian(iF, c), this._boundingSphere = re.fromPoints(s) } var cHe = new h, lHe = new he, uHe = new h, fHe = new he, dHe = new h, hHe = new h, mHe = new h, pHe = new h; function _He(e, t, n, i) { let o = new Array(6), r = e.getCenter(), s = i.geodeticSurfaceNormal(r, cHe), a = i.cartesianToCartographic(r, lHe); a.height = n; let c = i.cartographicToCartesian(a, uHe), u = nn.fromPointNormal(c, s); o[0] = u; let f = 0, d, p = [], g, m; for (d = 0; d < 4; d++) { g = e.getVertex(d), p[d] = g, m = i.cartesianToCartographic(g, fHe), m.height = t; let C = nn.getPointDistance(u, i.cartographicToCartesian(m, dHe)); C < f && (f = C) } let A = nn.clone(u); for (A.normal = h.negate(A.normal, A.normal), A.distance = A.distance * -1 + f, o[1] = A, d = 0; d < 4; d++) { g = p[d]; let C = p[(d + 1) % 4], x = i.geodeticSurfaceNormal(g, hHe), T = h.subtract(C, g, pHe), b = h.cross(T, x, mHe); b = h.normalize(b, b), o[2 + d] = nn.fromPointNormal(g, b) } return o } var cy = new h, ly = new h, uy = new h, w5 = new h, D5 = new h, v5 = new h, gHe = new h, yHe = new h, AHe = new h, P5 = new h, I5 = new h, O5 = new h, M_ = new h, ih = new Q; function vie(e, t, n) { cy = e.normal, ly = t.normal, uy = n.normal, w5 = h.multiplyByScalar(e.normal, -e.distance, w5), D5 = h.multiplyByScalar(t.normal, -t.distance, D5), v5 = h.multiplyByScalar(n.normal, -n.distance, v5), P5 = h.multiplyByScalar(h.cross(ly, uy, gHe), h.dot(w5, cy), P5), I5 = h.multiplyByScalar(h.cross(uy, cy, yHe), h.dot(D5, ly), I5), O5 = h.multiplyByScalar(h.cross(cy, ly, AHe), h.dot(v5, uy), O5), ih[0] = cy.x, ih[1] = ly.x, ih[2] = uy.x, ih[3] = cy.y, ih[4] = ly.y, ih[5] = uy.y, ih[6] = cy.z, ih[7] = ly.z, ih[8] = uy.z; let i = Q.determinant(ih); return M_ = h.add(P5, I5, M_), M_ = h.add(M_, O5, M_), new h(M_.x / i, M_.y / i, M_.z / i) } function CHe(e) { let t = new Array(8); for (let n = 0; n < 4; n++)t[n] = vie(e[0], e[2 + (n + 3) % 4], e[2 + n % 4]), t[n + 4] = vie(e[1], e[2 + (n + 3) % 4], e[2 + n % 4]); return t } var B5 = new h, Mx = new h; function R5(e, t) { let n = []; for (let i = 0; i < 4; i++)B5 = h.subtract(t[(i + 1) % 4], t[i], B5), Mx = h.cross(e.normal, B5, Mx), Mx = h.normalize(Mx, Mx), n[i] = h.clone(Mx); return n } Object.defineProperties(dw.prototype, { boundingVolume: { get: function () { return this } }, boundingSphere: { get: function () { return this._boundingSphere } } }); var M5 = new h; dw.prototype.distanceToCamera = function (e) { let t = e.camera.positionWC, n = [], i = [], o; nn.getPointDistance(this._boundingPlanes[0], t) > 0 ? (n.push(0), i.push(this._planeVertices[0]), o = this._edgeNormals[0]) : nn.getPointDistance(this._boundingPlanes[1], t) > 0 && (n.push(1), i.push(this._planeVertices[1]), o = this._edgeNormals[1]); let r, s; for (r = 0; r < 4; r++)s = 2 + r, nn.getPointDistance(this._boundingPlanes[s], t) > 0 && (n.push(s), i.push(this._planeVertices[s]), o = this._edgeNormals[s]); if (n.length === 0) return 0; let a, c; if (n.length === 1) return c = this._boundingPlanes[n[0]], a = L5(nn.projectPointOntoPlane(c, t, M5), i[0], c, o), h.distance(a, t); if (n.length === 2) { if (n[0] === 0) { let p = [this._vertices[4 * n[0] + (n[1] - 2)], this._vertices[4 * n[0] + (n[1] - 2 + 1) % 4]]; return a = Pie(t, p[0], p[1]), h.distance(a, t) } let f = Number.MAX_VALUE, d; for (r = 0; r < 2; r++)c = this._boundingPlanes[n[r]], a = L5(nn.projectPointOntoPlane(c, t, M5), i[r], c, this._edgeNormals[n[r]]), d = h.distanceSquared(a, t), d < f && (f = d); return Math.sqrt(f) } else if (n.length > 3) return a = L5(nn.projectPointOntoPlane(this._boundingPlanes[1], t, M5), this._planeVertices[1], this._boundingPlanes[1], this._edgeNormals[1]), h.distance(a, t); let u = n[1] === 2 && n[2] === 5 ? 0 : 1; return n[0] === 0 ? h.distance(t, this._vertices[(n[1] - 2 + u) % 4]) : h.distance(t, this._vertices[4 + (n[1] - 2 + u) % 4]) }; var xHe = new h, THe = new h; function Pie(e, t, n) { let i = h.subtract(n, t, xHe), o = h.subtract(e, t, THe), r = h.dot(i, o); if (r <= 0) return t; let s = h.dot(i, i); return r >= s ? n : (r = r / s, new h((1 - r) * t.x + r * n.x, (1 - r) * t.y + r * n.y, (1 - r) * t.z + r * n.z)) } var EHe = new nn(h.UNIT_X, 0); function L5(e, t, n, i) { let o = Number.MAX_VALUE, r, s, a; for (let c = 0; c < t.length; c++) { let u = nn.fromPointNormal(t[c], i[c], EHe); nn.getPointDistance(u, e) < 0 || (a = Pie(e, t[c], t[(c + 1) % 4]), r = h.distance(e, a), r < o && (o = r, s = a)) } return l(s) ? s : e } dw.prototype.intersectPlane = function (e) { let t = 0, n = 0; for (let i = 0; i < this._vertices.length; i++)h.dot(e.normal, this._vertices[i]) + e.distance < 0 ? n++ : t++; return t === this._vertices.length ? Kt.INSIDE : n === this._vertices.length ? Kt.OUTSIDE : Kt.INTERSECTING }; dw.prototype.createDebugVolume = function (e) { let t = new F.clone(F.IDENTITY), n = new Rf({ polygonHierarchy: { positions: this._planeVertices[0] } }), i = Rf.createGeometry(n), o = new At({ geometry: i, id: "outline", modelMatrix: t, attributes: { color: Bt.fromColor(e) } }), r = new Rf({ polygonHierarchy: { positions: this._planeVertices[1] } }), s = Rf.createGeometry(r), a = new At({ geometry: s, id: "outline", modelMatrix: t, attributes: { color: Bt.fromColor(e) } }), c = []; for (let u = 0; u < 4; u++) { let f = new Rf({ polygonHierarchy: { positions: this._planeVertices[2 + u] } }), d = Rf.createGeometry(f); c[u] = new At({ geometry: d, id: "outline", modelMatrix: t, attributes: { color: Bt.fromColor(e) } }) } return new xn({ geometryInstances: [c[0], c[1], c[2], c[3], a, o], appearance: new $t({ translucent: !1, flat: !0 }), asynchronous: !1 }) }; var oF = dw; var bHe = new h(1, 1, 1), rF = Math.cos, sF = Math.sin; function Lx(e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.radii, bHe), n = y(e.innerRadii, t), i = y(e.minimumClock, 0), o = y(e.maximumClock, I.TWO_PI), r = y(e.minimumCone, 0), s = y(e.maximumCone, I.PI), a = Math.round(y(e.stackPartitions, 10)), c = Math.round(y(e.slicePartitions, 8)), u = Math.round(y(e.subdivisions, 128)); this._radii = h.clone(t), this._innerRadii = h.clone(n), this._minimumClock = i, this._maximumClock = o, this._minimumCone = r, this._maximumCone = s, this._stackPartitions = a, this._slicePartitions = c, this._subdivisions = u, this._offsetAttribute = e.offsetAttribute, this._workerName = "createEllipsoidOutlineGeometry" } Lx.packedLength = 2 * h.packedLength + 8; Lx.pack = function (e, t, n) { return n = y(n, 0), h.pack(e._radii, t, n), n += h.packedLength, h.pack(e._innerRadii, t, n), n += h.packedLength, t[n++] = e._minimumClock, t[n++] = e._maximumClock, t[n++] = e._minimumCone, t[n++] = e._maximumCone, t[n++] = e._stackPartitions, t[n++] = e._slicePartitions, t[n++] = e._subdivisions, t[n] = y(e._offsetAttribute, -1), t }; var Iie = new h, Oie = new h, jm = { radii: Iie, innerRadii: Oie, minimumClock: void 0, maximumClock: void 0, minimumCone: void 0, maximumCone: void 0, stackPartitions: void 0, slicePartitions: void 0, subdivisions: void 0, offsetAttribute: void 0 }; Lx.unpack = function (e, t, n) { t = y(t, 0); let i = h.unpack(e, t, Iie); t += h.packedLength; let o = h.unpack(e, t, Oie); t += h.packedLength; let r = e[t++], s = e[t++], a = e[t++], c = e[t++], u = e[t++], f = e[t++], d = e[t++], p = e[t]; return l(n) ? (n._radii = h.clone(i, n._radii), n._innerRadii = h.clone(o, n._innerRadii), n._minimumClock = r, n._maximumClock = s, n._minimumCone = a, n._maximumCone = c, n._stackPartitions = u, n._slicePartitions = f, n._subdivisions = d, n._offsetAttribute = p === -1 ? void 0 : p, n) : (jm.minimumClock = r, jm.maximumClock = s, jm.minimumCone = a, jm.maximumCone = c, jm.stackPartitions = u, jm.slicePartitions = f, jm.subdivisions = d, jm.offsetAttribute = p === -1 ? void 0 : p, new Lx(jm)) }; Lx.createGeometry = function (e) { let t = e._radii; if (t.x <= 0 || t.y <= 0 || t.z <= 0) return; let n = e._innerRadii; if (n.x <= 0 || n.y <= 0 || n.z <= 0) return; let i = e._minimumClock, o = e._maximumClock, r = e._minimumCone, s = e._maximumCone, a = e._subdivisions, c = ie.fromCartesian3(t), u = e._slicePartitions + 1, f = e._stackPartitions + 1; u = Math.round(u * Math.abs(o - i) / I.TWO_PI), f = Math.round(f * Math.abs(s - r) / I.PI), u < 2 && (u = 2), f < 2 && (f = 2); let d = 0, p = 1, g = n.x !== t.x || n.y !== t.y || n.z !== t.z, m = !1, A = !1; g && (p = 2, r > 0 && (m = !0, d += u), s < Math.PI && (A = !0, d += u)); let C = a * p * (f + u), x = new Float64Array(C * 3), T = 2 * (C + d - (u + f) * p), b = Me.createTypedArray(C, T), S, D, P, B, R = 0, M = new Array(f), L = new Array(f); for (S = 0; S < f; S++)B = r + S * (s - r) / (f - 1), M[S] = sF(B), L[S] = rF(B); let _ = new Array(a), E = new Array(a); for (S = 0; S < a; S++)P = i + S * (o - i) / (a - 1), _[S] = sF(P), E[S] = rF(P); for (S = 0; S < f; S++)for (D = 0; D < a; D++)x[R++] = t.x * M[S] * E[D], x[R++] = t.y * M[S] * _[D], x[R++] = t.z * L[S]; if (g) for (S = 0; S < f; S++)for (D = 0; D < a; D++)x[R++] = n.x * M[S] * E[D], x[R++] = n.y * M[S] * _[D], x[R++] = n.z * L[S]; for (M.length = a, L.length = a, S = 0; S < a; S++)B = r + S * (s - r) / (a - 1), M[S] = sF(B), L[S] = rF(B); for (_.length = u, E.length = u, S = 0; S < u; S++)P = i + S * (o - i) / (u - 1), _[S] = sF(P), E[S] = rF(P); for (S = 0; S < a; S++)for (D = 0; D < u; D++)x[R++] = t.x * M[S] * E[D], x[R++] = t.y * M[S] * _[D], x[R++] = t.z * L[S]; if (g) for (S = 0; S < a; S++)for (D = 0; D < u; D++)x[R++] = n.x * M[S] * E[D], x[R++] = n.y * M[S] * _[D], x[R++] = n.z * L[S]; for (R = 0, S = 0; S < f * p; S++) { let O = S * a; for (D = 0; D < a - 1; D++)b[R++] = O + D, b[R++] = O + D + 1 } let w = f * a * p; for (S = 0; S < u; S++)for (D = 0; D < a - 1; D++)b[R++] = w + S + D * u, b[R++] = w + S + (D + 1) * u; if (g) for (w = f * a * p + u * a, S = 0; S < u; S++)for (D = 0; D < a - 1; D++)b[R++] = w + S + D * u, b[R++] = w + S + (D + 1) * u; if (g) { let O = f * a * p, V = O + a * u; if (m) for (S = 0; S < u; S++)b[R++] = O + S, b[R++] = V + S; if (A) for (O += a * u - u, V += a * u - u, S = 0; S < u; S++)b[R++] = O + S, b[R++] = V + S } let v = new sn({ position: new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: x }) }); if (l(e._offsetAttribute)) { let O = x.length, V = e._offsetAttribute === Qt.NONE ? 0 : 1, z = new Uint8Array(O / 3).fill(V); v.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: z }) } return new st({ attributes: v, indices: b, primitiveType: Oe.LINES, boundingSphere: re.fromEllipsoid(c), offsetAttribute: e._offsetAttribute }) }; var bu = Lx; function Fx(e) { let t = y(e.radius, 1), i = { radii: new h(t, t, t), stackPartitions: e.stackPartitions, slicePartitions: e.slicePartitions, subdivisions: e.subdivisions }; this._ellipsoidGeometry = new bu(i), this._workerName = "createSphereOutlineGeometry" } Fx.packedLength = bu.packedLength; Fx.pack = function (e, t, n) { return bu.pack(e._ellipsoidGeometry, t, n) }; var SHe = new bu, fy = { radius: void 0, radii: new h, stackPartitions: void 0, slicePartitions: void 0, subdivisions: void 0 }; Fx.unpack = function (e, t, n) { let i = bu.unpack(e, t, SHe); return fy.stackPartitions = i._stackPartitions, fy.slicePartitions = i._slicePartitions, fy.subdivisions = i._subdivisions, l(n) ? (h.clone(i._radii, fy.radii), n._ellipsoidGeometry = new bu(fy), n) : (fy.radius = i._radii.x, new Fx(fy)) }; Fx.createGeometry = function (e) { return bu.createGeometry(e._ellipsoidGeometry) }; var L_ = Fx; function Nx(e, t) { t === 0 && (t = I.EPSILON7), this._boundingSphere = new re(e, t) } Object.defineProperties(Nx.prototype, { center: { get: function () { return this._boundingSphere.center } }, radius: { get: function () { return this._boundingSphere.radius } }, boundingVolume: { get: function () { return this._boundingSphere } }, boundingSphere: { get: function () { return this._boundingSphere } } }); Nx.prototype.distanceToCamera = function (e) { let t = this._boundingSphere; return Math.max(0, h.distance(t.center, e.camera.positionWC) - t.radius) }; Nx.prototype.intersectPlane = function (e) { return re.intersectPlane(this._boundingSphere, e) }; Nx.prototype.update = function (e, t) { h.clone(e, this._boundingSphere.center), this._boundingSphere.radius = t }; Nx.prototype.createDebugVolume = function (e) { let t = new L_({ radius: this.radius }), n = F.fromTranslation(this.center, new F.clone(F.IDENTITY)), i = new At({ geometry: t, id: "outline", modelMatrix: n, attributes: { color: Bt.fromColor(e) } }); return new xn({ geometryInstances: i, appearance: new $t({ translucent: !1, flat: !0 }), asynchronous: !1 }) }; var F_ = Nx; var wHe = new h, DHe = new h, vHe = new h, PHe = new h; function dy(e, t, n) { n = h.cross(e, t, n); let i = h.magnitude(n); return h.multiplyByScalar(n, I.EPSILON7 / i, n) } function F5(e, t) { let n = h.normalize(e, PHe), i = h.equalsEpsilon(n, h.UNIT_X, I.EPSILON6) ? h.UNIT_Y : h.UNIT_X; return dy(e, i, t) } function Bie(e) { let t = Q.getColumn(e, 0, wHe), n = Q.getColumn(e, 1, DHe), i = Q.getColumn(e, 2, vHe), o = h.equals(t, h.ZERO), r = h.equals(n, h.ZERO), s = h.equals(i, h.ZERO); return !o && !r && !s ? e : o && r && s ? (e[0] = I.EPSILON7, e[4] = I.EPSILON7, e[8] = I.EPSILON7, e) : (o && !r && !s ? t = dy(n, i, t) : !o && r && !s ? n = dy(t, i, n) : !o && !r && s ? i = dy(n, t, i) : o ? r ? s || (t = F5(i, t), n = dy(i, t, n)) : (t = F5(n, t), i = dy(n, t, i)) : (n = F5(t, n), i = dy(n, t, i)), Q.setColumn(e, 0, t, e), Q.setColumn(e, 1, n, e), Q.setColumn(e, 2, i, e), e) } function Vx(e, t) { t = Bie(t), this._orientedBoundingBox = new di(e, t), this._boundingSphere = re.fromOrientedBoundingBox(this._orientedBoundingBox) } Object.defineProperties(Vx.prototype, { boundingVolume: { get: function () { return this._orientedBoundingBox } }, boundingSphere: { get: function () { return this._boundingSphere } } }); Vx.prototype.distanceToCamera = function (e) { return Math.sqrt(this._orientedBoundingBox.distanceSquaredTo(e.camera.positionWC)) }; Vx.prototype.intersectPlane = function (e) { return this._orientedBoundingBox.intersectPlane(e) }; Vx.prototype.update = function (e, t) { h.clone(e, this._orientedBoundingBox.center), t = Bie(t), Q.clone(t, this._orientedBoundingBox.halfAxes), re.fromOrientedBoundingBox(this._orientedBoundingBox, this._boundingSphere) }; Vx.prototype.createDebugVolume = function (e) { let t = new bd({ minimum: new h(-1, -1, -1), maximum: new h(1, 1, 1) }), n = F.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center), i = new At({ geometry: t, id: "outline", modelMatrix: n, attributes: { color: Bt.fromColor(e) } }); return new xn({ geometryInstances: i, appearance: new $t({ translucent: !1, flat: !0 }), asynchronous: !1 }) }; var Mf = Vx; function No(e, t, n, i) { this._tileset = e, this._header = n; let o = l(n.contents), r = o && n.contents.length > 1 || Mi(n, "3DTILES_multiple_contents"), s = o && !r ? n.contents[0] : n.content; this._contentHeader = s, this.transform = l(n.transform) ? F.unpack(n.transform) : F.clone(F.IDENTITY); let a = l(i) ? i.computedTransform : e.modelMatrix, c = F.multiply(a, this.transform, new F), u = l(i) ? i._initialTransform : F.IDENTITY; this._initialTransform = F.multiply(u, this.transform, new F), this.computedTransform = c, this._boundingVolume = this.createBoundingVolume(n.boundingVolume, c), this._boundingVolume2D = void 0; let f; l(s) && l(s.boundingVolume) && (f = this.createBoundingVolume(s.boundingVolume, c)), this._contentBoundingVolume = f, this._contentBoundingVolume2D = void 0; let d; l(n.viewerRequestVolume) && (d = this.createBoundingVolume(n.viewerRequestVolume, c)), this._viewerRequestVolume = d, this.geometricError = n.geometricError, this._geometricError = n.geometricError, l(this._geometricError) || (this._geometricError = l(i) ? i.geometricError : e._geometricError, No._deprecationWarning("geometricErrorUndefined", "Required property geometricError is undefined for this tile. Using parent's geometric error instead.")), this.updateGeometricErrorScale(); let p; l(n.refine) ? ((n.refine === "replace" || n.refine === "add") && No._deprecationWarning("lowercase-refine", `This tile uses a lowercase refine "${n.refine}". Instead use "${n.refine.toUpperCase()}".`), p = n.refine.toUpperCase() === "REPLACE" ? vr.REPLACE : vr.ADD) : l(i) ? p = i.refine : p = vr.REPLACE, this.refine = p, this.children = [], this.parent = i; let g, m = !1, A, C, x; if (t = Pe.createIfNeeded(t), r) A = To.UNLOADED, C = t.clone(); else if (l(s)) { let D = s.uri; l(s.url) && (No._deprecationWarning("contentUrl", 'This tileset JSON uses the "content.url" property which has been deprecated. Use "content.uri" instead.'), D = s.url), D === "" ? (No._deprecationWarning("contentUriEmpty", "content.uri property is an empty string, which creates a circular dependency, making this tileset invalid. Omit the content property instead"), g = new aw(e, this), m = !0, A = To.READY) : (A = To.UNLOADED, C = t.getDerivedResource({ url: D }), x = Ya.getServerKey(C.getUrlComponent())) } else g = new aw(e, this), m = !0, A = To.READY; this._content = g, this._contentResource = C, this._contentState = A, this._contentReadyToProcessPromise = void 0, this._contentReadyPromise = void 0, this._expiredContent = void 0, this._serverKey = x, this.hasEmptyContent = m, this.hasTilesetContent = !1, this.hasImplicitContent = !1, this.hasImplicitContentMetadata = !1, this.hasMultipleContents = r, this.metadata = KL(e, n), this.cacheNode = void 0; let T = n.expire, b, S; l(T) && (b = T.duration, l(T.date) && (S = $.fromIso8601(T.date))), this.expireDuration = b, this.expireDate = S, this.lastStyleTime = 0, this._optimChildrenWithinParent = Pf.NOT_COMPUTED, this.clippingPlanesDirty = !1, this.priorityDeferred = !1, this.implicitTileset = void 0, this.implicitCoordinates = void 0, this.implicitSubtree = void 0, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._screenSpaceErrorProgressiveResolution = 0, this._visibilityPlaneMask = 0, this._visible = !1, this._inRequestVolume = !1, this._finalResolution = !0, this._depth = 0, this._stackLength = 0, this._selectionDepth = 0, this._updatedVisibilityFrame = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._ancestorWithContent = void 0, this._ancestorWithContentAvailable = void 0, this._refines = !1, this._shouldSelect = !1, this._isClipped = !0, this._clippingPlanesState = 0, this._debugBoundingVolume = void 0, this._debugContentBoundingVolume = void 0, this._debugViewerRequestVolume = void 0, this._debugColor = U.fromRandom({ alpha: 1 }), this._debugColorizeTiles = !1, this._priority = 0, this._priorityHolder = this, this._priorityProgressiveResolution = !1, this._priorityProgressiveResolutionScreenSpaceErrorLeaf = !1, this._priorityReverseScreenSpaceError = 0, this._foveatedFactor = 0, this._wasMinPriorityChild = !1, this._loadTimestamp = new $, this._commandsLength = 0, this._color = void 0, this._colorDirty = !1, this._request = void 0 } No._deprecationWarning = Jr; Object.defineProperties(No.prototype, { tileset: { get: function () { return this._tileset } }, content: { get: function () { return this._content } }, boundingVolume: { get: function () { return this._boundingVolume } }, contentBoundingVolume: { get: function () { return y(this._contentBoundingVolume, this._boundingVolume) } }, boundingSphere: { get: function () { return this._boundingVolume.boundingSphere } }, extras: { get: function () { return this._header.extras } }, color: { get: function () { return l(this._color) || (this._color = new U), U.clone(this._color) }, set: function (e) { this._color = U.clone(e, this._color), this._colorDirty = !0 } }, contentAvailable: { get: function () { return this.contentReady && !this.hasEmptyContent && !this.hasTilesetContent && !this.hasImplicitContent || l(this._expiredContent) && !this.contentFailed } }, contentReady: { get: function () { return this._contentState === To.READY } }, contentUnloaded: { get: function () { return this._contentState === To.UNLOADED } }, contentExpired: { get: function () { return this._contentState === To.EXPIRED } }, contentFailed: { get: function () { return this._contentState === To.FAILED } }, contentReadyToProcessPromise: { get: function () { return this._contentReadyToProcessPromise } }, contentReadyPromise: { get: function () { return this._contentReadyPromise } }, commandsLength: { get: function () { return this._commandsLength } } }); var N_ = new h; function IHe(e, t) { let n = e._tileset, i = t.camera, o = e.boundingSphere, r = o.radius, s = h.multiplyByScalar(i.directionWC, e._centerZDepth, N_), a = h.add(i.positionWC, s, N_), c = h.subtract(a, o.center, N_); if (h.magnitude(c) > r) { let b = h.normalize(c, N_), S = h.multiplyByScalar(b, r, N_), D = h.add(o.center, S, N_), P = h.subtract(D, i.positionWC, N_), B = h.normalize(P, N_); e._foveatedFactor = 1 - Math.abs(h.dot(i.directionWC, B)) } else e._foveatedFactor = 0; let d = e.refine === vr.REPLACE, p = n._skipLevelOfDetail; if (d && !p || !n.foveatedScreenSpaceError || n.foveatedConeSize === 1 || e._priorityProgressiveResolution && d && p || n._pass === Qo.PRELOAD_FLIGHT || n._pass === Qo.PRELOAD) return !1; let g = 1 - Math.cos(i.frustum.fov * .5), m = n.foveatedConeSize * g; if (e._foveatedFactor <= m) return !1; let A = g - m, C = I.clamp((e._foveatedFactor - m) / A, 0, 1), x = n.foveatedInterpolationCallback(n.foveatedMinimumScreenSpaceErrorRelaxation, n.maximumScreenSpaceError, C), T = e._screenSpaceError === 0 && l(e.parent) ? e.parent._screenSpaceError * .5 : e._screenSpaceError; return n.maximumScreenSpaceError - x <= T } var Lie = new $; No.prototype.getScreenSpaceError = function (e, t, n) { let i = this._tileset, o = y(n, 1), r = l(this.parent) ? this.parent.geometricError : i._geometricError, s = t ? r : this.geometricError; if (s === 0) return 0; let a = e.camera, c = a.frustum, u = e.context, f = u.drawingBufferWidth, d = u.drawingBufferHeight * o, p; if (e.mode === ee.SCENE2D || c instanceof Zt) { l(c._offCenterFrustum) && (c = c._offCenterFrustum); let g = Math.max(c.top - c.bottom, c.right - c.left) / Math.max(f, d); p = s / g } else { let g = Math.max(this._distanceToCamera, I.EPSILON7), m = a.frustum.sseDenominator; if (p = s * d / (g * m), i.dynamicScreenSpaceError) { let A = i._dynamicScreenSpaceErrorComputedDensity, C = i.dynamicScreenSpaceErrorFactor; p -= I.fog(g, A) * C } } return p /= e.pixelRatio, p }; function OHe(e, t) { if (e.progressiveResolutionHeightFraction <= 0 || e.progressiveResolutionHeightFraction > .5) return !1; let n = t._screenSpaceErrorProgressiveResolution > e._maximumScreenSpaceError; t._priorityProgressiveResolutionScreenSpaceErrorLeaf = !1; let i = t.parent, o = e._maximumScreenSpaceError, r = t._screenSpaceErrorProgressiveResolution <= o, s = l(i) && i._screenSpaceErrorProgressiveResolution > o; return r && s && (t._priorityProgressiveResolutionScreenSpaceErrorLeaf = !0, n = !0), n } function BHe(e, t) { let n = t.parent, o = l(n) && (!e._skipLevelOfDetail || t._screenSpaceError === 0 || n.hasTilesetContent || n.hasImplicitContent) ? n._screenSpaceError : t._screenSpaceError; return e.root._screenSpaceError - o } No.prototype.updateVisibility = function (e) { let t = this.parent, n = this._tileset, i = l(t) ? t.computedTransform : n.modelMatrix, o = l(t) ? t._visibilityPlaneMask : Xs.MASK_INDETERMINATE; this.updateTransform(i), this._distanceToCamera = this.distanceToTile(e), this._centerZDepth = this.distanceToTileCenter(e), this._screenSpaceError = this.getScreenSpaceError(e, !1), this._screenSpaceErrorProgressiveResolution = this.getScreenSpaceError(e, !1, n.progressiveResolutionHeightFraction), this._visibilityPlaneMask = this.visibility(e, o), this._visible = this._visibilityPlaneMask !== Xs.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(e), this._priorityReverseScreenSpaceError = BHe(n, this), this._priorityProgressiveResolution = OHe(n, this), this.priorityDeferred = IHe(this, e) }; No.prototype.updateExpiration = function () { if (l(this.expireDate) && this.contentReady && !this.hasEmptyContent && !this.hasMultipleContents) { let e = $.now(Lie); $.lessThan(this.expireDate, e) && (this._contentState = To.EXPIRED, this._expiredContent = this._content) } }; function RHe(e) { if (l(e.expireDuration)) { let t = $.now(Lie); $.addSeconds(t, e.expireDuration, t), l(e.expireDate) ? $.lessThan(e.expireDate, t) && $.clone(t, e.expireDate) : e.expireDate = $.clone(t) } } function MHe(e) { return function () { return e._priority } } No.prototype.requestContent = function () { return this.hasEmptyContent ? 0 : this.hasMultipleContents ? LHe(this) : FHe(this) }; function LHe(e) { let t = e._content, n = e._tileset; if (!l(t)) { let r = Mi(e._header, "3DTILES_multiple_contents") ? e._header.extensions["3DTILES_multiple_contents"] : e._header; t = new JL(n, e, e._contentResource.clone(), r), e._content = t } let i = t.requestInnerContents(); if (i > 0) return i; e._contentState = To.LOADING; let o = t.contentsFetchedPromise.then(function () { if (!(e._contentState !== To.LOADING || !l(t.readyPromise))) { if (e.isDestroyed()) { N5(e, n, "Tile was unloaded while content was loading"); return } return e._contentState = To.PROCESSING, t } }); return e._contentReadyToProcessPromise = o, e._contentReadyPromise = o.then(function (r) { if (!!l(r)) return t.readyPromise }).then(function (r) { if (!!l(r)) { if (e.isDestroyed()) { N5(e, n, "Tile was unloaded while content was processing"); return } return e._selectedFrame = 0, e.lastStyleTime = 0, $.now(e._loadTimestamp), e._contentState = To.READY, r } }).catch(function (r) { N5(e, n, r) }), 0 } function N5(e, t, n) { e._contentState === To.PROCESSING && --t.statistics.numberOfTilesProcessing, e._contentState = To.FAILED } function FHe(e) { let t = e._contentResource.clone(), n = e.contentExpired; n && t.setQueryParameters({ expired: e.expireDate.toString() }); let i = new jo({ throttle: !0, throttleByServer: !0, type: Xr.TILES3D, priorityFunction: MHe(e), serverKey: e._serverKey }); e._request = i, t.request = i; let o = t.fetchArrayBuffer(); if (!l(o)) return 1; let r = e._contentState, s = e._tileset; e._contentState = To.LOADING, ++s.statistics.numberOfPendingRequests; let a = o.then(function (c) { if (e.isDestroyed()) { V5(e, s); return } let u = NHe(e, c); return n && (e.expireDate = void 0), e._content = u, e._contentState = To.PROCESSING, u }); return e._contentReadyToProcessPromise = a, e._contentReadyPromise = a.then(function (c) { if (!!l(c)) return --s.statistics.numberOfPendingRequests, c.readyPromise }).then(function (c) { if (!!l(c)) { if (e.isDestroyed()) { V5(e, s); return } return RHe(e), e._selectedFrame = 0, e.lastStyleTime = 0, $.now(e._loadTimestamp), e._contentState = To.READY, c } }).catch(function (c) { return i.state === ri.CANCELLED ? (e._contentState = r, --s.statistics.numberOfPendingRequests, ++s.statistics.numberOfAttemptedRequests, Promise.reject("Cancelled")) : (V5(e, s), Promise.reject(c)) }), 0 } function V5(e, t) { e._contentState === To.PROCESSING ? --t.statistics.numberOfTilesProcessing : --t.statistics.numberOfPendingRequests, e._contentState = To.FAILED } function NHe(e, t) { let n = wx(t), i = e._tileset; i._disableSkipLevelOfDetail = i._disableSkipLevelOfDetail || n.contentType === ws.GEOMETRY || n.contentType === ws.VECTOR, (n.contentType === ws.IMPLICIT_SUBTREE || n.contentType === ws.IMPLICIT_SUBTREE_JSON) && (e.hasImplicitContent = !0), n.contentType === ws.EXTERNAL_TILESET && (e.hasTilesetContent = !0); let o, r = Ex[n.contentType]; l(n.binaryPayload) ? o = r(i, e, e._contentResource, n.binaryPayload.buffer, 0) : o = r(i, e, e._contentResource, n.jsonPayload); let s = e._contentHeader; if (e.hasImplicitContentMetadata) { let c = e.implicitSubtree, u = e.implicitCoordinates; o.metadata = c.getContentMetadataView(u, 0) } else e.hasImplicitContent || (o.metadata = bx(i, s)); let a = Sx(i, s); return l(a) && (o.group = new kC({ metadata: a })), o } No.prototype.cancelRequests = function () { this.hasMultipleContents ? this._content.cancelRequests() : this._request.cancel() }; No.prototype.unloadContent = function () { this.hasEmptyContent || this.hasTilesetContent || this.hasImplicitContent || (this._content = this._content && this._content.destroy(), this._contentState = To.UNLOADED, this._contentReadyToProcessPromise = void 0, this._contentReadyPromise = void 0, this.lastStyleTime = 0, this.clippingPlanesDirty = this._clippingPlanesState === 0, this._clippingPlanesState = 0, this._debugColorizeTiles = !1, this._debugBoundingVolume = this._debugBoundingVolume && this._debugBoundingVolume.destroy(), this._debugContentBoundingVolume = this._debugContentBoundingVolume && this._debugContentBoundingVolume.destroy(), this._debugViewerRequestVolume = this._debugViewerRequestVolume && this._debugViewerRequestVolume.destroy()) }; var Fie = new re; function U5(e, t) { if (t.mode !== ee.SCENE3D && !l(e._boundingVolume2D)) { let n = e._boundingVolume.boundingSphere, i = re.projectTo2D(n, t.mapProjection, Fie); e._boundingVolume2D = new F_(i.center, i.radius) } return t.mode !== ee.SCENE3D ? e._boundingVolume2D : e._boundingVolume } function VHe(e, t) { if (t.mode !== ee.SCENE3D && !l(e._contentBoundingVolume2D)) { let n = e._contentBoundingVolume.boundingSphere, i = re.projectTo2D(n, t.mapProjection, Fie); e._contentBoundingVolume2D = new F_(i.center, i.radius) } return t.mode !== ee.SCENE3D ? e._contentBoundingVolume2D : e._contentBoundingVolume } No.prototype.visibility = function (e, t) { let n = e.cullingVolume, i = U5(this, e), o = this._tileset, r = o.clippingPlanes; if (l(r) && r.enabled) { let s = r.computeIntersectionWithBoundingVolume(i, o.clippingPlanesOriginMatrix); if (this._isClipped = s !== Kt.INSIDE, s === Kt.OUTSIDE) return Xs.MASK_OUTSIDE } return n.computeVisibilityWithPlaneMask(i, t) }; No.prototype.contentVisibility = function (e) { if (!l(this._contentBoundingVolume)) return Kt.INSIDE; if (this._visibilityPlaneMask === Xs.MASK_INSIDE) return Kt.INSIDE; let t = e.cullingVolume, n = VHe(this, e), i = this._tileset, o = i.clippingPlanes; if (l(o) && o.enabled) { let r = o.computeIntersectionWithBoundingVolume(n, i.clippingPlanesOriginMatrix); if (this._isClipped = r !== Kt.INSIDE, r === Kt.OUTSIDE) return Kt.OUTSIDE } return t.computeVisibility(n) }; No.prototype.distanceToTile = function (e) { return U5(this, e).distanceToCamera(e) }; var kHe = new h; No.prototype.distanceToTileCenter = function (e) { let n = U5(this, e).boundingVolume, i = h.subtract(n.center, e.camera.positionWC, kHe); return h.dot(e.camera.directionWC, i) }; No.prototype.insideViewerRequestVolume = function (e) { let t = this._viewerRequestVolume; return !l(t) || t.distanceToCamera(e) === 0 }; var Nie = new Q, Vie = new h, UHe = new Q, kie = new h, Uie = new ce, zHe = new di, k5 = new F; function HHe(e, t, n) { let i = h.fromElements(e[0], e[1], e[2], kie), o = Q.fromArray(e, 3, UHe); i = F.multiplyByPoint(t, i, i); let r = F.getMatrix3(t, Nie); return o = Q.multiply(r, o, o), l(n) ? (n.update(i, o), n) : new Mf(i, o) } function GHe(e, t, n, i) { let o = ce.unpack(e, 0, Uie), r = e[4], s = e[5], a = di.fromRectangle(o, r, s, ie.WGS84, zHe), c = a.center, u = a.halfAxes; t = F.multiplyTransformation(t, F.inverseTransformation(n, k5), k5), c = F.multiplyByPoint(t, c, c); let f = F.getMatrix3(t, Nie); return u = Q.multiply(f, u, u), l(i) && i instanceof Mf ? (i.update(c, u), i) : new Mf(c, u) } function WHe(e, t, n, i) { if (!F.equalsEpsilon(t, n, I.EPSILON8)) return GHe(e, t, n, i); if (l(i)) return i; let o = ce.unpack(e, 0, Uie); return new Bf({ rectangle: o, minimumHeight: e[4], maximumHeight: e[5] }) } function jHe(e, t, n) { let i = h.fromElements(e[0], e[1], e[2], kie), o = e[3]; i = F.multiplyByPoint(t, i, i); let r = F.getScale(t, Vie); return o *= h.maximumComponent(r), l(n) ? (n.update(i, o), n) : new F_(i, o) } No.prototype.createBoundingVolume = function (e, t, n) { if (!l(e)) throw new fe("boundingVolume must be defined"); if (Mi(e, "3DTILES_bounding_volume_S2")) return new oF(e.extensions["3DTILES_bounding_volume_S2"]); if (l(e.box)) return HHe(e.box, t, n); if (l(e.region)) return WHe(e.region, t, this._initialTransform, n); if (l(e.sphere)) return jHe(e.sphere, t, n); throw new fe("boundingVolume must contain a sphere, region, or box") }; No.prototype.updateTransform = function (e) { e = y(e, F.IDENTITY); let t = F.multiply(e, this.transform, k5); if (!!F.equals(t, this.computedTransform)) return; F.clone(t, this.computedTransform); let i = this._header, o = this._contentHeader; this._boundingVolume = this.createBoundingVolume(i.boundingVolume, this.computedTransform, this._boundingVolume), l(this._contentBoundingVolume) && (this._contentBoundingVolume = this.createBoundingVolume(o.boundingVolume, this.computedTransform, this._contentBoundingVolume)), l(this._viewerRequestVolume) && (this._viewerRequestVolume = this.createBoundingVolume(i.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)), this.updateGeometricErrorScale(), this._debugBoundingVolume = this._debugBoundingVolume && this._debugBoundingVolume.destroy(), this._debugContentBoundingVolume = this._debugContentBoundingVolume && this._debugContentBoundingVolume.destroy(), this._debugViewerRequestVolume = this._debugViewerRequestVolume && this._debugViewerRequestVolume.destroy() }; No.prototype.updateGeometricErrorScale = function () { let e = F.getScale(this.computedTransform, Vie), t = h.maximumComponent(e); this.geometricError = this._geometricError * t }; function qHe(e, t, n, i) { if (!i.isRender) return; let o = l(e._contentHeader) && l(e._contentHeader.boundingVolume), r = e.hasEmptyContent || e.hasTilesetContent || e.hasImplicitContent, s = t.debugShowBoundingVolume || t.debugShowContentBoundingVolume && !o; if (s) { let u; e._finalResolution ? r ? u = U.DARKGRAY : u = U.WHITE : u = U.YELLOW, l(e._debugBoundingVolume) || (e._debugBoundingVolume = e._boundingVolume.createDebugVolume(u)), e._debugBoundingVolume.update(n); let f = e._debugBoundingVolume.getGeometryInstanceAttributes("outline"); f.color = Bt.toValue(u, f.color) } else !s && l(e._debugBoundingVolume) && (e._debugBoundingVolume = e._debugBoundingVolume.destroy()); t.debugShowContentBoundingVolume && o ? (l(e._debugContentBoundingVolume) || (e._debugContentBoundingVolume = e._contentBoundingVolume.createDebugVolume(U.BLUE)), e._debugContentBoundingVolume.update(n)) : !t.debugShowContentBoundingVolume && l(e._debugContentBoundingVolume) && (e._debugContentBoundingVolume = e._debugContentBoundingVolume.destroy()), t.debugShowViewerRequestVolume && l(e._viewerRequestVolume) ? (l(e._debugViewerRequestVolume) || (e._debugViewerRequestVolume = e._viewerRequestVolume.createDebugVolume(U.YELLOW)), e._debugViewerRequestVolume.update(n)) : !t.debugShowViewerRequestVolume && l(e._debugViewerRequestVolume) && (e._debugViewerRequestVolume = e._debugViewerRequestVolume.destroy()); let a = t.debugColorizeTiles && !e._debugColorizeTiles || l(t._heatmap.tilePropertyName), c = !t.debugColorizeTiles && e._debugColorizeTiles; a ? (t._heatmap.colorize(e, n), e._debugColorizeTiles = !0, e.color = e._debugColor) : c && (e._debugColorizeTiles = !1, e.color = U.WHITE), e._colorDirty && (e._colorDirty = !1, e._content.applyDebugSettings(!0, e._color)), c && t.makeStyleDirty() } function YHe(e, t, n) { let i = e._content, o = e._expiredContent; if (!e.hasMultipleContents && l(o)) { if (!e.contentReady) { o.update(t, n); return } e._expiredContent.destroy(), e._expiredContent = void 0 } i.update(t, n) } function XHe(e, t) { let n = t.clippingPlanes, i = 0; l(n) && e._isClipped && n.enabled && (i = n.clippingPlanesState), i !== e._clippingPlanesState && (e._clippingPlanesState = i, e.clippingPlanesDirty = !0) } No.prototype.update = function (e, t, n) { let i = t.commandList.length; XHe(this, e), qHe(this, e, t, n), YHe(this, e, t); let r = t.commandList.length - i; this._commandsLength = r; for (let s = 0; s < r; ++s) { let a = t.commandList[i + s], c = a.pass === xe.TRANSLUCENT; a.depthForTranslucentClassification = c } this.clippingPlanesDirty = !1 }; var Rie = []; No.prototype.process = function (e, t) { let n = t.commandList; t.commandList = Rie, this._content.update(e, t), Rie.length = 0, t.commandList = n }; function Mie(e, t, n) { let i = e * Math.pow(10, t); return parseInt(i) * Math.pow(10, n) } function aF(e, t, n) { return Math.max(I.normalize(e, t, n) - I.EPSILON7, 0) } No.prototype.updatePriority = function () { let e = this.tileset, t = e.preferLeaves, n = e._minimumPriority, i = e._maximumPriority, o = 4, r = 1, s = 0, a = o, c = s + a, u = o, f = c + u, d = r, p = Math.pow(10, f), g = f + d, m = r, A = Math.pow(10, g), C = g + m, x = Math.pow(10, C), T = aF(this._depth, n.depth, i.depth); T = t ? 1 - T : T; let S = !e._skipLevelOfDetail && this.refine === vr.REPLACE ? aF(this._priorityHolder._distanceToCamera, n.distance, i.distance) : aF(this._priorityReverseScreenSpaceError, n.reverseScreenSpaceError, i.reverseScreenSpaceError), D = Mie(S, a, s), P = this._priorityProgressiveResolution ? 0 : p, B = aF(this._priorityHolder._foveatedFactor, n.foveatedFactor, i.foveatedFactor), R = Mie(B, u, c), M = this.priorityDeferred ? A : 0, L = e._pass === Qo.PRELOAD_FLIGHT ? 0 : x; this._priority = T + D + P + R + M + L }; No.prototype.isDestroyed = function () { return !1 }; No.prototype.destroy = function () { return this._content = this._content && this._content.destroy(), this._expiredContent = this._expiredContent && !this._expiredContent.isDestroyed() && this._expiredContent.destroy(), this._debugBoundingVolume = this._debugBoundingVolume && this._debugBoundingVolume.destroy(), this._debugContentBoundingVolume = this._debugContentBoundingVolume && this._debugContentBoundingVolume.destroy(), this._debugViewerRequestVolume = this._debugViewerRequestVolume && this._debugViewerRequestVolume.destroy(), le(this) }; var hw = No; function qm(e) { e = y(e, y.EMPTY_OBJECT); let t = e.id, n = e.group, i = e.class, o = l(n.properties) ? n.properties : {}; this._class = i, this._properties = o, this._id = t, this._extras = n.extras, this._extensions = n.extensions } Object.defineProperties(qm.prototype, { class: { get: function () { return this._class } }, id: { get: function () { return this._id } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); qm.prototype.hasProperty = function (e) { return Rn.hasProperty(e, this._properties, this._class) }; qm.prototype.hasPropertyBySemantic = function (e) { return Rn.hasPropertyBySemantic(e, this._properties, this._class) }; qm.prototype.getPropertyIds = function (e) { return Rn.getPropertyIds(this._properties, this._class, e) }; qm.prototype.getProperty = function (e) { return Rn.getProperty(e, this._properties, this._class) }; qm.prototype.setProperty = function (e, t) { return Rn.setProperty(e, t, this._properties, this._class) }; qm.prototype.getPropertyBySemantic = function (e) { return Rn.getPropertyBySemantic(e, this._properties, this._class) }; qm.prototype.setPropertyBySemantic = function (e, t) { return Rn.setPropertyBySemantic(e, t, this._properties, this._class) }; var mw = qm; function Ym(e) { e = y(e, y.EMPTY_OBJECT); let t = e.tileset, n = e.class, i = l(t.properties) ? t.properties : {}; this._class = n, this._properties = i, this._extras = t.extras, this._extensions = t.extensions } Object.defineProperties(Ym.prototype, { class: { get: function () { return this._class } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); Ym.prototype.hasProperty = function (e) { return Rn.hasProperty(e, this._properties, this._class) }; Ym.prototype.hasPropertyBySemantic = function (e) { return Rn.hasPropertyBySemantic(e, this._properties, this._class) }; Ym.prototype.getPropertyIds = function (e) { return Rn.getPropertyIds(this._properties, this._class, e) }; Ym.prototype.getProperty = function (e) { return Rn.getProperty(e, this._properties, this._class) }; Ym.prototype.setProperty = function (e, t) { return Rn.setProperty(e, t, this._properties, this._class) }; Ym.prototype.getPropertyBySemantic = function (e) { return Rn.getPropertyBySemantic(e, this._properties, this._class) }; Ym.prototype.setPropertyBySemantic = function (e, t) { return Rn.setPropertyBySemantic(e, t, this._properties, this._class) }; var cF = Ym; function zie(e) { e = y(e, y.EMPTY_OBJECT); let t = e.metadataJson, n = e.schema, i = y(t.metadata, t.tileset), o; l(i) && (o = new cF({ tileset: i, class: n.classes[i.class] })); let r = [], s = [], a = t.groups; if (Array.isArray(a)) { let c = a.length; for (let u = 0; u < c; u++) { let f = a[u]; s.push(new mw({ group: f, class: n.classes[f.class] })) } } else if (l(a)) { r = Object.keys(a).sort(); let c = r.length; for (let u = 0; u < c; u++) { let f = r[u]; if (a.hasOwnProperty(f)) { let d = a[f]; s.push(new mw({ id: f, group: a[f], class: n.classes[d.class] })) } } } this._schema = n, this._groups = s, this._groupIds = r, this._tileset = o, this._statistics = t.statistics, this._extras = t.extras, this._extensions = t.extensions } Object.defineProperties(zie.prototype, { schema: { get: function () { return this._schema } }, groups: { get: function () { return this._groups } }, groupIds: { get: function () { return this._groupIds } }, tileset: { get: function () { return this._tileset } }, statistics: { get: function () { return this._statistics } }, extras: { get: function () { return this._extras } }, extensions: { get: function () { return this._extensions } } }); var lF = zie; var Hie = {}, KHe = new h; Hie.checkChildrenWithinParent = function (e) { let t = e.children, n = t.length, i = e.boundingVolume; if (i instanceof Mf || i instanceof Bf) { let o = i._orientedBoundingBox; e._optimChildrenWithinParent = Pf.USE_OPTIMIZATION; for (let r = 0; r < n; ++r) { let a = t[r].boundingVolume; if (!(a instanceof Mf || a instanceof Bf)) { e._optimChildrenWithinParent = Pf.SKIP_OPTIMIZATION; break } let c = a._orientedBoundingBox, u = h.subtract(c.center, o.center, KHe), f = h.magnitude(u); h.divideByScalar(u, f, u); let d = Math.abs(o.halfAxes[0] * u.x) + Math.abs(o.halfAxes[1] * u.y) + Math.abs(o.halfAxes[2] * u.z) + Math.abs(o.halfAxes[3] * u.x) + Math.abs(o.halfAxes[4] * u.y) + Math.abs(o.halfAxes[5] * u.z) + Math.abs(o.halfAxes[6] * u.x) + Math.abs(o.halfAxes[7] * u.y) + Math.abs(o.halfAxes[8] * u.z), p = Math.abs(c.halfAxes[0] * u.x) + Math.abs(c.halfAxes[1] * u.y) + Math.abs(c.halfAxes[2] * u.z) + Math.abs(c.halfAxes[3] * u.x) + Math.abs(c.halfAxes[4] * u.y) + Math.abs(c.halfAxes[5] * u.z) + Math.abs(c.halfAxes[6] * u.x) + Math.abs(c.halfAxes[7] * u.y) + Math.abs(c.halfAxes[8] * u.z); if (d <= p + f) { e._optimChildrenWithinParent = Pf.SKIP_OPTIMIZATION; break } } } return e._optimChildrenWithinParent === Pf.USE_OPTIMIZATION }; var uF = Hie; function pw() { this.head = void 0, this.tail = void 0, this._length = 0 } Object.defineProperties(pw.prototype, { length: { get: function () { return this._length } } }); function JHe(e, t, n) { this.item = e, this.previous = t, this.next = n } pw.prototype.add = function (e) { let t = new JHe(e, this.tail, void 0); return l(this.tail) ? (this.tail.next = t, this.tail = t) : (this.head = t, this.tail = t), ++this._length, t }; function Gie(e, t) { l(t.previous) && l(t.next) ? (t.previous.next = t.next, t.next.previous = t.previous) : l(t.previous) ? (t.previous.next = void 0, e.tail = t.previous) : l(t.next) ? (t.next.previous = void 0, e.head = t.next) : (e.head = void 0, e.tail = void 0), t.next = void 0, t.previous = void 0 } pw.prototype.remove = function (e) { !l(e) || (Gie(this, e), --this._length) }; pw.prototype.splice = function (e, t) { if (e === t) return; Gie(this, t); let n = e.next; e.next = t, this.tail === e ? this.tail = t : n.previous = t, t.next = n, t.previous = e }; var fF = pw; function hy() { this._list = new fF, this._sentinel = this._list.add(), this._trimTiles = !1 } hy.prototype.reset = function () { this._list.splice(this._list.tail, this._sentinel) }; hy.prototype.touch = function (e) { let t = e.cacheNode; l(t) && this._list.splice(this._sentinel, t) }; hy.prototype.add = function (e) { l(e.cacheNode) || (e.cacheNode = this._list.add(e)) }; hy.prototype.unloadTile = function (e, t, n) { let i = t.cacheNode; !l(i) || (this._list.remove(i), t.cacheNode = void 0, n(e, t)) }; hy.prototype.unloadTiles = function (e, t) { let n = this._trimTiles; this._trimTiles = !1; let i = this._list, o = e.maximumMemoryUsage * 1024 * 1024, r = this._sentinel, s = i.head; for (; s !== r && (e.totalMemoryUsageInBytes > o || n);) { let a = s.item; s = s.next, this.unloadTile(e, a, t) } }; hy.prototype.trim = function () { this._trimTiles = !0 }; var dF = hy; function hF(e) { this.tilePropertyName = e, this._minimum = Number.MAX_VALUE, this._maximum = -Number.MAX_VALUE, this._previousMinimum = Number.MAX_VALUE, this._previousMaximum = -Number.MAX_VALUE, this._referenceMinimum = {}, this._referenceMaximum = {} } function H5(e, t) { let n; return t === "_loadTimestamp" ? n = $.toDate(e).getTime() : n = e, n } hF.prototype.setReferenceMinimumMaximum = function (e, t, n) { this._referenceMinimum[n] = H5(e, n), this._referenceMaximum[n] = H5(t, n) }; function ZHe(e, t) { let n = e.tilePropertyName; if (l(n)) { let i = H5(t[n], n); return l(i) ? (e._maximum = Math.max(i, e._maximum), e._minimum = Math.min(i, e._minimum), i) : (e.tilePropertyName = void 0, i) } } var z5 = [new U(.1, .1, .1, 1), new U(.153, .278, .878, 1), new U(.827, .231, .49, 1), new U(.827, .188, .22, 1), new U(1, .592, .259, 1), new U(1, .843, 0, 1)]; hF.prototype.colorize = function (e, t) { let n = this.tilePropertyName; if (!l(n) || !e.contentAvailable || e._selectedFrame !== t.frameNumber) return; let i = ZHe(this, e), o = this._previousMinimum, r = this._previousMaximum; if (o === Number.MAX_VALUE || r === -Number.MAX_VALUE) return; let s = r - o + I.EPSILON7, c = I.clamp(i - o, 0, s) / s, u = z5.length - 1, f = c * u, d = Math.floor(f), p = Math.ceil(f), g = f - d, m = z5[d], A = z5[p], C = U.clone(U.WHITE); C.red = I.lerp(m.red, A.red, g), C.green = I.lerp(m.green, A.green, g), C.blue = I.lerp(m.blue, A.blue, g), e._debugColor = C }; hF.prototype.resetMinimumMaximum = function () { let e = this.tilePropertyName; if (l(e)) { let t = this._referenceMinimum[e], n = this._referenceMaximum[e], i = l(t) && l(n); this._previousMinimum = i ? t : this._minimum, this._previousMaximum = i ? n : this._maximum, this._minimum = Number.MAX_VALUE, this._maximum = -Number.MAX_VALUE } }; var mF = hF; function kx() { this.selected = 0, this.visited = 0, this.numberOfCommands = 0, this.numberOfAttemptedRequests = 0, this.numberOfPendingRequests = 0, this.numberOfTilesProcessing = 0, this.numberOfTilesWithContentReady = 0, this.numberOfTilesTotal = 0, this.numberOfLoadedTilesTotal = 0, this.numberOfFeaturesSelected = 0, this.numberOfFeaturesLoaded = 0, this.numberOfPointsSelected = 0, this.numberOfPointsLoaded = 0, this.numberOfTrianglesSelected = 0, this.numberOfTilesStyled = 0, this.numberOfFeaturesStyled = 0, this.numberOfTilesCulledWithChildrenUnion = 0, this.geometryByteLength = 0, this.texturesByteLength = 0, this.batchTableByteLength = 0 } kx.prototype.clear = function () { this.selected = 0, this.visited = 0, this.numberOfCommands = 0, this.numberOfAttemptedRequests = 0, this.numberOfFeaturesSelected = 0, this.numberOfPointsSelected = 0, this.numberOfTrianglesSelected = 0, this.numberOfTilesStyled = 0, this.numberOfFeaturesStyled = 0, this.numberOfTilesCulledWithChildrenUnion = 0 }; function pF(e, t, n, i) { let o = t.innerContents, r = t.pointsLength, s = t.trianglesLength, a = t.featuresLength, c = t.geometryByteLength, u = t.texturesByteLength, f = t.batchTableByteLength; if (i ? (e.numberOfFeaturesLoaded += n ? -a : a, e.numberOfPointsLoaded += n ? -r : r, e.geometryByteLength += n ? -c : c, e.texturesByteLength += n ? -u : u, e.batchTableByteLength += n ? -f : f) : (e.numberOfFeaturesSelected += n ? -a : a, e.numberOfPointsSelected += n ? -r : r, e.numberOfTrianglesSelected += n ? -s : s), l(o)) { let d = o.length; for (let p = 0; p < d; ++p)pF(e, o[p], n, i) } } kx.prototype.incrementSelectionCounts = function (e) { pF(this, e, !1, !1) }; kx.prototype.incrementLoadCounts = function (e) { pF(this, e, !1, !0) }; kx.prototype.decrementLoadCounts = function (e) { pF(this, e, !0, !0) }; kx.clone = function (e, t) { t.selected = e.selected, t.visited = e.visited, t.numberOfCommands = e.numberOfCommands, t.selected = e.selected, t.numberOfAttemptedRequests = e.numberOfAttemptedRequests, t.numberOfPendingRequests = e.numberOfPendingRequests, t.numberOfTilesProcessing = e.numberOfTilesProcessing, t.numberOfTilesWithContentReady = e.numberOfTilesWithContentReady, t.numberOfTilesTotal = e.numberOfTilesTotal, t.numberOfFeaturesSelected = e.numberOfFeaturesSelected, t.numberOfFeaturesLoaded = e.numberOfFeaturesLoaded, t.numberOfPointsSelected = e.numberOfPointsSelected, t.numberOfPointsLoaded = e.numberOfPointsLoaded, t.numberOfTrianglesSelected = e.numberOfTrianglesSelected, t.numberOfTilesStyled = e.numberOfTilesStyled, t.numberOfFeaturesStyled = e.numberOfFeaturesStyled, t.numberOfTilesCulledWithChildrenUnion = e.numberOfTilesCulledWithChildrenUnion, t.geometryByteLength = e.geometryByteLength, t.texturesByteLength = e.texturesByteLength, t.batchTableByteLength = e.batchTableByteLength }; var V_ = kx; function _w() { this._style = void 0, this._styleDirty = !1, this._lastStyleTime = 0 } Object.defineProperties(_w.prototype, { style: { get: function () { return this._style }, set: function (e) { e !== this._style && (this._style = e, this._styleDirty = !0) } } }); _w.prototype.makeDirty = function () { this._styleDirty = !0 }; _w.prototype.resetDirty = function () { this._styleDirty = !1 }; _w.prototype.applyStyle = function (e) { if (!e.ready || l(this._style) && !this._style._ready) return; let t = this._styleDirty; t && ++this._lastStyleTime; let n = this._lastStyleTime, i = e._statistics, o = t ? e._selectedTiles : e._selectedTilesToStyle, r = o.length; for (let s = 0; s < r; ++s) { let a = o[s]; if (a.lastStyleTime !== n) { let c = a.content; a.lastStyleTime = n, c.applyStyle(this._style), i.numberOfFeaturesStyled += c.featuresLength, ++i.numberOfTilesStyled } } }; var _F = _w; function QHe(e, t, n) { let i = Mi(t, "3DTILES_implicit_tiling") ? t.extensions["3DTILES_implicit_tiling"] : t.implicitTiling; this.baseResource = e, this.geometricError = t.geometricError, this.metadataSchema = n; let o = t.boundingVolume; if (!l(o.box) && !l(o.region) && !Mi(o, "3DTILES_bounding_volume_S2")) throw new fe("Only box, region and 3DTILES_bounding_volume_S2 are supported for implicit tiling"); this.boundingVolume = o, this.refine = t.refine, this.subtreeUriTemplate = new Pe({ url: i.subtrees.uri }), this.contentUriTemplates = [], this.contentHeaders = []; let r = $He(t); for (let s = 0; s < r.length; s++) { let a = r[s]; this.contentHeaders.push(tt(a, !0)); let c = new Pe({ url: a.uri }); this.contentUriTemplates.push(c) } this.contentCount = this.contentHeaders.length, this.tileHeader = eGe(t), this.subdivisionScheme = kr[i.subdivisionScheme], this.branchingFactor = kr.getBranchingFactor(this.subdivisionScheme), this.subtreeLevels = i.subtreeLevels, l(i.availableLevels) ? this.availableLevels = i.availableLevels : this.availableLevels = i.maximumLevel + 1 } function $He(e) { if (Mi(e, "3DTILES_multiple_contents")) { let t = e.extensions["3DTILES_multiple_contents"]; return l(t.contents) ? t.contents : t.content } return l(e.contents) ? e.contents : l(e.content) ? [e.content] : [] } function eGe(e) { let t = tt(e, !0); return l(t.extensions) && (delete t.extensions["3DTILES_implicit_tiling"], delete t.extensions["3DTILES_multiple_contents"], Object.keys(t.extensions).length === 0 && delete t.extensions), delete t.implicitTiling, delete t.contents, delete t.content, t } var gF = QHe; var gw = {}; function Wie(e) { return e = (e ^ e << 8) & 16711935, e = (e ^ e << 4) & 252645135, e = (e ^ e << 2) & 858993459, e = (e ^ e << 1) & 1431655765, e } function G5(e) { return e = (e ^ e << 16) & 50331903, e = (e ^ e << 8) & 50393103, e = (e ^ e << 4) & 51130563, e = (e ^ e << 2) & 153391689, e } function jie(e) { return e &= 1431655765, e = (e ^ e >> 1) & 858993459, e = (e ^ e >> 2) & 252645135, e = (e ^ e >> 4) & 16711935, e = (e ^ e >> 8) & 65535, e } function W5(e) { return e &= 153391689, e = (e ^ e >> 2) & 51130563, e = (e ^ e >> 4) & 50393103, e = (e ^ e >> 8) & 4278190335, e = (e ^ e >> 16) & 1023, e } gw.encode2D = function (e, t) { return (Wie(e) | Wie(t) << 1) >>> 0 }; gw.decode2D = function (e, t) { return l(t) || (t = new Array(2)), t[0] = jie(e), t[1] = jie(e >> 1), t }; gw.encode3D = function (e, t, n) { return G5(e) | G5(t) << 1 | G5(n) << 2 }; gw.decode3D = function (e, t) { return l(t) || (t = new Array(3)), t[0] = W5(e), t[1] = W5(e >> 1), t[2] = W5(e >> 2), t }; var my = gw; function Io(e) { this.subdivisionScheme = e.subdivisionScheme, this.subtreeLevels = e.subtreeLevels, this.level = e.level, this.x = e.x, this.y = e.y, this.z = void 0, e.subdivisionScheme === kr.OCTREE && (this.z = e.z) } Object.defineProperties(Io.prototype, { childIndex: { get: function () { let e = 0; return e |= this.x & 1, e |= (this.y & 1) << 1, this.subdivisionScheme === kr.OCTREE && (e |= (this.z & 1) << 2), e } }, mortonIndex: { get: function () { return this.subdivisionScheme === kr.OCTREE ? my.encode3D(this.x, this.y, this.z) : my.encode2D(this.x, this.y) } }, tileIndex: { get: function () { let e = this.subdivisionScheme === kr.OCTREE ? ((1 << 3 * this.level) - 1) / 7 : ((1 << 2 * this.level) - 1) / 3, t = this.mortonIndex; return e + t } } }); Io.prototype.getDescendantCoordinates = function (e) { let t = this.level + e.level, n = (this.x << e.level) + e.x, i = (this.y << e.level) + e.y; if (this.subdivisionScheme === kr.OCTREE) { let o = (this.z << e.level) + e.z; return new Io({ subdivisionScheme: this.subdivisionScheme, subtreeLevels: this.subtreeLevels, level: t, x: n, y: i, z: o }) } return new Io({ subdivisionScheme: this.subdivisionScheme, subtreeLevels: this.subtreeLevels, level: t, x: n, y: i }) }; Io.prototype.getAncestorCoordinates = function (e) { let t = 1 << e, n = this.level - e, i = Math.floor(this.x / t), o = Math.floor(this.y / t); if (this.subdivisionScheme === kr.OCTREE) { let r = Math.floor(this.z / t); return new Io({ subdivisionScheme: this.subdivisionScheme, subtreeLevels: this.subtreeLevels, level: n, x: i, y: o, z: r }) } return new Io({ subdivisionScheme: this.subdivisionScheme, subtreeLevels: this.subtreeLevels, level: n, x: i, y: o }) }; Io.prototype.getOffsetCoordinates = function (e) { let t = e.level - this.level, n = 1 << t, i = e.x % n, o = e.y % n; if (this.subdivisionScheme === kr.OCTREE) { let r = e.z % n; return new Io({ subdivisionScheme: this.subdivisionScheme, subtreeLevels: this.subtreeLevels, level: t, x: i, y: o, z: r }) } return new Io({ subdivisionScheme: this.subdivisionScheme, subtreeLevels: this.subtreeLevels, level: t, x: i, y: o }) }; Io.prototype.getChildCoordinates = function (e) { let t = this.level + 1, n = 2 * this.x + e % 2, i = 2 * this.y + Math.floor(e / 2) % 2; if (this.subdivisionScheme === kr.OCTREE) { let o = 2 * this.z + Math.floor(e / 4) % 2; return new Io({ subdivisionScheme: this.subdivisionScheme, subtreeLevels: this.subtreeLevels, level: t, x: n, y: i, z: o }) } return new Io({ subdivisionScheme: this.subdivisionScheme, subtreeLevels: this.subtreeLevels, level: t, x: n, y: i }) }; Io.prototype.getSubtreeCoordinates = function () { return this.getAncestorCoordinates(this.level % this.subtreeLevels) }; Io.prototype.getParentSubtreeCoordinates = function () { return this.getAncestorCoordinates(this.level % this.subtreeLevels + this.subtreeLevels) }; Io.prototype.isAncestor = function (e) { let t = e.level - this.level; if (t <= 0) return !1; let n = e.x >> t, i = e.y >> t, o = this.x === n, r = this.y === i; if (this.subdivisionScheme === kr.OCTREE) { let s = e.z >> t, a = this.z === s; return o && r && a } return o && r }; Io.prototype.isEqual = function (e) { return this.subdivisionScheme === e.subdivisionScheme && this.subtreeLevels === e.subtreeLevels && this.level === e.level && this.x === e.x && this.y === e.y && (this.subdivisionScheme === kr.OCTREE ? this.z === e.z : !0) }; Io.prototype.isImplicitTilesetRoot = function () { return this.level === 0 }; Io.prototype.isSubtreeRoot = function () { return this.level % this.subtreeLevels === 0 }; Io.prototype.isBottomOfSubtree = function () { return this.level % this.subtreeLevels === this.subtreeLevels - 1 }; Io.prototype.getTemplateValues = function () { let e = { level: this.level, x: this.x, y: this.y }; return this.subdivisionScheme === kr.OCTREE && (e.z = this.z), e }; var qie = [0, 0, 0]; Io.fromMortonIndex = function (e, t, n, i) { let o; return e === kr.OCTREE ? (o = my.decode3D(i, qie), new Io({ subdivisionScheme: e, subtreeLevels: t, level: n, x: o[0], y: o[1], z: o[2] })) : (o = my.decode2D(i, qie), new Io({ subdivisionScheme: e, subtreeLevels: t, level: n, x: o[0], y: o[1] })) }; Io.fromTileIndex = function (e, t, n) { let i, o, r; return e === kr.OCTREE ? (i = Math.floor(I.log2(7 * n + 1) / 3), o = ((1 << 3 * i) - 1) / 7, r = n - o) : (i = Math.floor(I.log2(3 * n + 1) / 2), o = ((1 << 2 * i) - 1) / 3, r = n - o), Io.fromMortonIndex(e, t, i, r) }; var yF = Io; function Ds(e) { e = y(e, y.EMPTY_OBJECT), this._url = void 0, this._basePath = void 0, this._root = void 0, this._resource = void 0, this._asset = void 0, this._properties = void 0, this._geometricError = void 0, this._extensionsUsed = void 0, this._extensions = void 0, this._modelUpAxis = void 0, this._modelForwardAxis = void 0, this._cache = new dF, this._processingQueue = [], this._selectedTiles = [], this._emptyTiles = [], this._requestedTiles = [], this._selectedTilesToStyle = [], this._loadTimestamp = void 0, this._timeSinceLoad = 0, this._updatedVisibilityFrame = 0, this._updatedModelMatrixFrame = 0, this._modelMatrixChanged = !1, this._previousModelMatrix = void 0, this._extras = void 0, this._credits = void 0, this._showCreditsOnScreen = y(e.showCreditsOnScreen, !1), this._cullWithChildrenBounds = y(e.cullWithChildrenBounds, !0), this._allTilesAdditive = !0, this._hasMixedContent = !1, this._stencilClearCommand = void 0, this._backfaceCommands = new su, this._maximumScreenSpaceError = y(e.maximumScreenSpaceError, 16), this._maximumMemoryUsage = y(e.maximumMemoryUsage, 512), this._styleEngine = new _F, this._styleApplied = !1, this._modelMatrix = l(e.modelMatrix) ? F.clone(e.modelMatrix) : F.clone(F.IDENTITY), this._statistics = new V_, this._statisticsLast = new V_, this._statisticsPerPass = new Array(Qo.NUMBER_OF_PASSES); for (let r = 0; r < Qo.NUMBER_OF_PASSES; ++r)this._statisticsPerPass[r] = new V_; this._requestedTilesInFlight = [], this._maximumPriority = { foveatedFactor: -Number.MAX_VALUE, depth: -Number.MAX_VALUE, distance: -Number.MAX_VALUE, reverseScreenSpaceError: -Number.MAX_VALUE }, this._minimumPriority = { foveatedFactor: Number.MAX_VALUE, depth: Number.MAX_VALUE, distance: Number.MAX_VALUE, reverseScreenSpaceError: Number.MAX_VALUE }, this._heatmap = new mF(e.debugHeatmapTilePropertyName), this.cullRequestsWhileMoving = y(e.cullRequestsWhileMoving, !0), this._cullRequestsWhileMoving = !1, this.cullRequestsWhileMovingMultiplier = y(e.cullRequestsWhileMovingMultiplier, 60), this.progressiveResolutionHeightFraction = I.clamp(y(e.progressiveResolutionHeightFraction, .3), 0, .5), this.preferLeaves = y(e.preferLeaves, !1), this._tilesLoaded = !1, this._initialTilesLoaded = !1, this._tileDebugLabels = void 0, this._classificationType = e.classificationType, this._ellipsoid = y(e.ellipsoid, ie.WGS84), this._initialClippingPlanesOriginMatrix = F.IDENTITY, this._clippingPlanesOriginMatrix = void 0, this._clippingPlanesOriginMatrixDirty = !0, this._vectorClassificationOnly = y(e.vectorClassificationOnly, !1), this._vectorKeepDecodedPositions = y(e.vectorKeepDecodedPositions, !1), this.preloadWhenHidden = y(e.preloadWhenHidden, !1), this.preloadFlightDestinations = y(e.preloadFlightDestinations, !0), this._pass = void 0, this.dynamicScreenSpaceError = y(e.dynamicScreenSpaceError, !1), this.foveatedScreenSpaceError = y(e.foveatedScreenSpaceError, !0), this._foveatedConeSize = y(e.foveatedConeSize, .1), this._foveatedMinimumScreenSpaceErrorRelaxation = y(e.foveatedMinimumScreenSpaceErrorRelaxation, 0), this.foveatedInterpolationCallback = y(e.foveatedInterpolationCallback, I.lerp), this.foveatedTimeDelay = y(e.foveatedTimeDelay, .2), this.dynamicScreenSpaceErrorDensity = .00278, this.dynamicScreenSpaceErrorFactor = 4, this.dynamicScreenSpaceErrorHeightFalloff = .25, this._dynamicScreenSpaceErrorComputedDensity = 0, this.shadows = y(e.shadows, hn.ENABLED), this.show = y(e.show, !0), this.colorBlendMode = _l.HIGHLIGHT, this.colorBlendAmount = .5, this._pointCloudShading = new bm(e.pointCloudShading), this._pointCloudEyeDomeLighting = new m_, this.loadProgress = new _e, this.allTilesLoaded = new _e, this.initialTilesLoaded = new _e, this.tileLoad = new _e, this.tileUnload = new _e, this.tileFailed = new _e, this.tileVisible = new _e, this.skipLevelOfDetail = y(e.skipLevelOfDetail, !1), this._skipLevelOfDetail = this.skipLevelOfDetail, this._disableSkipLevelOfDetail = !1, this.baseScreenSpaceError = y(e.baseScreenSpaceError, 1024), this.skipScreenSpaceErrorFactor = y(e.skipScreenSpaceErrorFactor, 16), this.skipLevels = y(e.skipLevels, 1), this.immediatelyLoadDesiredLevelOfDetail = y(e.immediatelyLoadDesiredLevelOfDetail, !1), this.loadSiblings = y(e.loadSiblings, !1), this._clippingPlanes = void 0, this.clippingPlanes = e.clippingPlanes, l(e.imageBasedLighting) ? (this._imageBasedLighting = e.imageBasedLighting, this._shouldDestroyImageBasedLighting = !1) : (this._imageBasedLighting = new VC, this._shouldDestroyImageBasedLighting = !0), this.lightColor = e.lightColor, this.backFaceCulling = y(e.backFaceCulling, !0), this._enableShowOutline = y(e.enableShowOutline, !0), this.showOutline = y(e.showOutline, !0), this.outlineColor = y(e.outlineColor, U.BLACK), this.splitDirection = y(e.splitDirection, zc.NONE), this._projectTo2D = y(e.projectTo2D, !1), this.debugFreezeFrame = y(e.debugFreezeFrame, !1), this.debugColorizeTiles = y(e.debugColorizeTiles, !1), this._enableDebugWireframe = y(e.enableDebugWireframe, !1), this.debugWireframe = y(e.debugWireframe, !1), this.debugWireframe === !0 && this._enableDebugWireframe === !1 && Pt("tileset-debug-wireframe-ignored", "enableDebugWireframe must be set to true in the Cesium3DTileset constructor, otherwise debugWireframe will be ignored."), this.debugShowBoundingVolume = y(e.debugShowBoundingVolume, !1), this.debugShowContentBoundingVolume = y(e.debugShowContentBoundingVolume, !1), this.debugShowViewerRequestVolume = y(e.debugShowViewerRequestVolume, !1), this._tileDebugLabels = void 0, this.debugPickedTileLabelOnly = !1, this.debugPickedTile = void 0, this.debugPickPosition = void 0, this.debugShowGeometricError = y(e.debugShowGeometricError, !1), this.debugShowRenderingStatistics = y(e.debugShowRenderingStatistics, !1), this.debugShowMemoryUsage = y(e.debugShowMemoryUsage, !1), this.debugShowUrl = y(e.debugShowUrl, !1), this.examineVectorLinesFunction = void 0, this._metadataExtension = void 0, this._customShader = e.customShader; let t = y(e.featureIdLabel, "featureId_0"); typeof t == "number" && (t = `featureId_${t}`), this._featureIdLabel = t; let n = y(e.instanceFeatureIdLabel, "instanceFeatureId_0"); typeof n == "number" && (n = `instanceFeatureId_${n}`), this._instanceFeatureIdLabel = n, this._schemaLoader = void 0; let i = this, o; this._readyPromise = Promise.resolve(e.url).then(function (r) { let s; return o = Pe.createIfNeeded(r), i._resource = o, i._credits = o.credits, o.extension === "json" ? s = o.getBaseUri(!0) : o.isDataUri && (s = ""), i._url = o.url, i._basePath = s, Ds.loadJson(o) }).then(function (r) { if (!i.isDestroyed()) return tGe(i, r) }).then(function (r) { if (i.isDestroyed()) return; i._root = i.loadTileset(o, r); let s = l(r.asset.gltfUpAxis) ? Do.fromName(r.asset.gltfUpAxis) : Do.Y, a = y(e.modelUpAxis, s), c = y(e.modelForwardAxis, Do.X), u = r.asset; i._asset = u, i._properties = r.properties, i._geometricError = r.geometricError, i._extensionsUsed = r.extensionsUsed, i._extensions = r.extensions, i._modelUpAxis = a, i._modelForwardAxis = c, i._extras = r.extras; let f = u.extras; if (l(f) && l(f.cesium) && l(f.cesium.credits)) { let m = f.cesium.credits, A = i._credits; l(A) || (A = [], i._credits = A); for (let C = 0; C < m.length; ++C) { let x = m[C]; A.push(new Xt(x.html, i._showCreditsOnScreen)) } } let p = i._root.createBoundingVolume(r.root.boundingVolume, F.IDENTITY).boundingSphere.center, g = i._ellipsoid.cartesianToCartographic(p); return l(g) && g.height > oi._defaultMinTerrainHeight && (i._initialClippingPlanesOriginMatrix = It.eastNorthUpToFixedFrame(p)), i._clippingPlanesOriginMatrix = F.clone(i._initialClippingPlanesOriginMatrix), i }) } Object.defineProperties(Ds.prototype, { isCesium3DTileset: { get: function () { return !0 } }, asset: { get: function () { return this._asset } }, extensions: { get: function () { return this._extensions } }, clippingPlanes: { get: function () { return this._clippingPlanes }, set: function (e) { Ks.setOwner(e, this, "_clippingPlanes") } }, properties: { get: function () { return this._properties } }, ready: { get: function () { return l(this._root) } }, readyPromise: { get: function () { return this._readyPromise } }, tilesLoaded: { get: function () { return this._tilesLoaded } }, resource: { get: function () { return this._resource } }, basePath: { get: function () { return Jr("Cesium3DTileset.basePath", "Cesium3DTileset.basePath has been deprecated. All tiles are relative to the url of the tileset JSON file that contains them. Use the url property instead."), this._basePath } }, style: { get: function () { return this._styleEngine.style }, set: function (e) { this._styleEngine.style = e } }, customShader: { get: function () { return this._customShader }, set: function (e) { this._customShader = e } }, metadataExtension: { get: function () { return this._metadataExtension } }, metadata: { get: function () { if (l(this._metadataExtension)) return this._metadataExtension.tileset } }, schema: { get: function () { if (l(this._metadataExtension)) return this._metadataExtension.schema } }, maximumScreenSpaceError: { get: function () { return this._maximumScreenSpaceError }, set: function (e) { this._maximumScreenSpaceError = e } }, maximumMemoryUsage: { get: function () { return this._maximumMemoryUsage }, set: function (e) { this._maximumMemoryUsage = e } }, pointCloudShading: { get: function () { return this._pointCloudShading }, set: function (e) { this._pointCloudShading = e } }, root: { get: function () { return this._root } }, boundingSphere: { get: function () { return this._root.updateTransform(this._modelMatrix), this._root.boundingSphere } }, modelMatrix: { get: function () { return this._modelMatrix }, set: function (e) { this._modelMatrix = F.clone(e, this._modelMatrix) } }, timeSinceLoad: { get: function () { return this._timeSinceLoad } }, totalMemoryUsageInBytes: { get: function () { let e = this._statistics; return e.texturesByteLength + e.geometryByteLength + e.batchTableByteLength } }, clippingPlanesOriginMatrix: { get: function () { return l(this._clippingPlanesOriginMatrix) ? (this._clippingPlanesOriginMatrixDirty && (F.multiply(this.root.computedTransform, this._initialClippingPlanesOriginMatrix, this._clippingPlanesOriginMatrix), this._clippingPlanesOriginMatrixDirty = !1), this._clippingPlanesOriginMatrix) : F.IDENTITY } }, styleEngine: { get: function () { return this._styleEngine } }, statistics: { get: function () { return this._statistics } }, classificationType: { get: function () { return this._classificationType } }, ellipsoid: { get: function () { return this._ellipsoid } }, foveatedConeSize: { get: function () { return this._foveatedConeSize }, set: function (e) { this._foveatedConeSize = e } }, foveatedMinimumScreenSpaceErrorRelaxation: { get: function () { return this._foveatedMinimumScreenSpaceErrorRelaxation }, set: function (e) { this._foveatedMinimumScreenSpaceErrorRelaxation = e } }, extras: { get: function () { return this._extras } }, imageBasedLighting: { get: function () { return this._imageBasedLighting }, set: function (e) { e !== this._imageBasedLighting && (this._shouldDestroyImageBasedLighting && !this._imageBasedLighting.isDestroyed() && this._imageBasedLighting.destroy(), this._imageBasedLighting = e, this._shouldDestroyImageBasedLighting = !1) } }, vectorClassificationOnly: { get: function () { return this._vectorClassificationOnly } }, vectorKeepDecodedPositions: { get: function () { return this._vectorKeepDecodedPositions } }, showCreditsOnScreen: { get: function () { return this._showCreditsOnScreen }, set: function (e) { this._showCreditsOnScreen = e } }, featureIdLabel: { get: function () { return this._featureIdLabel }, set: function (e) { typeof e == "number" && (e = `featureId_${e}`), this._featureIdLabel = e } }, instanceFeatureIdLabel: { get: function () { return this._instanceFeatureIdLabel }, set: function (e) { typeof e == "number" && (e = `instanceFeatureId_${e}`), this._instanceFeatureIdLabel = e } } }); Ds.loadJson = function (e) { return Pe.createIfNeeded(e).fetchJson() }; Ds.prototype.makeStyleDirty = function () { this._styleEngine.makeDirty() }; Ds.prototype.loadTileset = function (e, t, n) { let i = t.asset; if (!l(i)) throw new fe("Tileset must have an asset property."); if (i.version !== "0.0" && i.version !== "1.0" && i.version !== "1.1") throw new fe("The tileset must be 3D Tiles version 0.0, 1.0, or 1.1"); l(t.extensionsRequired) && Ds.checkSupportedExtensions(t.extensionsRequired); let o = this._statistics, r = i.tilesetVersion; l(r) && (this._basePath += `?v=${r}`, e = e.clone(), e.setQueryParameters({ v: r })); let s = Yie(this, e, t.root, n); l(n) && (n.children.push(s), s._depth = n._depth + 1); let a = []; for (a.push(s); a.length > 0;) { let c = a.pop(); ++o.numberOfTilesTotal, this._allTilesAdditive = this._allTilesAdditive && c.refine === vr.ADD; let u = c._header.children; if (l(u)) { let f = u.length; for (let d = 0; d < f; ++d) { let p = u[d], g = Yie(this, e, p, c); c.children.push(g), g._depth = c._depth + 1, a.push(g) } } this._cullWithChildrenBounds && uF.checkChildrenWithinParent(c) } return s }; function Yie(e, t, n, i) { if (l(n.implicitTiling) || Mi(n, "3DTILES_implicit_tiling")) { let r = e.schema, s = new gF(t, n, r), a = new yF({ subdivisionScheme: s.subdivisionScheme, subtreeLevels: s.subtreeLevels, level: 0, x: 0, y: 0, z: 0 }), c = s.subtreeUriTemplate.getDerivedResource({ templateValues: a.getTemplateValues() }).url, f = tt(n, !0); f.contents = [{ uri: c }], delete f.content, delete f.extensions; let d = new hw(e, t, f, i); return d.implicitTileset = s, d.implicitCoordinates = a, d } return new hw(e, t, n, i) } function tGe(e, t) { let n = Mi(t, "3DTILES_metadata") ? t.extensions["3DTILES_metadata"] : t, i; if (l(n.schemaUri)) { let o = e._resource.getDerivedResource({ url: n.schemaUri }); i = ao.loadSchema({ resource: o }) } else if (l(n.schema)) i = ao.loadSchema({ schema: n.schema }); else return Promise.resolve(t); return e._schemaLoader = i, i.promise.then(function (o) { return e._metadataExtension = new lF({ schema: o.schema, metadataJson: n }), t }) } var Xie = new h, nGe = new he, iGe = new F, oGe = new h, rGe = new h, sGe = new h; function aGe(e, t) { let n, i, o, r, s, a = t.camera, c = e._root, u = c.contentBoundingVolume; if (u instanceof Bf) n = h.normalize(a.positionWC, Xie), i = a.directionWC, o = a.positionCartographic.height, r = u.minimumHeight, s = u.maximumHeight; else { let x = F.inverseTransformation(c.computedTransform, iGe), T = t.mapProjection.ellipsoid, b = u.boundingVolume, S = F.multiplyByPoint(x, b.center, oGe); if (h.magnitude(S) > T.minimumRadius) { let D = he.fromCartesian(S, T, nGe); n = h.normalize(a.positionWC, Xie), i = a.directionWC, o = a.positionCartographic.height, r = 0, s = D.height * 2 } else { let D = F.multiplyByPoint(x, a.positionWC, rGe); if (n = h.UNIT_Z, i = F.multiplyByPointAsVector(x, a.directionWC, sGe), i = h.normalize(i, i), o = D.z, u instanceof Mf) { let P = c._header.boundingVolume.box[11]; r = S.z - P, s = S.z + P } else if (u instanceof F_) { let P = b.radius; r = S.z - P, s = S.z + P } } } let f = e.dynamicScreenSpaceErrorHeightFalloff, d = r + (s - r) * f, p = s, g = I.clamp((o - d) / (p - d), 0, 1), m = Math.abs(h.dot(i, n)), A = 1 - m; A = A * (1 - g); let C = e.dynamicScreenSpaceErrorDensity; C *= A, e._dynamicScreenSpaceErrorComputedDensity = C } function cGe(e, t) { if (t.hasEmptyContent) return; let n = e._statistics, i = t.contentExpired, o = t.requestContent(); if (o > 0) { n.numberOfAttemptedRequests += o; return } i && (t.hasTilesetContent || t.hasImplicitContent ? CGe(e, t) : (n.decrementLoadCounts(t.content), --n.numberOfTilesWithContentReady)), e._requestedTilesInFlight.push(t), t.contentReadyToProcessPromise.then(dGe(e, t)).catch(function (r) { }), t.contentReadyPromise.then(mGe(e, t)).catch(hGe(e, t)) } function lGe(e, t) { return e._priority - t._priority } Ds.prototype.postPassesUpdate = function (e) { !this.ready || (uGe(this, e), TGe(this, e), this._cache.unloadTiles(this, Zie), this._styleApplied && this._styleEngine.resetDirty(), this._styleApplied = !1) }; Ds.prototype.prePassesUpdate = function (e) { if (!this.ready) return; _Ge(this, e); let t = this._clippingPlanes; this._clippingPlanesOriginMatrixDirty = !0, l(t) && t.enabled && t.update(e), l(this._loadTimestamp) || (this._loadTimestamp = $.clone(e.time)), this._timeSinceLoad = Math.max($.secondsDifference(e.time, this._loadTimestamp) * 1e3, 0), this._skipLevelOfDetail = this.skipLevelOfDetail && !l(this._classificationType) && !this._disableSkipLevelOfDetail && !this._allTilesAdditive, this.dynamicScreenSpaceError && aGe(this, e), e.newFrame && this._cache.reset() }; function uGe(e, t) { let n = e._requestedTilesInFlight, i = 0, o = n.length; for (let r = 0; r < o; ++r) { let s = n[r], a = t.frameNumber - s._touchedFrame >= 1; if (s._contentState !== To.LOADING) { ++i; continue } else if (a) { s.cancelRequests(), ++i; continue } i > 0 && (n[r - i] = s) } n.length -= i } function fGe(e, t) { let n = e._requestedTiles, i = n.length; n.sort(lGe); for (let o = 0; o < i; ++o)cGe(e, n[o]) } function dGe(e, t) { return function () { e._processingQueue.push(t), ++e._statistics.numberOfTilesProcessing } } function hGe(e, t) { return function (n) { if (t._contentState !== To.FAILED) return; let i = t._contentResource.url, o = l(n.message) ? n.message : n.toString(); e.tileFailed.numberOfListeners > 0 ? e.tileFailed.raiseEvent({ url: i, message: o }) : (console.log(`A 3D tile failed to load: ${i}`), console.log(`Error: ${o}`)) } } function mGe(e, t) { return function (n) { --e._statistics.numberOfTilesProcessing, l(n) && (!t.hasTilesetContent && !t.hasImplicitContent && (e._statistics.incrementLoadCounts(t.content), ++e._statistics.numberOfTilesWithContentReady, ++e._statistics.numberOfLoadedTilesTotal, e._cache.add(t)), e.tileLoad.raiseEvent(t)) } } function pGe(e) { let t = e._processingQueue, n = t.length, i = 0; for (let o = 0; o < n; ++o) { let r = t[o]; if (r._contentState !== To.PROCESSING) { ++i; continue } i > 0 && (t[o - i] = r) } t.length -= i } function _Ge(e, t) { pGe(e); let n = e._processingQueue, i = n.length; for (let o = 0; o < i; ++o)n[o].process(e, t) } var AF = new h, gGe = { maximumFractionDigits: 3 }; function Kie(e) { let t = e / 1048576; return t < 1 ? t.toLocaleString(void 0, gGe) : Math.round(t).toLocaleString() } function j5(e) { let t = e.boundingVolume.boundingVolume, n = t.halfAxes, i = t.radius, o = h.clone(t.center, AF); if (l(n)) o.x += .75 * (n[0] + n[3] + n[6]), o.y += .75 * (n[1] + n[4] + n[7]), o.z += .75 * (n[2] + n[5] + n[8]); else if (l(i)) { let r = h.normalize(t.center, AF); r = h.multiplyByScalar(r, .75 * i, AF), o = h.add(r, t.center, AF) } return o } function q5(e, t, n) {
        let i = "", o = 0; if (t.debugShowGeometricError && (i += `
Geometric error: ${e.geometricError}`, o++), t.debugShowRenderingStatistics && (i += `
Commands: ${e.commandsLength}`, o++, e.content.pointsLength > 0 && (i += `
Points: ${e.content.pointsLength}`, o++), e.content.trianglesLength > 0 && (i += `
Triangles: ${e.content.trianglesLength}`, o++), i += `
Features: ${e.content.featuresLength}`, o++), t.debugShowMemoryUsage && (i += `
Texture Memory: ${Kie(e.content.texturesByteLength)}`, i += `
Geometry Memory: ${Kie(e.content.geometryByteLength)}`, o += 2), t.debugShowUrl) if (e.hasMultipleContents) {
                i += `
Urls:`; let s = e.content.innerContentUrls; for (let a = 0; a < s.length; a++)i += `
- ${s[a]}`; o += s.length
            } else i += `
Url: ${e._contentHeader.uri}`, o++; let r = { text: i.substring(1), position: n, font: `${19 - o}px sans-serif`, showBackground: !0, disableDepthTestDistance: Number.POSITIVE_INFINITY }; return t._tileDebugLabels.add(r)
    } function yGe(e, t) { let n, i, o = e._selectedTiles, r = o.length, s = e._emptyTiles, a = s.length; if (e._tileDebugLabels.removeAll(), e.debugPickedTileLabelOnly) { if (l(e.debugPickedTile)) { let c = l(e.debugPickPosition) ? e.debugPickPosition : j5(e.debugPickedTile), u = q5(e.debugPickedTile, e, c); u.pixelOffset = new H(15, -15) } } else { for (n = 0; n < r; ++n)i = o[n], q5(i, e, j5(i)); for (n = 0; n < a; ++n)i = s[n], (i.hasTilesetContent || i.hasImplicitContent) && q5(i, e, j5(i)) } e._tileDebugLabels.update(t) } function AGe(e, t, n) { e._styleEngine.applyStyle(e), e._styleApplied = !0; let i = n.isRender, o = e._statistics, r = t.commandList, s = r.length, a = e._selectedTiles, c = a.length, u = e._emptyTiles, f = u.length, d = e.tileVisible, p, g, m = e._skipLevelOfDetail && e._hasMixedContent && t.context.stencilBuffer && c > 0; e._backfaceCommands.length = 0, m && (l(e._stencilClearCommand) || (e._stencilClearCommand = new ti({ stencil: 0, pass: xe.CESIUM_3D_TILE, renderState: Ve.fromCache({ stencilMask: vt.SKIP_LOD_MASK }) })), r.push(e._stencilClearCommand)); let A = r.length; for (p = 0; p < c; ++p)g = a[p], i && d.raiseEvent(g), g.update(e, t, n), o.incrementSelectionCounts(g.content), ++o.selected; for (p = 0; p < f; ++p)g = u[p], g.update(e, t, n); let C = r.length - A; if (e._backfaceCommands.trim(), m) { let x = e._backfaceCommands.values, T = x.length; for (r.length += T, p = C - 1; p >= 0; --p)r[A + T + p] = r[A + p]; for (p = 0; p < T; ++p)r[A + p] = x[p] } C = r.length - s, o.numberOfCommands = C, i && e.pointCloudShading.attenuation && e.pointCloudShading.eyeDomeLighting && C > 0 && e._pointCloudEyeDomeLighting.update(t, s, e.pointCloudShading, e.boundingSphere), i && (e.debugShowGeometricError || e.debugShowRenderingStatistics || e.debugShowMemoryUsage || e.debugShowUrl ? (l(e._tileDebugLabels) || (e._tileDebugLabels = new Lm), yGe(e, t)) : e._tileDebugLabels = e._tileDebugLabels && e._tileDebugLabels.destroy()) } var Jie = []; function CGe(e, t) { let n = t, i = Jie; for (i.push(t); i.length > 0;) { t = i.pop(); let o = t.children, r = o.length; for (let s = 0; s < r; ++s)i.push(o[s]); t !== n && (xGe(e, t), --e._statistics.numberOfTilesTotal) } n.children = [] } function Zie(e, t) { e.tileUnload.raiseEvent(t), e._statistics.decrementLoadCounts(t.content), --e._statistics.numberOfTilesWithContentReady, t.unloadContent() } function xGe(e, t) { e._cache.unloadTile(e, t, Zie), t.destroy() } Ds.prototype.trimLoadedTiles = function () { this._cache.trim() }; function TGe(e, t) { let n = e._statistics, i = e._statisticsLast, o = n.numberOfPendingRequests, r = n.numberOfTilesProcessing, s = i.numberOfPendingRequests, a = i.numberOfTilesProcessing; V_.clone(n, i); let c = o !== s || r !== a; c && t.afterRender.push(function () { e.loadProgress.raiseEvent(o, r) }), e._tilesLoaded = n.numberOfPendingRequests === 0 && n.numberOfTilesProcessing === 0 && n.numberOfAttemptedRequests === 0, c && e._tilesLoaded && (t.afterRender.push(function () { e.allTilesLoaded.raiseEvent() }), e._initialTilesLoaded || (e._initialTilesLoaded = !0, t.afterRender.push(function () { e.initialTilesLoaded.raiseEvent() }))) } function EGe(e) { e._heatmap.resetMinimumMaximum(), e._minimumPriority.depth = Number.MAX_VALUE, e._maximumPriority.depth = -Number.MAX_VALUE, e._minimumPriority.foveatedFactor = Number.MAX_VALUE, e._maximumPriority.foveatedFactor = -Number.MAX_VALUE, e._minimumPriority.distance = Number.MAX_VALUE, e._maximumPriority.distance = -Number.MAX_VALUE, e._minimumPriority.reverseScreenSpaceError = Number.MAX_VALUE, e._maximumPriority.reverseScreenSpaceError = -Number.MAX_VALUE } function bGe(e, t) { (t.frameNumber !== e._updatedModelMatrixFrame || !l(e._previousModelMatrix)) && (e._updatedModelMatrixFrame = t.frameNumber, e._modelMatrixChanged = !F.equals(e.modelMatrix, e._previousModelMatrix), e._modelMatrixChanged && (e._previousModelMatrix = F.clone(e.modelMatrix, e._previousModelMatrix))) } function SGe(e, t, n, i) { if (t.mode === ee.MORPHING || !e.ready) return !1; let o = e._statistics; o.clear(); let r = i.isRender; ++e._updatedVisibilityFrame, EGe(e), bGe(e, t), e._cullRequestsWhileMoving = e.cullRequestsWhileMoving && !e._modelMatrixChanged; let s = i.traversal.selectTiles(e, t); if (i.requestTiles && fGe(e), AGe(e, t, i), V_.clone(o, n), r) { let a = e._credits; if (l(a) && o.selected !== 0) { let c = a.length; for (let u = 0; u < c; ++u) { let f = a[u]; f.showOnScreen = e._showCreditsOnScreen, t.creditDisplay.addCredit(f) } } } return s } Ds.prototype.update = function (e) { this.updateForPass(e, e.tilesetPassState) }; Ds.prototype.updateForPass = function (e, t) { let n = t.pass; if (n === Qo.PRELOAD && (!this.preloadWhenHidden || this.show) || n === Qo.PRELOAD_FLIGHT && (!this.preloadFlightDestinations || !this.show && !this.preloadWhenHidden) || n === Qo.REQUEST_RENDER_MODE_DEFER_CHECK && (!this._cullRequestsWhileMoving && this.foveatedTimeDelay <= 0 || !this.show)) return; let i = e.commandList, o = e.camera, r = e.cullingVolume; t.ready = !1; let s = Qo.getPassOptions(n), a = s.ignoreCommands, c = y(t.commandList, i), u = c.length; e.commandList = c, e.camera = y(t.camera, o), e.cullingVolume = y(t.cullingVolume, r); let f = this._statisticsPerPass[n]; (this.show || a) && (this._pass = n, t.ready = SGe(this, e, f, s)), a && (c.length = u), e.commandList = i, e.camera = o, e.cullingVolume = r }; Ds.prototype.hasExtension = function (e) { return l(this._extensionsUsed) ? this._extensionsUsed.indexOf(e) > -1 : !1 }; Ds.prototype.isDestroyed = function () { return !1 }; Ds.prototype.destroy = function () { if (this._tileDebugLabels = this._tileDebugLabels && this._tileDebugLabels.destroy(), this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy(), l(this._schemaLoader) && ao.unload(this._schemaLoader), l(this._root)) { let e = Jie; for (e.push(this._root); e.length > 0;) { let t = e.pop(); t.destroy(); let n = t.children, i = n.length; for (let o = 0; o < i; ++o)e.push(n[o]) } } return this._root = void 0, this._shouldDestroyImageBasedLighting && !this._imageBasedLighting.isDestroyed() && this._imageBasedLighting.destroy(), this._imageBasedLighting = void 0, le(this) }; Ds.supportedExtensions = { "3DTILES_metadata": !0, "3DTILES_implicit_tiling": !0, "3DTILES_content_gltf": !0, "3DTILES_multiple_contents": !0, "3DTILES_bounding_volume_S2": !0, "3DTILES_batch_table_hierarchy": !0, "3DTILES_draco_point_compression": !0, MAXAR_content_geojson: !0 }; Ds.checkSupportedExtensions = function (e) { for (let t = 0; t < e.length; t++)if (!Ds.supportedExtensions[e[t]]) throw new fe(`Unsupported 3D Tiles Extension: ${e[t]}`) }; var Su = Ds; var wGe = new F; function k_(e, t) { t.collectionChanged.addEventListener(k_.prototype._onCollectionChanged, this), this._scene = e, this._primitives = e.primitives, this._entityCollection = t, this._tilesetHash = {}, this._entitiesToVisualize = new Ct, this._onCollectionChanged(t, t.values, [], []) } k_.prototype.update = function (e) { let t = this._entitiesToVisualize.values, n = this._tilesetHash, i = this._primitives; for (let o = 0, r = t.length; o < r; o++) { let s = t[o], a = s._tileset, c, u = n[s.id], f = s.isShowing && s.isAvailable(e) && j.getValueOrDefault(a._show, e, !0), d; if (f && (d = s.computeModelMatrix(e, wGe), c = Pe.createIfNeeded(j.getValueOrUndefined(a._uri, e))), !f) { l(u) && (u.tilesetPrimitive.show = !1); continue } let p = l(u) ? u.tilesetPrimitive : void 0; (!l(p) || c.url !== u.url) && (l(p) && (i.removeAndDestroy(p), delete n[s.id]), p = new Su({ url: c }), p.id = s, i.add(p), u = { tilesetPrimitive: p, url: c.url, loadFail: !1 }, n[s.id] = u, DGe(p, s, n)), p.show = !0, l(d) && (p.modelMatrix = d), p.maximumScreenSpaceError = j.getValueOrDefault(a.maximumScreenSpaceError, e, p.maximumScreenSpaceError) } return !0 }; k_.prototype.isDestroyed = function () { return !1 }; k_.prototype.destroy = function () { this._entityCollection.collectionChanged.removeEventListener(k_.prototype._onCollectionChanged, this); let e = this._entitiesToVisualize.values, t = this._tilesetHash, n = this._primitives; for (let i = e.length - 1; i > -1; i--)Y5(this, e[i], t, n); return le(this) }; k_.prototype.getBoundingSphere = function (e, t) { let n = this._tilesetHash[e.id]; if (!l(n) || n.loadFail) return rt.FAILED; let i = n.tilesetPrimitive; return !l(i) || !i.show ? rt.FAILED : i.ready ? (re.clone(i.boundingSphere, t), rt.DONE) : rt.PENDING }; k_.prototype._onCollectionChanged = function (e, t, n, i) { let o, r, s = this._entitiesToVisualize, a = this._tilesetHash, c = this._primitives; for (o = t.length - 1; o > -1; o--)r = t[o], l(r._tileset) && s.set(r.id, r); for (o = i.length - 1; o > -1; o--)r = i[o], l(r._tileset) ? s.set(r.id, r) : (Y5(this, r, a, c), s.remove(r.id)); for (o = n.length - 1; o > -1; o--)r = n[o], Y5(this, r, a, c), s.remove(r.id) }; function Y5(e, t, n, i) { let o = n[t.id]; l(o) && (i.removeAndDestroy(o.tilesetPrimitive), delete n[t.id]) } function DGe(e, t, n) { e.readyPromise.catch(function (i) { console.error(i), n[t.id].loadFail = !0 }) } var CF = k_; var vGe = U.WHITE, PGe = U.BLACK, IGe = new H(2, 2); function Ux(e) { e = y(e, y.EMPTY_OBJECT), this._definitionChanged = new _e, this._evenColor = void 0, this._evenColorSubscription = void 0, this._oddColor = void 0, this._oddColorSubscription = void 0, this._repeat = void 0, this._repeatSubscription = void 0, this.evenColor = e.evenColor, this.oddColor = e.oddColor, this.repeat = e.repeat } Object.defineProperties(Ux.prototype, { isConstant: { get: function () { return j.isConstant(this._evenColor) && j.isConstant(this._oddColor) && j.isConstant(this._repeat) } }, definitionChanged: { get: function () { return this._definitionChanged } }, evenColor: ae("evenColor"), oddColor: ae("oddColor"), repeat: ae("repeat") }); Ux.prototype.getType = function (e) { return "Checkerboard" }; Ux.prototype.getValue = function (e, t) { return l(t) || (t = {}), t.lightColor = j.getValueOrClonedDefault(this._evenColor, e, vGe, t.lightColor), t.darkColor = j.getValueOrClonedDefault(this._oddColor, e, PGe, t.darkColor), t.repeat = j.getValueOrDefault(this._repeat, e, IGe), t }; Ux.prototype.equals = function (e) { return this === e || e instanceof Ux && j.equals(this._evenColor, e._evenColor) && j.equals(this._oddColor, e._oddColor) && j.equals(this._repeat, e._repeat) }; var yw = Ux; var Qie = { id: void 0 }; function Aw(e) { if (e._firing) { e._refire = !0; return } if (e._suspendCount === 0) { let t = e._addedEntities, n = e._removedEntities, i = e._changedEntities; if (i.length !== 0 || t.length !== 0 || n.length !== 0) { e._firing = !0; do { e._refire = !1; let o = t.values.slice(0), r = n.values.slice(0), s = i.values.slice(0); t.removeAll(), n.removeAll(), i.removeAll(), e._collectionChanged.raiseEvent(e, o, r, s) } while (e._refire); e._firing = !1 } } } function Da(e) { this._owner = e, this._entities = new Ct, this._addedEntities = new Ct, this._removedEntities = new Ct, this._changedEntities = new Ct, this._suspendCount = 0, this._collectionChanged = new _e, this._id = Nn(), this._show = !0, this._firing = !1, this._refire = !1 } Da.prototype.suspendEvents = function () { this._suspendCount++ }; Da.prototype.resumeEvents = function () { this._suspendCount--, Aw(this) }; Object.defineProperties(Da.prototype, { collectionChanged: { get: function () { return this._collectionChanged } }, id: { get: function () { return this._id } }, values: { get: function () { return this._entities.values } }, show: { get: function () { return this._show }, set: function (e) { if (e === this._show) return; this.suspendEvents(); let t, n = [], i = this._entities.values, o = i.length; for (t = 0; t < o; t++)n.push(i[t].isShowing); for (this._show = e, t = 0; t < o; t++) { let r = n[t], s = i[t]; r !== s.isShowing && s.definitionChanged.raiseEvent(s, "isShowing", s.isShowing, r) } this.resumeEvents() } }, owner: { get: function () { return this._owner } } }); Da.prototype.computeAvailability = function () { let e = ke.MAXIMUM_VALUE, t = ke.MINIMUM_VALUE, n = this._entities.values; for (let i = 0, o = n.length; i < o; i++) { let s = n[i].availability; if (l(s)) { let a = s.start, c = s.stop; $.lessThan(a, e) && !a.equals(ke.MINIMUM_VALUE) && (e = a), $.greaterThan(c, t) && !c.equals(ke.MAXIMUM_VALUE) && (t = c) } } return ke.MAXIMUM_VALUE.equals(e) && (e = ke.MINIMUM_VALUE), ke.MINIMUM_VALUE.equals(t) && (t = ke.MAXIMUM_VALUE), new yn({ start: e, stop: t }) }; Da.prototype.add = function (e) { e instanceof Xo || (e = new Xo(e)); let t = e.id, n = this._entities; if (n.contains(t)) throw new fe(`An entity with id ${t} already exists in this collection.`); return e.entityCollection = this, n.set(t, e), this._removedEntities.remove(t) || this._addedEntities.set(t, e), e.definitionChanged.addEventListener(Da.prototype._onEntityDefinitionChanged, this), Aw(this), e }; Da.prototype.remove = function (e) { return l(e) ? this.removeById(e.id) : !1 }; Da.prototype.contains = function (e) { return this._entities.get(e.id) === e }; Da.prototype.removeById = function (e) { if (!l(e)) return !1; let n = this._entities.get(e); return this._entities.remove(e) ? (this._addedEntities.remove(e) || (this._removedEntities.set(e, n), this._changedEntities.remove(e)), this._entities.remove(e), n.definitionChanged.removeEventListener(Da.prototype._onEntityDefinitionChanged, this), Aw(this), !0) : !1 }; Da.prototype.removeAll = function () { let e = this._entities, t = e.length, n = e.values, i = this._addedEntities, o = this._removedEntities; for (let r = 0; r < t; r++) { let s = n[r], a = s.id, c = i.get(a); l(c) || (s.definitionChanged.removeEventListener(Da.prototype._onEntityDefinitionChanged, this), o.set(a, s)) } e.removeAll(), i.removeAll(), this._changedEntities.removeAll(), Aw(this) }; Da.prototype.getById = function (e) { return this._entities.get(e) }; Da.prototype.getOrCreateEntity = function (e) { let t = this._entities.get(e); return l(t) || (Qie.id = e, t = new Xo(Qie), this.add(t)), t }; Da.prototype._onEntityDefinitionChanged = function (e) { let t = e.id; this._addedEntities.contains(t) || this._changedEntities.set(t, e), Aw(this) }; var vs = Da; var xF = { id: void 0 }, zx = new Array(2); function X5(e) { let t = e.propertyNames, n = t.length; for (let i = 0; i < n; i++)e[t[i]] = void 0; e._name = void 0, e._availability = void 0 } function $ie(e, t, n, i) { zx[0] = n, zx[1] = i.id, t[JSON.stringify(zx)] = i.definitionChanged.addEventListener(yr.prototype._onDefinitionChanged, e) } function eoe(e, t, n, i) { zx[0] = n, zx[1] = i.id; let o = JSON.stringify(zx); t[o](), t[o] = void 0 } function U_(e) { if (e._shouldRecomposite = !0, e._suspendCount !== 0) return; let t = e._collections, n = t.length, i = e._collectionsCopy, o = i.length, r, s, a, c, u, f = e._composite, d = new vs(e), p = e._eventHash, g; for (r = 0; r < o; r++)for (u = i[r], u.collectionChanged.removeEventListener(yr.prototype._onCollectionChanged, e), a = u.values, g = u.id, c = a.length - 1; c > -1; c--)s = a[c], eoe(e, p, g, s); for (r = n - 1; r >= 0; r--)for (u = t[r], u.collectionChanged.addEventListener(yr.prototype._onCollectionChanged, e), a = u.values, g = u.id, c = a.length - 1; c > -1; c--) { s = a[c], $ie(e, p, g, s); let A = d.getById(s.id); l(A) || (A = f.getById(s.id), l(A) ? X5(A) : (xF.id = s.id, A = new Xo(xF)), d.add(A)), A.merge(s) } e._collectionsCopy = t.slice(0), f.suspendEvents(), f.removeAll(); let m = d.values; for (r = 0; r < m.length; r++)f.add(m[r]); f.resumeEvents() } function yr(e, t) { this._owner = t, this._composite = new vs(this), this._suspendCount = 0, this._collections = l(e) ? e.slice() : [], this._collectionsCopy = [], this._id = Nn(), this._eventHash = {}, U_(this), this._shouldRecomposite = !1 } Object.defineProperties(yr.prototype, { collectionChanged: { get: function () { return this._composite._collectionChanged } }, id: { get: function () { return this._id } }, values: { get: function () { return this._composite.values } }, owner: { get: function () { return this._owner } } }); yr.prototype.addCollection = function (e, t) { l(t) ? this._collections.splice(t, 0, e) : (t = this._collections.length, this._collections.push(e)), U_(this) }; yr.prototype.removeCollection = function (e) { let t = this._collections.indexOf(e); return t !== -1 ? (this._collections.splice(t, 1), U_(this), !0) : !1 }; yr.prototype.removeAllCollections = function () { this._collections.length = 0, U_(this) }; yr.prototype.containsCollection = function (e) { return this._collections.indexOf(e) !== -1 }; yr.prototype.contains = function (e) { return this._composite.contains(e) }; yr.prototype.indexOfCollection = function (e) { return this._collections.indexOf(e) }; yr.prototype.getCollection = function (e) { return this._collections[e] }; yr.prototype.getCollectionsLength = function () { return this._collections.length }; function TF(e, t) { return e.indexOf(t) } function toe(e, t, n) { let i = e._collections; if (t = I.clamp(t, 0, i.length - 1), n = I.clamp(n, 0, i.length - 1), t === n) return; let o = i[t]; i[t] = i[n], i[n] = o, U_(e) } yr.prototype.raiseCollection = function (e) { let t = TF(this._collections, e); toe(this, t, t + 1) }; yr.prototype.lowerCollection = function (e) { let t = TF(this._collections, e); toe(this, t, t - 1) }; yr.prototype.raiseCollectionToTop = function (e) { let t = TF(this._collections, e); t !== this._collections.length - 1 && (this._collections.splice(t, 1), this._collections.push(e), U_(this)) }; yr.prototype.lowerCollectionToBottom = function (e) { let t = TF(this._collections, e); t !== 0 && (this._collections.splice(t, 1), this._collections.splice(0, 0, e), U_(this)) }; yr.prototype.suspendEvents = function () { this._suspendCount++, this._composite.suspendEvents() }; yr.prototype.resumeEvents = function () { this._suspendCount--, this._shouldRecomposite && this._suspendCount === 0 && (U_(this), this._shouldRecomposite = !1), this._composite.resumeEvents() }; yr.prototype.computeAvailability = function () { return this._composite.computeAvailability() }; yr.prototype.getById = function (e) { return this._composite.getById(e) }; yr.prototype._onCollectionChanged = function (e, t, n) { let i = this._collectionsCopy, o = i.length, r = this._composite; r.suspendEvents(); let s, a, c, u, f = n.length, d = this._eventHash, p = e.id; for (s = 0; s < f; s++) { let m = n[s]; eoe(this, d, p, m); let A = m.id; for (a = o - 1; a >= 0; a--)c = i[a].getById(A), l(c) && (l(u) || (u = r.getById(A), X5(u)), u.merge(c)); l(u) || r.removeById(A), u = void 0 } let g = t.length; for (s = 0; s < g; s++) { let m = t[s]; $ie(this, d, p, m); let A = m.id; for (a = o - 1; a >= 0; a--)c = i[a].getById(A), l(c) && (l(u) || (u = r.getById(A), l(u) ? X5(u) : (xF.id = A, u = new Xo(xF), r.add(u))), u.merge(c)); u = void 0 } r.resumeEvents() }; yr.prototype._onDefinitionChanged = function (e, t, n, i) { let o = this._collections, r = this._composite, s = o.length, a = e.id, c = r.getById(a), u = c[t], f = !l(u), d = !0; for (let p = s - 1; p >= 0; p--) { let g = o[p].getById(e.id); if (l(g)) { let m = g[t]; if (l(m)) { if (d) if (d = !1, l(m.merge) && l(m.clone)) u = m.clone(u); else { u = m; break } u.merge(m) } } } f && c.propertyNames.indexOf(t) === -1 && c.addProperty(t), c[t] = u }; var noe = yr; function K5() { this._removalFunctions = [] } K5.prototype.add = function (e, t, n) { let i = e.addEventListener(t, n); this._removalFunctions.push(i); let o = this; return function () { i(); let r = o._removalFunctions; r.splice(r.indexOf(i), 1) } }; K5.prototype.removeAll = function () { let e = this._removalFunctions; for (let t = 0, n = e.length; t < n; ++t)e[t](); e.length = 0 }; var Pr = K5; function Q5(e, t) { return $.compare(e.start, t.start) } function Ar(e) { if (this._intervals = [], this._changedEvent = new _e, l(e)) { let t = e.length; for (let n = 0; n < t; n++)this.addInterval(e[n]) } } Object.defineProperties(Ar.prototype, { changedEvent: { get: function () { return this._changedEvent } }, start: { get: function () { let e = this._intervals; return e.length === 0 ? void 0 : e[0].start } }, isStartIncluded: { get: function () { let e = this._intervals; return e.length === 0 ? !1 : e[0].isStartIncluded } }, stop: { get: function () { let e = this._intervals, t = e.length; return t === 0 ? void 0 : e[t - 1].stop } }, isStopIncluded: { get: function () { let e = this._intervals, t = e.length; return t === 0 ? !1 : e[t - 1].isStopIncluded } }, length: { get: function () { return this._intervals.length } }, isEmpty: { get: function () { return this._intervals.length === 0 } } }); Ar.prototype.equals = function (e, t) { if (this === e) return !0; if (!(e instanceof Ar)) return !1; let n = this._intervals, i = e._intervals, o = n.length; if (o !== i.length) return !1; for (let r = 0; r < o; r++)if (!yn.equals(n[r], i[r], t)) return !1; return !0 }; Ar.prototype.get = function (e) { return this._intervals[e] }; Ar.prototype.removeAll = function () { this._intervals.length > 0 && (this._intervals.length = 0, this._changedEvent.raiseEvent(this)) }; Ar.prototype.findIntervalContainingDate = function (e) { let t = this.indexOf(e); return t >= 0 ? this._intervals[t] : void 0 }; Ar.prototype.findDataForIntervalContainingDate = function (e) { let t = this.indexOf(e); return t >= 0 ? this._intervals[t].data : void 0 }; Ar.prototype.contains = function (e) { return this.indexOf(e) >= 0 }; var J5 = new yn; Ar.prototype.indexOf = function (e) { let t = this._intervals; J5.start = e, J5.stop = e; let n = Wo(t, J5, Q5); return n >= 0 ? t[n].isStartIncluded ? n : n > 0 && t[n - 1].stop.equals(e) && t[n - 1].isStopIncluded ? n - 1 : ~n : (n = ~n, n > 0 && n - 1 < t.length && yn.contains(t[n - 1], e) ? n - 1 : ~n) }; Ar.prototype.findInterval = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.start, n = e.stop, i = e.isStartIncluded, o = e.isStopIncluded, r = this._intervals; for (let s = 0, a = r.length; s < a; s++) { let c = r[s]; if ((!l(t) || c.start.equals(t)) && (!l(n) || c.stop.equals(n)) && (!l(i) || c.isStartIncluded === i) && (!l(o) || c.isStopIncluded === o)) return r[s] } }; Ar.prototype.addInterval = function (e, t) { if (e.isEmpty) return; let n = this._intervals; if (n.length === 0 || $.greaterThan(e.start, n[n.length - 1].stop)) { n.push(e), this._changedEvent.raiseEvent(this); return } let i = Wo(n, e, Q5); i < 0 ? i = ~i : i > 0 && e.isStartIncluded && n[i - 1].isStartIncluded && n[i - 1].start.equals(e.start) ? --i : i < n.length && !e.isStartIncluded && n[i].isStartIncluded && n[i].start.equals(e.start) && ++i; let o; for (i > 0 && (o = $.compare(n[i - 1].stop, e.start), (o > 0 || o === 0 && (n[i - 1].isStopIncluded || e.isStartIncluded)) && ((l(t) ? t(n[i - 1].data, e.data) : n[i - 1].data === e.data) ? ($.greaterThan(e.stop, n[i - 1].stop) ? e = new yn({ start: n[i - 1].start, stop: e.stop, isStartIncluded: n[i - 1].isStartIncluded, isStopIncluded: e.isStopIncluded, data: e.data }) : e = new yn({ start: n[i - 1].start, stop: n[i - 1].stop, isStartIncluded: n[i - 1].isStartIncluded, isStopIncluded: n[i - 1].isStopIncluded || e.stop.equals(n[i - 1].stop) && e.isStopIncluded, data: e.data }), n.splice(i - 1, 1), --i) : (o = $.compare(n[i - 1].stop, e.stop), (o > 0 || o === 0 && n[i - 1].isStopIncluded && !e.isStopIncluded) && n.splice(i, 0, new yn({ start: e.stop, stop: n[i - 1].stop, isStartIncluded: !e.isStopIncluded, isStopIncluded: n[i - 1].isStopIncluded, data: n[i - 1].data })), n[i - 1] = new yn({ start: n[i - 1].start, stop: e.start, isStartIncluded: n[i - 1].isStartIncluded, isStopIncluded: !e.isStartIncluded, data: n[i - 1].data })))); i < n.length && (o = $.compare(e.stop, n[i].start), o > 0 || o === 0 && (e.isStopIncluded || n[i].isStartIncluded));)if (l(t) ? t(n[i].data, e.data) : n[i].data === e.data) e = new yn({ start: e.start, stop: $.greaterThan(n[i].stop, e.stop) ? n[i].stop : e.stop, isStartIncluded: e.isStartIncluded, isStopIncluded: $.greaterThan(n[i].stop, e.stop) ? n[i].isStopIncluded : e.isStopIncluded, data: e.data }), n.splice(i, 1); else if (n[i] = new yn({ start: e.stop, stop: n[i].stop, isStartIncluded: !e.isStopIncluded, isStopIncluded: n[i].isStopIncluded, data: n[i].data }), n[i].isEmpty) n.splice(i, 1); else break; n.splice(i, 0, e), this._changedEvent.raiseEvent(this) }; Ar.prototype.removeInterval = function (e) { if (e.isEmpty) return !1; let t = this._intervals, n = Wo(t, e, Q5); n < 0 && (n = ~n); let i = !1; for (n > 0 && ($.greaterThan(t[n - 1].stop, e.start) || t[n - 1].stop.equals(e.start) && t[n - 1].isStopIncluded && e.isStartIncluded) && (i = !0, ($.greaterThan(t[n - 1].stop, e.stop) || t[n - 1].isStopIncluded && !e.isStopIncluded && t[n - 1].stop.equals(e.stop)) && t.splice(n, 0, new yn({ start: e.stop, stop: t[n - 1].stop, isStartIncluded: !e.isStopIncluded, isStopIncluded: t[n - 1].isStopIncluded, data: t[n - 1].data })), t[n - 1] = new yn({ start: t[n - 1].start, stop: e.start, isStartIncluded: t[n - 1].isStartIncluded, isStopIncluded: !e.isStartIncluded, data: t[n - 1].data })), n < t.length && !e.isStartIncluded && t[n].isStartIncluded && e.start.equals(t[n].start) && (i = !0, t.splice(n, 0, new yn({ start: t[n].start, stop: t[n].start, isStartIncluded: !0, isStopIncluded: !0, data: t[n].data })), ++n); n < t.length && $.greaterThan(e.stop, t[n].stop);)i = !0, t.splice(n, 1); return n < t.length && e.stop.equals(t[n].stop) && (i = !0, !e.isStopIncluded && t[n].isStopIncluded ? n + 1 < t.length && t[n + 1].start.equals(e.stop) && t[n].data === t[n + 1].data ? (t.splice(n, 1), t[n] = new yn({ start: t[n].start, stop: t[n].stop, isStartIncluded: !0, isStopIncluded: t[n].isStopIncluded, data: t[n].data })) : t[n] = new yn({ start: e.stop, stop: e.stop, isStartIncluded: !0, isStopIncluded: !0, data: t[n].data }) : t.splice(n, 1)), n < t.length && ($.greaterThan(e.stop, t[n].start) || e.stop.equals(t[n].start) && e.isStopIncluded && t[n].isStartIncluded) && (i = !0, t[n] = new yn({ start: e.stop, stop: t[n].stop, isStartIncluded: !e.isStopIncluded, isStopIncluded: t[n].isStopIncluded, data: t[n].data })), i && this._changedEvent.raiseEvent(this), i }; Ar.prototype.intersect = function (e, t, n) { let i = new Ar, o = 0, r = 0, s = this._intervals, a = e._intervals; for (; o < s.length && r < a.length;) { let c = s[o], u = a[r]; if ($.lessThan(c.stop, u.start)) ++o; else if ($.lessThan(u.stop, c.start)) ++r; else { if (l(n) || l(t) && t(c.data, u.data) || !l(t) && u.data === c.data) { let f = yn.intersect(c, u, new yn, n); f.isEmpty || i.addInterval(f, t) } $.lessThan(c.stop, u.stop) || c.stop.equals(u.stop) && !c.isStopIncluded && u.isStopIncluded ? ++o : ++r } } return i }; Ar.fromJulianDateArray = function (e, t) { l(t) || (t = new Ar); let n = e.julianDates, i = n.length, o = e.dataCallback, r = y(e.isStartIncluded, !0), s = y(e.isStopIncluded, !0), a = y(e.leadingInterval, !1), c = y(e.trailingInterval, !1), u, f = 0; a && (++f, u = new yn({ start: ke.MINIMUM_VALUE, stop: n[0], isStartIncluded: !0, isStopIncluded: !r }), u.data = l(o) ? o(u, t.length) : t.length, t.addInterval(u)); for (let d = 0; d < i - 1; ++d) { let p = n[d], g = n[d + 1]; u = new yn({ start: p, stop: g, isStartIncluded: t.length === f ? r : !0, isStopIncluded: d === i - 2 ? s : !1 }), u.data = l(o) ? o(u, t.length) : t.length, t.addInterval(u), p = g } return c && (u = new yn({ start: n[i - 1], stop: ke.MAXIMUM_VALUE, isStartIncluded: !s, isStopIncluded: !0 }), u.data = l(o) ? o(u, t.length) : t.length, t.addInterval(u)), t }; var va = new Sp, Cw = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; function Z5(e, t, n) { l(n) || (n = new $), $.toGregorianDate(e, va); let i = va.millisecond + t.millisecond, o = va.second + t.second, r = va.minute + t.minute, s = va.hour + t.hour, a = va.day + t.day, c = va.month + t.month, u = va.year + t.year; for (i >= 1e3 && (o += Math.floor(i / 1e3), i = i % 1e3), o >= 60 && (r += Math.floor(o / 60), o = o % 60), r >= 60 && (s += Math.floor(r / 60), r = r % 60), s >= 24 && (a += Math.floor(s / 24), s = s % 24), Cw[2] = wp(u) ? 29 : 28; a > Cw[c] || c >= 13;)a > Cw[c] && (a -= Cw[c], ++c), c >= 13 && (--c, u += Math.floor(c / 12), c = c % 12, ++c), Cw[2] = wp(u) ? 29 : 28; return va.millisecond = i, va.second = o, va.minute = r, va.hour = s, va.day = a, va.month = c, va.year = u, $.fromGregorianDate(va, n) } var OGe = new $, BGe = /P(?:([\d.,]+)Y)?(?:([\d.,]+)M)?(?:([\d.,]+)W)?(?:([\d.,]+)D)?(?:T(?:([\d.,]+)H)?(?:([\d.,]+)M)?(?:([\d.,]+)S)?)?/; function ioe(e, t) { if (!l(e) || e.length === 0) return !1; if (t.year = 0, t.month = 0, t.day = 0, t.hour = 0, t.minute = 0, t.second = 0, t.millisecond = 0, e[0] === "P") { let n = e.match(BGe); if (!l(n)) return !1; if (l(n[1]) && (t.year = Number(n[1].replace(",", "."))), l(n[2]) && (t.month = Number(n[2].replace(",", "."))), l(n[3]) && (t.day = Number(n[3].replace(",", ".")) * 7), l(n[4]) && (t.day += Number(n[4].replace(",", "."))), l(n[5]) && (t.hour = Number(n[5].replace(",", "."))), l(n[6]) && (t.minute = Number(n[6].replace(",", "."))), l(n[7])) { let i = Number(n[7].replace(",", ".")); t.second = Math.floor(i), t.millisecond = i % 1 * 1e3 } } else e[e.length - 1] !== "Z" && (e += "Z"), $.toGregorianDate($.fromIso8601(e, OGe), t); return t.year || t.month || t.day || t.hour || t.minute || t.second || t.millisecond } var xw = new Sp; Ar.fromIso8601 = function (e, t) { let n = e.iso8601.split("/"), i = $.fromIso8601(n[0]), o = $.fromIso8601(n[1]), r = []; if (!ioe(n[2], xw)) r.push(i, o); else { let s = $.clone(i); for (r.push(s); $.compare(s, o) < 0;)s = Z5(s, xw), $.compare(o, s) <= 0 && $.clone(o, s), r.push(s) } return Ar.fromJulianDateArray({ julianDates: r, isStartIncluded: e.isStartIncluded, isStopIncluded: e.isStopIncluded, leadingInterval: e.leadingInterval, trailingInterval: e.trailingInterval, dataCallback: e.dataCallback }, t) }; Ar.fromIso8601DateArray = function (e, t) { return Ar.fromJulianDateArray({ julianDates: e.iso8601Dates.map(function (n) { return $.fromIso8601(n) }), isStartIncluded: e.isStartIncluded, isStopIncluded: e.isStopIncluded, leadingInterval: e.leadingInterval, trailingInterval: e.trailingInterval, dataCallback: e.dataCallback }, t) }; Ar.fromIso8601DurationArray = function (e, t) { let n = e.epoch, i = e.iso8601Durations, o = y(e.relativeToPrevious, !1), r = [], s, a, c = i.length; for (let u = 0; u < c; ++u)(ioe(i[u], xw) || u === 0) && (o && l(a) ? s = Z5(a, xw) : s = Z5(n, xw), r.push(s), a = s); return Ar.fromJulianDateArray({ julianDates: r, isStartIncluded: e.isStartIncluded, isStopIncluded: e.isStopIncluded, leadingInterval: e.leadingInterval, trailingInterval: e.trailingInterval, dataCallback: e.dataCallback }, t) }; var Ir = Ar; function RGe(e, t, n, i) { function o() { n.raiseEvent(e) } let r = []; t.removeAll(); let s = i.length; for (let a = 0; a < s; a++) { let c = i.get(a); l(c.data) && r.indexOf(c.data) === -1 && t.add(c.data.definitionChanged, o) } } function py() { this._eventHelper = new Pr, this._definitionChanged = new _e, this._intervals = new Ir, this._intervals.changedEvent.addEventListener(py.prototype._intervalsChanged, this) } Object.defineProperties(py.prototype, { isConstant: { get: function () { return this._intervals.isEmpty } }, definitionChanged: { get: function () { return this._definitionChanged } }, intervals: { get: function () { return this._intervals } } }); py.prototype.getValue = function (e, t) { let n = this._intervals.findDataForIntervalContainingDate(e); if (l(n)) return n.getValue(e, t) }; py.prototype.equals = function (e) { return this === e || e instanceof py && this._intervals.equals(e._intervals, j.equals) }; py.prototype._intervalsChanged = function () { RGe(this, this._eventHelper, this._definitionChanged, this._intervals), this._definitionChanged.raiseEvent(this) }; var cc = py; function z_() { this._definitionChanged = new _e, this._composite = new cc, this._composite.definitionChanged.addEventListener(z_.prototype._raiseDefinitionChanged, this) } Object.defineProperties(z_.prototype, { isConstant: { get: function () { return this._composite.isConstant } }, definitionChanged: { get: function () { return this._definitionChanged } }, intervals: { get: function () { return this._composite._intervals } } }); z_.prototype.getType = function (e) { let t = this._composite._intervals.findDataForIntervalContainingDate(e); if (l(t)) return t.getType(e) }; z_.prototype.getValue = function (e, t) { let n = this._composite._intervals.findDataForIntervalContainingDate(e); if (l(n)) return n.getValue(e, t) }; z_.prototype.equals = function (e) { return this === e || e instanceof z_ && this._composite.equals(e._composite, j.equals) }; z_.prototype._raiseDefinitionChanged = function () { this._definitionChanged.raiseEvent(this) }; var Tw = z_; function H_(e) { this._referenceFrame = y(e, Ji.FIXED), this._definitionChanged = new _e, this._composite = new cc, this._composite.definitionChanged.addEventListener(H_.prototype._raiseDefinitionChanged, this) } Object.defineProperties(H_.prototype, { isConstant: { get: function () { return this._composite.isConstant } }, definitionChanged: { get: function () { return this._definitionChanged } }, intervals: { get: function () { return this._composite.intervals } }, referenceFrame: { get: function () { return this._referenceFrame }, set: function (e) { this._referenceFrame = e } } }); H_.prototype.getValue = function (e, t) { return this.getValueInReferenceFrame(e, Ji.FIXED, t) }; H_.prototype.getValueInReferenceFrame = function (e, t, n) { let i = this._composite._intervals.findDataForIntervalContainingDate(e); if (l(i)) return i.getValueInReferenceFrame(e, t, n) }; H_.prototype.equals = function (e) { return this === e || e instanceof H_ && this._referenceFrame === e._referenceFrame && this._composite.equals(e._composite, j.equals) }; H_.prototype._raiseDefinitionChanged = function () { this._definitionChanged.raiseEvent(this) }; var $s = H_; var MGe = { ROUNDED: 0, MITERED: 1, BEVELED: 2 }, Ti = Object.freeze(MGe); var Ps = [new h, new h], LGe = new h, FGe = new h, NGe = new h, VGe = new h, kGe = new h, UGe = new h, zGe = new h, HGe = new h, GGe = new h, Hx = new h, EF = new h, Ew = {}, $5 = new he; function WGe(e, t) { let n = new Array(e.length); for (let i = 0; i < e.length; i++) { let o = e[i]; $5 = t.cartesianToCartographic(o, $5), n[i] = $5.height, e[i] = t.scaleToGeodeticSurface(o, o) } return n } function e6(e, t, n, i) { let o = e[0], r = e[1], s = h.angleBetween(o, r), a = Math.ceil(s / i), c = new Array(a), u; if (t === n) { for (u = 0; u < a; u++)c[u] = t; return c.push(n), c } let d = (n - t) / a; for (u = 1; u < a; u++) { let p = t + u * d; c[u] = p } return c[0] = t, c.push(n), c } var bF = new h, SF = new h; function jGe(e, t, n, i) { let o = new pa(n, i), r = o.projectPointOntoPlane(h.add(n, e, bF), bF), s = o.projectPointOntoPlane(h.add(n, t, SF), SF), a = H.angleBetween(r, s); return s.x * r.y - s.y * r.x >= 0 ? -a : a } var qGe = new h(-1, 0, 0), _y = new F, YGe = new F, t6 = new Q, XGe = Q.IDENTITY.clone(), KGe = new h, JGe = new se, ooe = new h; function Xm(e, t, n, i, o, r, s, a) { let c = KGe, u = JGe; _y = It.eastNorthUpToFixedFrame(e, o, _y), c = F.multiplyByPointAsVector(_y, qGe, c), c = h.normalize(c, c); let f = jGe(c, t, e, o); t6 = Q.fromRotationZ(f, t6), ooe.z = r, _y = F.multiplyTransformation(_y, F.fromRotationTranslation(t6, ooe, YGe), _y); let d = XGe; d[0] = s; for (let p = 0; p < a; p++)for (let g = 0; g < n.length; g += 3)u = h.fromArray(n, g, u), u = Q.multiplyByVector(d, u, u), u = F.multiplyByPoint(_y, u, u), i.push(u.x, u.y, u.z); return i } var ZGe = new h; function n6(e, t, n, i, o, r, s) { for (let a = 0; a < e.length; a += 3) { let c = h.fromArray(e, a, ZGe); i = Xm(c, t, n, i, o, r[a / 3], s, 1) } return i } function QGe(e, t) { let n = e.length, i = new Array(n * 6), o = 0, r = t.x + t.width / 2, s = t.y + t.height / 2, a = e[0]; i[o++] = a.x - r, i[o++] = 0, i[o++] = a.y - s; for (let c = 1; c < n; c++) { a = e[c]; let u = a.x - r, f = a.y - s; i[o++] = u, i[o++] = 0, i[o++] = f, i[o++] = u, i[o++] = 0, i[o++] = f } return a = e[0], i[o++] = a.x - r, i[o++] = 0, i[o++] = a.y - s, i } function roe(e, t) { let n = e.length, i = new Array(n * 3), o = 0, r = t.x + t.width / 2, s = t.y + t.height / 2; for (let a = 0; a < n; a++)i[o++] = e[a].x - r, i[o++] = 0, i[o++] = e[a].y - s; return i } var soe = new Be, aoe = new h, coe = new Q; function loe(e, t, n, i, o, r, s, a, c, u) { let f = h.angleBetween(h.subtract(t, e, Hx), h.subtract(n, e, EF)), d = i === Ti.BEVELED ? 0 : Math.ceil(f / I.toRadians(5)), p; o ? p = Q.fromQuaternion(Be.fromAxisAngle(h.negate(e, Hx), f / (d + 1), soe), coe) : p = Q.fromQuaternion(Be.fromAxisAngle(e, f / (d + 1), soe), coe); let g, m; if (t = h.clone(t, aoe), d > 0) { let A = u ? 2 : 1; for (let C = 0; C < d; C++)t = Q.multiplyByVector(p, t, t), g = h.subtract(t, e, Hx), g = h.normalize(g, g), o || (g = h.negate(g, g)), m = r.scaleToGeodeticSurface(t, EF), s = Xm(m, g, a, s, r, c, 1, A) } else g = h.subtract(t, e, Hx), g = h.normalize(g, g), o || (g = h.negate(g, g)), m = r.scaleToGeodeticSurface(t, EF), s = Xm(m, g, a, s, r, c, 1, 1), n = h.clone(n, aoe), g = h.subtract(n, e, Hx), g = h.normalize(g, g), o || (g = h.negate(g, g)), m = r.scaleToGeodeticSurface(n, EF), s = Xm(m, g, a, s, r, c, 1, 1); return s } Ew.removeDuplicatesFromShape = function (e) { let t = e.length, n = []; for (let i = t - 1, o = 0; o < t; i = o++) { let r = e[i], s = e[o]; H.equals(r, s) || n.push(s) } return n }; Ew.angleIsGreaterThanPi = function (e, t, n, i) { let o = new pa(n, i), r = o.projectPointOntoPlane(h.add(n, e, bF), bF), s = o.projectPointOntoPlane(h.add(n, t, SF), SF); return s.x * r.y - s.y * r.x >= 0 }; var $Ge = new h, e8e = new h; Ew.computePositions = function (e, t, n, i, o) { let r = i._ellipsoid, s = WGe(e, r), a = i._granularity, c = i._cornerType, u = o ? QGe(t, n) : roe(t, n), f = o ? roe(t, n) : void 0, d = n.height / 2, p = n.width / 2, g = e.length, m = [], A = o ? [] : void 0, C = LGe, x = FGe, T = NGe, b = VGe, S = kGe, D = UGe, P = zGe, B = HGe, R = GGe, M = e[0], L = e[1]; b = r.geodeticSurfaceNormal(M, b), C = h.subtract(L, M, C), C = h.normalize(C, C), B = h.cross(b, C, B), B = h.normalize(B, B); let _ = s[0], E = s[1]; o && (A = Xm(M, B, f, A, r, _ + d, 1, 1)), R = h.clone(M, R), M = L, x = h.negate(C, x); let w, v; for (let z = 1; z < g - 1; z++) { let k = o ? 2 : 1; if (L = e[z + 1], M.equals(L)) { Pt("Positions are too close and are considered equivalent with rounding error."); continue } C = h.subtract(L, M, C), C = h.normalize(C, C), T = h.add(C, x, T), T = h.normalize(T, T), b = r.geodeticSurfaceNormal(M, b); let G = h.multiplyByScalar(b, h.dot(C, b), $Ge); h.subtract(C, G, G), h.normalize(G, G); let N = h.multiplyByScalar(b, h.dot(x, b), e8e); if (h.subtract(x, N, N), h.normalize(N, N), !I.equalsEpsilon(Math.abs(h.dot(G, N)), 1, I.EPSILON7)) { T = h.cross(T, b, T), T = h.cross(b, T, T), T = h.normalize(T, T); let q = 1 / Math.max(.25, h.magnitude(h.cross(T, x, Hx))), J = Ew.angleIsGreaterThanPi(C, x, M, r); J ? (S = h.add(M, h.multiplyByScalar(T, q * p, T), S), D = h.add(S, h.multiplyByScalar(B, p, D), D), Ps[0] = h.clone(R, Ps[0]), Ps[1] = h.clone(D, Ps[1]), w = e6(Ps, _ + d, E + d, a), v = xi.generateArc({ positions: Ps, granularity: a, ellipsoid: r }), m = n6(v, B, u, m, r, w, 1), B = h.cross(b, C, B), B = h.normalize(B, B), P = h.add(S, h.multiplyByScalar(B, p, P), P), c === Ti.ROUNDED || c === Ti.BEVELED ? loe(S, D, P, c, J, r, m, u, E + d, o) : (T = h.negate(T, T), m = Xm(M, T, u, m, r, E + d, q, k)), R = h.clone(P, R)) : (S = h.add(M, h.multiplyByScalar(T, q * p, T), S), D = h.add(S, h.multiplyByScalar(B, -p, D), D), Ps[0] = h.clone(R, Ps[0]), Ps[1] = h.clone(D, Ps[1]), w = e6(Ps, _ + d, E + d, a), v = xi.generateArc({ positions: Ps, granularity: a, ellipsoid: r }), m = n6(v, B, u, m, r, w, 1), B = h.cross(b, C, B), B = h.normalize(B, B), P = h.add(S, h.multiplyByScalar(B, -p, P), P), c === Ti.ROUNDED || c === Ti.BEVELED ? loe(S, D, P, c, J, r, m, u, E + d, o) : m = Xm(M, T, u, m, r, E + d, q, k), R = h.clone(P, R)), x = h.negate(C, x) } else m = Xm(R, B, u, m, r, _ + d, 1, 1), R = M; _ = E, E = s[z + 1], M = L } Ps[0] = h.clone(R, Ps[0]), Ps[1] = h.clone(M, Ps[1]), w = e6(Ps, _ + d, E + d, a), v = xi.generateArc({ positions: Ps, granularity: a, ellipsoid: r }), m = n6(v, B, u, m, r, w, 1), o && (A = Xm(M, B, f, A, r, E + d, 1, 1)), g = m.length; let O = o ? g + A.length : g, V = new Float64Array(O); return V.set(m), o && V.set(A, g), V }; var oh = Ew; var o6 = {}, Gx = new h, moe = new h, t8e = new h, uoe = new h, lc = [new h, new h], poe = new h, _oe = new h, goe = new h, n8e = new h, i8e = new h, o8e = new h, r8e = new h, s8e = new h, a8e = new h, c8e = new h, foe = new Be, doe = new Q; function wF(e, t, n, i, o) { let r = h.angleBetween(h.subtract(t, e, Gx), h.subtract(n, e, moe)), s = i === Ti.BEVELED ? 1 : Math.ceil(r / I.toRadians(5)) + 1, a = s * 3, c = new Array(a); c[a - 3] = n.x, c[a - 2] = n.y, c[a - 1] = n.z; let u; o ? u = Q.fromQuaternion(Be.fromAxisAngle(h.negate(e, Gx), r / s, foe), doe) : u = Q.fromQuaternion(Be.fromAxisAngle(e, r / s, foe), doe); let f = 0; t = h.clone(t, Gx); for (let d = 0; d < s; d++)t = Q.multiplyByVector(u, t, t), c[f++] = t.x, c[f++] = t.y, c[f++] = t.z; return c } function l8e(e) { let t = poe, n = _oe, i = goe, o = e[1]; n = h.fromArray(e[1], o.length - 3, n), i = h.fromArray(e[0], 0, i), t = h.midpoint(n, i, t); let r = wF(t, n, i, Ti.ROUNDED, !1), s = e.length - 1, a = e[s - 1]; o = e[s], n = h.fromArray(a, a.length - 3, n), i = h.fromArray(o, 0, i), t = h.midpoint(n, i, t); let c = wF(t, n, i, Ti.ROUNDED, !1); return [r, c] } function hoe(e, t, n, i) { let o = Gx; return i ? o = h.add(e, t, o) : (t = h.negate(t, t), o = h.add(e, t, o)), [o.x, o.y, o.z, n.x, n.y, n.z] } function i6(e, t, n, i) { let o = new Array(e.length), r = new Array(e.length), s = h.multiplyByScalar(t, n, Gx), a = h.negate(s, moe), c = 0, u = e.length - 1; for (let f = 0; f < e.length; f += 3) { let d = h.fromArray(e, f, t8e), p = h.add(d, a, uoe); o[c++] = p.x, o[c++] = p.y, o[c++] = p.z; let g = h.add(d, s, uoe); r[u--] = g.z, r[u--] = g.y, r[u--] = g.x } return i.push(o, r), i } o6.addAttribute = function (e, t, n, i) { let o = t.x, r = t.y, s = t.z; l(n) && (e[n] = o, e[n + 1] = r, e[n + 2] = s), l(i) && (e[i] = s, e[i - 1] = r, e[i - 2] = o) }; var u8e = new h, f8e = new h; o6.computePositions = function (e) { let t = e.granularity, n = e.positions, i = e.ellipsoid, o = e.width / 2, r = e.cornerType, s = e.saveAttributes, a = poe, c = _oe, u = goe, f = n8e, d = i8e, p = o8e, g = r8e, m = s8e, A = a8e, C = c8e, x = [], T = s ? [] : void 0, b = s ? [] : void 0, S = n[0], D = n[1]; c = h.normalize(h.subtract(D, S, c), c), a = i.geodeticSurfaceNormal(S, a), f = h.normalize(h.cross(a, c, f), f), s && (T.push(f.x, f.y, f.z), b.push(a.x, a.y, a.z)), g = h.clone(S, g), S = D, u = h.negate(c, u); let P, B = [], R, M = n.length; for (R = 1; R < M - 1; R++) { a = i.geodeticSurfaceNormal(S, a), D = n[R + 1], c = h.normalize(h.subtract(D, S, c), c), d = h.normalize(h.add(c, u, d), d); let _ = h.multiplyByScalar(a, h.dot(c, a), u8e); h.subtract(c, _, _), h.normalize(_, _); let E = h.multiplyByScalar(a, h.dot(u, a), f8e); if (h.subtract(u, E, E), h.normalize(E, E), !I.equalsEpsilon(Math.abs(h.dot(_, E)), 1, I.EPSILON7)) { d = h.cross(d, a, d), d = h.cross(a, d, d), d = h.normalize(d, d); let v = o / Math.max(.25, h.magnitude(h.cross(d, u, Gx))), O = oh.angleIsGreaterThanPi(c, u, S, i); d = h.multiplyByScalar(d, v, d), O ? (m = h.add(S, d, m), C = h.add(m, h.multiplyByScalar(f, o, C), C), A = h.add(m, h.multiplyByScalar(f, o * 2, A), A), lc[0] = h.clone(g, lc[0]), lc[1] = h.clone(C, lc[1]), P = xi.generateArc({ positions: lc, granularity: t, ellipsoid: i }), x = i6(P, f, o, x), s && (T.push(f.x, f.y, f.z), b.push(a.x, a.y, a.z)), p = h.clone(A, p), f = h.normalize(h.cross(a, c, f), f), A = h.add(m, h.multiplyByScalar(f, o * 2, A), A), g = h.add(m, h.multiplyByScalar(f, o, g), g), r === Ti.ROUNDED || r === Ti.BEVELED ? B.push({ leftPositions: wF(m, p, A, r, O) }) : B.push({ leftPositions: hoe(S, h.negate(d, d), A, O) })) : (A = h.add(S, d, A), C = h.add(A, h.negate(h.multiplyByScalar(f, o, C), C), C), m = h.add(A, h.negate(h.multiplyByScalar(f, o * 2, m), m), m), lc[0] = h.clone(g, lc[0]), lc[1] = h.clone(C, lc[1]), P = xi.generateArc({ positions: lc, granularity: t, ellipsoid: i }), x = i6(P, f, o, x), s && (T.push(f.x, f.y, f.z), b.push(a.x, a.y, a.z)), p = h.clone(m, p), f = h.normalize(h.cross(a, c, f), f), m = h.add(A, h.negate(h.multiplyByScalar(f, o * 2, m), m), m), g = h.add(A, h.negate(h.multiplyByScalar(f, o, g), g), g), r === Ti.ROUNDED || r === Ti.BEVELED ? B.push({ rightPositions: wF(A, p, m, r, O) }) : B.push({ rightPositions: hoe(S, d, m, O) })), u = h.negate(c, u) } S = D } a = i.geodeticSurfaceNormal(S, a), lc[0] = h.clone(g, lc[0]), lc[1] = h.clone(S, lc[1]), P = xi.generateArc({ positions: lc, granularity: t, ellipsoid: i }), x = i6(P, f, o, x), s && (T.push(f.x, f.y, f.z), b.push(a.x, a.y, a.z)); let L; return r === Ti.ROUNDED && (L = l8e(x)), { positions: x, corners: B, lefts: T, normals: b, endPositions: L } }; var vi = o6; var Coe = new h, xoe = new h, DF = new h, vF = new h, d8e = new h, Toe = new h, G_ = new h, Wx = new h; function Eoe(e, t) { for (let n = 0; n < e.length; n++)e[n] = t.scaleToGeodeticSurface(e[n], e[n]); return e } function Lf(e, t, n, i, o, r) { let s = e.normals, a = e.tangents, c = e.bitangents, u = h.normalize(h.cross(n, t, G_), G_); r.normal && vi.addAttribute(s, t, i, o), r.tangent && vi.addAttribute(a, u, i, o), r.bitangent && vi.addAttribute(c, n, i, o) } function boe(e, t, n) { let i = e.positions, o = e.corners, r = e.endPositions, s = e.lefts, a = e.normals, c = new sn, u, f = 0, d = 0, p, g = 0, m; for (p = 0; p < i.length; p += 2)m = i[p].length - 3, f += m, g += m * 2, d += i[p + 1].length - 3; for (f += 3, d += 3, p = 0; p < o.length; p++) { u = o[p]; let Z = o[p].leftPositions; l(Z) ? (m = Z.length, f += m, g += m) : (m = o[p].rightPositions.length, d += m, g += m) } let A = l(r), C; A && (C = r[0].length - 3, f += C, d += C, C /= 3, g += C * 6); let x = f + d, T = new Float64Array(x), b = t.normal ? new Float32Array(x) : void 0, S = t.tangent ? new Float32Array(x) : void 0, D = t.bitangent ? new Float32Array(x) : void 0, P = { normals: b, tangents: S, bitangents: D }, B = 0, R = x - 1, M, L, _, E, w = Coe, v = xoe, O, V, z = C / 2, k = Me.createTypedArray(x / 3, g), G = 0; if (A) { V = DF, O = vF; let Z = r[0]; for (w = h.fromArray(a, 0, w), v = h.fromArray(s, 0, v), p = 0; p < z; p++)V = h.fromArray(Z, (z - 1 - p) * 3, V), O = h.fromArray(Z, (z + p) * 3, O), vi.addAttribute(T, O, B), vi.addAttribute(T, V, void 0, R), Lf(P, w, v, B, R, t), L = B / 3, E = L + 1, M = (R - 2) / 3, _ = M - 1, k[G++] = M, k[G++] = L, k[G++] = _, k[G++] = _, k[G++] = L, k[G++] = E, B += 3, R -= 3 } let N = 0, X = 0, q = i[N++], J = i[N++]; T.set(q, B), T.set(J, R - J.length + 1), v = h.fromArray(s, X, v); let W, K; for (m = J.length - 3, p = 0; p < m; p += 3)W = n.geodeticSurfaceNormal(h.fromArray(q, p, G_), G_), K = n.geodeticSurfaceNormal(h.fromArray(J, m - p, Wx), Wx), w = h.normalize(h.add(W, K, w), w), Lf(P, w, v, B, R, t), L = B / 3, E = L + 1, M = (R - 2) / 3, _ = M - 1, k[G++] = M, k[G++] = L, k[G++] = _, k[G++] = _, k[G++] = L, k[G++] = E, B += 3, R -= 3; for (W = n.geodeticSurfaceNormal(h.fromArray(q, m, G_), G_), K = n.geodeticSurfaceNormal(h.fromArray(J, m, Wx), Wx), w = h.normalize(h.add(W, K, w), w), X += 3, p = 0; p < o.length; p++) { let Z; u = o[p]; let de = u.leftPositions, pe = u.rightPositions, oe, ue, ge = Toe, Ee = DF, Ie = vF; if (w = h.fromArray(a, X, w), l(de)) { for (Lf(P, w, v, void 0, R, t), R -= 3, oe = E, ue = _, Z = 0; Z < de.length / 3; Z++)ge = h.fromArray(de, Z * 3, ge), k[G++] = oe, k[G++] = ue - Z - 1, k[G++] = ue - Z, vi.addAttribute(T, ge, void 0, R), Ee = h.fromArray(T, (ue - Z - 1) * 3, Ee), Ie = h.fromArray(T, oe * 3, Ie), v = h.normalize(h.subtract(Ee, Ie, v), v), Lf(P, w, v, void 0, R, t), R -= 3; ge = h.fromArray(T, oe * 3, ge), Ee = h.subtract(h.fromArray(T, ue * 3, Ee), ge, Ee), Ie = h.subtract(h.fromArray(T, (ue - Z) * 3, Ie), ge, Ie), v = h.normalize(h.add(Ee, Ie, v), v), Lf(P, w, v, B, void 0, t), B += 3 } else { for (Lf(P, w, v, B, void 0, t), B += 3, oe = _, ue = E, Z = 0; Z < pe.length / 3; Z++)ge = h.fromArray(pe, Z * 3, ge), k[G++] = oe, k[G++] = ue + Z, k[G++] = ue + Z + 1, vi.addAttribute(T, ge, B), Ee = h.fromArray(T, oe * 3, Ee), Ie = h.fromArray(T, (ue + Z) * 3, Ie), v = h.normalize(h.subtract(Ee, Ie, v), v), Lf(P, w, v, B, void 0, t), B += 3; ge = h.fromArray(T, oe * 3, ge), Ee = h.subtract(h.fromArray(T, (ue + Z) * 3, Ee), ge, Ee), Ie = h.subtract(h.fromArray(T, ue * 3, Ie), ge, Ie), v = h.normalize(h.negate(h.add(Ie, Ee, v), v), v), Lf(P, w, v, void 0, R, t), R -= 3 } for (q = i[N++], J = i[N++], q.splice(0, 3), J.splice(J.length - 3, 3), T.set(q, B), T.set(J, R - J.length + 1), m = J.length - 3, X += 3, v = h.fromArray(s, X, v), Z = 0; Z < J.length; Z += 3)W = n.geodeticSurfaceNormal(h.fromArray(q, Z, G_), G_), K = n.geodeticSurfaceNormal(h.fromArray(J, m - Z, Wx), Wx), w = h.normalize(h.add(W, K, w), w), Lf(P, w, v, B, R, t), E = B / 3, L = E - 1, _ = (R - 2) / 3, M = _ + 1, k[G++] = M, k[G++] = L, k[G++] = _, k[G++] = _, k[G++] = L, k[G++] = E, B += 3, R -= 3; B -= 3, R += 3 } if (w = h.fromArray(a, a.length - 3, w), Lf(P, w, v, B, R, t), A) { B += 3, R -= 3, V = DF, O = vF; let Z = r[1]; for (p = 0; p < z; p++)V = h.fromArray(Z, (C - p - 1) * 3, V), O = h.fromArray(Z, p * 3, O), vi.addAttribute(T, V, void 0, R), vi.addAttribute(T, O, B), Lf(P, w, v, B, R, t), E = B / 3, L = E - 1, _ = (R - 2) / 3, M = _ + 1, k[G++] = M, k[G++] = L, k[G++] = _, k[G++] = _, k[G++] = L, k[G++] = E, B += 3, R -= 3 } if (c.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: T }), t.st) { let Z = new Float32Array(x / 3 * 2), de, pe, oe = 0; if (A) { f /= 3, d /= 3; let ue = Math.PI / (C + 1); pe = 1 / (f - C + 1), de = 1 / (d - C + 1); let ge, Ee = C / 2; for (p = Ee + 1; p < C + 1; p++)ge = I.PI_OVER_TWO + ue * p, Z[oe++] = de * (1 + Math.cos(ge)), Z[oe++] = .5 * (1 + Math.sin(ge)); for (p = 1; p < d - C + 1; p++)Z[oe++] = p * de, Z[oe++] = 0; for (p = C; p > Ee; p--)ge = I.PI_OVER_TWO - p * ue, Z[oe++] = 1 - de * (1 + Math.cos(ge)), Z[oe++] = .5 * (1 + Math.sin(ge)); for (p = Ee; p > 0; p--)ge = I.PI_OVER_TWO - ue * p, Z[oe++] = 1 - pe * (1 + Math.cos(ge)), Z[oe++] = .5 * (1 + Math.sin(ge)); for (p = f - C; p > 0; p--)Z[oe++] = p * pe, Z[oe++] = 1; for (p = 1; p < Ee + 1; p++)ge = I.PI_OVER_TWO + ue * p, Z[oe++] = pe * (1 + Math.cos(ge)), Z[oe++] = .5 * (1 + Math.sin(ge)) } else { for (f /= 3, d /= 3, pe = 1 / (f - 1), de = 1 / (d - 1), p = 0; p < d; p++)Z[oe++] = p * de, Z[oe++] = 0; for (p = f; p > 0; p--)Z[oe++] = (p - 1) * pe, Z[oe++] = 1 } c.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: Z }) } return t.normal && (c.normal = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: P.normals })), t.tangent && (c.tangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: P.tangents })), t.bitangent && (c.bitangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: P.bitangents })), { attributes: c, indices: k } } function h8e(e, t) { if (!t.normal && !t.tangent && !t.bitangent && !t.st) return e; let n = e.position.values, i, o; (t.normal || t.bitangent) && (i = e.normal.values, o = e.bitangent.values); let r = e.position.values.length / 18, s = r * 3, a = r * 2, c = s * 2, u; if (t.normal || t.bitangent || t.tangent) { let f = t.normal ? new Float32Array(s * 6) : void 0, d = t.tangent ? new Float32Array(s * 6) : void 0, p = t.bitangent ? new Float32Array(s * 6) : void 0, g = Coe, m = xoe, A = DF, C = vF, x = d8e, T = Toe, b = c; for (u = 0; u < s; u += 3) { let S = b + c; g = h.fromArray(n, u, g), m = h.fromArray(n, u + s, m), A = h.fromArray(n, (u + 3) % s, A), m = h.subtract(m, g, m), A = h.subtract(A, g, A), C = h.normalize(h.cross(m, A, C), C), t.normal && (vi.addAttribute(f, C, S), vi.addAttribute(f, C, S + 3), vi.addAttribute(f, C, b), vi.addAttribute(f, C, b + 3)), (t.tangent || t.bitangent) && (T = h.fromArray(i, u, T), t.bitangent && (vi.addAttribute(p, T, S), vi.addAttribute(p, T, S + 3), vi.addAttribute(p, T, b), vi.addAttribute(p, T, b + 3)), t.tangent && (x = h.normalize(h.cross(T, C, x), x), vi.addAttribute(d, x, S), vi.addAttribute(d, x, S + 3), vi.addAttribute(d, x, b), vi.addAttribute(d, x, b + 3))), b += 6 } if (t.normal) { for (f.set(i), u = 0; u < s; u += 3)f[u + s] = -i[u], f[u + s + 1] = -i[u + 1], f[u + s + 2] = -i[u + 2]; e.normal.values = f } else e.normal = void 0; if (t.bitangent ? (p.set(o), p.set(o, s), e.bitangent.values = p) : e.bitangent = void 0, t.tangent) { let S = e.tangent.values; d.set(S), d.set(S, s), e.tangent.values = d } } if (t.st) { let f = e.st.values, d = new Float32Array(a * 6); d.set(f), d.set(f, a); let p = a * 2; for (let g = 0; g < 2; g++) { for (d[p++] = f[0], d[p++] = f[1], u = 2; u < a; u += 2) { let m = f[u], A = f[u + 1]; d[p++] = m, d[p++] = A, d[p++] = m, d[p++] = A } d[p++] = f[0], d[p++] = f[1] } e.st.values = d } return e } function r6(e, t, n) { n[t++] = e[0], n[t++] = e[1], n[t++] = e[2]; for (let i = 3; i < e.length; i += 3) { let o = e[i], r = e[i + 1], s = e[i + 2]; n[t++] = o, n[t++] = r, n[t++] = s, n[t++] = o, n[t++] = r, n[t++] = s } return n[t++] = e[0], n[t++] = e[1], n[t++] = e[2], n } function m8e(e, t) { let n = new we({ position: t.position, normal: t.normal || t.bitangent || e.shadowVolume, tangent: t.tangent, bitangent: t.normal || t.bitangent, st: t.st }), i = e.ellipsoid, o = vi.computePositions(e), r = boe(o, n, i), s = e.height, a = e.extrudedHeight, c = r.attributes, u = r.indices, f = c.position.values, d = f.length, p = new Float64Array(d * 6), g = new Float64Array(d); g.set(f); let m = new Float64Array(d * 4); f = ni.scaleToGeodeticHeight(f, s, i), m = r6(f, 0, m), g = ni.scaleToGeodeticHeight(g, a, i), m = r6(g, d * 2, m), p.set(f), p.set(g, d), p.set(m, d * 2), c.position.values = p, c = h8e(c, t); let A, C = d / 3; if (e.shadowVolume) { let M = c.normal.values; d = M.length; let L = new Float32Array(d * 6); for (A = 0; A < d; A++)M[A] = -M[A]; L.set(M, d), L = r6(M, d * 4, L), c.extrudeDirection = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: L }), t.normal || (c.normal = void 0) } if (l(e.offsetAttribute)) { let M = new Uint8Array(C * 6); if (e.offsetAttribute === Qt.TOP) M = M.fill(1, 0, C).fill(1, C * 2, C * 4); else { let L = e.offsetAttribute === Qt.NONE ? 0 : 1; M = M.fill(L) } c.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: M }) } let x = u.length, T = C + C, b = Me.createTypedArray(p.length / 3, x * 2 + T * 3); b.set(u); let S = x; for (A = 0; A < x; A += 3) { let M = u[A], L = u[A + 1], _ = u[A + 2]; b[S++] = _ + C, b[S++] = L + C, b[S++] = M + C } let D, P, B, R; for (A = 0; A < T; A += 2)D = A + T, P = D + T, B = D + 1, R = P + 1, b[S++] = D, b[S++] = P, b[S++] = B, b[S++] = B, b[S++] = P, b[S++] = R; return { attributes: c, indices: b } } var yoe = new h, bw = new h, Du = new he; function Aoe(e, t, n, i, o, r) { let s = h.subtract(t, e, yoe); h.normalize(s, s); let a = n.geodeticSurfaceNormal(e, bw), c = h.cross(s, a, yoe); h.multiplyByScalar(c, i, c); let u = o.latitude, f = o.longitude, d = r.latitude, p = r.longitude; h.add(e, c, bw), n.cartesianToCartographic(bw, Du); let g = Du.latitude, m = Du.longitude; u = Math.min(u, g), f = Math.min(f, m), d = Math.max(d, g), p = Math.max(p, m), h.subtract(e, c, bw), n.cartesianToCartographic(bw, Du), g = Du.latitude, m = Du.longitude, u = Math.min(u, g), f = Math.min(f, m), d = Math.max(d, g), p = Math.max(p, m), o.latitude = u, o.longitude = f, r.latitude = d, r.longitude = p } var wu = new h, Sw = new h, Wc = new he, jc = new he; function Soe(e, t, n, i, o) { e = Eoe(e, t); let r = _o(e, h.equalsEpsilon), s = r.length; if (s < 2 || n <= 0) return new ce; let a = n * .5; Wc.latitude = Number.POSITIVE_INFINITY, Wc.longitude = Number.POSITIVE_INFINITY, jc.latitude = Number.NEGATIVE_INFINITY, jc.longitude = Number.NEGATIVE_INFINITY; let c, u; if (i === Ti.ROUNDED) { let p = r[0]; h.subtract(p, r[1], wu), h.normalize(wu, wu), h.multiplyByScalar(wu, a, wu), h.add(p, wu, Sw), t.cartesianToCartographic(Sw, Du), c = Du.latitude, u = Du.longitude, Wc.latitude = Math.min(Wc.latitude, c), Wc.longitude = Math.min(Wc.longitude, u), jc.latitude = Math.max(jc.latitude, c), jc.longitude = Math.max(jc.longitude, u) } for (let p = 0; p < s - 1; ++p)Aoe(r[p], r[p + 1], t, a, Wc, jc); let f = r[s - 1]; h.subtract(f, r[s - 2], wu), h.normalize(wu, wu), h.multiplyByScalar(wu, a, wu), h.add(f, wu, Sw), Aoe(f, Sw, t, a, Wc, jc), i === Ti.ROUNDED && (t.cartesianToCartographic(Sw, Du), c = Du.latitude, u = Du.longitude, Wc.latitude = Math.min(Wc.latitude, c), Wc.longitude = Math.min(Wc.longitude, u), jc.latitude = Math.max(jc.latitude, c), jc.longitude = Math.max(jc.longitude, u)); let d = l(o) ? o : new ce; return d.north = jc.latitude, d.south = Wc.latitude, d.east = jc.longitude, d.west = Wc.longitude, d } function Jm(e) { e = y(e, y.EMPTY_OBJECT); let t = e.positions, n = e.width, i = y(e.height, 0), o = y(e.extrudedHeight, i); this._positions = t, this._ellipsoid = ie.clone(y(e.ellipsoid, ie.WGS84)), this._vertexFormat = we.clone(y(e.vertexFormat, we.DEFAULT)), this._width = n, this._height = Math.max(i, o), this._extrudedHeight = Math.min(i, o), this._cornerType = y(e.cornerType, Ti.ROUNDED), this._granularity = y(e.granularity, I.RADIANS_PER_DEGREE), this._shadowVolume = y(e.shadowVolume, !1), this._workerName = "createCorridorGeometry", this._offsetAttribute = e.offsetAttribute, this._rectangle = void 0, this.packedLength = 1 + t.length * h.packedLength + ie.packedLength + we.packedLength + 7 } Jm.pack = function (e, t, n) { n = y(n, 0); let i = e._positions, o = i.length; t[n++] = o; for (let r = 0; r < o; ++r, n += h.packedLength)h.pack(i[r], t, n); return ie.pack(e._ellipsoid, t, n), n += ie.packedLength, we.pack(e._vertexFormat, t, n), n += we.packedLength, t[n++] = e._width, t[n++] = e._height, t[n++] = e._extrudedHeight, t[n++] = e._cornerType, t[n++] = e._granularity, t[n++] = e._shadowVolume ? 1 : 0, t[n] = y(e._offsetAttribute, -1), t }; var woe = ie.clone(ie.UNIT_SPHERE), Doe = new we, Km = { positions: void 0, ellipsoid: woe, vertexFormat: Doe, width: void 0, height: void 0, extrudedHeight: void 0, cornerType: void 0, granularity: void 0, shadowVolume: void 0, offsetAttribute: void 0 }; Jm.unpack = function (e, t, n) { t = y(t, 0); let i = e[t++], o = new Array(i); for (let m = 0; m < i; ++m, t += h.packedLength)o[m] = h.unpack(e, t); let r = ie.unpack(e, t, woe); t += ie.packedLength; let s = we.unpack(e, t, Doe); t += we.packedLength; let a = e[t++], c = e[t++], u = e[t++], f = e[t++], d = e[t++], p = e[t++] === 1, g = e[t]; return l(n) ? (n._positions = o, n._ellipsoid = ie.clone(r, n._ellipsoid), n._vertexFormat = we.clone(s, n._vertexFormat), n._width = a, n._height = c, n._extrudedHeight = u, n._cornerType = f, n._granularity = d, n._shadowVolume = p, n._offsetAttribute = g === -1 ? void 0 : g, n) : (Km.positions = o, Km.width = a, Km.height = c, Km.extrudedHeight = u, Km.cornerType = f, Km.granularity = d, Km.shadowVolume = p, Km.offsetAttribute = g === -1 ? void 0 : g, new Jm(Km)) }; Jm.computeRectangle = function (e, t) { e = y(e, y.EMPTY_OBJECT); let n = e.positions, i = e.width, o = y(e.ellipsoid, ie.WGS84), r = y(e.cornerType, Ti.ROUNDED); return Soe(n, o, i, r, t) }; Jm.createGeometry = function (e) { let t = e._positions, n = e._width, i = e._ellipsoid; t = Eoe(t, i); let o = _o(t, h.equalsEpsilon); if (o.length < 2 || n <= 0) return; let r = e._height, s = e._extrudedHeight, a = !I.equalsEpsilon(r, s, 0, I.EPSILON2), c = e._vertexFormat, u = { ellipsoid: i, positions: o, width: n, cornerType: e._cornerType, granularity: e._granularity, saveAttributes: !0 }, f; if (a) u.height = r, u.extrudedHeight = s, u.shadowVolume = e._shadowVolume, u.offsetAttribute = e._offsetAttribute, f = m8e(u, c); else { let g = vi.computePositions(u); if (f = boe(g, c, i), f.attributes.position.values = ni.scaleToGeodeticHeight(f.attributes.position.values, r, i), l(e._offsetAttribute)) { let m = e._offsetAttribute === Qt.NONE ? 0 : 1, A = f.attributes.position.values.length, C = new Uint8Array(A / 3).fill(m); f.attributes.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: C }) } } let d = f.attributes, p = re.fromVertices(d.position.values, void 0, 3); return c.position || (f.attributes.position.values = void 0), new st({ attributes: d, indices: f.indices, primitiveType: Oe.TRIANGLES, boundingSphere: p, offsetAttribute: e._offsetAttribute }) }; Jm.createShadowVolume = function (e, t, n) { let i = e._granularity, o = e._ellipsoid, r = t(i, o), s = n(i, o); return new Jm({ positions: e._positions, width: e._width, cornerType: e._cornerType, ellipsoid: o, granularity: i, extrudedHeight: r, height: s, vertexFormat: we.POSITION_ONLY, shadowVolume: !0 }) }; Object.defineProperties(Jm.prototype, { rectangle: { get: function () { return l(this._rectangle) || (this._rectangle = Soe(this._positions, this._ellipsoid, this._width, this._cornerType)), this._rectangle } }, textureCoordinateRotationPoints: { get: function () { return [0, 0, 0, 1, 1, 0] } } }); var jx = Jm; var voe = new h, Poe = new h, p8e = new h; function _8e(e, t) { for (let n = 0; n < e.length; n++)e[n] = t.scaleToGeodeticSurface(e[n], e[n]); return e } function Ioe(e, t) { let n = [], i = e.positions, o = e.corners, r = e.endPositions, s = new sn, a, c = 0, u = 0, f, d = 0, p; for (f = 0; f < i.length; f += 2)p = i[f].length - 3, c += p, d += p / 3 * 4, u += i[f + 1].length - 3; for (c += 3, u += 3, f = 0; f < o.length; f++) { a = o[f]; let O = o[f].leftPositions; l(O) ? (p = O.length, c += p, d += p / 3 * 2) : (p = o[f].rightPositions.length, u += p, d += p / 3 * 2) } let g = l(r), m; g && (m = r[0].length - 3, c += m, u += m, m /= 3, d += m * 4); let A = c + u, C = new Float64Array(A), x = 0, T = A - 1, b, S, D, P, B, R, M = m / 2, L = Me.createTypedArray(A / 3, d + 4), _ = 0; if (L[_++] = x / 3, L[_++] = (T - 2) / 3, g) { n.push(x / 3), R = voe, B = Poe; let O = r[0]; for (f = 0; f < M; f++)R = h.fromArray(O, (M - 1 - f) * 3, R), B = h.fromArray(O, (M + f) * 3, B), vi.addAttribute(C, B, x), vi.addAttribute(C, R, void 0, T), S = x / 3, P = S + 1, b = (T - 2) / 3, D = b - 1, L[_++] = b, L[_++] = D, L[_++] = S, L[_++] = P, x += 3, T -= 3 } let E = 0, w = i[E++], v = i[E++]; for (C.set(w, x), C.set(v, T - v.length + 1), p = v.length - 3, n.push(x / 3, (T - 2) / 3), f = 0; f < p; f += 3)S = x / 3, P = S + 1, b = (T - 2) / 3, D = b - 1, L[_++] = b, L[_++] = D, L[_++] = S, L[_++] = P, x += 3, T -= 3; for (f = 0; f < o.length; f++) { let O; a = o[f]; let V = a.leftPositions, z = a.rightPositions, k, G = p8e; if (l(V)) { for (T -= 3, k = D, n.push(P), O = 0; O < V.length / 3; O++)G = h.fromArray(V, O * 3, G), L[_++] = k - O - 1, L[_++] = k - O, vi.addAttribute(C, G, void 0, T), T -= 3; n.push(k - Math.floor(V.length / 6)), t === Ti.BEVELED && n.push((T - 2) / 3 + 1), x += 3 } else { for (x += 3, k = P, n.push(D), O = 0; O < z.length / 3; O++)G = h.fromArray(z, O * 3, G), L[_++] = k + O, L[_++] = k + O + 1, vi.addAttribute(C, G, x), x += 3; n.push(k + Math.floor(z.length / 6)), t === Ti.BEVELED && n.push(x / 3 - 1), T -= 3 } for (w = i[E++], v = i[E++], w.splice(0, 3), v.splice(v.length - 3, 3), C.set(w, x), C.set(v, T - v.length + 1), p = v.length - 3, O = 0; O < v.length; O += 3)P = x / 3, S = P - 1, D = (T - 2) / 3, b = D + 1, L[_++] = b, L[_++] = D, L[_++] = S, L[_++] = P, x += 3, T -= 3; x -= 3, T += 3, n.push(x / 3, (T - 2) / 3) } if (g) { x += 3, T -= 3, R = voe, B = Poe; let O = r[1]; for (f = 0; f < M; f++)R = h.fromArray(O, (m - f - 1) * 3, R), B = h.fromArray(O, f * 3, B), vi.addAttribute(C, R, void 0, T), vi.addAttribute(C, B, x), P = x / 3, S = P - 1, D = (T - 2) / 3, b = D + 1, L[_++] = b, L[_++] = D, L[_++] = S, L[_++] = P, x += 3, T -= 3; n.push(x / 3) } else n.push(x / 3, (T - 2) / 3); return L[_++] = x / 3, L[_++] = (T - 2) / 3, s.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: C }), { attributes: s, indices: L, wallIndices: n } } function g8e(e) { let t = e.ellipsoid, n = vi.computePositions(e), i = Ioe(n, e.cornerType), o = i.wallIndices, r = e.height, s = e.extrudedHeight, a = i.attributes, c = i.indices, u = a.position.values, f = u.length, d = new Float64Array(f); d.set(u); let p = new Float64Array(f * 2); if (u = ni.scaleToGeodeticHeight(u, r, t), d = ni.scaleToGeodeticHeight(d, s, t), p.set(u), p.set(d, f), a.position.values = p, f /= 3, l(e.offsetAttribute)) { let b = new Uint8Array(f * 2); if (e.offsetAttribute === Qt.TOP) b = b.fill(1, 0, f); else { let S = e.offsetAttribute === Qt.NONE ? 0 : 1; b = b.fill(S) } a.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: b }) } let g, m = c.length, A = Me.createTypedArray(p.length / 3, (m + o.length) * 2); A.set(c); let C = m; for (g = 0; g < m; g += 2) { let b = c[g], S = c[g + 1]; A[C++] = b + f, A[C++] = S + f } let x, T; for (g = 0; g < o.length; g++)x = o[g], T = x + f, A[C++] = x, A[C++] = T; return { attributes: a, indices: A } } function ww(e) { e = y(e, y.EMPTY_OBJECT); let t = e.positions, n = e.width, i = y(e.height, 0), o = y(e.extrudedHeight, i); this._positions = t, this._ellipsoid = ie.clone(y(e.ellipsoid, ie.WGS84)), this._width = n, this._height = Math.max(i, o), this._extrudedHeight = Math.min(i, o), this._cornerType = y(e.cornerType, Ti.ROUNDED), this._granularity = y(e.granularity, I.RADIANS_PER_DEGREE), this._offsetAttribute = e.offsetAttribute, this._workerName = "createCorridorOutlineGeometry", this.packedLength = 1 + t.length * h.packedLength + ie.packedLength + 6 } ww.pack = function (e, t, n) { n = y(n, 0); let i = e._positions, o = i.length; t[n++] = o; for (let r = 0; r < o; ++r, n += h.packedLength)h.pack(i[r], t, n); return ie.pack(e._ellipsoid, t, n), n += ie.packedLength, t[n++] = e._width, t[n++] = e._height, t[n++] = e._extrudedHeight, t[n++] = e._cornerType, t[n++] = e._granularity, t[n] = y(e._offsetAttribute, -1), t }; var Ooe = ie.clone(ie.UNIT_SPHERE), W_ = { positions: void 0, ellipsoid: Ooe, width: void 0, height: void 0, extrudedHeight: void 0, cornerType: void 0, granularity: void 0, offsetAttribute: void 0 }; ww.unpack = function (e, t, n) { t = y(t, 0); let i = e[t++], o = new Array(i); for (let p = 0; p < i; ++p, t += h.packedLength)o[p] = h.unpack(e, t); let r = ie.unpack(e, t, Ooe); t += ie.packedLength; let s = e[t++], a = e[t++], c = e[t++], u = e[t++], f = e[t++], d = e[t]; return l(n) ? (n._positions = o, n._ellipsoid = ie.clone(r, n._ellipsoid), n._width = s, n._height = a, n._extrudedHeight = c, n._cornerType = u, n._granularity = f, n._offsetAttribute = d === -1 ? void 0 : d, n) : (W_.positions = o, W_.width = s, W_.height = a, W_.extrudedHeight = c, W_.cornerType = u, W_.granularity = f, W_.offsetAttribute = d === -1 ? void 0 : d, new ww(W_)) }; ww.createGeometry = function (e) { let t = e._positions, n = e._width, i = e._ellipsoid; t = _8e(t, i); let o = _o(t, h.equalsEpsilon); if (o.length < 2 || n <= 0) return; let r = e._height, s = e._extrudedHeight, a = !I.equalsEpsilon(r, s, 0, I.EPSILON2), c = { ellipsoid: i, positions: o, width: n, cornerType: e._cornerType, granularity: e._granularity, saveAttributes: !1 }, u; if (a) c.height = r, c.extrudedHeight = s, c.offsetAttribute = e._offsetAttribute, u = g8e(c); else { let p = vi.computePositions(c); if (u = Ioe(p, c.cornerType), u.attributes.position.values = ni.scaleToGeodeticHeight(u.attributes.position.values, r, i), l(e._offsetAttribute)) { let g = u.attributes.position.values.length, m = e._offsetAttribute === Qt.NONE ? 0 : 1, A = new Uint8Array(g / 3).fill(m); u.attributes.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: A }) } } let f = u.attributes, d = re.fromVertices(f.position.values, void 0, 3); return new st({ attributes: f, indices: u.indices, primitiveType: Oe.LINES, boundingSphere: d, offsetAttribute: e._offsetAttribute }) }; var PF = ww; var y8e = new Yn(0); function uc(e) { ei.call(this, e), this._zIndex = 0, this._terrainOffsetProperty = void 0 } l(Object.create) && (uc.prototype = Object.create(ei.prototype), uc.prototype.constructor = uc); Object.defineProperties(uc.prototype, { zIndex: { get: function () { return this._zIndex } }, terrainOffsetProperty: { get: function () { return this._terrainOffsetProperty } } }); uc.prototype._isOnTerrain = function (e, t) { return this._fillEnabled && !l(t.height) && !l(t.extrudedHeight) && Rc.isSupported(this._scene) }; uc.prototype._getIsClosed = function (e) { let t = e.height, n = e.extrudedHeight; return t === 0 || l(n) && n !== t }; uc.prototype._computeCenter = ye.throwInstantiationError; uc.prototype._onEntityPropertyChanged = function (e, t, n, i) { if (ei.prototype._onEntityPropertyChanged.call(this, e, t, n, i), this._observedPropertyNames.indexOf(t) === -1) return; let o = this._entity[this._geometryPropertyName]; if (!l(o)) return; l(o.zIndex) && (l(o.height) || l(o.extrudedHeight)) && Pt(Pt.geometryZIndex), this._zIndex = y(o.zIndex, y8e), l(this._terrainOffsetProperty) && (this._terrainOffsetProperty.destroy(), this._terrainOffsetProperty = void 0); let r = o.heightReference, s = o.extrudedHeightReference; if (l(r) || l(s)) { let a = new Nd(this._computeCenter.bind(this), !this._dynamic); this._terrainOffsetProperty = new FC(this._scene, a, r, s) } }; uc.prototype.destroy = function () { l(this._terrainOffsetProperty) && (this._terrainOffsetProperty.destroy(), this._terrainOffsetProperty = void 0), ei.prototype.destroy.call(this) }; uc.getGeometryHeight = function (e, t) { if (!l(e)) { t !== ze.NONE && Pt(Pt.geometryHeightReference); return } return t !== ze.CLAMP_TO_GROUND ? e : 0 }; uc.getGeometryExtrudedHeight = function (e, t) { if (!l(e)) { t !== ze.NONE && Pt(Pt.geometryExtrudedHeightReference); return } return t !== ze.CLAMP_TO_GROUND ? e : uc.CLAMP_TO_GROUND }; uc.CLAMP_TO_GROUND = "clamp"; uc.computeGeometryOffsetAttribute = function (e, t, n, i) { (!l(e) || !l(t)) && (t = ze.NONE), (!l(n) || !l(i)) && (i = ze.NONE); let o = 0; if (t !== ze.NONE && o++, i === ze.RELATIVE_TO_GROUND && o++, o === 2) return Qt.ALL; if (o === 1) return Qt.TOP }; var zn = uc; var Boe = new U, Roe = h.ZERO, Moe = new h, Loe = new ce; function A8e(e) { this.id = e, this.vertexFormat = void 0, this.positions = void 0, this.width = void 0, this.cornerType = void 0, this.height = void 0, this.extrudedHeight = void 0, this.granularity = void 0, this.offsetAttribute = void 0 } function Ff(e, t) { zn.call(this, { entity: e, scene: t, geometryOptions: new A8e(e), geometryPropertyName: "corridor", observedPropertyNames: ["availability", "corridor"] }), this._onEntityPropertyChanged(e, "corridor", e.corridor, void 0) } l(Object.create) && (Ff.prototype = Object.create(zn.prototype), Ff.prototype.constructor = Ff); Ff.prototype.createFillGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = { show: new fn(n && t.isShowing && this._showProperty.getValue(e) && this._fillProperty.getValue(e)), distanceDisplayCondition: Mn.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(e)), offset: void 0, color: void 0 }; if (this._materialProperty instanceof Ot) { let o; l(this._materialProperty.color) && (this._materialProperty.color.isConstant || n) && (o = this._materialProperty.color.getValue(e, Boe)), l(o) || (o = U.WHITE), i.color = Bt.fromColor(o) } return l(this._options.offsetAttribute) && (i.offset = zi.fromCartesian3(j.getValueOrDefault(this._terrainOffsetProperty, e, Roe, Moe))), new At({ id: t, geometry: new jx(this._options), attributes: i }) }; Ff.prototype.createOutlineGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = j.getValueOrDefault(this._outlineColorProperty, e, U.BLACK, Boe), o = { show: new fn(n && t.isShowing && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)), color: Bt.fromColor(i), distanceDisplayCondition: Mn.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(e)), offset: void 0 }; return l(this._options.offsetAttribute) && (o.offset = zi.fromCartesian3(j.getValueOrDefault(this._terrainOffsetProperty, e, Roe, Moe))), new At({ id: t, geometry: new PF(this._options), attributes: o }) }; Ff.prototype._computeCenter = function (e, t) { let n = j.getValueOrUndefined(this._entity.corridor.positions, e); if (!(!l(n) || n.length === 0)) return h.clone(n[Math.floor(n.length / 2)], t) }; Ff.prototype._isHidden = function (e, t) { return !l(t.positions) || !l(t.width) || ei.prototype._isHidden.call(this, e, t) }; Ff.prototype._isDynamic = function (e, t) { return !t.positions.isConstant || !j.isConstant(t.height) || !j.isConstant(t.extrudedHeight) || !j.isConstant(t.granularity) || !j.isConstant(t.width) || !j.isConstant(t.outlineWidth) || !j.isConstant(t.cornerType) || !j.isConstant(t.zIndex) || this._onTerrain && !j.isConstant(this._materialProperty) && !(this._materialProperty instanceof Ot) }; Ff.prototype._setStaticOptions = function (e, t) { let n = j.getValueOrUndefined(t.height, ke.MINIMUM_VALUE), i = j.getValueOrDefault(t.heightReference, ke.MINIMUM_VALUE, ze.NONE), o = j.getValueOrUndefined(t.extrudedHeight, ke.MINIMUM_VALUE), r = j.getValueOrDefault(t.extrudedHeightReference, ke.MINIMUM_VALUE, ze.NONE); l(o) && !l(n) && (n = 0); let s = this._options; s.vertexFormat = this._materialProperty instanceof Ot ? $t.VERTEX_FORMAT : eo.MaterialSupport.TEXTURED.vertexFormat, s.positions = t.positions.getValue(ke.MINIMUM_VALUE, s.positions), s.width = t.width.getValue(ke.MINIMUM_VALUE), s.granularity = j.getValueOrUndefined(t.granularity, ke.MINIMUM_VALUE), s.cornerType = j.getValueOrUndefined(t.cornerType, ke.MINIMUM_VALUE), s.offsetAttribute = zn.computeGeometryOffsetAttribute(n, i, o, r), s.height = zn.getGeometryHeight(n, i), o = zn.getGeometryExtrudedHeight(o, r), o === zn.CLAMP_TO_GROUND && (o = oi.getMinimumMaximumHeights(jx.computeRectangle(s, Loe)).minimumTerrainHeight), s.extrudedHeight = o }; Ff.DynamicGeometryUpdater = qx; function qx(e, t, n) { $n.call(this, e, t, n) } l(Object.create) && (qx.prototype = Object.create($n.prototype), qx.prototype.constructor = qx); qx.prototype._isHidden = function (e, t, n) { let i = this._options; return !l(i.positions) || !l(i.width) || $n.prototype._isHidden.call(this, e, t, n) }; qx.prototype._setOptions = function (e, t, n) { let i = this._options, o = j.getValueOrUndefined(t.height, n), r = j.getValueOrDefault(t.heightReference, n, ze.NONE), s = j.getValueOrUndefined(t.extrudedHeight, n), a = j.getValueOrDefault(t.extrudedHeightReference, n, ze.NONE); l(s) && !l(o) && (o = 0), i.positions = j.getValueOrUndefined(t.positions, n), i.width = j.getValueOrUndefined(t.width, n), i.granularity = j.getValueOrUndefined(t.granularity, n), i.cornerType = j.getValueOrUndefined(t.cornerType, n), i.offsetAttribute = zn.computeGeometryOffsetAttribute(o, r, s, a), i.height = zn.getGeometryHeight(o, r), s = zn.getGeometryExtrudedHeight(s, a), s === zn.CLAMP_TO_GROUND && (s = oi.getMinimumMaximumHeights(jx.computeRectangle(i, Loe)).minimumTerrainHeight), i.extrudedHeight = s }; var IF = Ff; function OF() { ye.throwInstantiationError() } Object.defineProperties(OF.prototype, { name: { get: ye.throwInstantiationError }, clock: { get: ye.throwInstantiationError }, entities: { get: ye.throwInstantiationError }, isLoading: { get: ye.throwInstantiationError }, changedEvent: { get: ye.throwInstantiationError }, errorEvent: { get: ye.throwInstantiationError }, loadingEvent: { get: ye.throwInstantiationError }, show: { get: ye.throwInstantiationError }, clustering: { get: ye.throwInstantiationError } }); OF.prototype.update = function (e) { ye.throwInstantiationError() }; OF.setLoading = function (e, t) { e._isLoading !== t && (t ? e._entityCollection.suspendEvents() : e._entityCollection.resumeEvents(), e._isLoading = t, e._loading.raiseEvent(e, t)) }; var Or = OF; function rh(e, t) { this._ellipsoid = e, this._cameraPosition = new h, this._cameraPositionInScaledSpace = new h, this._distanceToLimbInScaledSpaceSquared = 0, l(t) && (this.cameraPosition = t) } Object.defineProperties(rh.prototype, { ellipsoid: { get: function () { return this._ellipsoid } }, cameraPosition: { get: function () { return this._cameraPosition }, set: function (e) { let n = this._ellipsoid.transformPositionToScaledSpace(e, this._cameraPositionInScaledSpace), i = h.magnitudeSquared(n) - 1; h.clone(e, this._cameraPosition), this._cameraPositionInScaledSpace = n, this._distanceToLimbInScaledSpaceSquared = i } } }); var Foe = new h; rh.prototype.isPointVisible = function (e) { let n = this._ellipsoid.transformPositionToScaledSpace(e, Foe); return a6(n, this._cameraPositionInScaledSpace, this._distanceToLimbInScaledSpaceSquared) }; rh.prototype.isScaledSpacePointVisible = function (e) { return a6(e, this._cameraPositionInScaledSpace, this._distanceToLimbInScaledSpaceSquared) }; var C8e = new h; rh.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid = function (e, t) { let n = this._ellipsoid, i, o; return l(t) && t < 0 && n.minimumRadius > -t ? (o = C8e, o.x = this._cameraPosition.x / (n.radii.x + t), o.y = this._cameraPosition.y / (n.radii.y + t), o.z = this._cameraPosition.z / (n.radii.z + t), i = o.x * o.x + o.y * o.y + o.z * o.z - 1) : (o = this._cameraPositionInScaledSpace, i = this._distanceToLimbInScaledSpaceSquared), a6(e, o, i) }; rh.prototype.computeHorizonCullingPoint = function (e, t, n) { return koe(this._ellipsoid, e, t, n) }; var Noe = ie.clone(ie.UNIT_SPHERE); rh.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid = function (e, t, n, i) { let o = Voe(this._ellipsoid, n, Noe); return koe(o, e, t, i) }; rh.prototype.computeHorizonCullingPointFromVertices = function (e, t, n, i, o) { return Uoe(this._ellipsoid, e, t, n, i, o) }; rh.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid = function (e, t, n, i, o, r) { let s = Voe(this._ellipsoid, o, Noe); return Uoe(s, e, t, n, i, r) }; var x8e = []; rh.prototype.computeHorizonCullingPointFromRectangle = function (e, t, n) { let i = ce.subsample(e, t, 0, x8e), o = re.fromPoints(i); if (!(h.magnitude(o.center) < .1 * t.minimumRadius)) return this.computeHorizonCullingPoint(o.center, i, n) }; var T8e = new h; function Voe(e, t, n) { if (l(t) && t < 0 && e.minimumRadius > -t) { let i = h.fromElements(e.radii.x + t, e.radii.y + t, e.radii.z + t, T8e); e = ie.fromCartesian3(i, n) } return e } function koe(e, t, n, i) { l(i) || (i = new h); let o = Goe(e, t), r = 0; for (let s = 0, a = n.length; s < a; ++s) { let c = n[s], u = zoe(e, c, o); if (u < 0) return; r = Math.max(r, u) } return Hoe(o, r, i) } var BF = new h; function Uoe(e, t, n, i, o, r) { l(r) || (r = new h), i = y(i, 3), o = y(o, h.ZERO); let s = Goe(e, t), a = 0; for (let c = 0, u = n.length; c < u; c += i) { BF.x = n[c] + o.x, BF.y = n[c + 1] + o.y, BF.z = n[c + 2] + o.z; let f = zoe(e, BF, s); if (f < 0) return; a = Math.max(a, f) } return Hoe(s, a, r) } function a6(e, t, n) { let i = t, o = n, r = h.subtract(e, i, Foe), s = -h.dot(r, i); return !(o < 0 ? s > 0 : s > o && s * s / h.magnitudeSquared(r) > o) } var E8e = new h, b8e = new h; function zoe(e, t, n) { let i = e.transformPositionToScaledSpace(t, E8e), o = h.magnitudeSquared(i), r = Math.sqrt(o), s = h.divideByScalar(i, r, b8e); o = Math.max(1, o), r = Math.max(1, r); let a = h.dot(s, n), c = h.magnitude(h.cross(s, n, s)), u = 1 / r, f = Math.sqrt(o - 1) * u; return 1 / (a * u - c * f) } function Hoe(e, t, n) { if (!(t <= 0 || t === 1 / 0 || t !== t)) return h.multiplyByScalar(e, t, n) } var s6 = new h; function Goe(e, t) { return h.equals(t, h.ZERO) ? t : (e.transformPositionToScaledSpace(t, s6), h.normalize(s6, s6)) } var j_ = rh; function Cr(e, t) { e = y(e, y.EMPTY_OBJECT); let n = e.translucencyByDistance, i = e.scaleByDistance, o = e.distanceDisplayCondition; l(n) && (n = wt.clone(n)), l(i) && (i = wt.clone(i)), l(o) && (o = bt.clone(o)), this._show = y(e.show, !0), this._position = h.clone(y(e.position, h.ZERO)), this._actualPosition = h.clone(this._position), this._color = U.clone(y(e.color, U.WHITE)), this._outlineColor = U.clone(y(e.outlineColor, U.TRANSPARENT)), this._outlineWidth = y(e.outlineWidth, 0), this._pixelSize = y(e.pixelSize, 10), this._scaleByDistance = i, this._translucencyByDistance = n, this._distanceDisplayCondition = o, this._disableDepthTestDistance = y(e.disableDepthTestDistance, 0), this._id = e.id, this._collection = y(e.collection, t), this._clusterShow = !0, this._pickId = void 0, this._pointPrimitiveCollection = t, this._dirty = !1, this._index = -1 } var Woe = Cr.SHOW_INDEX = 0, Yoe = Cr.POSITION_INDEX = 1, S8e = Cr.COLOR_INDEX = 2, w8e = Cr.OUTLINE_COLOR_INDEX = 3, D8e = Cr.OUTLINE_WIDTH_INDEX = 4, v8e = Cr.PIXEL_SIZE_INDEX = 5, P8e = Cr.SCALE_BY_DISTANCE_INDEX = 6, I8e = Cr.TRANSLUCENCY_BY_DISTANCE_INDEX = 7, O8e = Cr.DISTANCE_DISPLAY_CONDITION_INDEX = 8, B8e = Cr.DISABLE_DEPTH_DISTANCE_INDEX = 9; Cr.NUMBER_OF_PROPERTIES = 10; function vu(e, t) { let n = e._pointPrimitiveCollection; l(n) && (n._updatePointPrimitive(e, t), e._dirty = !0) } Object.defineProperties(Cr.prototype, { show: { get: function () { return this._show }, set: function (e) { this._show !== e && (this._show = e, vu(this, Woe)) } }, position: { get: function () { return this._position }, set: function (e) { let t = this._position; h.equals(t, e) || (h.clone(e, t), h.clone(e, this._actualPosition), vu(this, Yoe)) } }, scaleByDistance: { get: function () { return this._scaleByDistance }, set: function (e) { let t = this._scaleByDistance; wt.equals(t, e) || (this._scaleByDistance = wt.clone(e, t), vu(this, P8e)) } }, translucencyByDistance: { get: function () { return this._translucencyByDistance }, set: function (e) { let t = this._translucencyByDistance; wt.equals(t, e) || (this._translucencyByDistance = wt.clone(e, t), vu(this, I8e)) } }, pixelSize: { get: function () { return this._pixelSize }, set: function (e) { this._pixelSize !== e && (this._pixelSize = e, vu(this, v8e)) } }, color: { get: function () { return this._color }, set: function (e) { let t = this._color; U.equals(t, e) || (U.clone(e, t), vu(this, S8e)) } }, outlineColor: { get: function () { return this._outlineColor }, set: function (e) { let t = this._outlineColor; U.equals(t, e) || (U.clone(e, t), vu(this, w8e)) } }, outlineWidth: { get: function () { return this._outlineWidth }, set: function (e) { this._outlineWidth !== e && (this._outlineWidth = e, vu(this, D8e)) } }, distanceDisplayCondition: { get: function () { return this._distanceDisplayCondition }, set: function (e) { bt.equals(this._distanceDisplayCondition, e) || (this._distanceDisplayCondition = bt.clone(e, this._distanceDisplayCondition), vu(this, O8e)) } }, disableDepthTestDistance: { get: function () { return this._disableDepthTestDistance }, set: function (e) { this._disableDepthTestDistance !== e && (this._disableDepthTestDistance = e, vu(this, B8e)) } }, id: { get: function () { return this._id }, set: function (e) { this._id = e, l(this._pickId) && (this._pickId.object.id = e) } }, pickId: { get: function () { return this._pickId } }, clusterShow: { get: function () { return this._clusterShow }, set: function (e) { this._clusterShow !== e && (this._clusterShow = e, vu(this, Woe)) } } }); Cr.prototype.getPickId = function (e) { return l(this._pickId) || (this._pickId = e.createPickId({ primitive: this, collection: this._collection, id: this._id })), this._pickId }; Cr.prototype._getActualPosition = function () { return this._actualPosition }; Cr.prototype._setActualPosition = function (e) { h.clone(e, this._actualPosition), vu(this, Yoe) }; var joe = new se; Cr._computeActualPosition = function (e, t, n) { return t.mode === ee.SCENE3D ? e : (F.multiplyByPoint(n, e, joe), ji.computeActualWgs84Position(t, joe)) }; var qoe = new se; Cr._computeScreenSpacePosition = function (e, t, n, i) { let o = F.multiplyByVector(e, se.fromElements(t.x, t.y, t.z, 1, qoe), qoe); return ji.wgs84ToWindowCoordinates(n, o, i) }; Cr.prototype.computeScreenSpacePosition = function (e, t) { let n = this._pointPrimitiveCollection; l(t) || (t = new H); let i = n.modelMatrix, o = Cr._computeScreenSpacePosition(i, this._actualPosition, e, t); if (!!l(o)) return o.y = e.canvas.clientHeight - o.y, o }; Cr.getScreenSpaceBoundingBox = function (e, t, n) { let i = e.pixelSize, o = i * .5, r = t.x - o, s = t.y - o, a = i, c = i; return l(n) || (n = new Ge), n.x = r, n.y = s, n.width = a, n.height = c, n }; Cr.prototype.equals = function (e) { return this === e || l(e) && this._id === e._id && h.equals(this._position, e._position) && U.equals(this._color, e._color) && this._pixelSize === e._pixelSize && this._outlineWidth === e._outlineWidth && this._show === e._show && U.equals(this._outlineColor, e._outlineColor) && wt.equals(this._scaleByDistance, e._scaleByDistance) && wt.equals(this._translucencyByDistance, e._translucencyByDistance) && bt.equals(this._distanceDisplayCondition, e._distanceDisplayCondition) && this._disableDepthTestDistance === e._disableDepthTestDistance }; Cr.prototype._destroy = function () { this._pickId = this._pickId && this._pickId.destroy(), this._pointPrimitiveCollection = void 0 }; var Is = Cr; var gy = `varying vec4 v_color;
varying vec4 v_outlineColor;
varying float v_innerPercent;
varying float v_pixelDistance;
varying vec4 v_pickColor;
void main()
{
float distanceToCenter = length(gl_PointCoord - vec2(0.5));
float maxDistance = max(0.0, 0.5 - v_pixelDistance);
float wholeAlpha = 1.0 - smoothstep(maxDistance, 0.5, distanceToCenter);
float innerAlpha = 1.0 - smoothstep(maxDistance * v_innerPercent, 0.5 * v_innerPercent, distanceToCenter);
vec4 color = mix(v_outlineColor, v_color, innerAlpha);
color.a *= wholeAlpha;
#if !defined(OPAQUE) && !defined(TRANSLUCENT)
if (color.a < 0.005)
{
discard;
}
#else
#ifdef OPAQUE
if (color.a < 0.995)
{
discard;
}
#else
if (color.a >= 0.995)
{
discard;
}
#endif
#endif
gl_FragColor = czm_gammaCorrect(color);
czm_writeLogDepth();
}
`; var RF = `uniform float u_maxTotalPointSize;
attribute vec4 positionHighAndSize;
attribute vec4 positionLowAndOutline;
attribute vec4 compressedAttribute0;
attribute vec4 compressedAttribute1;
attribute vec4 scaleByDistance;
attribute vec3 distanceDisplayConditionAndDisableDepth;
varying vec4 v_color;
varying vec4 v_outlineColor;
varying float v_innerPercent;
varying float v_pixelDistance;
varying vec4 v_pickColor;
const float SHIFT_LEFT8 = 256.0;
const float SHIFT_RIGHT8 = 1.0 / 256.0;
void main()
{
vec3 positionHigh = positionHighAndSize.xyz;
vec3 positionLow = positionLowAndOutline.xyz;
float outlineWidthBothSides = 2.0 * positionLowAndOutline.w;
float totalSize = positionHighAndSize.w + outlineWidthBothSides;
float outlinePercent = outlineWidthBothSides / totalSize;
totalSize *= czm_pixelRatio;
totalSize += 3.0;
float temp = compressedAttribute1.x * SHIFT_RIGHT8;
float show = floor(temp);
#ifdef EYE_DISTANCE_TRANSLUCENCY
vec4 translucencyByDistance;
translucencyByDistance.x = compressedAttribute1.z;
translucencyByDistance.z = compressedAttribute1.w;
translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;
temp = compressedAttribute1.y * SHIFT_RIGHT8;
translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;
#endif
vec4 color;
vec4 outlineColor;
vec4 pickColor;
temp = compressedAttribute0.z * SHIFT_RIGHT8;
pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
temp = floor(temp) * SHIFT_RIGHT8;
pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
pickColor.r = floor(temp);
temp = compressedAttribute0.x * SHIFT_RIGHT8;
color.b = (temp - floor(temp)) * SHIFT_LEFT8;
temp = floor(temp) * SHIFT_RIGHT8;
color.g = (temp - floor(temp)) * SHIFT_LEFT8;
color.r = floor(temp);
temp = compressedAttribute0.y * SHIFT_RIGHT8;
outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
temp = floor(temp) * SHIFT_RIGHT8;
outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
outlineColor.r = floor(temp);
temp = compressedAttribute0.w * SHIFT_RIGHT8;
pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;
pickColor = pickColor / 255.0;
temp = floor(temp) * SHIFT_RIGHT8;
outlineColor.a = (temp - floor(temp)) * SHIFT_LEFT8;
outlineColor /= 255.0;
color.a = floor(temp);
color /= 255.0;
vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
vec4 positionEC = czm_modelViewRelativeToEye * p;
#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE)
float lengthSq;
if (czm_sceneMode == czm_sceneMode2D)
{
lengthSq = czm_eyeHeight2D.y;
}
else
{
lengthSq = dot(positionEC.xyz, positionEC.xyz);
}
#endif
#ifdef EYE_DISTANCE_SCALING
totalSize *= czm_nearFarScalar(scaleByDistance, lengthSq);
#endif
totalSize = min(totalSize, u_maxTotalPointSize);
if (totalSize < 1.0)
{
positionEC.xyz = vec3(0.0);
totalSize = 1.0;
}
float translucency = 1.0;
#ifdef EYE_DISTANCE_TRANSLUCENCY
translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);
if (translucency < 0.004)
{
positionEC.xyz = vec3(0.0);
}
#endif
#ifdef DISTANCE_DISPLAY_CONDITION
float nearSq = distanceDisplayConditionAndDisableDepth.x;
float farSq = distanceDisplayConditionAndDisableDepth.y;
if (lengthSq < nearSq || lengthSq > farSq) {
positionEC.xyz = vec3(0.0, 0.0, 1.0);
}
#endif
gl_Position = czm_projection * positionEC;
czm_vertexLogDepth();
#ifdef DISABLE_DEPTH_DISTANCE
float disableDepthTestDistance = distanceDisplayConditionAndDisableDepth.z;
if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0)
{
disableDepthTestDistance = czm_minimumDisableDepthTestDistance;
}
if (disableDepthTestDistance != 0.0)
{
float zclip = gl_Position.z / gl_Position.w;
bool clipped = (zclip < -1.0 || zclip > 1.0);
if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance)))
{
gl_Position.z = -gl_Position.w;
#ifdef LOG_DEPTH
czm_vertexLogDepth(vec4(czm_currentFrustum.x));
#endif
}
}
#endif
v_color = color;
v_color.a *= translucency * show;
v_outlineColor = outlineColor;
v_outlineColor.a *= translucency * show;
v_innerPercent = 1.0 - outlinePercent;
v_pixelDistance = 2.0 / totalSize;
gl_PointSize = totalSize * show;
gl_Position *= show;
v_pickColor = pickColor;
}
`; var R8e = Is.SHOW_INDEX, u6 = Is.POSITION_INDEX, Xoe = Is.COLOR_INDEX, M8e = Is.OUTLINE_COLOR_INDEX, L8e = Is.OUTLINE_WIDTH_INDEX, F8e = Is.PIXEL_SIZE_INDEX, Koe = Is.SCALE_BY_DISTANCE_INDEX, Joe = Is.TRANSLUCENCY_BY_DISTANCE_INDEX, Zoe = Is.DISTANCE_DISPLAY_CONDITION_INDEX, N8e = Is.DISABLE_DEPTH_DISTANCE_INDEX, f6 = Is.NUMBER_OF_PROPERTIES, Pa = { positionHighAndSize: 0, positionLowAndOutline: 1, compressedAttribute0: 2, compressedAttribute1: 3, scaleByDistance: 4, distanceDisplayConditionAndDisableDepth: 5 }; function Pu(e) { e = y(e, y.EMPTY_OBJECT), this._sp = void 0, this._spTranslucent = void 0, this._rsOpaque = void 0, this._rsTranslucent = void 0, this._vaf = void 0, this._pointPrimitives = [], this._pointPrimitivesToUpdate = [], this._pointPrimitivesToUpdateIndex = 0, this._pointPrimitivesRemoved = !1, this._createVertexArray = !1, this._shaderScaleByDistance = !1, this._compiledShaderScaleByDistance = !1, this._shaderTranslucencyByDistance = !1, this._compiledShaderTranslucencyByDistance = !1, this._shaderDistanceDisplayCondition = !1, this._compiledShaderDistanceDisplayCondition = !1, this._shaderDisableDepthDistance = !1, this._compiledShaderDisableDepthDistance = !1, this._propertiesChanged = new Uint32Array(f6), this._maxPixelSize = 1, this._baseVolume = new re, this._baseVolumeWC = new re, this._baseVolume2D = new re, this._boundingVolume = new re, this._boundingVolumeDirty = !1, this._colorCommands = [], this.show = y(e.show, !0), this.modelMatrix = F.clone(y(e.modelMatrix, F.IDENTITY)), this._modelMatrix = F.clone(F.IDENTITY), this.debugShowBoundingVolume = y(e.debugShowBoundingVolume, !1), this.blendOption = y(e.blendOption, xo.OPAQUE_AND_TRANSLUCENT), this._blendOption = void 0, this._mode = ee.SCENE3D, this._maxTotalPointSize = 1, this._buffersUsage = [Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW, Re.STATIC_DRAW]; let t = this; this._uniforms = { u_maxTotalPointSize: function () { return t._maxTotalPointSize } } } Object.defineProperties(Pu.prototype, { length: { get: function () { return d6(this), this._pointPrimitives.length } } }); function Qoe(e) { let t = e.length; for (let n = 0; n < t; ++n)e[n] && e[n]._destroy() } Pu.prototype.add = function (e) { let t = new Is(e, this); return t._index = this._pointPrimitives.length, this._pointPrimitives.push(t), this._createVertexArray = !0, t }; Pu.prototype.remove = function (e) { return this.contains(e) ? (this._pointPrimitives[e._index] = null, this._pointPrimitivesRemoved = !0, this._createVertexArray = !0, e._destroy(), !0) : !1 }; Pu.prototype.removeAll = function () { Qoe(this._pointPrimitives), this._pointPrimitives = [], this._pointPrimitivesToUpdate = [], this._pointPrimitivesToUpdateIndex = 0, this._pointPrimitivesRemoved = !1, this._createVertexArray = !0 }; function d6(e) { if (e._pointPrimitivesRemoved) { e._pointPrimitivesRemoved = !1; let t = [], n = e._pointPrimitives, i = n.length; for (let o = 0, r = 0; o < i; ++o) { let s = n[o]; s && (s._index = r++, t.push(s)) } e._pointPrimitives = t } } Pu.prototype._updatePointPrimitive = function (e, t) { e._dirty || (this._pointPrimitivesToUpdate[this._pointPrimitivesToUpdateIndex++] = e), ++this._propertiesChanged[t] }; Pu.prototype.contains = function (e) { return l(e) && e._pointPrimitiveCollection === this }; Pu.prototype.get = function (e) { return d6(this), this._pointPrimitives[e] }; Pu.prototype.computeNewBuffersUsage = function () { let e = this._buffersUsage, t = !1, n = this._propertiesChanged; for (let i = 0; i < f6; ++i) { let o = n[i] === 0 ? Re.STATIC_DRAW : Re.STREAM_DRAW; t = t || e[i] !== o, e[i] = o } return t }; function V8e(e, t, n) { return new E_(e, [{ index: Pa.positionHighAndSize, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: n[u6] }, { index: Pa.positionLowAndShow, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: n[u6] }, { index: Pa.compressedAttribute0, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: n[Xoe] }, { index: Pa.compressedAttribute1, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: n[Joe] }, { index: Pa.scaleByDistance, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: n[Koe] }, { index: Pa.distanceDisplayConditionAndDisableDepth, componentsPerAttribute: 3, componentDatatype: Y.FLOAT, usage: n[Zoe] }], t) } var c6 = new Vn; function $oe(e, t, n, i) { let o = i._index, r = i._getActualPosition(); e._mode === ee.SCENE3D && (re.expand(e._baseVolume, r, e._baseVolume), e._boundingVolumeDirty = !0), Vn.fromCartesian(r, c6); let s = i.pixelSize, a = i.outlineWidth; e._maxPixelSize = Math.max(e._maxPixelSize, s + a); let c = n[Pa.positionHighAndSize], u = c6.high; c(o, u.x, u.y, u.z, s); let f = n[Pa.positionLowAndOutline], d = c6.low; f(o, d.x, d.y, d.z, a) } var MF = 65536, Dw = 256; function ere(e, t, n, i) { let o = i._index, r = i.color, s = i.getPickId(t).color, a = i.outlineColor, c = U.floatToByte(r.red), u = U.floatToByte(r.green), f = U.floatToByte(r.blue), d = c * MF + u * Dw + f; c = U.floatToByte(a.red), u = U.floatToByte(a.green), f = U.floatToByte(a.blue); let p = c * MF + u * Dw + f; c = U.floatToByte(s.red), u = U.floatToByte(s.green), f = U.floatToByte(s.blue); let g = c * MF + u * Dw + f, m = U.floatToByte(r.alpha) * MF + U.floatToByte(a.alpha) * Dw + U.floatToByte(s.alpha), A = n[Pa.compressedAttribute0]; A(o, d, p, g, m) } function tre(e, t, n, i) { let o = i._index, r = 0, s = 1, a = 1, c = 1, u = i.translucencyByDistance; l(u) && (r = u.near, s = u.nearValue, a = u.far, c = u.farValue, (s !== 1 || c !== 1) && (e._shaderTranslucencyByDistance = !0)); let f = i.show && i.clusterShow; i.color.alpha === 0 && i.outlineColor.alpha === 0 && (f = !1), s = I.clamp(s, 0, 1), s = s === 1 ? 255 : s * 255 | 0; let d = (f ? 1 : 0) * Dw + s; c = I.clamp(c, 0, 1), c = c === 1 ? 255 : c * 255 | 0; let p = c, g = n[Pa.compressedAttribute1]; g(o, d, p, r, a) } function nre(e, t, n, i) { let o = i._index, r = n[Pa.scaleByDistance], s = 0, a = 1, c = 1, u = 1, f = i.scaleByDistance; l(f) && (s = f.near, a = f.nearValue, c = f.far, u = f.farValue, (a !== 1 || u !== 1) && (e._shaderScaleByDistance = !0)), r(o, s, a, c, u) } function ire(e, t, n, i) { let o = i._index, r = n[Pa.distanceDisplayConditionAndDisableDepth], s = 0, a = Number.MAX_VALUE, c = i.distanceDisplayCondition; l(c) && (s = c.near, a = c.far, s *= s, a *= a, e._shaderDistanceDisplayCondition = !0); let u = i.disableDepthTestDistance; u *= u, u > 0 && (e._shaderDisableDepthDistance = !0, u === Number.POSITIVE_INFINITY && (u = -1)), r(o, s, a, u) } function k8e(e, t, n, i) { $oe(e, t, n, i), ere(e, t, n, i), tre(e, t, n, i), nre(e, t, n, i), ire(e, t, n, i) } function l6(e, t, n, i, o, r) { let s; i.mode === ee.SCENE3D ? (s = e._baseVolume, e._boundingVolumeDirty = !0) : s = e._baseVolume2D; let a = []; for (let c = 0; c < n; ++c) { let u = t[c], f = u.position, d = Is._computeActualPosition(f, i, o); l(d) && (u._setActualPosition(d), r ? a.push(d) : re.expand(s, d, s)) } r && re.fromPoints(a, s) } function U8e(e, t) { let n = t.mode, i = e._pointPrimitives, o = e._pointPrimitivesToUpdate, r = e._modelMatrix; e._createVertexArray || e._mode !== n || n !== ee.SCENE3D && !F.equals(r, e.modelMatrix) ? (e._mode = n, F.clone(e.modelMatrix, r), e._createVertexArray = !0, (n === ee.SCENE3D || n === ee.SCENE2D || n === ee.COLUMBUS_VIEW) && l6(e, i, i.length, t, r, !0)) : n === ee.MORPHING ? l6(e, i, i.length, t, r, !0) : (n === ee.SCENE2D || n === ee.COLUMBUS_VIEW) && l6(e, o, e._pointPrimitivesToUpdateIndex, t, r, !1) } function z8e(e, t, n) { let o = t.camera.getPixelSize(n, t.context.drawingBufferWidth, t.context.drawingBufferHeight) * e._maxPixelSize; n.radius += o } var H8e = []; Pu.prototype.update = function (e) { if (d6(this), !this.show) return; this._maxTotalPointSize = Ut.maximumAliasedPointSize, U8e(this, e); let n = this._pointPrimitives.length, i = this._pointPrimitivesToUpdate, o = this._pointPrimitivesToUpdateIndex, r = this._propertiesChanged, s = this._createVertexArray, a, c = e.context, u = e.passes, f = u.pick; if (s || !f && this.computeNewBuffersUsage()) { this._createVertexArray = !1; for (let D = 0; D < f6; ++D)r[D] = 0; if (this._vaf = this._vaf && this._vaf.destroy(), n > 0) { this._vaf = V8e(c, n, this._buffersUsage), a = this._vaf.writers; for (let D = 0; D < n; ++D) { let P = this._pointPrimitives[D]; P._dirty = !1, k8e(this, c, a, P) } this._vaf.commit() } this._pointPrimitivesToUpdateIndex = 0 } else if (o > 0) { let D = H8e; D.length = 0, (r[u6] || r[L8e] || r[F8e]) && D.push($oe), (r[Xoe] || r[M8e]) && D.push(ere), (r[R8e] || r[Joe]) && D.push(tre), r[Koe] && D.push(nre), (r[Zoe] || r[N8e]) && D.push(ire); let P = D.length; if (a = this._vaf.writers, o / n > .1) { for (let B = 0; B < o; ++B) { let R = i[B]; R._dirty = !1; for (let M = 0; M < P; ++M)D[M](this, c, a, R) } this._vaf.commit() } else { for (let B = 0; B < o; ++B) { let R = i[B]; R._dirty = !1; for (let M = 0; M < P; ++M)D[M](this, c, a, R); this._vaf.subCommit(R._index, 1) } this._vaf.endSubCommits() } this._pointPrimitivesToUpdateIndex = 0 } if (o > n * 1.5 && (i.length = n), !l(this._vaf) || !l(this._vaf.va)) return; this._boundingVolumeDirty && (this._boundingVolumeDirty = !1, re.transform(this._baseVolume, this.modelMatrix, this._baseVolumeWC)); let d, p = F.IDENTITY; e.mode === ee.SCENE3D ? (p = this.modelMatrix, d = re.clone(this._baseVolumeWC, this._boundingVolume)) : d = re.clone(this._baseVolume2D, this._boundingVolume), z8e(this, e, d); let g = this._blendOption !== this.blendOption; this._blendOption = this.blendOption, g && (this._blendOption === xo.OPAQUE || this._blendOption === xo.OPAQUE_AND_TRANSLUCENT ? this._rsOpaque = Ve.fromCache({ depthTest: { enabled: !0, func: te.LEQUAL }, depthMask: !0 }) : this._rsOpaque = void 0, this._blendOption === xo.TRANSLUCENT || this._blendOption === xo.OPAQUE_AND_TRANSLUCENT ? this._rsTranslucent = Ve.fromCache({ depthTest: { enabled: !0, func: te.LEQUAL }, depthMask: !1, blending: an.ALPHA_BLEND }) : this._rsTranslucent = void 0), this._shaderDisableDepthDistance = this._shaderDisableDepthDistance || e.minimumDisableDepthTestDistance !== 0; let m, A; (g || this._shaderScaleByDistance && !this._compiledShaderScaleByDistance || this._shaderTranslucencyByDistance && !this._compiledShaderTranslucencyByDistance || this._shaderDistanceDisplayCondition && !this._compiledShaderDistanceDisplayCondition || this._shaderDisableDepthDistance !== this._compiledShaderDisableDepthDistance) && (m = new Ue({ sources: [RF] }), this._shaderScaleByDistance && m.defines.push("EYE_DISTANCE_SCALING"), this._shaderTranslucencyByDistance && m.defines.push("EYE_DISTANCE_TRANSLUCENCY"), this._shaderDistanceDisplayCondition && m.defines.push("DISTANCE_DISPLAY_CONDITION"), this._shaderDisableDepthDistance && m.defines.push("DISABLE_DEPTH_DISTANCE"), this._blendOption === xo.OPAQUE_AND_TRANSLUCENT && (A = new Ue({ defines: ["OPAQUE"], sources: [gy] }), this._sp = qt.replaceCache({ context: c, shaderProgram: this._sp, vertexShaderSource: m, fragmentShaderSource: A, attributeLocations: Pa }), A = new Ue({ defines: ["TRANSLUCENT"], sources: [gy] }), this._spTranslucent = qt.replaceCache({ context: c, shaderProgram: this._spTranslucent, vertexShaderSource: m, fragmentShaderSource: A, attributeLocations: Pa })), this._blendOption === xo.OPAQUE && (A = new Ue({ sources: [gy] }), this._sp = qt.replaceCache({ context: c, shaderProgram: this._sp, vertexShaderSource: m, fragmentShaderSource: A, attributeLocations: Pa })), this._blendOption === xo.TRANSLUCENT && (A = new Ue({ sources: [gy] }), this._spTranslucent = qt.replaceCache({ context: c, shaderProgram: this._spTranslucent, vertexShaderSource: m, fragmentShaderSource: A, attributeLocations: Pa })), this._compiledShaderScaleByDistance = this._shaderScaleByDistance, this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance, this._compiledShaderDistanceDisplayCondition = this._shaderDistanceDisplayCondition, this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance); let C, x, T, b, S = e.commandList; if (u.render || f) { let D = this._colorCommands, P = this._blendOption === xo.OPAQUE, B = this._blendOption === xo.OPAQUE_AND_TRANSLUCENT; C = this._vaf.va, x = C.length, D.length = x; let R = B ? x * 2 : x; for (b = 0; b < R; ++b) { let M = P || B && b % 2 === 0; T = D[b], l(T) || (T = D[b] = new $e), T.primitiveType = Oe.POINTS, T.pass = M || !B ? xe.OPAQUE : xe.TRANSLUCENT, T.owner = this; let L = B ? Math.floor(b / 2) : b; T.boundingVolume = d, T.modelMatrix = p, T.shaderProgram = M ? this._sp : this._spTranslucent, T.uniformMap = this._uniforms, T.vertexArray = C[L].va, T.renderState = M ? this._rsOpaque : this._rsTranslucent, T.debugShowBoundingVolume = this.debugShowBoundingVolume, T.pickId = "v_pickColor", S.push(T) } } }; Pu.prototype.isDestroyed = function () { return !1 }; Pu.prototype.destroy = function () { return this._sp = this._sp && this._sp.destroy(), this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy(), this._spPick = this._spPick && this._spPick.destroy(), this._vaf = this._vaf && this._vaf.destroy(), Qoe(this._pointPrimitives), le(this) }; var vw = Pu; function Iw(e, t, n, i, o, r) { if (o - i <= n) return; let s = i + o >> 1; ore(e, t, s, i, o, r % 2), Iw(e, t, n, i, s - 1, r + 1), Iw(e, t, n, s + 1, o, r + 1) } function ore(e, t, n, i, o, r) { for (; o > i;) { if (o - i > 600) { let u = o - i + 1, f = n - i + 1, d = Math.log(u), p = .5 * Math.exp(2 * d / 3), g = .5 * Math.sqrt(d * p * (u - p) / u) * (f - u / 2 < 0 ? -1 : 1), m = Math.max(i, Math.floor(n - f * p / u + g)), A = Math.min(o, Math.floor(n + (u - f) * p / u + g)); ore(e, t, n, m, A, r) } let s = t[2 * n + r], a = i, c = o; for (Pw(e, t, i, n), t[2 * o + r] > s && Pw(e, t, i, o); a < c;) { for (Pw(e, t, a, c), a++, c--; t[2 * a + r] < s;)a++; for (; t[2 * c + r] > s;)c-- } t[2 * i + r] === s ? Pw(e, t, i, c) : (c++, Pw(e, t, c, o)), c <= n && (i = c + 1), n <= c && (o = c - 1) } } function Pw(e, t, n, i) { h6(e, n, i), h6(t, 2 * n, 2 * i), h6(t, 2 * n + 1, 2 * i + 1) } function h6(e, t, n) { let i = e[t]; e[t] = e[n], e[n] = i } function m6(e, t, n, i, o, r, s) { let a = [0, e.length - 1, 0], c = [], u, f; for (; a.length;) { let d = a.pop(), p = a.pop(), g = a.pop(); if (p - g <= s) { for (let C = g; C <= p; C++)u = t[2 * C], f = t[2 * C + 1], u >= n && u <= o && f >= i && f <= r && c.push(e[C]); continue } let m = Math.floor((g + p) / 2); u = t[2 * m], f = t[2 * m + 1], u >= n && u <= o && f >= i && f <= r && c.push(e[m]); let A = (d + 1) % 2; (d === 0 ? n <= u : i <= f) && (a.push(g), a.push(m - 1), a.push(A)), (d === 0 ? o >= u : r >= f) && (a.push(m + 1), a.push(p), a.push(A)) } return c } function p6(e, t, n, i, o, r) { let s = [0, e.length - 1, 0], a = [], c = o * o; for (; s.length;) { let u = s.pop(), f = s.pop(), d = s.pop(); if (f - d <= r) { for (let C = d; C <= f; C++)rre(t[2 * C], t[2 * C + 1], n, i) <= c && a.push(e[C]); continue } let p = Math.floor((d + f) / 2), g = t[2 * p], m = t[2 * p + 1]; rre(g, m, n, i) <= c && a.push(e[p]); let A = (u + 1) % 2; (u === 0 ? n - o <= g : i - o <= m) && (s.push(d), s.push(p - 1), s.push(A)), (u === 0 ? n + o >= g : i + o >= m) && (s.push(p + 1), s.push(f), s.push(A)) } return a } function rre(e, t, n, i) { let o = e - n, r = t - i; return o * o + r * r } var G8e = e => e[0], W8e = e => e[1], Ow = class { constructor(t, n = G8e, i = W8e, o = 64, r = Float64Array) { this.nodeSize = o, this.points = t; let s = t.length < 65536 ? Uint16Array : Uint32Array, a = this.ids = new s(t.length), c = this.coords = new r(t.length * 2); for (let u = 0; u < t.length; u++)a[u] = u, c[2 * u] = n(t[u]), c[2 * u + 1] = i(t[u]); Iw(a, c, o, 0, a.length - 1, 0) } range(t, n, i, o) { return m6(this.ids, this.coords, t, n, i, o, this.nodeSize) } within(t, n, i) { return p6(this.ids, this.coords, t, n, i, this.nodeSize) } }; function Nf(e) { e = y(e, y.EMPTY_OBJECT), this._enabled = y(e.enabled, !1), this._pixelRange = y(e.pixelRange, 80), this._minimumClusterSize = y(e.minimumClusterSize, 2), this._clusterBillboards = y(e.clusterBillboards, !0), this._clusterLabels = y(e.clusterLabels, !0), this._clusterPoints = y(e.clusterPoints, !0), this._labelCollection = void 0, this._billboardCollection = void 0, this._pointCollection = void 0, this._clusterBillboardCollection = void 0, this._clusterLabelCollection = void 0, this._clusterPointCollection = void 0, this._collectionIndicesByEntity = {}, this._unusedLabelIndices = [], this._unusedBillboardIndices = [], this._unusedPointIndices = [], this._previousClusters = [], this._previousHeight = void 0, this._enabledDirty = !1, this._clusterDirty = !1, this._cluster = void 0, this._removeEventListener = void 0, this._clusterEvent = new _e, this.show = y(e.show, !0) } function j8e(e) { return e.coord.x } function q8e(e) { return e.coord.y } function sre(e, t) { e.x -= t, e.y -= t, e.width += t * 2, e.height += t * 2 } var Y8e = new Ge; function are(e, t, n, i, o) { if (l(e._labelCollection) && i._clusterLabels ? o = ty.getScreenSpaceBoundingBox(e, t, o) : l(e._billboardCollection) && i._clusterBillboards ? o = co.getScreenSpaceBoundingBox(e, t, o) : l(e._pointPrimitiveCollection) && i._clusterPoints && (o = Is.getScreenSpaceBoundingBox(e, t, o)), sre(o, n), i._clusterLabels && !l(e._labelCollection) && l(e.id) && lre(i, e.id.id) && l(e.id._label)) { let r = i._collectionIndicesByEntity[e.id.id].labelIndex, s = i._labelCollection.get(r), a = ty.getScreenSpaceBoundingBox(s, t, Y8e); sre(a, n), o = Ge.union(o, a, o) } return o } function X8e(e, t) { if (e.clusterShow = !0, !l(e._labelCollection) && l(e.id) && lre(t, e.id.id) && l(e.id._label)) { let n = t._collectionIndicesByEntity[e.id.id].labelIndex, i = t._labelCollection.get(n); i.clusterShow = !0 } } function cre(e, t, n, i) { let o = { billboard: i._clusterBillboardCollection.add(), label: i._clusterLabelCollection.add(), point: i._clusterPointCollection.add() }; o.billboard.show = !1, o.point.show = !1, o.label.show = !0, o.label.text = t.toLocaleString(), o.label.id = n, o.billboard.position = o.label.position = o.point.position = e, i._clusterEvent.raiseEvent(n, o) } function lre(e, t) { return l(e) && l(e._collectionIndicesByEntity[t]) && l(e._collectionIndicesByEntity[t].labelIndex) } function _6(e, t, n, i, o) { if (!l(e)) return; let r = e.length; for (let s = 0; s < r; ++s) { let a = e.get(s); if (a.clusterShow = !1, !a.show || o._scene.mode === ee.SCENE3D && !i.isPointVisible(a.position)) continue; let c = o._clusterLabels && l(a._labelCollection), u = o._clusterBillboards && l(a.id._billboard), f = o._clusterPoints && l(a.id._point); if (c && (f || u)) continue; let d = a.computeScreenSpacePosition(n); !l(d) || t.push({ index: s, collection: e, clustered: !1, coord: d }) } } var K8e = new Ge, J8e = new Ge, Z8e = new Ge; function Q8e(e) { return function (t) { if (l(t) && t < .05 || !e.enabled) return; let n = e._scene, i = e._labelCollection, o = e._billboardCollection, r = e._pointCollection; if (!l(i) && !l(o) && !l(r) || !e._clusterBillboards && !e._clusterLabels && !e._clusterPoints) return; let s = e._clusterLabelCollection, a = e._clusterBillboardCollection, c = e._clusterPointCollection; l(s) ? s.removeAll() : s = e._clusterLabelCollection = new Lm({ scene: n }), l(a) ? a.removeAll() : a = e._clusterBillboardCollection = new yu({ scene: n }), l(c) ? c.removeAll() : c = e._clusterPointCollection = new vw; let u = e._pixelRange, f = e._minimumClusterSize, d = e._previousClusters, p = [], g = e._previousHeight, m = n.camera.positionCartographic.height, A = n.mapProjection.ellipsoid, C = n.camera.positionWC, x = new j_(A, C), T = []; e._clusterLabels && _6(i, T, n, x, e), e._clusterBillboards && _6(o, T, n, x, e), e._clusterPoints && _6(r, T, n, x, e); let b, S, D, P, B, R, M, L, _, E, w, v, O = new Ow(T, j8e, q8e, 64, Int32Array); if (m < g) for (D = d.length, b = 0; b < D; ++b) { let V = d[b]; if (!x.isPointVisible(V.position)) continue; let z = co._computeScreenSpacePosition(F.IDENTITY, V.position, h.ZERO, H.ZERO, n); if (!l(z)) continue; let k = 1 - m / g, G = V.width = V.width * k, N = V.height = V.height * k; G = Math.max(G, V.minimumWidth), N = Math.max(N, V.minimumHeight); let X = z.x - G * .5, q = z.y - N * .5, J = z.x + G, W = z.y + N; for (B = O.range(X, q, J, W), R = B.length, E = 0, _ = [], S = 0; S < R; ++S)M = B[S], L = T[M], L.clustered || (++E, w = L.collection, v = L.index, _.push(w.get(v).id)); if (E >= f) for (cre(V.position, E, _, e), p.push(V), S = 0; S < R; ++S)T[B[S]].clustered = !0 } for (D = T.length, b = 0; b < D; ++b) { let V = T[b]; if (V.clustered) continue; V.clustered = !0, w = V.collection, v = V.index; let z = w.get(v); P = are(z, V.coord, u, e, K8e); let k = Ge.clone(P, J8e); B = O.range(P.x, P.y, P.x + P.width, P.y + P.height), R = B.length; let G = h.clone(z.position); for (E = 1, _ = [z.id], S = 0; S < R; ++S)if (M = B[S], L = T[M], !L.clustered) { let N = L.collection.get(L.index), X = are(N, L.coord, u, e, Z8e); h.add(N.position, G, G), Ge.union(k, X, k), ++E, _.push(N.id) } if (E >= f) { let N = h.multiplyByScalar(G, 1 / E, G); for (cre(N, E, _, e), p.push({ position: N, width: k.width, height: k.height, minimumWidth: P.width, minimumHeight: P.height }), S = 0; S < R; ++S)T[B[S]].clustered = !0 } else X8e(z, e) } s.length === 0 && (s.destroy(), e._clusterLabelCollection = void 0), a.length === 0 && (a.destroy(), e._clusterBillboardCollection = void 0), c.length === 0 && (c.destroy(), e._clusterPointCollection = void 0), e._previousClusters = p, e._previousHeight = m } } Nf.prototype._initialize = function (e) { this._scene = e; let t = Q8e(this); this._cluster = t, this._removeEventListener = e.camera.changed.addEventListener(t) }; Object.defineProperties(Nf.prototype, { enabled: { get: function () { return this._enabled }, set: function (e) { this._enabledDirty = e !== this._enabled, this._enabled = e } }, pixelRange: { get: function () { return this._pixelRange }, set: function (e) { this._clusterDirty = this._clusterDirty || e !== this._pixelRange, this._pixelRange = e } }, minimumClusterSize: { get: function () { return this._minimumClusterSize }, set: function (e) { this._clusterDirty = this._clusterDirty || e !== this._minimumClusterSize, this._minimumClusterSize = e } }, clusterEvent: { get: function () { return this._clusterEvent } }, clusterBillboards: { get: function () { return this._clusterBillboards }, set: function (e) { this._clusterDirty = this._clusterDirty || e !== this._clusterBillboards, this._clusterBillboards = e } }, clusterLabels: { get: function () { return this._clusterLabels }, set: function (e) { this._clusterDirty = this._clusterDirty || e !== this._clusterLabels, this._clusterLabels = e } }, clusterPoints: { get: function () { return this._clusterPoints }, set: function (e) { this._clusterDirty = this._clusterDirty || e !== this._clusterPoints, this._clusterPoints = e } } }); function y6(e, t, n, i) { return function (o) { let r = this[e]; l(this._collectionIndicesByEntity) || (this._collectionIndicesByEntity = {}); let s = this._collectionIndicesByEntity[o.id]; if (l(s) || (s = this._collectionIndicesByEntity[o.id] = { billboardIndex: void 0, labelIndex: void 0, pointIndex: void 0 }), l(r) && l(s[i])) return r.get(s[i]); l(r) || (r = this[e] = new t({ scene: this._scene })); let a, c, u = this[n]; u.length > 0 ? (a = u.pop(), c = r.get(a)) : (c = r.add(), a = r.length - 1), s[i] = a; let f = this; return Promise.resolve().then(function () { f._clusterDirty = !0 }), c } } function A6(e, t) { let n = e._collectionIndicesByEntity[t]; !l(n.billboardIndex) && !l(n.labelIndex) && !l(n.pointIndex) && delete e._collectionIndicesByEntity[t] } Nf.prototype.getLabel = y6("_labelCollection", Lm, "_unusedLabelIndices", "labelIndex"); Nf.prototype.removeLabel = function (e) { let t = this._collectionIndicesByEntity && this._collectionIndicesByEntity[e.id]; if (!l(this._labelCollection) || !l(t) || !l(t.labelIndex)) return; let n = t.labelIndex; t.labelIndex = void 0, A6(this, e.id); let i = this._labelCollection.get(n); i.show = !1, i.text = "", i.id = void 0, this._unusedLabelIndices.push(n), this._clusterDirty = !0 }; Nf.prototype.getBillboard = y6("_billboardCollection", yu, "_unusedBillboardIndices", "billboardIndex"); Nf.prototype.removeBillboard = function (e) { let t = this._collectionIndicesByEntity && this._collectionIndicesByEntity[e.id]; if (!l(this._billboardCollection) || !l(t) || !l(t.billboardIndex)) return; let n = t.billboardIndex; t.billboardIndex = void 0, A6(this, e.id); let i = this._billboardCollection.get(n); i.id = void 0, i.show = !1, i.image = void 0, this._unusedBillboardIndices.push(n), this._clusterDirty = !0 }; Nf.prototype.getPoint = y6("_pointCollection", vw, "_unusedPointIndices", "pointIndex"); Nf.prototype.removePoint = function (e) { let t = this._collectionIndicesByEntity && this._collectionIndicesByEntity[e.id]; if (!l(this._pointCollection) || !l(t) || !l(t.pointIndex)) return; let n = t.pointIndex; t.pointIndex = void 0, A6(this, e.id); let i = this._pointCollection.get(n); i.show = !1, i.id = void 0, this._unusedPointIndices.push(n), this._clusterDirty = !0 }; function g6(e) { if (!l(e)) return; let t = e.length; for (let n = 0; n < t; ++n)e.get(n).clusterShow = !0 } function $8e(e) { e.enabled || (l(e._clusterLabelCollection) && e._clusterLabelCollection.destroy(), l(e._clusterBillboardCollection) && e._clusterBillboardCollection.destroy(), l(e._clusterPointCollection) && e._clusterPointCollection.destroy(), e._clusterLabelCollection = void 0, e._clusterBillboardCollection = void 0, e._clusterPointCollection = void 0, g6(e._labelCollection), g6(e._billboardCollection), g6(e._pointCollection)) } Nf.prototype.update = function (e) { if (!this.show) return; let t; l(this._labelCollection) && this._labelCollection.length > 0 && this._labelCollection.get(0)._glyphs.length === 0 && (t = e.commandList, e.commandList = [], this._labelCollection.update(e), e.commandList = t), l(this._billboardCollection) && this._billboardCollection.length > 0 && !l(this._billboardCollection.get(0).width) && (t = e.commandList, e.commandList = [], this._billboardCollection.update(e), e.commandList = t), this._enabledDirty && (this._enabledDirty = !1, $8e(this), this._clusterDirty = !0), this._clusterDirty && (this._clusterDirty = !1, this._cluster()), l(this._clusterLabelCollection) && this._clusterLabelCollection.update(e), l(this._clusterBillboardCollection) && this._clusterBillboardCollection.update(e), l(this._clusterPointCollection) && this._clusterPointCollection.update(e), l(this._labelCollection) && this._labelCollection.update(e), l(this._billboardCollection) && this._billboardCollection.update(e), l(this._pointCollection) && this._pointCollection.update(e) }; Nf.prototype.destroy = function () { this._labelCollection = this._labelCollection && this._labelCollection.destroy(), this._billboardCollection = this._billboardCollection && this._billboardCollection.destroy(), this._pointCollection = this._pointCollection && this._pointCollection.destroy(), this._clusterLabelCollection = this._clusterLabelCollection && this._clusterLabelCollection.destroy(), this._clusterBillboardCollection = this._clusterBillboardCollection && this._clusterBillboardCollection.destroy(), this._clusterPointCollection = this._clusterPointCollection && this._clusterPointCollection.destroy(), l(this._removeEventListener) && (this._removeEventListener(), this._removeEventListener = void 0), this._labelCollection = void 0, this._billboardCollection = void 0, this._pointCollection = void 0, this._clusterBillboardCollection = void 0, this._clusterLabelCollection = void 0, this._clusterPointCollection = void 0, this._collectionIndicesByEntity = void 0, this._unusedLabelIndices = [], this._unusedBillboardIndices = [], this._unusedPointIndices = [], this._previousClusters = [], this._previousHeight = void 0, this._enabledDirty = !1, this._pixelRangeDirty = !1, this._minimumClusterSizeDirty = !1 }; var Iu = Nf; function C6(e) { this._name = e, this._clock = void 0, this._changed = new _e, this._error = new _e, this._isLoading = !1, this._loading = new _e, this._entityCollection = new vs(this), this._entityCluster = new Iu } Object.defineProperties(C6.prototype, { name: { get: function () { return this._name }, set: function (e) { this._name !== e && (this._name = e, this._changed.raiseEvent(this)) } }, clock: { get: function () { return this._clock }, set: function (e) { this._clock !== e && (this._clock = e, this._changed.raiseEvent(this)) } }, entities: { get: function () { return this._entityCollection } }, isLoading: { get: function () { return this._isLoading }, set: function (e) { Or.setLoading(this, e) } }, changedEvent: { get: function () { return this._changed } }, errorEvent: { get: function () { return this._error } }, loadingEvent: { get: function () { return this._loading } }, show: { get: function () { return this._entityCollection.show }, set: function (e) { this._entityCollection.show = e } }, clustering: { get: function () { return this._entityCluster }, set: function (e) { this._entityCluster = e } } }); C6.prototype.update = function (e) { return !0 }; var LF = C6; var ure = {}; ure.computePositions = function (e, t, n, i, o) { let r = e * .5, s = -r, a = i + i, c = o ? 2 * a : a, u = new Float64Array(c * 3), f, d = 0, p = 0, g = o ? a * 3 : 0, m = o ? (a + i) * 3 : i * 3; for (f = 0; f < i; f++) { let A = f / i * I.TWO_PI, C = Math.cos(A), x = Math.sin(A), T = C * n, b = x * n, S = C * t, D = x * t; u[p + g] = T, u[p + g + 1] = b, u[p + g + 2] = s, u[p + m] = S, u[p + m + 1] = D, u[p + m + 2] = r, p += 3, o && (u[d++] = T, u[d++] = b, u[d++] = s, u[d++] = S, u[d++] = D, u[d++] = r) } return u }; var Yx = ure; var x6 = new H, e5e = new h, t5e = new h, n5e = new h, i5e = new h; function Zm(e) { e = y(e, y.EMPTY_OBJECT); let t = e.length, n = e.topRadius, i = e.bottomRadius, o = y(e.vertexFormat, we.DEFAULT), r = y(e.slices, 128); this._length = t, this._topRadius = n, this._bottomRadius = i, this._vertexFormat = we.clone(o), this._slices = r, this._offsetAttribute = e.offsetAttribute, this._workerName = "createCylinderGeometry" } Zm.packedLength = we.packedLength + 5; Zm.pack = function (e, t, n) { return n = y(n, 0), we.pack(e._vertexFormat, t, n), n += we.packedLength, t[n++] = e._length, t[n++] = e._topRadius, t[n++] = e._bottomRadius, t[n++] = e._slices, t[n] = y(e._offsetAttribute, -1), t }; var fre = new we, Xx = { vertexFormat: fre, length: void 0, topRadius: void 0, bottomRadius: void 0, slices: void 0, offsetAttribute: void 0 }; Zm.unpack = function (e, t, n) { t = y(t, 0); let i = we.unpack(e, t, fre); t += we.packedLength; let o = e[t++], r = e[t++], s = e[t++], a = e[t++], c = e[t]; return l(n) ? (n._vertexFormat = we.clone(i, n._vertexFormat), n._length = o, n._topRadius = r, n._bottomRadius = s, n._slices = a, n._offsetAttribute = c === -1 ? void 0 : c, n) : (Xx.length = o, Xx.topRadius = r, Xx.bottomRadius = s, Xx.slices = a, Xx.offsetAttribute = c === -1 ? void 0 : c, new Zm(Xx)) }; Zm.createGeometry = function (e) { let t = e._length, n = e._topRadius, i = e._bottomRadius, o = e._vertexFormat, r = e._slices; if (t <= 0 || n < 0 || i < 0 || n === 0 && i === 0) return; let s = r + r, a = r + s, c = s + s, u = Yx.computePositions(t, n, i, r, !0), f = o.st ? new Float32Array(c * 2) : void 0, d = o.normal ? new Float32Array(c * 3) : void 0, p = o.tangent ? new Float32Array(c * 3) : void 0, g = o.bitangent ? new Float32Array(c * 3) : void 0, m, A = o.normal || o.tangent || o.bitangent; if (A) { let B = o.tangent || o.bitangent, R = 0, M = 0, L = 0, _ = Math.atan2(i - n, t), E = e5e; E.z = Math.sin(_); let w = Math.cos(_), v = n5e, O = t5e; for (m = 0; m < r; m++) { let V = m / r * I.TWO_PI, z = w * Math.cos(V), k = w * Math.sin(V); A && (E.x = z, E.y = k, B && (v = h.normalize(h.cross(h.UNIT_Z, E, v), v)), o.normal && (d[R++] = E.x, d[R++] = E.y, d[R++] = E.z, d[R++] = E.x, d[R++] = E.y, d[R++] = E.z), o.tangent && (p[M++] = v.x, p[M++] = v.y, p[M++] = v.z, p[M++] = v.x, p[M++] = v.y, p[M++] = v.z), o.bitangent && (O = h.normalize(h.cross(E, v, O), O), g[L++] = O.x, g[L++] = O.y, g[L++] = O.z, g[L++] = O.x, g[L++] = O.y, g[L++] = O.z)) } for (m = 0; m < r; m++)o.normal && (d[R++] = 0, d[R++] = 0, d[R++] = -1), o.tangent && (p[M++] = 1, p[M++] = 0, p[M++] = 0), o.bitangent && (g[L++] = 0, g[L++] = -1, g[L++] = 0); for (m = 0; m < r; m++)o.normal && (d[R++] = 0, d[R++] = 0, d[R++] = 1), o.tangent && (p[M++] = 1, p[M++] = 0, p[M++] = 0), o.bitangent && (g[L++] = 0, g[L++] = 1, g[L++] = 0) } let C = 12 * r - 12, x = Me.createTypedArray(c, C), T = 0, b = 0; for (m = 0; m < r - 1; m++)x[T++] = b, x[T++] = b + 2, x[T++] = b + 3, x[T++] = b, x[T++] = b + 3, x[T++] = b + 1, b += 2; for (x[T++] = s - 2, x[T++] = 0, x[T++] = 1, x[T++] = s - 2, x[T++] = 1, x[T++] = s - 1, m = 1; m < r - 1; m++)x[T++] = s + m + 1, x[T++] = s + m, x[T++] = s; for (m = 1; m < r - 1; m++)x[T++] = a, x[T++] = a + m, x[T++] = a + m + 1; let S = 0; if (o.st) { let B = Math.max(n, i); for (m = 0; m < c; m++) { let R = h.fromArray(u, m * 3, i5e); f[S++] = (R.x + B) / (2 * B), f[S++] = (R.y + B) / (2 * B) } } let D = new sn; o.position && (D.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: u })), o.normal && (D.normal = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: d })), o.tangent && (D.tangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: p })), o.bitangent && (D.bitangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: g })), o.st && (D.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: f })), x6.x = t * .5, x6.y = Math.max(i, n); let P = new re(h.ZERO, H.magnitude(x6)); if (l(e._offsetAttribute)) { t = u.length; let B = e._offsetAttribute === Qt.NONE ? 0 : 1, R = new Uint8Array(t / 3).fill(B); D.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: R }) } return new st({ attributes: D, indices: x, primitiveType: Oe.TRIANGLES, boundingSphere: P, offsetAttribute: e._offsetAttribute }) }; var T6; Zm.getUnitCylinder = function () { return l(T6) || (T6 = Zm.createGeometry(new Zm({ topRadius: 1, bottomRadius: 1, length: 1, vertexFormat: we.POSITION_ONLY }))), T6 }; var FF = Zm; var E6 = new H; function Kx(e) { e = y(e, y.EMPTY_OBJECT); let t = e.length, n = e.topRadius, i = e.bottomRadius, o = y(e.slices, 128), r = Math.max(y(e.numberOfVerticalLines, 16), 0); this._length = t, this._topRadius = n, this._bottomRadius = i, this._slices = o, this._numberOfVerticalLines = r, this._offsetAttribute = e.offsetAttribute, this._workerName = "createCylinderOutlineGeometry" } Kx.packedLength = 6; Kx.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e._length, t[n++] = e._topRadius, t[n++] = e._bottomRadius, t[n++] = e._slices, t[n++] = e._numberOfVerticalLines, t[n] = y(e._offsetAttribute, -1), t }; var yy = { length: void 0, topRadius: void 0, bottomRadius: void 0, slices: void 0, numberOfVerticalLines: void 0, offsetAttribute: void 0 }; Kx.unpack = function (e, t, n) { t = y(t, 0); let i = e[t++], o = e[t++], r = e[t++], s = e[t++], a = e[t++], c = e[t]; return l(n) ? (n._length = i, n._topRadius = o, n._bottomRadius = r, n._slices = s, n._numberOfVerticalLines = a, n._offsetAttribute = c === -1 ? void 0 : c, n) : (yy.length = i, yy.topRadius = o, yy.bottomRadius = r, yy.slices = s, yy.numberOfVerticalLines = a, yy.offsetAttribute = c === -1 ? void 0 : c, new Kx(yy)) }; Kx.createGeometry = function (e) { let t = e._length, n = e._topRadius, i = e._bottomRadius, o = e._slices, r = e._numberOfVerticalLines; if (t <= 0 || n < 0 || i < 0 || n === 0 && i === 0) return; let s = o * 2, a = Yx.computePositions(t, n, i, o, !1), c = o * 2, u; if (r > 0) { let A = Math.min(r, o); u = Math.round(o / A), c += A } let f = Me.createTypedArray(s, c * 2), d = 0, p; for (p = 0; p < o - 1; p++)f[d++] = p, f[d++] = p + 1, f[d++] = p + o, f[d++] = p + 1 + o; if (f[d++] = o - 1, f[d++] = 0, f[d++] = o + o - 1, f[d++] = o, r > 0) for (p = 0; p < o; p += u)f[d++] = p, f[d++] = p + o; let g = new sn; g.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: a }), E6.x = t * .5, E6.y = Math.max(i, n); let m = new re(h.ZERO, H.magnitude(E6)); if (l(e._offsetAttribute)) { t = a.length; let A = e._offsetAttribute === Qt.NONE ? 0 : 1, C = new Uint8Array(t / 3).fill(A); g.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: C }) } return new st({ attributes: g, indices: f, primitiveType: Oe.LINES, boundingSphere: m, offsetAttribute: e._offsetAttribute }) }; var NF = Kx; var dre = h.ZERO, hre = new h, o5e = new h, mre = new U; function r5e(e) { this.id = e, this.vertexFormat = void 0, this.length = void 0, this.topRadius = void 0, this.bottomRadius = void 0, this.slices = void 0, this.numberOfVerticalLines = void 0, this.offsetAttribute = void 0 } function El(e, t) { ei.call(this, { entity: e, scene: t, geometryOptions: new r5e(e), geometryPropertyName: "cylinder", observedPropertyNames: ["availability", "position", "orientation", "cylinder"] }), this._onEntityPropertyChanged(e, "cylinder", e.cylinder, void 0) } l(Object.create) && (El.prototype = Object.create(ei.prototype), El.prototype.constructor = El); Object.defineProperties(El.prototype, { terrainOffsetProperty: { get: function () { return this._terrainOffsetProperty } } }); El.prototype.createFillGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = new fn(n && t.isShowing && this._showProperty.getValue(e) && this._fillProperty.getValue(e)), o = this._distanceDisplayConditionProperty.getValue(e), r = Mn.fromDistanceDisplayCondition(o), s = { show: i, distanceDisplayCondition: r, color: void 0, offset: void 0 }; if (this._materialProperty instanceof Ot) { let a; l(this._materialProperty.color) && (this._materialProperty.color.isConstant || n) && (a = this._materialProperty.color.getValue(e, mre)), l(a) || (a = U.WHITE), s.color = Bt.fromColor(a) } return l(this._options.offsetAttribute) && (s.offset = zi.fromCartesian3(j.getValueOrDefault(this._terrainOffsetProperty, e, dre, hre))), new At({ id: t, geometry: new FF(this._options), modelMatrix: t.computeModelMatrixForHeightReference(e, t.cylinder.heightReference, this._options.length * .5, this._scene.mapProjection.ellipsoid), attributes: s }) }; El.prototype.createOutlineGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = j.getValueOrDefault(this._outlineColorProperty, e, U.BLACK, mre), o = this._distanceDisplayConditionProperty.getValue(e), r = { show: new fn(n && t.isShowing && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)), color: Bt.fromColor(i), distanceDisplayCondition: Mn.fromDistanceDisplayCondition(o), offset: void 0 }; return l(this._options.offsetAttribute) && (r.offset = zi.fromCartesian3(j.getValueOrDefault(this._terrainOffsetProperty, e, dre, hre))), new At({ id: t, geometry: new NF(this._options), modelMatrix: t.computeModelMatrixForHeightReference(e, t.cylinder.heightReference, this._options.length * .5, this._scene.mapProjection.ellipsoid), attributes: r }) }; El.prototype._computeCenter = function (e, t) { return j.getValueOrUndefined(this._entity.position, e, t) }; El.prototype._isHidden = function (e, t) { return !l(e.position) || !l(t.length) || !l(t.topRadius) || !l(t.bottomRadius) || ei.prototype._isHidden.call(this, e, t) }; El.prototype._isDynamic = function (e, t) { return !e.position.isConstant || !j.isConstant(e.orientation) || !t.length.isConstant || !t.topRadius.isConstant || !t.bottomRadius.isConstant || !j.isConstant(t.slices) || !j.isConstant(t.outlineWidth) || !j.isConstant(t.numberOfVerticalLines) }; El.prototype._setStaticOptions = function (e, t) { let n = j.getValueOrDefault(t.heightReference, ke.MINIMUM_VALUE, ze.NONE), i = this._options; i.vertexFormat = this._materialProperty instanceof Ot ? $t.VERTEX_FORMAT : eo.MaterialSupport.TEXTURED.vertexFormat, i.length = t.length.getValue(ke.MINIMUM_VALUE), i.topRadius = t.topRadius.getValue(ke.MINIMUM_VALUE), i.bottomRadius = t.bottomRadius.getValue(ke.MINIMUM_VALUE), i.slices = j.getValueOrUndefined(t.slices, ke.MINIMUM_VALUE), i.numberOfVerticalLines = j.getValueOrUndefined(t.numberOfVerticalLines, ke.MINIMUM_VALUE), i.offsetAttribute = n !== ze.NONE ? Qt.ALL : void 0 }; El.prototype._onEntityPropertyChanged = Wp; El.DynamicGeometryUpdater = Jx; function Jx(e, t, n) { $n.call(this, e, t, n) } l(Object.create) && (Jx.prototype = Object.create($n.prototype), Jx.prototype.constructor = Jx); Jx.prototype._isHidden = function (e, t, n) { let i = this._options, o = j.getValueOrUndefined(e.position, n, o5e); return !l(o) || !l(i.length) || !l(i.topRadius) || !l(i.bottomRadius) || $n.prototype._isHidden.call(this, e, t, n) }; Jx.prototype._setOptions = function (e, t, n) { let i = j.getValueOrDefault(t.heightReference, n, ze.NONE), o = this._options; o.length = j.getValueOrUndefined(t.length, n), o.topRadius = j.getValueOrUndefined(t.topRadius, n), o.bottomRadius = j.getValueOrUndefined(t.bottomRadius, n), o.slices = j.getValueOrUndefined(t.slices, n), o.numberOfVerticalLines = j.getValueOrUndefined(t.numberOfVerticalLines, n), o.offsetAttribute = i !== ze.NONE ? Qt.ALL : void 0 }; var VF = El; var s5e = { UNBOUNDED: 0, CLAMPED: 1, LOOP_STOP: 2 }, Br = Object.freeze(s5e); var a5e = { TICK_DEPENDENT: 0, SYSTEM_CLOCK_MULTIPLIER: 1, SYSTEM_CLOCK: 2 }, uo = Object.freeze(a5e); var c5e = { NONE: 0, HOLD: 1, EXTRAPOLATE: 2 }, Ou = Object.freeze(c5e); var pre = po(al(), 1); function l5e(e) { let t = new pre.default(e); t.normalize(); let n = t.path(), i = n.lastIndexOf("/"); return i !== -1 && (n = n.substr(i + 1)), n } var q_ = l5e; var u5e = I.factorial; function b6(e, t, n, i, o, r) { let s = 0, a, c, u; if (i > 0) { for (c = 0; c < o; c++) { for (a = !1, u = 0; u < r.length && !a; u++)c === r[u] && (a = !0); a || (r.push(c), s += b6(e, t, n, i - 1, o, r), r.splice(r.length - 1, 1)) } return s } for (s = 1, c = 0; c < o; c++) { for (a = !1, u = 0; u < r.length && !a; u++)c === r[u] && (a = !0); a || (s *= e - n[t[c]]) } return s } var kF = { type: "Hermite" }; kF.getRequiredDataPoints = function (e, t) { return t = y(t, 0), Math.max(Math.floor((e + 1) / (t + 1)), 2) }; kF.interpolateOrderZero = function (e, t, n, i, o) { l(o) || (o = new Array(i)); let r, s, a, c, u, f, d = t.length, p = new Array(i); for (r = 0; r < i; r++) { o[r] = 0; let C = new Array(d); for (p[r] = C, s = 0; s < d; s++)C[s] = [] } let g = d, m = new Array(g); for (r = 0; r < g; r++)m[r] = r; let A = d - 1; for (c = 0; c < i; c++) { for (s = 0; s < g; s++)f = m[s] * i + c, p[c][0].push(n[f]); for (r = 1; r < g; r++) { let C = !1; for (s = 0; s < g - r; s++) { let x = t[m[s]], T = t[m[s + r]], b; T - x <= 0 ? (f = m[s] * i + i * r + c, b = n[f], p[c][r].push(b / u5e(r))) : (b = p[c][r - 1][s + 1] - p[c][r - 1][s], p[c][r].push(b / (T - x))), C = C || b !== 0 } C || (A = r - 1) } } for (a = 0, u = 0; a <= u; a++)for (r = a; r <= A; r++) { let C = b6(e, m, t, a, r, []); for (c = 0; c < i; c++) { let x = p[c][r][0]; o[c + a * i] += x * C } } return o }; var f5e = []; kF.interpolate = function (e, t, n, i, o, r, s) { let a = i * (r + 1); l(s) || (s = new Array(a)); for (let x = 0; x < a; x++)s[x] = 0; let c = t.length, u = new Array(c * (o + 1)), f; for (f = 0; f < c; f++)for (let x = 0; x < o + 1; x++)u[f * (o + 1) + x] = f; let d = u.length, p = f5e, g = d5e(p, u, t, n, i, o), m = [], A = d * (d + 1) / 2, C = Math.min(g, r); for (let x = 0; x <= C; x++)for (f = x; f <= g; f++) { m.length = 0; let T = b6(e, u, t, x, f, m), b = Math.floor(f * (1 - f) / 2) + d * f; for (let S = 0; S < i; S++) { let D = Math.floor(S * A), P = p[D + b]; s[S + x * i] += P * T } } return s }; function d5e(e, t, n, i, o, r) { let s, a, c = -1, u = t.length, f = u * (u + 1) / 2; for (let d = 0; d < o; d++) { let p = Math.floor(d * f); for (s = 0; s < u; s++)a = t[s] * o * (r + 1) + d, e[p + s] = i[a]; for (let g = 1; g < u; g++) { let m = 0, A = Math.floor(g * (1 - g) / 2) + u * g, C = !1; for (s = 0; s < u - g; s++) { let x = n[t[s]], T = n[t[s + g]], b, S; if (T - x <= 0) a = t[s] * o * (r + 1) + o * g + d, b = i[a], S = b / I.factorial(g), e[p + A + m] = S, m++; else { let D = Math.floor((g - 1) * (2 - g) / 2) + u * (g - 1); b = e[p + D + s + 1] - e[p + D + s], S = b / (T - x), e[p + A + m] = S, m++ } C = C || b !== 0 } C && (c = Math.max(c, g)) } } return c } var UF = kF; var S6 = { type: "Lagrange" }; S6.getRequiredDataPoints = function (e) { return Math.max(e + 1, 2) }; S6.interpolateOrderZero = function (e, t, n, i, o) { l(o) || (o = new Array(i)); let r, s, a = t.length; for (r = 0; r < i; r++)o[r] = 0; for (r = 0; r < a; r++) { let c = 1; for (s = 0; s < a; s++)if (s !== r) { let u = t[r] - t[s]; c *= (e - t[s]) / u } for (s = 0; s < i; s++)o[s] += c * n[r * i + s] } return o }; var zF = S6; var w6 = { type: "Linear" }; w6.getRequiredDataPoints = function (e) { return 2 }; w6.interpolateOrderZero = function (e, t, n, i, o) { l(o) || (o = new Array(i)); let r, s, a, c = t[0], u = t[1]; for (r = 0; r < i; r++)s = n[r], a = n[r + i], o[r] = ((a - s) * e + u * s - c * a) / (u - c); return o }; var Zx = w6; function Ia(e, t, n) { this.clock = y(e, 0), this.cone = y(t, 0), this.magnitude = y(n, 1) } Ia.fromCartesian3 = function (e, t) { let n = e.x, i = e.y, o = e.z, r = n * n + i * i; return l(t) || (t = new Ia), t.clock = Math.atan2(i, n), t.cone = Math.atan2(Math.sqrt(r), o), t.magnitude = Math.sqrt(r + o * o), t }; Ia.clone = function (e, t) { if (!!l(e)) return l(t) ? (t.clock = e.clock, t.cone = e.cone, t.magnitude = e.magnitude, t) : new Ia(e.clock, e.cone, e.magnitude) }; Ia.normalize = function (e, t) { return l(t) ? (t.clock = e.clock, t.cone = e.cone, t.magnitude = 1, t) : new Ia(e.clock, e.cone, 1) }; Ia.equals = function (e, t) { return e === t || l(e) && l(t) && e.clock === t.clock && e.cone === t.cone && e.magnitude === t.magnitude }; Ia.equalsEpsilon = function (e, t, n) { return n = y(n, 0), e === t || l(e) && l(t) && Math.abs(e.clock - t.clock) <= n && Math.abs(e.cone - t.cone) <= n && Math.abs(e.magnitude - t.magnitude) <= n }; Ia.prototype.equals = function (e) { return Ia.equals(this, e) }; Ia.prototype.clone = function (e) { return Ia.clone(this, e) }; Ia.prototype.equalsEpsilon = function (e, t) { return Ia.equalsEpsilon(this, e, t) }; Ia.prototype.toString = function () { return `(${this.clock}, ${this.cone}, ${this.magnitude})` }; var HF = Ia; var zw = po(al(), 1); var D6; typeof performance < "u" && typeof performance.now == "function" && isFinite(performance.now()) ? D6 = function () { return performance.now() } : D6 = function () { return Date.now() }; var Ei = D6; function v6(e) { e = y(e, y.EMPTY_OBJECT); let t = e.currentTime, n = e.startTime, i = e.stopTime; l(t) ? t = $.clone(t) : l(n) ? t = $.clone(n) : l(i) ? t = $.addDays(i, -1, new $) : t = $.now(), l(n) ? n = $.clone(n) : n = $.clone(t), l(i) ? i = $.clone(i) : i = $.addDays(n, 1, new $), this.startTime = n, this.stopTime = i, this.clockRange = y(e.clockRange, Br.UNBOUNDED), this.canAnimate = y(e.canAnimate, !0), this.onTick = new _e, this.onStop = new _e, this._currentTime = void 0, this._multiplier = void 0, this._clockStep = void 0, this._shouldAnimate = void 0, this._lastSystemTime = Ei(), this.currentTime = t, this.multiplier = y(e.multiplier, 1), this.shouldAnimate = y(e.shouldAnimate, !1), this.clockStep = y(e.clockStep, uo.SYSTEM_CLOCK_MULTIPLIER) } Object.defineProperties(v6.prototype, { currentTime: { get: function () { return this._currentTime }, set: function (e) { $.equals(this._currentTime, e) || (this._clockStep === uo.SYSTEM_CLOCK && (this._clockStep = uo.SYSTEM_CLOCK_MULTIPLIER), this._currentTime = e) } }, multiplier: { get: function () { return this._multiplier }, set: function (e) { this._multiplier !== e && (this._clockStep === uo.SYSTEM_CLOCK && (this._clockStep = uo.SYSTEM_CLOCK_MULTIPLIER), this._multiplier = e) } }, clockStep: { get: function () { return this._clockStep }, set: function (e) { e === uo.SYSTEM_CLOCK && (this._multiplier = 1, this._shouldAnimate = !0, this._currentTime = $.now()), this._clockStep = e } }, shouldAnimate: { get: function () { return this._shouldAnimate }, set: function (e) { this._shouldAnimate !== e && (this._clockStep === uo.SYSTEM_CLOCK && (this._clockStep = uo.SYSTEM_CLOCK_MULTIPLIER), this._shouldAnimate = e) } } }); v6.prototype.tick = function () { let e = Ei(), t = $.clone(this._currentTime); if (this.canAnimate && this._shouldAnimate) { let n = this._clockStep; if (n === uo.SYSTEM_CLOCK) t = $.now(t); else { let i = this._multiplier; if (n === uo.TICK_DEPENDENT) t = $.addSeconds(t, i, t); else { let a = e - this._lastSystemTime; t = $.addSeconds(t, i * (a / 1e3), t) } let o = this.clockRange, r = this.startTime, s = this.stopTime; if (o === Br.CLAMPED) $.lessThan(t, r) ? t = $.clone(r, t) : $.greaterThan(t, s) && (t = $.clone(s, t), this.onStop.raiseEvent(this)); else if (o === Br.LOOP_STOP) for ($.lessThan(t, r) && (t = $.clone(r, t)); $.greaterThan(t, s);)t = $.addSeconds(r, $.secondsDifference(t, s), t), this.onStop.raiseEvent(this) } } return this._currentTime = t, this._lastSystemTime = e, this.onTick.raiseEvent(this), t }; var sh = v6; function Ay() { this._definitionChanged = new _e, this._startTime = void 0, this._stopTime = void 0, this._currentTime = void 0, this._clockRange = void 0, this._clockStep = void 0, this._multiplier = void 0 } Object.defineProperties(Ay.prototype, { definitionChanged: { get: function () { return this._definitionChanged } }, startTime: dl("startTime"), stopTime: dl("stopTime"), currentTime: dl("currentTime"), clockRange: dl("clockRange"), clockStep: dl("clockStep"), multiplier: dl("multiplier") }); Ay.prototype.clone = function (e) { return l(e) || (e = new Ay), e.startTime = this.startTime, e.stopTime = this.stopTime, e.currentTime = this.currentTime, e.clockRange = this.clockRange, e.clockStep = this.clockStep, e.multiplier = this.multiplier, e }; Ay.prototype.equals = function (e) { return this === e || l(e) && $.equals(this.startTime, e.startTime) && $.equals(this.stopTime, e.stopTime) && $.equals(this.currentTime, e.currentTime) && this.clockRange === e.clockRange && this.clockStep === e.clockStep && this.multiplier === e.multiplier }; Ay.prototype.merge = function (e) { this.startTime = y(this.startTime, e.startTime), this.stopTime = y(this.stopTime, e.stopTime), this.currentTime = y(this.currentTime, e.currentTime), this.clockRange = y(this.clockRange, e.clockRange), this.clockStep = y(this.clockStep, e.clockStep), this.multiplier = y(this.multiplier, e.multiplier) }; Ay.prototype.getValue = function (e) { return l(e) || (e = new sh), e.startTime = y(this.startTime, e.startTime), e.stopTime = y(this.stopTime, e.stopTime), e.currentTime = y(this.currentTime, e.currentTime), e.clockRange = y(this.clockRange, e.clockRange), e.multiplier = y(this.multiplier, e.multiplier), e.clockStep = y(this.clockStep, e.clockStep), e }; var ah = Ay; var h5e = U.WHITE, m5e = .1, p5e = new H(8, 8), _5e = new H(0, 0), g5e = new H(1, 1); function Qx(e) { e = y(e, y.EMPTY_OBJECT), this._definitionChanged = new _e, this._color = void 0, this._colorSubscription = void 0, this._cellAlpha = void 0, this._cellAlphaSubscription = void 0, this._lineCount = void 0, this._lineCountSubscription = void 0, this._lineThickness = void 0, this._lineThicknessSubscription = void 0, this._lineOffset = void 0, this._lineOffsetSubscription = void 0, this.color = e.color, this.cellAlpha = e.cellAlpha, this.lineCount = e.lineCount, this.lineThickness = e.lineThickness, this.lineOffset = e.lineOffset } Object.defineProperties(Qx.prototype, { isConstant: { get: function () { return j.isConstant(this._color) && j.isConstant(this._cellAlpha) && j.isConstant(this._lineCount) && j.isConstant(this._lineThickness) && j.isConstant(this._lineOffset) } }, definitionChanged: { get: function () { return this._definitionChanged } }, color: ae("color"), cellAlpha: ae("cellAlpha"), lineCount: ae("lineCount"), lineThickness: ae("lineThickness"), lineOffset: ae("lineOffset") }); Qx.prototype.getType = function (e) { return "Grid" }; Qx.prototype.getValue = function (e, t) { return l(t) || (t = {}), t.color = j.getValueOrClonedDefault(this._color, e, h5e, t.color), t.cellAlpha = j.getValueOrDefault(this._cellAlpha, e, m5e), t.lineCount = j.getValueOrClonedDefault(this._lineCount, e, p5e, t.lineCount), t.lineThickness = j.getValueOrClonedDefault(this._lineThickness, e, g5e, t.lineThickness), t.lineOffset = j.getValueOrClonedDefault(this._lineOffset, e, _5e, t.lineOffset), t }; Qx.prototype.equals = function (e) { return this === e || e instanceof Qx && j.equals(this._color, e._color) && j.equals(this._cellAlpha, e._cellAlpha) && j.equals(this._lineCount, e._lineCount) && j.equals(this._lineThickness, e._lineThickness) && j.equals(this._lineOffset, e._lineOffset) }; var Bw = Qx; function $x(e) { this._definitionChanged = new _e, this._color = void 0, this._colorSubscription = void 0, this.color = e } Object.defineProperties($x.prototype, { isConstant: { get: function () { return j.isConstant(this._color) } }, definitionChanged: { get: function () { return this._definitionChanged } }, color: ae("color") }); $x.prototype.getType = function (e) { return "PolylineArrow" }; $x.prototype.getValue = function (e, t) { return l(t) || (t = {}), t.color = j.getValueOrClonedDefault(this._color, e, U.WHITE, t.color), t }; $x.prototype.equals = function (e) { return this === e || e instanceof $x && j.equals(this._color, e._color) }; var Rw = $x; var y5e = U.WHITE, A5e = U.TRANSPARENT, C5e = 16, x5e = 255; function eT(e) { e = y(e, y.EMPTY_OBJECT), this._definitionChanged = new _e, this._color = void 0, this._colorSubscription = void 0, this._gapColor = void 0, this._gapColorSubscription = void 0, this._dashLength = void 0, this._dashLengthSubscription = void 0, this._dashPattern = void 0, this._dashPatternSubscription = void 0, this.color = e.color, this.gapColor = e.gapColor, this.dashLength = e.dashLength, this.dashPattern = e.dashPattern } Object.defineProperties(eT.prototype, { isConstant: { get: function () { return j.isConstant(this._color) && j.isConstant(this._gapColor) && j.isConstant(this._dashLength) && j.isConstant(this._dashPattern) } }, definitionChanged: { get: function () { return this._definitionChanged } }, color: ae("color"), gapColor: ae("gapColor"), dashLength: ae("dashLength"), dashPattern: ae("dashPattern") }); eT.prototype.getType = function (e) { return "PolylineDash" }; eT.prototype.getValue = function (e, t) { return l(t) || (t = {}), t.color = j.getValueOrClonedDefault(this._color, e, y5e, t.color), t.gapColor = j.getValueOrClonedDefault(this._gapColor, e, A5e, t.gapColor), t.dashLength = j.getValueOrDefault(this._dashLength, e, C5e, t.dashLength), t.dashPattern = j.getValueOrDefault(this._dashPattern, e, x5e, t.dashPattern), t }; eT.prototype.equals = function (e) { return this === e || e instanceof eT && j.equals(this._color, e._color) && j.equals(this._gapColor, e._gapColor) && j.equals(this._dashLength, e._dashLength) && j.equals(this._dashPattern, e._dashPattern) }; var Mw = eT; var T5e = U.WHITE, E5e = .25, b5e = 1; function tT(e) { e = y(e, y.EMPTY_OBJECT), this._definitionChanged = new _e, this._color = void 0, this._colorSubscription = void 0, this._glowPower = void 0, this._glowPowerSubscription = void 0, this._taperPower = void 0, this._taperPowerSubscription = void 0, this.color = e.color, this.glowPower = e.glowPower, this.taperPower = e.taperPower } Object.defineProperties(tT.prototype, { isConstant: { get: function () { return j.isConstant(this._color) && j.isConstant(this._glow) } }, definitionChanged: { get: function () { return this._definitionChanged } }, color: ae("color"), glowPower: ae("glowPower"), taperPower: ae("taperPower") }); tT.prototype.getType = function (e) { return "PolylineGlow" }; tT.prototype.getValue = function (e, t) { return l(t) || (t = {}), t.color = j.getValueOrClonedDefault(this._color, e, T5e, t.color), t.glowPower = j.getValueOrDefault(this._glowPower, e, E5e, t.glowPower), t.taperPower = j.getValueOrDefault(this._taperPower, e, b5e, t.taperPower), t }; tT.prototype.equals = function (e) { return this === e || e instanceof tT && j.equals(this._color, e._color) && j.equals(this._glowPower, e._glowPower) && j.equals(this._taperPower, e._taperPower) }; var Lw = tT; var S5e = U.WHITE, w5e = U.BLACK, D5e = 1; function nT(e) { e = y(e, y.EMPTY_OBJECT), this._definitionChanged = new _e, this._color = void 0, this._colorSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this.color = e.color, this.outlineColor = e.outlineColor, this.outlineWidth = e.outlineWidth } Object.defineProperties(nT.prototype, { isConstant: { get: function () { return j.isConstant(this._color) && j.isConstant(this._outlineColor) && j.isConstant(this._outlineWidth) } }, definitionChanged: { get: function () { return this._definitionChanged } }, color: ae("color"), outlineColor: ae("outlineColor"), outlineWidth: ae("outlineWidth") }); nT.prototype.getType = function (e) { return "PolylineOutline" }; nT.prototype.getValue = function (e, t) { return l(t) || (t = {}), t.color = j.getValueOrClonedDefault(this._color, e, S5e, t.color), t.outlineColor = j.getValueOrClonedDefault(this._outlineColor, e, w5e, t.outlineColor), t.outlineWidth = j.getValueOrDefault(this._outlineWidth, e, D5e), t }; nT.prototype.equals = function (e) { return this === e || e instanceof nT && j.equals(this._color, e._color) && j.equals(this._outlineColor, e._outlineColor) && j.equals(this._outlineWidth, e._outlineWidth) }; var Cy = nT; function Qm(e, t) { this._value = void 0, this._definitionChanged = new _e, this._eventHelper = new Pr, this._referenceFrame = y(t, Ji.FIXED), this.setValue(e) } Object.defineProperties(Qm.prototype, { isConstant: { get: function () { let e = this._value; if (!l(e)) return !0; let t = e.length; for (let n = 0; n < t; n++)if (!j.isConstant(e[n])) return !1; return !0 } }, definitionChanged: { get: function () { return this._definitionChanged } }, referenceFrame: { get: function () { return this._referenceFrame } } }); Qm.prototype.getValue = function (e, t) { return this.getValueInReferenceFrame(e, Ji.FIXED, t) }; Qm.prototype.getValueInReferenceFrame = function (e, t, n) { let i = this._value; if (!l(i)) return; let o = i.length; l(n) || (n = new Array(o)); let r = 0, s = 0; for (; r < o;) { let c = i[r].getValueInReferenceFrame(e, t, n[r]); l(c) && (n[s] = c, s++), r++ } return n.length = s, n }; Qm.prototype.setValue = function (e) { let t = this._eventHelper; if (t.removeAll(), l(e)) { this._value = e.slice(); let n = e.length; for (let i = 0; i < n; i++) { let o = e[i]; l(o) && t.add(o.definitionChanged, Qm.prototype._raiseDefinitionChanged, this) } } else this._value = void 0; this._definitionChanged.raiseEvent(this) }; Qm.prototype.equals = function (e) { return this === e || e instanceof Qm && this._referenceFrame === e._referenceFrame && j.arrayEquals(this._value, e._value) }; Qm.prototype._raiseDefinitionChanged = function () { this._definitionChanged.raiseEvent(this) }; var Y_ = Qm; function X_(e) { this._value = void 0, this._definitionChanged = new _e, this._eventHelper = new Pr, this.setValue(e) } Object.defineProperties(X_.prototype, { isConstant: { get: function () { let e = this._value; if (!l(e)) return !0; let t = e.length; for (let n = 0; n < t; n++)if (!j.isConstant(e[n])) return !1; return !0 } }, definitionChanged: { get: function () { return this._definitionChanged } } }); X_.prototype.getValue = function (e, t) { let n = this._value; if (!l(n)) return; let i = n.length; l(t) || (t = new Array(i)); let o = 0, r = 0; for (; o < i;) { let a = this._value[o].getValue(e, t[o]); l(a) && (t[r] = a, r++), o++ } return t.length = r, t }; X_.prototype.setValue = function (e) { let t = this._eventHelper; if (t.removeAll(), l(e)) { this._value = e.slice(); let n = e.length; for (let i = 0; i < n; i++) { let o = e[i]; l(o) && t.add(o.definitionChanged, X_.prototype._raiseDefinitionChanged, this) } } else this._value = void 0; this._definitionChanged.raiseEvent(this) }; X_.prototype.equals = function (e) { return this === e || e instanceof X_ && j.arrayEquals(this._value, e._value) }; X_.prototype._raiseDefinitionChanged = function () { this._definitionChanged.raiseEvent(this) }; var Fw = X_; function xy(e) { let t = e._targetProperty; if (!l(t)) { let n = e._targetEntity; if (!l(n)) { if (n = e._targetCollection.getById(e._targetId), !l(n)) { e._targetEntity = e._targetProperty = void 0; return } n.definitionChanged.addEventListener(bl.prototype._onTargetEntityDefinitionChanged, e), e._targetEntity = n } let i = e._targetPropertyNames; t = e._targetEntity; for (let o = 0, r = i.length; o < r && l(t); ++o)t = t[i[o]]; e._targetProperty = t } return t } function bl(e, t, n) { this._targetCollection = e, this._targetId = t, this._targetPropertyNames = n, this._targetProperty = void 0, this._targetEntity = void 0, this._definitionChanged = new _e, e.collectionChanged.addEventListener(bl.prototype._onCollectionChanged, this) } Object.defineProperties(bl.prototype, { isConstant: { get: function () { return j.isConstant(xy(this)) } }, definitionChanged: { get: function () { return this._definitionChanged } }, referenceFrame: { get: function () { let e = xy(this); return l(e) ? e.referenceFrame : void 0 } }, targetId: { get: function () { return this._targetId } }, targetCollection: { get: function () { return this._targetCollection } }, targetPropertyNames: { get: function () { return this._targetPropertyNames } }, resolvedProperty: { get: function () { return xy(this) } } }); bl.fromString = function (e, t) { let n, i = [], o = !0, r = !1, s = ""; for (let a = 0; a < t.length; ++a) { let c = t.charAt(a); r ? (s += c, r = !1) : c === "\\" ? r = !0 : o && c === "#" ? (n = s, o = !1, s = "") : !o && c === "." ? (i.push(s), s = "") : s += c } return i.push(s), new bl(e, n, i) }; bl.prototype.getValue = function (e, t) { let n = xy(this); return l(n) ? n.getValue(e, t) : void 0 }; bl.prototype.getValueInReferenceFrame = function (e, t, n) { let i = xy(this); return l(i) ? i.getValueInReferenceFrame(e, t, n) : void 0 }; bl.prototype.getType = function (e) { let t = xy(this); return l(t) ? t.getType(e) : void 0 }; bl.prototype.equals = function (e) { if (this === e) return !0; let t = this._targetPropertyNames, n = e._targetPropertyNames; if (this._targetCollection !== e._targetCollection || this._targetId !== e._targetId || t.length !== n.length) return !1; let i = this._targetPropertyNames.length; for (let o = 0; o < i; o++)if (t[o] !== n[o]) return !1; return !0 }; bl.prototype._onTargetEntityDefinitionChanged = function (e, t, n, i) { l(this._targetProperty) && this._targetPropertyNames[0] === t && (this._targetProperty = void 0, this._definitionChanged.raiseEvent(this)) }; bl.prototype._onCollectionChanged = function (e, t, n) { let i = this._targetEntity; l(i) && n.indexOf(i) !== -1 ? (i.definitionChanged.removeEventListener(bl.prototype._onTargetEntityDefinitionChanged, this), this._targetEntity = this._targetProperty = void 0) : l(i) || (i = xy(this), l(i) && this._definitionChanged.raiseEvent(this)) }; var K_ = bl; var v5e = { packedLength: 1, pack: function (e, t, n) { return n = y(n, 0), t[n] = e, t }, unpack: function (e, t, n) { return t = y(t, 0), e[t] }, convertPackedArrayForInterpolation: function (e, t, n, i) { l(i) || (i = []), t = y(t, 0), n = y(n, e.length); let o; for (let r = 0, s = n - t + 1; r < s; r++) { let a = e[t + r]; r === 0 || Math.abs(o - a) < Math.PI ? i[r] = a : i[r] = a - I.TWO_PI, o = a } }, unpackInterpolationResult: function (e, t, n, i, o) { return o = e[0], o < 0 ? o + I.TWO_PI : o } }, Vf = v5e; var _re = { packedLength: 1, pack: function (e, t, n) { n = y(n, 0), t[n] = e }, unpack: function (e, t, n) { return t = y(t, 0), e[t] } }; function gre(e, t, n) { let i, o = e.length, r = n.length, s = o + r; if (e.length = s, o !== t) { let a = o - 1; for (i = s - 1; i >= t; i--)e[i] = e[a--] } for (i = 0; i < r; i++)e[t++] = n[i] } function yre(e, t) { return e instanceof $ ? e : typeof e == "string" ? $.fromIso8601(e) : $.addSeconds(t, e, new $) } var P6 = [], I6 = []; function GF(e, t, n, i, o) { let r = 0, s, a, c, u, f, d; for (; r < i.length;) { f = yre(i[r], e), c = Wo(t, f, $.compare); let p = 0, g = 0; if (c < 0) { for (c = ~c, u = c * o, a = void 0, d = t[c]; r < i.length && (f = yre(i[r], e), !(l(a) && $.compare(a, f) >= 0 || l(d) && $.compare(f, d) >= 0));) { for (P6[p++] = f, r = r + 1, s = 0; s < o; s++)I6[g++] = i[r], r = r + 1; a = f } p > 0 && (I6.length = g, gre(n, u, I6), P6.length = p, gre(t, c, P6)) } else { for (s = 0; s < o; s++)r++, n[c * o + s] = i[r]; r++ } } } function kf(e, t) { let n = e; n === Number && (n = _re); let i = n.packedLength, o = y(n.packedInterpolationLength, i), r = 0, s; if (l(t)) { let a = t.length; s = new Array(a); for (let c = 0; c < a; c++) { let u = t[c]; u === Number && (u = _re); let f = u.packedLength; i += f, o += y(u.packedInterpolationLength, f), s[c] = u } r = a } this._type = e, this._innerType = n, this._interpolationDegree = 1, this._interpolationAlgorithm = Zx, this._numberOfPoints = 0, this._times = [], this._values = [], this._xTable = [], this._yTable = [], this._packedLength = i, this._packedInterpolationLength = o, this._updateTableLength = !0, this._interpolationResult = new Array(o), this._definitionChanged = new _e, this._derivativeTypes = t, this._innerDerivativeTypes = s, this._inputOrder = r, this._forwardExtrapolationType = Ou.NONE, this._forwardExtrapolationDuration = 0, this._backwardExtrapolationType = Ou.NONE, this._backwardExtrapolationDuration = 0 } Object.defineProperties(kf.prototype, { isConstant: { get: function () { return this._values.length === 0 } }, definitionChanged: { get: function () { return this._definitionChanged } }, type: { get: function () { return this._type } }, derivativeTypes: { get: function () { return this._derivativeTypes } }, interpolationDegree: { get: function () { return this._interpolationDegree } }, interpolationAlgorithm: { get: function () { return this._interpolationAlgorithm } }, forwardExtrapolationType: { get: function () { return this._forwardExtrapolationType }, set: function (e) { this._forwardExtrapolationType !== e && (this._forwardExtrapolationType = e, this._definitionChanged.raiseEvent(this)) } }, forwardExtrapolationDuration: { get: function () { return this._forwardExtrapolationDuration }, set: function (e) { this._forwardExtrapolationDuration !== e && (this._forwardExtrapolationDuration = e, this._definitionChanged.raiseEvent(this)) } }, backwardExtrapolationType: { get: function () { return this._backwardExtrapolationType }, set: function (e) { this._backwardExtrapolationType !== e && (this._backwardExtrapolationType = e, this._definitionChanged.raiseEvent(this)) } }, backwardExtrapolationDuration: { get: function () { return this._backwardExtrapolationDuration }, set: function (e) { this._backwardExtrapolationDuration !== e && (this._backwardExtrapolationDuration = e, this._definitionChanged.raiseEvent(this)) } } }); kf.prototype.getValue = function (e, t) { let n = this._times, i = n.length; if (i === 0) return; let o, r = this._innerType, s = this._values, a = Wo(n, e, $.compare); if (a < 0) { if (a = ~a, a === 0) { let S = n[a]; if (o = this._backwardExtrapolationDuration, this._backwardExtrapolationType === Ou.NONE || o !== 0 && $.secondsDifference(S, e) > o) return; if (this._backwardExtrapolationType === Ou.HOLD) return r.unpack(s, 0, t) } if (a >= i) { a = i - 1; let S = n[a]; if (o = this._forwardExtrapolationDuration, this._forwardExtrapolationType === Ou.NONE || o !== 0 && $.secondsDifference(e, S) > o) return; if (this._forwardExtrapolationType === Ou.HOLD) return a = i - 1, r.unpack(s, a * r.packedLength, t) } let c = this._xTable, u = this._yTable, f = this._interpolationAlgorithm, d = this._packedInterpolationLength, p = this._inputOrder; if (this._updateTableLength) { this._updateTableLength = !1; let S = Math.min(f.getRequiredDataPoints(this._interpolationDegree, p), i); S !== this._numberOfPoints && (this._numberOfPoints = S, c.length = S, u.length = S * d) } let g = this._numberOfPoints - 1; if (g < 1) return; let m = 0, A = i - 1; if (A - m + 1 >= g + 1) { let S = a - (g / 2 | 0) - 1; S < m && (S = m); let D = S + g; D > A && (D = A, S = D - g, S < m && (S = m)), m = S, A = D } let x = A - m + 1; for (let S = 0; S < x; ++S)c[S] = $.secondsDifference(n[m + S], n[A]); if (l(r.convertPackedArrayForInterpolation)) r.convertPackedArrayForInterpolation(s, m, A, u); else { let S = 0, D = this._packedLength, P = m * D, B = (A + 1) * D; for (; P < B;)u[S] = s[P], P++, S++ } let T = $.secondsDifference(e, n[A]), b; if (p === 0 || !l(f.interpolate)) b = f.interpolateOrderZero(T, c, u, d, this._interpolationResult); else { let S = Math.floor(d / (p + 1)); b = f.interpolate(T, c, u, S, p, p, this._interpolationResult) } return l(r.unpackInterpolationResult) ? r.unpackInterpolationResult(b, s, m, A, t) : r.unpack(b, 0, t) } return r.unpack(s, a * this._packedLength, t) }; kf.prototype.setInterpolationOptions = function (e) { if (!l(e)) return; let t = !1, n = e.interpolationAlgorithm, i = e.interpolationDegree; l(n) && this._interpolationAlgorithm !== n && (this._interpolationAlgorithm = n, t = !0), l(i) && this._interpolationDegree !== i && (this._interpolationDegree = i, t = !0), t && (this._updateTableLength = !0, this._definitionChanged.raiseEvent(this)) }; kf.prototype.addSample = function (e, t, n) { let i = this._innerDerivativeTypes, o = l(i), r = this._innerType, s = []; if (s.push(e), r.pack(t, s, s.length), o) { let a = i.length; for (let c = 0; c < a; c++)i[c].pack(n[c], s, s.length) } GF(void 0, this._times, this._values, s, this._packedLength), this._updateTableLength = !0, this._definitionChanged.raiseEvent(this) }; kf.prototype.addSamples = function (e, t, n) { let i = this._innerDerivativeTypes, o = l(i), r = this._innerType, s = e.length, a = []; for (let c = 0; c < s; c++)if (a.push(e[c]), r.pack(t[c], a, a.length), o) { let u = n[c], f = i.length; for (let d = 0; d < f; d++)i[d].pack(u[d], a, a.length) } GF(void 0, this._times, this._values, a, this._packedLength), this._updateTableLength = !0, this._definitionChanged.raiseEvent(this) }; kf.prototype.addSamplesPackedArray = function (e, t) { GF(t, this._times, this._values, e, this._packedLength), this._updateTableLength = !0, this._definitionChanged.raiseEvent(this) }; kf.prototype.removeSample = function (e) { let t = Wo(this._times, e, $.compare); return t < 0 ? !1 : (Are(this, t, 1), !0) }; function Are(e, t, n) { let i = e._packedLength; e._times.splice(t, n), e._values.splice(t * i, n * i), e._updateTableLength = !0, e._definitionChanged.raiseEvent(e) } kf.prototype.removeSamples = function (e) { let t = this._times, n = Wo(t, e.start, $.compare); n < 0 ? n = ~n : e.isStartIncluded || ++n; let i = Wo(t, e.stop, $.compare); i < 0 ? i = ~i : e.isStopIncluded && ++i, Are(this, n, i - n) }; kf.prototype.equals = function (e) { if (this === e) return !0; if (!l(e) || this._type !== e._type || this._interpolationDegree !== e._interpolationDegree || this._interpolationAlgorithm !== e._interpolationAlgorithm) return !1; let t = this._derivativeTypes, n = l(t), i = e._derivativeTypes, o = l(i); if (n !== o) return !1; let r, s; if (n) { if (s = t.length, s !== i.length) return !1; for (r = 0; r < s; r++)if (t[r] !== i[r]) return !1 } let a = this._times, c = e._times; if (s = a.length, s !== c.length) return !1; for (r = 0; r < s; r++)if (!$.equals(a[r], c[r])) return !1; let u = this._values, f = e._values; for (s = u.length, r = 0; r < s; r++)if (u[r] !== f[r]) return !1; return !0 }; kf._mergeNewSamples = GF; var Bu = kf; function Ru(e, t) { t = y(t, 0); let n; if (t > 0) { n = new Array(t); for (let i = 0; i < t; i++)n[i] = h } this._numberOfDerivatives = t, this._property = new Bu(h, n), this._definitionChanged = new _e, this._referenceFrame = y(e, Ji.FIXED), this._property._definitionChanged.addEventListener(function () { this._definitionChanged.raiseEvent(this) }, this) } Object.defineProperties(Ru.prototype, { isConstant: { get: function () { return this._property.isConstant } }, definitionChanged: { get: function () { return this._definitionChanged } }, referenceFrame: { get: function () { return this._referenceFrame } }, interpolationDegree: { get: function () { return this._property.interpolationDegree } }, interpolationAlgorithm: { get: function () { return this._property.interpolationAlgorithm } }, numberOfDerivatives: { get: function () { return this._numberOfDerivatives } }, forwardExtrapolationType: { get: function () { return this._property.forwardExtrapolationType }, set: function (e) { this._property.forwardExtrapolationType = e } }, forwardExtrapolationDuration: { get: function () { return this._property.forwardExtrapolationDuration }, set: function (e) { this._property.forwardExtrapolationDuration = e } }, backwardExtrapolationType: { get: function () { return this._property.backwardExtrapolationType }, set: function (e) { this._property.backwardExtrapolationType = e } }, backwardExtrapolationDuration: { get: function () { return this._property.backwardExtrapolationDuration }, set: function (e) { this._property.backwardExtrapolationDuration = e } } }); Ru.prototype.getValue = function (e, t) { return this.getValueInReferenceFrame(e, Ji.FIXED, t) }; Ru.prototype.getValueInReferenceFrame = function (e, t, n) { if (n = this._property.getValue(e, n), l(n)) return Up.convertToReferenceFrame(e, n, this._referenceFrame, t, n) }; Ru.prototype.setInterpolationOptions = function (e) { this._property.setInterpolationOptions(e) }; Ru.prototype.addSample = function (e, t, n) { let i = this._numberOfDerivatives; this._property.addSample(e, t, n) }; Ru.prototype.addSamples = function (e, t, n) { this._property.addSamples(e, t, n) }; Ru.prototype.addSamplesPackedArray = function (e, t) { this._property.addSamplesPackedArray(e, t) }; Ru.prototype.removeSample = function (e) { return this._property.removeSample(e) }; Ru.prototype.removeSamples = function (e) { this._property.removeSamples(e) }; Ru.prototype.equals = function (e) { return this === e || e instanceof Ru && j.equals(this._property, e._property) && this._referenceFrame === e._referenceFrame }; var ea = Ru; var P5e = { HORIZONTAL: 0, VERTICAL: 1 }, ch = Object.freeze(P5e); var I5e = ch.HORIZONTAL, O5e = U.WHITE, B5e = U.BLACK, R5e = 0, M5e = 1; function iT(e) { e = y(e, y.EMPTY_OBJECT), this._definitionChanged = new _e, this._orientation = void 0, this._orientationSubscription = void 0, this._evenColor = void 0, this._evenColorSubscription = void 0, this._oddColor = void 0, this._oddColorSubscription = void 0, this._offset = void 0, this._offsetSubscription = void 0, this._repeat = void 0, this._repeatSubscription = void 0, this.orientation = e.orientation, this.evenColor = e.evenColor, this.oddColor = e.oddColor, this.offset = e.offset, this.repeat = e.repeat } Object.defineProperties(iT.prototype, { isConstant: { get: function () { return j.isConstant(this._orientation) && j.isConstant(this._evenColor) && j.isConstant(this._oddColor) && j.isConstant(this._offset) && j.isConstant(this._repeat) } }, definitionChanged: { get: function () { return this._definitionChanged } }, orientation: ae("orientation"), evenColor: ae("evenColor"), oddColor: ae("oddColor"), offset: ae("offset"), repeat: ae("repeat") }); iT.prototype.getType = function (e) { return "Stripe" }; iT.prototype.getValue = function (e, t) { return l(t) || (t = {}), t.horizontal = j.getValueOrDefault(this._orientation, e, I5e) === ch.HORIZONTAL, t.evenColor = j.getValueOrClonedDefault(this._evenColor, e, O5e, t.evenColor), t.oddColor = j.getValueOrClonedDefault(this._oddColor, e, B5e, t.oddColor), t.offset = j.getValueOrDefault(this._offset, e, R5e), t.repeat = j.getValueOrDefault(this._repeat, e, M5e), t }; iT.prototype.equals = function (e) { return this === e || e instanceof iT && j.equals(this._orientation, e._orientation) && j.equals(this._evenColor, e._evenColor) && j.equals(this._oddColor, e._oddColor) && j.equals(this._offset, e._offset) && j.equals(this._repeat, e._repeat) }; var Nw = iT; function J_(e) { this._definitionChanged = new _e, this._intervals = new Ir, this._intervals.changedEvent.addEventListener(J_.prototype._intervalsChanged, this), this._referenceFrame = y(e, Ji.FIXED) } Object.defineProperties(J_.prototype, { isConstant: { get: function () { return this._intervals.isEmpty } }, definitionChanged: { get: function () { return this._definitionChanged } }, intervals: { get: function () { return this._intervals } }, referenceFrame: { get: function () { return this._referenceFrame } } }); J_.prototype.getValue = function (e, t) { return this.getValueInReferenceFrame(e, Ji.FIXED, t) }; J_.prototype.getValueInReferenceFrame = function (e, t, n) { let i = this._intervals.findDataForIntervalContainingDate(e); if (l(i)) return Up.convertToReferenceFrame(e, i, this._referenceFrame, t, n) }; J_.prototype.equals = function (e) { return this === e || e instanceof J_ && this._intervals.equals(e._intervals, j.equals) && this._referenceFrame === e._referenceFrame }; J_.prototype._intervalsChanged = function () { this._definitionChanged.raiseEvent(this) }; var Z_ = J_; function Ty() { this._definitionChanged = new _e, this._intervals = new Ir, this._intervals.changedEvent.addEventListener(Ty.prototype._intervalsChanged, this) } Object.defineProperties(Ty.prototype, { isConstant: { get: function () { return this._intervals.isEmpty } }, definitionChanged: { get: function () { return this._definitionChanged } }, intervals: { get: function () { return this._intervals } } }); Ty.prototype.getValue = function (e, t) { let n = this._intervals.findDataForIntervalContainingDate(e); return l(n) && typeof n.clone == "function" ? n.clone(t) : n }; Ty.prototype.equals = function (e) { return this === e || e instanceof Ty && this._intervals.equals(e._intervals, j.equals) }; Ty.prototype._intervalsChanged = function () { this._definitionChanged.raiseEvent(this) }; var Q_ = Ty; function oT(e, t) { this._position = void 0, this._subscription = void 0, this._definitionChanged = new _e, this._normalize = y(t, !0), this.position = e } Object.defineProperties(oT.prototype, { isConstant: { get: function () { return j.isConstant(this._position) } }, definitionChanged: { get: function () { return this._definitionChanged } }, position: { get: function () { return this._position }, set: function (e) { let t = this._position; t !== e && (l(t) && this._subscription(), this._position = e, l(e) && (this._subscription = e._definitionChanged.addEventListener(function () { this._definitionChanged.raiseEvent(this) }, this)), this._definitionChanged.raiseEvent(this)) } }, normalize: { get: function () { return this._normalize }, set: function (e) { this._normalize !== e && (this._normalize = e, this._definitionChanged.raiseEvent(this)) } } }); var L5e = new h, Cre = new h, xre = new $, O6 = 1 / 60; oT.prototype.getValue = function (e, t) { return this._getValue(e, t) }; oT.prototype._getValue = function (e, t, n) { l(t) || (t = new h); let i = this._position; if (j.isConstant(i)) return this._normalize ? void 0 : h.clone(h.ZERO, t); let o = i.getValue(e, L5e), r = i.getValue($.addSeconds(e, O6, xre), Cre); if (!l(o) || !l(r) && (r = o, o = i.getValue($.addSeconds(e, -O6, xre), Cre), !l(o))) return; if (h.equals(o, r)) return this._normalize ? void 0 : h.clone(h.ZERO, t); l(n) && o.clone(n); let s = h.subtract(r, o, t); return this._normalize ? h.normalize(s, t) : h.divideByScalar(s, O6, t) }; oT.prototype.equals = function (e) { return this === e || e instanceof oT && j.equals(this._position, e._position) }; var rT = oT; function Vw(e, t) { this._velocityVectorProperty = new rT(e, !0), this._subscription = void 0, this._ellipsoid = void 0, this._definitionChanged = new _e, this.ellipsoid = y(t, ie.WGS84); let n = this; this._velocityVectorProperty.definitionChanged.addEventListener(function () { n._definitionChanged.raiseEvent(n) }) } Object.defineProperties(Vw.prototype, { isConstant: { get: function () { return j.isConstant(this._velocityVectorProperty) } }, definitionChanged: { get: function () { return this._definitionChanged } }, position: { get: function () { return this._velocityVectorProperty.position }, set: function (e) { this._velocityVectorProperty.position = e } }, ellipsoid: { get: function () { return this._ellipsoid }, set: function (e) { this._ellipsoid !== e && (this._ellipsoid = e, this._definitionChanged.raiseEvent(this)) } } }); var Tre = new h, F5e = new h, Ere = new Q; Vw.prototype.getValue = function (e, t) { let n = this._velocityVectorProperty._getValue(e, F5e, Tre); if (!!l(n)) return It.rotationMatrixFromPositionVelocity(Tre, n, this._ellipsoid, Ere), Be.fromRotationMatrix(Ere, t) }; Vw.prototype.equals = function (e) { return this === e || e instanceof Vw && j.equals(this._velocityVectorProperty, e._velocityVectorProperty) && (this._ellipsoid === e._ellipsoid || this._ellipsoid.equals(e._ellipsoid)) }; var WF = Vw; function $_() { } $_.packedLength = h.packedLength; $_.unpack = h.unpack; $_.pack = h.pack; var B6; function kw(e, t) { return t[0] === "#" && (t = B6 + t), K_.fromString(e, t) } function bre(e, t, n) { if (l(n.reference)) return kw(t, n.reference); if (l(n.velocityReference)) { let i = kw(t, n.velocityReference); switch (e) { case h: case $_: return new rT(i, e === $_); case Be: return new WF(i) } } throw new fe(`${JSON.stringify(n)} is not valid CZML.`) } function N5e(e, t) { return new Nd(function (n, i) { return t(e.getValue(n, i)) }, e.isConstant) } var bi = new h, fc = new HF, Oa = new he, Ey = new yn, jF = new Be; function V5e(e) { let t = e.rgbaf; if (l(t)) return t; let n = e.rgba; if (!l(n)) return; let i = n.length; if (i === U.packedLength) return [U.byteToFloat(n[0]), U.byteToFloat(n[1]), U.byteToFloat(n[2]), U.byteToFloat(n[3])]; t = new Array(i); for (let o = 0; o < i; o += 5)t[o] = n[o], t[o + 1] = U.byteToFloat(n[o + 1]), t[o + 2] = U.byteToFloat(n[o + 2]), t[o + 3] = U.byteToFloat(n[o + 3]), t[o + 4] = U.byteToFloat(n[o + 4]); return t } function Sre(e, t) { let n = y(e.uri, e); return l(t) ? t.getDerivedResource({ url: n }) : Pe.createIfNeeded(n) } function k5e(e) { let t = e.wsen; if (l(t)) return t; let n = e.wsenDegrees; if (!l(n)) return; let i = n.length; if (i === ce.packedLength) return [I.toRadians(n[0]), I.toRadians(n[1]), I.toRadians(n[2]), I.toRadians(n[3])]; t = new Array(i); for (let o = 0; o < i; o += 5)t[o] = n[o], t[o + 1] = I.toRadians(n[o + 1]), t[o + 2] = I.toRadians(n[o + 2]), t[o + 3] = I.toRadians(n[o + 3]), t[o + 4] = I.toRadians(n[o + 4]); return t } function U5e(e) { let t = e.length; if (fc.magnitude = 1, t === 2) return fc.clock = e[0], fc.cone = e[1], h.fromSpherical(fc, bi), [bi.x, bi.y, bi.z]; let n = new Array(t / 3 * 4); for (let i = 0, o = 0; i < t; i += 3, o += 4)n[o] = e[i], fc.clock = e[i + 1], fc.cone = e[i + 2], h.fromSpherical(fc, bi), n[o + 1] = bi.x, n[o + 2] = bi.y, n[o + 3] = bi.z; return n } function z5e(e) { let t = e.length; if (t === 3) return fc.clock = e[0], fc.cone = e[1], fc.magnitude = e[2], h.fromSpherical(fc, bi), [bi.x, bi.y, bi.z]; let n = new Array(t); for (let i = 0; i < t; i += 4)n[i] = e[i], fc.clock = e[i + 1], fc.cone = e[i + 2], fc.magnitude = e[i + 3], h.fromSpherical(fc, bi), n[i + 1] = bi.x, n[i + 2] = bi.y, n[i + 3] = bi.z; return n } function H5e(e) { let t = e.length; if (t === 3) return Oa.longitude = e[0], Oa.latitude = e[1], Oa.height = e[2], ie.WGS84.cartographicToCartesian(Oa, bi), [bi.x, bi.y, bi.z]; let n = new Array(t); for (let i = 0; i < t; i += 4)n[i] = e[i], Oa.longitude = e[i + 1], Oa.latitude = e[i + 2], Oa.height = e[i + 3], ie.WGS84.cartographicToCartesian(Oa, bi), n[i + 1] = bi.x, n[i + 2] = bi.y, n[i + 3] = bi.z; return n } function G5e(e) { let t = e.length; if (t === 3) return Oa.longitude = I.toRadians(e[0]), Oa.latitude = I.toRadians(e[1]), Oa.height = e[2], ie.WGS84.cartographicToCartesian(Oa, bi), [bi.x, bi.y, bi.z]; let n = new Array(t); for (let i = 0; i < t; i += 4)n[i] = e[i], Oa.longitude = I.toRadians(e[i + 1]), Oa.latitude = I.toRadians(e[i + 2]), Oa.height = e[i + 3], ie.WGS84.cartographicToCartesian(Oa, bi), n[i + 1] = bi.x, n[i + 2] = bi.y, n[i + 3] = bi.z; return n } function R6(e) { let t = e.cartesian; if (l(t)) return t; let n = e.cartesianVelocity; if (l(n)) return n; let i = e.unitCartesian; if (l(i)) return i; let o = e.unitSpherical; if (l(o)) return U5e(o); let r = e.spherical; if (l(r)) return z5e(r); let s = e.cartographicRadians; if (l(s)) return H5e(s); let a = e.cartographicDegrees; if (l(a)) return G5e(a); throw new fe(`${JSON.stringify(e)} is not a valid CZML interval.`) } function wre(e, t) { h.unpack(e, t, bi), h.normalize(bi, bi), h.pack(bi, e, t) } function W5e(e) { let t = R6(e); if (t.length === 3) return wre(t, 0), t; for (let n = 1; n < t.length; n += 4)wre(t, n); return t } function Dre(e, t) { Be.unpack(e, t, jF), Be.normalize(jF, jF), Be.pack(jF, e, t) } function j5e(e) { let t = e.unitQuaternion; if (l(t)) { if (t.length === 4) return Dre(t, 0), t; for (let n = 1; n < t.length; n += 5)Dre(t, n) } return t } function vre(e) { return typeof e == "boolean" ? Boolean : typeof e == "number" ? Number : typeof e == "string" ? String : e.hasOwnProperty("array") ? Array : e.hasOwnProperty("boolean") ? Boolean : e.hasOwnProperty("boundingRectangle") ? Ge : e.hasOwnProperty("cartesian2") ? H : e.hasOwnProperty("cartesian") || e.hasOwnProperty("spherical") || e.hasOwnProperty("cartographicRadians") || e.hasOwnProperty("cartographicDegrees") ? h : e.hasOwnProperty("unitCartesian") || e.hasOwnProperty("unitSpherical") ? $_ : e.hasOwnProperty("rgba") || e.hasOwnProperty("rgbaf") ? U : e.hasOwnProperty("arcType") ? Yt : e.hasOwnProperty("classificationType") ? Ln : e.hasOwnProperty("colorBlendMode") ? oc : e.hasOwnProperty("cornerType") ? Ti : e.hasOwnProperty("heightReference") ? ze : e.hasOwnProperty("horizontalOrigin") ? ai : e.hasOwnProperty("date") ? $ : e.hasOwnProperty("labelStyle") ? Fo : e.hasOwnProperty("number") ? Number : e.hasOwnProperty("nearFarScalar") ? wt : e.hasOwnProperty("distanceDisplayCondition") ? bt : e.hasOwnProperty("object") || e.hasOwnProperty("value") ? Object : e.hasOwnProperty("unitQuaternion") ? Be : e.hasOwnProperty("shadowMode") ? hn : e.hasOwnProperty("string") ? String : e.hasOwnProperty("stripeOrientation") ? ch : e.hasOwnProperty("wsen") || e.hasOwnProperty("wsenDegrees") ? ce : e.hasOwnProperty("uri") ? zw.default : e.hasOwnProperty("verticalOrigin") ? Sn : Object } function q5e(e, t, n) { switch (e) { case Yt: return Yt[y(t.arcType, t)]; case Array: return t.array; case Boolean: return y(t.boolean, t); case Ge: return t.boundingRectangle; case H: return t.cartesian2; case h: return R6(t); case $_: return W5e(t); case U: return V5e(t); case Ln: return Ln[y(t.classificationType, t)]; case oc: return oc[y(t.colorBlendMode, t)]; case Ti: return Ti[y(t.cornerType, t)]; case ze: return ze[y(t.heightReference, t)]; case ai: return ai[y(t.horizontalOrigin, t)]; case Image: return Sre(t, n); case $: return $.fromIso8601(y(t.date, t)); case Fo: return Fo[y(t.labelStyle, t)]; case Number: return y(t.number, t); case wt: return t.nearFarScalar; case bt: return t.distanceDisplayCondition; case Object: return y(y(t.object, t.value), t); case Be: return j5e(t); case Vf: return y(t.number, t); case hn: return hn[y(y(t.shadowMode, t.shadows), t)]; case String: return y(t.string, t); case ch: return ch[y(t.stripeOrientation, t)]; case ce: return k5e(t); case zw.default: return Sre(t, n); case Sn: return Sn[y(t.verticalOrigin, t)]; default: throw new fe(e) } } var Y5e = { HERMITE: UF, LAGRANGE: zF, LINEAR: Zx }; function qF(e, t) { let n = e.interpolationAlgorithm, i = e.interpolationDegree; (l(n) || l(i)) && t.setInterpolationOptions({ interpolationAlgorithm: Y5e[n], interpolationDegree: i }); let o = e.forwardExtrapolationType; l(o) && (t.forwardExtrapolationType = Ou[o]); let r = e.forwardExtrapolationDuration; l(r) && (t.forwardExtrapolationDuration = r); let s = e.backwardExtrapolationType; l(s) && (t.backwardExtrapolationType = Ou[s]); let a = e.backwardExtrapolationDuration; l(a) && (t.backwardExtrapolationDuration = a) } var Pre = { iso8601: void 0 }; function er(e) { if (!!l(e)) return Pre.iso8601 = e, yn.fromIso8601(Pre) } function M6(e) { let t = ke.MAXIMUM_INTERVAL.clone(); return t.data = e, t } function Ire(e) { let t = new cc; return t.intervals.addInterval(M6(e)), t } function Ore(e) { let t = new $s(e.referenceFrame); return t.intervals.addInterval(M6(e)), t } function YF(e, t, n, i, o, r, s) { let a = er(i.interval); l(o) && (l(a) ? a = yn.intersect(a, o, Ey) : a = o); let c, u, f, d = !l(i.reference) && !l(i.velocityReference), p = l(a) && !a.equals(ke.MAXIMUM_INTERVAL); if (i.delete === !0) { if (!p) { t[n] = void 0; return } return Hre(t[n], a) } let g = !1; if (d) { if (u = q5e(e, i, r), !l(u)) return; c = y(e.packedLength, 1), f = y(u.length, 1), g = !l(i.array) && typeof u != "string" && f > c && e !== Object } let m = typeof e.unpack == "function" && e !== Vf; if (!g && !p) { d ? t[n] = new Yn(m ? e.unpack(u, 0) : u) : t[n] = bre(e, s, i); return } let A = t[n], C, x = i.epoch; if (l(x) && (C = $.fromIso8601(x)), g && !p) { A instanceof Bu || (t[n] = A = new Bu(e)), A.addSamplesPackedArray(u, C), qF(i, A); return } let T; if (!g && p) { a = a.clone(), d ? a.data = m ? e.unpack(u, 0) : u : a.data = bre(e, s, i), l(A) || (t[n] = A = d ? new Q_ : new cc), d && A instanceof Q_ ? A.intervals.addInterval(a) : A instanceof cc ? (d && (a.data = new Yn(a.data)), A.intervals.addInterval(a)) : (t[n] = A = Ire(A), d && (a.data = new Yn(a.data)), A.intervals.addInterval(a)); return } l(A) || (t[n] = A = new cc), A instanceof cc || (t[n] = A = Ire(A)); let b = A.intervals; T = b.findInterval(a), (!l(T) || !(T.data instanceof Bu)) && (T = a.clone(), T.data = new Bu(e), b.addInterval(T)), T.data.addSamplesPackedArray(u, C), qF(i, T.data) } function Hre(e, t) { if (e instanceof Bu) { e.removeSamples(t); return } else if (e instanceof Q_) { e.intervals.removeInterval(t); return } else if (e instanceof cc) { let n = e.intervals; for (let i = 0; i < n.length; ++i) { let o = yn.intersect(n.get(i), t, Ey); o.isEmpty || Hre(o.data, t) } n.removeInterval(t); return } } function me(e, t, n, i, o, r, s) { if (!!l(i)) if (Array.isArray(i)) for (let a = 0, c = i.length; a < c; ++a)YF(e, t, n, i[a], o, r, s); else YF(e, t, n, i, o, r, s) } function Bre(e, t, n, i, o, r) { let s = er(n.interval); l(i) && (l(s) ? s = yn.intersect(s, i, Ey) : s = i); let a = l(n.cartesianVelocity) ? 1 : 0, c = h.packedLength * (a + 1), u, f, d = !l(n.reference), p = l(s) && !s.equals(ke.MAXIMUM_INTERVAL); if (n.delete === !0) { if (!p) { e[t] = void 0; return } return Gre(e[t], s) } let g, m = !1; if (d && (l(n.referenceFrame) && (g = Ji[n.referenceFrame]), g = y(g, Ji.FIXED), u = R6(n), f = y(u.length, 1), m = f > c), !m && !p) { d ? e[t] = new Mc(h.unpack(u), g) : e[t] = kw(r, n.reference); return } let A = e[t], C, x = n.epoch; if (l(x) && (C = $.fromIso8601(x)), m && !p) { (!(A instanceof ea) || l(g) && A.referenceFrame !== g) && (e[t] = A = new ea(g, a)), A.addSamplesPackedArray(u, C), qF(n, A); return } let T; if (!m && p) { s = s.clone(), d ? s.data = h.unpack(u) : s.data = kw(r, n.reference), l(A) || (d ? A = new Z_(g) : A = new $s(g), e[t] = A), d && A instanceof Z_ && l(g) && A.referenceFrame === g ? A.intervals.addInterval(s) : A instanceof $s ? (d && (s.data = new Mc(s.data, g)), A.intervals.addInterval(s)) : (e[t] = A = Ore(A), d && (s.data = new Mc(s.data, g)), A.intervals.addInterval(s)); return } l(A) ? A instanceof $s || (e[t] = A = Ore(A)) : e[t] = A = new $s(g); let b = A.intervals; T = b.findInterval(s), (!l(T) || !(T.data instanceof ea) || l(g) && T.data.referenceFrame !== g) && (T = s.clone(), T.data = new ea(g, a), b.addInterval(T)), T.data.addSamplesPackedArray(u, C), qF(n, T.data) } function Gre(e, t) { if (e instanceof ea) { e.removeSamples(t); return } else if (e instanceof Z_) { e.intervals.removeInterval(t); return } else if (e instanceof $s) { let n = e.intervals; for (let i = 0; i < n.length; ++i) { let o = yn.intersect(n.get(i), t, Ey); o.isEmpty || Gre(o.data, t) } n.removeInterval(t); return } } function Wre(e, t, n, i, o, r) { if (!!l(n)) if (Array.isArray(n)) for (let s = 0, a = n.length; s < a; ++s)Bre(e, t, n[s], i, o, r); else Bre(e, t, n, i, o, r) } function Rre(e, t, n, i) { l(n.references) ? XF(e, t, n.references, n.interval, i, Fw, cc) : (l(n.cartesian2) ? n.array = H.unpackArray(n.cartesian2) : l(n.cartesian) && (n.array = H.unpackArray(n.cartesian)), l(n.array) && me(Array, e, t, n, void 0, void 0, i)) } function Mre(e, t, n, i, o, r) { let s = er(n.interval); l(i) && (l(s) ? s = yn.intersect(s, i, Ey) : s = i); let a = e[t], c, u; if (l(s)) { a instanceof Tw || (a = new Tw, e[t] = a); let d = a.intervals; u = d.findInterval({ start: s.start, stop: s.stop }), l(u) ? c = u.data : (u = s.clone(), d.addInterval(u)) } else c = a; let f; l(n.solidColor) ? (c instanceof Ot || (c = new Ot), f = n.solidColor, me(U, c, "color", f.color, void 0, void 0, r)) : l(n.grid) ? (c instanceof Bw || (c = new Bw), f = n.grid, me(U, c, "color", f.color, void 0, o, r), me(Number, c, "cellAlpha", f.cellAlpha, void 0, o, r), me(H, c, "lineCount", f.lineCount, void 0, o, r), me(H, c, "lineThickness", f.lineThickness, void 0, o, r), me(H, c, "lineOffset", f.lineOffset, void 0, o, r)) : l(n.image) ? (c instanceof S0 || (c = new S0), f = n.image, me(Image, c, "image", f.image, void 0, o, r), me(H, c, "repeat", f.repeat, void 0, o, r), me(U, c, "color", f.color, void 0, o, r), me(Boolean, c, "transparent", f.transparent, void 0, o, r)) : l(n.stripe) ? (c instanceof Nw || (c = new Nw), f = n.stripe, me(ch, c, "orientation", f.orientation, void 0, o, r), me(U, c, "evenColor", f.evenColor, void 0, o, r), me(U, c, "oddColor", f.oddColor, void 0, o, r), me(Number, c, "offset", f.offset, void 0, o, r), me(Number, c, "repeat", f.repeat, void 0, o, r)) : l(n.polylineOutline) ? (c instanceof Cy || (c = new Cy), f = n.polylineOutline, me(U, c, "color", f.color, void 0, o, r), me(U, c, "outlineColor", f.outlineColor, void 0, o, r), me(Number, c, "outlineWidth", f.outlineWidth, void 0, o, r)) : l(n.polylineGlow) ? (c instanceof Lw || (c = new Lw), f = n.polylineGlow, me(U, c, "color", f.color, void 0, o, r), me(Number, c, "glowPower", f.glowPower, void 0, o, r), me(Number, c, "taperPower", f.taperPower, void 0, o, r)) : l(n.polylineArrow) ? (c instanceof Rw || (c = new Rw), f = n.polylineArrow, me(U, c, "color", f.color, void 0, void 0, r)) : l(n.polylineDash) ? (c instanceof Mw || (c = new Mw), f = n.polylineDash, me(U, c, "color", f.color, void 0, void 0, r), me(U, c, "gapColor", f.gapColor, void 0, void 0, r), me(Number, c, "dashLength", f.dashLength, void 0, o, r), me(Number, c, "dashPattern", f.dashPattern, void 0, o, r)) : l(n.checkerboard) && (c instanceof yw || (c = new yw), f = n.checkerboard, me(U, c, "evenColor", f.evenColor, void 0, o, r), me(U, c, "oddColor", f.oddColor, void 0, o, r), me(H, c, "repeat", f.repeat, void 0, o, r)), l(u) ? u.data = c : e[t] = c } function Sl(e, t, n, i, o, r) { if (!!l(n)) if (Array.isArray(n)) for (let s = 0, a = n.length; s < a; ++s)Mre(e, t, n[s], i, o, r); else Mre(e, t, n, i, o, r) } function X5e(e, t, n, i) { let o = t.name; l(o) && (e.name = t.name) } function K5e(e, t, n, i) { let o = t.description; l(o) && me(String, e, "description", o, void 0, i, n) } function J5e(e, t, n, i) { let o = t.position; l(o) && Wre(e, "position", o, void 0, i, n) } function Z5e(e, t, n, i) { let o = t.viewFrom; l(o) && me(h, e, "viewFrom", o, void 0, i, n) } function Q5e(e, t, n, i) { let o = t.orientation; l(o) && me(Be, e, "orientation", o, void 0, i, n) } function $5e(e, t, n, i) { let o = t.properties; if (l(o)) { l(e.properties) || (e.properties = new hl); for (let r in o) if (o.hasOwnProperty(r)) { e.properties.hasProperty(r) || e.properties.addProperty(r); let s = o[r]; if (Array.isArray(s)) for (let a = 0, c = s.length; a < c; ++a)YF(vre(s[a]), e.properties, r, s[a], void 0, i, n); else YF(vre(s), e.properties, r, s, void 0, i, n) } } } function XF(e, t, n, i, o, r, s) { let a = n.map(function (c) { return kw(o, c) }); if (l(i)) { i = er(i); let c = e[t]; if (!(c instanceof s)) { let u = new s; u.intervals.addInterval(M6(c)), e[t] = c = u } i.data = new r(a), c.intervals.addInterval(i) } else e[t] = new r(a) } function Lre(e, t, n, i) { let o = n.references; l(o) ? XF(e, t, o, n.interval, i, Fw, cc) : me(Array, e, t, n, void 0, void 0, i) } function Fre(e, t, n, i) { if (!!l(n)) if (Array.isArray(n)) for (let o = 0, r = n.length; o < r; ++o)Lre(e, t, n[o], i); else Lre(e, t, n, i) } function Nre(e, t, n, i) { let o = n.references; l(o) ? XF(e, t, o, n.interval, i, Y_, $s) : (l(n.cartesian) ? n.array = h.unpackArray(n.cartesian) : l(n.cartographicRadians) ? n.array = h.fromRadiansArrayHeights(n.cartographicRadians) : l(n.cartographicDegrees) && (n.array = h.fromDegreesArrayHeights(n.cartographicDegrees)), l(n.array) && me(Array, e, t, n, void 0, void 0, i)) } function Hw(e, t, n, i) { if (!!l(n)) if (Array.isArray(n)) for (let o = 0, r = n.length; o < r; ++o)Nre(e, t, n[o], i); else Nre(e, t, n, i) } function e6e(e) { return h.unpackArray(e) } function t6e(e) { return h.fromRadiansArrayHeights(e) } function n6e(e) { return h.fromDegreesArrayHeights(e) } function Vre(e, t, n, i) { let o = n.references; if (l(o)) { let r = o.map(function (s) { let a = {}; return XF(a, "positions", s, n.interval, i, Y_, $s), a.positions }); e[t] = new Y_(r) } else l(n.cartesian) ? n.array = n.cartesian.map(e6e) : l(n.cartographicRadians) ? n.array = n.cartographicRadians.map(t6e) : l(n.cartographicDegrees) && (n.array = n.cartographicDegrees.map(n6e)), l(n.array) && me(Array, e, t, n, void 0, void 0, i) } function i6e(e, t, n, i) { if (!!l(n)) if (Array.isArray(n)) for (let o = 0, r = n.length; o < r; ++o)Vre(e, t, n[o], i); else Vre(e, t, n, i) } function o6e(e, t, n, i) { if (!!l(n)) if (Array.isArray(n)) for (let o = 0, r = n.length; o < r; o++)Rre(e, t, n[o], i); else Rre(e, t, n, i) } function r6e(e, t, n, i) { let o = t.availability; if (!l(o)) return; let r; if (Array.isArray(o)) for (let s = 0, a = o.length; s < a; ++s)l(r) || (r = new Ir), r.addInterval(er(o[s])); else r = new Ir, r.addInterval(er(o)); e.availability = r } function s6e(e, t, n, i, o) { !l(t) || me($_, e, "alignedAxis", t, n, i, o) } function a6e(e, t, n, i) { let o = t.billboard; if (!l(o)) return; let r = er(o.interval), s = e.billboard; l(s) || (e.billboard = s = new ja), me(Boolean, s, "show", o.show, r, i, n), me(Image, s, "image", o.image, r, i, n), me(Number, s, "scale", o.scale, r, i, n), me(H, s, "pixelOffset", o.pixelOffset, r, i, n), me(h, s, "eyeOffset", o.eyeOffset, r, i, n), me(ai, s, "horizontalOrigin", o.horizontalOrigin, r, i, n), me(Sn, s, "verticalOrigin", o.verticalOrigin, r, i, n), me(ze, s, "heightReference", o.heightReference, r, i, n), me(U, s, "color", o.color, r, i, n), me(Vf, s, "rotation", o.rotation, r, i, n), s6e(s, o.alignedAxis, r, i, n), me(Boolean, s, "sizeInMeters", o.sizeInMeters, r, i, n), me(Number, s, "width", o.width, r, i, n), me(Number, s, "height", o.height, r, i, n), me(wt, s, "scaleByDistance", o.scaleByDistance, r, i, n), me(wt, s, "translucencyByDistance", o.translucencyByDistance, r, i, n), me(wt, s, "pixelOffsetScaleByDistance", o.pixelOffsetScaleByDistance, r, i, n), me(Ge, s, "imageSubRegion", o.imageSubRegion, r, i, n), me(bt, s, "distanceDisplayCondition", o.distanceDisplayCondition, r, i, n), me(Number, s, "disableDepthTestDistance", o.disableDepthTestDistance, r, i, n) } function c6e(e, t, n, i) { let o = t.box; if (!l(o)) return; let r = er(o.interval), s = e.box; l(s) || (e.box = s = new bC), me(Boolean, s, "show", o.show, r, i, n), me(h, s, "dimensions", o.dimensions, r, i, n), me(ze, s, "heightReference", o.heightReference, r, i, n), me(Boolean, s, "fill", o.fill, r, i, n), Sl(s, "material", o.material, r, i, n), me(Boolean, s, "outline", o.outline, r, i, n), me(U, s, "outlineColor", o.outlineColor, r, i, n), me(Number, s, "outlineWidth", o.outlineWidth, r, i, n), me(hn, s, "shadows", o.shadows, r, i, n), me(bt, s, "distanceDisplayCondition", o.distanceDisplayCondition, r, i, n) } function l6e(e, t, n, i) { let o = t.corridor; if (!l(o)) return; let r = er(o.interval), s = e.corridor; l(s) || (e.corridor = s = new wC), me(Boolean, s, "show", o.show, r, i, n), Hw(s, "positions", o.positions, n), me(Number, s, "width", o.width, r, i, n), me(Number, s, "height", o.height, r, i, n), me(ze, s, "heightReference", o.heightReference, r, i, n), me(Number, s, "extrudedHeight", o.extrudedHeight, r, i, n), me(ze, s, "extrudedHeightReference", o.extrudedHeightReference, r, i, n), me(Ti, s, "cornerType", o.cornerType, r, i, n), me(Number, s, "granularity", o.granularity, r, i, n), me(Boolean, s, "fill", o.fill, r, i, n), Sl(s, "material", o.material, r, i, n), me(Boolean, s, "outline", o.outline, r, i, n), me(U, s, "outlineColor", o.outlineColor, r, i, n), me(Number, s, "outlineWidth", o.outlineWidth, r, i, n), me(hn, s, "shadows", o.shadows, r, i, n), me(bt, s, "distanceDisplayCondition", o.distanceDisplayCondition, r, i, n), me(Ln, s, "classificationType", o.classificationType, r, i, n), me(Number, s, "zIndex", o.zIndex, r, i, n) } function u6e(e, t, n, i) { let o = t.cylinder; if (!l(o)) return; let r = er(o.interval), s = e.cylinder; l(s) || (e.cylinder = s = new DC), me(Boolean, s, "show", o.show, r, i, n), me(Number, s, "length", o.length, r, i, n), me(Number, s, "topRadius", o.topRadius, r, i, n), me(Number, s, "bottomRadius", o.bottomRadius, r, i, n), me(ze, s, "heightReference", o.heightReference, r, i, n), me(Boolean, s, "fill", o.fill, r, i, n), Sl(s, "material", o.material, r, i, n), me(Boolean, s, "outline", o.outline, r, i, n), me(U, s, "outlineColor", o.outlineColor, r, i, n), me(Number, s, "outlineWidth", o.outlineWidth, r, i, n), me(Number, s, "numberOfVerticalLines", o.numberOfVerticalLines, r, i, n), me(Number, s, "slices", o.slices, r, i, n), me(hn, s, "shadows", o.shadows, r, i, n), me(bt, s, "distanceDisplayCondition", o.distanceDisplayCondition, r, i, n) } function f6e(e, t) { let n = e.version; if (l(n) && typeof n == "string") { let r = n.split("."); if (r.length === 2) { if (r[0] !== "1") throw new fe("Cesium only supports CZML version 1."); t._version = n } } if (!l(t._version)) throw new fe("CZML version information invalid.  It is expected to be a property on the document object in the <Major>.<Minor> version format."); let i = t._documentPacket; l(e.name) && (i.name = e.name); let o = e.clock; if (l(o)) { let r = i.clock; l(r) ? (r.interval = y(o.interval, r.interval), r.currentTime = y(o.currentTime, r.currentTime), r.range = y(o.range, r.range), r.step = y(o.step, r.step), r.multiplier = y(o.multiplier, r.multiplier)) : i.clock = { interval: o.interval, currentTime: o.currentTime, range: o.range, step: o.step, multiplier: o.multiplier } } } function d6e(e, t, n, i) { let o = t.ellipse; if (!l(o)) return; let r = er(o.interval), s = e.ellipse; l(s) || (e.ellipse = s = new vC), me(Boolean, s, "show", o.show, r, i, n), me(Number, s, "semiMajorAxis", o.semiMajorAxis, r, i, n), me(Number, s, "semiMinorAxis", o.semiMinorAxis, r, i, n), me(Number, s, "height", o.height, r, i, n), me(ze, s, "heightReference", o.heightReference, r, i, n), me(Number, s, "extrudedHeight", o.extrudedHeight, r, i, n), me(ze, s, "extrudedHeightReference", o.extrudedHeightReference, r, i, n), me(Vf, s, "rotation", o.rotation, r, i, n), me(Vf, s, "stRotation", o.stRotation, r, i, n), me(Number, s, "granularity", o.granularity, r, i, n), me(Boolean, s, "fill", o.fill, r, i, n), Sl(s, "material", o.material, r, i, n), me(Boolean, s, "outline", o.outline, r, i, n), me(U, s, "outlineColor", o.outlineColor, r, i, n), me(Number, s, "outlineWidth", o.outlineWidth, r, i, n), me(Number, s, "numberOfVerticalLines", o.numberOfVerticalLines, r, i, n), me(hn, s, "shadows", o.shadows, r, i, n), me(bt, s, "distanceDisplayCondition", o.distanceDisplayCondition, r, i, n), me(Ln, s, "classificationType", o.classificationType, r, i, n), me(Number, s, "zIndex", o.zIndex, r, i, n) } function h6e(e, t, n, i) { let o = t.ellipsoid; if (!l(o)) return; let r = er(o.interval), s = e.ellipsoid; l(s) || (e.ellipsoid = s = new PC), me(Boolean, s, "show", o.show, r, i, n), me(h, s, "radii", o.radii, r, i, n), me(h, s, "innerRadii", o.innerRadii, r, i, n), me(Number, s, "minimumClock", o.minimumClock, r, i, n), me(Number, s, "maximumClock", o.maximumClock, r, i, n), me(Number, s, "minimumCone", o.minimumCone, r, i, n), me(Number, s, "maximumCone", o.maximumCone, r, i, n), me(ze, s, "heightReference", o.heightReference, r, i, n), me(Boolean, s, "fill", o.fill, r, i, n), Sl(s, "material", o.material, r, i, n), me(Boolean, s, "outline", o.outline, r, i, n), me(U, s, "outlineColor", o.outlineColor, r, i, n), me(Number, s, "outlineWidth", o.outlineWidth, r, i, n), me(Number, s, "stackPartitions", o.stackPartitions, r, i, n), me(Number, s, "slicePartitions", o.slicePartitions, r, i, n), me(Number, s, "subdivisions", o.subdivisions, r, i, n), me(hn, s, "shadows", o.shadows, r, i, n), me(bt, s, "distanceDisplayCondition", o.distanceDisplayCondition, r, i, n) } function m6e(e, t, n, i) { let o = t.label; if (!l(o)) return; let r = er(o.interval), s = e.label; l(s) || (e.label = s = new Rd), me(Boolean, s, "show", o.show, r, i, n), me(String, s, "text", o.text, r, i, n), me(String, s, "font", o.font, r, i, n), me(Fo, s, "style", o.style, r, i, n), me(Number, s, "scale", o.scale, r, i, n), me(Boolean, s, "showBackground", o.showBackground, r, i, n), me(U, s, "backgroundColor", o.backgroundColor, r, i, n), me(H, s, "backgroundPadding", o.backgroundPadding, r, i, n), me(H, s, "pixelOffset", o.pixelOffset, r, i, n), me(h, s, "eyeOffset", o.eyeOffset, r, i, n), me(ai, s, "horizontalOrigin", o.horizontalOrigin, r, i, n), me(Sn, s, "verticalOrigin", o.verticalOrigin, r, i, n), me(ze, s, "heightReference", o.heightReference, r, i, n), me(U, s, "fillColor", o.fillColor, r, i, n), me(U, s, "outlineColor", o.outlineColor, r, i, n), me(Number, s, "outlineWidth", o.outlineWidth, r, i, n), me(wt, s, "translucencyByDistance", o.translucencyByDistance, r, i, n), me(wt, s, "pixelOffsetScaleByDistance", o.pixelOffsetScaleByDistance, r, i, n), me(wt, s, "scaleByDistance", o.scaleByDistance, r, i, n), me(bt, s, "distanceDisplayCondition", o.distanceDisplayCondition, r, i, n), me(Number, s, "disableDepthTestDistance", o.disableDepthTestDistance, r, i, n) } function p6e(e, t, n, i) { let o = t.model; if (!l(o)) return; let r = er(o.interval), s = e.model; l(s) || (e.model = s = new zp), me(Boolean, s, "show", o.show, r, i, n), me(zw.default, s, "uri", o.gltf, r, i, n), me(Number, s, "scale", o.scale, r, i, n), me(Number, s, "minimumPixelSize", o.minimumPixelSize, r, i, n), me(Number, s, "maximumScale", o.maximumScale, r, i, n), me(Boolean, s, "incrementallyLoadTextures", o.incrementallyLoadTextures, r, i, n), me(Boolean, s, "runAnimations", o.runAnimations, r, i, n), me(Boolean, s, "clampAnimations", o.clampAnimations, r, i, n), me(hn, s, "shadows", o.shadows, r, i, n), me(ze, s, "heightReference", o.heightReference, r, i, n), me(U, s, "silhouetteColor", o.silhouetteColor, r, i, n), me(Number, s, "silhouetteSize", o.silhouetteSize, r, i, n), me(U, s, "color", o.color, r, i, n), me(oc, s, "colorBlendMode", o.colorBlendMode, r, i, n), me(Number, s, "colorBlendAmount", o.colorBlendAmount, r, i, n), me(bt, s, "distanceDisplayCondition", o.distanceDisplayCondition, r, i, n); let a, c, u = o.nodeTransformations; if (l(u)) if (Array.isArray(u)) for (a = 0, c = u.length; a < c; ++a)kre(s, u[a], r, i, n); else kre(s, u, r, i, n); let f = o.articulations; if (l(f)) if (Array.isArray(f)) for (a = 0, c = f.length; a < c; ++a)Ure(s, f[a], r, i, n); else Ure(s, f, r, i, n) } function kre(e, t, n, i, o) { let r = er(t.interval); l(n) && (l(r) ? r = yn.intersect(r, n, Ey) : r = n); let s = e.nodeTransformations, a = Object.keys(t); for (let c = 0, u = a.length; c < u; ++c) { let f = a[c]; if (f === "interval") continue; let d = t[f]; if (!l(d)) continue; l(s) || (e.nodeTransformations = s = new hl), s.hasProperty(f) || s.addProperty(f); let p = s[f]; l(p) || (s[f] = p = new IC), me(h, p, "translation", d.translation, r, i, o), me(Be, p, "rotation", d.rotation, r, i, o), me(h, p, "scale", d.scale, r, i, o) } } function Ure(e, t, n, i, o) { let r = er(t.interval); l(n) && (l(r) ? r = yn.intersect(r, n, Ey) : r = n); let s = e.articulations, a = Object.keys(t); for (let c = 0, u = a.length; c < u; ++c) { let f = a[c]; if (f === "interval") continue; let d = t[f]; !l(d) || (l(s) || (e.articulations = s = new hl), s.hasProperty(f) || s.addProperty(f), me(Number, s, f, d, r, i, o)) } } function _6e(e, t, n, i) { let o = t.path; if (!l(o)) return; let r = er(o.interval), s = e.path; l(s) || (e.path = s = new Hp), me(Boolean, s, "show", o.show, r, i, n), me(Number, s, "leadTime", o.leadTime, r, i, n), me(Number, s, "trailTime", o.trailTime, r, i, n), me(Number, s, "width", o.width, r, i, n), me(Number, s, "resolution", o.resolution, r, i, n), Sl(s, "material", o.material, r, i, n), me(bt, s, "distanceDisplayCondition", o.distanceDisplayCondition, r, i, n) } function g6e(e, t, n, i) { let o = t.point; if (!l(o)) return; let r = er(o.interval), s = e.point; l(s) || (e.point = s = new BC), me(Boolean, s, "show", o.show, r, i, n), me(Number, s, "pixelSize", o.pixelSize, r, i, n), me(ze, s, "heightReference", o.heightReference, r, i, n), me(U, s, "color", o.color, r, i, n), me(U, s, "outlineColor", o.outlineColor, r, i, n), me(Number, s, "outlineWidth", o.outlineWidth, r, i, n), me(wt, s, "scaleByDistance", o.scaleByDistance, r, i, n), me(wt, s, "translucencyByDistance", o.translucencyByDistance, r, i, n), me(bt, s, "distanceDisplayCondition", o.distanceDisplayCondition, r, i, n), me(Number, s, "disableDepthTestDistance", o.disableDepthTestDistance, r, i, n) } function Uw(e) { this.polygon = e, this._definitionChanged = new _e } Object.defineProperties(Uw.prototype, { isConstant: { get: function () { let e = this.polygon._positions, t = this.polygon._holes; return (!l(e) || e.isConstant) && (!l(t) || t.isConstant) } }, definitionChanged: { get: function () { return this._definitionChanged } } }); Uw.prototype.getValue = function (e, t) { let n; l(this.polygon._positions) && (n = this.polygon._positions.getValue(e)); let i; return l(this.polygon._holes) && (i = this.polygon._holes.getValue(e), l(i) && (i = i.map(function (o) { return new Lc(o) }))), l(t) ? (t.positions = n, t.holes = i, t) : new Lc(n, i) }; Uw.prototype.equals = function (e) { return this === e || e instanceof Uw && j.equals(this.polygon._positions, e.polygon._positions) && j.equals(this.polygon._holes, e.polygon._holes) }; function y6e(e, t, n, i) { let o = t.polygon; if (!l(o)) return; let r = er(o.interval), s = e.polygon; l(s) || (e.polygon = s = new Md), me(Boolean, s, "show", o.show, r, i, n), Hw(s, "_positions", o.positions, n), i6e(s, "_holes", o.holes, n), (l(s._positions) || l(s._holes)) && (s.hierarchy = new Uw(s)), me(Number, s, "height", o.height, r, i, n), me(ze, s, "heightReference", o.heightReference, r, i, n), me(Number, s, "extrudedHeight", o.extrudedHeight, r, i, n), me(ze, s, "extrudedHeightReference", o.extrudedHeightReference, r, i, n), me(Vf, s, "stRotation", o.stRotation, r, i, n), me(Number, s, "granularity", o.granularity, r, i, n), me(Boolean, s, "fill", o.fill, r, i, n), Sl(s, "material", o.material, r, i, n), me(Boolean, s, "outline", o.outline, r, i, n), me(U, s, "outlineColor", o.outlineColor, r, i, n), me(Number, s, "outlineWidth", o.outlineWidth, r, i, n), me(Boolean, s, "perPositionHeight", o.perPositionHeight, r, i, n), me(Boolean, s, "closeTop", o.closeTop, r, i, n), me(Boolean, s, "closeBottom", o.closeBottom, r, i, n), me(Yt, s, "arcType", o.arcType, r, i, n), me(hn, s, "shadows", o.shadows, r, i, n), me(bt, s, "distanceDisplayCondition", o.distanceDisplayCondition, r, i, n), me(Ln, s, "classificationType", o.classificationType, r, i, n), me(Number, s, "zIndex", o.zIndex, r, i, n) } function A6e(e) { return e ? Yt.GEODESIC : Yt.NONE } function C6e(e, t, n, i) { let o = t.polyline; if (!l(o)) return; let r = er(o.interval), s = e.polyline; if (l(s) || (e.polyline = s = new ec), me(Boolean, s, "show", o.show, r, i, n), Hw(s, "positions", o.positions, n), me(Number, s, "width", o.width, r, i, n), me(Number, s, "granularity", o.granularity, r, i, n), Sl(s, "material", o.material, r, i, n), Sl(s, "depthFailMaterial", o.depthFailMaterial, r, i, n), me(Yt, s, "arcType", o.arcType, r, i, n), me(Boolean, s, "clampToGround", o.clampToGround, r, i, n), me(hn, s, "shadows", o.shadows, r, i, n), me(bt, s, "distanceDisplayCondition", o.distanceDisplayCondition, r, i, n), me(Ln, s, "classificationType", o.classificationType, r, i, n), me(Number, s, "zIndex", o.zIndex, r, i, n), l(o.followSurface) && !l(o.arcType)) { let a = {}; me(Boolean, a, "followSurface", o.followSurface, r, i, n), s.arcType = N5e(a.followSurface, A6e) } } function x6e(e, t, n, i) { let o = t.polylineVolume; if (!l(o)) return; let r = er(o.interval), s = e.polylineVolume; l(s) || (e.polylineVolume = s = new RC), Hw(s, "positions", o.positions, n), o6e(s, "shape", o.shape, n), me(Boolean, s, "show", o.show, r, i, n), me(Ti, s, "cornerType", o.cornerType, r, i, n), me(Boolean, s, "fill", o.fill, r, i, n), Sl(s, "material", o.material, r, i, n), me(Boolean, s, "outline", o.outline, r, i, n), me(U, s, "outlineColor", o.outlineColor, r, i, n), me(Number, s, "outlineWidth", o.outlineWidth, r, i, n), me(Number, s, "granularity", o.granularity, r, i, n), me(hn, s, "shadows", o.shadows, r, i, n), me(bt, s, "distanceDisplayCondition", o.distanceDisplayCondition, r, i, n) } function T6e(e, t, n, i) { let o = t.rectangle; if (!l(o)) return; let r = er(o.interval), s = e.rectangle; l(s) || (e.rectangle = s = new Ld), me(Boolean, s, "show", o.show, r, i, n), me(ce, s, "coordinates", o.coordinates, r, i, n), me(Number, s, "height", o.height, r, i, n), me(ze, s, "heightReference", o.heightReference, r, i, n), me(Number, s, "extrudedHeight", o.extrudedHeight, r, i, n), me(ze, s, "extrudedHeightReference", o.extrudedHeightReference, r, i, n), me(Vf, s, "rotation", o.rotation, r, i, n), me(Vf, s, "stRotation", o.stRotation, r, i, n), me(Number, s, "granularity", o.granularity, r, i, n), me(Boolean, s, "fill", o.fill, r, i, n), Sl(s, "material", o.material, r, i, n), me(Boolean, s, "outline", o.outline, r, i, n), me(U, s, "outlineColor", o.outlineColor, r, i, n), me(Number, s, "outlineWidth", o.outlineWidth, r, i, n), me(hn, s, "shadows", o.shadows, r, i, n), me(bt, s, "distanceDisplayCondition", o.distanceDisplayCondition, r, i, n), me(Ln, s, "classificationType", o.classificationType, r, i, n), me(Number, s, "zIndex", o.zIndex, r, i, n) } function E6e(e, t, n, i) { let o = t.tileset; if (!l(o)) return; let r = er(o.interval), s = e.tileset; l(s) || (e.tileset = s = new OC), me(Boolean, s, "show", o.show, r, i, n), me(zw.default, s, "uri", o.uri, r, i, n), me(Number, s, "maximumScreenSpaceError", o.maximumScreenSpaceError, r, i, n) } function b6e(e, t, n, i) { let o = t.wall; if (!l(o)) return; let r = er(o.interval), s = e.wall; l(s) || (e.wall = s = new Gp), me(Boolean, s, "show", o.show, r, i, n), Hw(s, "positions", o.positions, n), Fre(s, "minimumHeights", o.minimumHeights, n), Fre(s, "maximumHeights", o.maximumHeights, n), me(Number, s, "granularity", o.granularity, r, i, n), me(Boolean, s, "fill", o.fill, r, i, n), Sl(s, "material", o.material, r, i, n), me(Boolean, s, "outline", o.outline, r, i, n), me(U, s, "outlineColor", o.outlineColor, r, i, n), me(Number, s, "outlineWidth", o.outlineWidth, r, i, n), me(hn, s, "shadows", o.shadows, r, i, n), me(bt, s, "distanceDisplayCondition", o.distanceDisplayCondition, r, i, n) } function zre(e, t, n, i, o) { let r = e.id; if (l(r) || (r = Nn()), B6 = r, !l(o._version) && r !== "document") throw new fe("The first CZML packet is required to be the document object."); if (e.delete === !0) t.removeById(r); else if (r === "document") f6e(e, o); else { let s = t.getOrCreateEntity(r), a = e.parent; l(a) && (s.parent = t.getOrCreateEntity(a)); for (let c = n.length - 1; c > -1; c--)n[c](s, e, t, i) } B6 = void 0 } function S6e(e) { let t, n = e._documentPacket.clock; if (!l(n)) { if (!l(e._clock)) { let o = e._entityCollection.computeAvailability(); if (!o.start.equals(ke.MINIMUM_VALUE)) { let r = o.start, s = o.stop, a = $.secondsDifference(s, r), c = Math.round(a / 120); return t = new ah, t.startTime = $.clone(r), t.stopTime = $.clone(s), t.clockRange = Br.LOOP_STOP, t.multiplier = c, t.currentTime = $.clone(r), t.clockStep = uo.SYSTEM_CLOCK_MULTIPLIER, e._clock = t, !0 } } return !1 } l(e._clock) ? t = e._clock.clone() : (t = new ah, t.startTime = ke.MINIMUM_VALUE.clone(), t.stopTime = ke.MAXIMUM_VALUE.clone(), t.currentTime = ke.MINIMUM_VALUE.clone(), t.clockRange = Br.LOOP_STOP, t.clockStep = uo.SYSTEM_CLOCK_MULTIPLIER, t.multiplier = 1); let i = er(n.interval); return l(i) && (t.startTime = i.start, t.stopTime = i.stop), l(n.currentTime) && (t.currentTime = $.fromIso8601(n.currentTime)), l(n.range) && (t.clockRange = y(Br[n.range], Br.LOOP_STOP)), l(n.step) && (t.clockStep = y(uo[n.step], uo.SYSTEM_CLOCK_MULTIPLIER)), l(n.multiplier) && (t.multiplier = n.multiplier), t.equals(e._clock) ? !1 : (e._clock = t.clone(e._clock), !0) } function jre(e, t, n, i) { n = y(n, y.EMPTY_OBJECT); let o = t, r = n.sourceUri, s = n.credit; if (typeof s == "string" && (s = new Xt(s)), e._credit = s, typeof t == "string" || t instanceof Pe) { t = Pe.createIfNeeded(t), o = t.fetchJson(), r = y(r, t.clone()); let a = e._resourceCredits, c = t.credits; if (l(c)) { let u = c.length; for (let f = 0; f < u; f++)a.push(c[f]) } } return r = Pe.createIfNeeded(r), Or.setLoading(e, !0), Promise.resolve(o).then(function (a) { return w6e(e, a, r, i) }).catch(function (a) { return Or.setLoading(e, !1), e._error.raiseEvent(e, a), console.log(a), Promise.reject(a) }) } function w6e(e, t, n, i) { Or.setLoading(e, !0); let o = e._entityCollection; i && (e._version = void 0, e._documentPacket = new qre, o.removeAll()), qc._processCzml(t, o, n, void 0, e); let r = S6e(e), s = e._documentPacket; return l(s.name) && e._name !== s.name ? (e._name = s.name, r = !0) : !l(e._name) && l(n) && (e._name = q_(n.getUrlComponent()), r = !0), Or.setLoading(e, !1), r && e._changed.raiseEvent(e), e } function qre() { this.name = void 0, this.clock = void 0 } function qc(e) { this._name = e, this._changed = new _e, this._error = new _e, this._isLoading = !1, this._loading = new _e, this._clock = void 0, this._documentPacket = new qre, this._version = void 0, this._entityCollection = new vs(this), this._entityCluster = new Iu, this._credit = void 0, this._resourceCredits = [] } qc.load = function (e, t) { return new qc().load(e, t) }; Object.defineProperties(qc.prototype, { name: { get: function () { return this._name } }, clock: { get: function () { return this._clock } }, entities: { get: function () { return this._entityCollection } }, isLoading: { get: function () { return this._isLoading } }, changedEvent: { get: function () { return this._changed } }, errorEvent: { get: function () { return this._error } }, loadingEvent: { get: function () { return this._loading } }, show: { get: function () { return this._entityCollection.show }, set: function (e) { this._entityCollection.show = e } }, clustering: { get: function () { return this._entityCluster }, set: function (e) { this._entityCluster = e } }, credit: { get: function () { return this._credit } } }); qc.updaters = [a6e, c6e, l6e, u6e, d6e, h6e, m6e, p6e, X5e, K5e, _6e, g6e, y6e, C6e, x6e, $5e, T6e, J5e, E6e, Z5e, b6e, Q5e, r6e]; qc.prototype.process = function (e, t) { return jre(this, e, t, !1) }; qc.prototype.load = function (e, t) { return jre(this, e, t, !0) }; qc.prototype.update = function (e) { return !0 }; qc.processPacketData = me; qc.processPositionPacketData = Wre; qc.processMaterialPacketData = Sl; qc._processCzml = function (e, t, n, i, o) { if (i = y(i, qc.updaters), Array.isArray(e)) for (let r = 0, s = e.length; r < s; ++r)zre(e[r], t, i, n, o); else zre(e, t, i, n, o) }; var KF = qc; function dc() { this._dataSources = [], this._dataSourceAdded = new _e, this._dataSourceRemoved = new _e, this._dataSourceMoved = new _e } Object.defineProperties(dc.prototype, { length: { get: function () { return this._dataSources.length } }, dataSourceAdded: { get: function () { return this._dataSourceAdded } }, dataSourceRemoved: { get: function () { return this._dataSourceRemoved } }, dataSourceMoved: { get: function () { return this._dataSourceMoved } } }); dc.prototype.add = function (e) { let t = this, n = this._dataSources; return Promise.resolve(e).then(function (i) { return n === t._dataSources && (t._dataSources.push(i), t._dataSourceAdded.raiseEvent(t, i)), i }) }; dc.prototype.remove = function (e, t) { t = y(t, !1); let n = this._dataSources.indexOf(e); return n !== -1 ? (this._dataSources.splice(n, 1), this._dataSourceRemoved.raiseEvent(this, e), t && typeof e.destroy == "function" && e.destroy(), !0) : !1 }; dc.prototype.removeAll = function (e) { e = y(e, !1); let t = this._dataSources; for (let n = 0, i = t.length; n < i; ++n) { let o = t[n]; this._dataSourceRemoved.raiseEvent(this, o), e && typeof o.destroy == "function" && o.destroy() } this._dataSources = [] }; dc.prototype.contains = function (e) { return this.indexOf(e) !== -1 }; dc.prototype.indexOf = function (e) { return this._dataSources.indexOf(e) }; dc.prototype.get = function (e) { return this._dataSources[e] }; dc.prototype.getByName = function (e) { return this._dataSources.filter(function (t) { return t.name === e }) }; function JF(e, t) { return e.indexOf(t) } function Yre(e, t, n) { let i = e._dataSources, o = i.length - 1; if (t = I.clamp(t, 0, o), n = I.clamp(n, 0, o), t === n) return; let r = i[t]; i[t] = i[n], i[n] = r, e.dataSourceMoved.raiseEvent(r, n, t) } dc.prototype.raise = function (e) { let t = JF(this._dataSources, e); Yre(this, t, t + 1) }; dc.prototype.lower = function (e) { let t = JF(this._dataSources, e); Yre(this, t, t - 1) }; dc.prototype.raiseToTop = function (e) { let t = JF(this._dataSources, e); t !== this._dataSources.length - 1 && (this._dataSources.splice(t, 1), this._dataSources.push(e), this.dataSourceMoved.raiseEvent(e, this._dataSources.length - 1, t)) }; dc.prototype.lowerToBottom = function (e) { let t = JF(this._dataSources, e); t !== 0 && (this._dataSources.splice(t, 1), this._dataSources.splice(0, 0, e), this.dataSourceMoved.raiseEvent(e, 0, t)) }; dc.prototype.isDestroyed = function () { return !1 }; dc.prototype.destroy = function () { return this.removeAll(!0), le(this) }; var ZF = dc; function Os(e) { e = y(e, y.EMPTY_OBJECT), this._primitives = [], this._guid = Nn(), this._zIndex = void 0, this.show = y(e.show, !0), this.destroyPrimitives = y(e.destroyPrimitives, !0) } Object.defineProperties(Os.prototype, { length: { get: function () { return this._primitives.length } } }); Os.prototype.add = function (e, t) { let n = l(t), i = e._external = e._external || {}, o = i._composites = i._composites || {}; return o[this._guid] = { collection: this }, n ? this._primitives.splice(t, 0, e) : this._primitives.push(e), e }; Os.prototype.remove = function (e) { if (this.contains(e)) { let t = this._primitives.indexOf(e); if (t !== -1) return this._primitives.splice(t, 1), delete e._external._composites[this._guid], this.destroyPrimitives && e.destroy(), !0 } return !1 }; Os.prototype.removeAndDestroy = function (e) { let t = this.remove(e); return t && !this.destroyPrimitives && e.destroy(), t }; Os.prototype.removeAll = function () { let e = this._primitives, t = e.length; for (let n = 0; n < t; ++n)delete e[n]._external._composites[this._guid], this.destroyPrimitives && e[n].destroy(); this._primitives = [] }; Os.prototype.contains = function (e) { return !!(l(e) && e._external && e._external._composites && e._external._composites[this._guid]) }; function QF(e, t) { return e._primitives.indexOf(t) } Os.prototype.raise = function (e) { if (l(e)) { let t = QF(this, e), n = this._primitives; if (t !== n.length - 1) { let i = n[t]; n[t] = n[t + 1], n[t + 1] = i } } }; Os.prototype.raiseToTop = function (e) { if (l(e)) { let t = QF(this, e), n = this._primitives; t !== n.length - 1 && (n.splice(t, 1), n.push(e)) } }; Os.prototype.lower = function (e) { if (l(e)) { let t = QF(this, e), n = this._primitives; if (t !== 0) { let i = n[t]; n[t] = n[t - 1], n[t - 1] = i } } }; Os.prototype.lowerToBottom = function (e) { if (l(e)) { let t = QF(this, e), n = this._primitives; t !== 0 && (n.splice(t, 1), n.unshift(e)) } }; Os.prototype.get = function (e) { return this._primitives[e] }; Os.prototype.update = function (e) { if (!this.show) return; let t = this._primitives; for (let n = 0; n < t.length; ++n)t[n].update(e) }; Os.prototype.prePassesUpdate = function (e) { let t = this._primitives; for (let n = 0; n < t.length; ++n) { let i = t[n]; l(i.prePassesUpdate) && i.prePassesUpdate(e) } }; Os.prototype.updateForPass = function (e, t) { let n = this._primitives; for (let i = 0; i < n.length; ++i) { let o = n[i]; l(o.updateForPass) && o.updateForPass(e, t) } }; Os.prototype.postPassesUpdate = function (e) { let t = this._primitives; for (let n = 0; n < t.length; ++n) { let i = t[n]; l(i.postPassesUpdate) && i.postPassesUpdate(e) } }; Os.prototype.isDestroyed = function () { return !1 }; Os.prototype.destroy = function () { return this.removeAll(), le(this) }; var wl = Os; function lh() { this._length = 0, this._collections = {}, this._collectionsArray = [], this.show = !0 } Object.defineProperties(lh.prototype, { length: { get: function () { return this._length } } }); lh.prototype.add = function (e, t) { t = y(t, 0); let n = this._collections[t]; if (!l(n)) { n = new wl({ destroyPrimitives: !1 }), n._zIndex = t, this._collections[t] = n; let i = this._collectionsArray, o = 0; for (; o < i.length && i[o]._zIndex < t;)o++; i.splice(o, 0, n) } return n.add(e), this._length++, e._zIndex = t, e }; lh.prototype.set = function (e, t) { return t === e._zIndex || (this.remove(e, !0), this.add(e, t)), e }; lh.prototype.remove = function (e, t) { if (this.contains(e)) { let n = e._zIndex, i = this._collections[n], o; return t ? o = i.remove(e) : o = i.removeAndDestroy(e), o && this._length--, i.length === 0 && (this._collectionsArray.splice(this._collectionsArray.indexOf(i), 1), this._collections[n] = void 0, i.destroy()), o } return !1 }; lh.prototype.removeAll = function () { let e = this._collectionsArray; for (let t = 0; t < e.length; t++) { let n = e[t]; n.destroyPrimitives = !0, n.destroy() } this._collections = {}, this._collectionsArray = [], this._length = 0 }; lh.prototype.contains = function (e) { if (!l(e)) return !1; let t = this._collections[e._zIndex]; return l(t) && t.contains(e) }; lh.prototype.update = function (e) { if (!this.show) return; let t = this._collectionsArray; for (let n = 0; n < t.length; n++)t[n].update(e) }; lh.prototype.isDestroyed = function () { return !1 }; lh.prototype.destroy = function () { return this.removeAll(), le(this) }; var $F = lh; function sT(e, t) { this._primitives = e, this._orderedGroundPrimitives = t, this._dynamicUpdaters = new Ct } sT.prototype.add = function (e, t) { this._dynamicUpdaters.set(t.id, t.createDynamicUpdater(this._primitives, this._orderedGroundPrimitives)) }; sT.prototype.remove = function (e) { let t = e.id, n = this._dynamicUpdaters.get(t); l(n) && (this._dynamicUpdaters.remove(t), n.destroy()) }; sT.prototype.update = function (e) { let t = this._dynamicUpdaters.values; for (let n = 0, i = t.length; n < i; n++)t[n].update(e); return !0 }; sT.prototype.removeAllPrimitives = function () { let e = this._dynamicUpdaters.values; for (let t = 0, n = e.length; t < n; t++)e[t].destroy(); this._dynamicUpdaters.removeAll() }; sT.prototype.getBoundingSphere = function (e, t) { return e = this._dynamicUpdaters.get(e.id), l(e) && l(e.getBoundingSphere) ? e.getBoundingSphere(t) : rt.FAILED }; var aT = sT; var F6 = {}, eN = new h, Xre = new h, Kre = new Be, Jre = new Q; function cT(e, t, n, i, o, r, s, a, c, u) { let f = e + t; h.multiplyByScalar(i, Math.cos(f), eN), h.multiplyByScalar(n, Math.sin(f), Xre), h.add(eN, Xre, eN); let d = Math.cos(e); d = d * d; let p = Math.sin(e); p = p * p; let m = r / Math.sqrt(s * d + o * p) / a; return Be.fromAxisAngle(eN, m, Kre), Q.fromQuaternion(Kre, Jre), Q.multiplyByVector(Jre, c, u), h.normalize(u, u), h.multiplyByScalar(u, a, u), u } var Zre = new h, Qre = new h, L6 = new h, D6e = new h; F6.raisePositionsToHeight = function (e, t, n) { let i = t.ellipsoid, o = t.height, r = t.extrudedHeight, s = n ? e.length / 3 * 2 : e.length / 3, a = new Float64Array(s * 3), c = e.length, u = n ? c : 0; for (let f = 0; f < c; f += 3) { let d = f + 1, p = f + 2, g = h.fromArray(e, f, Zre); i.scaleToGeodeticSurface(g, g); let m = h.clone(g, Qre), A = i.geodeticSurfaceNormal(g, D6e), C = h.multiplyByScalar(A, o, L6); h.add(g, C, g), n && (h.multiplyByScalar(A, r, C), h.add(m, C, m), a[f + u] = m.x, a[d + u] = m.y, a[p + u] = m.z), a[f] = g.x, a[d] = g.y, a[p] = g.z } return a }; var v6e = new h, P6e = new h, I6e = new h; F6.computeEllipsePositions = function (e, t, n) { let i = e.semiMinorAxis, o = e.semiMajorAxis, r = e.rotation, s = e.center, a = e.granularity * 8, c = i * i, u = o * o, f = o * i, d = h.magnitude(s), p = h.normalize(s, v6e), g = h.cross(h.UNIT_Z, s, P6e); g = h.normalize(g, g); let m = h.cross(p, g, I6e), A = 1 + Math.ceil(I.PI_OVER_TWO / a), C = I.PI_OVER_TWO / (A - 1), x = I.PI_OVER_TWO - A * C; x < 0 && (A -= Math.ceil(Math.abs(x) / C)); let T = 2 * (A * (A + 2)), b = t ? new Array(T * 3) : void 0, S = 0, D = Zre, P = Qre, B = A * 4 * 3, R = B - 1, M = 0, L = n ? new Array(B) : void 0, _, E, w, v, O; for (x = I.PI_OVER_TWO, D = cT(x, r, m, g, c, f, u, d, p, D), t && (b[S++] = D.x, b[S++] = D.y, b[S++] = D.z), n && (L[R--] = D.z, L[R--] = D.y, L[R--] = D.x), x = I.PI_OVER_TWO - C, _ = 1; _ < A + 1; ++_) { if (D = cT(x, r, m, g, c, f, u, d, p, D), P = cT(Math.PI - x, r, m, g, c, f, u, d, p, P), t) { for (b[S++] = D.x, b[S++] = D.y, b[S++] = D.z, w = 2 * _ + 2, E = 1; E < w - 1; ++E)v = E / (w - 1), O = h.lerp(D, P, v, L6), b[S++] = O.x, b[S++] = O.y, b[S++] = O.z; b[S++] = P.x, b[S++] = P.y, b[S++] = P.z } n && (L[R--] = D.z, L[R--] = D.y, L[R--] = D.x, L[M++] = P.x, L[M++] = P.y, L[M++] = P.z), x = I.PI_OVER_TWO - (_ + 1) * C } for (_ = A; _ > 1; --_) { if (x = I.PI_OVER_TWO - (_ - 1) * C, D = cT(-x, r, m, g, c, f, u, d, p, D), P = cT(x + Math.PI, r, m, g, c, f, u, d, p, P), t) { for (b[S++] = D.x, b[S++] = D.y, b[S++] = D.z, w = 2 * (_ - 1) + 2, E = 1; E < w - 1; ++E)v = E / (w - 1), O = h.lerp(D, P, v, L6), b[S++] = O.x, b[S++] = O.y, b[S++] = O.z; b[S++] = P.x, b[S++] = P.y, b[S++] = P.z } n && (L[R--] = D.z, L[R--] = D.y, L[R--] = D.x, L[M++] = P.x, L[M++] = P.y, L[M++] = P.z) } x = I.PI_OVER_TWO, D = cT(-x, r, m, g, c, f, u, d, p, D); let V = {}; return t && (b[S++] = D.x, b[S++] = D.y, b[S++] = D.z, V.positions = b, V.numPts = A), n && (L[R--] = D.z, L[R--] = D.y, L[R--] = D.x, V.outerPositions = L), V }; var Dl = F6; var lT = new h, N6 = new h, V6 = new h, $re = new h, $r = new H, ese = new Q, O6e = new Q, k6 = new Be, tse = new h, nse = new h, ise = new h, iN = new he, ose = new h, rse = new H, sse = new H; function ase(e, t, n) { let i = t.vertexFormat, o = t.center, r = t.semiMajorAxis, s = t.semiMinorAxis, a = t.ellipsoid, c = t.stRotation, u = n ? e.length / 3 * 2 : e.length / 3, f = t.shadowVolume, d = i.st ? new Float32Array(u * 2) : void 0, p = i.normal ? new Float32Array(u * 3) : void 0, g = i.tangent ? new Float32Array(u * 3) : void 0, m = i.bitangent ? new Float32Array(u * 3) : void 0, A = f ? new Float32Array(u * 3) : void 0, C = 0, x = tse, T = nse, b = ise, S = new _i(a), D = S.project(a.cartesianToCartographic(o, iN), ose), P = a.scaleToGeodeticSurface(o, lT); a.geodeticSurfaceNormal(P, P); let B = ese, R = O6e; if (c !== 0) { let O = Be.fromAxisAngle(P, c, k6); B = Q.fromQuaternion(O, B), O = Be.fromAxisAngle(P, -c, k6), R = Q.fromQuaternion(O, R) } else B = Q.clone(Q.IDENTITY, B), R = Q.clone(Q.IDENTITY, R); let M = H.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, rse), L = H.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, sse), _ = e.length, E = n ? _ : 0, w = E / 3 * 2; for (let O = 0; O < _; O += 3) { let V = O + 1, z = O + 2, k = h.fromArray(e, O, lT); if (i.st) { let G = Q.multiplyByVector(B, k, N6), N = S.project(a.cartesianToCartographic(G, iN), V6); h.subtract(N, D, N), $r.x = (N.x + r) / (2 * r), $r.y = (N.y + s) / (2 * s), M.x = Math.min($r.x, M.x), M.y = Math.min($r.y, M.y), L.x = Math.max($r.x, L.x), L.y = Math.max($r.y, L.y), n && (d[C + w] = $r.x, d[C + 1 + w] = $r.y), d[C++] = $r.x, d[C++] = $r.y } (i.normal || i.tangent || i.bitangent || f) && (x = a.geodeticSurfaceNormal(k, x), f && (A[O + E] = -x.x, A[V + E] = -x.y, A[z + E] = -x.z), (i.normal || i.tangent || i.bitangent) && ((i.tangent || i.bitangent) && (T = h.normalize(h.cross(h.UNIT_Z, x, T), T), Q.multiplyByVector(R, T, T)), i.normal && (p[O] = x.x, p[V] = x.y, p[z] = x.z, n && (p[O + E] = -x.x, p[V + E] = -x.y, p[z + E] = -x.z)), i.tangent && (g[O] = T.x, g[V] = T.y, g[z] = T.z, n && (g[O + E] = -T.x, g[V + E] = -T.y, g[z + E] = -T.z)), i.bitangent && (b = h.normalize(h.cross(x, T, b), b), m[O] = b.x, m[V] = b.y, m[z] = b.z, n && (m[O + E] = b.x, m[V + E] = b.y, m[z + E] = b.z)))) } if (i.st) { _ = d.length; for (let O = 0; O < _; O += 2)d[O] = (d[O] - M.x) / (L.x - M.x), d[O + 1] = (d[O + 1] - M.y) / (L.y - M.y) } let v = new sn; if (i.position) { let O = Dl.raisePositionsToHeight(e, t, n); v.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: O }) } if (i.st && (v.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: d })), i.normal && (v.normal = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: p })), i.tangent && (v.tangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: g })), i.bitangent && (v.bitangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: m })), f && (v.extrudeDirection = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: A })), n && l(t.offsetAttribute)) { let O = new Uint8Array(u); if (t.offsetAttribute === Qt.TOP) O = O.fill(1, 0, u / 2); else { let V = t.offsetAttribute === Qt.NONE ? 0 : 1; O = O.fill(V) } v.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: O }) } return v } function cse(e) { let t = new Array(12 * (e * (e + 1)) - 6), n = 0, i, o, r, s, a; for (i = 0, r = 1, s = 0; s < 3; s++)t[n++] = r++, t[n++] = i, t[n++] = r; for (s = 2; s < e + 1; ++s) { for (r = s * (s + 1) - 1, i = (s - 1) * s - 1, t[n++] = r++, t[n++] = i, t[n++] = r, o = 2 * s, a = 0; a < o - 1; ++a)t[n++] = r, t[n++] = i++, t[n++] = i, t[n++] = r++, t[n++] = i, t[n++] = r; t[n++] = r++, t[n++] = i, t[n++] = r } for (o = e * 2, ++r, ++i, s = 0; s < o - 1; ++s)t[n++] = r, t[n++] = i++, t[n++] = i, t[n++] = r++, t[n++] = i, t[n++] = r; for (t[n++] = r, t[n++] = i++, t[n++] = i, t[n++] = r++, t[n++] = i++, t[n++] = i, ++i, s = e - 1; s > 1; --s) { for (t[n++] = i++, t[n++] = i, t[n++] = r, o = 2 * s, a = 0; a < o - 1; ++a)t[n++] = r, t[n++] = i++, t[n++] = i, t[n++] = r++, t[n++] = i, t[n++] = r; t[n++] = i++, t[n++] = i++, t[n++] = r++ } for (s = 0; s < 3; s++)t[n++] = i++, t[n++] = i, t[n++] = r; return t } var by = new h; function B6e(e) { let t = e.center; by = h.multiplyByScalar(e.ellipsoid.geodeticSurfaceNormal(t, by), e.height, by), by = h.add(t, by, by); let n = new re(by, e.semiMajorAxis), i = Dl.computeEllipsePositions(e, !0, !1), o = i.positions, r = i.numPts, s = ase(o, e, !1), a = cse(r); return a = Me.createTypedArray(o.length / 3, a), { boundingSphere: n, attributes: s, indices: a } } function R6e(e, t) { let n = t.vertexFormat, i = t.center, o = t.semiMajorAxis, r = t.semiMinorAxis, s = t.ellipsoid, a = t.height, c = t.extrudedHeight, u = t.stRotation, f = e.length / 3 * 2, d = new Float64Array(f * 3), p = n.st ? new Float32Array(f * 2) : void 0, g = n.normal ? new Float32Array(f * 3) : void 0, m = n.tangent ? new Float32Array(f * 3) : void 0, A = n.bitangent ? new Float32Array(f * 3) : void 0, C = t.shadowVolume, x = C ? new Float32Array(f * 3) : void 0, T = 0, b = tse, S = nse, D = ise, P = new _i(s), B = P.project(s.cartesianToCartographic(i, iN), ose), R = s.scaleToGeodeticSurface(i, lT); s.geodeticSurfaceNormal(R, R); let M = Be.fromAxisAngle(R, u, k6), L = Q.fromQuaternion(M, ese), _ = H.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, rse), E = H.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, sse), w = e.length, v = w / 3 * 2; for (let V = 0; V < w; V += 3) { let z = V + 1, k = V + 2, G = h.fromArray(e, V, lT), N; if (n.st) { let q = Q.multiplyByVector(L, G, N6), J = P.project(s.cartesianToCartographic(q, iN), V6); h.subtract(J, B, J), $r.x = (J.x + o) / (2 * o), $r.y = (J.y + r) / (2 * r), _.x = Math.min($r.x, _.x), _.y = Math.min($r.y, _.y), E.x = Math.max($r.x, E.x), E.y = Math.max($r.y, E.y), p[T + v] = $r.x, p[T + 1 + v] = $r.y, p[T++] = $r.x, p[T++] = $r.y } G = s.scaleToGeodeticSurface(G, G), N = h.clone(G, N6), b = s.geodeticSurfaceNormal(G, b), C && (x[V + w] = -b.x, x[z + w] = -b.y, x[k + w] = -b.z); let X = h.multiplyByScalar(b, a, $re); if (G = h.add(G, X, G), X = h.multiplyByScalar(b, c, X), N = h.add(N, X, N), n.position && (d[V + w] = N.x, d[z + w] = N.y, d[k + w] = N.z, d[V] = G.x, d[z] = G.y, d[k] = G.z), n.normal || n.tangent || n.bitangent) { D = h.clone(b, D); let q = h.fromArray(e, (V + 3) % w, $re); h.subtract(q, G, q); let J = h.subtract(N, G, V6); b = h.normalize(h.cross(J, q, b), b), n.normal && (g[V] = b.x, g[z] = b.y, g[k] = b.z, g[V + w] = b.x, g[z + w] = b.y, g[k + w] = b.z), n.tangent && (S = h.normalize(h.cross(D, b, S), S), m[V] = S.x, m[z] = S.y, m[k] = S.z, m[V + w] = S.x, m[V + 1 + w] = S.y, m[V + 2 + w] = S.z), n.bitangent && (A[V] = D.x, A[z] = D.y, A[k] = D.z, A[V + w] = D.x, A[z + w] = D.y, A[k + w] = D.z) } } if (n.st) { w = p.length; for (let V = 0; V < w; V += 2)p[V] = (p[V] - _.x) / (E.x - _.x), p[V + 1] = (p[V + 1] - _.y) / (E.y - _.y) } let O = new sn; if (n.position && (O.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: d })), n.st && (O.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: p })), n.normal && (O.normal = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: g })), n.tangent && (O.tangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: m })), n.bitangent && (O.bitangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: A })), C && (O.extrudeDirection = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: x })), l(t.offsetAttribute)) { let V = new Uint8Array(f); if (t.offsetAttribute === Qt.TOP) V = V.fill(1, 0, f / 2); else { let z = t.offsetAttribute === Qt.NONE ? 0 : 1; V = V.fill(z) } O.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: V }) } return O } function M6e(e) { let t = e.length / 3, n = Me.createTypedArray(t, t * 6), i = 0; for (let o = 0; o < t; o++) { let r = o, s = o + t, a = (r + 1) % t, c = a + t; n[i++] = r, n[i++] = s, n[i++] = a, n[i++] = a, n[i++] = s, n[i++] = c } return n } var tN = new re, nN = new re; function L6e(e) { let t = e.center, n = e.ellipsoid, i = e.semiMajorAxis, o = h.multiplyByScalar(n.geodeticSurfaceNormal(t, lT), e.height, lT); tN.center = h.add(t, o, tN.center), tN.radius = i, o = h.multiplyByScalar(n.geodeticSurfaceNormal(t, o), e.extrudedHeight, o), nN.center = h.add(t, o, nN.center), nN.radius = i; let r = Dl.computeEllipsePositions(e, !0, !0), s = r.positions, a = r.numPts, c = r.outerPositions, u = re.union(tN, nN), f = ase(s, e, !0), d = cse(a), p = d.length; d.length = p * 2; let g = s.length / 3; for (let S = 0; S < p; S += 3)d[S + p] = d[S + 2] + g, d[S + 1 + p] = d[S + 1] + g, d[S + 2 + p] = d[S] + g; let m = Me.createTypedArray(g * 2 / 3, d), A = new st({ attributes: f, indices: m, primitiveType: Oe.TRIANGLES }), C = R6e(c, e); d = M6e(c); let x = Me.createTypedArray(c.length * 2 / 3, d), T = new st({ attributes: C, indices: x, primitiveType: Oe.TRIANGLES }), b = Bn.combineInstances([new At({ geometry: A }), new At({ geometry: T })]); return { boundingSphere: u, attributes: b[0].attributes, indices: b[0].indices } } function lse(e, t, n, i, o, r, s) { let c = Dl.computeEllipsePositions({ center: e, semiMajorAxis: t, semiMinorAxis: n, rotation: i, granularity: o }, !1, !0).outerPositions, u = c.length / 3, f = new Array(u); for (let p = 0; p < u; ++p)f[p] = h.fromArray(c, p * 3); let d = ce.fromCartesianArray(f, r, s); return d.width > I.PI && (d.north = d.north > 0 ? I.PI_OVER_TWO - I.EPSILON7 : d.north, d.south = d.south < 0 ? I.EPSILON7 - I.PI_OVER_TWO : d.south, d.east = I.PI, d.west = -I.PI), d } function fh(e) { e = y(e, y.EMPTY_OBJECT); let t = e.center, n = y(e.ellipsoid, ie.WGS84), i = e.semiMajorAxis, o = e.semiMinorAxis, r = y(e.granularity, I.RADIANS_PER_DEGREE), s = y(e.vertexFormat, we.DEFAULT), a = y(e.height, 0), c = y(e.extrudedHeight, a); this._center = h.clone(t), this._semiMajorAxis = i, this._semiMinorAxis = o, this._ellipsoid = ie.clone(n), this._rotation = y(e.rotation, 0), this._stRotation = y(e.stRotation, 0), this._height = Math.max(c, a), this._granularity = r, this._vertexFormat = we.clone(s), this._extrudedHeight = Math.min(c, a), this._shadowVolume = y(e.shadowVolume, !1), this._workerName = "createEllipseGeometry", this._offsetAttribute = e.offsetAttribute, this._rectangle = void 0, this._textureCoordinateRotationPoints = void 0 } fh.packedLength = h.packedLength + ie.packedLength + we.packedLength + 9; fh.pack = function (e, t, n) { return n = y(n, 0), h.pack(e._center, t, n), n += h.packedLength, ie.pack(e._ellipsoid, t, n), n += ie.packedLength, we.pack(e._vertexFormat, t, n), n += we.packedLength, t[n++] = e._semiMajorAxis, t[n++] = e._semiMinorAxis, t[n++] = e._rotation, t[n++] = e._stRotation, t[n++] = e._height, t[n++] = e._granularity, t[n++] = e._extrudedHeight, t[n++] = e._shadowVolume ? 1 : 0, t[n] = y(e._offsetAttribute, -1), t }; var use = new h, fse = new ie, dse = new we, uh = { center: use, ellipsoid: fse, vertexFormat: dse, semiMajorAxis: void 0, semiMinorAxis: void 0, rotation: void 0, stRotation: void 0, height: void 0, granularity: void 0, extrudedHeight: void 0, shadowVolume: void 0, offsetAttribute: void 0 }; fh.unpack = function (e, t, n) { t = y(t, 0); let i = h.unpack(e, t, use); t += h.packedLength; let o = ie.unpack(e, t, fse); t += ie.packedLength; let r = we.unpack(e, t, dse); t += we.packedLength; let s = e[t++], a = e[t++], c = e[t++], u = e[t++], f = e[t++], d = e[t++], p = e[t++], g = e[t++] === 1, m = e[t]; return l(n) ? (n._center = h.clone(i, n._center), n._ellipsoid = ie.clone(o, n._ellipsoid), n._vertexFormat = we.clone(r, n._vertexFormat), n._semiMajorAxis = s, n._semiMinorAxis = a, n._rotation = c, n._stRotation = u, n._height = f, n._granularity = d, n._extrudedHeight = p, n._shadowVolume = g, n._offsetAttribute = m === -1 ? void 0 : m, n) : (uh.height = f, uh.extrudedHeight = p, uh.granularity = d, uh.stRotation = u, uh.rotation = c, uh.semiMajorAxis = s, uh.semiMinorAxis = a, uh.shadowVolume = g, uh.offsetAttribute = m === -1 ? void 0 : m, new fh(uh)) }; fh.computeRectangle = function (e, t) { e = y(e, y.EMPTY_OBJECT); let n = e.center, i = y(e.ellipsoid, ie.WGS84), o = e.semiMajorAxis, r = e.semiMinorAxis, s = y(e.granularity, I.RADIANS_PER_DEGREE), a = y(e.rotation, 0); return lse(n, o, r, a, s, i, t) }; fh.createGeometry = function (e) { if (e._semiMajorAxis <= 0 || e._semiMinorAxis <= 0) return; let t = e._height, n = e._extrudedHeight, i = !I.equalsEpsilon(t, n, 0, I.EPSILON2); e._center = e._ellipsoid.scaleToGeodeticSurface(e._center, e._center); let o = { center: e._center, semiMajorAxis: e._semiMajorAxis, semiMinorAxis: e._semiMinorAxis, ellipsoid: e._ellipsoid, rotation: e._rotation, height: t, granularity: e._granularity, vertexFormat: e._vertexFormat, stRotation: e._stRotation }, r; if (i) o.extrudedHeight = n, o.shadowVolume = e._shadowVolume, o.offsetAttribute = e._offsetAttribute, r = L6e(o); else if (r = B6e(o), l(e._offsetAttribute)) { let s = r.attributes.position.values.length, a = e._offsetAttribute === Qt.NONE ? 0 : 1, c = new Uint8Array(s / 3).fill(a); r.attributes.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: c }) } return new st({ attributes: r.attributes, indices: r.indices, primitiveType: Oe.TRIANGLES, boundingSphere: r.boundingSphere, offsetAttribute: e._offsetAttribute }) }; fh.createShadowVolume = function (e, t, n) { let i = e._granularity, o = e._ellipsoid, r = t(i, o), s = n(i, o); return new fh({ center: e._center, semiMajorAxis: e._semiMajorAxis, semiMinorAxis: e._semiMinorAxis, ellipsoid: o, rotation: e._rotation, stRotation: e._stRotation, granularity: i, extrudedHeight: r, height: s, vertexFormat: we.POSITION_ONLY, shadowVolume: !0 }) }; function F6e(e) { let t = -e._stRotation; if (t === 0) return [0, 0, 0, 1, 1, 0]; let i = Dl.computeEllipsePositions({ center: e._center, semiMajorAxis: e._semiMajorAxis, semiMinorAxis: e._semiMinorAxis, rotation: e._rotation, granularity: e._granularity }, !1, !0).outerPositions, o = i.length / 3, r = new Array(o); for (let c = 0; c < o; ++c)r[c] = h.fromArray(i, c * 3); let s = e._ellipsoid, a = e.rectangle; return st._textureCoordinateRotationPoints(r, t, s, a) } Object.defineProperties(fh.prototype, { rectangle: { get: function () { return l(this._rectangle) || (this._rectangle = lse(this._center, this._semiMajorAxis, this._semiMinorAxis, this._rotation, this._granularity, this._ellipsoid)), this._rectangle } }, textureCoordinateRotationPoints: { get: function () { return l(this._textureCoordinateRotationPoints) || (this._textureCoordinateRotationPoints = F6e(this)), this._textureCoordinateRotationPoints } } }); var Yc = fh; var hse = new h, Sy = new h; function N6e(e) { let t = e.center; Sy = h.multiplyByScalar(e.ellipsoid.geodeticSurfaceNormal(t, Sy), e.height, Sy), Sy = h.add(t, Sy, Sy); let n = new re(Sy, e.semiMajorAxis), i = Dl.computeEllipsePositions(e, !1, !0).outerPositions, o = new sn({ position: new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: Dl.raisePositionsToHeight(i, e, !1) }) }), r = i.length / 3, s = Me.createTypedArray(r, r * 2), a = 0; for (let c = 0; c < r; ++c)s[a++] = c, s[a++] = (c + 1) % r; return { boundingSphere: n, attributes: o, indices: s } } var oN = new re, rN = new re; function V6e(e) { let t = e.center, n = e.ellipsoid, i = e.semiMajorAxis, o = h.multiplyByScalar(n.geodeticSurfaceNormal(t, hse), e.height, hse); oN.center = h.add(t, o, oN.center), oN.radius = i, o = h.multiplyByScalar(n.geodeticSurfaceNormal(t, o), e.extrudedHeight, o), rN.center = h.add(t, o, rN.center), rN.radius = i; let r = Dl.computeEllipsePositions(e, !1, !0).outerPositions, s = new sn({ position: new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: Dl.raisePositionsToHeight(r, e, !0) }) }); r = s.position.values; let a = re.union(oN, rN), c = r.length / 3; if (l(e.offsetAttribute)) { let m = new Uint8Array(c); if (e.offsetAttribute === Qt.TOP) m = m.fill(1, 0, c / 2); else { let A = e.offsetAttribute === Qt.NONE ? 0 : 1; m = m.fill(A) } s.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: m }) } let u = y(e.numberOfVerticalLines, 16); u = I.clamp(u, 0, c / 2); let f = Me.createTypedArray(c, c * 2 + u * 2); c /= 2; let d = 0, p; for (p = 0; p < c; ++p)f[d++] = p, f[d++] = (p + 1) % c, f[d++] = p + c, f[d++] = (p + 1) % c + c; let g; if (u > 0) { let m = Math.min(u, c); g = Math.round(c / m); let A = Math.min(g * u, c); for (p = 0; p < A; p += g)f[d++] = p, f[d++] = p + c } return { boundingSphere: a, attributes: s, indices: f } } function uT(e) { e = y(e, y.EMPTY_OBJECT); let t = e.center, n = y(e.ellipsoid, ie.WGS84), i = e.semiMajorAxis, o = e.semiMinorAxis, r = y(e.granularity, I.RADIANS_PER_DEGREE), s = y(e.height, 0), a = y(e.extrudedHeight, s); this._center = h.clone(t), this._semiMajorAxis = i, this._semiMinorAxis = o, this._ellipsoid = ie.clone(n), this._rotation = y(e.rotation, 0), this._height = Math.max(a, s), this._granularity = r, this._extrudedHeight = Math.min(a, s), this._numberOfVerticalLines = Math.max(y(e.numberOfVerticalLines, 16), 0), this._offsetAttribute = e.offsetAttribute, this._workerName = "createEllipseOutlineGeometry" } uT.packedLength = h.packedLength + ie.packedLength + 8; uT.pack = function (e, t, n) { return n = y(n, 0), h.pack(e._center, t, n), n += h.packedLength, ie.pack(e._ellipsoid, t, n), n += ie.packedLength, t[n++] = e._semiMajorAxis, t[n++] = e._semiMinorAxis, t[n++] = e._rotation, t[n++] = e._height, t[n++] = e._granularity, t[n++] = e._extrudedHeight, t[n++] = e._numberOfVerticalLines, t[n] = y(e._offsetAttribute, -1), t }; var mse = new h, pse = new ie, $m = { center: mse, ellipsoid: pse, semiMajorAxis: void 0, semiMinorAxis: void 0, rotation: void 0, height: void 0, granularity: void 0, extrudedHeight: void 0, numberOfVerticalLines: void 0, offsetAttribute: void 0 }; uT.unpack = function (e, t, n) { t = y(t, 0); let i = h.unpack(e, t, mse); t += h.packedLength; let o = ie.unpack(e, t, pse); t += ie.packedLength; let r = e[t++], s = e[t++], a = e[t++], c = e[t++], u = e[t++], f = e[t++], d = e[t++], p = e[t]; return l(n) ? (n._center = h.clone(i, n._center), n._ellipsoid = ie.clone(o, n._ellipsoid), n._semiMajorAxis = r, n._semiMinorAxis = s, n._rotation = a, n._height = c, n._granularity = u, n._extrudedHeight = f, n._numberOfVerticalLines = d, n._offsetAttribute = p === -1 ? void 0 : p, n) : ($m.height = c, $m.extrudedHeight = f, $m.granularity = u, $m.rotation = a, $m.semiMajorAxis = r, $m.semiMinorAxis = s, $m.numberOfVerticalLines = d, $m.offsetAttribute = p === -1 ? void 0 : p, new uT($m)) }; uT.createGeometry = function (e) { if (e._semiMajorAxis <= 0 || e._semiMinorAxis <= 0) return; let t = e._height, n = e._extrudedHeight, i = !I.equalsEpsilon(t, n, 0, I.EPSILON2); e._center = e._ellipsoid.scaleToGeodeticSurface(e._center, e._center); let o = { center: e._center, semiMajorAxis: e._semiMajorAxis, semiMinorAxis: e._semiMinorAxis, ellipsoid: e._ellipsoid, rotation: e._rotation, height: t, granularity: e._granularity, numberOfVerticalLines: e._numberOfVerticalLines }, r; if (i) o.extrudedHeight = n, o.offsetAttribute = e._offsetAttribute, r = V6e(o); else if (r = N6e(o), l(e._offsetAttribute)) { let s = r.attributes.position.values.length, a = e._offsetAttribute === Qt.NONE ? 0 : 1, c = new Uint8Array(s / 3).fill(a); r.attributes.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: c }) } return new st({ attributes: r.attributes, indices: r.indices, primitiveType: Oe.LINES, boundingSphere: r.boundingSphere, offsetAttribute: e._offsetAttribute }) }; var Mu = uT; var _se = new U, gse = h.ZERO, yse = new h, Ase = new ce; function k6e(e) { this.id = e, this.vertexFormat = void 0, this.center = void 0, this.semiMajorAxis = void 0, this.semiMinorAxis = void 0, this.rotation = void 0, this.height = void 0, this.extrudedHeight = void 0, this.granularity = void 0, this.stRotation = void 0, this.numberOfVerticalLines = void 0, this.offsetAttribute = void 0 } function Uf(e, t) { zn.call(this, { entity: e, scene: t, geometryOptions: new k6e(e), geometryPropertyName: "ellipse", observedPropertyNames: ["availability", "position", "ellipse"] }), this._onEntityPropertyChanged(e, "ellipse", e.ellipse, void 0) } l(Object.create) && (Uf.prototype = Object.create(zn.prototype), Uf.prototype.constructor = Uf); Uf.prototype.createFillGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = { show: new fn(n && t.isShowing && this._showProperty.getValue(e) && this._fillProperty.getValue(e)), distanceDisplayCondition: Mn.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(e)), offset: void 0, color: void 0 }; if (this._materialProperty instanceof Ot) { let o; l(this._materialProperty.color) && (this._materialProperty.color.isConstant || n) && (o = this._materialProperty.color.getValue(e, _se)), l(o) || (o = U.WHITE), i.color = Bt.fromColor(o) } return l(this._options.offsetAttribute) && (i.offset = zi.fromCartesian3(j.getValueOrDefault(this._terrainOffsetProperty, e, gse, yse))), new At({ id: t, geometry: new Yc(this._options), attributes: i }) }; Uf.prototype.createOutlineGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = j.getValueOrDefault(this._outlineColorProperty, e, U.BLACK, _se), o = this._distanceDisplayConditionProperty.getValue(e), r = { show: new fn(n && t.isShowing && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)), color: Bt.fromColor(i), distanceDisplayCondition: Mn.fromDistanceDisplayCondition(o), offset: void 0 }; return l(this._options.offsetAttribute) && (r.offset = zi.fromCartesian3(j.getValueOrDefault(this._terrainOffsetProperty, e, gse, yse))), new At({ id: t, geometry: new Mu(this._options), attributes: r }) }; Uf.prototype._computeCenter = function (e, t) { return j.getValueOrUndefined(this._entity.position, e, t) }; Uf.prototype._isHidden = function (e, t) { let n = e.position; return !l(n) || !l(t.semiMajorAxis) || !l(t.semiMinorAxis) || ei.prototype._isHidden.call(this, e, t) }; Uf.prototype._isDynamic = function (e, t) { return !e.position.isConstant || !t.semiMajorAxis.isConstant || !t.semiMinorAxis.isConstant || !j.isConstant(t.rotation) || !j.isConstant(t.height) || !j.isConstant(t.extrudedHeight) || !j.isConstant(t.granularity) || !j.isConstant(t.stRotation) || !j.isConstant(t.outlineWidth) || !j.isConstant(t.numberOfVerticalLines) || !j.isConstant(t.zIndex) || this._onTerrain && !j.isConstant(this._materialProperty) && !(this._materialProperty instanceof Ot) }; Uf.prototype._setStaticOptions = function (e, t) { let n = j.getValueOrUndefined(t.height, ke.MINIMUM_VALUE), i = j.getValueOrDefault(t.heightReference, ke.MINIMUM_VALUE, ze.NONE), o = j.getValueOrUndefined(t.extrudedHeight, ke.MINIMUM_VALUE), r = j.getValueOrDefault(t.extrudedHeightReference, ke.MINIMUM_VALUE, ze.NONE); l(o) && !l(n) && (n = 0); let s = this._options; s.vertexFormat = this._materialProperty instanceof Ot ? $t.VERTEX_FORMAT : eo.MaterialSupport.TEXTURED.vertexFormat, s.center = e.position.getValue(ke.MINIMUM_VALUE, s.center), s.semiMajorAxis = t.semiMajorAxis.getValue(ke.MINIMUM_VALUE, s.semiMajorAxis), s.semiMinorAxis = t.semiMinorAxis.getValue(ke.MINIMUM_VALUE, s.semiMinorAxis), s.rotation = j.getValueOrUndefined(t.rotation, ke.MINIMUM_VALUE), s.granularity = j.getValueOrUndefined(t.granularity, ke.MINIMUM_VALUE), s.stRotation = j.getValueOrUndefined(t.stRotation, ke.MINIMUM_VALUE), s.numberOfVerticalLines = j.getValueOrUndefined(t.numberOfVerticalLines, ke.MINIMUM_VALUE), s.offsetAttribute = zn.computeGeometryOffsetAttribute(n, i, o, r), s.height = zn.getGeometryHeight(n, i), o = zn.getGeometryExtrudedHeight(o, r), o === zn.CLAMP_TO_GROUND && (o = oi.getMinimumMaximumHeights(Yc.computeRectangle(s, Ase)).minimumTerrainHeight), s.extrudedHeight = o }; Uf.DynamicGeometryUpdater = fT; function fT(e, t, n) { $n.call(this, e, t, n) } l(Object.create) && (fT.prototype = Object.create($n.prototype), fT.prototype.constructor = fT); fT.prototype._isHidden = function (e, t, n) { let i = this._options; return !l(i.center) || !l(i.semiMajorAxis) || !l(i.semiMinorAxis) || $n.prototype._isHidden.call(this, e, t, n) }; fT.prototype._setOptions = function (e, t, n) { let i = this._options, o = j.getValueOrUndefined(t.height, n), r = j.getValueOrDefault(t.heightReference, n, ze.NONE), s = j.getValueOrUndefined(t.extrudedHeight, n), a = j.getValueOrDefault(t.extrudedHeightReference, n, ze.NONE); l(s) && !l(o) && (o = 0), i.center = j.getValueOrUndefined(e.position, n, i.center), i.semiMajorAxis = j.getValueOrUndefined(t.semiMajorAxis, n), i.semiMinorAxis = j.getValueOrUndefined(t.semiMinorAxis, n), i.rotation = j.getValueOrUndefined(t.rotation, n), i.granularity = j.getValueOrUndefined(t.granularity, n), i.stRotation = j.getValueOrUndefined(t.stRotation, n), i.numberOfVerticalLines = j.getValueOrUndefined(t.numberOfVerticalLines, n), i.offsetAttribute = zn.computeGeometryOffsetAttribute(o, r, s, a), i.height = zn.getGeometryHeight(o, r), s = zn.getGeometryExtrudedHeight(s, a), s === zn.CLAMP_TO_GROUND && (s = oi.getMinimumMaximumHeights(Yc.computeRectangle(i, Ase)).minimumTerrainHeight), i.extrudedHeight = s }; var sN = Uf; var U6e = new h, z6e = new h, H6e = new h, G6e = new h, W6e = new h, j6e = new h(1, 1, 1), Cse = Math.cos, xse = Math.sin; function ep(e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.radii, j6e), n = y(e.innerRadii, t), i = y(e.minimumClock, 0), o = y(e.maximumClock, I.TWO_PI), r = y(e.minimumCone, 0), s = y(e.maximumCone, I.PI), a = Math.round(y(e.stackPartitions, 64)), c = Math.round(y(e.slicePartitions, 64)), u = y(e.vertexFormat, we.DEFAULT); this._radii = h.clone(t), this._innerRadii = h.clone(n), this._minimumClock = i, this._maximumClock = o, this._minimumCone = r, this._maximumCone = s, this._stackPartitions = a, this._slicePartitions = c, this._vertexFormat = we.clone(u), this._offsetAttribute = e.offsetAttribute, this._workerName = "createEllipsoidGeometry" } ep.packedLength = 2 * h.packedLength + we.packedLength + 7; ep.pack = function (e, t, n) { return n = y(n, 0), h.pack(e._radii, t, n), n += h.packedLength, h.pack(e._innerRadii, t, n), n += h.packedLength, we.pack(e._vertexFormat, t, n), n += we.packedLength, t[n++] = e._minimumClock, t[n++] = e._maximumClock, t[n++] = e._minimumCone, t[n++] = e._maximumCone, t[n++] = e._stackPartitions, t[n++] = e._slicePartitions, t[n] = y(e._offsetAttribute, -1), t }; var Tse = new h, Ese = new h, bse = new we, eg = { radii: Tse, innerRadii: Ese, vertexFormat: bse, minimumClock: void 0, maximumClock: void 0, minimumCone: void 0, maximumCone: void 0, stackPartitions: void 0, slicePartitions: void 0, offsetAttribute: void 0 }; ep.unpack = function (e, t, n) { t = y(t, 0); let i = h.unpack(e, t, Tse); t += h.packedLength; let o = h.unpack(e, t, Ese); t += h.packedLength; let r = we.unpack(e, t, bse); t += we.packedLength; let s = e[t++], a = e[t++], c = e[t++], u = e[t++], f = e[t++], d = e[t++], p = e[t]; return l(n) ? (n._radii = h.clone(i, n._radii), n._innerRadii = h.clone(o, n._innerRadii), n._vertexFormat = we.clone(r, n._vertexFormat), n._minimumClock = s, n._maximumClock = a, n._minimumCone = c, n._maximumCone = u, n._stackPartitions = f, n._slicePartitions = d, n._offsetAttribute = p === -1 ? void 0 : p, n) : (eg.minimumClock = s, eg.maximumClock = a, eg.minimumCone = c, eg.maximumCone = u, eg.stackPartitions = f, eg.slicePartitions = d, eg.offsetAttribute = p === -1 ? void 0 : p, new ep(eg)) }; ep.createGeometry = function (e) { let t = e._radii; if (t.x <= 0 || t.y <= 0 || t.z <= 0) return; let n = e._innerRadii; if (n.x <= 0 || n.y <= 0 || n.z <= 0) return; let i = e._minimumClock, o = e._maximumClock, r = e._minimumCone, s = e._maximumCone, a = e._vertexFormat, c = e._slicePartitions + 1, u = e._stackPartitions + 1; c = Math.round(c * Math.abs(o - i) / I.TWO_PI), u = Math.round(u * Math.abs(s - r) / I.PI), c < 2 && (c = 2), u < 2 && (u = 2); let f, d, p = 0, g = [r], m = [i]; for (f = 0; f < u; f++)g.push(r + f * (s - r) / (u - 1)); for (g.push(s), d = 0; d < c; d++)m.push(i + d * (o - i) / (c - 1)); m.push(o); let A = g.length, C = m.length, x = 0, T = 1, b = n.x !== t.x || n.y !== t.y || n.z !== t.z, S = !1, D = !1, P = !1; b && (T = 2, r > 0 && (S = !0, x += c - 1), s < Math.PI && (D = !0, x += c - 1), (o - i) % I.TWO_PI ? (P = !0, x += (u - 1) * 2 + 1) : x += 1); let B = C * A * T, R = new Float64Array(B * 3), M = new Array(B).fill(!1), L = new Array(B).fill(!1), _ = c * u * T, E = 6 * (_ + x + 1 - (c + u) * T), w = Me.createTypedArray(_, E), v = a.normal ? new Float32Array(B * 3) : void 0, O = a.tangent ? new Float32Array(B * 3) : void 0, V = a.bitangent ? new Float32Array(B * 3) : void 0, z = a.st ? new Float32Array(B * 2) : void 0, k = new Array(A), G = new Array(A); for (f = 0; f < A; f++)k[f] = xse(g[f]), G[f] = Cse(g[f]); let N = new Array(C), X = new Array(C); for (d = 0; d < C; d++)X[d] = Cse(m[d]), N[d] = xse(m[d]); for (f = 0; f < A; f++)for (d = 0; d < C; d++)R[p++] = t.x * k[f] * X[d], R[p++] = t.y * k[f] * N[d], R[p++] = t.z * G[f]; let q = B / 2; if (b) for (f = 0; f < A; f++)for (d = 0; d < C; d++)R[p++] = n.x * k[f] * X[d], R[p++] = n.y * k[f] * N[d], R[p++] = n.z * G[f], M[q] = !0, f > 0 && f !== A - 1 && d !== 0 && d !== C - 1 && (L[q] = !0), q++; p = 0; let J, W; for (f = 1; f < A - 2; f++)for (J = f * C, W = (f + 1) * C, d = 1; d < C - 2; d++)w[p++] = W + d, w[p++] = W + d + 1, w[p++] = J + d + 1, w[p++] = W + d, w[p++] = J + d + 1, w[p++] = J + d; if (b) { let Lt = A * C; for (f = 1; f < A - 2; f++)for (J = Lt + f * C, W = Lt + (f + 1) * C, d = 1; d < C - 2; d++)w[p++] = W + d, w[p++] = J + d, w[p++] = J + d + 1, w[p++] = W + d, w[p++] = J + d + 1, w[p++] = W + d + 1 } let K, Z; if (b) { if (S) for (Z = A * C, f = 1; f < C - 2; f++)w[p++] = f, w[p++] = f + 1, w[p++] = Z + f + 1, w[p++] = f, w[p++] = Z + f + 1, w[p++] = Z + f; if (D) for (K = A * C - C, Z = A * C * T - C, f = 1; f < C - 2; f++)w[p++] = K + f + 1, w[p++] = K + f, w[p++] = Z + f, w[p++] = K + f + 1, w[p++] = Z + f, w[p++] = Z + f + 1 } if (P) { for (f = 1; f < A - 2; f++)Z = C * A + C * f, K = C * f, w[p++] = Z, w[p++] = K + C, w[p++] = K, w[p++] = Z, w[p++] = Z + C, w[p++] = K + C; for (f = 1; f < A - 2; f++)Z = C * A + C * (f + 1) - 1, K = C * (f + 1) - 1, w[p++] = K + C, w[p++] = Z, w[p++] = K, w[p++] = K + C, w[p++] = Z + C, w[p++] = Z } let de = new sn; a.position && (de.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: R })); let pe = 0, oe = 0, ue = 0, ge = 0, Ee = B / 2, Ie, Fe = ie.fromCartesian3(t), We = ie.fromCartesian3(n); if (a.st || a.normal || a.tangent || a.bitangent) { for (f = 0; f < B; f++) { Ie = M[f] ? We : Fe; let Lt = h.fromArray(R, f * 3, U6e), Gt = Ie.geodeticSurfaceNormal(Lt, z6e); if (L[f] && h.negate(Gt, Gt), a.st) { let cn = H.negate(Gt, W6e); z[pe++] = Math.atan2(cn.y, cn.x) / I.TWO_PI + .5, z[pe++] = Math.asin(Gt.z) / Math.PI + .5 } if (a.normal && (v[oe++] = Gt.x, v[oe++] = Gt.y, v[oe++] = Gt.z), a.tangent || a.bitangent) { let cn = H6e, _t = 0, Pn; if (M[f] && (_t = Ee), !S && f >= _t && f < _t + C * 2 ? Pn = h.UNIT_X : Pn = h.UNIT_Z, h.cross(Pn, Gt, cn), h.normalize(cn, cn), a.tangent && (O[ue++] = cn.x, O[ue++] = cn.y, O[ue++] = cn.z), a.bitangent) { let Jn = h.cross(Gt, cn, G6e); h.normalize(Jn, Jn), V[ge++] = Jn.x, V[ge++] = Jn.y, V[ge++] = Jn.z } } } a.st && (de.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: z })), a.normal && (de.normal = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: v })), a.tangent && (de.tangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: O })), a.bitangent && (de.bitangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: V })) } if (l(e._offsetAttribute)) { let Lt = R.length, Gt = e._offsetAttribute === Qt.NONE ? 0 : 1, cn = new Uint8Array(Lt / 3).fill(Gt); de.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: cn }) } return new st({ attributes: de, indices: w, primitiveType: Oe.TRIANGLES, boundingSphere: re.fromEllipsoid(Fe), offsetAttribute: e._offsetAttribute }) }; var U6; ep.getUnitEllipsoid = function () { return l(U6) || (U6 = ep.createGeometry(new ep({ radii: new h(1, 1, 1), vertexFormat: we.POSITION_ONLY }))), U6 }; var Bs = ep; var q6e = new Ot(U.WHITE), z6 = h.ZERO, H6 = new h, Y6e = new h, X6e = new h, G6 = new U, K6e = new h(1, 1, 1); function J6e(e) { this.id = e, this.vertexFormat = void 0, this.radii = void 0, this.innerRadii = void 0, this.minimumClock = void 0, this.maximumClock = void 0, this.minimumCone = void 0, this.maximumCone = void 0, this.stackPartitions = void 0, this.slicePartitions = void 0, this.subdivisions = void 0, this.offsetAttribute = void 0 } function vl(e, t) { ei.call(this, { entity: e, scene: t, geometryOptions: new J6e(e), geometryPropertyName: "ellipsoid", observedPropertyNames: ["availability", "position", "orientation", "ellipsoid"] }), this._onEntityPropertyChanged(e, "ellipsoid", e.ellipsoid, void 0) } l(Object.create) && (vl.prototype = Object.create(ei.prototype), vl.prototype.constructor = vl); Object.defineProperties(vl.prototype, { terrainOffsetProperty: { get: function () { return this._terrainOffsetProperty } } }); vl.prototype.createFillGeometryInstance = function (e, t, n) { let i = this._entity, o = i.isAvailable(e), r, s = new fn(o && i.isShowing && this._showProperty.getValue(e) && this._fillProperty.getValue(e)), a = this._distanceDisplayConditionProperty.getValue(e), c = Mn.fromDistanceDisplayCondition(a), u = { show: s, distanceDisplayCondition: c, color: void 0, offset: void 0 }; if (this._materialProperty instanceof Ot) { let f; l(this._materialProperty.color) && (this._materialProperty.color.isConstant || o) && (f = this._materialProperty.color.getValue(e, G6)), l(f) || (f = U.WHITE), r = Bt.fromColor(f), u.color = r } return l(this._options.offsetAttribute) && (u.offset = zi.fromCartesian3(j.getValueOrDefault(this._terrainOffsetProperty, e, z6, H6))), new At({ id: i, geometry: new Bs(this._options), modelMatrix: t ? void 0 : i.computeModelMatrixForHeightReference(e, i.ellipsoid.heightReference, this._options.radii.z * .5, this._scene.mapProjection.ellipsoid, n), attributes: u }) }; vl.prototype.createOutlineGeometryInstance = function (e, t, n) { let i = this._entity, o = i.isAvailable(e), r = j.getValueOrDefault(this._outlineColorProperty, e, U.BLACK, G6), s = this._distanceDisplayConditionProperty.getValue(e), a = { show: new fn(o && i.isShowing && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)), color: Bt.fromColor(r), distanceDisplayCondition: Mn.fromDistanceDisplayCondition(s), offset: void 0 }; return l(this._options.offsetAttribute) && (a.offset = zi.fromCartesian3(j.getValueOrDefault(this._terrainOffsetProperty, e, z6, H6))), new At({ id: i, geometry: new bu(this._options), modelMatrix: t ? void 0 : i.computeModelMatrixForHeightReference(e, i.ellipsoid.heightReference, this._options.radii.z * .5, this._scene.mapProjection.ellipsoid, n), attributes: a }) }; vl.prototype._computeCenter = function (e, t) { return j.getValueOrUndefined(this._entity.position, e, t) }; vl.prototype._isHidden = function (e, t) { return !l(e.position) || !l(t.radii) || ei.prototype._isHidden.call(this, e, t) }; vl.prototype._isDynamic = function (e, t) { return !e.position.isConstant || !j.isConstant(e.orientation) || !t.radii.isConstant || !j.isConstant(t.innerRadii) || !j.isConstant(t.stackPartitions) || !j.isConstant(t.slicePartitions) || !j.isConstant(t.outlineWidth) || !j.isConstant(t.minimumClock) || !j.isConstant(t.maximumClock) || !j.isConstant(t.minimumCone) || !j.isConstant(t.maximumCone) || !j.isConstant(t.subdivisions) }; vl.prototype._setStaticOptions = function (e, t) { let n = j.getValueOrDefault(t.heightReference, ke.MINIMUM_VALUE, ze.NONE), i = this._options; i.vertexFormat = this._materialProperty instanceof Ot ? $t.VERTEX_FORMAT : eo.MaterialSupport.TEXTURED.vertexFormat, i.radii = t.radii.getValue(ke.MINIMUM_VALUE, i.radii), i.innerRadii = j.getValueOrUndefined(t.innerRadii, i.radii), i.minimumClock = j.getValueOrUndefined(t.minimumClock, ke.MINIMUM_VALUE), i.maximumClock = j.getValueOrUndefined(t.maximumClock, ke.MINIMUM_VALUE), i.minimumCone = j.getValueOrUndefined(t.minimumCone, ke.MINIMUM_VALUE), i.maximumCone = j.getValueOrUndefined(t.maximumCone, ke.MINIMUM_VALUE), i.stackPartitions = j.getValueOrUndefined(t.stackPartitions, ke.MINIMUM_VALUE), i.slicePartitions = j.getValueOrUndefined(t.slicePartitions, ke.MINIMUM_VALUE), i.subdivisions = j.getValueOrUndefined(t.subdivisions, ke.MINIMUM_VALUE), i.offsetAttribute = n !== ze.NONE ? Qt.ALL : void 0 }; vl.prototype._onEntityPropertyChanged = Wp; vl.DynamicGeometryUpdater = Gw; function Gw(e, t, n) { $n.call(this, e, t, n), this._scene = e._scene, this._modelMatrix = new F, this._attributes = void 0, this._outlineAttributes = void 0, this._lastSceneMode = void 0, this._lastShow = void 0, this._lastOutlineShow = void 0, this._lastOutlineWidth = void 0, this._lastOutlineColor = void 0, this._lastOffset = new h, this._material = {} } l(Object.create) && (Gw.prototype = Object.create($n.prototype), Gw.prototype.constructor = Gw); Gw.prototype.update = function (e) { let t = this._entity, n = t.ellipsoid; if (!t.isShowing || !t.isAvailable(e) || !j.getValueOrDefault(n.show, e, !0)) { l(this._primitive) && (this._primitive.show = !1), l(this._outlinePrimitive) && (this._outlinePrimitive.show = !1); return } let i = j.getValueOrUndefined(n.radii, e, Y6e), o = l(i) ? t.computeModelMatrixForHeightReference(e, n.heightReference, i.z * .5, this._scene.mapProjection.ellipsoid, this._modelMatrix) : void 0; if (!l(o) || !l(i)) { l(this._primitive) && (this._primitive.show = !1), l(this._outlinePrimitive) && (this._outlinePrimitive.show = !1); return } let r = j.getValueOrDefault(n.fill, e, !0), s = j.getValueOrDefault(n.outline, e, !1), a = j.getValueOrClonedDefault(n.outlineColor, e, U.BLACK, G6), c = Yo.getValue(e, y(n.material, q6e), this._material), u = j.getValueOrUndefined(n.innerRadii, e, X6e), f = j.getValueOrUndefined(n.minimumClock, e), d = j.getValueOrUndefined(n.maximumClock, e), p = j.getValueOrUndefined(n.minimumCone, e), g = j.getValueOrUndefined(n.maximumCone, e), m = j.getValueOrUndefined(n.stackPartitions, e), A = j.getValueOrUndefined(n.slicePartitions, e), C = j.getValueOrUndefined(n.subdivisions, e), x = j.getValueOrDefault(n.outlineWidth, e, 1), T = j.getValueOrDefault(n.heightReference, e, ze.NONE), b = T !== ze.NONE ? Qt.ALL : void 0, S = this._scene.mode, D = S === ee.SCENE3D && T === ze.NONE, P = this._options, B = this._geometryUpdater.shadowsProperty.getValue(e), M = this._geometryUpdater.distanceDisplayConditionProperty.getValue(e), L = j.getValueOrDefault(this._geometryUpdater.terrainOffsetProperty, e, z6, H6); if (!D || this._lastSceneMode !== S || !l(this._primitive) || P.stackPartitions !== m || P.slicePartitions !== A || l(u) && !h.equals(P.innerRadii !== u) || P.minimumClock !== f || P.maximumClock !== d || P.minimumCone !== p || P.maximumCone !== g || P.subdivisions !== C || this._lastOutlineWidth !== x || P.offsetAttribute !== b) { let E = this._primitives; if (E.removeAndDestroy(this._primitive), E.removeAndDestroy(this._outlinePrimitive), this._primitive = void 0, this._outlinePrimitive = void 0, this._lastSceneMode = S, this._lastOutlineWidth = x, P.stackPartitions = m, P.slicePartitions = A, P.subdivisions = C, P.offsetAttribute = b, P.radii = h.clone(D ? K6e : i, P.radii), l(u)) if (D) { let V = h.magnitude(i); P.innerRadii = h.fromElements(u.x / V, u.y / V, u.z / V, P.innerRadii) } else P.innerRadii = h.clone(u, P.innerRadii); else P.innerRadii = void 0; P.minimumClock = f, P.maximumClock = d, P.minimumCone = p, P.maximumCone = g; let w = new eo({ material: c, translucent: c.isTranslucent(), closed: !0 }); P.vertexFormat = w.vertexFormat; let v = this._geometryUpdater.createFillGeometryInstance(e, D, this._modelMatrix); this._primitive = E.add(new xn({ geometryInstances: v, appearance: w, asynchronous: !1, shadows: B })); let O = this._geometryUpdater.createOutlineGeometryInstance(e, D, this._modelMatrix); this._outlinePrimitive = E.add(new xn({ geometryInstances: O, appearance: new $t({ flat: !0, translucent: O.attributes.color.value[3] !== 255, renderState: { lineWidth: this._geometryUpdater._scene.clampLineWidth(x) } }), asynchronous: !1, shadows: B })), this._lastShow = r, this._lastOutlineShow = s, this._lastOutlineColor = U.clone(a, this._lastOutlineColor), this._lastDistanceDisplayCondition = M, this._lastOffset = h.clone(L, this._lastOffset) } else if (this._primitive.ready) { let E = this._primitive, w = this._outlinePrimitive; E.show = !0, w.show = !0, E.appearance.material = c; let v = this._attributes; l(v) || (v = E.getGeometryInstanceAttributes(t), this._attributes = v), r !== this._lastShow && (v.show = fn.toValue(r, v.show), this._lastShow = r); let O = this._outlineAttributes; l(O) || (O = w.getGeometryInstanceAttributes(t), this._outlineAttributes = O), s !== this._lastOutlineShow && (O.show = fn.toValue(s, O.show), this._lastOutlineShow = s), U.equals(a, this._lastOutlineColor) || (O.color = Bt.toValue(a, O.color), U.clone(a, this._lastOutlineColor)), bt.equals(M, this._lastDistanceDisplayCondition) || (v.distanceDisplayCondition = Mn.toValue(M, v.distanceDisplayCondition), O.distanceDisplayCondition = Mn.toValue(M, O.distanceDisplayCondition), bt.clone(M, this._lastDistanceDisplayCondition)), h.equals(L, this._lastOffset) || (v.offset = zi.toValue(L, v.offset), O.offset = zi.toValue(L, v.offset), h.clone(L, this._lastOffset)) } D && (i.x = Math.max(i.x, .001), i.y = Math.max(i.y, .001), i.z = Math.max(i.z, .001), o = F.multiplyByScale(o, i, o), this._primitive.modelMatrix = o, this._outlinePrimitive.modelMatrix = o) }; var aN = vl; function dT(e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.vertexFormat, we.DEFAULT); this._vertexFormat = t, this._workerName = "createPlaneGeometry" } dT.packedLength = we.packedLength; dT.pack = function (e, t, n) { return n = y(n, 0), we.pack(e._vertexFormat, t, n), t }; var Sse = new we, Z6e = { vertexFormat: Sse }; dT.unpack = function (e, t, n) { t = y(t, 0); let i = we.unpack(e, t, Sse); return l(n) ? (n._vertexFormat = we.clone(i, n._vertexFormat), n) : new dT(Z6e) }; var cN = new h(-.5, -.5, 0), lN = new h(.5, .5, 0); dT.createGeometry = function (e) { let t = e._vertexFormat, n = new sn, i, o; if (t.position) { if (o = new Float64Array(4 * 3), o[0] = cN.x, o[1] = cN.y, o[2] = 0, o[3] = lN.x, o[4] = cN.y, o[5] = 0, o[6] = lN.x, o[7] = lN.y, o[8] = 0, o[9] = cN.x, o[10] = lN.y, o[11] = 0, n.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: o }), t.normal) { let r = new Float32Array(12); r[0] = 0, r[1] = 0, r[2] = 1, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 1, r[9] = 0, r[10] = 0, r[11] = 1, n.normal = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: r }) } if (t.st) { let r = new Float32Array(8); r[0] = 0, r[1] = 0, r[2] = 1, r[3] = 0, r[4] = 1, r[5] = 1, r[6] = 0, r[7] = 1, n.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: r }) } if (t.tangent) { let r = new Float32Array(12); r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 1, r[4] = 0, r[5] = 0, r[6] = 1, r[7] = 0, r[8] = 0, r[9] = 1, r[10] = 0, r[11] = 0, n.tangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: r }) } if (t.bitangent) { let r = new Float32Array(12); r[0] = 0, r[1] = 1, r[2] = 0, r[3] = 0, r[4] = 1, r[5] = 0, r[6] = 0, r[7] = 1, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, n.bitangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: r }) } i = new Uint16Array(2 * 3), i[0] = 0, i[1] = 1, i[2] = 2, i[3] = 0, i[4] = 2, i[5] = 3 } return new st({ attributes: n, indices: i, primitiveType: Oe.TRIANGLES, boundingSphere: new re(h.ZERO, Math.sqrt(2)) }) }; var uN = dT; function hT() { this._workerName = "createPlaneOutlineGeometry" } hT.packedLength = 0; hT.pack = function (e, t) { return t }; hT.unpack = function (e, t, n) { return l(n) ? n : new hT }; var tg = new h(-.5, -.5, 0), fN = new h(.5, .5, 0); hT.createGeometry = function () { let e = new sn, t = new Uint16Array(4 * 2), n = new Float64Array(4 * 3); return n[0] = tg.x, n[1] = tg.y, n[2] = tg.z, n[3] = fN.x, n[4] = tg.y, n[5] = tg.z, n[6] = fN.x, n[7] = fN.y, n[8] = tg.z, n[9] = tg.x, n[10] = fN.y, n[11] = tg.z, e.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: n }), t[0] = 0, t[1] = 1, t[2] = 1, t[3] = 2, t[4] = 2, t[5] = 3, t[6] = 3, t[7] = 0, new st({ attributes: e, indices: t, primitiveType: Oe.LINES, boundingSphere: new re(h.ZERO, Math.sqrt(2)) }) }; var dN = hT; var Q6e = new h, wse = new U; function $6e(e) { this.id = e, this.vertexFormat = void 0, this.plane = void 0, this.dimensions = void 0 } function Lu(e, t) { ei.call(this, { entity: e, scene: t, geometryOptions: new $6e(e), geometryPropertyName: "plane", observedPropertyNames: ["availability", "position", "orientation", "plane"] }), this._onEntityPropertyChanged(e, "plane", e.plane, void 0) } l(Object.create) && (Lu.prototype = Object.create(ei.prototype), Lu.prototype.constructor = Lu); Lu.prototype.createFillGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i, o, r = new fn(n && t.isShowing && this._showProperty.getValue(e) && this._fillProperty.getValue(e)), s = this._distanceDisplayConditionProperty.getValue(e), a = Mn.fromDistanceDisplayCondition(s); if (this._materialProperty instanceof Ot) { let g; l(this._materialProperty.color) && (this._materialProperty.color.isConstant || n) && (g = this._materialProperty.color.getValue(e, wse)), l(g) || (g = U.WHITE), o = Bt.fromColor(g), i = { show: r, distanceDisplayCondition: a, color: o } } else i = { show: r, distanceDisplayCondition: a }; let c = t.plane, u = this._options, f = t.computeModelMatrix(e), d = j.getValueOrDefault(c.plane, e, u.plane), p = j.getValueOrUndefined(c.dimensions, e, u.dimensions); return u.plane = d, u.dimensions = p, f = W6(d, p, f, f), new At({ id: t, geometry: new uN(this._options), modelMatrix: f, attributes: i }) }; Lu.prototype.createOutlineGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = j.getValueOrDefault(this._outlineColorProperty, e, U.BLACK, wse), o = this._distanceDisplayConditionProperty.getValue(e), r = t.plane, s = this._options, a = t.computeModelMatrix(e), c = j.getValueOrDefault(r.plane, e, s.plane), u = j.getValueOrUndefined(r.dimensions, e, s.dimensions); return s.plane = c, s.dimensions = u, a = W6(c, u, a, a), new At({ id: t, geometry: new dN, modelMatrix: a, attributes: { show: new fn(n && t.isShowing && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)), color: Bt.fromColor(i), distanceDisplayCondition: Mn.fromDistanceDisplayCondition(o) } }) }; Lu.prototype._isHidden = function (e, t) { return !l(t.plane) || !l(t.dimensions) || !l(e.position) || ei.prototype._isHidden.call(this, e, t) }; Lu.prototype._getIsClosed = function (e) { return !1 }; Lu.prototype._isDynamic = function (e, t) { return !e.position.isConstant || !j.isConstant(e.orientation) || !t.plane.isConstant || !t.dimensions.isConstant || !j.isConstant(t.outlineWidth) }; Lu.prototype._setStaticOptions = function (e, t) { let n = this._materialProperty instanceof Ot, i = this._options; i.vertexFormat = n ? $t.VERTEX_FORMAT : eo.MaterialSupport.TEXTURED.vertexFormat, i.plane = t.plane.getValue(ke.MINIMUM_VALUE, i.plane), i.dimensions = t.dimensions.getValue(ke.MINIMUM_VALUE, i.dimensions) }; Lu.DynamicGeometryUpdater = mT; function mT(e, t, n) { $n.call(this, e, t, n) } l(Object.create) && (mT.prototype = Object.create($n.prototype), mT.prototype.constructor = mT); mT.prototype._isHidden = function (e, t, n) { let i = this._options, o = j.getValueOrUndefined(e.position, n, Q6e); return !l(o) || !l(i.plane) || !l(i.dimensions) || $n.prototype._isHidden.call(this, e, t, n) }; mT.prototype._setOptions = function (e, t, n) { let i = this._options; i.plane = j.getValueOrDefault(t.plane, n, i.plane), i.dimensions = j.getValueOrUndefined(t.dimensions, n, i.dimensions) }; var e9e = new h, t9e = new h, n9e = new h, i9e = new h, o9e = new Q, r9e = new Q, s9e = new F; function W6(e, t, n, i) { let o = e.normal, r = e.distance, s = h.multiplyByScalar(o, -r, n9e), a = h.clone(h.UNIT_Z, t9e); I.equalsEpsilon(Math.abs(h.dot(a, o)), 1, I.EPSILON8) && (a = h.clone(h.UNIT_Y, a)); let c = h.cross(a, o, e9e); a = h.cross(o, c, a), h.normalize(c, c), h.normalize(a, a); let u = o9e; Q.setColumn(u, 0, c, u), Q.setColumn(u, 1, a, u), Q.setColumn(u, 2, o, u); let f = h.fromElements(t.x, t.y, 1, i9e), d = Q.multiplyByScale(u, f, r9e), p = F.fromRotationTranslation(d, s, s9e); return F.multiplyTransformation(n, p, i) } Lu.createPrimitiveMatrix = W6; var hN = Lu; var a9e = new h, c9e = new Ge, l9e = new H, u9e = new H, f9e = new h, d9e = new h, h9e = new h, Ww = new h, m9e = new h, p9e = new h, Dse = new Be, _9e = new Q, g9e = new Q, y9e = new h; function A9e(e, t, n, i, o, r, s, a, c) { let u = e.positions, f = ni.triangulate(e.positions2D, e.holes); f.length < 3 && (f = [0, 1, 2]); let d = Me.createTypedArray(u.length, f.length); d.set(f); let p = _9e; if (i !== 0) { let _ = Be.fromAxisAngle(s, i, Dse); if (p = Q.fromQuaternion(_, p), t.tangent || t.bitangent) { _ = Be.fromAxisAngle(s, -i, Dse); let E = Q.fromQuaternion(_, g9e); a = h.normalize(Q.multiplyByVector(E, a, a), a), t.bitangent && (c = h.normalize(h.cross(s, a, c), c)) } } else p = Q.clone(Q.IDENTITY, p); let g = u9e; t.st && (g.x = n.x, g.y = n.y); let m = u.length, A = m * 3, C = new Float64Array(A), x = t.normal ? new Float32Array(A) : void 0, T = t.tangent ? new Float32Array(A) : void 0, b = t.bitangent ? new Float32Array(A) : void 0, S = t.st ? new Float32Array(m * 2) : void 0, D = 0, P = 0, B = 0, R = 0, M = 0; for (let _ = 0; _ < m; _++) { let E = u[_]; if (C[D++] = E.x, C[D++] = E.y, C[D++] = E.z, t.st) if (l(o) && o.positions.length === m) S[M++] = o.positions[_].x, S[M++] = o.positions[_].y; else { let w = Q.multiplyByVector(p, E, a9e), v = r(w, l9e); H.subtract(v, g, v); let O = I.clamp(v.x / n.width, 0, 1), V = I.clamp(v.y / n.height, 0, 1); S[M++] = O, S[M++] = V } t.normal && (x[P++] = s.x, x[P++] = s.y, x[P++] = s.z), t.tangent && (T[R++] = a.x, T[R++] = a.y, T[R++] = a.z), t.bitangent && (b[B++] = c.x, b[B++] = c.y, b[B++] = c.z) } let L = new sn; return t.position && (L.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: C })), t.normal && (L.normal = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: x })), t.tangent && (L.tangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: T })), t.bitangent && (L.bitangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: b })), t.st && (L.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: S })), new st({ attributes: L, indices: d, primitiveType: Oe.TRIANGLES }) } function wy(e) { e = y(e, y.EMPTY_OBJECT); let t = e.polygonHierarchy, n = e.textureCoordinates, i = y(e.vertexFormat, we.DEFAULT); this._vertexFormat = we.clone(i), this._polygonHierarchy = t, this._stRotation = y(e.stRotation, 0), this._ellipsoid = ie.clone(y(e.ellipsoid, ie.WGS84)), this._workerName = "createCoplanarPolygonGeometry", this._textureCoordinates = n, this.packedLength = Un.computeHierarchyPackedLength(t, h) + we.packedLength + ie.packedLength + (l(n) ? Un.computeHierarchyPackedLength(n, H) : 1) + 2 } wy.fromPositions = function (e) { e = y(e, y.EMPTY_OBJECT); let t = { polygonHierarchy: { positions: e.positions }, vertexFormat: e.vertexFormat, stRotation: e.stRotation, ellipsoid: e.ellipsoid, textureCoordinates: e.textureCoordinates }; return new wy(t) }; wy.pack = function (e, t, n) { return n = y(n, 0), n = Un.packPolygonHierarchy(e._polygonHierarchy, t, n, h), ie.pack(e._ellipsoid, t, n), n += ie.packedLength, we.pack(e._vertexFormat, t, n), n += we.packedLength, t[n++] = e._stRotation, l(e._textureCoordinates) ? n = Un.packPolygonHierarchy(e._textureCoordinates, t, n, H) : t[n++] = -1, t[n++] = e.packedLength, t }; var C9e = ie.clone(ie.UNIT_SPHERE), x9e = new we, T9e = { polygonHierarchy: {} }; wy.unpack = function (e, t, n) { t = y(t, 0); let i = Un.unpackPolygonHierarchy(e, t, h); t = i.startingIndex, delete i.startingIndex; let o = ie.unpack(e, t, C9e); t += ie.packedLength; let r = we.unpack(e, t, x9e); t += we.packedLength; let s = e[t++], a = e[t] === -1 ? void 0 : Un.unpackPolygonHierarchy(e, t, H); l(a) ? (t = a.startingIndex, delete a.startingIndex) : t++; let c = e[t++]; return l(n) || (n = new wy(T9e)), n._polygonHierarchy = i, n._ellipsoid = ie.clone(o, n._ellipsoid), n._vertexFormat = we.clone(r, n._vertexFormat), n._stRotation = s, n._textureCoordinates = a, n.packedLength = c, n }; wy.createGeometry = function (e) { let t = e._vertexFormat, n = e._polygonHierarchy, i = e._stRotation, o = e._textureCoordinates, r = l(o), s = n.positions; if (s = _o(s, h.equalsEpsilon, !0), s.length < 3) return; let a = f9e, c = d9e, u = h9e, f = m9e, d = p9e; if (!O_.computeProjectTo2DArguments(s, Ww, f, d)) return; if (a = h.cross(f, d, a), a = h.normalize(a, a), !h.equalsEpsilon(Ww, h.ZERO, I.EPSILON6)) { let M = e._ellipsoid.geodeticSurfaceNormal(Ww, y9e); h.dot(a, M) < 0 && (a = h.negate(a, a), f = h.negate(f, f)) } let g = O_.createProjectPointsTo2DFunction(Ww, f, d), m = O_.createProjectPointTo2DFunction(Ww, f, d); t.tangent && (c = h.clone(f, c)), t.bitangent && (u = h.clone(d, u)); let A = Un.polygonsFromHierarchy(n, r, g, !1), C = A.hierarchy, x = A.polygons, T = function (M) { return M }, b = r ? Un.polygonsFromHierarchy(o, !0, T, !1).polygons : void 0; if (C.length === 0) return; s = C[0].outerRing; let S = re.fromPoints(s), D = Un.computeBoundingRectangle(a, m, s, i, c9e), P = []; for (let M = 0; M < x.length; M++) { let L = new At({ geometry: A9e(x[M], t, D, i, r ? b[M] : void 0, m, a, c, u) }); P.push(L) } let B = Bn.combineInstances(P)[0]; B.attributes.position.values = new Float64Array(B.attributes.position.values), B.indices = Me.createTypedArray(B.attributes.position.values.length / 3, B.indices); let R = B.attributes; return t.position || delete R.position, new st({ attributes: R, indices: B.indices, primitiveType: B.primitiveType, boundingSphere: S }) }; var mN = wy; var E9e = new he, vse = new he; function b9e(e, t, n, i) { let r = i.cartesianToCartographic(e, E9e).height, s = i.cartesianToCartographic(t, vse); s.height = r, i.cartographicToCartesian(s, t); let a = i.cartesianToCartographic(n, vse); a.height = r - 100, i.cartographicToCartesian(a, n) } var S9e = new Ge, w9e = new h, D9e = new h, v9e = new h, P9e = new h, I9e = new h, O9e = new h, pN = new h, dh = new h, pT = new h, B9e = new H, R9e = new H, M9e = new h, Pse = new Be, L9e = new Q, F9e = new Q; function j6(e) { let t = e.vertexFormat, n = e.geometry, i = e.shadowVolume, o = n.attributes.position.values, r = l(n.attributes.st) ? n.attributes.st.values : void 0, s = o.length, a = e.wall, c = e.top || a, u = e.bottom || a; if (t.st || t.normal || t.tangent || t.bitangent || i) { let f = e.boundingRectangle, d = e.tangentPlane, p = e.ellipsoid, g = e.stRotation, m = e.perPositionHeight, A = B9e; A.x = f.x, A.y = f.y; let C = t.st ? new Float32Array(2 * (s / 3)) : void 0, x; t.normal && (m && c && !a ? x = n.attributes.normal.values : x = new Float32Array(s)); let T = t.tangent ? new Float32Array(s) : void 0, b = t.bitangent ? new Float32Array(s) : void 0, S = i ? new Float32Array(s) : void 0, D = 0, P = 0, B = D9e, R = v9e, M = P9e, L = !0, _ = L9e, E = F9e; if (g !== 0) { let O = Be.fromAxisAngle(d._plane.normal, g, Pse); _ = Q.fromQuaternion(O, _), O = Be.fromAxisAngle(d._plane.normal, -g, Pse), E = Q.fromQuaternion(O, E) } else _ = Q.clone(Q.IDENTITY, _), E = Q.clone(Q.IDENTITY, E); let w = 0, v = 0; c && u && (w = s / 2, v = s / 3, s /= 2); for (let O = 0; O < s; O += 3) { let V = h.fromArray(o, O, M9e); if (t.st && !l(r)) { let z = Q.multiplyByVector(_, V, w9e); z = p.scaleToGeodeticSurface(z, z); let k = d.projectPointOntoPlane(z, R9e); H.subtract(k, A, k); let G = I.clamp(k.x / f.width, 0, 1), N = I.clamp(k.y / f.height, 0, 1); u && (C[D + v] = G, C[D + 1 + v] = N), c && (C[D] = G, C[D + 1] = N), D += 2 } if (t.normal || t.tangent || t.bitangent || i) { let z = P + 1, k = P + 2; if (a) { if (O + 3 < s) { let G = h.fromArray(o, O + 3, I9e); if (L) { let N = h.fromArray(o, O + s, O9e); m && b9e(V, G, N, p), h.subtract(G, V, G), h.subtract(N, V, N), B = h.normalize(h.cross(N, G, B), B), L = !1 } h.equalsEpsilon(G, V, I.EPSILON10) && (L = !0) } (t.tangent || t.bitangent) && (M = p.geodeticSurfaceNormal(V, M), t.tangent && (R = h.normalize(h.cross(M, B, R), R))) } else B = p.geodeticSurfaceNormal(V, B), (t.tangent || t.bitangent) && (m && (pN = h.fromArray(x, P, pN), dh = h.cross(h.UNIT_Z, pN, dh), dh = h.normalize(Q.multiplyByVector(E, dh, dh), dh), t.bitangent && (pT = h.normalize(h.cross(pN, dh, pT), pT))), R = h.cross(h.UNIT_Z, B, R), R = h.normalize(Q.multiplyByVector(E, R, R), R), t.bitangent && (M = h.normalize(h.cross(B, R, M), M))); t.normal && (e.wall ? (x[P + w] = B.x, x[z + w] = B.y, x[k + w] = B.z) : u && (x[P + w] = -B.x, x[z + w] = -B.y, x[k + w] = -B.z), (c && !m || a) && (x[P] = B.x, x[z] = B.y, x[k] = B.z)), i && (a && (B = p.geodeticSurfaceNormal(V, B)), S[P + w] = -B.x, S[z + w] = -B.y, S[k + w] = -B.z), t.tangent && (e.wall ? (T[P + w] = R.x, T[z + w] = R.y, T[k + w] = R.z) : u && (T[P + w] = -R.x, T[z + w] = -R.y, T[k + w] = -R.z), c && (m ? (T[P] = dh.x, T[z] = dh.y, T[k] = dh.z) : (T[P] = R.x, T[z] = R.y, T[k] = R.z))), t.bitangent && (u && (b[P + w] = M.x, b[z + w] = M.y, b[k + w] = M.z), c && (m ? (b[P] = pT.x, b[z] = pT.y, b[k] = pT.z) : (b[P] = M.x, b[z] = M.y, b[k] = M.z))), P += 3 } } t.st && !l(r) && (n.attributes.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: C })), t.normal && (n.attributes.normal = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: x })), t.tangent && (n.attributes.tangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: T })), t.bitangent && (n.attributes.bitangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: b })), i && (n.attributes.extrudeDirection = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: S })) } if (e.extrude && l(e.offsetAttribute)) { let f = o.length / 3, d = new Uint8Array(f); if (e.offsetAttribute === Qt.TOP) c && u || a ? d = d.fill(1, 0, f / 2) : c && (d = d.fill(1)); else { let p = e.offsetAttribute === Qt.NONE ? 0 : 1; d = d.fill(p) } n.attributes.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: d }) } return n } var N9e = new he, V9e = new he, ng = { westOverIDL: 0, eastOverIDL: 0 }, _T = new mf; function Bse(e, t, n, i, o) { if (o = y(o, new ce), !l(e) || e.length < 3) return o.west = 0, o.north = 0, o.south = 0, o.east = 0, o; if (n === Yt.RHUMB) return ce.fromCartesianArray(e, t, o); _T.ellipsoid.equals(t) || (_T = new mf(void 0, void 0, t)), o.west = Number.POSITIVE_INFINITY, o.east = Number.NEGATIVE_INFINITY, o.south = Number.POSITIVE_INFINITY, o.north = Number.NEGATIVE_INFINITY, ng.westOverIDL = Number.POSITIVE_INFINITY, ng.eastOverIDL = Number.NEGATIVE_INFINITY; let r = 1 / I.chordLength(i, t.maximumRadius), s = e.length, a = t.cartesianToCartographic(e[0], V9e), c = N9e, u; for (let f = 1; f < s; f++)u = c, c = a, a = t.cartesianToCartographic(e[f], u), _T.setEndPoints(c, a), Ise(_T, r, o, ng); return u = c, c = a, a = t.cartesianToCartographic(e[0], u), _T.setEndPoints(c, a), Ise(_T, r, o, ng), o.east - o.west > ng.eastOverIDL - ng.westOverIDL && (o.west = ng.westOverIDL, o.east = ng.eastOverIDL, o.east > I.PI && (o.east = o.east - I.TWO_PI), o.west > I.PI && (o.west = o.west - I.TWO_PI)), o } var k9e = new he; function Ise(e, t, n, i) { let o = e.surfaceDistance, r = Math.ceil(o * t), s = r > 0 ? o / (r - 1) : Number.POSITIVE_INFINITY, a = 0; for (let c = 0; c < r; c++) { let u = e.interpolateUsingSurfaceDistance(a, k9e); a += s; let f = u.longitude, d = u.latitude; n.west = Math.min(n.west, f), n.east = Math.max(n.east, f), n.south = Math.min(n.south, d), n.north = Math.max(n.north, d); let p = f >= 0 ? f : f + I.TWO_PI; i.westOverIDL = Math.min(i.westOverIDL, p), i.eastOverIDL = Math.max(i.eastOverIDL, p) } } var Ose = []; function U9e(e, t, n, i, o, r, s, a, c, u) { let f = { walls: [] }, d; if (s || a) { let T = Un.createGeometryFromPositions(e, t, n, i, r, c, u), b = T.attributes.position.values, S = T.indices, D, P; if (s && a) { let B = b.concat(b); D = B.length / 3, P = Me.createTypedArray(D, S.length * 2), P.set(S); let R = S.length, M = D / 2; for (d = 0; d < R; d += 3) { let L = P[d] + M, _ = P[d + 1] + M, E = P[d + 2] + M; P[d + R] = E, P[d + 1 + R] = _, P[d + 2 + R] = L } if (T.attributes.position.values = B, r && c.normal) { let L = T.attributes.normal.values; T.attributes.normal.values = new Float32Array(B.length), T.attributes.normal.values.set(L) } if (c.st && l(n)) { let L = T.attributes.st.values; T.attributes.st.values = new Float32Array(D * 2), T.attributes.st.values = L.concat(L) } T.indices = P } else if (a) { for (D = b.length / 3, P = Me.createTypedArray(D, S.length), d = 0; d < S.length; d += 3)P[d] = S[d + 2], P[d + 1] = S[d + 1], P[d + 2] = S[d]; T.indices = P } f.topAndBottom = new At({ geometry: T }) } let p = o.outerRing, g = pa.fromPoints(p, e), m = g.projectPointsOntoPlane(p, Ose), A = ni.computeWindingOrder2D(m); A === Kr.CLOCKWISE && (p = p.slice().reverse()); let C = Un.computeWallGeometry(p, n, e, i, r, u); f.walls.push(new At({ geometry: C })); let x = o.holes; for (d = 0; d < x.length; d++) { let T = x[d]; g = pa.fromPoints(T, e), m = g.projectPointsOntoPlane(T, Ose), A = ni.computeWindingOrder2D(m), A === Kr.COUNTER_CLOCKWISE && (T = T.slice().reverse()), C = Un.computeWallGeometry(T, n, e, i, r, u), f.walls.push(new At({ geometry: C })) } return f } function zf(e) { let t = e.polygonHierarchy, n = y(e.vertexFormat, we.DEFAULT), i = y(e.ellipsoid, ie.WGS84), o = y(e.granularity, I.RADIANS_PER_DEGREE), r = y(e.stRotation, 0), s = e.textureCoordinates, a = y(e.perPositionHeight, !1), c = a && l(e.extrudedHeight), u = y(e.height, 0), f = y(e.extrudedHeight, u); if (!c) { let d = Math.max(u, f); f = Math.min(u, f), u = d } this._vertexFormat = we.clone(n), this._ellipsoid = ie.clone(i), this._granularity = o, this._stRotation = r, this._height = u, this._extrudedHeight = f, this._closeTop = y(e.closeTop, !0), this._closeBottom = y(e.closeBottom, !0), this._polygonHierarchy = t, this._perPositionHeight = a, this._perPositionHeightExtrude = c, this._shadowVolume = y(e.shadowVolume, !1), this._workerName = "createPolygonGeometry", this._offsetAttribute = e.offsetAttribute, this._arcType = y(e.arcType, Yt.GEODESIC), this._rectangle = void 0, this._textureCoordinateRotationPoints = void 0, this._textureCoordinates = s, this.packedLength = Un.computeHierarchyPackedLength(t, h) + ie.packedLength + we.packedLength + (s ? Un.computeHierarchyPackedLength(s, H) : 1) + 12 } zf.fromPositions = function (e) { e = y(e, y.EMPTY_OBJECT); let t = { polygonHierarchy: { positions: e.positions }, height: e.height, extrudedHeight: e.extrudedHeight, vertexFormat: e.vertexFormat, stRotation: e.stRotation, ellipsoid: e.ellipsoid, granularity: e.granularity, perPositionHeight: e.perPositionHeight, closeTop: e.closeTop, closeBottom: e.closeBottom, offsetAttribute: e.offsetAttribute, arcType: e.arcType, textureCoordinates: e.textureCoordinates }; return new zf(t) }; zf.pack = function (e, t, n) { return n = y(n, 0), n = Un.packPolygonHierarchy(e._polygonHierarchy, t, n, h), ie.pack(e._ellipsoid, t, n), n += ie.packedLength, we.pack(e._vertexFormat, t, n), n += we.packedLength, t[n++] = e._height, t[n++] = e._extrudedHeight, t[n++] = e._granularity, t[n++] = e._stRotation, t[n++] = e._perPositionHeightExtrude ? 1 : 0, t[n++] = e._perPositionHeight ? 1 : 0, t[n++] = e._closeTop ? 1 : 0, t[n++] = e._closeBottom ? 1 : 0, t[n++] = e._shadowVolume ? 1 : 0, t[n++] = y(e._offsetAttribute, -1), t[n++] = e._arcType, l(e._textureCoordinates) ? n = Un.packPolygonHierarchy(e._textureCoordinates, t, n, H) : t[n++] = -1, t[n++] = e.packedLength, t }; var z9e = ie.clone(ie.UNIT_SPHERE), H9e = new we, G9e = { polygonHierarchy: {} }; zf.unpack = function (e, t, n) { t = y(t, 0); let i = Un.unpackPolygonHierarchy(e, t, h); t = i.startingIndex, delete i.startingIndex; let o = ie.unpack(e, t, z9e); t += ie.packedLength; let r = we.unpack(e, t, H9e); t += we.packedLength; let s = e[t++], a = e[t++], c = e[t++], u = e[t++], f = e[t++] === 1, d = e[t++] === 1, p = e[t++] === 1, g = e[t++] === 1, m = e[t++] === 1, A = e[t++], C = e[t++], x = e[t] === -1 ? void 0 : Un.unpackPolygonHierarchy(e, t, H); l(x) ? (t = x.startingIndex, delete x.startingIndex) : t++; let T = e[t++]; return l(n) || (n = new zf(G9e)), n._polygonHierarchy = i, n._ellipsoid = ie.clone(o, n._ellipsoid), n._vertexFormat = we.clone(r, n._vertexFormat), n._height = s, n._extrudedHeight = a, n._granularity = c, n._stRotation = u, n._perPositionHeightExtrude = f, n._perPositionHeight = d, n._closeTop = p, n._closeBottom = g, n._shadowVolume = m, n._offsetAttribute = A === -1 ? void 0 : A, n._arcType = C, n._textureCoordinates = x, n.packedLength = T, n }; zf.computeRectangle = function (e, t) { let n = y(e.granularity, I.RADIANS_PER_DEGREE), i = y(e.arcType, Yt.GEODESIC), o = e.polygonHierarchy, r = y(e.ellipsoid, ie.WGS84); return Bse(o.positions, r, i, n, t) }; zf.createGeometry = function (e) { let t = e._vertexFormat, n = e._ellipsoid, i = e._granularity, o = e._stRotation, r = e._polygonHierarchy, s = e._perPositionHeight, a = e._closeTop, c = e._closeBottom, u = e._arcType, f = e._textureCoordinates, d = l(f), p = r.positions; if (p.length < 3) return; let g = pa.fromPoints(p, n), m = Un.polygonsFromHierarchy(r, d, g.projectPointsOntoPlane.bind(g), !s, n), A = m.hierarchy, C = m.polygons, x = function (w) { return w }, T = d ? Un.polygonsFromHierarchy(f, !0, x, !1).polygons : void 0; if (A.length === 0) return; p = A[0].outerRing; let b = Un.computeBoundingRectangle(g.plane.normal, g.projectPointOntoPlane.bind(g), p, o, S9e), S = [], D = e._height, P = e._extrudedHeight, B = e._perPositionHeightExtrude || !I.equalsEpsilon(D, P, 0, I.EPSILON2), R = { perPositionHeight: s, vertexFormat: t, geometry: void 0, tangentPlane: g, boundingRectangle: b, ellipsoid: n, stRotation: o, textureCoordinates: void 0, bottom: !1, top: !0, wall: !1, extrude: !1, arcType: u }, M; if (B) for (R.extrude = !0, R.top = a, R.bottom = c, R.shadowVolume = e._shadowVolume, R.offsetAttribute = e._offsetAttribute, M = 0; M < C.length; M++) { let w = U9e(n, C[M], d ? T[M] : void 0, i, A[M], s, a, c, t, u), v; a && c ? (v = w.topAndBottom, R.geometry = Un.scaleToGeodeticHeightExtruded(v.geometry, D, P, n, s)) : a ? (v = w.topAndBottom, v.geometry.attributes.position.values = ni.scaleToGeodeticHeight(v.geometry.attributes.position.values, D, n, !s), R.geometry = v.geometry) : c && (v = w.topAndBottom, v.geometry.attributes.position.values = ni.scaleToGeodeticHeight(v.geometry.attributes.position.values, P, n, !0), R.geometry = v.geometry), (a || c) && (R.wall = !1, v.geometry = j6(R), S.push(v)); let O = w.walls; R.wall = !0; for (let V = 0; V < O.length; V++) { let z = O[V]; R.geometry = Un.scaleToGeodeticHeightExtruded(z.geometry, D, P, n, s), z.geometry = j6(R), S.push(z) } } else for (M = 0; M < C.length; M++) { let w = new At({ geometry: Un.createGeometryFromPositions(n, C[M], d ? T[M] : void 0, i, s, t, u) }); if (w.geometry.attributes.position.values = ni.scaleToGeodeticHeight(w.geometry.attributes.position.values, D, n, !s), R.geometry = w.geometry, w.geometry = j6(R), l(e._offsetAttribute)) { let v = w.geometry.attributes.position.values.length, O = e._offsetAttribute === Qt.NONE ? 0 : 1, V = new Uint8Array(v / 3).fill(O); w.geometry.attributes.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: V }) } S.push(w) } let L = Bn.combineInstances(S)[0]; L.attributes.position.values = new Float64Array(L.attributes.position.values), L.indices = Me.createTypedArray(L.attributes.position.values.length / 3, L.indices); let _ = L.attributes, E = re.fromVertices(_.position.values); return t.position || delete _.position, new st({ attributes: _, indices: L.indices, primitiveType: L.primitiveType, boundingSphere: E, offsetAttribute: e._offsetAttribute }) }; zf.createShadowVolume = function (e, t, n) { let i = e._granularity, o = e._ellipsoid, r = t(i, o), s = n(i, o); return new zf({ polygonHierarchy: e._polygonHierarchy, ellipsoid: o, stRotation: e._stRotation, granularity: i, perPositionHeight: !1, extrudedHeight: r, height: s, vertexFormat: we.POSITION_ONLY, shadowVolume: !0, arcType: e._arcType }) }; function W9e(e) { let t = -e._stRotation; if (t === 0) return [0, 0, 0, 1, 1, 0]; let n = e._ellipsoid, i = e._polygonHierarchy.positions, o = e.rectangle; return st._textureCoordinateRotationPoints(i, t, n, o) } Object.defineProperties(zf.prototype, { rectangle: { get: function () { if (!l(this._rectangle)) { let e = this._polygonHierarchy.positions; this._rectangle = Bse(e, this._ellipsoid, this._arcType, this._granularity) } return this._rectangle } }, textureCoordinateRotationPoints: { get: function () { return l(this._textureCoordinateRotationPoints) || (this._textureCoordinateRotationPoints = W9e(this)), this._textureCoordinateRotationPoints } } }); var gT = zf; var Rse = [], _N = []; function j9e(e, t, n, i, o) { let s = pa.fromPoints(t, e).projectPointsOntoPlane(t, Rse); ni.computeWindingOrder2D(s) === Kr.CLOCKWISE && (s.reverse(), t = t.slice().reverse()); let c, u, f = t.length, d = 0; if (i) for (c = new Float64Array(f * 2 * 3), u = 0; u < f; u++) { let m = t[u], A = t[(u + 1) % f]; c[d++] = m.x, c[d++] = m.y, c[d++] = m.z, c[d++] = A.x, c[d++] = A.y, c[d++] = A.z } else { let m = 0; if (o === Yt.GEODESIC) for (u = 0; u < f; u++)m += Un.subdivideLineCount(t[u], t[(u + 1) % f], n); else if (o === Yt.RHUMB) for (u = 0; u < f; u++)m += Un.subdivideRhumbLineCount(e, t[u], t[(u + 1) % f], n); for (c = new Float64Array(m * 3), u = 0; u < f; u++) { let A; o === Yt.GEODESIC ? A = Un.subdivideLine(t[u], t[(u + 1) % f], n, _N) : o === Yt.RHUMB && (A = Un.subdivideRhumbLine(e, t[u], t[(u + 1) % f], n, _N)); let C = A.length; for (let x = 0; x < C; ++x)c[d++] = A[x] } } f = c.length / 3; let p = f * 2, g = Me.createTypedArray(f, p); for (d = 0, u = 0; u < f - 1; u++)g[d++] = u, g[d++] = u + 1; return g[d++] = f - 1, g[d++] = 0, new At({ geometry: new st({ attributes: new sn({ position: new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: c }) }), indices: g, primitiveType: Oe.LINES }) }) } function q9e(e, t, n, i, o) { let s = pa.fromPoints(t, e).projectPointsOntoPlane(t, Rse); ni.computeWindingOrder2D(s) === Kr.CLOCKWISE && (s.reverse(), t = t.slice().reverse()); let c, u, f = t.length, d = new Array(f), p = 0; if (i) for (c = new Float64Array(f * 2 * 3 * 2), u = 0; u < f; ++u) { d[u] = p / 3; let C = t[u], x = t[(u + 1) % f]; c[p++] = C.x, c[p++] = C.y, c[p++] = C.z, c[p++] = x.x, c[p++] = x.y, c[p++] = x.z } else { let C = 0; if (o === Yt.GEODESIC) for (u = 0; u < f; u++)C += Un.subdivideLineCount(t[u], t[(u + 1) % f], n); else if (o === Yt.RHUMB) for (u = 0; u < f; u++)C += Un.subdivideRhumbLineCount(e, t[u], t[(u + 1) % f], n); for (c = new Float64Array(C * 3 * 2), u = 0; u < f; ++u) { d[u] = p / 3; let x; o === Yt.GEODESIC ? x = Un.subdivideLine(t[u], t[(u + 1) % f], n, _N) : o === Yt.RHUMB && (x = Un.subdivideRhumbLine(e, t[u], t[(u + 1) % f], n, _N)); let T = x.length; for (let b = 0; b < T; ++b)c[p++] = x[b] } } f = c.length / (3 * 2); let g = d.length, m = (f * 2 + g) * 2, A = Me.createTypedArray(f + g, m); for (p = 0, u = 0; u < f; ++u)A[p++] = u, A[p++] = (u + 1) % f, A[p++] = u + f, A[p++] = (u + 1) % f + f; for (u = 0; u < g; u++) { let C = d[u]; A[p++] = C, A[p++] = C + f } return new At({ geometry: new st({ attributes: new sn({ position: new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: c }) }), indices: A, primitiveType: Oe.LINES }) }) } function Dy(e) { let t = e.polygonHierarchy, n = y(e.ellipsoid, ie.WGS84), i = y(e.granularity, I.RADIANS_PER_DEGREE), o = y(e.perPositionHeight, !1), r = o && l(e.extrudedHeight), s = y(e.arcType, Yt.GEODESIC), a = y(e.height, 0), c = y(e.extrudedHeight, a); if (!r) { let u = Math.max(a, c); c = Math.min(a, c), a = u } this._ellipsoid = ie.clone(n), this._granularity = i, this._height = a, this._extrudedHeight = c, this._arcType = s, this._polygonHierarchy = t, this._perPositionHeight = o, this._perPositionHeightExtrude = r, this._offsetAttribute = e.offsetAttribute, this._workerName = "createPolygonOutlineGeometry", this.packedLength = Un.computeHierarchyPackedLength(t, h) + ie.packedLength + 8 } Dy.pack = function (e, t, n) { return n = y(n, 0), n = Un.packPolygonHierarchy(e._polygonHierarchy, t, n, h), ie.pack(e._ellipsoid, t, n), n += ie.packedLength, t[n++] = e._height, t[n++] = e._extrudedHeight, t[n++] = e._granularity, t[n++] = e._perPositionHeightExtrude ? 1 : 0, t[n++] = e._perPositionHeight ? 1 : 0, t[n++] = e._arcType, t[n++] = y(e._offsetAttribute, -1), t[n] = e.packedLength, t }; var Y9e = ie.clone(ie.UNIT_SPHERE), X9e = { polygonHierarchy: {} }; Dy.unpack = function (e, t, n) { t = y(t, 0); let i = Un.unpackPolygonHierarchy(e, t, h); t = i.startingIndex, delete i.startingIndex; let o = ie.unpack(e, t, Y9e); t += ie.packedLength; let r = e[t++], s = e[t++], a = e[t++], c = e[t++] === 1, u = e[t++] === 1, f = e[t++], d = e[t++], p = e[t]; return l(n) || (n = new Dy(X9e)), n._polygonHierarchy = i, n._ellipsoid = ie.clone(o, n._ellipsoid), n._height = r, n._extrudedHeight = s, n._granularity = a, n._perPositionHeight = u, n._perPositionHeightExtrude = c, n._arcType = f, n._offsetAttribute = d === -1 ? void 0 : d, n.packedLength = p, n }; Dy.fromPositions = function (e) { e = y(e, y.EMPTY_OBJECT); let t = { polygonHierarchy: { positions: e.positions }, height: e.height, extrudedHeight: e.extrudedHeight, ellipsoid: e.ellipsoid, granularity: e.granularity, perPositionHeight: e.perPositionHeight, arcType: e.arcType, offsetAttribute: e.offsetAttribute }; return new Dy(t) }; Dy.createGeometry = function (e) { let t = e._ellipsoid, n = e._granularity, i = e._polygonHierarchy, o = e._perPositionHeight, r = e._arcType, s = Un.polygonOutlinesFromHierarchy(i, !o, t); if (s.length === 0) return; let a, c = [], u = I.chordLength(n, t.maximumRadius), f = e._height, d = e._extrudedHeight, p = e._perPositionHeightExtrude || !I.equalsEpsilon(f, d, 0, I.EPSILON2), g, m; if (p) for (m = 0; m < s.length; m++) { if (a = q9e(t, s[m], u, o, r), a.geometry = Un.scaleToGeodeticHeightExtruded(a.geometry, f, d, t, o), l(e._offsetAttribute)) { let x = a.geometry.attributes.position.values.length / 3, T = new Uint8Array(x); e._offsetAttribute === Qt.TOP ? T = T.fill(1, 0, x / 2) : (g = e._offsetAttribute === Qt.NONE ? 0 : 1, T = T.fill(g)), a.geometry.attributes.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: T }) } c.push(a) } else for (m = 0; m < s.length; m++) { if (a = j9e(t, s[m], u, o, r), a.geometry.attributes.position.values = ni.scaleToGeodeticHeight(a.geometry.attributes.position.values, f, t, !o), l(e._offsetAttribute)) { let x = a.geometry.attributes.position.values.length; g = e._offsetAttribute === Qt.NONE ? 0 : 1; let T = new Uint8Array(x / 3).fill(g); a.geometry.attributes.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: T }) } c.push(a) } let A = Bn.combineInstances(c)[0], C = re.fromVertices(A.attributes.position.values); return new st({ attributes: A.attributes, indices: A.indices, primitiveType: A.primitiveType, boundingSphere: C, offsetAttribute: e._offsetAttribute }) }; var gN = Dy; var Mse = "Entity polygons cannot have both height and perPositionHeight.  height will be ignored", Lse = "heightReference is not supported for entity polygons with perPositionHeight. heightReference will be ignored", Fse = new U, Nse = h.ZERO, Vse = new h, kse = new ce, K9e = [], J9e = new H; function Z9e(e) { this.id = e, this.vertexFormat = void 0, this.polygonHierarchy = void 0, this.perPositionHeight = void 0, this.closeTop = void 0, this.closeBottom = void 0, this.height = void 0, this.extrudedHeight = void 0, this.granularity = void 0, this.stRotation = void 0, this.offsetAttribute = void 0, this.arcType = void 0, this.textureCoordinates = void 0 } function Pl(e, t) { zn.call(this, { entity: e, scene: t, geometryOptions: new Z9e(e), geometryPropertyName: "polygon", observedPropertyNames: ["availability", "polygon"] }), this._onEntityPropertyChanged(e, "polygon", e.polygon, void 0) } l(Object.create) && (Pl.prototype = Object.create(zn.prototype), Pl.prototype.constructor = Pl); Pl.prototype.createFillGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = this._options, o = { show: new fn(n && t.isShowing && this._showProperty.getValue(e) && this._fillProperty.getValue(e)), distanceDisplayCondition: Mn.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(e)), offset: void 0, color: void 0 }; if (this._materialProperty instanceof Ot) { let s; l(this._materialProperty.color) && (this._materialProperty.color.isConstant || n) && (s = this._materialProperty.color.getValue(e, Fse)), l(s) || (s = U.WHITE), o.color = Bt.fromColor(s) } l(i.offsetAttribute) && (o.offset = zi.fromCartesian3(j.getValueOrDefault(this._terrainOffsetProperty, e, Nse, Vse))); let r; return i.perPositionHeight && !l(i.extrudedHeight) ? r = new mN(i) : r = new gT(i), new At({ id: t, geometry: r, attributes: o }) }; Pl.prototype.createOutlineGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = this._options, o = j.getValueOrDefault(this._outlineColorProperty, e, U.BLACK, Fse), r = this._distanceDisplayConditionProperty.getValue(e), s = { show: new fn(n && t.isShowing && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)), color: Bt.fromColor(o), distanceDisplayCondition: Mn.fromDistanceDisplayCondition(r), offset: void 0 }; l(i.offsetAttribute) && (s.offset = zi.fromCartesian3(j.getValueOrDefault(this._terrainOffsetProperty, e, Nse, Vse))); let a; return i.perPositionHeight && !l(i.extrudedHeight) ? a = new Rf(i) : a = new gN(i), new At({ id: t, geometry: a, attributes: s }) }; Pl.prototype._computeCenter = function (e, t) { let n = j.getValueOrUndefined(this._entity.polygon.hierarchy, e); if (!l(n)) return; let i = n.positions; if (i.length === 0) return; let o = this._scene.mapProjection.ellipsoid, r = pa.fromPoints(i, o), s = r.projectPointsOntoPlane(i, K9e), a = s.length, c = 0, u = a - 1, f = new H; for (let p = 0; p < a; u = p++) { let g = s[p], m = s[u], A = g.x * m.y - m.x * g.y, C = H.add(g, m, J9e); C = H.multiplyByScalar(C, A, C), f = H.add(f, C, f), c += A } let d = 1 / (c * 3); return f = H.multiplyByScalar(f, d, f), r.projectPointOntoEllipsoid(f, t) }; Pl.prototype._isHidden = function (e, t) { return !l(t.hierarchy) || ei.prototype._isHidden.call(this, e, t) }; Pl.prototype._isOnTerrain = function (e, t) { let n = zn.prototype._isOnTerrain.call(this, e, t), i = t.perPositionHeight, o = l(i) && (i.isConstant ? i.getValue(ke.MINIMUM_VALUE) : !0); return n && !o }; Pl.prototype._isDynamic = function (e, t) { return !t.hierarchy.isConstant || !j.isConstant(t.height) || !j.isConstant(t.extrudedHeight) || !j.isConstant(t.granularity) || !j.isConstant(t.stRotation) || !j.isConstant(t.textureCoordinates) || !j.isConstant(t.outlineWidth) || !j.isConstant(t.perPositionHeight) || !j.isConstant(t.closeTop) || !j.isConstant(t.closeBottom) || !j.isConstant(t.zIndex) || !j.isConstant(t.arcType) || this._onTerrain && !j.isConstant(this._materialProperty) && !(this._materialProperty instanceof Ot) }; Pl.prototype._setStaticOptions = function (e, t) { let n = this._materialProperty instanceof Ot, i = this._options; i.vertexFormat = n ? $t.VERTEX_FORMAT : eo.MaterialSupport.TEXTURED.vertexFormat; let o = t.hierarchy.getValue(ke.MINIMUM_VALUE), r = j.getValueOrUndefined(t.height, ke.MINIMUM_VALUE), s = j.getValueOrDefault(t.heightReference, ke.MINIMUM_VALUE, ze.NONE), a = j.getValueOrUndefined(t.extrudedHeight, ke.MINIMUM_VALUE), c = j.getValueOrDefault(t.extrudedHeightReference, ke.MINIMUM_VALUE, ze.NONE), u = j.getValueOrDefault(t.perPositionHeight, ke.MINIMUM_VALUE, !1); r = zn.getGeometryHeight(r, s); let f; u ? (l(r) && (r = void 0, Pt(Mse)), s !== ze.NONE && u && (r = void 0, Pt(Lse))) : (l(a) && !l(r) && (r = 0), f = zn.computeGeometryOffsetAttribute(r, s, a, c)), i.polygonHierarchy = o, i.granularity = j.getValueOrUndefined(t.granularity, ke.MINIMUM_VALUE), i.stRotation = j.getValueOrUndefined(t.stRotation, ke.MINIMUM_VALUE), i.perPositionHeight = u, i.closeTop = j.getValueOrDefault(t.closeTop, ke.MINIMUM_VALUE, !0), i.closeBottom = j.getValueOrDefault(t.closeBottom, ke.MINIMUM_VALUE, !0), i.offsetAttribute = f, i.height = r, i.arcType = j.getValueOrDefault(t.arcType, ke.MINIMUM_VALUE, Yt.GEODESIC), i.textureCoordinates = j.getValueOrUndefined(t.textureCoordinates, ke.MINIMUM_VALUE), a = zn.getGeometryExtrudedHeight(a, c), a === zn.CLAMP_TO_GROUND && (a = oi.getMinimumMaximumHeights(gT.computeRectangle(i, kse)).minimumTerrainHeight), i.extrudedHeight = a }; Pl.prototype._getIsClosed = function (e) { let t = e.height, n = e.extrudedHeight, i = l(n) && n !== t; return !e.perPositionHeight && (!i && t === 0 || i && e.closeTop && e.closeBottom) }; Pl.DynamicGeometryUpdater = yT; function yT(e, t, n) { $n.call(this, e, t, n) } l(Object.create) && (yT.prototype = Object.create($n.prototype), yT.prototype.constructor = yT); yT.prototype._isHidden = function (e, t, n) { return !l(this._options.polygonHierarchy) || $n.prototype._isHidden.call(this, e, t, n) }; yT.prototype._setOptions = function (e, t, n) { let i = this._options; i.polygonHierarchy = j.getValueOrUndefined(t.hierarchy, n); let o = j.getValueOrUndefined(t.height, n), r = j.getValueOrDefault(t.heightReference, n, ze.NONE), s = j.getValueOrDefault(t.extrudedHeightReference, n, ze.NONE), a = j.getValueOrUndefined(t.extrudedHeight, n), c = j.getValueOrUndefined(t.perPositionHeight, n); o = zn.getGeometryHeight(o, s); let u; c ? (l(o) && (o = void 0, Pt(Mse)), r !== ze.NONE && c && (o = void 0, Pt(Lse))) : (l(a) && !l(o) && (o = 0), u = zn.computeGeometryOffsetAttribute(o, r, a, s)), i.granularity = j.getValueOrUndefined(t.granularity, n), i.stRotation = j.getValueOrUndefined(t.stRotation, n), i.textureCoordinates = j.getValueOrUndefined(t.textureCoordinates, n), i.perPositionHeight = j.getValueOrUndefined(t.perPositionHeight, n), i.closeTop = j.getValueOrDefault(t.closeTop, n, !0), i.closeBottom = j.getValueOrDefault(t.closeBottom, n, !0), i.offsetAttribute = u, i.height = o, i.arcType = j.getValueOrDefault(t.arcType, n, Yt.GEODESIC), a = zn.getGeometryExtrudedHeight(a, s), a === zn.CLAMP_TO_GROUND && (a = oi.getMinimumMaximumHeights(gT.computeRectangle(i, kse)).minimumTerrainHeight), i.extrudedHeight = a }; var yN = Pl; function Q9e(e, t, n, i) { let o = new sn; i.position && (o.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: e })); let r = t.length, s = e.length / 3, a = (s - r * 2) / (r * 2), c = ni.triangulate(t), u = (a - 1) * r * 6 + c.length * 2, f = Me.createTypedArray(s, u), d, p, g, m, A, C, x = r * 2, T = 0; for (d = 0; d < a - 1; d++) { for (p = 0; p < r - 1; p++)g = p * 2 + d * r * 2, C = g + x, m = g + 1, A = m + x, f[T++] = m, f[T++] = g, f[T++] = A, f[T++] = A, f[T++] = g, f[T++] = C; g = r * 2 - 2 + d * r * 2, m = g + 1, A = m + x, C = g + x, f[T++] = m, f[T++] = g, f[T++] = A, f[T++] = A, f[T++] = g, f[T++] = C } if (i.st || i.tangent || i.bitangent) { let D = new Float32Array(s * 2), P = 1 / (a - 1), B = 1 / n.height, R = n.height / 2, M, L, _ = 0; for (d = 0; d < a; d++) { for (M = d * P, L = B * (t[0].y + R), D[_++] = M, D[_++] = L, p = 1; p < r; p++)L = B * (t[p].y + R), D[_++] = M, D[_++] = L, D[_++] = M, D[_++] = L; L = B * (t[0].y + R), D[_++] = M, D[_++] = L } for (p = 0; p < r; p++)M = 0, L = B * (t[p].y + R), D[_++] = M, D[_++] = L; for (p = 0; p < r; p++)M = (a - 1) * P, L = B * (t[p].y + R), D[_++] = M, D[_++] = L; o.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: new Float32Array(D) }) } let b = s - r * 2; for (d = 0; d < c.length; d += 3) { let D = c[d] + b, P = c[d + 1] + b, B = c[d + 2] + b; f[T++] = D, f[T++] = P, f[T++] = B, f[T++] = B + r, f[T++] = P + r, f[T++] = D + r } let S = new st({ attributes: o, indices: f, boundingSphere: re.fromVertices(e), primitiveType: Oe.TRIANGLES }); if (i.normal && (S = Bn.computeNormal(S)), i.tangent || i.bitangent) { try { S = Bn.computeTangentAndBitangent(S) } catch { Pt("polyline-volume-tangent-bitangent", "Unable to compute tangents and bitangents for polyline volume geometry") } i.tangent || (S.attributes.tangent = void 0), i.bitangent || (S.attributes.bitangent = void 0), i.st || (S.attributes.st = void 0) } return S } function qw(e) { e = y(e, y.EMPTY_OBJECT); let t = e.polylinePositions, n = e.shapePositions; this._positions = t, this._shape = n, this._ellipsoid = ie.clone(y(e.ellipsoid, ie.WGS84)), this._cornerType = y(e.cornerType, Ti.ROUNDED), this._vertexFormat = we.clone(y(e.vertexFormat, we.DEFAULT)), this._granularity = y(e.granularity, I.RADIANS_PER_DEGREE), this._workerName = "createPolylineVolumeGeometry"; let i = 1 + t.length * h.packedLength; i += 1 + n.length * H.packedLength, this.packedLength = i + ie.packedLength + we.packedLength + 2 } qw.pack = function (e, t, n) { n = y(n, 0); let i, o = e._positions, r = o.length; for (t[n++] = r, i = 0; i < r; ++i, n += h.packedLength)h.pack(o[i], t, n); let s = e._shape; for (r = s.length, t[n++] = r, i = 0; i < r; ++i, n += H.packedLength)H.pack(s[i], t, n); return ie.pack(e._ellipsoid, t, n), n += ie.packedLength, we.pack(e._vertexFormat, t, n), n += we.packedLength, t[n++] = e._cornerType, t[n] = e._granularity, t }; var Use = ie.clone(ie.UNIT_SPHERE), zse = new we, jw = { polylinePositions: void 0, shapePositions: void 0, ellipsoid: Use, vertexFormat: zse, cornerType: void 0, granularity: void 0 }; qw.unpack = function (e, t, n) { t = y(t, 0); let i, o = e[t++], r = new Array(o); for (i = 0; i < o; ++i, t += h.packedLength)r[i] = h.unpack(e, t); o = e[t++]; let s = new Array(o); for (i = 0; i < o; ++i, t += H.packedLength)s[i] = H.unpack(e, t); let a = ie.unpack(e, t, Use); t += ie.packedLength; let c = we.unpack(e, t, zse); t += we.packedLength; let u = e[t++], f = e[t]; return l(n) ? (n._positions = r, n._shape = s, n._ellipsoid = ie.clone(a, n._ellipsoid), n._vertexFormat = we.clone(c, n._vertexFormat), n._cornerType = u, n._granularity = f, n) : (jw.polylinePositions = r, jw.shapePositions = s, jw.cornerType = u, jw.granularity = f, new qw(jw)) }; var $9e = new Ge; qw.createGeometry = function (e) { let t = e._positions, n = _o(t, h.equalsEpsilon), i = e._shape; if (i = oh.removeDuplicatesFromShape(i), n.length < 2 || i.length < 3) return; ni.computeWindingOrder2D(i) === Kr.CLOCKWISE && i.reverse(); let o = Ge.fromPoints(i, $9e), r = oh.computePositions(n, i, o, e, !0); return Q9e(r, i, o, e._vertexFormat) }; var AN = qw; function eWe(e, t) { let n = new sn; n.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: e }); let i = t.length, o = n.position.values.length / 3, s = e.length / 3 / i, a = Me.createTypedArray(o, 2 * i * (s + 1)), c, u, f = 0; c = 0; let d = c * i; for (u = 0; u < i - 1; u++)a[f++] = u + d, a[f++] = u + d + 1; for (a[f++] = i - 1 + d, a[f++] = d, c = s - 1, d = c * i, u = 0; u < i - 1; u++)a[f++] = u + d, a[f++] = u + d + 1; for (a[f++] = i - 1 + d, a[f++] = d, c = 0; c < s - 1; c++) { let g = i * c, m = g + i; for (u = 0; u < i; u++)a[f++] = u + g, a[f++] = u + m } return new st({ attributes: n, indices: Me.createTypedArray(o, a), boundingSphere: re.fromVertices(e), primitiveType: Oe.LINES }) } function Xw(e) { e = y(e, y.EMPTY_OBJECT); let t = e.polylinePositions, n = e.shapePositions; this._positions = t, this._shape = n, this._ellipsoid = ie.clone(y(e.ellipsoid, ie.WGS84)), this._cornerType = y(e.cornerType, Ti.ROUNDED), this._granularity = y(e.granularity, I.RADIANS_PER_DEGREE), this._workerName = "createPolylineVolumeOutlineGeometry"; let i = 1 + t.length * h.packedLength; i += 1 + n.length * H.packedLength, this.packedLength = i + ie.packedLength + 2 } Xw.pack = function (e, t, n) { n = y(n, 0); let i, o = e._positions, r = o.length; for (t[n++] = r, i = 0; i < r; ++i, n += h.packedLength)h.pack(o[i], t, n); let s = e._shape; for (r = s.length, t[n++] = r, i = 0; i < r; ++i, n += H.packedLength)H.pack(s[i], t, n); return ie.pack(e._ellipsoid, t, n), n += ie.packedLength, t[n++] = e._cornerType, t[n] = e._granularity, t }; var Hse = ie.clone(ie.UNIT_SPHERE), Yw = { polylinePositions: void 0, shapePositions: void 0, ellipsoid: Hse, height: void 0, cornerType: void 0, granularity: void 0 }; Xw.unpack = function (e, t, n) { t = y(t, 0); let i, o = e[t++], r = new Array(o); for (i = 0; i < o; ++i, t += h.packedLength)r[i] = h.unpack(e, t); o = e[t++]; let s = new Array(o); for (i = 0; i < o; ++i, t += H.packedLength)s[i] = H.unpack(e, t); let a = ie.unpack(e, t, Hse); t += ie.packedLength; let c = e[t++], u = e[t]; return l(n) ? (n._positions = r, n._shape = s, n._ellipsoid = ie.clone(a, n._ellipsoid), n._cornerType = c, n._granularity = u, n) : (Yw.polylinePositions = r, Yw.shapePositions = s, Yw.cornerType = c, Yw.granularity = u, new Xw(Yw)) }; var tWe = new Ge; Xw.createGeometry = function (e) { let t = e._positions, n = _o(t, h.equalsEpsilon), i = e._shape; if (i = oh.removeDuplicatesFromShape(i), n.length < 2 || i.length < 3) return; ni.computeWindingOrder2D(i) === Kr.CLOCKWISE && i.reverse(); let o = Ge.fromPoints(i, tWe), r = oh.computePositions(n, i, o, e, !1); return eWe(r, i) }; var CN = Xw; var Gse = new U; function nWe(e) { this.id = e, this.vertexFormat = void 0, this.polylinePositions = void 0, this.shapePositions = void 0, this.cornerType = void 0, this.granularity = void 0 } function hh(e, t) { ei.call(this, { entity: e, scene: t, geometryOptions: new nWe(e), geometryPropertyName: "polylineVolume", observedPropertyNames: ["availability", "polylineVolume"] }), this._onEntityPropertyChanged(e, "polylineVolume", e.polylineVolume, void 0) } l(Object.create) && (hh.prototype = Object.create(ei.prototype), hh.prototype.constructor = hh); hh.prototype.createFillGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i, o, r = new fn(n && t.isShowing && this._showProperty.getValue(e) && this._fillProperty.getValue(e)), s = this._distanceDisplayConditionProperty.getValue(e), a = Mn.fromDistanceDisplayCondition(s); if (this._materialProperty instanceof Ot) { let c; l(this._materialProperty.color) && (this._materialProperty.color.isConstant || n) && (c = this._materialProperty.color.getValue(e, Gse)), l(c) || (c = U.WHITE), o = Bt.fromColor(c), i = { show: r, distanceDisplayCondition: a, color: o } } else i = { show: r, distanceDisplayCondition: a }; return new At({ id: t, geometry: new AN(this._options), attributes: i }) }; hh.prototype.createOutlineGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = j.getValueOrDefault(this._outlineColorProperty, e, U.BLACK, Gse), o = this._distanceDisplayConditionProperty.getValue(e); return new At({ id: t, geometry: new CN(this._options), attributes: { show: new fn(n && t.isShowing && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)), color: Bt.fromColor(i), distanceDisplayCondition: Mn.fromDistanceDisplayCondition(o) } }) }; hh.prototype._isHidden = function (e, t) { return !l(t.positions) || !l(t.shape) || ei.prototype._isHidden.call(this, e, t) }; hh.prototype._isDynamic = function (e, t) { return !t.positions.isConstant || !t.shape.isConstant || !j.isConstant(t.granularity) || !j.isConstant(t.outlineWidth) || !j.isConstant(t.cornerType) }; hh.prototype._setStaticOptions = function (e, t) { let n = t.granularity, i = t.cornerType, o = this._options, r = this._materialProperty instanceof Ot; o.vertexFormat = r ? $t.VERTEX_FORMAT : eo.MaterialSupport.TEXTURED.vertexFormat, o.polylinePositions = t.positions.getValue(ke.MINIMUM_VALUE, o.polylinePositions), o.shapePositions = t.shape.getValue(ke.MINIMUM_VALUE, o.shape), o.granularity = l(n) ? n.getValue(ke.MINIMUM_VALUE) : void 0, o.cornerType = l(i) ? i.getValue(ke.MINIMUM_VALUE) : void 0 }; hh.DynamicGeometryUpdater = AT; function AT(e, t, n) { $n.call(this, e, t, n) } l(Object.create) && (AT.prototype = Object.create($n.prototype), AT.prototype.constructor = AT); AT.prototype._isHidden = function (e, t, n) { let i = this._options; return !l(i.polylinePositions) || !l(i.shapePositions) || $n.prototype._isHidden.call(this, e, t, n) }; AT.prototype._setOptions = function (e, t, n) { let i = this._options; i.polylinePositions = j.getValueOrUndefined(t.positions, n, i.polylinePositions), i.shapePositions = j.getValueOrUndefined(t.shape, n), i.granularity = j.getValueOrUndefined(t.granularity, n), i.cornerType = j.getValueOrUndefined(t.cornerType, n) }; var xN = hh; var q6 = new h, qse = new h, Yse = new h, Xse = new h, Kse = new ce, iWe = new H, oWe = new re, rWe = new re; function Jse(e, t) { let n = new st({ attributes: new sn, primitiveType: Oe.TRIANGLES }); return n.attributes.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: t.positions }), e.normal && (n.attributes.normal = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: t.normals })), e.tangent && (n.attributes.tangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: t.tangents })), e.bitangent && (n.attributes.bitangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: t.bitangents })), n } function sWe(e, t, n, i) { let o = e.length, r = t.normal ? new Float32Array(o) : void 0, s = t.tangent ? new Float32Array(o) : void 0, a = t.bitangent ? new Float32Array(o) : void 0, c = 0, u = Xse, f = Yse, d = qse; if (t.normal || t.tangent || t.bitangent) for (let p = 0; p < o; p += 3) { let g = h.fromArray(e, p, q6), m = c + 1, A = c + 2; d = n.geodeticSurfaceNormal(g, d), (t.tangent || t.bitangent) && (h.cross(h.UNIT_Z, d, f), Q.multiplyByVector(i, f, f), h.normalize(f, f), t.bitangent && h.normalize(h.cross(d, f, u), u)), t.normal && (r[c] = d.x, r[m] = d.y, r[A] = d.z), t.tangent && (s[c] = f.x, s[m] = f.y, s[A] = f.z), t.bitangent && (a[c] = u.x, a[m] = u.y, a[A] = u.z), c += 3 } return Jse(t, { positions: e, normals: r, tangents: s, bitangents: a }) } var Y6 = new h, Zse = new h; function aWe(e, t, n) { let i = e.length, o = t.normal ? new Float32Array(i) : void 0, r = t.tangent ? new Float32Array(i) : void 0, s = t.bitangent ? new Float32Array(i) : void 0, a = 0, c = 0, u = 0, f = !0, d = Xse, p = Yse, g = qse; if (t.normal || t.tangent || t.bitangent) for (let m = 0; m < i; m += 6) { let A = h.fromArray(e, m, q6), C = h.fromArray(e, (m + 6) % i, Y6); if (f) { let x = h.fromArray(e, (m + 3) % i, Zse); h.subtract(C, A, C), h.subtract(x, A, x), g = h.normalize(h.cross(x, C, g), g), f = !1 } h.equalsEpsilon(C, A, I.EPSILON10) && (f = !0), (t.tangent || t.bitangent) && (d = n.geodeticSurfaceNormal(A, d), t.tangent && (p = h.normalize(h.cross(d, g, p), p))), t.normal && (o[a++] = g.x, o[a++] = g.y, o[a++] = g.z, o[a++] = g.x, o[a++] = g.y, o[a++] = g.z), t.tangent && (r[c++] = p.x, r[c++] = p.y, r[c++] = p.z, r[c++] = p.x, r[c++] = p.y, r[c++] = p.z), t.bitangent && (s[u++] = d.x, s[u++] = d.y, s[u++] = d.z, s[u++] = d.x, s[u++] = d.y, s[u++] = d.z) } return Jse(t, { positions: e, normals: o, tangents: r, bitangents: s }) } function Qse(e, t) { let n = e._vertexFormat, i = e._ellipsoid, o = t.height, r = t.width, s = t.northCap, a = t.southCap, c = 0, u = o, f = o, d = 0; s && (c = 1, f -= 1, d += 1), a && (u -= 1, f -= 1, d += 1), d += r * f; let p = n.position ? new Float64Array(d * 3) : void 0, g = n.st ? new Float32Array(d * 2) : void 0, m = 0, A = 0, C = q6, x = iWe, T = Number.MAX_VALUE, b = Number.MAX_VALUE, S = -Number.MAX_VALUE, D = -Number.MAX_VALUE; for (let E = c; E < u; ++E)for (let w = 0; w < r; ++w)ms.computePosition(t, i, n.st, E, w, C, x), p[m++] = C.x, p[m++] = C.y, p[m++] = C.z, n.st && (g[A++] = x.x, g[A++] = x.y, T = Math.min(T, x.x), b = Math.min(b, x.y), S = Math.max(S, x.x), D = Math.max(D, x.y)); if (s && (ms.computePosition(t, i, n.st, 0, 0, C, x), p[m++] = C.x, p[m++] = C.y, p[m++] = C.z, n.st && (g[A++] = x.x, g[A++] = x.y, T = x.x, b = x.y, S = x.x, D = x.y)), a && (ms.computePosition(t, i, n.st, o - 1, 0, C, x), p[m++] = C.x, p[m++] = C.y, p[m] = C.z, n.st && (g[A++] = x.x, g[A] = x.y, T = Math.min(T, x.x), b = Math.min(b, x.y), S = Math.max(S, x.x), D = Math.max(D, x.y))), n.st && (T < 0 || b < 0 || S > 1 || D > 1)) for (let E = 0; E < g.length; E += 2)g[E] = (g[E] - T) / (S - T), g[E + 1] = (g[E + 1] - b) / (D - b); let P = sWe(p, n, i, t.tangentRotationMatrix), B = 6 * (r - 1) * (f - 1); s && (B += 3 * (r - 1)), a && (B += 3 * (r - 1)); let R = Me.createTypedArray(d, B), M = 0, L = 0, _; for (_ = 0; _ < f - 1; ++_) { for (let E = 0; E < r - 1; ++E) { let w = M, v = w + r, O = v + 1, V = w + 1; R[L++] = w, R[L++] = v, R[L++] = V, R[L++] = V, R[L++] = v, R[L++] = O, ++M } ++M } if (s || a) { let E = d - 1, w = d - 1; s && a && (E = d - 2); let v, O; if (M = 0, s) for (_ = 0; _ < r - 1; _++)v = M, O = v + 1, R[L++] = E, R[L++] = v, R[L++] = O, ++M; if (a) for (M = (f - 1) * r, _ = 0; _ < r - 1; _++)v = M, O = v + 1, R[L++] = v, R[L++] = w, R[L++] = O, ++M } return P.indices = R, n.st && (P.attributes.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: g })), P } function CT(e, t, n, i, o) { return e[t++] = i[n], e[t++] = i[n + 1], e[t++] = i[n + 2], e[t++] = o[n], e[t++] = o[n + 1], e[t] = o[n + 2], e } function xT(e, t, n, i) { return e[t++] = i[n], e[t++] = i[n + 1], e[t++] = i[n], e[t] = i[n + 1], e } var X6 = new we; function cWe(e, t) { let n = e._shadowVolume, i = e._offsetAttribute, o = e._vertexFormat, r = e._extrudedHeight, s = e._surfaceHeight, a = e._ellipsoid, c = t.height, u = t.width, f; if (n) { let _t = we.clone(o, X6); _t.normal = !0, e._vertexFormat = _t } let d = Qse(e, t); n && (e._vertexFormat = o); let p = ni.scaleToGeodeticHeight(d.attributes.position.values, s, a, !1); p = new Float64Array(p); let g = p.length, m = g * 2, A = new Float64Array(m); A.set(p); let C = ni.scaleToGeodeticHeight(d.attributes.position.values, r, a); A.set(C, g), d.attributes.position.values = A; let x = o.normal ? new Float32Array(m) : void 0, T = o.tangent ? new Float32Array(m) : void 0, b = o.bitangent ? new Float32Array(m) : void 0, S = o.st ? new Float32Array(m / 3 * 2) : void 0, D, P; if (o.normal) { for (P = d.attributes.normal.values, x.set(P), f = 0; f < g; f++)P[f] = -P[f]; x.set(P, g), d.attributes.normal.values = x } if (n) { P = d.attributes.normal.values, o.normal || (d.attributes.normal = void 0); let _t = new Float32Array(m); for (f = 0; f < g; f++)P[f] = -P[f]; _t.set(P, g), d.attributes.extrudeDirection = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: _t }) } let B, R = l(i); if (R) { let _t = g / 3 * 2, Pn = new Uint8Array(_t); i === Qt.TOP ? Pn = Pn.fill(1, 0, _t / 2) : (B = i === Qt.NONE ? 0 : 1, Pn = Pn.fill(B)), d.attributes.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: Pn }) } if (o.tangent) { let _t = d.attributes.tangent.values; for (T.set(_t), f = 0; f < g; f++)_t[f] = -_t[f]; T.set(_t, g), d.attributes.tangent.values = T } if (o.bitangent) { let _t = d.attributes.bitangent.values; b.set(_t), b.set(_t, g), d.attributes.bitangent.values = b } o.st && (D = d.attributes.st.values, S.set(D), S.set(D, g / 3 * 2), d.attributes.st.values = S); let M = d.indices, L = M.length, _ = g / 3, E = Me.createTypedArray(m / 3, L * 2); for (E.set(M), f = 0; f < L; f += 3)E[f + L] = M[f + 2] + _, E[f + 1 + L] = M[f + 1] + _, E[f + 2 + L] = M[f] + _; d.indices = E; let w = t.northCap, v = t.southCap, O = c, V = 2, z = 0, k = 4, G = 4; w && (V -= 1, O -= 1, z += 1, k -= 2, G -= 1), v && (V -= 1, O -= 1, z += 1, k -= 2, G -= 1), z += V * u + 2 * O - k; let N = (z + G) * 2, X = new Float64Array(N * 3), q = n ? new Float32Array(N * 3) : void 0, J = R ? new Uint8Array(N) : void 0, W = o.st ? new Float32Array(N * 2) : void 0, K = i === Qt.TOP; R && !K && (B = i === Qt.ALL ? 1 : 0, J = J.fill(B)); let Z = 0, de = 0, pe = 0, oe = 0, ue = u * O, ge; for (f = 0; f < ue; f += u)ge = f * 3, X = CT(X, Z, ge, p, C), Z += 6, o.st && (W = xT(W, de, f * 2, D), de += 4), n && (pe += 3, q[pe++] = P[ge], q[pe++] = P[ge + 1], q[pe++] = P[ge + 2]), K && (J[oe++] = 1, oe += 1); if (v) { let _t = w ? ue + 1 : ue; for (ge = _t * 3, f = 0; f < 2; f++)X = CT(X, Z, ge, p, C), Z += 6, o.st && (W = xT(W, de, _t * 2, D), de += 4), n && (pe += 3, q[pe++] = P[ge], q[pe++] = P[ge + 1], q[pe++] = P[ge + 2]), K && (J[oe++] = 1, oe += 1) } else for (f = ue - u; f < ue; f++)ge = f * 3, X = CT(X, Z, ge, p, C), Z += 6, o.st && (W = xT(W, de, f * 2, D), de += 4), n && (pe += 3, q[pe++] = P[ge], q[pe++] = P[ge + 1], q[pe++] = P[ge + 2]), K && (J[oe++] = 1, oe += 1); for (f = ue - 1; f > 0; f -= u)ge = f * 3, X = CT(X, Z, ge, p, C), Z += 6, o.st && (W = xT(W, de, f * 2, D), de += 4), n && (pe += 3, q[pe++] = P[ge], q[pe++] = P[ge + 1], q[pe++] = P[ge + 2]), K && (J[oe++] = 1, oe += 1); if (w) { let _t = ue; for (ge = _t * 3, f = 0; f < 2; f++)X = CT(X, Z, ge, p, C), Z += 6, o.st && (W = xT(W, de, _t * 2, D), de += 4), n && (pe += 3, q[pe++] = P[ge], q[pe++] = P[ge + 1], q[pe++] = P[ge + 2]), K && (J[oe++] = 1, oe += 1) } else for (f = u - 1; f >= 0; f--)ge = f * 3, X = CT(X, Z, ge, p, C), Z += 6, o.st && (W = xT(W, de, f * 2, D), de += 4), n && (pe += 3, q[pe++] = P[ge], q[pe++] = P[ge + 1], q[pe++] = P[ge + 2]), K && (J[oe++] = 1, oe += 1); let Ee = aWe(X, o, a); o.st && (Ee.attributes.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: W })), n && (Ee.attributes.extrudeDirection = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: q })), R && (Ee.attributes.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: J })); let Ie = Me.createTypedArray(N, z * 6), Fe, We, Lt, Gt; g = X.length / 3; let cn = 0; for (f = 0; f < g - 1; f += 2) { Fe = f, Gt = (Fe + 2) % g; let _t = h.fromArray(X, Fe * 3, Y6), Pn = h.fromArray(X, Gt * 3, Zse); h.equalsEpsilon(_t, Pn, I.EPSILON10) || (We = (Fe + 1) % g, Lt = (We + 2) % g, Ie[cn++] = Fe, Ie[cn++] = We, Ie[cn++] = Gt, Ie[cn++] = Gt, Ie[cn++] = We, Ie[cn++] = Lt) } return Ee.indices = Ie, Ee = Bn.combineInstances([new At({ geometry: d }), new At({ geometry: Ee })]), Ee[0] } var lWe = [new h, new h, new h, new h], $se = new he, uWe = new he; function K6(e, t, n, i, o) { if (n === 0) return ce.clone(e, o); let r = ms.computeOptions(e, t, n, 0, Kse, $se), s = r.height, a = r.width, c = lWe; return ms.computePosition(r, i, !1, 0, 0, c[0]), ms.computePosition(r, i, !1, 0, a - 1, c[1]), ms.computePosition(r, i, !1, s - 1, 0, c[2]), ms.computePosition(r, i, !1, s - 1, a - 1, c[3]), ce.fromCartesianArray(c, i, o) } function mh(e) { e = y(e, y.EMPTY_OBJECT); let t = e.rectangle, n = y(e.height, 0), i = y(e.extrudedHeight, n); this._rectangle = ce.clone(t), this._granularity = y(e.granularity, I.RADIANS_PER_DEGREE), this._ellipsoid = ie.clone(y(e.ellipsoid, ie.WGS84)), this._surfaceHeight = Math.max(n, i), this._rotation = y(e.rotation, 0), this._stRotation = y(e.stRotation, 0), this._vertexFormat = we.clone(y(e.vertexFormat, we.DEFAULT)), this._extrudedHeight = Math.min(n, i), this._shadowVolume = y(e.shadowVolume, !1), this._workerName = "createRectangleGeometry", this._offsetAttribute = e.offsetAttribute, this._rotatedRectangle = void 0, this._textureCoordinateRotationPoints = void 0 } mh.packedLength = ce.packedLength + ie.packedLength + we.packedLength + 7; mh.pack = function (e, t, n) { return n = y(n, 0), ce.pack(e._rectangle, t, n), n += ce.packedLength, ie.pack(e._ellipsoid, t, n), n += ie.packedLength, we.pack(e._vertexFormat, t, n), n += we.packedLength, t[n++] = e._granularity, t[n++] = e._surfaceHeight, t[n++] = e._rotation, t[n++] = e._stRotation, t[n++] = e._extrudedHeight, t[n++] = e._shadowVolume ? 1 : 0, t[n] = y(e._offsetAttribute, -1), t }; var eae = new ce, tae = ie.clone(ie.UNIT_SPHERE), ig = { rectangle: eae, ellipsoid: tae, vertexFormat: X6, granularity: void 0, height: void 0, rotation: void 0, stRotation: void 0, extrudedHeight: void 0, shadowVolume: void 0, offsetAttribute: void 0 }; mh.unpack = function (e, t, n) { t = y(t, 0); let i = ce.unpack(e, t, eae); t += ce.packedLength; let o = ie.unpack(e, t, tae); t += ie.packedLength; let r = we.unpack(e, t, X6); t += we.packedLength; let s = e[t++], a = e[t++], c = e[t++], u = e[t++], f = e[t++], d = e[t++] === 1, p = e[t]; return l(n) ? (n._rectangle = ce.clone(i, n._rectangle), n._ellipsoid = ie.clone(o, n._ellipsoid), n._vertexFormat = we.clone(r, n._vertexFormat), n._granularity = s, n._surfaceHeight = a, n._rotation = c, n._stRotation = u, n._extrudedHeight = f, n._shadowVolume = d, n._offsetAttribute = p === -1 ? void 0 : p, n) : (ig.granularity = s, ig.height = a, ig.rotation = c, ig.stRotation = u, ig.extrudedHeight = f, ig.shadowVolume = d, ig.offsetAttribute = p === -1 ? void 0 : p, new mh(ig)) }; mh.computeRectangle = function (e, t) { e = y(e, y.EMPTY_OBJECT); let n = e.rectangle, i = y(e.granularity, I.RADIANS_PER_DEGREE), o = y(e.ellipsoid, ie.WGS84), r = y(e.rotation, 0); return K6(n, i, r, o, t) }; var fWe = new Q, Wse = new Be, dWe = new he; mh.createGeometry = function (e) { if (I.equalsEpsilon(e._rectangle.north, e._rectangle.south, I.EPSILON10) || I.equalsEpsilon(e._rectangle.east, e._rectangle.west, I.EPSILON10)) return; let t = e._rectangle, n = e._ellipsoid, i = e._rotation, o = e._stRotation, r = e._vertexFormat, s = ms.computeOptions(t, e._granularity, i, o, Kse, $se, uWe), a = fWe; if (o !== 0 || i !== 0) { let g = ce.center(t, dWe), m = n.geodeticSurfaceNormalCartographic(g, Y6); Be.fromAxisAngle(m, -o, Wse), Q.fromQuaternion(Wse, a) } else Q.clone(Q.IDENTITY, a); let c = e._surfaceHeight, u = e._extrudedHeight, f = !I.equalsEpsilon(c, u, 0, I.EPSILON2); s.lonScalar = 1 / e._rectangle.width, s.latScalar = 1 / e._rectangle.height, s.tangentRotationMatrix = a; let d, p; if (t = e._rectangle, f) { d = cWe(e, s); let g = re.fromRectangle3D(t, n, c, rWe), m = re.fromRectangle3D(t, n, u, oWe); p = re.union(g, m) } else { if (d = Qse(e, s), d.attributes.position.values = ni.scaleToGeodeticHeight(d.attributes.position.values, c, n, !1), l(e._offsetAttribute)) { let g = d.attributes.position.values.length, m = e._offsetAttribute === Qt.NONE ? 0 : 1, A = new Uint8Array(g / 3).fill(m); d.attributes.applyOffset = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 1, values: A }) } p = re.fromRectangle3D(t, n, c) } return r.position || delete d.attributes.position, new st({ attributes: d.attributes, indices: d.indices, primitiveType: d.primitiveType, boundingSphere: p, offsetAttribute: e._offsetAttribute }) }; mh.createShadowVolume = function (e, t, n) { let i = e._granularity, o = e._ellipsoid, r = t(i, o), s = n(i, o); return new mh({ rectangle: e._rectangle, rotation: e._rotation, ellipsoid: o, stRotation: e._stRotation, granularity: i, extrudedHeight: s, height: r, vertexFormat: we.POSITION_ONLY, shadowVolume: !0 }) }; var jse = new ce, hWe = [new H, new H, new H], mWe = new qi, pWe = new he; function _We(e) { if (e._stRotation === 0) return [0, 0, 0, 1, 1, 0]; let t = ce.clone(e._rectangle, jse), n = e._granularity, i = e._ellipsoid, o = e._rotation - e._stRotation, r = K6(t, n, o, i, jse), s = hWe; s[0].x = r.west, s[0].y = r.south, s[1].x = r.west, s[1].y = r.north, s[2].x = r.east, s[2].y = r.south; let a = e.rectangle, c = qi.fromRotation(e._stRotation, mWe), u = ce.center(a, pWe); for (let m = 0; m < 3; ++m) { let A = s[m]; A.x -= u.longitude, A.y -= u.latitude, qi.multiplyByVector(c, A, A), A.x += u.longitude, A.y += u.latitude, A.x = (A.x - a.west) / a.width, A.y = (A.y - a.south) / a.height } let f = s[0], d = s[1], p = s[2], g = new Array(6); return H.pack(f, g), H.pack(d, g, 2), H.pack(p, g, 4), g } Object.defineProperties(mh.prototype, { rectangle: { get: function () { return l(this._rotatedRectangle) || (this._rotatedRectangle = K6(this._rectangle, this._granularity, this._rotation, this._ellipsoid)), this._rotatedRectangle } }, textureCoordinateRotationPoints: { get: function () { return l(this._textureCoordinateRotationPoints) || (this._textureCoordinateRotationPoints = _We(this)), this._textureCoordinateRotationPoints } } }); var TT = mh; var nae = new U, iae = h.ZERO, oae = new h, rae = new ce, gWe = new ce, yWe = new he; function AWe(e) { this.id = e, this.vertexFormat = void 0, this.rectangle = void 0, this.height = void 0, this.extrudedHeight = void 0, this.granularity = void 0, this.stRotation = void 0, this.rotation = void 0, this.offsetAttribute = void 0 } function Hf(e, t) { zn.call(this, { entity: e, scene: t, geometryOptions: new AWe(e), geometryPropertyName: "rectangle", observedPropertyNames: ["availability", "rectangle"] }), this._onEntityPropertyChanged(e, "rectangle", e.rectangle, void 0) } l(Object.create) && (Hf.prototype = Object.create(zn.prototype), Hf.prototype.constructor = Hf); Hf.prototype.createFillGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = { show: new fn(n && t.isShowing && this._showProperty.getValue(e) && this._fillProperty.getValue(e)), distanceDisplayCondition: Mn.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(e)), offset: void 0, color: void 0 }; if (this._materialProperty instanceof Ot) { let o; l(this._materialProperty.color) && (this._materialProperty.color.isConstant || n) && (o = this._materialProperty.color.getValue(e, nae)), l(o) || (o = U.WHITE), i.color = Bt.fromColor(o) } return l(this._options.offsetAttribute) && (i.offset = zi.fromCartesian3(j.getValueOrDefault(this._terrainOffsetProperty, e, iae, oae))), new At({ id: t, geometry: new TT(this._options), attributes: i }) }; Hf.prototype.createOutlineGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = j.getValueOrDefault(this._outlineColorProperty, e, U.BLACK, nae), o = this._distanceDisplayConditionProperty.getValue(e), r = { show: new fn(n && t.isShowing && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)), color: Bt.fromColor(i), distanceDisplayCondition: Mn.fromDistanceDisplayCondition(o), offset: void 0 }; return l(this._options.offsetAttribute) && (r.offset = zi.fromCartesian3(j.getValueOrDefault(this._terrainOffsetProperty, e, iae, oae))), new At({ id: t, geometry: new Ox(this._options), attributes: r }) }; Hf.prototype._computeCenter = function (e, t) { let n = j.getValueOrUndefined(this._entity.rectangle.coordinates, e, gWe); if (!l(n)) return; let i = ce.center(n, yWe); return he.toCartesian(i, ie.WGS84, t) }; Hf.prototype._isHidden = function (e, t) { return !l(t.coordinates) || ei.prototype._isHidden.call(this, e, t) }; Hf.prototype._isDynamic = function (e, t) { return !t.coordinates.isConstant || !j.isConstant(t.height) || !j.isConstant(t.extrudedHeight) || !j.isConstant(t.granularity) || !j.isConstant(t.stRotation) || !j.isConstant(t.rotation) || !j.isConstant(t.outlineWidth) || !j.isConstant(t.zIndex) || this._onTerrain && !j.isConstant(this._materialProperty) && !(this._materialProperty instanceof Ot) }; Hf.prototype._setStaticOptions = function (e, t) { let n = this._materialProperty instanceof Ot, i = j.getValueOrUndefined(t.height, ke.MINIMUM_VALUE), o = j.getValueOrDefault(t.heightReference, ke.MINIMUM_VALUE, ze.NONE), r = j.getValueOrUndefined(t.extrudedHeight, ke.MINIMUM_VALUE), s = j.getValueOrDefault(t.extrudedHeightReference, ke.MINIMUM_VALUE, ze.NONE); l(r) && !l(i) && (i = 0); let a = this._options; a.vertexFormat = n ? $t.VERTEX_FORMAT : eo.MaterialSupport.TEXTURED.vertexFormat, a.rectangle = t.coordinates.getValue(ke.MINIMUM_VALUE, a.rectangle), a.granularity = j.getValueOrUndefined(t.granularity, ke.MINIMUM_VALUE), a.stRotation = j.getValueOrUndefined(t.stRotation, ke.MINIMUM_VALUE), a.rotation = j.getValueOrUndefined(t.rotation, ke.MINIMUM_VALUE), a.offsetAttribute = zn.computeGeometryOffsetAttribute(i, o, r, s), a.height = zn.getGeometryHeight(i, o), r = zn.getGeometryExtrudedHeight(r, s), r === zn.CLAMP_TO_GROUND && (r = oi.getMinimumMaximumHeights(TT.computeRectangle(a, rae)).minimumTerrainHeight), a.extrudedHeight = r }; Hf.DynamicGeometryUpdater = ET; function ET(e, t, n) { $n.call(this, e, t, n) } l(Object.create) && (ET.prototype = Object.create($n.prototype), ET.prototype.constructor = ET); ET.prototype._isHidden = function (e, t, n) { return !l(this._options.rectangle) || $n.prototype._isHidden.call(this, e, t, n) }; ET.prototype._setOptions = function (e, t, n) { let i = this._options, o = j.getValueOrUndefined(t.height, n), r = j.getValueOrDefault(t.heightReference, n, ze.NONE), s = j.getValueOrUndefined(t.extrudedHeight, n), a = j.getValueOrDefault(t.extrudedHeightReference, n, ze.NONE); l(s) && !l(o) && (o = 0), i.rectangle = j.getValueOrUndefined(t.coordinates, n, i.rectangle), i.granularity = j.getValueOrUndefined(t.granularity, n), i.stRotation = j.getValueOrUndefined(t.stRotation, n), i.rotation = j.getValueOrUndefined(t.rotation, n), i.offsetAttribute = zn.computeGeometryOffsetAttribute(o, r, s, a), i.height = zn.getGeometryHeight(o, r), s = zn.getGeometryExtrudedHeight(s, a), s === zn.CLAMP_TO_GROUND && (s = oi.getMinimumMaximumHeights(TT.computeRectangle(i, rae)).minimumTerrainHeight), i.extrudedHeight = s }; var TN = Hf; var sae = new U, CWe = new bt, xWe = new bt, TWe = h.ZERO, EWe = new h; function Gf(e, t, n, i, o, r, s) { this.translucent = t, this.appearanceType = n, this.depthFailAppearanceType = i, this.depthFailMaterialProperty = o, this.depthFailMaterial = void 0, this.closed = r, this.shadows = s, this.primitives = e, this.createPrimitive = !1, this.waitingOnCreate = !1, this.primitive = void 0, this.oldPrimitive = void 0, this.geometry = new Ct, this.updaters = new Ct, this.updatersWithAttributes = new Ct, this.attributes = new Ct, this.subscriptions = new Ct, this.showsUpdated = new Ct, this.itemsToRemove = [], this.invalidated = !1; let a; l(o) && (a = o.definitionChanged.addEventListener(Gf.prototype.onMaterialChanged, this)), this.removeMaterialSubscription = a } Gf.prototype.onMaterialChanged = function () { this.invalidated = !0 }; Gf.prototype.isMaterial = function (e) { let t = this.depthFailMaterialProperty, n = e.depthFailMaterialProperty; return n === t ? !0 : l(t) ? t.equals(n) : !1 }; Gf.prototype.add = function (e, t) { let n = e.id; if (this.createPrimitive = !0, this.geometry.set(n, t), this.updaters.set(n, e), !e.hasConstantFill || !e.fillMaterialProperty.isConstant || !j.isConstant(e.distanceDisplayConditionProperty) || !j.isConstant(e.terrainOffsetProperty)) this.updatersWithAttributes.set(n, e); else { let i = this; this.subscriptions.set(n, e.entity.definitionChanged.addEventListener(function (o, r, s, a) { r === "isShowing" && i.showsUpdated.set(e.id, e) })) } }; Gf.prototype.remove = function (e) { let t = e.id; if (this.createPrimitive = this.geometry.remove(t) || this.createPrimitive, this.updaters.remove(t)) { this.updatersWithAttributes.remove(t); let n = this.subscriptions.get(t); return l(n) && (n(), this.subscriptions.remove(t), this.showsUpdated.remove(t)), !0 } return !1 }; Gf.prototype.update = function (e) { let t = !0, n = 0, i = this.primitive, o = this.primitives, r; if (this.createPrimitive) { let s = this.geometry.values; if (s.length > 0) { l(i) && (l(this.oldPrimitive) ? o.remove(i) : this.oldPrimitive = i); let c; l(this.depthFailAppearanceType) && (l(this.depthFailMaterialProperty) && (this.depthFailMaterial = Yo.getValue(e, this.depthFailMaterialProperty, this.depthFailMaterial)), c = new this.depthFailAppearanceType({ material: this.depthFailMaterial, translucent: this.translucent, closed: this.closed })), i = new xn({ show: !1, asynchronous: !0, geometryInstances: s.slice(), appearance: new this.appearanceType({ translucent: this.translucent, closed: this.closed }), depthFailAppearance: c, shadows: this.shadows }), o.add(i), t = !1 } else { l(i) && (o.remove(i), i = void 0); let c = this.oldPrimitive; l(c) && (o.remove(c), this.oldPrimitive = void 0) } this.attributes.removeAll(), this.primitive = i, this.createPrimitive = !1, this.waitingOnCreate = !0 } else if (l(i) && i.ready) { i.show = !0, l(this.oldPrimitive) && (o.remove(this.oldPrimitive), this.oldPrimitive = void 0), l(this.depthFailAppearanceType) && !(this.depthFailMaterialProperty instanceof Ot) && (this.depthFailMaterial = Yo.getValue(e, this.depthFailMaterialProperty, this.depthFailMaterial), this.primitive.depthFailAppearance.material = this.depthFailMaterial); let s = this.updatersWithAttributes.values, a = s.length, c = this.waitingOnCreate; for (r = 0; r < a; r++) { let u = s[r], f = this.geometry.get(u.id), d = this.attributes.get(f.id.id); if (l(d) || (d = i.getGeometryInstanceAttributes(f.id), this.attributes.set(f.id.id, d)), !u.fillMaterialProperty.isConstant || c) { let C = u.fillMaterialProperty.color, x = j.getValueOrDefault(C, e, U.WHITE, sae); U.equals(d._lastColor, x) || (d._lastColor = U.clone(x, d._lastColor), d.color = Bt.toValue(x, d.color), (this.translucent && d.color[3] === 255 || !this.translucent && d.color[3] !== 255) && (this.itemsToRemove[n++] = u)) } if (l(this.depthFailAppearanceType) && u.depthFailMaterialProperty instanceof Ot && (!u.depthFailMaterialProperty.isConstant || c)) { let C = u.depthFailMaterialProperty.color, x = j.getValueOrDefault(C, e, U.WHITE, sae); U.equals(d._lastDepthFailColor, x) || (d._lastDepthFailColor = U.clone(x, d._lastDepthFailColor), d.depthFailColor = Bt.toValue(x, d.depthFailColor)) } let p = u.entity.isShowing && (u.hasConstantFill || u.isFilled(e)), g = d.show[0] === 1; p !== g && (d.show = fn.toValue(p, d.show)); let m = u.distanceDisplayConditionProperty; if (!j.isConstant(m)) { let C = j.getValueOrDefault(m, e, xWe, CWe); bt.equals(C, d._lastDistanceDisplayCondition) || (d._lastDistanceDisplayCondition = bt.clone(C, d._lastDistanceDisplayCondition), d.distanceDisplayCondition = Mn.toValue(C, d.distanceDisplayCondition)) } let A = u.terrainOffsetProperty; if (!j.isConstant(A)) { let C = j.getValueOrDefault(A, e, TWe, EWe); h.equals(C, d._lastOffset) || (d._lastOffset = h.clone(C, d._lastOffset), d.offset = zi.toValue(C, d.offset)) } } this.updateShows(i), this.waitingOnCreate = !1 } else l(i) && !i.ready && (t = !1); return this.itemsToRemove.length = n, t }; Gf.prototype.updateShows = function (e) { let t = this.showsUpdated.values, n = t.length; for (let i = 0; i < n; i++) { let o = t[i], r = this.geometry.get(o.id), s = this.attributes.get(r.id.id); l(s) || (s = e.getGeometryInstanceAttributes(r.id), this.attributes.set(r.id.id, s)); let a = o.entity.isShowing, c = s.show[0] === 1; a !== c && (s.show = fn.toValue(a, s.show), r.attributes.show.value[0] = s.show[0]) } this.showsUpdated.removeAll() }; Gf.prototype.contains = function (e) { return this.updaters.contains(e.id) }; Gf.prototype.getBoundingSphere = function (e, t) { let n = this.primitive; if (!n.ready) return rt.PENDING; let i = n.getGeometryInstanceAttributes(e.entity); return !l(i) || !l(i.boundingSphere) || l(i.show) && i.show[0] === 0 ? rt.FAILED : (i.boundingSphere.clone(t), rt.DONE) }; Gf.prototype.destroy = function () { let e = this.primitive, t = this.primitives; l(e) && t.remove(e); let n = this.oldPrimitive; l(n) && t.remove(n), l(this.removeMaterialSubscription) && this.removeMaterialSubscription() }; function bT(e, t, n, i, o) { this._solidItems = [], this._translucentItems = [], this._primitives = e, this._appearanceType = t, this._depthFailAppearanceType = n, this._closed = i, this._shadows = o } bT.prototype.add = function (e, t) { let n, i, o = t.createFillGeometryInstance(e); o.attributes.color.value[3] === 255 ? (n = this._solidItems, i = !1) : (n = this._translucentItems, i = !0); let r = n.length; for (let a = 0; a < r; a++) { let c = n[a]; if (c.isMaterial(t)) { c.add(t, o); return } } let s = new Gf(this._primitives, i, this._appearanceType, this._depthFailAppearanceType, t.depthFailMaterialProperty, this._closed, this._shadows); s.add(t, o), n.push(s) }; function aae(e, t) { let n = e.length; for (let i = n - 1; i >= 0; i--) { let o = e[i]; if (o.remove(t)) return o.updaters.length === 0 && (e.splice(i, 1), o.destroy()), !0 } return !1 } bT.prototype.remove = function (e) { aae(this._solidItems, e) || aae(this._translucentItems, e) }; function cae(e, t, n) { let i = !1, o = t.length; for (let r = 0; r < o; ++r) { let s = t[r], a = s.itemsToRemove, c = a.length; if (c > 0) for (r = 0; r < c; r++) { let u = a[r]; s.remove(u), e.add(n, u), i = !0 } } return i } function EN(e, t, n, i) { let o = t.length, r; for (r = o - 1; r >= 0; r--) { let s = t[r]; if (s.invalidated) { t.splice(r, 1); let a = s.updaters.values, c = a.length; for (let u = 0; u < c; u++)e.add(n, a[u]); s.destroy() } } for (o = t.length, r = 0; r < o; ++r)i = t[r].update(n) && i; return i } bT.prototype.update = function (e) { let t = EN(this, this._solidItems, e, !0); t = EN(this, this._translucentItems, e, t) && t; let n = cae(this, this._solidItems, e), i = cae(this, this._translucentItems, e); return (n || i) && (t = EN(this, this._solidItems, e, t) && t, t = EN(this, this._translucentItems, e, t) && t), t }; function lae(e, t, n) { let i = e.length; for (let o = 0; o < i; o++) { let r = e[o]; if (r.contains(t)) return r.getBoundingSphere(t, n) } return rt.FAILED } bT.prototype.getBoundingSphere = function (e, t) { let n = lae(this._solidItems, e, t); return n === rt.FAILED ? lae(this._translucentItems, e, t) : n }; function uae(e) { let t = e.length; for (let n = 0; n < t; n++)e[n].destroy(); e.length = 0 } bT.prototype.removeAllPrimitives = function () { uae(this._solidItems), uae(this._translucentItems) }; var Wf = bT; var bWe = new bt, SWe = new bt, wWe = h.ZERO, DWe = new h; function jf(e, t, n, i, o, r, s) { this.primitives = e, this.appearanceType = t, this.materialProperty = n, this.depthFailAppearanceType = i, this.depthFailMaterialProperty = o, this.closed = r, this.shadows = s, this.updaters = new Ct, this.createPrimitive = !0, this.primitive = void 0, this.oldPrimitive = void 0, this.geometry = new Ct, this.material = void 0, this.depthFailMaterial = void 0, this.updatersWithAttributes = new Ct, this.attributes = new Ct, this.invalidated = !1, this.removeMaterialSubscription = n.definitionChanged.addEventListener(jf.prototype.onMaterialChanged, this), this.subscriptions = new Ct, this.showsUpdated = new Ct } jf.prototype.onMaterialChanged = function () { this.invalidated = !0 }; jf.prototype.isMaterial = function (e) { let t = this.materialProperty, n = e.fillMaterialProperty, i = this.depthFailMaterialProperty, o = e.depthFailMaterialProperty; if (n === t && o === i) return !0; let r = l(t) && t.equals(n); return r = (!l(i) && !l(o) || l(i) && i.equals(o)) && r, r }; jf.prototype.add = function (e, t) { let n = t.id; if (this.updaters.set(n, t), this.geometry.set(n, t.createFillGeometryInstance(e)), !t.hasConstantFill || !t.fillMaterialProperty.isConstant || !j.isConstant(t.distanceDisplayConditionProperty) || !j.isConstant(t.terrainOffsetProperty)) this.updatersWithAttributes.set(n, t); else { let i = this; this.subscriptions.set(n, t.entity.definitionChanged.addEventListener(function (o, r, s, a) { r === "isShowing" && i.showsUpdated.set(t.id, t) })) } this.createPrimitive = !0 }; jf.prototype.remove = function (e) { let t = e.id; if (this.createPrimitive = this.geometry.remove(t) || this.createPrimitive, this.updaters.remove(t)) { this.updatersWithAttributes.remove(t); let n = this.subscriptions.get(t); return l(n) && (n(), this.subscriptions.remove(t), this.showsUpdated.remove(t)), !0 } return !1 }; var vWe = new U; jf.prototype.update = function (e) { let t = !0, n = this.primitive, i = this.primitives, o = this.geometry.values, r; if (this.createPrimitive) { if (o.length > 0) { l(n) && (l(this.oldPrimitive) ? i.remove(n) : this.oldPrimitive = n), this.material = Yo.getValue(e, this.materialProperty, this.material); let a; l(this.depthFailMaterialProperty) && (this.depthFailMaterial = Yo.getValue(e, this.depthFailMaterialProperty, this.depthFailMaterial), a = new this.depthFailAppearanceType({ material: this.depthFailMaterial, translucent: this.depthFailMaterial.isTranslucent(), closed: this.closed })), n = new xn({ show: !1, asynchronous: !0, geometryInstances: o.slice(), appearance: new this.appearanceType({ material: this.material, translucent: this.material.isTranslucent(), closed: this.closed }), depthFailAppearance: a, shadows: this.shadows }), i.add(n), t = !1 } else { l(n) && (i.remove(n), n = void 0); let a = this.oldPrimitive; l(a) && (i.remove(a), this.oldPrimitive = void 0) } this.attributes.removeAll(), this.primitive = n, this.createPrimitive = !1 } else if (l(n) && n.ready) { n.show = !0, l(this.oldPrimitive) && (i.remove(this.oldPrimitive), this.oldPrimitive = void 0), this.material = Yo.getValue(e, this.materialProperty, this.material), this.primitive.appearance.material = this.material, l(this.depthFailAppearanceType) && !(this.depthFailMaterialProperty instanceof Ot) && (this.depthFailMaterial = Yo.getValue(e, this.depthFailMaterialProperty, this.depthFailMaterial), this.primitive.depthFailAppearance.material = this.depthFailMaterial); let s = this.updatersWithAttributes.values, a = s.length; for (r = 0; r < a; r++) { let c = s[r], u = c.entity, f = this.geometry.get(c.id), d = this.attributes.get(f.id.id); if (l(d) || (d = n.getGeometryInstanceAttributes(f.id), this.attributes.set(f.id.id, d)), l(this.depthFailAppearanceType) && this.depthFailMaterialProperty instanceof Ot && !c.depthFailMaterialProperty.isConstant) { let C = c.depthFailMaterialProperty.color, x = j.getValueOrDefault(C, e, U.WHITE, vWe); U.equals(d._lastDepthFailColor, x) || (d._lastDepthFailColor = U.clone(x, d._lastDepthFailColor), d.depthFailColor = Bt.toValue(x, d.depthFailColor)) } let p = u.isShowing && (c.hasConstantFill || c.isFilled(e)), g = d.show[0] === 1; p !== g && (d.show = fn.toValue(p, d.show)); let m = c.distanceDisplayConditionProperty; if (!j.isConstant(m)) { let C = j.getValueOrDefault(m, e, SWe, bWe); bt.equals(C, d._lastDistanceDisplayCondition) || (d._lastDistanceDisplayCondition = bt.clone(C, d._lastDistanceDisplayCondition), d.distanceDisplayCondition = Mn.toValue(C, d.distanceDisplayCondition)) } let A = c.terrainOffsetProperty; if (!j.isConstant(A)) { let C = j.getValueOrDefault(A, e, wWe, DWe); h.equals(C, d._lastOffset) || (d._lastOffset = h.clone(C, d._lastOffset), d.offset = zi.toValue(C, d.offset)) } } this.updateShows(n) } else l(n) && !n.ready && (t = !1); return t }; jf.prototype.updateShows = function (e) { let t = this.showsUpdated.values, n = t.length; for (let i = 0; i < n; i++) { let o = t[i], r = o.entity, s = this.geometry.get(o.id), a = this.attributes.get(s.id.id); l(a) || (a = e.getGeometryInstanceAttributes(s.id), this.attributes.set(s.id.id, a)); let c = r.isShowing, u = a.show[0] === 1; c !== u && (a.show = fn.toValue(c, a.show), s.attributes.show.value[0] = a.show[0]) } this.showsUpdated.removeAll() }; jf.prototype.contains = function (e) { return this.updaters.contains(e.id) }; jf.prototype.getBoundingSphere = function (e, t) { let n = this.primitive; if (!n.ready) return rt.PENDING; let i = n.getGeometryInstanceAttributes(e.entity); return !l(i) || !l(i.boundingSphere) || l(i.show) && i.show[0] === 0 ? rt.FAILED : (i.boundingSphere.clone(t), rt.DONE) }; jf.prototype.destroy = function () { let e = this.primitive, t = this.primitives; l(e) && t.remove(e); let n = this.oldPrimitive; l(n) && t.remove(n), this.removeMaterialSubscription() }; function ST(e, t, n, i, o) { this._items = [], this._primitives = e, this._appearanceType = t, this._depthFailAppearanceType = n, this._closed = i, this._shadows = o } ST.prototype.add = function (e, t) { let n = this._items, i = n.length; for (let r = 0; r < i; r++) { let s = n[r]; if (s.isMaterial(t)) { s.add(e, t); return } } let o = new jf(this._primitives, this._appearanceType, t.fillMaterialProperty, this._depthFailAppearanceType, t.depthFailMaterialProperty, this._closed, this._shadows); o.add(e, t), n.push(o) }; ST.prototype.remove = function (e) { let t = this._items, n = t.length; for (let i = n - 1; i >= 0; i--) { let o = t[i]; if (o.remove(e)) { o.updaters.length === 0 && (t.splice(i, 1), o.destroy()); break } } }; ST.prototype.update = function (e) { let t, n = this._items, i = n.length; for (t = i - 1; t >= 0; t--) { let r = n[t]; if (r.invalidated) { n.splice(t, 1); let s = r.updaters.values, a = s.length; for (let c = 0; c < a; c++)this.add(e, s[c]); r.destroy() } } let o = !0; for (t = 0; t < n.length; t++)o = n[t].update(e) && o; return o }; ST.prototype.getBoundingSphere = function (e, t) { let n = this._items, i = n.length; for (let o = 0; o < i; o++) { let r = n[o]; if (r.contains(e)) return r.getBoundingSphere(e, t) } return rt.FAILED }; ST.prototype.removeAllPrimitives = function () { let e = this._items, t = e.length; for (let n = 0; n < t; n++)e[n].destroy(); this._items.length = 0 }; var qf = ST; var dae = po(fae(), 1); function bN() { this._tree = new dae.default } function vy() { this.minX = 0, this.minY = 0, this.maxX = 0, this.maxY = 0, this.id = "" } vy.fromRectangleAndId = function (e, t, n) { return n.minX = t.west, n.minY = t.south, n.maxX = t.east, n.maxY = t.north, n.id = e, n }; bN.prototype.insert = function (e, t) { let n = vy.fromRectangleAndId(e, t, new vy); this._tree.insert(n) }; function PWe(e, t) { return e.id === t.id } var IWe = new vy; bN.prototype.remove = function (e, t) { let n = vy.fromRectangleAndId(e, t, IWe); this._tree.remove(n, PWe) }; var OWe = new vy; bN.prototype.collides = function (e) { let t = vy.fromRectangleAndId("", e, OWe); return this._tree.collides(t) }; var wT = bN; var BWe = new U, RWe = new bt, MWe = new bt; function tp(e, t, n, i) { this.primitives = e, this.zIndex = i, this.classificationType = t, this.color = n, this.createPrimitive = !1, this.waitingOnCreate = !1, this.primitive = void 0, this.oldPrimitive = void 0, this.geometry = new Ct, this.updaters = new Ct, this.updatersWithAttributes = new Ct, this.attributes = new Ct, this.subscriptions = new Ct, this.showsUpdated = new Ct, this.itemsToRemove = [], this.isDirty = !1, this.rectangleCollisionCheck = new wT } tp.prototype.overlapping = function (e) { return this.rectangleCollisionCheck.collides(e) }; tp.prototype.add = function (e, t) { let n = e.id; if (this.createPrimitive = !0, this.geometry.set(n, t), this.updaters.set(n, e), this.rectangleCollisionCheck.insert(n, t.geometry.rectangle), !e.hasConstantFill || !e.fillMaterialProperty.isConstant || !j.isConstant(e.distanceDisplayConditionProperty)) this.updatersWithAttributes.set(n, e); else { let i = this; this.subscriptions.set(n, e.entity.definitionChanged.addEventListener(function (o, r, s, a) { r === "isShowing" && i.showsUpdated.set(e.id, e) })) } }; tp.prototype.remove = function (e) { let t = e.id, n = this.geometry.get(t); if (this.createPrimitive = this.geometry.remove(t) || this.createPrimitive, this.updaters.remove(t)) { this.rectangleCollisionCheck.remove(t, n.geometry.rectangle), this.updatersWithAttributes.remove(t); let i = this.subscriptions.get(t); return l(i) && (i(), this.subscriptions.remove(t), this.showsUpdated.remove(t)), !0 } return !1 }; tp.prototype.update = function (e) { let t = !0, n = 0, i = this.primitive, o = this.primitives, r; if (this.createPrimitive) { let s = this.geometry.values; if (s.length > 0) l(i) && (l(this.oldPrimitive) ? o.remove(i) : this.oldPrimitive = i), i = new Rc({ show: !1, asynchronous: !0, geometryInstances: s.slice(), classificationType: this.classificationType }), o.add(i, this.zIndex), t = !1; else { l(i) && (o.remove(i), i = void 0); let c = this.oldPrimitive; l(c) && (o.remove(c), this.oldPrimitive = void 0) } this.attributes.removeAll(), this.primitive = i, this.createPrimitive = !1, this.waitingOnCreate = !0 } else if (l(i) && i.ready) { i.show = !0, l(this.oldPrimitive) && (o.remove(this.oldPrimitive), this.oldPrimitive = void 0); let s = this.updatersWithAttributes.values, a = s.length, c = this.waitingOnCreate; for (r = 0; r < a; r++) { let u = s[r], f = this.geometry.get(u.id), d = this.attributes.get(f.id.id); if (l(d) || (d = i.getGeometryInstanceAttributes(f.id), this.attributes.set(f.id.id, d)), !u.fillMaterialProperty.isConstant || c) { let A = u.fillMaterialProperty.color, C = j.getValueOrDefault(A, e, U.WHITE, BWe); U.equals(d._lastColor, C) || (d._lastColor = U.clone(C, d._lastColor), d.color = Bt.toValue(C, d.color)) } let p = u.entity.isShowing && (u.hasConstantFill || u.isFilled(e)), g = d.show[0] === 1; p !== g && (d.show = fn.toValue(p, d.show)); let m = u.distanceDisplayConditionProperty; if (!j.isConstant(m)) { let A = j.getValueOrDefault(m, e, MWe, RWe); bt.equals(A, d._lastDistanceDisplayCondition) || (d._lastDistanceDisplayCondition = bt.clone(A, d._lastDistanceDisplayCondition), d.distanceDisplayCondition = Mn.toValue(A, d.distanceDisplayCondition)) } } this.updateShows(i), this.waitingOnCreate = !1 } else l(i) && !i.ready && (t = !1); return this.itemsToRemove.length = n, t }; tp.prototype.updateShows = function (e) { let t = this.showsUpdated.values, n = t.length; for (let i = 0; i < n; i++) { let o = t[i], r = this.geometry.get(o.id), s = this.attributes.get(r.id.id); l(s) || (s = e.getGeometryInstanceAttributes(r.id), this.attributes.set(r.id.id, s)); let a = o.entity.isShowing, c = s.show[0] === 1; a !== c && (s.show = fn.toValue(a, s.show), r.attributes.show.value[0] = s.show[0]) } this.showsUpdated.removeAll() }; tp.prototype.contains = function (e) { return this.updaters.contains(e.id) }; tp.prototype.getBoundingSphere = function (e, t) { let n = this.primitive; if (!n.ready) return rt.PENDING; let i = n.getBoundingSphere(e.entity); return l(i) ? (i.clone(t), rt.DONE) : rt.FAILED }; tp.prototype.removeAllPrimitives = function () { let e = this.primitives, t = this.primitive; l(t) && (e.remove(t), this.primitive = void 0, this.geometry.removeAll(), this.updaters.removeAll()); let n = this.oldPrimitive; l(n) && (e.remove(n), this.oldPrimitive = void 0) }; function DT(e, t) { this._batches = [], this._primitives = e, this._classificationType = t } DT.prototype.add = function (e, t) { let n = t.createFillGeometryInstance(e), i = this._batches, o = j.getValueOrDefault(t.zIndex, 0), r, s = i.length; for (let a = 0; a < s; ++a) { let c = i[a]; if (c.zIndex === o && !c.overlapping(n.geometry.rectangle)) { r = c; break } } return l(r) || (r = new tp(this._primitives, this._classificationType, n.attributes.color.value, o), i.push(r)), r.add(t, n), r }; DT.prototype.remove = function (e) { let t = this._batches, n = t.length; for (let i = 0; i < n; ++i)if (t[i].remove(e)) return }; DT.prototype.update = function (e) { let t, n, i = !0, o = this._batches, r = o.length; for (t = 0; t < r; ++t)i = o[t].update(e) && i; for (t = 0; t < r; ++t) { let s = o[t], a = s.itemsToRemove, c = a.length; for (let u = 0; u < c; u++) { n = a[u], s.remove(n); let f = this.add(e, n); s.isDirty = !0, f.isDirty = !0 } } for (t = r - 1; t >= 0; --t) { let s = o[t]; s.isDirty && (i = o[t].update(e) && i, s.isDirty = !1), s.geometry.length === 0 && o.splice(t, 1) } return i }; DT.prototype.getBoundingSphere = function (e, t) { let n = this._batches, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; if (r.contains(e)) return r.getBoundingSphere(e, t) } return rt.FAILED }; DT.prototype.removeAllPrimitives = function () { let e = this._batches, t = e.length; for (let n = 0; n < t; ++n)e[n].removeAllPrimitives() }; var Kw = DT; var LWe = new bt, FWe = new bt; function Fu(e, t, n, i, o, r) { this.primitives = e, this.classificationType = t, this.appearanceType = n, this.materialProperty = i, this.updaters = new Ct, this.createPrimitive = !0, this.primitive = void 0, this.oldPrimitive = void 0, this.geometry = new Ct, this.material = void 0, this.updatersWithAttributes = new Ct, this.attributes = new Ct, this.invalidated = !1, this.removeMaterialSubscription = i.definitionChanged.addEventListener(Fu.prototype.onMaterialChanged, this), this.subscriptions = new Ct, this.showsUpdated = new Ct, this.usingSphericalTextureCoordinates = o, this.zIndex = r, this.rectangleCollisionCheck = new wT } Fu.prototype.onMaterialChanged = function () { this.invalidated = !0 }; Fu.prototype.overlapping = function (e) { return this.rectangleCollisionCheck.collides(e) }; Fu.prototype.isMaterial = function (e) { let t = this.materialProperty, n = e.fillMaterialProperty; return n === t || n instanceof Ot && t instanceof Ot ? !0 : l(t) && t.equals(n) }; Fu.prototype.add = function (e, t, n) { let i = t.id; if (this.updaters.set(i, t), this.geometry.set(i, n), this.rectangleCollisionCheck.insert(i, n.geometry.rectangle), !t.hasConstantFill || !t.fillMaterialProperty.isConstant || !j.isConstant(t.distanceDisplayConditionProperty)) this.updatersWithAttributes.set(i, t); else { let o = this; this.subscriptions.set(i, t.entity.definitionChanged.addEventListener(function (r, s, a, c) { s === "isShowing" && o.showsUpdated.set(t.id, t) })) } this.createPrimitive = !0 }; Fu.prototype.remove = function (e) { let t = e.id, n = this.geometry.get(t); if (this.createPrimitive = this.geometry.remove(t) || this.createPrimitive, this.updaters.remove(t)) { this.rectangleCollisionCheck.remove(t, n.geometry.rectangle), this.updatersWithAttributes.remove(t); let i = this.subscriptions.get(t); return l(i) && (i(), this.subscriptions.remove(t)), !0 } return !1 }; Fu.prototype.update = function (e) { let t = !0, n = this.primitive, i = this.primitives, o = this.geometry.values, r; if (this.createPrimitive) { if (o.length > 0) l(n) && (l(this.oldPrimitive) ? i.remove(n) : this.oldPrimitive = n), this.material = Yo.getValue(e, this.materialProperty, this.material), n = new Rc({ show: !1, asynchronous: !0, geometryInstances: o.slice(), appearance: new this.appearanceType({ material: this.material }), classificationType: this.classificationType }), i.add(n, this.zIndex), t = !1; else { l(n) && (i.remove(n), n = void 0); let a = this.oldPrimitive; l(a) && (i.remove(a), this.oldPrimitive = void 0) } this.attributes.removeAll(), this.primitive = n, this.createPrimitive = !1 } else if (l(n) && n.ready) { n.show = !0, l(this.oldPrimitive) && (i.remove(this.oldPrimitive), this.oldPrimitive = void 0), this.material = Yo.getValue(e, this.materialProperty, this.material), this.primitive.appearance.material = this.material; let s = this.updatersWithAttributes.values, a = s.length; for (r = 0; r < a; r++) { let c = s[r], u = c.entity, f = this.geometry.get(c.id), d = this.attributes.get(f.id.id); l(d) || (d = n.getGeometryInstanceAttributes(f.id), this.attributes.set(f.id.id, d)); let p = u.isShowing && (c.hasConstantFill || c.isFilled(e)), g = d.show[0] === 1; p !== g && (d.show = fn.toValue(p, d.show)); let m = c.distanceDisplayConditionProperty; if (!j.isConstant(m)) { let A = j.getValueOrDefault(m, e, FWe, LWe); bt.equals(A, d._lastDistanceDisplayCondition) || (d._lastDistanceDisplayCondition = bt.clone(A, d._lastDistanceDisplayCondition), d.distanceDisplayCondition = Mn.toValue(A, d.distanceDisplayCondition)) } } this.updateShows(n) } else l(n) && !n.ready && (t = !1); return t }; Fu.prototype.updateShows = function (e) { let t = this.showsUpdated.values, n = t.length; for (let i = 0; i < n; i++) { let o = t[i], r = o.entity, s = this.geometry.get(o.id), a = this.attributes.get(s.id.id); l(a) || (a = e.getGeometryInstanceAttributes(s.id), this.attributes.set(s.id.id, a)); let c = r.isShowing, u = a.show[0] === 1; c !== u && (a.show = fn.toValue(c, a.show), s.attributes.show.value[0] = a.show[0]) } this.showsUpdated.removeAll() }; Fu.prototype.contains = function (e) { return this.updaters.contains(e.id) }; Fu.prototype.getBoundingSphere = function (e, t) { let n = this.primitive; if (!n.ready) return rt.PENDING; let i = n.getGeometryInstanceAttributes(e.entity); return !l(i) || !l(i.boundingSphere) || l(i.show) && i.show[0] === 0 ? rt.FAILED : (i.boundingSphere.clone(t), rt.DONE) }; Fu.prototype.destroy = function () { let e = this.primitive, t = this.primitives; l(e) && t.remove(e); let n = this.oldPrimitive; l(n) && t.remove(n), this.removeMaterialSubscription() }; function vT(e, t, n) { this._items = [], this._primitives = e, this._classificationType = t, this._appearanceType = n } vT.prototype.add = function (e, t) { let n = this._items, i = n.length, o = t.createFillGeometryInstance(e), r = ou.shouldUseSphericalCoordinates(o.geometry.rectangle), s = j.getValueOrDefault(t.zIndex, 0); for (let c = 0; c < i; ++c) { let u = n[c]; if (u.isMaterial(t) && u.usingSphericalTextureCoordinates === r && u.zIndex === s && !u.overlapping(o.geometry.rectangle)) { u.add(e, t, o); return } } let a = new Fu(this._primitives, this._classificationType, this._appearanceType, t.fillMaterialProperty, r, s); a.add(e, t, o), n.push(a) }; vT.prototype.remove = function (e) { let t = this._items, n = t.length; for (let i = n - 1; i >= 0; i--) { let o = t[i]; if (o.remove(e)) { o.updaters.length === 0 && (t.splice(i, 1), o.destroy()); break } } }; vT.prototype.update = function (e) { let t, n = this._items, i = n.length; for (t = i - 1; t >= 0; t--) { let r = n[t]; if (r.invalidated) { n.splice(t, 1); let s = r.updaters.values, a = s.length; for (let c = 0; c < a; c++)this.add(e, s[c]); r.destroy() } } let o = !0; for (t = 0; t < n.length; t++)o = n[t].update(e) && o; return o }; vT.prototype.getBoundingSphere = function (e, t) { let n = this._items, i = n.length; for (let o = 0; o < i; o++) { let r = n[o]; if (r.contains(e)) return r.getBoundingSphere(e, t) } return rt.FAILED }; vT.prototype.removeAllPrimitives = function () { let e = this._items, t = e.length; for (let n = 0; n < t; n++)e[n].destroy(); this._items.length = 0 }; var SN = vT; var NWe = new U, VWe = new bt, kWe = new bt, UWe = h.ZERO, zWe = new h; function np(e, t, n, i) { this.translucent = t, this.width = n, this.shadows = i, this.primitives = e, this.createPrimitive = !1, this.waitingOnCreate = !1, this.primitive = void 0, this.oldPrimitive = void 0, this.geometry = new Ct, this.updaters = new Ct, this.updatersWithAttributes = new Ct, this.attributes = new Ct, this.itemsToRemove = [], this.subscriptions = new Ct, this.showsUpdated = new Ct } np.prototype.add = function (e, t) { let n = e.id; if (this.createPrimitive = !0, this.geometry.set(n, t), this.updaters.set(n, e), !e.hasConstantOutline || !e.outlineColorProperty.isConstant || !j.isConstant(e.distanceDisplayConditionProperty) || !j.isConstant(e.terrainOffsetProperty)) this.updatersWithAttributes.set(n, e); else { let i = this; this.subscriptions.set(n, e.entity.definitionChanged.addEventListener(function (o, r, s, a) { r === "isShowing" && i.showsUpdated.set(e.id, e) })) } }; np.prototype.remove = function (e) { let t = e.id; if (this.createPrimitive = this.geometry.remove(t) || this.createPrimitive, this.updaters.remove(t)) { this.updatersWithAttributes.remove(t); let n = this.subscriptions.get(t); return l(n) && (n(), this.subscriptions.remove(t), this.showsUpdated.remove(t)), !0 } return !1 }; np.prototype.update = function (e) { let t = !0, n = 0, i = this.primitive, o = this.primitives, r; if (this.createPrimitive) { let s = this.geometry.values; if (s.length > 0) l(i) && (l(this.oldPrimitive) ? o.remove(i) : this.oldPrimitive = i), i = new xn({ show: !1, asynchronous: !0, geometryInstances: s.slice(), appearance: new $t({ flat: !0, translucent: this.translucent, renderState: { lineWidth: this.width } }), shadows: this.shadows }), o.add(i), t = !1; else { l(i) && (o.remove(i), i = void 0); let c = this.oldPrimitive; l(c) && (o.remove(c), this.oldPrimitive = void 0) } this.attributes.removeAll(), this.primitive = i, this.createPrimitive = !1, this.waitingOnCreate = !0 } else if (l(i) && i.ready) { i.show = !0, l(this.oldPrimitive) && (o.remove(this.oldPrimitive), this.oldPrimitive = void 0); let s = this.updatersWithAttributes.values, a = s.length, c = this.waitingOnCreate; for (r = 0; r < a; r++) { let u = s[r], f = this.geometry.get(u.id), d = this.attributes.get(f.id.id); if (l(d) || (d = i.getGeometryInstanceAttributes(f.id), this.attributes.set(f.id.id, d)), !u.outlineColorProperty.isConstant || c) { let C = u.outlineColorProperty, x = j.getValueOrDefault(C, e, U.WHITE, NWe); U.equals(d._lastColor, x) || (d._lastColor = U.clone(x, d._lastColor), d.color = Bt.toValue(x, d.color), (this.translucent && d.color[3] === 255 || !this.translucent && d.color[3] !== 255) && (this.itemsToRemove[n++] = u)) } let p = u.entity.isShowing && (u.hasConstantOutline || u.isOutlineVisible(e)), g = d.show[0] === 1; p !== g && (d.show = fn.toValue(p, d.show)); let m = u.distanceDisplayConditionProperty; if (!j.isConstant(m)) { let C = j.getValueOrDefault(m, e, kWe, VWe); bt.equals(C, d._lastDistanceDisplayCondition) || (d._lastDistanceDisplayCondition = bt.clone(C, d._lastDistanceDisplayCondition), d.distanceDisplayCondition = Mn.toValue(C, d.distanceDisplayCondition)) } let A = u.terrainOffsetProperty; if (!j.isConstant(A)) { let C = j.getValueOrDefault(A, e, UWe, zWe); h.equals(C, d._lastOffset) || (d._lastOffset = h.clone(C, d._lastOffset), d.offset = zi.toValue(C, d.offset)) } } this.updateShows(i), this.waitingOnCreate = !1 } else l(i) && !i.ready && (t = !1); return this.itemsToRemove.length = n, t }; np.prototype.updateShows = function (e) { let t = this.showsUpdated.values, n = t.length; for (let i = 0; i < n; i++) { let o = t[i], r = this.geometry.get(o.id), s = this.attributes.get(r.id.id); l(s) || (s = e.getGeometryInstanceAttributes(r.id), this.attributes.set(r.id.id, s)); let a = o.entity.isShowing, c = s.show[0] === 1; a !== c && (s.show = fn.toValue(a, s.show), r.attributes.show.value[0] = s.show[0]) } this.showsUpdated.removeAll() }; np.prototype.contains = function (e) { return this.updaters.contains(e.id) }; np.prototype.getBoundingSphere = function (e, t) { let n = this.primitive; if (!n.ready) return rt.PENDING; let i = n.getGeometryInstanceAttributes(e.entity); return !l(i) || !l(i.boundingSphere) || l(i.show) && i.show[0] === 0 ? rt.FAILED : (i.boundingSphere.clone(t), rt.DONE) }; np.prototype.removeAllPrimitives = function () { let e = this.primitives, t = this.primitive; l(t) && (e.remove(t), this.primitive = void 0, this.geometry.removeAll(), this.updaters.removeAll()); let n = this.oldPrimitive; l(n) && (e.remove(n), this.oldPrimitive = void 0) }; function PT(e, t, n) { this._primitives = e, this._scene = t, this._shadows = n, this._solidBatches = new Ct, this._translucentBatches = new Ct } PT.prototype.add = function (e, t) { let n = t.createOutlineGeometryInstance(e), i = this._scene.clampLineWidth(t.outlineWidth), o, r; n.attributes.color.value[3] === 255 ? (o = this._solidBatches, r = o.get(i), l(r) || (r = new np(this._primitives, !1, i, this._shadows), o.set(i, r)), r.add(t, n)) : (o = this._translucentBatches, r = o.get(i), l(r) || (r = new np(this._primitives, !0, i, this._shadows), o.set(i, r)), r.add(t, n)) }; PT.prototype.remove = function (e) { let t, n = this._solidBatches.values, i = n.length; for (t = 0; t < i; t++)if (n[t].remove(e)) return; let o = this._translucentBatches.values, r = o.length; for (t = 0; t < r; t++)if (o[t].remove(e)) return }; PT.prototype.update = function (e) { let t, n, i, o, r = this._solidBatches.values, s = r.length, a = this._translucentBatches.values, c = a.length, u, f = !0, d = !1; do { for (d = !1, n = 0; n < s; n++) { o = r[n], f = o.update(e), u = o.itemsToRemove; let p = u.length; if (p > 0) for (d = !0, t = 0; t < p; t++)i = u[t], o.remove(i), this.add(e, i) } for (n = 0; n < c; n++) { o = a[n], f = o.update(e), u = o.itemsToRemove; let p = u.length; if (p > 0) for (d = !0, t = 0; t < p; t++)i = u[t], o.remove(i), this.add(e, i) } } while (d); return f }; PT.prototype.getBoundingSphere = function (e, t) { let n, i = this._solidBatches.values, o = i.length; for (n = 0; n < o; n++) { let a = i[n]; if (a.contains(e)) return a.getBoundingSphere(e, t) } let r = this._translucentBatches.values, s = r.length; for (n = 0; n < s; n++) { let a = r[n]; if (a.contains(e)) return a.getBoundingSphere(e, t) } return rt.FAILED }; PT.prototype.removeAllPrimitives = function () { let e, t = this._solidBatches.values, n = t.length; for (e = 0; e < n; e++)t[e].removeAllPrimitives(); let i = this._translucentBatches.values, o = i.length; for (e = 0; e < o; e++)i[e].removeAllPrimitives() }; var Jw = PT; var hae = {}; function HWe(e, t) { return I.equalsEpsilon(e.latitude, t.latitude, I.EPSILON10) && I.equalsEpsilon(e.longitude, t.longitude, I.EPSILON10) } var GWe = new he, WWe = new he; function jWe(e, t, n, i) { t = _o(t, h.equalsEpsilon); let o = t.length; if (o < 2) return; let r = l(i), s = l(n), a = new Array(o), c = new Array(o), u = new Array(o), f = t[0]; a[0] = f; let d = e.cartesianToCartographic(f, GWe); s && (d.height = n[0]), c[0] = d.height, r ? u[0] = i[0] : u[0] = 0; let p = c[0], g = u[0], m = p === g, A = 1; for (let C = 1; C < o; ++C) { let x = t[C], T = e.cartesianToCartographic(x, WWe); s && (T.height = n[C]), m = m && T.height === 0, HWe(d, T) ? d.height < T.height && (c[A - 1] = T.height) : (a[A] = x, c[A] = T.height, r ? u[A] = i[C] : u[A] = 0, m = m && c[A] === u[A], he.clone(T, d), ++A) } if (!(m || A < 2)) return a.length = A, c.length = A, u.length = A, { positions: a, topHeights: c, bottomHeights: u } } var qWe = new Array(2), YWe = new Array(2), XWe = { positions: void 0, height: void 0, granularity: void 0, ellipsoid: void 0 }; hae.computePositions = function (e, t, n, i, o, r) { let s = jWe(e, t, n, i); if (!l(s)) return; t = s.positions, n = s.topHeights, i = s.bottomHeights; let a = t.length, c = a - 2, u, f, d = I.chordLength(o, e.maximumRadius), p = XWe; if (p.minDistance = d, p.ellipsoid = e, r) { let g = 0, m; for (m = 0; m < a - 1; m++)g += xi.numberOfPoints(t[m], t[m + 1], d) + 1; u = new Float64Array(g * 3), f = new Float64Array(g * 3); let A = qWe, C = YWe; p.positions = A, p.height = C; let x = 0; for (m = 0; m < a - 1; m++) { A[0] = t[m], A[1] = t[m + 1], C[0] = n[m], C[1] = n[m + 1]; let T = xi.generateArc(p); u.set(T, x), C[0] = i[m], C[1] = i[m + 1], f.set(xi.generateArc(p), x), x += T.length } } else p.positions = t, p.height = n, u = new Float64Array(xi.generateArc(p)), p.height = i, f = new Float64Array(xi.generateArc(p)); return { bottomPositions: f, topPositions: u, numCorners: c } }; var IT = hae; var Q6 = new h, wN = new h, KWe = new h, mae = new h, JWe = new h, ZWe = new h, QWe = new h; function Py(e) { e = y(e, y.EMPTY_OBJECT); let t = e.positions, n = e.maximumHeights, i = e.minimumHeights, o = y(e.vertexFormat, we.DEFAULT), r = y(e.granularity, I.RADIANS_PER_DEGREE), s = y(e.ellipsoid, ie.WGS84); this._positions = t, this._minimumHeights = i, this._maximumHeights = n, this._vertexFormat = we.clone(o), this._granularity = r, this._ellipsoid = ie.clone(s), this._workerName = "createWallGeometry"; let a = 1 + t.length * h.packedLength + 2; l(i) && (a += i.length), l(n) && (a += n.length), this.packedLength = a + ie.packedLength + we.packedLength + 1 } Py.pack = function (e, t, n) { n = y(n, 0); let i, o = e._positions, r = o.length; for (t[n++] = r, i = 0; i < r; ++i, n += h.packedLength)h.pack(o[i], t, n); let s = e._minimumHeights; if (r = l(s) ? s.length : 0, t[n++] = r, l(s)) for (i = 0; i < r; ++i)t[n++] = s[i]; let a = e._maximumHeights; if (r = l(a) ? a.length : 0, t[n++] = r, l(a)) for (i = 0; i < r; ++i)t[n++] = a[i]; return ie.pack(e._ellipsoid, t, n), n += ie.packedLength, we.pack(e._vertexFormat, t, n), n += we.packedLength, t[n] = e._granularity, t }; var pae = ie.clone(ie.UNIT_SPHERE), _ae = new we, Zw = { positions: void 0, minimumHeights: void 0, maximumHeights: void 0, ellipsoid: pae, vertexFormat: _ae, granularity: void 0 }; Py.unpack = function (e, t, n) { t = y(t, 0); let i, o = e[t++], r = new Array(o); for (i = 0; i < o; ++i, t += h.packedLength)r[i] = h.unpack(e, t); o = e[t++]; let s; if (o > 0) for (s = new Array(o), i = 0; i < o; ++i)s[i] = e[t++]; o = e[t++]; let a; if (o > 0) for (a = new Array(o), i = 0; i < o; ++i)a[i] = e[t++]; let c = ie.unpack(e, t, pae); t += ie.packedLength; let u = we.unpack(e, t, _ae); t += we.packedLength; let f = e[t]; return l(n) ? (n._positions = r, n._minimumHeights = s, n._maximumHeights = a, n._ellipsoid = ie.clone(c, n._ellipsoid), n._vertexFormat = we.clone(u, n._vertexFormat), n._granularity = f, n) : (Zw.positions = r, Zw.minimumHeights = s, Zw.maximumHeights = a, Zw.granularity = f, new Py(Zw)) }; Py.fromConstantHeights = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.positions, n, i, o = e.minimumHeight, r = e.maximumHeight, s = l(o), a = l(r); if (s || a) { let u = t.length; n = s ? new Array(u) : void 0, i = a ? new Array(u) : void 0; for (let f = 0; f < u; ++f)s && (n[f] = o), a && (i[f] = r) } let c = { positions: t, maximumHeights: i, minimumHeights: n, ellipsoid: e.ellipsoid, vertexFormat: e.vertexFormat }; return new Py(c) }; Py.createGeometry = function (e) { let t = e._positions, n = e._minimumHeights, i = e._maximumHeights, o = e._vertexFormat, r = e._granularity, s = e._ellipsoid, a = IT.computePositions(s, t, i, n, r, !0); if (!l(a)) return; let c = a.bottomPositions, u = a.topPositions, f = a.numCorners, d = u.length, p = d * 2, g = o.position ? new Float64Array(p) : void 0, m = o.normal ? new Float32Array(p) : void 0, A = o.tangent ? new Float32Array(p) : void 0, C = o.bitangent ? new Float32Array(p) : void 0, x = o.st ? new Float32Array(p / 3 * 2) : void 0, T = 0, b = 0, S = 0, D = 0, P = 0, B = QWe, R = ZWe, M = JWe, L = !0; d /= 3; let _, E = 0, w = 1 / (d - f - 1); for (_ = 0; _ < d; ++_) { let k = _ * 3, G = h.fromArray(u, k, Q6), N = h.fromArray(c, k, wN); if (o.position && (g[T++] = N.x, g[T++] = N.y, g[T++] = N.z, g[T++] = G.x, g[T++] = G.y, g[T++] = G.z), o.st && (x[P++] = E, x[P++] = 0, x[P++] = E, x[P++] = 1), o.normal || o.tangent || o.bitangent) { let X = h.clone(h.ZERO, mae), q = h.subtract(G, s.geodeticSurfaceNormal(G, wN), wN); if (_ + 1 < d && (X = h.fromArray(u, k + 3, mae)), L) { let J = h.subtract(X, G, KWe), W = h.subtract(q, G, Q6); B = h.normalize(h.cross(W, J, B), B), L = !1 } h.equalsEpsilon(G, X, I.EPSILON10) ? L = !0 : (E += w, o.tangent && (R = h.normalize(h.subtract(X, G, R), R)), o.bitangent && (M = h.normalize(h.cross(B, R, M), M))), o.normal && (m[b++] = B.x, m[b++] = B.y, m[b++] = B.z, m[b++] = B.x, m[b++] = B.y, m[b++] = B.z), o.tangent && (A[D++] = R.x, A[D++] = R.y, A[D++] = R.z, A[D++] = R.x, A[D++] = R.y, A[D++] = R.z), o.bitangent && (C[S++] = M.x, C[S++] = M.y, C[S++] = M.z, C[S++] = M.x, C[S++] = M.y, C[S++] = M.z) } } let v = new sn; o.position && (v.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: g })), o.normal && (v.normal = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: m })), o.tangent && (v.tangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: A })), o.bitangent && (v.bitangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: C })), o.st && (v.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: x })); let O = p / 3; p -= 6 * (f + 1); let V = Me.createTypedArray(O, p), z = 0; for (_ = 0; _ < O - 2; _ += 2) { let k = _, G = _ + 2, N = h.fromArray(g, k * 3, Q6), X = h.fromArray(g, G * 3, wN); if (h.equalsEpsilon(N, X, I.EPSILON10)) continue; let q = _ + 1, J = _ + 3; V[z++] = q, V[z++] = k, V[z++] = J, V[z++] = J, V[z++] = k, V[z++] = G } return new st({ attributes: v, indices: V, primitiveType: Oe.TRIANGLES, boundingSphere: new re.fromVertices(g) }) }; var DN = Py; var gae = new h, yae = new h; function Iy(e) { e = y(e, y.EMPTY_OBJECT); let t = e.positions, n = e.maximumHeights, i = e.minimumHeights, o = y(e.granularity, I.RADIANS_PER_DEGREE), r = y(e.ellipsoid, ie.WGS84); this._positions = t, this._minimumHeights = i, this._maximumHeights = n, this._granularity = o, this._ellipsoid = ie.clone(r), this._workerName = "createWallOutlineGeometry"; let s = 1 + t.length * h.packedLength + 2; l(i) && (s += i.length), l(n) && (s += n.length), this.packedLength = s + ie.packedLength + 1 } Iy.pack = function (e, t, n) { n = y(n, 0); let i, o = e._positions, r = o.length; for (t[n++] = r, i = 0; i < r; ++i, n += h.packedLength)h.pack(o[i], t, n); let s = e._minimumHeights; if (r = l(s) ? s.length : 0, t[n++] = r, l(s)) for (i = 0; i < r; ++i)t[n++] = s[i]; let a = e._maximumHeights; if (r = l(a) ? a.length : 0, t[n++] = r, l(a)) for (i = 0; i < r; ++i)t[n++] = a[i]; return ie.pack(e._ellipsoid, t, n), n += ie.packedLength, t[n] = e._granularity, t }; var Aae = ie.clone(ie.UNIT_SPHERE), Qw = { positions: void 0, minimumHeights: void 0, maximumHeights: void 0, ellipsoid: Aae, granularity: void 0 }; Iy.unpack = function (e, t, n) { t = y(t, 0); let i, o = e[t++], r = new Array(o); for (i = 0; i < o; ++i, t += h.packedLength)r[i] = h.unpack(e, t); o = e[t++]; let s; if (o > 0) for (s = new Array(o), i = 0; i < o; ++i)s[i] = e[t++]; o = e[t++]; let a; if (o > 0) for (a = new Array(o), i = 0; i < o; ++i)a[i] = e[t++]; let c = ie.unpack(e, t, Aae); t += ie.packedLength; let u = e[t]; return l(n) ? (n._positions = r, n._minimumHeights = s, n._maximumHeights = a, n._ellipsoid = ie.clone(c, n._ellipsoid), n._granularity = u, n) : (Qw.positions = r, Qw.minimumHeights = s, Qw.maximumHeights = a, Qw.granularity = u, new Iy(Qw)) }; Iy.fromConstantHeights = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.positions, n, i, o = e.minimumHeight, r = e.maximumHeight, s = l(o), a = l(r); if (s || a) { let u = t.length; n = s ? new Array(u) : void 0, i = a ? new Array(u) : void 0; for (let f = 0; f < u; ++f)s && (n[f] = o), a && (i[f] = r) } let c = { positions: t, maximumHeights: i, minimumHeights: n, ellipsoid: e.ellipsoid }; return new Iy(c) }; Iy.createGeometry = function (e) { let t = e._positions, n = e._minimumHeights, i = e._maximumHeights, o = e._granularity, r = e._ellipsoid, s = IT.computePositions(r, t, i, n, o, !1); if (!l(s)) return; let a = s.bottomPositions, c = s.topPositions, u = c.length, f = u * 2, d = new Float64Array(f), p = 0; u /= 3; let g; for (g = 0; g < u; ++g) { let T = g * 3, b = h.fromArray(c, T, gae), S = h.fromArray(a, T, yae); d[p++] = S.x, d[p++] = S.y, d[p++] = S.z, d[p++] = b.x, d[p++] = b.y, d[p++] = b.z } let m = new sn({ position: new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: d }) }), A = f / 3; f = 2 * A - 4 + A; let C = Me.createTypedArray(A, f), x = 0; for (g = 0; g < A - 2; g += 2) { let T = g, b = g + 2, S = h.fromArray(d, T * 3, gae), D = h.fromArray(d, b * 3, yae); if (h.equalsEpsilon(S, D, I.EPSILON10)) continue; let P = g + 1, B = g + 3; C[x++] = P, C[x++] = T, C[x++] = P, C[x++] = B, C[x++] = T, C[x++] = b } return C[x++] = A - 2, C[x++] = A - 1, new st({ attributes: m, indices: C, primitiveType: Oe.LINES, boundingSphere: new re.fromVertices(d) }) }; var vN = Iy; var Cae = new U; function $We(e) { this.id = e, this.vertexFormat = void 0, this.positions = void 0, this.minimumHeights = void 0, this.maximumHeights = void 0, this.granularity = void 0 } function Yf(e, t) { ei.call(this, { entity: e, scene: t, geometryOptions: new $We(e), geometryPropertyName: "wall", observedPropertyNames: ["availability", "wall"] }), this._onEntityPropertyChanged(e, "wall", e.wall, void 0) } l(Object.create) && (Yf.prototype = Object.create(ei.prototype), Yf.prototype.constructor = Yf); Yf.prototype.createFillGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i, o, r = new fn(n && t.isShowing && this._showProperty.getValue(e) && this._fillProperty.getValue(e)), s = this._distanceDisplayConditionProperty.getValue(e), a = Mn.fromDistanceDisplayCondition(s); if (this._materialProperty instanceof Ot) { let c; l(this._materialProperty.color) && (this._materialProperty.color.isConstant || n) && (c = this._materialProperty.color.getValue(e, Cae)), l(c) || (c = U.WHITE), o = Bt.fromColor(c), i = { show: r, distanceDisplayCondition: a, color: o } } else i = { show: r, distanceDisplayCondition: a }; return new At({ id: t, geometry: new DN(this._options), attributes: i }) }; Yf.prototype.createOutlineGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = j.getValueOrDefault(this._outlineColorProperty, e, U.BLACK, Cae), o = this._distanceDisplayConditionProperty.getValue(e); return new At({ id: t, geometry: new vN(this._options), attributes: { show: new fn(n && t.isShowing && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)), color: Bt.fromColor(i), distanceDisplayCondition: Mn.fromDistanceDisplayCondition(o) } }) }; Yf.prototype._isHidden = function (e, t) { return !l(t.positions) || ei.prototype._isHidden.call(this, e, t) }; Yf.prototype._getIsClosed = function (e) { return !1 }; Yf.prototype._isDynamic = function (e, t) { return !t.positions.isConstant || !j.isConstant(t.minimumHeights) || !j.isConstant(t.maximumHeights) || !j.isConstant(t.outlineWidth) || !j.isConstant(t.granularity) }; Yf.prototype._setStaticOptions = function (e, t) { let n = t.minimumHeights, i = t.maximumHeights, o = t.granularity, r = this._materialProperty instanceof Ot, s = this._options; s.vertexFormat = r ? $t.VERTEX_FORMAT : eo.MaterialSupport.TEXTURED.vertexFormat, s.positions = t.positions.getValue(ke.MINIMUM_VALUE, s.positions), s.minimumHeights = l(n) ? n.getValue(ke.MINIMUM_VALUE, s.minimumHeights) : void 0, s.maximumHeights = l(i) ? i.getValue(ke.MINIMUM_VALUE, s.maximumHeights) : void 0, s.granularity = l(o) ? o.getValue(ke.MINIMUM_VALUE) : void 0 }; Yf.DynamicGeometryUpdater = OT; function OT(e, t, n) { $n.call(this, e, t, n) } l(Object.create) && (OT.prototype = Object.create($n.prototype), OT.prototype.constructor = OT); OT.prototype._isHidden = function (e, t, n) { return !l(this._options.positions) || $n.prototype._isHidden.call(this, e, t, n) }; OT.prototype._setOptions = function (e, t, n) { let i = this._options; i.positions = j.getValueOrUndefined(t.positions, n, i.positions), i.minimumHeights = j.getValueOrUndefined(t.minimumHeights, n, i.minimumHeights), i.maximumHeights = j.getValueOrUndefined(t.maximumHeights, n, i.maximumHeights), i.granularity = j.getValueOrUndefined(t.granularity, n) }; var PN = Yf; var e7e = [], xae = [bB, VF, IF, sN, aN, hN, yN, xN, TN, PN]; function $w(e, t) { this.entity = e, this.scene = t; let n = new Array(xae.length), i = new _e; function o(s) { i.raiseEvent(s) } let r = new Pr; for (let s = 0; s < n.length; s++) { let a = new xae[s](e, t); r.add(a.geometryChanged, o), n[s] = a } this.updaters = n, this.geometryChanged = i, this.eventHelper = r, this._removeEntitySubscription = e.definitionChanged.addEventListener($w.prototype._onEntityPropertyChanged, this) } $w.prototype._onEntityPropertyChanged = function (e, t, n, i) { let o = this.updaters; for (let r = 0; r < o.length; r++)o[r]._onEntityPropertyChanged(e, t, n, i) }; $w.prototype.forEach = function (e) { let t = this.updaters; for (let n = 0; n < t.length; n++)e(t[n]) }; $w.prototype.destroy = function () { this.eventHelper.removeAll(); let e = this.updaters; for (let t = 0; t < e.length; t++)e[t].destroy(); this._removeEntitySubscription(), le(this) }; function Nu(e, t, n, i) { n = y(n, e.primitives), i = y(i, e.groundPrimitives), this._scene = e, this._primitives = n, this._groundPrimitives = i, this._entityCollection = void 0, this._addedObjects = new Ct, this._removedObjects = new Ct, this._changedObjects = new Ct; let o = hn.NUMBER_OF_SHADOW_MODES; this._outlineBatches = new Array(o * 2), this._closedColorBatches = new Array(o * 2), this._closedMaterialBatches = new Array(o * 2), this._openColorBatches = new Array(o * 2), this._openMaterialBatches = new Array(o * 2); let r = Xo.supportsMaterialsforEntitiesOnTerrain(e); this._supportsMaterialsforEntitiesOnTerrain = r; let s; for (s = 0; s < o; ++s)this._outlineBatches[s] = new Jw(n, e, s, !1), this._outlineBatches[o + s] = new Jw(n, e, s, !0), this._closedColorBatches[s] = new Wf(n, $t, void 0, !0, s, !0), this._closedColorBatches[o + s] = new Wf(n, $t, void 0, !0, s, !1), this._closedMaterialBatches[s] = new qf(n, eo, void 0, !0, s, !0), this._closedMaterialBatches[o + s] = new qf(n, eo, void 0, !0, s, !1), this._openColorBatches[s] = new Wf(n, $t, void 0, !1, s, !0), this._openColorBatches[o + s] = new Wf(n, $t, void 0, !1, s, !1), this._openMaterialBatches[s] = new qf(n, eo, void 0, !1, s, !0), this._openMaterialBatches[o + s] = new qf(n, eo, void 0, !1, s, !1); let a = Ln.NUMBER_OF_CLASSIFICATION_TYPES, c = new Array(a), u = []; if (r) for (s = 0; s < a; ++s)u.push(new SN(i, s, eo)), c[s] = new Kw(i, s); else for (s = 0; s < a; ++s)c[s] = new Kw(i, s); this._groundColorBatches = c, this._groundMaterialBatches = u, this._dynamicBatch = new aT(n, i), this._batches = this._outlineBatches.concat(this._closedColorBatches, this._closedMaterialBatches, this._openColorBatches, this._openMaterialBatches, this._groundColorBatches, this._groundMaterialBatches, this._dynamicBatch), this._subscriptions = new Ct, this._updaterSets = new Ct, this._entityCollection = t, t.collectionChanged.addEventListener(Nu.prototype._onCollectionChanged, this), this._onCollectionChanged(t, t.values, e7e) } Nu.prototype.update = function (e) { let t = this._addedObjects, n = t.values, i = this._removedObjects, o = i.values, r = this._changedObjects, s = r.values, a, c, u, f, d = this; for (a = s.length - 1; a > -1; a--)c = s[a], u = c.id, f = this._updaterSets.get(u), f.entity === c ? f.forEach(function (A) { d._removeUpdater(A), d._insertUpdaterIntoBatch(e, A) }) : (o.push(c), n.push(c)); for (a = o.length - 1; a > -1; a--)c = o[a], u = c.id, f = this._updaterSets.get(u), f.forEach(this._removeUpdater.bind(this)), f.destroy(), this._updaterSets.remove(u), this._subscriptions.get(u)(), this._subscriptions.remove(u); for (a = n.length - 1; a > -1; a--)c = n[a], u = c.id, f = new $w(c, this._scene), this._updaterSets.set(u, f), f.forEach(function (A) { d._insertUpdaterIntoBatch(e, A) }), this._subscriptions.set(u, f.geometryChanged.addEventListener(Nu._onGeometryChanged, this)); t.removeAll(), i.removeAll(), r.removeAll(); let p = !0, g = this._batches, m = g.length; for (a = 0; a < m; a++)p = g[a].update(e) && p; return p }; var t7e = [], n7e = new re; Nu.prototype.getBoundingSphere = function (e, t) { let n = t7e, i = n7e, o = 0, r = rt.DONE, s = this._batches, a = s.length, c = e.id, u = this._updaterSets.get(c).updaters; for (let f = 0; f < u.length; f++) { let d = u[f]; for (let p = 0; p < a; p++) { if (r = s[p].getBoundingSphere(d, i), r === rt.PENDING) return rt.PENDING; r === rt.DONE && (n[o] = re.clone(i, n[o]), o++) } } return o === 0 ? rt.FAILED : (n.length = o, re.fromBoundingSpheres(n, t), rt.DONE) }; Nu.prototype.isDestroyed = function () { return !1 }; Nu.prototype.destroy = function () { this._entityCollection.collectionChanged.removeEventListener(Nu.prototype._onCollectionChanged, this), this._addedObjects.removeAll(), this._removedObjects.removeAll(); let e, t = this._batches, n = t.length; for (e = 0; e < n; e++)t[e].removeAllPrimitives(); let i = this._subscriptions.values; for (n = i.length, e = 0; e < n; e++)i[e](); this._subscriptions.removeAll(); let o = this._updaterSets.values; for (n = o.length, e = 0; e < n; e++)o[e].destroy(); return this._updaterSets.removeAll(), le(this) }; Nu.prototype._removeUpdater = function (e) { let t = this._batches, n = t.length; for (let i = 0; i < n; i++)t[i].remove(e) }; Nu.prototype._insertUpdaterIntoBatch = function (e, t) { if (t.isDynamic) { this._dynamicBatch.add(e, t); return } let n; (t.outlineEnabled || t.fillEnabled) && (n = t.shadowsProperty.getValue(e)); let i = hn.NUMBER_OF_SHADOW_MODES; if (t.outlineEnabled && (l(t.terrainOffsetProperty) ? this._outlineBatches[i + n].add(e, t) : this._outlineBatches[n].add(e, t)), t.fillEnabled) if (t.onTerrain) { let o = t.classificationTypeProperty.getValue(e); t.fillMaterialProperty instanceof Ot ? this._groundColorBatches[o].add(e, t) : this._groundMaterialBatches[o].add(e, t) } else t.isClosed ? t.fillMaterialProperty instanceof Ot ? l(t.terrainOffsetProperty) ? this._closedColorBatches[i + n].add(e, t) : this._closedColorBatches[n].add(e, t) : l(t.terrainOffsetProperty) ? this._closedMaterialBatches[i + n].add(e, t) : this._closedMaterialBatches[n].add(e, t) : t.fillMaterialProperty instanceof Ot ? l(t.terrainOffsetProperty) ? this._openColorBatches[i + n].add(e, t) : this._openColorBatches[n].add(e, t) : l(t.terrainOffsetProperty) ? this._openMaterialBatches[i + n].add(e, t) : this._openMaterialBatches[n].add(e, t) }; Nu._onGeometryChanged = function (e) { let t = this._removedObjects, n = this._changedObjects, i = e.entity, o = i.id; !l(t.get(o)) && !l(n.get(o)) && n.set(o, i) }; Nu.prototype._onCollectionChanged = function (e, t, n) { let i = this._addedObjects, o = this._removedObjects, r = this._changedObjects, s, a, c; for (s = n.length - 1; s > -1; s--)c = n[s], a = c.id, i.remove(a) || (o.set(a, c), r.remove(a)); for (s = t.length - 1; s > -1; s--)c = t[s], a = c.id, o.remove(a) ? r.set(a, c) : i.set(a, c) }; var IN = Nu; var i7e = 1, o7e = "30px sans-serif", r7e = Fo.FILL, s7e = U.WHITE, a7e = U.BLACK, c7e = 1, l7e = !1, u7e = new U(.165, .165, .165, .8), f7e = new H(7, 5), d7e = H.ZERO, h7e = h.ZERO, m7e = ze.NONE, p7e = ai.CENTER, _7e = Sn.CENTER, g7e = new h, y7e = new U, A7e = new U, C7e = new U, x7e = new H, T7e = new h, E7e = new H, b7e = new wt, S7e = new wt, w7e = new wt, D7e = new bt; function Tae(e) { this.entity = e, this.label = void 0, this.index = void 0 } function og(e, t) { t.collectionChanged.addEventListener(og.prototype._onCollectionChanged, this), this._cluster = e, this._entityCollection = t, this._items = new Ct, this._onCollectionChanged(t, t.values, [], []) } og.prototype.update = function (e) { let t = this._items.values, n = this._cluster; for (let i = 0, o = t.length; i < o; i++) { let r = t[i], s = r.entity, a = s._label, c, u = r.label, f = s.isShowing && s.isAvailable(e) && j.getValueOrDefault(a._show, e, !0), d; if (f && (d = j.getValueOrUndefined(s._position, e, g7e), c = j.getValueOrUndefined(a._text, e), f = l(d) && l(c)), !f) { $6(r, s, n); continue } j.isConstant(s._position) || (n._clusterDirty = !0); let p = !1, g = j.getValueOrDefault(a._heightReference, e, m7e); l(u) || (u = n.getLabel(s), u.id = s, r.label = u, p = h.equals(u.position, d) && u.heightReference === g), u.show = !0, u.position = d, u.text = c, u.scale = j.getValueOrDefault(a._scale, e, i7e), u.font = j.getValueOrDefault(a._font, e, o7e), u.style = j.getValueOrDefault(a._style, e, r7e), u.fillColor = j.getValueOrDefault(a._fillColor, e, s7e, y7e), u.outlineColor = j.getValueOrDefault(a._outlineColor, e, a7e, A7e), u.outlineWidth = j.getValueOrDefault(a._outlineWidth, e, c7e), u.showBackground = j.getValueOrDefault(a._showBackground, e, l7e), u.backgroundColor = j.getValueOrDefault(a._backgroundColor, e, u7e, C7e), u.backgroundPadding = j.getValueOrDefault(a._backgroundPadding, e, f7e, x7e), u.pixelOffset = j.getValueOrDefault(a._pixelOffset, e, d7e, E7e), u.eyeOffset = j.getValueOrDefault(a._eyeOffset, e, h7e, T7e), u.heightReference = g, u.horizontalOrigin = j.getValueOrDefault(a._horizontalOrigin, e, p7e), u.verticalOrigin = j.getValueOrDefault(a._verticalOrigin, e, _7e), u.translucencyByDistance = j.getValueOrUndefined(a._translucencyByDistance, e, b7e), u.pixelOffsetScaleByDistance = j.getValueOrUndefined(a._pixelOffsetScaleByDistance, e, S7e), u.scaleByDistance = j.getValueOrUndefined(a._scaleByDistance, e, w7e), u.distanceDisplayCondition = j.getValueOrUndefined(a._distanceDisplayCondition, e, D7e), u.disableDepthTestDistance = j.getValueOrUndefined(a._disableDepthTestDistance, e), p && u._updateClamping() } return !0 }; og.prototype.getBoundingSphere = function (e, t) { let n = this._items.get(e.id); if (!l(n) || !l(n.label)) return rt.FAILED; let i = n.label; return t.center = h.clone(y(i._clampedPosition, i.position), t.center), t.radius = 0, rt.DONE }; og.prototype.isDestroyed = function () { return !1 }; og.prototype.destroy = function () { this._entityCollection.collectionChanged.removeEventListener(og.prototype._onCollectionChanged, this); let e = this._entityCollection.values; for (let t = 0; t < e.length; t++)this._cluster.removeLabel(e[t]); return le(this) }; og.prototype._onCollectionChanged = function (e, t, n, i) { let o, r, s = this._items, a = this._cluster; for (o = t.length - 1; o > -1; o--)r = t[o], l(r._label) && l(r._position) && s.set(r.id, new Tae(r)); for (o = i.length - 1; o > -1; o--)r = i[o], l(r._label) && l(r._position) ? s.contains(r.id) || s.set(r.id, new Tae(r)) : ($6(s.get(r.id), r, a), s.remove(r.id)); for (o = n.length - 1; o > -1; o--)r = n[o], $6(s.get(r.id), r, a), s.remove(r.id) }; function $6(e, t, n) { l(e) && (e.label = void 0, n.removeLabel(t)) } var ON = og; function v7e(e, t, n) { return e.readyPromise.then(function () { return O7e(e, t, n) }) } function P7e(e, t) { let n = e[0], i = n.terrainProvider.requestTileGeometry(n.x, n.y, n.level); if (!i) return !1; let o = i.then(B7e(n)).catch(R7e(n)); return e.shift(), t.push(o), !0 } function I7e(e) { return new Promise(function (t) { setTimeout(t, e) }) } function e9(e, t) { return e.length ? P7e(e, t) ? e9(e, t) : I7e(100).then(() => e9(e, t)) : Promise.resolve() } function O7e(e, t, n) { let i = e.tilingScheme, o, r = [], s = {}; for (o = 0; o < n.length; ++o) { let c = i.positionToTileXY(n[o], t), u = c.toString(); if (!s.hasOwnProperty(u)) { let f = { x: c.x, y: c.y, level: t, tilingScheme: i, terrainProvider: e, positions: [] }; s[u] = f, r.push(f) } s[u].positions.push(n[o]) } let a = []; return e9(r, a).then(function () { return Promise.all(a).then(function () { return n }) }) } function Eae(e, t, n) { let i = t.interpolateHeight(n, e.longitude, e.latitude); return i === void 0 ? !1 : (e.height = i, !0) } function B7e(e) { let t = e.positions, n = e.tilingScheme.tileXYToRectangle(e.x, e.y, e.level); return function (i) { let o = !1; for (let r = 0; r < t.length; ++r) { let s = t[r]; if (!Eae(s, i, n)) { o = !0; break } } return o ? i.createMesh({ tilingScheme: e.tilingScheme, x: e.x, y: e.y, level: e.level, throttle: !1 }).then(function () { for (let r = 0; r < t.length; ++r) { let s = t[r]; Eae(s, i, n) } }) : Promise.resolve() } } function R7e(e) { let t = e.positions; return function () { for (let n = 0; n < t.length; ++n) { let i = t[n]; i.height = void 0 } } } var BN = v7e; var t9 = new H; function bae(e, t) { return e.readyPromise.then(function () { let n = [], i = [], o = e.availability, r = []; for (let s = 0; s < t.length; ++s) { let a = t[s], c = o.computeMaximumLevelAtPosition(a); if (i[s] = c, c === 0) { e.tilingScheme.positionToTileXY(a, 1, t9); let f = e.loadTileDataAvailability(t9.x, t9.y, 1); l(f) && r.push(f) } let u = n[c]; l(u) || (n[c] = u = []), u.push(a) } return Promise.all(r).then(function () { return Promise.all(n.map(function (s, a) { if (l(s)) return BN(e, a, s) })) }).then(function () { let s = []; for (let a = 0; a < t.length; ++a) { let c = t[a]; o.computeMaximumLevelAtPosition(c) !== i[a] && s.push(c) } if (s.length > 0) return bae(e, s) }).then(function () { return t }) }) } var rg = bae; var M7e = 1, L7e = 0, F7e = !0, N7e = !0, V7e = hn.ENABLED, k7e = ze.NONE, U7e = U.RED, z7e = 0, H7e = U.WHITE, G7e = oc.HIGHLIGHT, W7e = .5, j7e = new H(1, 1), q7e = new F, Y7e = new F, Sae = new U; function ph(e, t) { t.collectionChanged.addEventListener(ph.prototype._onCollectionChanged, this), this._scene = e, this._primitives = e.primitives, this._entityCollection = t, this._modelHash = {}, this._entitiesToVisualize = new Ct, this._onCollectionChanged(t, t.values, [], []) } ph.prototype.update = function (e) { let t = this._entitiesToVisualize.values, n = this._modelHash, i = this._primitives; for (let o = 0, r = t.length; o < r; o++) { let s = t[o], a = s._model, c, u = n[s.id], f = s.isShowing && s.isAvailable(e) && j.getValueOrDefault(a._show, e, !0), d; if (f && (d = s.computeModelMatrix(e, q7e), c = Pe.createIfNeeded(j.getValueOrUndefined(a._uri, e)), f = l(d) && l(c)), !f) { l(u) && (u.modelPrimitive.show = !1); continue } let p = l(u) ? u.modelPrimitive : void 0; if ((!l(p) || c.url !== u.url) && (l(p) && (i.removeAndDestroy(p), delete n[s.id]), p = Jd.fromGltf({ url: c, incrementallyLoadTextures: j.getValueOrDefault(a._incrementallyLoadTextures, e, F7e), scene: this._scene }), p.id = s, i.add(p), u = { modelPrimitive: p, url: c.url, animationsRunning: !1, nodeTransformationsScratch: {}, articulationsScratch: {}, loadFail: !1, awaitingSampleTerrain: !1, clampedBoundingSphere: void 0, sampleTerrainFailed: !1 }, n[s.id] = u, K7e(p, s, n)), p.show = !0, p.scale = j.getValueOrDefault(a._scale, e, M7e), p.minimumPixelSize = j.getValueOrDefault(a._minimumPixelSize, e, L7e), p.maximumScale = j.getValueOrUndefined(a._maximumScale, e), p.modelMatrix = F.clone(d, p.modelMatrix), p.shadows = j.getValueOrDefault(a._shadows, e, V7e), p.heightReference = j.getValueOrDefault(a._heightReference, e, k7e), p.distanceDisplayCondition = j.getValueOrUndefined(a._distanceDisplayCondition, e), p.silhouetteColor = j.getValueOrDefault(a._silhouetteColor, e, U7e, Sae), p.silhouetteSize = j.getValueOrDefault(a._silhouetteSize, e, z7e), p.color = j.getValueOrDefault(a._color, e, H7e, Sae), p.colorBlendMode = j.getValueOrDefault(a._colorBlendMode, e, G7e), p.colorBlendAmount = j.getValueOrDefault(a._colorBlendAmount, e, W7e), p.clippingPlanes = j.getValueOrUndefined(a._clippingPlanes, e), p.clampAnimations = j.getValueOrDefault(a._clampAnimations, e, N7e), p.imageBasedLighting.imageBasedLightingFactor = j.getValueOrDefault(a._imageBasedLightingFactor, e, j7e), p.lightColor = j.getValueOrUndefined(a._lightColor, e), p.customShader = j.getValueOrUndefined(a._customShader, e), p.ready) { let g = j.getValueOrDefault(a._runAnimations, e, !0); u.animationsRunning !== g && (g ? p.activeAnimations.addAll({ loop: ic.REPEAT }) : p.activeAnimations.removeAll(), u.animationsRunning = g); let m = j.getValueOrUndefined(a._nodeTransformations, e, u.nodeTransformationsScratch); if (l(m)) { let x = Object.keys(m); for (let T = 0, b = x.length; T < b; ++T) { let S = x[T], D = m[S]; if (!l(D)) continue; let P = p.getNode(S); if (!l(P)) continue; let B = F.fromTranslationRotationScale(D, Y7e); P.matrix = F.multiply(P.originalMatrix, B, B) } } let A = !1, C = j.getValueOrUndefined(a._articulations, e, u.articulationsScratch); if (l(C)) { let x = Object.keys(C); for (let T = 0, b = x.length; T < b; ++T) { let S = x[T], D = C[S]; !l(D) || (A = !0, p.setArticulationStage(S, D)) } } A && p.applyArticulations() } } return !0 }; ph.prototype.isDestroyed = function () { return !1 }; ph.prototype.destroy = function () { this._entityCollection.collectionChanged.removeEventListener(ph.prototype._onCollectionChanged, this); let e = this._entitiesToVisualize.values, t = this._modelHash, n = this._primitives; for (let i = e.length - 1; i > -1; i--)n9(this, e[i], t, n); return le(this) }; ph._sampleTerrainMostDetailed = rg; var BT = new h, wae = new he; ph.prototype.getBoundingSphere = function (e, t) { let n = this._modelHash[e.id]; if (!l(n) || n.loadFail) return rt.FAILED; let i = n.modelPrimitive; if (!l(i) || !i.show) return rt.FAILED; if (!i.ready) return rt.PENDING; let r = this._scene.globe, s = r.ellipsoid, a = r.terrainProvider; if (i.heightReference !== ze.NONE) { if (!a.ready) return rt.PENDING; let u = i.modelMatrix; BT.x = u[12], BT.y = u[13], BT.z = u[14]; let f = s.cartesianToCartographic(BT); if (!l(a.availability)) { i.heightReference === ze.CLAMP_TO_GROUND && (f.height = 0); let g = s.cartographicToCartesian(f); return re.clone(i.boundingSphere, t), t.center = g, rt.DONE } let d = this._modelHash[e.id].clampedBoundingSphere; return this._modelHash[e.id].sampleTerrainFailed ? (this._modelHash[e.id].sampleTerrainFailed = !1, rt.FAILED) : l(d) ? (re.clone(d, t), this._modelHash[e.id].clampedBoundingSphere = void 0, rt.DONE) : (d = new re, this._modelHash[e.id].awaitingSampleTerrain || (he.clone(f, wae), this._modelHash[e.id].awaitingSampleTerrain = !0, ph._sampleTerrainMostDetailed(a, [wae]).then(m => { this._modelHash[e.id].awaitingSampleTerrain = !1; let A = m[0]; i.heightReference === ze.RELATIVE_TO_GROUND && (A.height += f.height), s.cartographicToCartesian(A, BT), re.clone(i.boundingSphere, d), d.center = BT, this._modelHash[e.id].clampedBoundingSphere = re.clone(d) }).catch(m => { this._modelHash[e.id].sampleTerrainFailed = !0, this._modelHash[e.id].awaitingSampleTerrain = !1 })), rt.PENDING) } return re.clone(i.boundingSphere, t), rt.DONE }; ph.prototype._onCollectionChanged = function (e, t, n, i) { let o, r, s = this._entitiesToVisualize, a = this._modelHash, c = this._primitives; for (o = t.length - 1; o > -1; o--)r = t[o], l(r._model) && l(r._position) && s.set(r.id, r); for (o = i.length - 1; o > -1; o--)r = i[o], l(r._model) && l(r._position) ? (X7e(r, a), s.set(r.id, r)) : (n9(this, r, a, c), s.remove(r.id)); for (o = n.length - 1; o > -1; o--)r = n[o], n9(this, r, a, c), s.remove(r.id) }; function n9(e, t, n, i) { let o = n[t.id]; l(o) && (i.removeAndDestroy(o.modelPrimitive), delete n[t.id]) } function X7e(e, t) { let n = t[e.id]; l(n) && (n.nodeTransformationsScratch = {}, n.articulationsScratch = {}) } function K7e(e, t, n) { e.readyPromise.catch(function (i) { console.error(i), n[t.id].loadFail = !0 }) } var RN = ph; function sg(e) { this._definitionChanged = new _e, this._value = void 0, this._removeSubscription = void 0, this.setValue(e) } Object.defineProperties(sg.prototype, { isConstant: { get: function () { return j.isConstant(this._value) } }, definitionChanged: { get: function () { return this._definitionChanged } }, referenceFrame: { get: function () { return l(this._value) ? this._value.referenceFrame : Ji.FIXED } } }); sg.prototype.getValue = function (e, t) { return this.getValueInReferenceFrame(e, Ji.FIXED, t) }; sg.prototype.setValue = function (e) { this._value !== e && (this._value = e, l(this._removeSubscription) && (this._removeSubscription(), this._removeSubscription = void 0), l(e) && (this._removeSubscription = e.definitionChanged.addEventListener(this._raiseDefinitionChanged, this)), this._definitionChanged.raiseEvent(this)) }; sg.prototype.getValueInReferenceFrame = function (e, t, n) { if (!!l(this._value)) return n = this._value.getValueInReferenceFrame(e, t, n), l(n) ? ie.WGS84.scaleToGeodeticSurface(n, n) : void 0 }; sg.prototype.equals = function (e) { return this === e || e instanceof sg && this._value === e._value }; sg.prototype._raiseDefinitionChanged = function () { this._definitionChanged.raiseEvent(this) }; var ip = sg; var J7e = 60, Z7e = 1, Pae = new yn, i9 = new yn, o9 = new yn; function Dae(e) { this.entity = e, this.polyline = void 0, this.index = void 0, this.updater = void 0 } function Q7e(e, t, n, i, o, r, s, a, c) { let u = a, f; f = e.getValueInReferenceFrame(t, r, c[u]), l(f) && (c[u++] = f); let d = !l(o) || $.lessThanOrEquals(o, t) || $.greaterThanOrEquals(o, n), p = 0, g = i.length, m = i[p], A = n, C = !1, x, T, b; for (; p < g;) { if (!d && $.greaterThanOrEquals(m, o) && (f = e.getValueInReferenceFrame(o, r, c[u]), l(f) && (c[u++] = f), d = !0), $.greaterThan(m, t) && $.lessThan(m, A) && !m.equals(o) && (f = e.getValueInReferenceFrame(m, r, c[u]), l(f) && (c[u++] = f)), p < g - 1) { if (s > 0 && !C) { let S = i[p + 1], D = $.secondsDifference(S, m); C = D > s, C && (x = Math.ceil(D / s), T = 0, b = D / Math.max(x, 2), x = Math.max(x - 1, 1)) } if (C && T < x) { m = $.addSeconds(m, b, new $), T++; continue } } C = !1, p++, m = i[p] } return f = e.getValueInReferenceFrame(n, r, c[u]), l(f) && (c[u++] = f), u } function $7e(e, t, n, i, o, r, s, a) { let c, u = 0, f = s, d = t, p = Math.max(r, 60), g = !l(i) || $.lessThanOrEquals(i, t) || $.greaterThanOrEquals(i, n); for (; $.lessThan(d, n);)!g && $.greaterThanOrEquals(d, i) && (g = !0, c = e.getValueInReferenceFrame(i, o, a[f]), l(c) && (a[f] = c, f++)), c = e.getValueInReferenceFrame(d, o, a[f]), l(c) && (a[f] = c, f++), u++, d = $.addSeconds(t, p * u, new $); return c = e.getValueInReferenceFrame(n, o, a[f]), l(c) && (a[f] = c, f++), f } function eje(e, t, n, i, o, r, s, a) { o9.start = t, o9.stop = n; let c = s, u = e.intervals; for (let f = 0; f < u.length; f++) { let d = u.get(f); if (!yn.intersect(d, o9, Pae).isEmpty) { let p = d.start; d.isStartIncluded || (d.isStopIncluded ? p = d.stop : p = $.addSeconds(d.start, $.secondsDifference(d.stop, d.start) / 2, new $)); let g = e.getValueInReferenceFrame(p, o, a[c]); l(g) && (a[c] = g, c++) } } return c } function tje(e, t, n, i, o, r, s, a) { let c = e.getValueInReferenceFrame(t, o, a[s]); return l(c) && (a[s++] = c), s } function nje(e, t, n, i, o, r, s, a) { i9.start = t, i9.stop = n; let c = s, u = e.intervals; for (let f = 0; f < u.length; f++) { let d = u.get(f); if (!yn.intersect(d, i9, Pae).isEmpty) { let p = d.start, g = d.stop, m = t; $.greaterThan(p, m) && (m = p); let A = n; $.lessThan(g, A) && (A = g), c = Iae(d.data, m, A, i, o, r, c, a) } } return c } function Iae(e, t, n, i, o, r, s, a) { for (; e instanceof K_;)e = e.resolvedProperty; if (e instanceof ea) { let c = e._property._times; s = Q7e(e, t, n, c, i, o, r, s, a) } else e instanceof $s ? s = nje(e, t, n, i, o, r, s, a) : e instanceof Z_ ? s = eje(e, t, n, i, o, r, s, a) : e instanceof Mc || e instanceof ip && j.isConstant(e) ? s = tje(e, t, n, i, o, r, s, a) : s = $7e(e, t, n, i, o, r, s, a); return s } function Oae(e, t, n, i, o, r, s) { l(s) || (s = []); let a = Iae(e, t, n, i, o, r, 0, s); return s.length = a, s } var vae = new Q; function eD(e, t) { this._unusedIndexes = [], this._polylineCollection = new D_, this._scene = e, this._referenceFrame = t, e.primitives.add(this._polylineCollection) } eD.prototype.update = function (e) { if (this._referenceFrame === Ji.INERTIAL) { let t = It.computeIcrfToFixedMatrix(e, vae); l(t) || (t = It.computeTemeToPseudoFixedMatrix(e, vae)), F.fromRotationTranslation(t, h.ZERO, this._polylineCollection.modelMatrix) } }; eD.prototype.updateObject = function (e, t) { let n = t.entity, i = n._path, o = n._position, r, s, a = i._show, c = t.polyline, u = n.isShowing && n.isAvailable(e) && (!l(a) || a.getValue(e)); if (u) { let d = j.getValueOrUndefined(i._leadTime, e), p = j.getValueOrUndefined(i._trailTime, e), g = n._availability, m = l(g), A = l(d), C = l(p); if (u = m || A && C, u) { if (C && (r = $.addSeconds(e, -p, new $)), A && (s = $.addSeconds(e, d, new $)), m) { let x = g.start, T = g.stop; (!C || $.greaterThan(x, r)) && (r = x), (!A || $.lessThan(T, s)) && (s = T) } u = $.lessThan(r, s) } } if (!u) { l(c) && (this._unusedIndexes.push(t.index), t.polyline = void 0, c.show = !1, t.index = void 0); return } if (!l(c)) { let d = this._unusedIndexes; if (d.length > 0) { let g = d.pop(); c = this._polylineCollection.get(g), t.index = g } else t.index = this._polylineCollection.length, c = this._polylineCollection.add(); c.id = n, t.polyline = c } let f = j.getValueOrDefault(i._resolution, e, J7e); c.show = !0, c.positions = Oae(o, r, s, e, this._referenceFrame, f, c.positions.slice()), c.material = Yo.getValue(e, i._material, c.material), c.width = j.getValueOrDefault(i._width, e, Z7e), c.distanceDisplayCondition = j.getValueOrUndefined(i._distanceDisplayCondition, e, c.distanceDisplayCondition) }; eD.prototype.removeObject = function (e) { let t = e.polyline; l(t) && (this._unusedIndexes.push(e.index), e.polyline = void 0, t.show = !1, t.id = void 0, e.index = void 0) }; eD.prototype.destroy = function () { return this._scene.primitives.remove(this._polylineCollection), le(this) }; function ag(e, t) { t.collectionChanged.addEventListener(ag.prototype._onCollectionChanged, this), this._scene = e, this._updaters = {}, this._entityCollection = t, this._items = new Ct, this._onCollectionChanged(t, t.values, [], []) } ag.prototype.update = function (e) { let t = this._updaters; for (let i in t) t.hasOwnProperty(i) && t[i].update(e); let n = this._items.values; if (n.length === 0 && l(this._updaters) && Object.keys(this._updaters).length > 0) { for (let i in t) t.hasOwnProperty(i) && t[i].destroy(); this._updaters = {} } for (let i = 0, o = n.length; i < o; i++) { let r = n[i], a = r.entity._position, c = r.updater, u = Ji.FIXED; this._scene.mode === ee.SCENE3D && (u = a.referenceFrame); let f = this._updaters[u]; if (c === f && l(f)) { f.updateObject(e, r); continue } l(c) && c.removeObject(r), l(f) || (f = new eD(this._scene, u), f.update(e), this._updaters[u] = f), r.updater = f, l(f) && f.updateObject(e, r) } return !0 }; ag.prototype.isDestroyed = function () { return !1 }; ag.prototype.destroy = function () { this._entityCollection.collectionChanged.removeEventListener(ag.prototype._onCollectionChanged, this); let e = this._updaters; for (let t in e) e.hasOwnProperty(t) && e[t].destroy(); return le(this) }; ag.prototype._onCollectionChanged = function (e, t, n, i) { let o, r, s, a = this._items; for (o = t.length - 1; o > -1; o--)r = t[o], l(r._path) && l(r._position) && a.set(r.id, new Dae(r)); for (o = i.length - 1; o > -1; o--)r = i[o], l(r._path) && l(r._position) ? a.contains(r.id) || a.set(r.id, new Dae(r)) : (s = a.get(r.id), l(s) && (l(s.updater) && s.updater.removeObject(s), a.remove(r.id))); for (o = n.length - 1; o > -1; o--)r = n[o], s = a.get(r.id), l(s) && (l(s.updater) && s.updater.removeObject(s), a.remove(r.id)) }; ag._subSample = Oae; var MN = ag; var Bae = U.WHITE, Rae = U.BLACK, Mae = 0, Lae = 1, Fae = 0, Nae = new U, ije = new h, Vae = new U, kae = new wt, Uae = new wt, zae = new bt; function Hae(e) { this.entity = e, this.pointPrimitive = void 0, this.billboard = void 0, this.color = void 0, this.outlineColor = void 0, this.pixelSize = void 0, this.outlineWidth = void 0 } function cg(e, t) { t.collectionChanged.addEventListener(cg.prototype._onCollectionChanged, this), this._cluster = e, this._entityCollection = t, this._items = new Ct, this._onCollectionChanged(t, t.values, [], []) } cg.prototype.update = function (e) { let t = this._items.values, n = this._cluster; for (let i = 0, o = t.length; i < o; i++) { let r = t[i], s = r.entity, a = s._point, c = r.pointPrimitive, u = r.billboard, f = j.getValueOrDefault(a._heightReference, e, ze.NONE), d = s.isShowing && s.isAvailable(e) && j.getValueOrDefault(a._show, e, !0), p; if (d && (p = j.getValueOrUndefined(s._position, e, ije), d = l(p)), !d) { tD(r, s, n); continue } j.isConstant(s._position) || (n._clusterDirty = !0); let g = !1, m = !1; if (f !== ze.NONE && !l(u) ? (l(c) && (tD(r, s, n), c = void 0), u = n.getBillboard(s), u.id = s, u.image = void 0, r.billboard = u, g = !0, m = h.equals(u.position, p) && u.heightReference === f) : f === ze.NONE && !l(c) && (l(u) && (tD(r, s, n), u = void 0), c = n.getPoint(s), c.id = s, r.pointPrimitive = c), l(c)) c.show = !0, c.position = p, c.scaleByDistance = j.getValueOrUndefined(a._scaleByDistance, e, kae), c.translucencyByDistance = j.getValueOrUndefined(a._translucencyByDistance, e, Uae), c.color = j.getValueOrDefault(a._color, e, Bae, Nae), c.outlineColor = j.getValueOrDefault(a._outlineColor, e, Rae, Vae), c.outlineWidth = j.getValueOrDefault(a._outlineWidth, e, Mae), c.pixelSize = j.getValueOrDefault(a._pixelSize, e, Lae), c.distanceDisplayCondition = j.getValueOrUndefined(a._distanceDisplayCondition, e, zae), c.disableDepthTestDistance = j.getValueOrDefault(a._disableDepthTestDistance, e, Fae); else if (l(u)) { u.show = !0, u.position = p, u.scaleByDistance = j.getValueOrUndefined(a._scaleByDistance, e, kae), u.translucencyByDistance = j.getValueOrUndefined(a._translucencyByDistance, e, Uae), u.distanceDisplayCondition = j.getValueOrUndefined(a._distanceDisplayCondition, e, zae), u.disableDepthTestDistance = j.getValueOrDefault(a._disableDepthTestDistance, e, Fae), u.heightReference = f; let A = j.getValueOrDefault(a._color, e, Bae, Nae), C = j.getValueOrDefault(a._outlineColor, e, Rae, Vae), x = Math.round(j.getValueOrDefault(a._outlineWidth, e, Mae)), T = Math.max(1, Math.round(j.getValueOrDefault(a._pixelSize, e, Lae))); if (x > 0 ? (u.scale = 1, g = g || x !== r.outlineWidth || T !== r.pixelSize || !U.equals(A, r.color) || !U.equals(C, r.outlineColor)) : (u.scale = T / 50, T = 50, g = g || x !== r.outlineWidth || !U.equals(A, r.color) || !U.equals(C, r.outlineColor)), g) { r.color = U.clone(A, r.color), r.outlineColor = U.clone(C, r.outlineColor), r.pixelSize = T, r.outlineWidth = x; let b = A.alpha, S = A.toCssColorString(), D = C.toCssColorString(), P = JSON.stringify([S, T, D, x]); u.setImage(P, gx(b, S, D, x, T)) } m && u._updateClamping() } } return !0 }; cg.prototype.getBoundingSphere = function (e, t) { let n = this._items.get(e.id); if (!l(n) || !(l(n.pointPrimitive) || l(n.billboard))) return rt.FAILED; if (l(n.pointPrimitive)) t.center = h.clone(n.pointPrimitive.position, t.center); else { let i = n.billboard; if (!l(i._clampedPosition)) return rt.PENDING; t.center = h.clone(i._clampedPosition, t.center) } return t.radius = 0, rt.DONE }; cg.prototype.isDestroyed = function () { return !1 }; cg.prototype.destroy = function () { this._entityCollection.collectionChanged.removeEventListener(cg.prototype._onCollectionChanged, this); let e = this._entityCollection.values; for (let t = 0; t < e.length; t++)this._cluster.removePoint(e[t]); return le(this) }; cg.prototype._onCollectionChanged = function (e, t, n, i) { let o, r, s = this._items, a = this._cluster; for (o = t.length - 1; o > -1; o--)r = t[o], l(r._point) && l(r._position) && s.set(r.id, new Hae(r)); for (o = i.length - 1; o > -1; o--)r = i[o], l(r._point) && l(r._position) ? s.contains(r.id) || s.set(r.id, new Hae(r)) : (tD(s.get(r.id), r, a), s.remove(r.id)); for (o = n.length - 1; o > -1; o--)r = n[o], tD(s.get(r.id), r, a), s.remove(r.id) }; function tD(e, t, n) { if (l(e)) { let i = e.pointPrimitive; if (l(i)) { e.pointPrimitive = void 0, n.removePoint(t); return } let o = e.billboard; l(o) && (e.billboard = void 0, n.removeBillboard(t)) } } var LN = cg; var Yae = []; function oje(e, t, n, i, o) { let r = Yae; r.length = o; let s, a = n.red, c = n.green, u = n.blue, f = n.alpha, d = i.red, p = i.green, g = i.blue, m = i.alpha; if (U.equals(n, i)) { for (s = 0; s < o; s++)r[s] = U.clone(n); return r } let A = (d - a) / o, C = (p - c) / o, x = (g - u) / o, T = (m - f) / o; for (s = 0; s < o; s++)r[s] = new U(a + s * A, c + s * C, u + s * x, f + s * T); return r } function nD(e) { e = y(e, y.EMPTY_OBJECT); let t = e.positions, n = e.colors, i = y(e.width, 1), o = y(e.colorsPerVertex, !1); this._positions = t, this._colors = n, this._width = i, this._colorsPerVertex = o, this._vertexFormat = we.clone(y(e.vertexFormat, we.DEFAULT)), this._arcType = y(e.arcType, Yt.GEODESIC), this._granularity = y(e.granularity, I.RADIANS_PER_DEGREE), this._ellipsoid = ie.clone(y(e.ellipsoid, ie.WGS84)), this._workerName = "createPolylineGeometry"; let r = 1 + t.length * h.packedLength; r += l(n) ? 1 + n.length * U.packedLength : 1, this.packedLength = r + ie.packedLength + we.packedLength + 4 } nD.pack = function (e, t, n) { n = y(n, 0); let i, o = e._positions, r = o.length; for (t[n++] = r, i = 0; i < r; ++i, n += h.packedLength)h.pack(o[i], t, n); let s = e._colors; for (r = l(s) ? s.length : 0, t[n++] = r, i = 0; i < r; ++i, n += U.packedLength)U.pack(s[i], t, n); return ie.pack(e._ellipsoid, t, n), n += ie.packedLength, we.pack(e._vertexFormat, t, n), n += we.packedLength, t[n++] = e._width, t[n++] = e._colorsPerVertex ? 1 : 0, t[n++] = e._arcType, t[n] = e._granularity, t }; var Xae = ie.clone(ie.UNIT_SPHERE), Kae = new we, Oy = { positions: void 0, colors: void 0, ellipsoid: Xae, vertexFormat: Kae, width: void 0, colorsPerVertex: void 0, arcType: void 0, granularity: void 0 }; nD.unpack = function (e, t, n) { t = y(t, 0); let i, o = e[t++], r = new Array(o); for (i = 0; i < o; ++i, t += h.packedLength)r[i] = h.unpack(e, t); o = e[t++]; let s = o > 0 ? new Array(o) : void 0; for (i = 0; i < o; ++i, t += U.packedLength)s[i] = U.unpack(e, t); let a = ie.unpack(e, t, Xae); t += ie.packedLength; let c = we.unpack(e, t, Kae); t += we.packedLength; let u = e[t++], f = e[t++] === 1, d = e[t++], p = e[t]; return l(n) ? (n._positions = r, n._colors = s, n._ellipsoid = ie.clone(a, n._ellipsoid), n._vertexFormat = we.clone(c, n._vertexFormat), n._width = u, n._colorsPerVertex = f, n._arcType = d, n._granularity = p, n) : (Oy.positions = r, Oy.colors = s, Oy.width = u, Oy.colorsPerVertex = f, Oy.arcType = d, Oy.granularity = p, new nD(Oy)) }; var Gae = new h, Wae = new h, jae = new h, qae = new h; nD.createGeometry = function (e) { let t = e._width, n = e._vertexFormat, i = e._colors, o = e._colorsPerVertex, r = e._arcType, s = e._granularity, a = e._ellipsoid, c, u, f, d = [], p = _o(e._positions, h.equalsEpsilon, !1, d); if (l(i) && d.length > 0) { let O = 0, V = d[0]; i = i.filter(function (z, k) { let G = !1; return o ? G = k === V || k === 0 && V === 1 : G = k + 1 === V, G ? (O++, V = d[O], !1) : !0 }) } let g = p.length; if (g < 2 || t <= 0) return; if (r === Yt.GEODESIC || r === Yt.RHUMB) { let O, V; r === Yt.GEODESIC ? (O = I.chordLength(s, a.maximumRadius), V = xi.numberOfPoints) : (O = s, V = xi.numberOfPointsRhumbLine); let z = xi.extractHeights(p, a); if (l(i)) { let k = 1; for (c = 0; c < g - 1; ++c)k += V(p[c], p[c + 1], O); let G = new Array(k), N = 0; for (c = 0; c < g - 1; ++c) { let X = p[c], q = p[c + 1], J = i[c], W = V(X, q, O); if (o && c < k) { let K = i[c + 1], Z = oje(X, q, J, K, W), de = Z.length; for (u = 0; u < de; ++u)G[N++] = Z[u] } else for (u = 0; u < W; ++u)G[N++] = U.clone(J) } G[N] = U.clone(i[i.length - 1]), i = G, Yae.length = 0 } r === Yt.GEODESIC ? p = xi.generateCartesianArc({ positions: p, minDistance: O, ellipsoid: a, height: z }) : p = xi.generateCartesianRhumbArc({ positions: p, granularity: O, ellipsoid: a, height: z }) } g = p.length; let m = g * 4 - 4, A = new Float64Array(m * 3), C = new Float64Array(m * 3), x = new Float64Array(m * 3), T = new Float32Array(m * 2), b = n.st ? new Float32Array(m * 2) : void 0, S = l(i) ? new Uint8Array(m * 4) : void 0, D = 0, P = 0, B = 0, R = 0, M; for (u = 0; u < g; ++u) { u === 0 ? (M = Gae, h.subtract(p[0], p[1], M), h.add(p[0], M, M)) : M = p[u - 1], h.clone(M, jae), h.clone(p[u], Wae), u === g - 1 ? (M = Gae, h.subtract(p[g - 1], p[g - 2], M), h.add(p[g - 1], M, M)) : M = p[u + 1], h.clone(M, qae); let O, V; l(S) && (u !== 0 && !o ? O = i[u - 1] : O = i[u], u !== g - 1 && (V = i[u])); let z = u === 0 ? 2 : 0, k = u === g - 1 ? 2 : 4; for (f = z; f < k; ++f) { h.pack(Wae, A, D), h.pack(jae, C, D), h.pack(qae, x, D), D += 3; let G = f - 2 < 0 ? -1 : 1; if (T[P++] = 2 * (f % 2) - 1, T[P++] = G * t, n.st && (b[B++] = u / (g - 1), b[B++] = Math.max(T[P - 2], 0)), l(S)) { let N = f < 2 ? O : V; S[R++] = U.floatToByte(N.red), S[R++] = U.floatToByte(N.green), S[R++] = U.floatToByte(N.blue), S[R++] = U.floatToByte(N.alpha) } } } let L = new sn; L.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: A }), L.prevPosition = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: C }), L.nextPosition = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: x }), L.expandAndWidth = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: T }), n.st && (L.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: b })), l(S) && (L.color = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 4, values: S, normalize: !0 })); let _ = Me.createTypedArray(m, g * 6 - 6), E = 0, w = 0, v = g - 1; for (u = 0; u < v; ++u)_[w++] = E, _[w++] = E + 2, _[w++] = E + 1, _[w++] = E + 1, _[w++] = E + 2, _[w++] = E + 3, E += 4; return new st({ attributes: L, indices: _, primitiveType: Oe.TRIANGLES, boundingSphere: re.fromPoints(p), geometryType: af.POLYLINES }) }; var lg = nD; var rje = new Yn(0), FN = {}, Jae = new U, sje = new Ot(U.WHITE), aje = new Yn(!0), cje = new Yn(hn.DISABLED), lje = new Yn(new bt), uje = new Yn(Ln.BOTH); function fje() { this.vertexFormat = void 0, this.positions = void 0, this.width = void 0, this.arcType = void 0, this.granularity = void 0 } function dje() { this.positions = void 0, this.width = void 0, this.arcType = void 0, this.granularity = void 0 } function Xf(e, t) { this._entity = e, this._scene = t, this._entitySubscription = e.definitionChanged.addEventListener(Xf.prototype._onEntityPropertyChanged, this), this._fillEnabled = !1, this._dynamic = !1, this._geometryChanged = new _e, this._showProperty = void 0, this._materialProperty = void 0, this._shadowsProperty = void 0, this._distanceDisplayConditionProperty = void 0, this._classificationTypeProperty = void 0, this._depthFailMaterialProperty = void 0, this._geometryOptions = new fje, this._groundGeometryOptions = new dje, this._id = `polyline-${e.id}`, this._clampToGround = !1, this._supportsPolylinesOnTerrain = Xo.supportsPolylinesOnTerrain(t), this._zIndex = 0, this._onEntityPropertyChanged(e, "polyline", e.polyline, void 0) } Object.defineProperties(Xf.prototype, { id: { get: function () { return this._id } }, entity: { get: function () { return this._entity } }, fillEnabled: { get: function () { return this._fillEnabled } }, hasConstantFill: { get: function () { return !this._fillEnabled || !l(this._entity.availability) && j.isConstant(this._showProperty) } }, fillMaterialProperty: { get: function () { return this._materialProperty } }, depthFailMaterialProperty: { get: function () { return this._depthFailMaterialProperty } }, outlineEnabled: { value: !1 }, hasConstantOutline: { value: !0 }, outlineColorProperty: { value: void 0 }, shadowsProperty: { get: function () { return this._shadowsProperty } }, distanceDisplayConditionProperty: { get: function () { return this._distanceDisplayConditionProperty } }, classificationTypeProperty: { get: function () { return this._classificationTypeProperty } }, isDynamic: { get: function () { return this._dynamic } }, isClosed: { value: !1 }, geometryChanged: { get: function () { return this._geometryChanged } }, arcType: { get: function () { return this._arcType } }, clampToGround: { get: function () { return this._clampToGround && this._supportsPolylinesOnTerrain } }, zIndex: { get: function () { return this._zIndex } } }); Xf.prototype.isOutlineVisible = function (e) { return !1 }; Xf.prototype.isFilled = function (e) { let t = this._entity, n = this._fillEnabled && t.isAvailable(e) && this._showProperty.getValue(e); return y(n, !1) }; Xf.prototype.createFillGeometryInstance = function (e) { let t = this._entity, n = t.isAvailable(e), i = new fn(n && t.isShowing && this._showProperty.getValue(e)), o = this._distanceDisplayConditionProperty.getValue(e), r = Mn.fromDistanceDisplayCondition(o), s = { show: i, distanceDisplayCondition: r }, a; return this._materialProperty instanceof Ot && (l(this._materialProperty.color) && (this._materialProperty.color.isConstant || n) && (a = this._materialProperty.color.getValue(e, Jae)), l(a) || (a = U.WHITE), s.color = Bt.fromColor(a)), this.clampToGround ? new At({ id: t, geometry: new xC(this._groundGeometryOptions), attributes: s }) : (l(this._depthFailMaterialProperty) && this._depthFailMaterialProperty instanceof Ot && (l(this._depthFailMaterialProperty.color) && (this._depthFailMaterialProperty.color.isConstant || n) && (a = this._depthFailMaterialProperty.color.getValue(e, Jae)), l(a) || (a = U.WHITE), s.depthFailColor = Bt.fromColor(a)), new At({ id: t, geometry: new lg(this._geometryOptions), attributes: s })) }; Xf.prototype.createOutlineGeometryInstance = function (e) { }; Xf.prototype.isDestroyed = function () { return !1 }; Xf.prototype.destroy = function () { this._entitySubscription(), le(this) }; Xf.prototype._onEntityPropertyChanged = function (e, t, n, i) { if (!(t === "availability" || t === "polyline")) return; let o = this._entity.polyline; if (!l(o)) { this._fillEnabled && (this._fillEnabled = !1, this._geometryChanged.raiseEvent(this)); return } let r = o.positions, s = o.show; if (l(s) && s.isConstant && !s.getValue(ke.MINIMUM_VALUE) || !l(r)) { this._fillEnabled && (this._fillEnabled = !1, this._geometryChanged.raiseEvent(this)); return } let a = o.zIndex, c = y(o.material, sje), u = c instanceof Ot; this._materialProperty = c, this._depthFailMaterialProperty = o.depthFailMaterial, this._showProperty = y(s, aje), this._shadowsProperty = y(o.shadows, cje), this._distanceDisplayConditionProperty = y(o.distanceDisplayCondition, lje), this._classificationTypeProperty = y(o.classificationType, uje), this._fillEnabled = !0, this._zIndex = y(a, rje); let f = o.width, d = o.arcType, p = o.clampToGround, g = o.granularity; if (!r.isConstant || !j.isConstant(f) || !j.isConstant(d) || !j.isConstant(g) || !j.isConstant(p) || !j.isConstant(a)) this._dynamic || (this._dynamic = !0, this._geometryChanged.raiseEvent(this)); else { let m = this._geometryOptions, A = r.getValue(ke.MINIMUM_VALUE, m.positions); if (!l(A) || A.length < 2) { this._fillEnabled && (this._fillEnabled = !1, this._geometryChanged.raiseEvent(this)); return } let C; u && (!l(this._depthFailMaterialProperty) || this._depthFailMaterialProperty instanceof Ot) ? C = Vr.VERTEX_FORMAT : C = Ys.VERTEX_FORMAT, m.vertexFormat = C, m.positions = A, m.width = l(f) ? f.getValue(ke.MINIMUM_VALUE) : void 0, m.arcType = l(d) ? d.getValue(ke.MINIMUM_VALUE) : void 0, m.granularity = l(g) ? g.getValue(ke.MINIMUM_VALUE) : void 0; let x = this._groundGeometryOptions; x.positions = A, x.width = m.width, x.arcType = m.arcType, x.granularity = m.granularity, this._clampToGround = l(p) ? p.getValue(ke.MINIMUM_VALUE) : !1, !this._clampToGround && l(a) && Pt("Entity polylines must have clampToGround: true when using zIndex.  zIndex will be ignored."), this._dynamic = !1, this._geometryChanged.raiseEvent(this) } }; Xf.prototype.createDynamicUpdater = function (e, t) { return new iD(e, t, this) }; var RT = { positions: void 0, granularity: void 0, height: void 0, ellipsoid: void 0 }; function iD(e, t, n) { this._line = void 0, this._primitives = e, this._groundPrimitives = t, this._groundPolylinePrimitive = void 0, this._material = void 0, this._geometryUpdater = n, this._positions = [] } function Zae(e) { if (l(e._line)) return e._line; let t = e._geometryUpdater._scene.id, n = FN[t], i = e._primitives; !l(n) || n.isDestroyed() ? (n = new D_, FN[t] = n, i.add(n)) : i.contains(n) || i.add(n); let o = n.add(); return o.id = e._geometryUpdater._entity, e._line = o, o } iD.prototype.update = function (e) { let t = this._geometryUpdater, n = t._entity, i = n.polyline, o = i.positions, r = j.getValueOrUndefined(o, e, this._positions); t._clampToGround = j.getValueOrDefault(i._clampToGround, e, !1), t._groundGeometryOptions.positions = r, t._groundGeometryOptions.width = j.getValueOrDefault(i._width, e, 1), t._groundGeometryOptions.arcType = j.getValueOrDefault(i._arcType, e, Yt.GEODESIC), t._groundGeometryOptions.granularity = j.getValueOrDefault(i._granularity, e, 9999); let s = this._groundPrimitives; if (l(this._groundPolylinePrimitive) && (s.remove(this._groundPolylinePrimitive), this._groundPolylinePrimitive = void 0), t.clampToGround) { if (!n.isShowing || !n.isAvailable(e) || !j.getValueOrDefault(i._show, e, !0) || !l(r) || r.length < 2) return; let f = t.fillMaterialProperty, d; if (f instanceof Ot) d = new Vr; else { let p = Yo.getValue(e, f, this._material); d = new Ys({ material: p, translucent: p.isTranslucent() }), this._material = p } this._groundPolylinePrimitive = s.add(new Bd({ geometryInstances: t.createFillGeometryInstance(e), appearance: d, classificationType: t.classificationTypeProperty.getValue(e), asynchronous: !1 }), j.getValueOrUndefined(t.zIndex, e)), l(this._line) && (this._line.show = !1); return } let a = Zae(this); if (!n.isShowing || !n.isAvailable(e) || !j.getValueOrDefault(i._show, e, !0)) { a.show = !1; return } if (!l(r) || r.length < 2) { a.show = !1; return } let c = Yt.GEODESIC; c = j.getValueOrDefault(i._arcType, e, c); let u = t._scene.globe; c !== Yt.NONE && l(u) && (RT.ellipsoid = u.ellipsoid, RT.positions = r, RT.granularity = j.getValueOrUndefined(i._granularity, e), RT.height = xi.extractHeights(r, u.ellipsoid), c === Yt.GEODESIC ? r = xi.generateCartesianArc(RT) : r = xi.generateCartesianRhumbArc(RT)), a.show = !0, a.positions = r.slice(), a.material = Yo.getValue(e, t.fillMaterialProperty, a.material), a.width = j.getValueOrDefault(i._width, e, 1), a.distanceDisplayCondition = j.getValueOrUndefined(i._distanceDisplayCondition, e, a.distanceDisplayCondition) }; iD.prototype.getBoundingSphere = function (e) { if (this._geometryUpdater.clampToGround) { let t = this._groundPolylinePrimitive; if (l(t) && t.show && t.ready) { let n = t.getGeometryInstanceAttributes(this._geometryUpdater._entity); if (l(n) && l(n.boundingSphere)) return re.clone(n.boundingSphere, e), rt.DONE } return l(t) && !t.ready ? rt.PENDING : rt.DONE } else { let t = Zae(this); if (t.show && t.positions.length > 0) return re.fromPoints(t.positions, e), rt.DONE } return rt.FAILED }; iD.prototype.isDestroyed = function () { return !1 }; iD.prototype.destroy = function () { let t = this._geometryUpdater._scene.id, n = FN[t]; l(n) && (n.remove(this._line), n.length === 0 && (this._primitives.removeAndDestroy(n), delete FN[t])), l(this._groundPolylinePrimitive) && this._groundPrimitives.remove(this._groundPolylinePrimitive), le(this) }; var NN = Xf; var hje = new U, mje = new bt, pje = new bt; function Kf(e, t, n, i, o) { let r; n instanceof Ot ? r = Vr : r = Ys, this.orderedGroundPrimitives = e, this.classificationType = t, this.appearanceType = r, this.materialProperty = n, this.updaters = new Ct, this.createPrimitive = !0, this.primitive = void 0, this.oldPrimitive = void 0, this.geometry = new Ct, this.material = void 0, this.updatersWithAttributes = new Ct, this.attributes = new Ct, this.invalidated = !1, this.removeMaterialSubscription = n.definitionChanged.addEventListener(Kf.prototype.onMaterialChanged, this), this.subscriptions = new Ct, this.showsUpdated = new Ct, this.zIndex = i, this._asynchronous = o } Kf.prototype.onMaterialChanged = function () { this.invalidated = !0 }; Kf.prototype.isMaterial = function (e) { let t = this.materialProperty, n = e.fillMaterialProperty; return n === t || n instanceof Ot && t instanceof Ot ? !0 : l(t) && t.equals(n) }; Kf.prototype.add = function (e, t, n) { let i = t.id; if (this.updaters.set(i, t), this.geometry.set(i, n), !t.hasConstantFill || !t.fillMaterialProperty.isConstant || !j.isConstant(t.distanceDisplayConditionProperty)) this.updatersWithAttributes.set(i, t); else { let o = this; this.subscriptions.set(i, t.entity.definitionChanged.addEventListener(function (r, s, a, c) { s === "isShowing" && o.showsUpdated.set(t.id, t) })) } this.createPrimitive = !0 }; Kf.prototype.remove = function (e) { let t = e.id; if (this.createPrimitive = this.geometry.remove(t) || this.createPrimitive, this.updaters.remove(t)) { this.updatersWithAttributes.remove(t); let n = this.subscriptions.get(t); return l(n) && (n(), this.subscriptions.remove(t)), !0 } return !1 }; Kf.prototype.update = function (e) { let t = !0, n = this.primitive, i = this.orderedGroundPrimitives, o = this.geometry.values, r; if (this.createPrimitive) { if (o.length > 0) l(n) && (l(this.oldPrimitive) ? i.remove(n) : this.oldPrimitive = n), n = new Bd({ show: !1, asynchronous: this._asynchronous, geometryInstances: o.slice(), appearance: new this.appearanceType, classificationType: this.classificationType }), this.appearanceType === Ys && (this.material = Yo.getValue(e, this.materialProperty, this.material), n.appearance.material = this.material), i.add(n, this.zIndex), t = !1; else { l(n) && (i.remove(n), n = void 0); let a = this.oldPrimitive; l(a) && (i.remove(a), this.oldPrimitive = void 0) } this.attributes.removeAll(), this.primitive = n, this.createPrimitive = !1 } else if (l(n) && n.ready) { n.show = !0, l(this.oldPrimitive) && (i.remove(this.oldPrimitive), this.oldPrimitive = void 0), this.appearanceType === Ys && (this.material = Yo.getValue(e, this.materialProperty, this.material), this.primitive.appearance.material = this.material); let s = this.updatersWithAttributes.values, a = s.length; for (r = 0; r < a; r++) { let c = s[r], u = c.entity, f = this.geometry.get(c.id), d = this.attributes.get(f.id.id); if (l(d) || (d = n.getGeometryInstanceAttributes(f.id), this.attributes.set(f.id.id, d)), !c.fillMaterialProperty.isConstant) { let A = c.fillMaterialProperty.color, C = j.getValueOrDefault(A, e, U.WHITE, hje); U.equals(d._lastColor, C) || (d._lastColor = U.clone(C, d._lastColor), d.color = Bt.toValue(C, d.color)) } let p = u.isShowing && (c.hasConstantFill || c.isFilled(e)), g = d.show[0] === 1; p !== g && (d.show = fn.toValue(p, d.show)); let m = c.distanceDisplayConditionProperty; if (!j.isConstant(m)) { let A = j.getValueOrDefault(m, e, pje, mje); bt.equals(A, d._lastDistanceDisplayCondition) || (d._lastDistanceDisplayCondition = bt.clone(A, d._lastDistanceDisplayCondition), d.distanceDisplayCondition = Mn.toValue(A, d.distanceDisplayCondition)) } } this.updateShows(n) } else l(n) && !n.ready && (t = !1); return t }; Kf.prototype.updateShows = function (e) { let t = this.showsUpdated.values, n = t.length; for (let i = 0; i < n; i++) { let o = t[i], r = o.entity, s = this.geometry.get(o.id), a = this.attributes.get(s.id.id); l(a) || (a = e.getGeometryInstanceAttributes(s.id), this.attributes.set(s.id.id, a)); let c = r.isShowing, u = a.show[0] === 1; c !== u && (a.show = fn.toValue(c, a.show), s.attributes.show.value[0] = a.show[0]) } this.showsUpdated.removeAll() }; Kf.prototype.contains = function (e) { return this.updaters.contains(e.id) }; Kf.prototype.getBoundingSphere = function (e, t) { let n = this.primitive; if (!n.ready) return rt.PENDING; let i = n.getGeometryInstanceAttributes(e.entity); return !l(i) || !l(i.boundingSphere) || l(i.show) && i.show[0] === 0 ? rt.FAILED : (i.boundingSphere.clone(t), rt.DONE) }; Kf.prototype.destroy = function () { let e = this.primitive, t = this.orderedGroundPrimitives; l(e) && t.remove(e); let n = this.oldPrimitive; l(n) && t.remove(n), this.removeMaterialSubscription() }; function MT(e, t, n) { this._items = [], this._orderedGroundPrimitives = e, this._classificationType = t, this._asynchronous = y(n, !0) } MT.prototype.add = function (e, t) { let n = this._items, i = n.length, o = t.createFillGeometryInstance(e), r = j.getValueOrDefault(t.zIndex, 0); for (let a = 0; a < i; ++a) { let c = n[a]; if (c.isMaterial(t) && c.zIndex === r) { c.add(e, t, o); return } } let s = new Kf(this._orderedGroundPrimitives, this._classificationType, t.fillMaterialProperty, r, this._asynchronous); s.add(e, t, o), n.push(s) }; MT.prototype.remove = function (e) { let t = this._items, n = t.length; for (let i = n - 1; i >= 0; i--) { let o = t[i]; if (o.remove(e)) { o.updaters.length === 0 && (t.splice(i, 1), o.destroy()); break } } }; MT.prototype.update = function (e) { let t, n = this._items, i = n.length; for (t = i - 1; t >= 0; t--) { let r = n[t]; if (r.invalidated) { n.splice(t, 1); let s = r.updaters.values, a = s.length; for (let c = 0; c < a; c++)this.add(e, s[c]); r.destroy() } } let o = !0; for (t = 0; t < n.length; t++)o = n[t].update(e) && o; return o }; MT.prototype.getBoundingSphere = function (e, t) { let n = this._items, i = n.length; for (let o = 0; o < i; o++) { let r = n[o]; if (r.contains(e)) return r.getBoundingSphere(e, t) } return rt.FAILED }; MT.prototype.removeAllPrimitives = function () { let e = this._items, t = e.length; for (let n = 0; n < t; n++)e[n].destroy(); this._items.length = 0 }; var VN = MT; var _je = []; function Qae(e, t) { let n = e._batches, i = n.length; for (let o = 0; o < i; o++)n[o].remove(t) } function $ae(e, t, n) { if (n.isDynamic) { e._dynamicBatch.add(t, n); return } if (n.clampToGround && n.fillEnabled) { let s = n.classificationTypeProperty.getValue(t); e._groundBatches[s].add(t, n); return } let i; n.fillEnabled && (i = n.shadowsProperty.getValue(t)); let o = 0; l(n.depthFailMaterialProperty) && (o = n.depthFailMaterialProperty instanceof Ot ? 1 : 2); let r; l(i) && (r = i + o * hn.NUMBER_OF_SHADOW_MODES), n.fillEnabled && (n.fillMaterialProperty instanceof Ot ? e._colorBatches[r].add(t, n) : e._materialBatches[r].add(t, n)) } function _h(e, t, n, i) { i = y(i, e.groundPrimitives), n = y(n, e.primitives), this._scene = e, this._primitives = n, this._entityCollection = void 0, this._addedObjects = new Ct, this._removedObjects = new Ct, this._changedObjects = new Ct; let o, r = hn.NUMBER_OF_SHADOW_MODES; for (this._colorBatches = new Array(r * 3), this._materialBatches = new Array(r * 3), o = 0; o < r; ++o)this._colorBatches[o] = new Wf(n, Vr, void 0, !1, o), this._materialBatches[o] = new qf(n, Ys, void 0, !1, o), this._colorBatches[o + r] = new Wf(n, Vr, Vr, !1, o), this._materialBatches[o + r] = new qf(n, Ys, Vr, !1, o), this._colorBatches[o + r * 2] = new Wf(n, Vr, Ys, !1, o), this._materialBatches[o + r * 2] = new qf(n, Ys, Ys, !1, o); this._dynamicBatch = new aT(n, i); let s = Ln.NUMBER_OF_CLASSIFICATION_TYPES; for (this._groundBatches = new Array(s), o = 0; o < s; ++o)this._groundBatches[o] = new VN(i, o); this._batches = this._colorBatches.concat(this._materialBatches, this._dynamicBatch, this._groundBatches), this._subscriptions = new Ct, this._updaters = new Ct, this._entityCollection = t, t.collectionChanged.addEventListener(_h.prototype._onCollectionChanged, this), this._onCollectionChanged(t, t.values, _je) } _h.prototype.update = function (e) { let t = this._addedObjects, n = t.values, i = this._removedObjects, o = i.values, r = this._changedObjects, s = r.values, a, c, u, f; for (a = s.length - 1; a > -1; a--)c = s[a], u = c.id, f = this._updaters.get(u), f.entity === c ? (Qae(this, f), $ae(this, e, f)) : (o.push(c), n.push(c)); for (a = o.length - 1; a > -1; a--)c = o[a], u = c.id, f = this._updaters.get(u), Qae(this, f), f.destroy(), this._updaters.remove(u), this._subscriptions.get(u)(), this._subscriptions.remove(u); for (a = n.length - 1; a > -1; a--)c = n[a], u = c.id, f = new NN(c, this._scene), this._updaters.set(u, f), $ae(this, e, f), this._subscriptions.set(u, f.geometryChanged.addEventListener(_h._onGeometryChanged, this)); t.removeAll(), i.removeAll(), r.removeAll(); let d = !0, p = this._batches, g = p.length; for (a = 0; a < g; a++)d = p[a].update(e) && d; return d }; var gje = [], yje = new re; _h.prototype.getBoundingSphere = function (e, t) { let n = gje, i = yje, o = 0, r = rt.DONE, s = this._batches, a = s.length, c = this._updaters.get(e.id); for (let u = 0; u < a; u++) { if (r = s[u].getBoundingSphere(c, i), r === rt.PENDING) return rt.PENDING; r === rt.DONE && (n[o] = re.clone(i, n[o]), o++) } return o === 0 ? rt.FAILED : (n.length = o, re.fromBoundingSpheres(n, t), rt.DONE) }; _h.prototype.isDestroyed = function () { return !1 }; _h.prototype.destroy = function () { this._entityCollection.collectionChanged.removeEventListener(_h.prototype._onCollectionChanged, this), this._addedObjects.removeAll(), this._removedObjects.removeAll(); let e, t = this._batches, n = t.length; for (e = 0; e < n; e++)t[e].removeAllPrimitives(); let i = this._subscriptions.values; for (n = i.length, e = 0; e < n; e++)i[e](); return this._subscriptions.removeAll(), le(this) }; _h._onGeometryChanged = function (e) { let t = this._removedObjects, n = this._changedObjects, i = e.entity, o = i.id; !l(t.get(o)) && !l(n.get(o)) && n.set(o, i) }; _h.prototype._onCollectionChanged = function (e, t, n) { let i = this._addedObjects, o = this._removedObjects, r = this._changedObjects, s, a, c; for (s = n.length - 1; s > -1; s--)c = n[s], a = c.id, i.remove(a) || (o.set(a, c), r.remove(a)); for (s = t.length - 1; s > -1; s--)c = t[s], a = c.id, o.remove(a) ? r.set(a, c) : i.set(a, c) }; var kN = _h; function Vu(e) { Rc.initializeTerrainHeights(), Bd.initializeTerrainHeights(); let t = e.scene, n = e.dataSourceCollection; this._eventHelper = new Pr, this._eventHelper.add(n.dataSourceAdded, this._onDataSourceAdded, this), this._eventHelper.add(n.dataSourceRemoved, this._onDataSourceRemoved, this), this._eventHelper.add(n.dataSourceMoved, this._onDataSourceMoved, this), this._eventHelper.add(t.postRender, this._postRender, this), this._dataSourceCollection = n, this._scene = t, this._visualizersCallback = y(e.visualizersCallback, Vu.defaultVisualizersCallback); let i = !1, o = new wl, r = new wl; n.length > 0 && (t.primitives.add(o), t.groundPrimitives.add(r), i = !0), this._primitives = o, this._groundPrimitives = r; for (let u = 0, f = n.length; u < f; u++)this._onDataSourceAdded(n, n.get(u)); let s = new LF; this._onDataSourceAdded(void 0, s), this._defaultDataSource = s; let a, c; if (!i) { let u = this, f = function () { t.primitives.add(o), t.groundPrimitives.add(r), a(), c(), u._removeDefaultDataSourceListener = void 0, u._removeDataSourceCollectionListener = void 0 }; a = s.entities.collectionChanged.addEventListener(f), c = n.dataSourceAdded.addEventListener(f) } this._removeDefaultDataSourceListener = a, this._removeDataSourceCollectionListener = c, this._ready = !1 } Vu.defaultVisualizersCallback = function (e, t, n) { let i = n.entities; return [new hP(t, i), new IN(e, i, n._primitives, n._groundPrimitives), new ON(t, i), new RN(e, i), new CF(e, i), new LN(t, i), new MN(e, i), new kN(e, i, n._primitives, n._groundPrimitives)] }; Object.defineProperties(Vu.prototype, { scene: { get: function () { return this._scene } }, dataSources: { get: function () { return this._dataSourceCollection } }, defaultDataSource: { get: function () { return this._defaultDataSource } }, ready: { get: function () { return this._ready } } }); Vu.prototype.isDestroyed = function () { return !1 }; Vu.prototype.destroy = function () { this._eventHelper.removeAll(); let e = this._dataSourceCollection; for (let t = 0, n = e.length; t < n; ++t)this._onDataSourceRemoved(this._dataSourceCollection, e.get(t)); return this._onDataSourceRemoved(void 0, this._defaultDataSource), l(this._removeDefaultDataSourceListener) ? (this._removeDefaultDataSourceListener(), this._removeDataSourceCollectionListener()) : (this._scene.primitives.remove(this._primitives), this._scene.groundPrimitives.remove(this._groundPrimitives)), le(this) }; Vu.prototype.update = function (e) { if (!oi.initialized) return this._ready = !1, !1; let t = !0, n, i, o, r, s = this._dataSourceCollection, a = s.length; for (n = 0; n < a; n++) { let c = s.get(n); for (l(c.update) && (t = c.update(e) && t), o = c._visualizers, r = o.length, i = 0; i < r; i++)t = o[i].update(e) && t } for (o = this._defaultDataSource._visualizers, r = o.length, i = 0; i < r; i++)t = o[i].update(e) && t; return this._ready = t, t }; Vu.prototype._postRender = function () { let e = this._scene.frameState, t = this._dataSourceCollection, n = t.length; for (let i = 0; i < n; i++) { let o = t.get(i), r = o.credit; l(r) && e.creditDisplay.addCredit(r); let s = o._resourceCredits; if (l(s)) { let a = s.length; for (let c = 0; c < a; c++)e.creditDisplay.addCredit(s[c]) } } }; var Aje = [], Cje = new re; Vu.prototype.getBoundingSphere = function (e, t, n) { if (!this._ready) return rt.PENDING; let i, o, r = this._defaultDataSource; if (!r.entities.contains(e)) { r = void 0; let p = this._dataSourceCollection; for (o = p.length, i = 0; i < o; i++) { let g = p.get(i); if (g.entities.contains(e)) { r = g; break } } } if (!l(r)) return rt.FAILED; let s = Aje, a = Cje, c = 0, u = rt.DONE, f = r._visualizers, d = f.length; for (i = 0; i < d; i++) { let p = f[i]; if (l(p.getBoundingSphere)) { if (u = f[i].getBoundingSphere(e, a), !t && u === rt.PENDING) return rt.PENDING; u === rt.DONE && (s[c] = re.clone(a, s[c]), c++) } } return c === 0 ? rt.FAILED : (s.length = c, re.fromBoundingSpheres(s, n), rt.DONE) }; Vu.prototype._onDataSourceAdded = function (e, t) { let n = this._scene, i = this._primitives, o = this._groundPrimitives, r = i.add(new wl), s = o.add(new $F); t._primitives = r, t._groundPrimitives = s; let a = t.clustering; a._initialize(n), r.add(a), t._visualizers = this._visualizersCallback(n, a, t) }; Vu.prototype._onDataSourceRemoved = function (e, t) { let n = this._primitives, i = this._groundPrimitives, o = t._primitives, r = t._groundPrimitives, s = t.clustering; o.remove(s); let a = t._visualizers, c = a.length; for (let u = 0; u < c; u++)a[u].destroy(); n.remove(o), i.remove(r), t._visualizers = void 0 }; Vu.prototype._onDataSourceMoved = function (e, t, n) { let i = this._primitives, o = this._groundPrimitives, r = e._primitives, s = e._groundPrimitives; t === n + 1 ? (i.raise(r), o.raise(s)) : t === n - 1 ? (i.lower(r), o.lower(s)) : t === 0 ? (i.lowerToBottom(r), o.lowerToBottom(s), i.raise(r), o.raise(s)) : (i.raiseToTop(r), o.raiseToTop(s)) }; var UN = Vu; function r9(e, t, n) { this.heading = y(e, 0), this.pitch = y(t, 0), this.range = y(n, 0) } r9.clone = function (e, t) { if (!!l(e)) return l(t) || (t = new r9), t.heading = e.heading, t.pitch = e.pitch, t.range = e.range, t }; var ku = r9; var ece = new Q, tce = new Q, nce = new Q, xje = new F, zN = new h, ice = new h, s9 = new h, a9 = new h, oce = new h, rce = new h, LT = new $, Tje = 1.25; function Eje(e, t, n, i, o, r, s) { let a = e.scene.mode, c = o.getValue(r, e._lastCartesian); if (l(c)) { let u = !1, f = !1, d, p, g; if (a === ee.SCENE3D) { $.addSeconds(r, .001, LT); let T = o.getValue(LT, zN); if (l(T) || ($.addSeconds(r, -.001, LT), T = o.getValue(LT, zN), f = !0), l(T)) { let b = It.computeFixedToIcrfMatrix(r, ece), S = It.computeFixedToIcrfMatrix(LT, tce), D; !l(b) || !l(S) ? (D = It.computeTemeToPseudoFixedMatrix(r, nce), b = Q.transpose(D, ece), S = It.computeTemeToPseudoFixedMatrix(LT, tce), Q.transpose(S, S)) : D = Q.transpose(b, nce); let P = Q.multiplyByVector(b, c, oce), B = Q.multiplyByVector(S, T, rce); h.subtract(P, B, a9); let R = h.magnitude(a9) * 1e3, M = I.GRAVITATIONALPARAMETER, L = -M / (R * R - 2 * M / h.magnitude(P)); L < 0 || L > Tje * s.maximumRadius ? (d = ice, h.normalize(c, d), h.negate(d, d), g = h.clone(h.UNIT_Z, s9), p = h.cross(g, d, zN), h.magnitude(p) > I.EPSILON7 && (h.normalize(d, d), h.normalize(p, p), g = h.cross(d, p, s9), h.normalize(g, g), u = !0)) : h.equalsEpsilon(c, T, I.EPSILON7) || (g = ice, h.normalize(P, g), h.normalize(B, B), p = h.cross(g, B, s9), f && (p = h.multiplyByScalar(p, -1, p)), h.equalsEpsilon(p, h.ZERO, I.EPSILON7) || (d = h.cross(p, g, zN), Q.multiplyByVector(D, d, d), Q.multiplyByVector(D, p, p), Q.multiplyByVector(D, g, g), h.normalize(d, d), h.normalize(p, p), h.normalize(g, g), u = !0)) } } l(e.boundingSphere) && (c = e.boundingSphere.center); let m, A, C; i && (m = h.clone(t.position, a9), A = h.clone(t.direction, oce), C = h.clone(t.up, rce)); let x = xje; u ? (x[0] = d.x, x[1] = d.y, x[2] = d.z, x[3] = 0, x[4] = p.x, x[5] = p.y, x[6] = p.z, x[7] = 0, x[8] = g.x, x[9] = g.y, x[10] = g.z, x[11] = 0, x[12] = c.x, x[13] = c.y, x[14] = c.z, x[15] = 0) : It.eastNorthUpToFixedFrame(c, s, x), t._setTransform(x), i && (h.clone(m, t.position), h.clone(A, t.direction), h.clone(C, t.up), h.cross(A, C, t.right)) } if (n) { let u = a === ee.SCENE2D || h.equals(e._offset3D, h.ZERO) ? void 0 : e._offset3D; t.lookAtTransform(t.transform, u) } } function oD(e, t, n) { this.entity = e, this.scene = t, this.ellipsoid = y(n, ie.WGS84), this.boundingSphere = void 0, this._lastEntity = void 0, this._mode = void 0, this._lastCartesian = new h, this._defaultOffset3D = void 0, this._offset3D = new h } Object.defineProperties(oD, { defaultOffset3D: { get: function () { return this._defaultOffset3D }, set: function (e) { this._defaultOffset3D = h.clone(e, new h) } } }); oD.defaultOffset3D = new h(-14e3, 3500, 3500); var HN = new ku, bje = new h; oD.prototype.update = function (e, t) { let n = this.scene, i = this.ellipsoid, o = n.mode; if (o === ee.MORPHING) return; let r = this.entity, s = r.position; if (!l(s)) return; let a = r !== this._lastEntity, c = o !== this._mode, u = n.camera, f = a || c, d = !0; if (a) { let p = r.viewFrom, g = l(p); if (!g && l(t)) { HN.pitch = -I.PI_OVER_FOUR, HN.range = 0; let m = s.getValue(e, bje); if (l(m)) { let A = 2 - 1 / Math.max(1, h.magnitude(m) / i.maximumRadius); HN.pitch *= A } u.viewBoundingSphere(t, HN), this.boundingSphere = t, f = !1, d = !1 } else (!g || !l(p.getValue(e, this._offset3D))) && h.clone(oD._defaultOffset3D, this._offset3D) } else !c && this._mode !== ee.SCENE2D && h.clone(u.position, this._offset3D); this._lastEntity = r, this._mode = o, Eje(this, u, f, d, s, e, i) }; var GN = oD; function JN(e) { return ZN(e.map(([t, n]) => new Array(t).fill(n, 0, t))) } function ZN(e) { return e.reduce((t, n) => t.concat(Array.isArray(n) ? ZN(n) : n), []) } var sce = [0, 1, 2, 3].concat(...JN([[2, 4], [2, 5], [4, 6], [4, 7], [8, 8], [8, 9], [16, 10], [16, 11], [32, 12], [32, 13], [64, 14], [64, 15], [2, 0], [1, 16], [1, 17], [2, 18], [2, 19], [4, 20], [4, 21], [8, 22], [8, 23], [16, 24], [16, 25], [32, 26], [32, 27], [64, 28], [64, 29]])); function tr() { let e = this; function t(o) { let r = e.dyn_tree, s = e.stat_desc.static_tree, a = e.stat_desc.extra_bits, c = e.stat_desc.extra_base, u = e.stat_desc.max_length, f, d, p, g, m, A, C = 0; for (g = 0; g <= 15; g++)o.bl_count[g] = 0; for (r[o.heap[o.heap_max] * 2 + 1] = 0, f = o.heap_max + 1; f < 573; f++)d = o.heap[f], g = r[r[d * 2 + 1] * 2 + 1] + 1, g > u && (g = u, C++), r[d * 2 + 1] = g, !(d > e.max_code) && (o.bl_count[g]++, m = 0, d >= c && (m = a[d - c]), A = r[d * 2], o.opt_len += A * (g + m), s && (o.static_len += A * (s[d * 2 + 1] + m))); if (C !== 0) { do { for (g = u - 1; o.bl_count[g] === 0;)g--; o.bl_count[g]--, o.bl_count[g + 1] += 2, o.bl_count[u]--, C -= 2 } while (C > 0); for (g = u; g !== 0; g--)for (d = o.bl_count[g]; d !== 0;)p = o.heap[--f], !(p > e.max_code) && (r[p * 2 + 1] != g && (o.opt_len += (g - r[p * 2 + 1]) * r[p * 2], r[p * 2 + 1] = g), d--) } } function n(o, r) { let s = 0; do s |= o & 1, o >>>= 1, s <<= 1; while (--r > 0); return s >>> 1 } function i(o, r, s) { let a = [], c = 0, u, f, d; for (u = 1; u <= 15; u++)a[u] = c = c + s[u - 1] << 1; for (f = 0; f <= r; f++)d = o[f * 2 + 1], d !== 0 && (o[f * 2] = n(a[d]++, d)) } e.build_tree = function (o) { let r = e.dyn_tree, s = e.stat_desc.static_tree, a = e.stat_desc.elems, c, u, f = -1, d; for (o.heap_len = 0, o.heap_max = 573, c = 0; c < a; c++)r[c * 2] !== 0 ? (o.heap[++o.heap_len] = f = c, o.depth[c] = 0) : r[c * 2 + 1] = 0; for (; o.heap_len < 2;)d = o.heap[++o.heap_len] = f < 2 ? ++f : 0, r[d * 2] = 1, o.depth[d] = 0, o.opt_len--, s && (o.static_len -= s[d * 2 + 1]); for (e.max_code = f, c = Math.floor(o.heap_len / 2); c >= 1; c--)o.pqdownheap(r, c); d = a; do c = o.heap[1], o.heap[1] = o.heap[o.heap_len--], o.pqdownheap(r, 1), u = o.heap[1], o.heap[--o.heap_max] = c, o.heap[--o.heap_max] = u, r[d * 2] = r[c * 2] + r[u * 2], o.depth[d] = Math.max(o.depth[c], o.depth[u]) + 1, r[c * 2 + 1] = r[u * 2 + 1] = d, o.heap[1] = d++, o.pqdownheap(r, 1); while (o.heap_len >= 2); o.heap[--o.heap_max] = o.heap[1], t(o), i(r, e.max_code, o.bl_count) } } tr._length_code = [0, 1, 2, 3, 4, 5, 6, 7].concat(...JN([[2, 8], [2, 9], [2, 10], [2, 11], [4, 12], [4, 13], [4, 14], [4, 15], [8, 16], [8, 17], [8, 18], [8, 19], [16, 20], [16, 21], [16, 22], [16, 23], [32, 24], [32, 25], [32, 26], [31, 27], [1, 28]])); tr.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0]; tr.base_dist = [0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576]; tr.d_code = function (e) { return e < 256 ? sce[e] : sce[256 + (e >>> 7)] }; tr.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]; tr.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]; tr.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]; tr.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; function ta(e, t, n, i, o) { let r = this; r.static_tree = e, r.extra_bits = t, r.extra_base = n, r.elems = i, r.max_length = o } var Sje = [12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 19, 275, 147, 403, 83, 339, 211, 467, 51, 307, 179, 435, 115, 371, 243, 499, 11, 267, 139, 395, 75, 331, 203, 459, 43, 299, 171, 427, 107, 363, 235, 491, 27, 283, 155, 411, 91, 347, 219, 475, 59, 315, 187, 443, 123, 379, 251, 507, 7, 263, 135, 391, 71, 327, 199, 455, 39, 295, 167, 423, 103, 359, 231, 487, 23, 279, 151, 407, 87, 343, 215, 471, 55, 311, 183, 439, 119, 375, 247, 503, 15, 271, 143, 399, 79, 335, 207, 463, 47, 303, 175, 431, 111, 367, 239, 495, 31, 287, 159, 415, 95, 351, 223, 479, 63, 319, 191, 447, 127, 383, 255, 511, 0, 64, 32, 96, 16, 80, 48, 112, 8, 72, 40, 104, 24, 88, 56, 120, 4, 68, 36, 100, 20, 84, 52, 116, 3, 131, 67, 195, 35, 163, 99, 227], wje = JN([[144, 8], [112, 9], [24, 7], [8, 8]]); ta.static_ltree = ZN(Sje.map((e, t) => [e, wje[t]])); var Dje = [0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30, 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23], vje = JN([[30, 5]]); ta.static_dtree = ZN(Dje.map((e, t) => [e, vje[t]])); ta.static_l_desc = new ta(ta.static_ltree, tr.extra_lbits, 256 + 1, 286, 15); ta.static_d_desc = new ta(ta.static_dtree, tr.extra_dbits, 0, 30, 15); ta.static_bl_desc = new ta(null, tr.extra_blbits, 0, 19, 7); var Pje = 9, Ije = 8; function gh(e, t, n, i, o) { let r = this; r.good_length = e, r.max_lazy = t, r.nice_length = n, r.max_chain = i, r.func = o } var cce = 0, XN = 1, By = 2, Jf = [new gh(0, 0, 0, 0, cce), new gh(4, 4, 8, 4, XN), new gh(4, 5, 16, 8, XN), new gh(4, 6, 32, 32, XN), new gh(4, 4, 16, 16, By), new gh(8, 16, 32, 32, By), new gh(8, 16, 128, 128, By), new gh(8, 32, 128, 256, By), new gh(32, 128, 258, 1024, By), new gh(32, 258, 258, 4096, By)], WN = ["need dictionary", "stream end", "", "", "stream error", "data error", "", "buffer error", "", ""], Uu = 0, jN = 1, rD = 2, qN = 3, Oje = 32, c9 = 42, YN = 113, sD = 666, l9 = 8, Bje = 0, u9 = 1, Rje = 2, cr = 3, KN = 258, Il = KN + cr + 1; function ace(e, t, n, i) { let o = e[t * 2], r = e[n * 2]; return o < r || o == r && i[t] <= i[n] } function Mje() { let e = this, t, n, i, o, r, s, a, c, u, f, d, p, g, m, A, C, x, T, b, S, D, P, B, R, M, L, _, E, w, v, O, V, z, k = new tr, G = new tr, N = new tr; e.depth = []; let X, q, J, W, K, Z; e.bl_count = [], e.heap = [], O = [], V = [], z = []; function de() { u = 2 * r, d[g - 1] = 0; for (let Le = 0; Le < g - 1; Le++)d[Le] = 0; L = Jf[_].max_lazy, w = Jf[_].good_length, v = Jf[_].nice_length, M = Jf[_].max_chain, D = 0, x = 0, B = 0, T = R = cr - 1, S = 0, p = 0 } function pe() { let Le; for (Le = 0; Le < 286; Le++)O[Le * 2] = 0; for (Le = 0; Le < 30; Le++)V[Le * 2] = 0; for (Le = 0; Le < 19; Le++)z[Le * 2] = 0; O[256 * 2] = 1, e.opt_len = e.static_len = 0, q = J = 0 } function oe() { k.dyn_tree = O, k.stat_desc = ta.static_l_desc, G.dyn_tree = V, G.stat_desc = ta.static_d_desc, N.dyn_tree = z, N.stat_desc = ta.static_bl_desc, K = 0, Z = 0, W = 8, pe() } e.pqdownheap = function (Le, et) { let Ke = e.heap, qe = Ke[et], mt = et << 1; for (; mt <= e.heap_len && (mt < e.heap_len && ace(Le, Ke[mt + 1], Ke[mt], e.depth) && mt++, !ace(Le, qe, Ke[mt], e.depth));)Ke[et] = Ke[mt], et = mt, mt <<= 1; Ke[et] = qe }; function ue(Le, et) { let Ke = -1, qe, mt = Le[0 * 2 + 1], Ft = 0, Cn = 7, ro = 4; mt === 0 && (Cn = 138, ro = 3), Le[(et + 1) * 2 + 1] = 65535; for (let So = 0; So <= et; So++)qe = mt, mt = Le[(So + 1) * 2 + 1], !(++Ft < Cn && qe == mt) && (Ft < ro ? z[qe * 2] += Ft : qe !== 0 ? (qe != Ke && z[qe * 2]++, z[16 * 2]++) : Ft <= 10 ? z[17 * 2]++ : z[18 * 2]++, Ft = 0, Ke = qe, mt === 0 ? (Cn = 138, ro = 3) : qe == mt ? (Cn = 6, ro = 3) : (Cn = 7, ro = 4)) } function ge() { let Le; for (ue(O, k.max_code), ue(V, G.max_code), N.build_tree(e), Le = 19 - 1; Le >= 3 && z[tr.bl_order[Le] * 2 + 1] === 0; Le--); return e.opt_len += 3 * (Le + 1) + 5 + 5 + 4, Le } function Ee(Le) { e.pending_buf[e.pending++] = Le } function Ie(Le) { Ee(Le & 255), Ee(Le >>> 8 & 255) } function Fe(Le) { Ee(Le >> 8 & 255), Ee(Le & 255 & 255) } function We(Le, et) { let Ke, qe = et; Z > 16 - qe ? (Ke = Le, K |= Ke << Z & 65535, Ie(K), K = Ke >>> 16 - Z, Z += qe - 16) : (K |= Le << Z & 65535, Z += qe) } function Lt(Le, et) { let Ke = Le * 2; We(et[Ke] & 65535, et[Ke + 1] & 65535) } function Gt(Le, et) { let Ke, qe = -1, mt, Ft = Le[0 * 2 + 1], Cn = 0, ro = 7, So = 4; for (Ft === 0 && (ro = 138, So = 3), Ke = 0; Ke <= et; Ke++)if (mt = Ft, Ft = Le[(Ke + 1) * 2 + 1], !(++Cn < ro && mt == Ft)) { if (Cn < So) do Lt(mt, z); while (--Cn !== 0); else mt !== 0 ? (mt != qe && (Lt(mt, z), Cn--), Lt(16, z), We(Cn - 3, 2)) : Cn <= 10 ? (Lt(17, z), We(Cn - 3, 3)) : (Lt(18, z), We(Cn - 11, 7)); Cn = 0, qe = mt, Ft === 0 ? (ro = 138, So = 3) : mt == Ft ? (ro = 6, So = 3) : (ro = 7, So = 4) } } function cn(Le, et, Ke) { let qe; for (We(Le - 257, 5), We(et - 1, 5), We(Ke - 4, 4), qe = 0; qe < Ke; qe++)We(z[tr.bl_order[qe] * 2 + 1], 3); Gt(O, Le - 1), Gt(V, et - 1) } function _t() { Z == 16 ? (Ie(K), K = 0, Z = 0) : Z >= 8 && (Ee(K & 255), K >>>= 8, Z -= 8) } function Pn() { We(u9 << 1, 3), Lt(256, ta.static_ltree), _t(), 1 + W + 10 - Z < 9 && (We(u9 << 1, 3), Lt(256, ta.static_ltree), _t()), W = 7 } function Jn(Le, et) { let Ke, qe, mt; if (e.dist_buf[q] = Le, e.lc_buf[q] = et & 255, q++, Le === 0 ? O[et * 2]++ : (J++, Le--, O[(tr._length_code[et] + 256 + 1) * 2]++, V[tr.d_code(Le) * 2]++), (q & 8191) === 0 && _ > 2) { for (Ke = q * 8, qe = D - x, mt = 0; mt < 30; mt++)Ke += V[mt * 2] * (5 + tr.extra_dbits[mt]); if (Ke >>>= 3, J < Math.floor(q / 2) && Ke < Math.floor(qe / 2)) return !0 } return q == X - 1 } function at(Le, et) { let Ke, qe, mt = 0, Ft, Cn; if (q !== 0) do Ke = e.dist_buf[mt], qe = e.lc_buf[mt], mt++, Ke === 0 ? Lt(qe, Le) : (Ft = tr._length_code[qe], Lt(Ft + 256 + 1, Le), Cn = tr.extra_lbits[Ft], Cn !== 0 && (qe -= tr.base_length[Ft], We(qe, Cn)), Ke--, Ft = tr.d_code(Ke), Lt(Ft, et), Cn = tr.extra_dbits[Ft], Cn !== 0 && (Ke -= tr.base_dist[Ft], We(Ke, Cn))); while (mt < q); Lt(256, Le), W = Le[256 * 2 + 1] } function Ne() { Z > 8 ? Ie(K) : Z > 0 && Ee(K & 255), K = 0, Z = 0 } function nt(Le, et, Ke) { Ne(), W = 8, Ke && (Ie(et), Ie(~et)), e.pending_buf.set(c.subarray(Le, Le + et), e.pending), e.pending += et } function Ce(Le, et, Ke) { We((Bje << 1) + (Ke ? 1 : 0), 3), nt(Le, et, !0) } function je(Le, et, Ke) { let qe, mt, Ft = 0; _ > 0 ? (k.build_tree(e), G.build_tree(e), Ft = ge(), qe = e.opt_len + 3 + 7 >>> 3, mt = e.static_len + 3 + 7 >>> 3, mt <= qe && (qe = mt)) : qe = mt = et + 5, et + 4 <= qe && Le != -1 ? Ce(Le, et, Ke) : mt == qe ? (We((u9 << 1) + (Ke ? 1 : 0), 3), at(ta.static_ltree, ta.static_dtree)) : (We((Rje << 1) + (Ke ? 1 : 0), 3), cn(k.max_code + 1, G.max_code + 1, Ft + 1), at(O, V)), pe(), Ke && Ne() } function ut(Le) { je(x >= 0 ? x : -1, D - x, Le), x = D, t.flush_pending() } function Wn() { let Le, et, Ke, qe; do { if (qe = u - B - D, qe === 0 && D === 0 && B === 0) qe = r; else if (qe == -1) qe--; else if (D >= r + r - Il) { c.set(c.subarray(r, r + r), 0), P -= r, D -= r, x -= r, Le = g, Ke = Le; do et = d[--Ke] & 65535, d[Ke] = et >= r ? et - r : 0; while (--Le !== 0); Le = r, Ke = Le; do et = f[--Ke] & 65535, f[Ke] = et >= r ? et - r : 0; while (--Le !== 0); qe += r } if (t.avail_in === 0) return; Le = t.read_buf(c, D + B, qe), B += Le, B >= cr && (p = c[D] & 255, p = (p << C ^ c[D + 1] & 255) & A) } while (B < Il && t.avail_in !== 0) } function Zn(Le) { let et = 65535, Ke; for (et > i - 5 && (et = i - 5); ;) { if (B <= 1) { if (Wn(), B === 0 && Le == 0) return Uu; if (B === 0) break } if (D += B, B = 0, Ke = x + et, (D === 0 || D >= Ke) && (B = D - Ke, D = Ke, ut(!1), t.avail_out === 0) || D - x >= r - Il && (ut(!1), t.avail_out === 0)) return Uu } return ut(Le == 4), t.avail_out === 0 ? Le == 4 ? rD : Uu : Le == 4 ? qN : jN } function Fi(Le) { let et = M, Ke = D, qe, mt, Ft = R, Cn = D > r - Il ? D - (r - Il) : 0, ro = v, So = a, Ao = D + KN, Hs = c[Ke + Ft - 1], nr = c[Ke + Ft]; R >= w && (et >>= 2), ro > B && (ro = B); do if (qe = Le, !(c[qe + Ft] != nr || c[qe + Ft - 1] != Hs || c[qe] != c[Ke] || c[++qe] != c[Ke + 1])) { Ke += 2, qe++; do; while (c[++Ke] == c[++qe] && c[++Ke] == c[++qe] && c[++Ke] == c[++qe] && c[++Ke] == c[++qe] && c[++Ke] == c[++qe] && c[++Ke] == c[++qe] && c[++Ke] == c[++qe] && c[++Ke] == c[++qe] && Ke < Ao); if (mt = KN - (Ao - Ke), Ke = Ao - KN, mt > Ft) { if (P = Le, Ft = mt, mt >= ro) break; Hs = c[Ke + Ft - 1], nr = c[Ke + Ft] } } while ((Le = f[Le & So] & 65535) > Cn && --et !== 0); return Ft <= B ? Ft : B } function mo(Le) { let et = 0, Ke; for (; ;) { if (B < Il) { if (Wn(), B < Il && Le == 0) return Uu; if (B === 0) break } if (B >= cr && (p = (p << C ^ c[D + (cr - 1)] & 255) & A, et = d[p] & 65535, f[D & a] = d[p], d[p] = D), et !== 0 && (D - et & 65535) <= r - Il && E != 2 && (T = Fi(et)), T >= cr) if (Ke = Jn(D - P, T - cr), B -= T, T <= L && B >= cr) { T--; do D++, p = (p << C ^ c[D + (cr - 1)] & 255) & A, et = d[p] & 65535, f[D & a] = d[p], d[p] = D; while (--T !== 0); D++ } else D += T, T = 0, p = c[D] & 255, p = (p << C ^ c[D + 1] & 255) & A; else Ke = Jn(0, c[D] & 255), B--, D++; if (Ke && (ut(!1), t.avail_out === 0)) return Uu } return ut(Le == 4), t.avail_out === 0 ? Le == 4 ? rD : Uu : Le == 4 ? qN : jN } function bo(Le) { let et = 0, Ke, qe; for (; ;) { if (B < Il) { if (Wn(), B < Il && Le == 0) return Uu; if (B === 0) break } if (B >= cr && (p = (p << C ^ c[D + (cr - 1)] & 255) & A, et = d[p] & 65535, f[D & a] = d[p], d[p] = D), R = T, b = P, T = cr - 1, et !== 0 && R < L && (D - et & 65535) <= r - Il && (E != 2 && (T = Fi(et)), T <= 5 && (E == 1 || T == cr && D - P > 4096) && (T = cr - 1)), R >= cr && T <= R) { qe = D + B - cr, Ke = Jn(D - 1 - b, R - cr), B -= R - 1, R -= 2; do ++D <= qe && (p = (p << C ^ c[D + (cr - 1)] & 255) & A, et = d[p] & 65535, f[D & a] = d[p], d[p] = D); while (--R !== 0); if (S = 0, T = cr - 1, D++, Ke && (ut(!1), t.avail_out === 0)) return Uu } else if (S !== 0) { if (Ke = Jn(0, c[D - 1] & 255), Ke && ut(!1), D++, B--, t.avail_out === 0) return Uu } else S = 1, D++, B-- } return S !== 0 && (Ke = Jn(0, c[D - 1] & 255), S = 0), ut(Le == 4), t.avail_out === 0 ? Le == 4 ? rD : Uu : Le == 4 ? qN : jN } function Ii(Le) { return Le.total_in = Le.total_out = 0, Le.msg = null, e.pending = 0, e.pending_out = 0, n = YN, o = 0, oe(), de(), 0 } e.deflateInit = function (Le, et, Ke, qe, mt, Ft) { return qe || (qe = l9), mt || (mt = Ije), Ft || (Ft = 0), Le.msg = null, et == -1 && (et = 6), mt < 1 || mt > Pje || qe != l9 || Ke < 9 || Ke > 15 || et < 0 || et > 9 || Ft < 0 || Ft > 2 ? -2 : (Le.dstate = e, s = Ke, r = 1 << s, a = r - 1, m = mt + 7, g = 1 << m, A = g - 1, C = Math.floor((m + cr - 1) / cr), c = new Uint8Array(r * 2), f = [], d = [], X = 1 << mt + 6, e.pending_buf = new Uint8Array(X * 4), i = X * 4, e.dist_buf = new Uint16Array(X), e.lc_buf = new Uint8Array(X), _ = et, E = Ft, Ii(Le)) }, e.deflateEnd = function () { return n != c9 && n != YN && n != sD ? -2 : (e.lc_buf = null, e.dist_buf = null, e.pending_buf = null, d = null, f = null, c = null, e.dstate = null, n == YN ? -3 : 0) }, e.deflateParams = function (Le, et, Ke) { let qe = 0; return et == -1 && (et = 6), et < 0 || et > 9 || Ke < 0 || Ke > 2 ? -2 : (Jf[_].func != Jf[et].func && Le.total_in !== 0 && (qe = Le.deflate(1)), _ != et && (_ = et, L = Jf[_].max_lazy, w = Jf[_].good_length, v = Jf[_].nice_length, M = Jf[_].max_chain), E = Ke, qe) }, e.deflateSetDictionary = function (Le, et, Ke) { let qe = Ke, mt, Ft = 0; if (!et || n != c9) return -2; if (qe < cr) return 0; for (qe > r - Il && (qe = r - Il, Ft = Ke - qe), c.set(et.subarray(Ft, Ft + qe), 0), D = qe, x = qe, p = c[0] & 255, p = (p << C ^ c[1] & 255) & A, mt = 0; mt <= qe - cr; mt++)p = (p << C ^ c[mt + (cr - 1)] & 255) & A, f[mt & a] = d[p], d[p] = mt; return 0 }, e.deflate = function (Le, et) { let Ke, qe, mt, Ft, Cn; if (et > 4 || et < 0) return -2; if (!Le.next_out || !Le.next_in && Le.avail_in !== 0 || n == sD && et != 4) return Le.msg = WN[2 - -2], -2; if (Le.avail_out === 0) return Le.msg = WN[2 - -5], -5; if (t = Le, Ft = o, o = et, n == c9 && (qe = l9 + (s - 8 << 4) << 8, mt = (_ - 1 & 255) >> 1, mt > 3 && (mt = 3), qe |= mt << 6, D !== 0 && (qe |= Oje), qe += 31 - qe % 31, n = YN, Fe(qe)), e.pending !== 0) { if (t.flush_pending(), t.avail_out === 0) return o = -1, 0 } else if (t.avail_in === 0 && et <= Ft && et != 4) return t.msg = WN[2 - -5], -5; if (n == sD && t.avail_in !== 0) return Le.msg = WN[2 - -5], -5; if (t.avail_in !== 0 || B !== 0 || et != 0 && n != sD) { switch (Cn = -1, Jf[_].func) { case cce: Cn = Zn(et); break; case XN: Cn = mo(et); break; case By: Cn = bo(et); break; default: }if ((Cn == rD || Cn == qN) && (n = sD), Cn == Uu || Cn == rD) return t.avail_out === 0 && (o = -1), 0; if (Cn == jN) { if (et == 1) Pn(); else if (Ce(0, 0, !1), et == 3) for (Ke = 0; Ke < g; Ke++)d[Ke] = 0; if (t.flush_pending(), t.avail_out === 0) return o = -1, 0 } } return et != 4 ? 0 : 1 } } function lce() { let e = this; e.next_in_index = 0, e.next_out_index = 0, e.avail_in = 0, e.total_in = 0, e.avail_out = 0, e.total_out = 0 } lce.prototype = { deflateInit: function (e, t) { let n = this; return n.dstate = new Mje, t || (t = 15), n.dstate.deflateInit(n, e, t) }, deflate: function (e) { let t = this; return t.dstate ? t.dstate.deflate(t, e) : -2 }, deflateEnd: function () { let e = this; if (!e.dstate) return -2; let t = e.dstate.deflateEnd(); return e.dstate = null, t }, deflateParams: function (e, t) { let n = this; return n.dstate ? n.dstate.deflateParams(n, e, t) : -2 }, deflateSetDictionary: function (e, t) { let n = this; return n.dstate ? n.dstate.deflateSetDictionary(n, e, t) : -2 }, read_buf: function (e, t, n) { let i = this, o = i.avail_in; return o > n && (o = n), o === 0 ? 0 : (i.avail_in -= o, e.set(i.next_in.subarray(i.next_in_index, i.next_in_index + o), t), i.next_in_index += o, i.total_in += o, o) }, flush_pending: function () { let e = this, t = e.dstate.pending; t > e.avail_out && (t = e.avail_out), t !== 0 && (e.next_out.set(e.dstate.pending_buf.subarray(e.dstate.pending_out, e.dstate.pending_out + t), e.next_out_index), e.next_out_index += t, e.dstate.pending_out += t, e.total_out += t, e.avail_out -= t, e.dstate.pending -= t, e.dstate.pending === 0 && (e.dstate.pending_out = 0)) } }; function Lje(e) { let t = this, n = new lce, i = Fje(e && e.chunkSize ? e.chunkSize : 64 * 1024), o = 0, r = new Uint8Array(i), s = e ? e.level : -1; typeof s > "u" && (s = -1), n.deflateInit(s), n.next_out = r, t.append = function (a, c) { let u, f, d = 0, p = 0, g = 0, m = []; if (!!a.length) { n.next_in_index = 0, n.next_in = a, n.avail_in = a.length; do { if (n.next_out_index = 0, n.avail_out = i, u = n.deflate(o), u != 0) throw new Error("deflating: " + n.msg); n.next_out_index && (n.next_out_index == i ? m.push(new Uint8Array(r)) : m.push(r.slice(0, n.next_out_index))), g += n.next_out_index, c && n.next_in_index > 0 && n.next_in_index != d && (c(n.next_in_index), d = n.next_in_index) } while (n.avail_in > 0 || n.avail_out === 0); return m.length > 1 ? (f = new Uint8Array(g), m.forEach(function (A) { f.set(A, p), p += A.length })) : f = m[0] || new Uint8Array(0), f } }, t.flush = function () { let a, c, u = 0, f = 0, d = []; do { if (n.next_out_index = 0, n.avail_out = i, a = n.deflate(4), a != 1 && a != 0) throw new Error("deflating: " + n.msg); i - n.avail_out > 0 && d.push(r.slice(0, n.next_out_index)), f += n.next_out_index } while (n.avail_in > 0 || n.avail_out === 0); return n.deflateEnd(), c = new Uint8Array(f), d.forEach(function (p) { c.set(p, u), u += p.length }), c } } function Fje(e) { return e + 5 * (Math.floor(e / 16383) + 1) } var uce = Lje; var Ol = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535], Ice = 1440, Nje = 0, Vje = 4, kje = 9, Uje = 5, zje = [96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255], Hje = [80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5, 8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5, 24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577], Gje = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], Wje = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112], jje = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], qje = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], ug = 15; function m9() { let e = this, t, n, i, o, r, s; function a(u, f, d, p, g, m, A, C, x, T, b) { let S, D, P, B, R, M, L, _, E, w, v, O, V, z, k; w = 0, R = d; do i[u[f + w]]++, w++, R--; while (R !== 0); if (i[0] == d) return A[0] = -1, C[0] = 0, 0; for (_ = C[0], M = 1; M <= ug && i[M] === 0; M++); for (L = M, _ < M && (_ = M), R = ug; R !== 0 && i[R] === 0; R--); for (P = R, _ > R && (_ = R), C[0] = _, z = 1 << M; M < R; M++, z <<= 1)if ((z -= i[M]) < 0) return -3; if ((z -= i[R]) < 0) return -3; for (i[R] += z, s[1] = M = 0, w = 1, V = 2; --R !== 0;)s[V] = M += i[w], V++, w++; R = 0, w = 0; do (M = u[f + w]) !== 0 && (b[s[M]++] = R), w++; while (++R < d); for (d = s[P], s[0] = R = 0, w = 0, B = -1, O = -_, r[0] = 0, v = 0, k = 0; L <= P; L++)for (S = i[L]; S-- !== 0;) { for (; L > O + _;) { if (B++, O += _, k = P - O, k = k > _ ? _ : k, (D = 1 << (M = L - O)) > S + 1 && (D -= S + 1, V = L, M < k)) for (; ++M < k && !((D <<= 1) <= i[++V]);)D -= i[V]; if (k = 1 << M, T[0] + k > Ice) return -3; r[B] = v = T[0], T[0] += k, B !== 0 ? (s[B] = R, o[0] = M, o[1] = _, M = R >>> O - _, o[2] = v - r[B - 1] - M, x.set(o, (r[B - 1] + M) * 3)) : A[0] = v } for (o[1] = L - O, w >= d ? o[0] = 128 + 64 : b[w] < p ? (o[0] = b[w] < 256 ? 0 : 32 + 64, o[2] = b[w++]) : (o[0] = m[b[w] - p] + 16 + 64, o[2] = g[b[w++] - p]), D = 1 << L - O, M = R >>> O; M < k; M += D)x.set(o, (v + M) * 3); for (M = 1 << L - 1; (R & M) !== 0; M >>>= 1)R ^= M; for (R ^= M, E = (1 << O) - 1; (R & E) != s[B];)B--, O -= _, E = (1 << O) - 1 } return z !== 0 && P != 1 ? -5 : 0 } function c(u) { let f; for (t || (t = [], n = [], i = new Int32Array(ug + 1), o = [], r = new Int32Array(ug), s = new Int32Array(ug + 1)), n.length < u && (n = []), f = 0; f < u; f++)n[f] = 0; for (f = 0; f < ug + 1; f++)i[f] = 0; for (f = 0; f < 3; f++)o[f] = 0; r.set(i.subarray(0, ug), 0), s.set(i.subarray(0, ug + 1), 0) } e.inflate_trees_bits = function (u, f, d, p, g) { let m; return c(19), t[0] = 0, m = a(u, 0, 19, 19, null, null, d, f, p, t, n), m == -3 ? g.msg = "oversubscribed dynamic bit lengths tree" : (m == -5 || f[0] === 0) && (g.msg = "incomplete dynamic bit lengths tree", m = -3), m }, e.inflate_trees_dynamic = function (u, f, d, p, g, m, A, C, x) { let T; return c(288), t[0] = 0, T = a(d, 0, u, 257, Gje, Wje, m, p, C, t, n), T != 0 || p[0] === 0 ? (T == -3 ? x.msg = "oversubscribed literal/length tree" : T != -4 && (x.msg = "incomplete literal/length tree", T = -3), T) : (c(288), T = a(d, u, f, 0, jje, qje, A, g, C, t, n), T != 0 || g[0] === 0 && u > 257 ? (T == -3 ? x.msg = "oversubscribed distance tree" : T == -5 ? (x.msg = "incomplete distance tree", T = -3) : T != -4 && (x.msg = "empty distance tree with lengths", T = -3), T) : 0) } } m9.inflate_trees_fixed = function (e, t, n, i) { return e[0] = kje, t[0] = Uje, n[0] = zje, i[0] = Hje, 0 }; var QN = 0, fce = 1, dce = 2, hce = 3, mce = 4, pce = 5, _ce = 6, f9 = 7, gce = 8, $N = 9; function Yje() { let e = this, t, n = 0, i, o = 0, r = 0, s = 0, a = 0, c = 0, u = 0, f = 0, d, p = 0, g, m = 0; function A(C, x, T, b, S, D, P, B) { let R, M, L, _, E, w, v, O, V, z, k, G, N, X, q, J; v = B.next_in_index, O = B.avail_in, E = P.bitb, w = P.bitk, V = P.write, z = V < P.read ? P.read - V - 1 : P.end - V, k = Ol[C], G = Ol[x]; do { for (; w < 20;)O--, E |= (B.read_byte(v++) & 255) << w, w += 8; if (R = E & k, M = T, L = b, J = (L + R) * 3, (_ = M[J]) === 0) { E >>= M[J + 1], w -= M[J + 1], P.win[V++] = M[J + 2], z--; continue } do { if (E >>= M[J + 1], w -= M[J + 1], (_ & 16) !== 0) { for (_ &= 15, N = M[J + 2] + (E & Ol[_]), E >>= _, w -= _; w < 15;)O--, E |= (B.read_byte(v++) & 255) << w, w += 8; R = E & G, M = S, L = D, J = (L + R) * 3, _ = M[J]; do if (E >>= M[J + 1], w -= M[J + 1], (_ & 16) !== 0) { for (_ &= 15; w < _;)O--, E |= (B.read_byte(v++) & 255) << w, w += 8; if (X = M[J + 2] + (E & Ol[_]), E >>= _, w -= _, z -= N, V >= X) q = V - X, V - q > 0 && 2 > V - q ? (P.win[V++] = P.win[q++], P.win[V++] = P.win[q++], N -= 2) : (P.win.set(P.win.subarray(q, q + 2), V), V += 2, q += 2, N -= 2); else { q = V - X; do q += P.end; while (q < 0); if (_ = P.end - q, N > _) { if (N -= _, V - q > 0 && _ > V - q) do P.win[V++] = P.win[q++]; while (--_ !== 0); else P.win.set(P.win.subarray(q, q + _), V), V += _, q += _, _ = 0; q = 0 } } if (V - q > 0 && N > V - q) do P.win[V++] = P.win[q++]; while (--N !== 0); else P.win.set(P.win.subarray(q, q + N), V), V += N, q += N, N = 0; break } else if ((_ & 64) === 0) R += M[J + 2], R += E & Ol[_], J = (L + R) * 3, _ = M[J]; else return B.msg = "invalid distance code", N = B.avail_in - O, N = w >> 3 < N ? w >> 3 : N, O += N, v -= N, w -= N << 3, P.bitb = E, P.bitk = w, B.avail_in = O, B.total_in += v - B.next_in_index, B.next_in_index = v, P.write = V, -3; while (!0); break } if ((_ & 64) === 0) { if (R += M[J + 2], R += E & Ol[_], J = (L + R) * 3, (_ = M[J]) === 0) { E >>= M[J + 1], w -= M[J + 1], P.win[V++] = M[J + 2], z--; break } } else return (_ & 32) !== 0 ? (N = B.avail_in - O, N = w >> 3 < N ? w >> 3 : N, O += N, v -= N, w -= N << 3, P.bitb = E, P.bitk = w, B.avail_in = O, B.total_in += v - B.next_in_index, B.next_in_index = v, P.write = V, 1) : (B.msg = "invalid literal/length code", N = B.avail_in - O, N = w >> 3 < N ? w >> 3 : N, O += N, v -= N, w -= N << 3, P.bitb = E, P.bitk = w, B.avail_in = O, B.total_in += v - B.next_in_index, B.next_in_index = v, P.write = V, -3) } while (!0) } while (z >= 258 && O >= 10); return N = B.avail_in - O, N = w >> 3 < N ? w >> 3 : N, O += N, v -= N, w -= N << 3, P.bitb = E, P.bitk = w, B.avail_in = O, B.total_in += v - B.next_in_index, B.next_in_index = v, P.write = V, 0 } e.init = function (C, x, T, b, S, D) { t = QN, u = C, f = x, d = T, p = b, g = S, m = D, i = null }, e.proc = function (C, x, T) { let b, S, D, P = 0, B = 0, R = 0, M, L, _, E; for (R = x.next_in_index, M = x.avail_in, P = C.bitb, B = C.bitk, L = C.write, _ = L < C.read ? C.read - L - 1 : C.end - L; ;)switch (t) { case QN: if (_ >= 258 && M >= 10 && (C.bitb = P, C.bitk = B, x.avail_in = M, x.total_in += R - x.next_in_index, x.next_in_index = R, C.write = L, T = A(u, f, d, p, g, m, C, x), R = x.next_in_index, M = x.avail_in, P = C.bitb, B = C.bitk, L = C.write, _ = L < C.read ? C.read - L - 1 : C.end - L, T != 0)) { t = T == 1 ? f9 : $N; break } r = u, i = d, o = p, t = fce; case fce: for (b = r; B < b;) { if (M !== 0) T = 0; else return C.bitb = P, C.bitk = B, x.avail_in = M, x.total_in += R - x.next_in_index, x.next_in_index = R, C.write = L, C.inflate_flush(x, T); M--, P |= (x.read_byte(R++) & 255) << B, B += 8 } if (S = (o + (P & Ol[b])) * 3, P >>>= i[S + 1], B -= i[S + 1], D = i[S], D === 0) { s = i[S + 2], t = _ce; break } if ((D & 16) !== 0) { a = D & 15, n = i[S + 2], t = dce; break } if ((D & 64) === 0) { r = D, o = S / 3 + i[S + 2]; break } if ((D & 32) !== 0) { t = f9; break } return t = $N, x.msg = "invalid literal/length code", T = -3, C.bitb = P, C.bitk = B, x.avail_in = M, x.total_in += R - x.next_in_index, x.next_in_index = R, C.write = L, C.inflate_flush(x, T); case dce: for (b = a; B < b;) { if (M !== 0) T = 0; else return C.bitb = P, C.bitk = B, x.avail_in = M, x.total_in += R - x.next_in_index, x.next_in_index = R, C.write = L, C.inflate_flush(x, T); M--, P |= (x.read_byte(R++) & 255) << B, B += 8 } n += P & Ol[b], P >>= b, B -= b, r = f, i = g, o = m, t = hce; case hce: for (b = r; B < b;) { if (M !== 0) T = 0; else return C.bitb = P, C.bitk = B, x.avail_in = M, x.total_in += R - x.next_in_index, x.next_in_index = R, C.write = L, C.inflate_flush(x, T); M--, P |= (x.read_byte(R++) & 255) << B, B += 8 } if (S = (o + (P & Ol[b])) * 3, P >>= i[S + 1], B -= i[S + 1], D = i[S], (D & 16) !== 0) { a = D & 15, c = i[S + 2], t = mce; break } if ((D & 64) === 0) { r = D, o = S / 3 + i[S + 2]; break } return t = $N, x.msg = "invalid distance code", T = -3, C.bitb = P, C.bitk = B, x.avail_in = M, x.total_in += R - x.next_in_index, x.next_in_index = R, C.write = L, C.inflate_flush(x, T); case mce: for (b = a; B < b;) { if (M !== 0) T = 0; else return C.bitb = P, C.bitk = B, x.avail_in = M, x.total_in += R - x.next_in_index, x.next_in_index = R, C.write = L, C.inflate_flush(x, T); M--, P |= (x.read_byte(R++) & 255) << B, B += 8 } c += P & Ol[b], P >>= b, B -= b, t = pce; case pce: for (E = L - c; E < 0;)E += C.end; for (; n !== 0;) { if (_ === 0 && (L == C.end && C.read !== 0 && (L = 0, _ = L < C.read ? C.read - L - 1 : C.end - L), _ === 0 && (C.write = L, T = C.inflate_flush(x, T), L = C.write, _ = L < C.read ? C.read - L - 1 : C.end - L, L == C.end && C.read !== 0 && (L = 0, _ = L < C.read ? C.read - L - 1 : C.end - L), _ === 0))) return C.bitb = P, C.bitk = B, x.avail_in = M, x.total_in += R - x.next_in_index, x.next_in_index = R, C.write = L, C.inflate_flush(x, T); C.win[L++] = C.win[E++], _--, E == C.end && (E = 0), n-- } t = QN; break; case _ce: if (_ === 0 && (L == C.end && C.read !== 0 && (L = 0, _ = L < C.read ? C.read - L - 1 : C.end - L), _ === 0 && (C.write = L, T = C.inflate_flush(x, T), L = C.write, _ = L < C.read ? C.read - L - 1 : C.end - L, L == C.end && C.read !== 0 && (L = 0, _ = L < C.read ? C.read - L - 1 : C.end - L), _ === 0))) return C.bitb = P, C.bitk = B, x.avail_in = M, x.total_in += R - x.next_in_index, x.next_in_index = R, C.write = L, C.inflate_flush(x, T); T = 0, C.win[L++] = s, _--, t = QN; break; case f9: if (B > 7 && (B -= 8, M++, R--), C.write = L, T = C.inflate_flush(x, T), L = C.write, _ = L < C.read ? C.read - L - 1 : C.end - L, C.read != C.write) return C.bitb = P, C.bitk = B, x.avail_in = M, x.total_in += R - x.next_in_index, x.next_in_index = R, C.write = L, C.inflate_flush(x, T); t = gce; case gce: return T = 1, C.bitb = P, C.bitk = B, x.avail_in = M, x.total_in += R - x.next_in_index, x.next_in_index = R, C.write = L, C.inflate_flush(x, T); case $N: return T = -3, C.bitb = P, C.bitk = B, x.avail_in = M, x.total_in += R - x.next_in_index, x.next_in_index = R, C.write = L, C.inflate_flush(x, T); default: return T = -2, C.bitb = P, C.bitk = B, x.avail_in = M, x.total_in += R - x.next_in_index, x.next_in_index = R, C.write = L, C.inflate_flush(x, T) } }, e.free = function () { } } var yce = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], FT = 0, d9 = 1, Ace = 2, Cce = 3, xce = 4, Tce = 5, e2 = 6, t2 = 7, Ece = 8, Ry = 9; function Xje(e, t) { let n = this, i = FT, o = 0, r = 0, s = 0, a, c = [0], u = [0], f = new Yje, d = 0, p = new Int32Array(Ice * 3), g = 0, m = new m9; n.bitk = 0, n.bitb = 0, n.win = new Uint8Array(t), n.end = t, n.read = 0, n.write = 0, n.reset = function (A, C) { C && (C[0] = g), i == e2 && f.free(A), i = FT, n.bitk = 0, n.bitb = 0, n.read = n.write = 0 }, n.reset(e, null), n.inflate_flush = function (A, C) { let x, T, b; return T = A.next_out_index, b = n.read, x = (b <= n.write ? n.write : n.end) - b, x > A.avail_out && (x = A.avail_out), x !== 0 && C == -5 && (C = 0), A.avail_out -= x, A.total_out += x, A.next_out.set(n.win.subarray(b, b + x), T), T += x, b += x, b == n.end && (b = 0, n.write == n.end && (n.write = 0), x = n.write - b, x > A.avail_out && (x = A.avail_out), x !== 0 && C == -5 && (C = 0), A.avail_out -= x, A.total_out += x, A.next_out.set(n.win.subarray(b, b + x), T), T += x, b += x), A.next_out_index = T, n.read = b, C }, n.proc = function (A, C) { let x, T, b, S, D, P, B, R; for (S = A.next_in_index, D = A.avail_in, T = n.bitb, b = n.bitk, P = n.write, B = P < n.read ? n.read - P - 1 : n.end - P; ;) { let M, L, _, E, w, v, O, V; switch (i) { case FT: for (; b < 3;) { if (D !== 0) C = 0; else return n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C); D--, T |= (A.read_byte(S++) & 255) << b, b += 8 } switch (x = T & 7, d = x & 1, x >>> 1) { case 0: T >>>= 3, b -= 3, x = b & 7, T >>>= x, b -= x, i = d9; break; case 1: M = [], L = [], _ = [[]], E = [[]], m9.inflate_trees_fixed(M, L, _, E), f.init(M[0], L[0], _[0], 0, E[0], 0), T >>>= 3, b -= 3, i = e2; break; case 2: T >>>= 3, b -= 3, i = Cce; break; case 3: return T >>>= 3, b -= 3, i = Ry, A.msg = "invalid block type", C = -3, n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C) }break; case d9: for (; b < 32;) { if (D !== 0) C = 0; else return n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C); D--, T |= (A.read_byte(S++) & 255) << b, b += 8 } if ((~T >>> 16 & 65535) != (T & 65535)) return i = Ry, A.msg = "invalid stored block lengths", C = -3, n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C); o = T & 65535, T = b = 0, i = o !== 0 ? Ace : d !== 0 ? t2 : FT; break; case Ace: if (D === 0 || B === 0 && (P == n.end && n.read !== 0 && (P = 0, B = P < n.read ? n.read - P - 1 : n.end - P), B === 0 && (n.write = P, C = n.inflate_flush(A, C), P = n.write, B = P < n.read ? n.read - P - 1 : n.end - P, P == n.end && n.read !== 0 && (P = 0, B = P < n.read ? n.read - P - 1 : n.end - P), B === 0))) return n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C); if (C = 0, x = o, x > D && (x = D), x > B && (x = B), n.win.set(A.read_buf(S, x), P), S += x, D -= x, P += x, B -= x, (o -= x) !== 0) break; i = d !== 0 ? t2 : FT; break; case Cce: for (; b < 14;) { if (D !== 0) C = 0; else return n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C); D--, T |= (A.read_byte(S++) & 255) << b, b += 8 } if (r = x = T & 16383, (x & 31) > 29 || (x >> 5 & 31) > 29) return i = Ry, A.msg = "too many length or distance symbols", C = -3, n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C); if (x = 258 + (x & 31) + (x >> 5 & 31), !a || a.length < x) a = []; else for (R = 0; R < x; R++)a[R] = 0; T >>>= 14, b -= 14, s = 0, i = xce; case xce: for (; s < 4 + (r >>> 10);) { for (; b < 3;) { if (D !== 0) C = 0; else return n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C); D--, T |= (A.read_byte(S++) & 255) << b, b += 8 } a[yce[s++]] = T & 7, T >>>= 3, b -= 3 } for (; s < 19;)a[yce[s++]] = 0; if (c[0] = 7, x = m.inflate_trees_bits(a, c, u, p, A), x != 0) return C = x, C == -3 && (a = null, i = Ry), n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C); s = 0, i = Tce; case Tce: for (; x = r, !(s >= 258 + (x & 31) + (x >> 5 & 31));) { let z, k; for (x = c[0]; b < x;) { if (D !== 0) C = 0; else return n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C); D--, T |= (A.read_byte(S++) & 255) << b, b += 8 } if (x = p[(u[0] + (T & Ol[x])) * 3 + 1], k = p[(u[0] + (T & Ol[x])) * 3 + 2], k < 16) T >>>= x, b -= x, a[s++] = k; else { for (R = k == 18 ? 7 : k - 14, z = k == 18 ? 11 : 3; b < x + R;) { if (D !== 0) C = 0; else return n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C); D--, T |= (A.read_byte(S++) & 255) << b, b += 8 } if (T >>>= x, b -= x, z += T & Ol[R], T >>>= R, b -= R, R = s, x = r, R + z > 258 + (x & 31) + (x >> 5 & 31) || k == 16 && R < 1) return a = null, i = Ry, A.msg = "invalid bit length repeat", C = -3, n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C); k = k == 16 ? a[R - 1] : 0; do a[R++] = k; while (--z !== 0); s = R } } if (u[0] = -1, w = [], v = [], O = [], V = [], w[0] = 9, v[0] = 6, x = r, x = m.inflate_trees_dynamic(257 + (x & 31), 1 + (x >> 5 & 31), a, w, v, O, V, p, A), x != 0) return x == -3 && (a = null, i = Ry), C = x, n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C); f.init(w[0], v[0], p, O[0], p, V[0]), i = e2; case e2: if (n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, (C = f.proc(n, A, C)) != 1) return n.inflate_flush(A, C); if (C = 0, f.free(A), S = A.next_in_index, D = A.avail_in, T = n.bitb, b = n.bitk, P = n.write, B = P < n.read ? n.read - P - 1 : n.end - P, d === 0) { i = FT; break } i = t2; case t2: if (n.write = P, C = n.inflate_flush(A, C), P = n.write, B = P < n.read ? n.read - P - 1 : n.end - P, n.read != n.write) return n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C); i = Ece; case Ece: return C = 1, n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C); case Ry: return C = -3, n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C); default: return C = -2, n.bitb = T, n.bitk = b, A.avail_in = D, A.total_in += S - A.next_in_index, A.next_in_index = S, n.write = P, n.inflate_flush(A, C) } } }, n.free = function (A) { n.reset(A, null), n.win = null, p = null }, n.set_dictionary = function (A, C, x) { n.win.set(A.subarray(C, C + x), 0), n.read = n.write = x }, n.sync_point = function () { return i == d9 ? 1 : 0 } } var Kje = 32, Jje = 8, Zje = 0, bce = 1, Sce = 2, wce = 3, Dce = 4, vce = 5, h9 = 6, aD = 7, Pce = 12, fg = 13, Qje = [0, 0, 255, 255]; function $je() { let e = this; e.mode = 0, e.method = 0, e.was = [0], e.need = 0, e.marker = 0, e.wbits = 0; function t(n) { return !n || !n.istate ? -2 : (n.total_in = n.total_out = 0, n.msg = null, n.istate.mode = aD, n.istate.blocks.reset(n, null), 0) } e.inflateEnd = function (n) { return e.blocks && e.blocks.free(n), e.blocks = null, 0 }, e.inflateInit = function (n, i) { return n.msg = null, e.blocks = null, i < 8 || i > 15 ? (e.inflateEnd(n), -2) : (e.wbits = i, n.istate.blocks = new Xje(n, 1 << i), t(n), 0) }, e.inflate = function (n, i) { let o, r; if (!n || !n.istate || !n.next_in) return -2; let s = n.istate; for (i = i == Vje ? -5 : 0, o = -5; ;)switch (s.mode) { case Zje: if (n.avail_in === 0) return o; if (o = i, n.avail_in--, n.total_in++, ((s.method = n.read_byte(n.next_in_index++)) & 15) != Jje) { s.mode = fg, n.msg = "unknown compression method", s.marker = 5; break } if ((s.method >> 4) + 8 > s.wbits) { s.mode = fg, n.msg = "invalid win size", s.marker = 5; break } s.mode = bce; case bce: if (n.avail_in === 0) return o; if (o = i, n.avail_in--, n.total_in++, r = n.read_byte(n.next_in_index++) & 255, ((s.method << 8) + r) % 31 !== 0) { s.mode = fg, n.msg = "incorrect header check", s.marker = 5; break } if ((r & Kje) === 0) { s.mode = aD; break } s.mode = Sce; case Sce: if (n.avail_in === 0) return o; o = i, n.avail_in--, n.total_in++, s.need = (n.read_byte(n.next_in_index++) & 255) << 24 & 4278190080, s.mode = wce; case wce: if (n.avail_in === 0) return o; o = i, n.avail_in--, n.total_in++, s.need += (n.read_byte(n.next_in_index++) & 255) << 16 & 16711680, s.mode = Dce; case Dce: if (n.avail_in === 0) return o; o = i, n.avail_in--, n.total_in++, s.need += (n.read_byte(n.next_in_index++) & 255) << 8 & 65280, s.mode = vce; case vce: return n.avail_in === 0 ? o : (o = i, n.avail_in--, n.total_in++, s.need += n.read_byte(n.next_in_index++) & 255, s.mode = h9, 2); case h9: return s.mode = fg, n.msg = "need dictionary", s.marker = 0, -2; case aD: if (o = s.blocks.proc(n, o), o == -3) { s.mode = fg, s.marker = 0; break } if (o == 0 && (o = i), o != 1) return o; o = i, s.blocks.reset(n, s.was), s.mode = Pce; case Pce: return n.avail_in = 0, 1; case fg: return -3; default: return -2 } }, e.inflateSetDictionary = function (n, i, o) { let r = 0, s = o; if (!n || !n.istate || n.istate.mode != h9) return -2; let a = n.istate; return s >= 1 << a.wbits && (s = (1 << a.wbits) - 1, r = o - s), a.blocks.set_dictionary(i, r, s), a.mode = aD, 0 }, e.inflateSync = function (n) { let i, o, r, s, a; if (!n || !n.istate) return -2; let c = n.istate; if (c.mode != fg && (c.mode = fg, c.marker = 0), (i = n.avail_in) === 0) return -5; for (o = n.next_in_index, r = c.marker; i !== 0 && r < 4;)n.read_byte(o) == Qje[r] ? r++ : n.read_byte(o) !== 0 ? r = 0 : r = 4 - r, o++, i--; return n.total_in += o - n.next_in_index, n.next_in_index = o, n.avail_in = i, c.marker = r, r != 4 ? -3 : (s = n.total_in, a = n.total_out, t(n), n.total_in = s, n.total_out = a, c.mode = aD, 0) }, e.inflateSyncPoint = function (n) { return !n || !n.istate || !n.istate.blocks ? -2 : n.istate.blocks.sync_point() } } function Oce() { } Oce.prototype = { inflateInit: function (e) { let t = this; return t.istate = new $je, e || (e = 15), t.istate.inflateInit(t, e) }, inflate: function (e) { let t = this; return t.istate ? t.istate.inflate(t, e) : -2 }, inflateEnd: function () { let e = this; if (!e.istate) return -2; let t = e.istate.inflateEnd(e); return e.istate = null, t }, inflateSync: function () { let e = this; return e.istate ? e.istate.inflateSync(e) : -2 }, inflateSetDictionary: function (e, t) { let n = this; return n.istate ? n.istate.inflateSetDictionary(n, e, t) : -2 }, read_byte: function (e) { return this.next_in[e] }, read_buf: function (e, t) { return this.next_in.subarray(e, e + t) } }; function eqe(e) { let t = this, n = new Oce, i = e && e.chunkSize ? Math.floor(e.chunkSize * 2) : 128 * 1024, o = Nje, r = new Uint8Array(i), s = !1; n.inflateInit(), n.next_out = r, t.append = function (a, c) { let u = [], f, d, p = 0, g = 0, m = 0; if (a.length !== 0) { n.next_in_index = 0, n.next_in = a, n.avail_in = a.length; do { if (n.next_out_index = 0, n.avail_out = i, n.avail_in === 0 && !s && (n.next_in_index = 0, s = !0), f = n.inflate(o), s && f === -5) { if (n.avail_in !== 0) throw new Error("inflating: bad input") } else if (f !== 0 && f !== 1) throw new Error("inflating: " + n.msg); if ((s || f === 1) && n.avail_in === a.length) throw new Error("inflating: bad input"); n.next_out_index && (n.next_out_index === i ? u.push(new Uint8Array(r)) : u.push(r.slice(0, n.next_out_index))), m += n.next_out_index, c && n.next_in_index > 0 && n.next_in_index != p && (c(n.next_in_index), p = n.next_in_index) } while (n.avail_in > 0 || n.avail_out === 0); return u.length > 1 ? (d = new Uint8Array(m), u.forEach(function (A) { d.set(A, g), g += A.length })) : d = u[0] || new Uint8Array(0), d } }, t.flush = function () { n.inflateEnd() } } var Bce = eqe; var tqe = { chunkSize: 524288, maxWorkers: typeof navigator < "u" && navigator.hardwareConcurrency || 2, terminateWorkerTimeout: 5e3, useWebWorkers: !0, workerScripts: void 0 }, Xc = Object.assign({}, tqe); function n2() { return Xc } function NT(e) { if (e.baseURL !== void 0 && (Xc.baseURL = e.baseURL), e.chunkSize !== void 0 && (Xc.chunkSize = e.chunkSize), e.maxWorkers !== void 0 && (Xc.maxWorkers = e.maxWorkers), e.terminateWorkerTimeout !== void 0 && (Xc.terminateWorkerTimeout = e.terminateWorkerTimeout), e.useWebWorkers !== void 0 && (Xc.useWebWorkers = e.useWebWorkers), e.Deflate !== void 0 && (Xc.Deflate = e.Deflate), e.Inflate !== void 0 && (Xc.Inflate = e.Inflate), e.workerScripts !== void 0) { if (e.workerScripts.deflate) { if (!Array.isArray(e.workerScripts.deflate)) throw new Error("workerScripts.deflate must be an array"); Xc.workerScripts || (Xc.workerScripts = {}), Xc.workerScripts.deflate = e.workerScripts.deflate } if (e.workerScripts.inflate) { if (!Array.isArray(e.workerScripts.inflate)) throw new Error("workerScripts.inflate must be an array"); Xc.workerScripts || (Xc.workerScripts = {}), Xc.workerScripts.inflate = e.workerScripts.inflate } } } var Rce = []; for (let e = 0; e < 256; e++) { let t = e; for (let n = 0; n < 8; n++)t & 1 ? t = t >>> 1 ^ 3988292384 : t = t >>> 1; Rce[e] = t } var p9 = class { constructor(t) { this.crc = t || -1 } append(t) { let n = this.crc | 0; for (let i = 0, o = t.length | 0; i < o; i++)n = n >>> 8 ^ Rce[(n ^ t[i]) & 255]; this.crc = n } get() { return ~this.crc } }, dg = p9; var cD = nqe; function nqe(e) { if (typeof TextEncoder > "u") { e = unescape(encodeURIComponent(e)); let t = new Uint8Array(e.length); for (let n = 0; n < t.length; n++)t[n] = e.charCodeAt(n); return t } else return new TextEncoder().encode(e) } var hc = { concat(e, t) { if (e.length === 0 || t.length === 0) return e.concat(t); let n = e[e.length - 1], i = hc.getPartial(n); return i === 32 ? e.concat(t) : hc._shiftRight(t, i, n | 0, e.slice(0, e.length - 1)) }, bitLength(e) { let t = e.length; if (t === 0) return 0; let n = e[t - 1]; return (t - 1) * 32 + hc.getPartial(n) }, clamp(e, t) { if (e.length * 32 < t) return e; e = e.slice(0, Math.ceil(t / 32)); let n = e.length; return t = t & 31, n > 0 && t && (e[n - 1] = hc.partial(t, e[n - 1] & 2147483648 >> t - 1, 1)), e }, partial(e, t, n) { return e === 32 ? t : (n ? t | 0 : t << 32 - e) + e * 1099511627776 }, getPartial(e) { return Math.round(e / 1099511627776) || 32 }, _shiftRight(e, t, n, i) { for (i === void 0 && (i = []); t >= 32; t -= 32)i.push(n), n = 0; if (t === 0) return i.concat(e); for (let s = 0; s < e.length; s++)i.push(n | e[s] >>> t), n = e[s] << 32 - t; let o = e.length ? e[e.length - 1] : 0, r = hc.getPartial(o); return i.push(hc.partial(t + r & 31, t + r > 32 ? n : i.pop(), 1)), i } }, lD = { bytes: { fromBits(e) { let n = hc.bitLength(e) / 8, i = new Uint8Array(n), o; for (let r = 0; r < n; r++)(r & 3) === 0 && (o = e[r / 4]), i[r] = o >>> 24, o <<= 8; return i }, toBits(e) { let t = [], n, i = 0; for (n = 0; n < e.length; n++)i = i << 8 | e[n], (n & 3) === 3 && (t.push(i), i = 0); return n & 3 && t.push(hc.partial(8 * (n & 3), i)), t } } }, _9 = {}; _9.sha1 = function (e) { e ? (this._h = e._h.slice(0), this._buffer = e._buffer.slice(0), this._length = e._length) : this.reset() }; _9.sha1.prototype = { blockSize: 512, reset: function () { let e = this; return e._h = this._init.slice(0), e._buffer = [], e._length = 0, e }, update: function (e) { let t = this; typeof e == "string" && (e = lD.utf8String.toBits(e)); let n = t._buffer = hc.concat(t._buffer, e), i = t._length, o = t._length = i + hc.bitLength(e); if (o > 9007199254740991) throw new Error("Cannot hash more than 2^53 - 1 bits"); let r = new Uint32Array(n), s = 0; for (let a = t.blockSize + i - (t.blockSize + i & t.blockSize - 1); a <= o; a += t.blockSize)t._block(r.subarray(16 * s, 16 * (s + 1))), s += 1; return n.splice(0, 16 * s), t }, finalize: function () { let e = this, t = e._buffer, n = e._h; t = hc.concat(t, [hc.partial(1, 1)]); for (let i = t.length + 2; i & 15; i++)t.push(0); for (t.push(Math.floor(e._length / 4294967296)), t.push(e._length | 0); t.length;)e._block(t.splice(0, 16)); return e.reset(), n }, _init: [1732584193, 4023233417, 2562383102, 271733878, 3285377520], _key: [1518500249, 1859775393, 2400959708, 3395469782], _f: function (e, t, n, i) { if (e <= 19) return t & n | ~t & i; if (e <= 39) return t ^ n ^ i; if (e <= 59) return t & n | t & i | n & i; if (e <= 79) return t ^ n ^ i }, _S: function (e, t) { return t << e | t >>> 32 - e }, _block: function (e) { let t = this, n = t._h, i = Array(80); for (let u = 0; u < 16; u++)i[u] = e[u]; let o = n[0], r = n[1], s = n[2], a = n[3], c = n[4]; for (let u = 0; u <= 79; u++) { u >= 16 && (i[u] = t._S(1, i[u - 3] ^ i[u - 8] ^ i[u - 14] ^ i[u - 16])); let f = t._S(5, o) + t._f(u, r, s, a) + c + i[u] + t._key[Math.floor(u / 20)] | 0; c = a, a = s, s = t._S(30, r), r = o, o = f } n[0] = n[0] + o | 0, n[1] = n[1] + r | 0, n[2] = n[2] + s | 0, n[3] = n[3] + a | 0, n[4] = n[4] + c | 0 } }; var g9 = {}; g9.aes = class { constructor(e) { let t = this; t._tables = [[[], [], [], [], []], [[], [], [], [], []]], t._tables[0][0][0] || t._precompute(); let n = t._tables[0][4], i = t._tables[1], o = e.length, r, s, a, c = 1; if (o !== 4 && o !== 6 && o !== 8) throw new Error("invalid aes key size"); for (t._key = [s = e.slice(0), a = []], r = o; r < 4 * o + 28; r++) { let u = s[r - 1]; (r % o === 0 || o === 8 && r % o === 4) && (u = n[u >>> 24] << 24 ^ n[u >> 16 & 255] << 16 ^ n[u >> 8 & 255] << 8 ^ n[u & 255], r % o === 0 && (u = u << 8 ^ u >>> 24 ^ c << 24, c = c << 1 ^ (c >> 7) * 283)), s[r] = s[r - o] ^ u } for (let u = 0; r; u++, r--) { let f = s[u & 3 ? r : r - 4]; r <= 4 || u < 4 ? a[u] = f : a[u] = i[0][n[f >>> 24]] ^ i[1][n[f >> 16 & 255]] ^ i[2][n[f >> 8 & 255]] ^ i[3][n[f & 255]] } } encrypt(e) { return this._crypt(e, 0) } decrypt(e) { return this._crypt(e, 1) } _precompute() { let e = this._tables[0], t = this._tables[1], n = e[4], i = t[4], o = [], r = [], s, a, c, u; for (let f = 0; f < 256; f++)r[(o[f] = f << 1 ^ (f >> 7) * 283) ^ f] = f; for (let f = s = 0; !n[f]; f ^= a || 1, s = r[s] || 1) { let d = s ^ s << 1 ^ s << 2 ^ s << 3 ^ s << 4; d = d >> 8 ^ d & 255 ^ 99, n[f] = d, i[d] = f, u = o[c = o[a = o[f]]]; let p = u * 16843009 ^ c * 65537 ^ a * 257 ^ f * 16843008, g = o[d] * 257 ^ d * 16843008; for (let m = 0; m < 4; m++)e[m][f] = g = g << 24 ^ g >>> 8, t[m][d] = p = p << 24 ^ p >>> 8 } for (let f = 0; f < 5; f++)e[f] = e[f].slice(0), t[f] = t[f].slice(0) } _crypt(e, t) { if (e.length !== 4) throw new Error("invalid aes block size"); let n = this._key[t], i = n.length / 4 - 2, o = [0, 0, 0, 0], r = this._tables[t], s = r[0], a = r[1], c = r[2], u = r[3], f = r[4], d = e[0] ^ n[0], p = e[t ? 3 : 1] ^ n[1], g = e[2] ^ n[2], m = e[t ? 1 : 3] ^ n[3], A = 4, C, x, T; for (let b = 0; b < i; b++)C = s[d >>> 24] ^ a[p >> 16 & 255] ^ c[g >> 8 & 255] ^ u[m & 255] ^ n[A], x = s[p >>> 24] ^ a[g >> 16 & 255] ^ c[m >> 8 & 255] ^ u[d & 255] ^ n[A + 1], T = s[g >>> 24] ^ a[m >> 16 & 255] ^ c[d >> 8 & 255] ^ u[p & 255] ^ n[A + 2], m = s[m >>> 24] ^ a[d >> 16 & 255] ^ c[p >> 8 & 255] ^ u[g & 255] ^ n[A + 3], A += 4, d = C, p = x, g = T; for (let b = 0; b < 4; b++)o[t ? 3 & -b : b] = f[d >>> 24] << 24 ^ f[p >> 16 & 255] << 16 ^ f[g >> 8 & 255] << 8 ^ f[m & 255] ^ n[A++], C = d, d = p, p = g, g = m, m = C; return o } }; var Mce = { getRandomValues(e) { let t = new Uint32Array(e.buffer), n = i => { let o = 987654321, r = 4294967295; return function () { return o = 36969 * (o & 65535) + (o >> 16) & r, i = 18e3 * (i & 65535) + (i >> 16) & r, (((o << 16) + i & r) / 4294967296 + .5) * (Math.random() > .5 ? 1 : -1) } }; for (let i = 0, o; i < e.length; i += 4) { let r = n((o || Math.random()) * 4294967296); o = r() * 987654071, t[i / 4] = r() * 4294967296 | 0 } return e } }, y9 = {}; y9.ctrGladman = class { constructor(e, t) { this._prf = e, this._initIv = t, this._iv = t } reset() { this._iv = this._initIv } update(e) { return this.calculate(this._prf, e, this._iv) } incWord(e) { if ((e >> 24 & 255) === 255) { let t = e >> 16 & 255, n = e >> 8 & 255, i = e & 255; t === 255 ? (t = 0, n === 255 ? (n = 0, i === 255 ? i = 0 : ++i) : ++n) : ++t, e = 0, e += t << 16, e += n << 8, e += i } else e += 1 << 24; return e } incCounter(e) { (e[0] = this.incWord(e[0])) === 0 && (e[1] = this.incWord(e[1])) } calculate(e, t, n) { let i; if (!(i = t.length)) return []; let o = hc.bitLength(t); for (let r = 0; r < i; r += 4) { this.incCounter(n); let s = e.encrypt(n); t[r] ^= s[0], t[r + 1] ^= s[1], t[r + 2] ^= s[2], t[r + 3] ^= s[3] } return hc.clamp(t, o) } }; var VT = { importKey(e) { return new VT.hmacSha1(lD.bytes.toBits(e)) }, pbkdf2(e, t, n, i) { if (n = n || 1e4, i < 0 || n < 0) throw new Error("invalid params to pbkdf2"); let o = (i >> 5) + 1 << 2, r, s, a, c, u, f = new ArrayBuffer(o), d = new DataView(f), p = 0, g = hc; for (t = lD.bytes.toBits(t), u = 1; p < (o || 1); u++) { for (r = s = e.encrypt(g.concat(t, [u])), a = 1; a < n; a++)for (s = e.encrypt(s), c = 0; c < s.length; c++)r[c] ^= s[c]; for (a = 0; p < (o || 1) && a < r.length; a++)d.setInt32(p, r[a]), p += 4 } return f.slice(0, i / 8) } }; VT.hmacSha1 = class { constructor(e) { let t = this, n = t._hash = _9.sha1, i = [[], []], o = n.prototype.blockSize / 32; t._baseHash = [new n, new n], e.length > o && (e = n.hash(e)); for (let r = 0; r < o; r++)i[0][r] = e[r] ^ 909522486, i[1][r] = e[r] ^ 1549556828; t._baseHash[0].update(i[0]), t._baseHash[1].update(i[1]), t._resultHash = new n(t._baseHash[0]) } reset() { let e = this; e._resultHash = new e._hash(e._baseHash[0]), e._updated = !1 } update(e) { let t = this; t._updated = !0, t._resultHash.update(e) } digest() { let e = this, t = e._resultHash.finalize(), n = new e._hash(e._baseHash[1]).update(t).finalize(); return e.reset(), n } encrypt(e) { if (this._updated) throw new Error("encrypt on already updated hmac called!"); return this.update(e), this.digest(e) } }; var UT = "Invalid pasword", kT = 16, iqe = "raw", Lce = { name: "PBKDF2" }, oqe = { name: "HMAC" }, rqe = "SHA-1", sqe = Object.assign({ hash: oqe }, Lce), Fce = Object.assign({ iterations: 1e3, hash: { name: rqe } }, Lce), aqe = ["deriveBits"], fD = [8, 12, 16], uD = [16, 24, 32], hg = 10, Nce = [0, 0, 0, 0], r2 = typeof crypto < "u", Vce = r2 && typeof crypto.subtle < "u", yh = lD.bytes, kce = g9.aes, Uce = y9.ctrGladman, zce = VT.hmacSha1, i2 = class { constructor(t, n, i) { Object.assign(this, { password: t, signed: n, strength: i - 1, pendingInput: new Uint8Array(0) }) } async append(t) { let n = this; if (n.password) { let o = Bl(t, 0, fD[n.strength] + 2); await cqe(n, o, n.password), n.password = null, n.aesCtrGladman = new Uce(new kce(n.keys.key), Array.from(Nce)), n.hmac = new zce(n.keys.authentication), t = Bl(t, fD[n.strength] + 2) } let i = new Uint8Array(t.length - hg - (t.length - hg) % kT); return Hce(n, t, i, 0, hg, !0) } flush() { let t = this, n = t.pendingInput, i = Bl(n, 0, n.length - hg), o = Bl(n, n.length - hg), r = new Uint8Array(0); if (i.length) { let a = yh.toBits(i); t.hmac.update(a); let c = t.aesCtrGladman.update(a); r = yh.fromBits(c) } let s = !0; if (t.signed) { let a = Bl(yh.fromBits(t.hmac.digest()), 0, hg); for (let c = 0; c < hg; c++)a[c] != o[c] && (s = !1) } return { valid: s, data: r } } }, o2 = class { constructor(t, n) { Object.assign(this, { password: t, strength: n - 1, pendingInput: new Uint8Array(0) }) } async append(t) { let n = this, i = new Uint8Array(0); n.password && (i = await lqe(n, n.password), n.password = null, n.aesCtrGladman = new Uce(new kce(n.keys.key), Array.from(Nce)), n.hmac = new zce(n.keys.authentication)); let o = new Uint8Array(i.length + t.length - t.length % kT); return o.set(i, 0), Hce(n, t, o, i.length, 0) } flush() { let t = this, n = new Uint8Array(0); if (t.pendingInput.length) { let o = t.aesCtrGladman.update(yh.toBits(t.pendingInput)); t.hmac.update(o), n = yh.fromBits(o) } let i = Bl(yh.fromBits(t.hmac.digest()), 0, hg); return { data: A9(n, i), signature: i } } }; function Hce(e, t, n, i, o, r) { let s = t.length - o; e.pendingInput.length && (t = A9(e.pendingInput, t), n = hqe(n, s - s % kT)); let a; for (a = 0; a <= s - kT; a += kT) { let c = yh.toBits(Bl(t, a, a + kT)); r && e.hmac.update(c); let u = e.aesCtrGladman.update(c); r || e.hmac.update(u), n.set(yh.fromBits(u), a + i) } return e.pendingInput = Bl(t, a), n } async function cqe(e, t, n) { await Gce(e, n, Bl(t, 0, fD[e.strength])); let i = Bl(t, fD[e.strength]), o = e.keys.passwordVerification; if (o[0] != i[0] || o[1] != i[1]) throw new Error(UT) } async function lqe(e, t) { let n = uqe(new Uint8Array(fD[e.strength])); return await Gce(e, t, n), A9(n, e.keys.passwordVerification) } async function Gce(e, t, n) { let i = cD(t), o = await fqe(iqe, i, sqe, !1, aqe), r = await dqe(Object.assign({ salt: n }, Fce), o, 8 * (uD[e.strength] * 2 + 2)), s = new Uint8Array(r); e.keys = { key: yh.toBits(Bl(s, 0, uD[e.strength])), authentication: yh.toBits(Bl(s, uD[e.strength], uD[e.strength] * 2)), passwordVerification: Bl(s, uD[e.strength] * 2) } } function uqe(e) { return r2 && typeof crypto.getRandomValues == "function" ? crypto.getRandomValues(e) : Mce.getRandomValues(e) } function fqe(e, t, n, i, o) { return r2 && Vce && typeof crypto.subtle.importKey == "function" ? crypto.subtle.importKey(e, t, n, i, o) : VT.importKey(t) } async function dqe(e, t, n) { return r2 && Vce && typeof crypto.subtle.deriveBits == "function" ? await crypto.subtle.deriveBits(e, t, n) : VT.pbkdf2(t, e.salt, Fce.iterations, n) } function A9(e, t) { let n = e; return e.length + t.length && (n = new Uint8Array(e.length + t.length), n.set(e, 0), n.set(t, e.length)), n } function hqe(e, t) { if (t && t > e.length) { let n = e; e = new Uint8Array(t), e.set(n, 0) } return e } function Bl(e, t, n) { return e.subarray(t, n) } var zT = 12, s2 = class { constructor(t, n) { let i = this; Object.assign(i, { password: t, passwordVerification: n }), Yce(i, t) } append(t) { let n = this; if (n.password) { let i = Wce(n, t.subarray(0, zT)); if (n.password = null, i[zT - 1] != n.passwordVerification) throw new Error(UT); t = t.subarray(zT) } return Wce(n, t) } flush() { return { valid: !0, data: new Uint8Array(0) } } }, a2 = class { constructor(t, n) { let i = this; Object.assign(i, { password: t, passwordVerification: n }), Yce(i, t) } append(t) { let n = this, i, o; if (n.password) { n.password = null; let r = crypto.getRandomValues(new Uint8Array(zT)); r[zT - 1] = n.passwordVerification, i = new Uint8Array(t.length + r.length), i.set(jce(n, r), 0), o = zT } else i = new Uint8Array(t.length), o = 0; return i.set(jce(n, t), o), i } flush() { return { data: new Uint8Array(0) } } }; function Wce(e, t) { let n = new Uint8Array(t.length); for (let i = 0; i < t.length; i++)n[i] = Xce(e) ^ t[i], C9(e, n[i]); return n } function jce(e, t) { let n = new Uint8Array(t.length); for (let i = 0; i < t.length; i++)n[i] = Xce(e) ^ t[i], C9(e, t[i]); return n } function Yce(e, t) { e.keys = [305419896, 591751049, 878082192], e.crcKey0 = new dg(e.keys[0]), e.crcKey2 = new dg(e.keys[2]); for (let n = 0; n < t.length; n++)C9(e, t.charCodeAt(n)) } function C9(e, t) { e.crcKey0.append([t]), e.keys[0] = ~e.crcKey0.get(), e.keys[1] = qce(e.keys[1] + Kce(e.keys[0])), e.keys[1] = qce(Math.imul(e.keys[1], 134775813) + 1), e.crcKey2.append([e.keys[1] >>> 24]), e.keys[2] = ~e.crcKey2.get() } function Xce(e) { let t = e.keys[2] | 2; return Kce(Math.imul(t, t ^ 1) >>> 8) } function Kce(e) { return e & 255 } function qce(e) { return e & 4294967295 } var l2 = "deflate", u2 = "inflate", c2 = "Invalid signature", x9 = class { constructor(t, { signature: n, password: i, signed: o, compressed: r, zipCrypto: s, passwordVerification: a, encryptionStrength: c }, { chunkSize: u }) { let f = Boolean(i); Object.assign(this, { signature: n, encrypted: f, signed: o, compressed: r, inflate: r && new t({ chunkSize: u }), crc32: o && new dg, zipCrypto: s, decrypt: f && s ? new s2(i, a) : new i2(i, o, c) }) } async append(t) { let n = this; return n.encrypted && t.length && (t = await n.decrypt.append(t)), n.compressed && t.length && (t = await n.inflate.append(t)), (!n.encrypted || n.zipCrypto) && n.signed && t.length && n.crc32.append(t), t } async flush() { let t = this, n, i = new Uint8Array(0); if (t.encrypted) { let o = t.decrypt.flush(); if (!o.valid) throw new Error(c2); i = o.data } if ((!t.encrypted || t.zipCrypto) && t.signed) { let o = new DataView(new Uint8Array(4).buffer); if (n = t.crc32.get(), o.setUint32(0, n), t.signature != o.getUint32(0, !1)) throw new Error(c2) } return t.compressed && (i = await t.inflate.append(i) || new Uint8Array(0), await t.inflate.flush()), { data: i, signature: n } } }, T9 = class { constructor(t, { encrypted: n, signed: i, compressed: o, level: r, zipCrypto: s, password: a, passwordVerification: c, encryptionStrength: u }, { chunkSize: f }) { Object.assign(this, { encrypted: n, signed: i, compressed: o, deflate: o && new t({ level: r || 5, chunkSize: f }), crc32: i && new dg, zipCrypto: s, encrypt: n && s ? new a2(a, c) : new o2(a, u) }) } async append(t) { let n = this, i = t; return n.compressed && t.length && (i = await n.deflate.append(t)), n.encrypted && i.length && (i = await n.encrypt.append(i)), (!n.encrypted || n.zipCrypto) && n.signed && t.length && n.crc32.append(t), i } async flush() { let t = this, n, i = new Uint8Array(0); if (t.compressed && (i = await t.deflate.flush() || new Uint8Array(0)), t.encrypted) { i = await t.encrypt.append(i); let o = t.encrypt.flush(); n = o.signature; let r = new Uint8Array(i.length + o.data.length); r.set(i, 0), r.set(o.data, i.length), i = r } return (!t.encrypted || t.zipCrypto) && t.signed && (n = t.crc32.get()), { data: i, signature: n } } }; function Jce(e, t, n) { if (t.codecType.startsWith(l2)) return new T9(e, t, n); if (t.codecType.startsWith(u2)) return new x9(e, t, n) } var Zce = "init", Qce = "append", E9 = "flush", mqe = "message", $ce = !0, f2 = (e, t, n, i, o, r, s) => (Object.assign(e, { busy: !0, codecConstructor: t, options: Object.assign({}, n), scripts: s, terminate() { e.worker && !e.busy && (e.worker.terminate(), e.interface = null) }, onTaskFinished() { e.busy = !1, o(e) } }), r ? _qe(e, i) : pqe(e, i)); function pqe(e, t) { let n = Jce(e.codecConstructor, e.options, t); return { async append(i) { try { return await n.append(i) } catch (o) { throw e.onTaskFinished(), o } }, async flush() { try { return await n.flush() } finally { e.onTaskFinished() } }, abort() { e.onTaskFinished() } } } function _qe(e, t) { let n, i = { type: "module" }; if (!e.interface) { if (!$ce) e.worker = o(i, t.baseURL); else try { e.worker = o({}, t.baseURL) } catch { $ce = !1, e.worker = o(i, t.baseURL) } e.worker.addEventListener(mqe, a, !1), e.interface = { append(c) { return r({ type: Qce, data: c }) }, flush() { return r({ type: E9 }) }, abort() { e.onTaskFinished() } } } return e.interface; function o(c, u) { let f, d; f = e.scripts[0], typeof f == "function" && (f = f()); try { d = new URL(f, u) } catch { d = f } return new Worker(d, c) } async function r(c) { if (!n) { let u = e.options, f = e.scripts.slice(1); await s({ scripts: f, type: Zce, options: u, config: { chunkSize: t.chunkSize } }) } return s(c) } function s(c) { let u = e.worker, f = new Promise((d, p) => n = { resolve: d, reject: p }); try { if (c.data) try { c.data = c.data.buffer, u.postMessage(c, [c.data]) } catch { u.postMessage(c) } else u.postMessage(c) } catch (d) { n.reject(d), n = null, e.onTaskFinished() } return f } function a(c) { let u = c.data; if (n) { let f = u.error, d = u.type; if (f) { let p = new Error(f.message); p.stack = f.stack, n.reject(p), n = null, e.onTaskFinished() } else if (d == Zce || d == E9 || d == Qce) { let p = u.data; d == E9 ? (n.resolve({ data: new Uint8Array(p), signature: u.signature }), n = null, e.onTaskFinished()) : n.resolve(p && new Uint8Array(p)) } } } } var My = [], b9 = []; function d2(e, t, n) { let o = !(!t.compressed && !t.signed && !t.encrypted) && (t.useWebWorkers || t.useWebWorkers === void 0 && n.useWebWorkers), r = o && n.workerScripts ? n.workerScripts[t.codecType] : []; if (My.length < n.maxWorkers) { let a = {}; return My.push(a), f2(a, e, t, n, s, o, r) } else { let a = My.find(c => !c.busy); return a ? (ele(a), f2(a, e, t, n, s, o, r)) : new Promise(c => b9.push({ resolve: c, codecConstructor: e, options: t, webWorker: o, scripts: r })) } function s(a) { if (b9.length) { let [{ resolve: c, codecConstructor: u, options: f, webWorker: d, scripts: p }] = b9.splice(0, 1); c(f2(a, u, f, n, s, d, p)) } else a.worker ? (ele(a), Number.isFinite(n.terminateWorkerTimeout) && n.terminateWorkerTimeout >= 0 && (a.terminateTimeout = setTimeout(() => { My = My.filter(c => c != a), a.terminate() }, n.terminateWorkerTimeout))) : My = My.filter(c => c != a) } } function ele(e) { e.terminateTimeout && (clearTimeout(e.terminateTimeout), e.terminateTimeout = null) } var nle = "Abort error"; async function h2(e, t, n, i, o, r, s) { let a = Math.max(r.chunkSize, 64); return c(); async function c(u = 0, f = 0) { let d = s.signal, p = o(); if (u < p) { S9(d, e); let g = await t.readUint8Array(u + i, Math.min(a, p - u)), m = g.length; S9(d, e); let A = await e.append(g); if (S9(d, e), f += await tle(n, A), s.onprogress) try { s.onprogress(u + m, p) } catch { } return c(u + a, f) } else { let g = await e.flush(); return f += await tle(n, g.data), { signature: g.signature, length: f } } } } function S9(e, t) { if (e && e.aborted) throw t.abort(), new Error(nle) } async function tle(e, t) { return t.length && await e.writeUint8Array(t), t.length } var w9 = "text/plain"; var m2 = class { constructor() { this.size = 0 } init() { this.initialized = !0 } }, p2 = class extends m2 { }, dD = class extends m2 { writeUint8Array(t) { this.size += t.length } }, _2 = class extends p2 { constructor(t) { super(), this.blobReader = new Ly(new Blob([t], { type: w9 })) } init() { super.init(), this.blobReader.init(), this.size = this.blobReader.size } readUint8Array(t, n) { return this.blobReader.readUint8Array(t, n) } }, g2 = class extends dD { constructor(t) { super(), this.encoding = t, this.blob = new Blob([], { type: w9 }) } writeUint8Array(t) { super.writeUint8Array(t), this.blob = new Blob([this.blob, t.buffer], { type: w9 }) } getData() { if (this.blob.text) return this.blob.text(); { let t = new FileReader; return new Promise((n, i) => { t.onload = o => n(o.target.result), t.onerror = () => i(t.error), t.readAsText(this.blob, this.encoding) }) } } }; var y2 = class extends dD { constructor(t) { super(), this.data = "data:" + (t || "") + ";base64,", this.pending = [] } writeUint8Array(t) { super.writeUint8Array(t); let n = 0, i = this.pending, o = this.pending.length; for (this.pending = "", n = 0; n < Math.floor((o + t.length) / 3) * 3 - o; n++)i += String.fromCharCode(t[n]); for (; n < t.length; n++)this.pending += String.fromCharCode(t[n]); i.length > 2 ? this.data += btoa(i) : this.pending = i } getData() { return this.data + btoa(this.pending) } }, Ly = class extends p2 { constructor(t) { super(), this.blob = t, this.size = t.size } async readUint8Array(t, n) { if (this.blob.arrayBuffer) return new Uint8Array(await this.blob.slice(t, t + n).arrayBuffer()); { let i = new FileReader; return new Promise((o, r) => { i.onload = s => o(new Uint8Array(s.target.result)), i.onerror = () => r(i.error), i.readAsArrayBuffer(this.blob.slice(t, t + n)) }) } } }, HT = class extends dD { constructor(t) { super(), this.contentType = t, this.arrayBuffersMaxlength = 8, ile(this) } writeUint8Array(t) { super.writeUint8Array(t), this.arrayBuffers.length == this.arrayBuffersMaxlength && ole(this), this.arrayBuffers.push(t.buffer) } getData() { return this.blob || (this.arrayBuffers.length && ole(this), this.blob = this.pendingBlob, ile(this)), this.blob } }; function ile(e) { e.pendingBlob = new Blob([], { type: e.contentType }), e.arrayBuffers = [] } function ole(e) { e.pendingBlob = new Blob([e.pendingBlob, ...e.arrayBuffers], { type: e.contentType }), e.arrayBuffers = [] } var GT = "/", D9 = new Date(2107, 11, 31), v9 = new Date(1980, 0, 1); var gqe = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0 ".split(""), rle = e => { let t = ""; for (let n = 0; n < e.length; n++)t += gqe[e[n]]; return t }; var A2 = yqe; function yqe(e, t) { if (t && t.trim().toLowerCase() == "cp437") return rle(e); if (typeof TextDecoder > "u") { let n = new FileReader; return new Promise((i, o) => { n.onload = r => i(r.target.result), n.onerror = () => o(n.error), n.readAsText(new Blob([e])) }) } else return new TextDecoder(t).decode(e) } var Aqe = ["filename", "rawFilename", "directory", "encrypted", "compressedSize", "uncompressedSize", "lastModDate", "rawLastModDate", "comment", "rawComment", "signature", "extraField", "rawExtraField", "bitFlag", "extraFieldZip64", "extraFieldUnicodePath", "extraFieldUnicodeComment", "extraFieldAES", "filenameUTF8", "commentUTF8", "offset", "zip64", "compressionMethod", "extraFieldNTFS", "lastAccessDate", "creationDate", "extraFieldExtendedTimestamp", "version", "versionMadeBy", "msDosCompatible", "internalFileAttribute", "externalFileAttribute"], op = class { constructor(t) { Aqe.forEach(n => this[n] = t[n]) } }; var O9 = "File format is not recognized", Eqe = "End of central directory not found", bqe = "End of Zip64 central directory not found", Sqe = "End of Zip64 central directory locator not found", wqe = "Central directory header not found", Dqe = "Local file header not found", vqe = "Zip64 extra field not found", Pqe = "File contains encrypted entry", Iqe = "Encryption method not supported", sle = "Compression method not supported", ale = "utf-8", cle = "cp437", lle = ["uncompressedSize", "compressedSize", "offset"], v2 = class { constructor(t, n = {}) { Object.assign(this, { reader: t, options: n, config: n2() }) } async*getEntriesGenerator(t = {}) { let n = this, i = n.reader; if (i.initialized || await i.init(), i.size < 22) throw new Error(O9); let o = await Lqe(i, 101010256, i.size, 22, 65535 * 16); if (!o) throw new Error(Eqe); let r = Ba(o), s = Rs(r, 12), a = Rs(r, 16), c = Rl(r, 8), u = 0; if (a == 4294967295 || s == 4294967295 || c == 65535) { let g = await mg(i, o.offset - 20, 20), m = Ba(g); if (Rs(m, 0) != 117853008) throw new Error(bqe); a = C2(m, 8); let A = await mg(i, a, 56), C = Ba(A), x = o.offset - 20 - 56; if (Rs(C, 0) != 101075792 && a != x) { let T = a; a = x, u = a - T, A = await mg(i, a, 56), C = Ba(A) } if (Rs(C, 0) != 101075792) throw new Error(Sqe); c = C2(C, 32), s = C2(C, 40), a -= s } if (a < 0 || a >= i.size) throw new Error(O9); let f = 0, d = await mg(i, a, s), p = Ba(d); if (s) { let g = o.offset - s; if (Rs(p, f) != 33639248 && a != g) { let m = a; a = g, u = a - m, d = await mg(i, a, s), p = Ba(d) } } if (a < 0 || a >= i.size) throw new Error(O9); for (let g = 0; g < c; g++) { let m = new R9(i, n.config, n.options); if (Rs(p, f) != 33639248) throw new Error(wqe); fle(m, p, f + 6); let A = Boolean(m.bitFlag.languageEncodingFlag), C = f + 46, x = C + m.filenameLength, T = x + m.extraFieldLength, b = Rl(p, f + 4), S = (b & 0) == 0; Object.assign(m, { versionMadeBy: b, msDosCompatible: S, compressedSize: 0, uncompressedSize: 0, commentLength: Rl(p, f + 32), directory: S && (jT(p, f + 38) & 16) == 16, offset: Rs(p, f + 42) + u, internalFileAttribute: Rs(p, f + 34), externalFileAttribute: Rs(p, f + 38), rawFilename: d.subarray(C, x), filenameUTF8: A, commentUTF8: A, rawExtraField: d.subarray(x, T) }); let D = T + m.commentLength; m.rawComment = d.subarray(T, D); let P = WT(n, t, "filenameEncoding"), B = WT(n, t, "commentEncoding"), [R, M] = await Promise.all([A2(m.rawFilename, m.filenameUTF8 ? ale : P || cle), A2(m.rawComment, m.commentUTF8 ? ale : B || cle)]); m.filename = R, m.comment = M, !m.directory && m.filename.endsWith(GT) && (m.directory = !0), await dle(m, m, p, f + 6); let L = new op(m); if (L.getData = (_, E) => m.getData(_, L, E), f = D, t.onprogress) try { t.onprogress(g + 1, c, new op(m)) } catch { } yield L } return !0 } async getEntries(t = {}) { let n = [], i = this.getEntriesGenerator(t), o = i.next(); for (; !(await o).done;)n.push((await o).value), o = i.next(); return n } async close() { } }; var R9 = class { constructor(t, n, i) { Object.assign(this, { reader: t, config: n, options: i }) } async getData(t, n, i = {}) { let o = this, { reader: r, offset: s, extraFieldAES: a, compressionMethod: c, config: u, bitFlag: f, signature: d, rawLastModDate: p, compressedSize: g } = o, m = o.localDirectory = {}; r.initialized || await r.init(); let A = await mg(r, s, 30), C = Ba(A), x = WT(o, i, "password"); if (x = x && x.length && x, a && a.originalCompressionMethod != 99) throw new Error(sle); if (c != 0 && c != 8) throw new Error(sle); if (Rs(C, 0) != 67324752) throw new Error(Dqe); fle(m, C, 4), A = await mg(r, s, 30 + m.filenameLength + m.extraFieldLength), m.rawExtraField = A.subarray(30 + m.filenameLength), await dle(o, m, C, 4), n.lastAccessDate = m.lastAccessDate, n.creationDate = m.creationDate; let T = o.encrypted && m.encrypted, b = T && !a; if (T) { if (!b && a.strength === void 0) throw new Error(Iqe); if (!x) throw new Error(Pqe) } let S = await d2(u.Inflate, { codecType: u2, password: x, zipCrypto: b, encryptionStrength: a && a.strength, signed: WT(o, i, "checkSignature"), passwordVerification: b && (f.dataDescriptor ? p >>> 8 & 255 : d >>> 24 & 255), signature: d, compressed: c != 0, encrypted: T, useWebWorkers: WT(o, i, "useWebWorkers") }, u); t.initialized || await t.init(); let D = WT(o, i, "signal"), P = s + 30 + m.filenameLength + m.extraFieldLength; return await h2(S, r, t, P, () => g, u, { onprogress: i.onprogress, signal: D }), t.getData() } }; function fle(e, t, n) { let i = e.rawBitFlag = Rl(t, n + 2), o = (i & 1) == 1, r = Rs(t, n + 6); Object.assign(e, { encrypted: o, version: Rl(t, n), bitFlag: { level: (i & 6) >> 1, dataDescriptor: (i & 8) == 8, languageEncodingFlag: (i & 2048) == 2048 }, rawLastModDate: r, lastModDate: Fqe(r), filenameLength: Rl(t, n + 22), extraFieldLength: Rl(t, n + 24) }) } async function dle(e, t, n, i) { let o = t.rawExtraField, r = t.extraField = new Map, s = Ba(new Uint8Array(o)), a = 0; try { for (; a < o.length;) { let A = Rl(s, a), C = Rl(s, a + 2); r.set(A, { type: A, data: o.slice(a + 4, a + 4 + C) }), a += 4 + C } } catch { } let c = Rl(n, i + 4); t.signature = Rs(n, i + 10), t.uncompressedSize = Rs(n, i + 18), t.compressedSize = Rs(n, i + 14); let u = r.get(1); u && (Oqe(u, t), t.extraFieldZip64 = u); let f = r.get(28789); f && (await ule(f, "filename", "rawFilename", t, e), t.extraFieldUnicodePath = f); let d = r.get(25461); d && (await ule(d, "comment", "rawComment", t, e), t.extraFieldUnicodeComment = d); let p = r.get(39169); p ? (Bqe(p, t, c), t.extraFieldAES = p) : t.compressionMethod = c; let g = r.get(10); g && (Rqe(g, t), t.extraFieldNTFS = g); let m = r.get(21589); m && (Mqe(m, t), t.extraFieldExtendedTimestamp = m) } function Oqe(e, t) { t.zip64 = !0; let n = Ba(e.data); e.values = []; for (let o = 0; o < Math.floor(e.data.length / 8); o++)e.values.push(C2(n, 0 + o * 8)); let i = lle.filter(o => t[o] == 4294967295); for (let o = 0; o < i.length; o++)e[i[o]] = e.values[o]; lle.forEach(o => { if (t[o] == 4294967295) if (e[o] !== void 0) t[o] = e[o]; else throw new Error(vqe) }) } async function ule(e, t, n, i, o) { let r = Ba(e.data); e.version = jT(r, 0), e.signature = Rs(r, 1); let s = new dg; s.append(o[n]); let a = Ba(new Uint8Array(4)); a.setUint32(0, s.get(), !0), e[t] = await A2(e.data.subarray(5)), e.valid = !o.bitFlag.languageEncodingFlag && e.signature == Rs(a, 0), e.valid && (i[t] = e[t], i[t + "UTF8"] = !0) } function Bqe(e, t, n) { let i = Ba(e.data); e.vendorVersion = jT(i, 0), e.vendorId = jT(i, 2); let o = jT(i, 4); e.strength = o, e.originalCompressionMethod = n, t.compressionMethod = e.compressionMethod = Rl(i, 5) } function Rqe(e, t) { let n = Ba(e.data), i = 4, o; try { for (; i < e.data.length && !o;) { let r = Rl(n, i), s = Rl(n, i + 2); r == 1 && (o = e.data.slice(i + 4, i + 4 + s)), i += 4 + s } } catch { } try { if (o && o.length == 24) { let r = Ba(o), s = r.getBigUint64(0, !0), a = r.getBigUint64(8, !0), c = r.getBigUint64(16, !0); Object.assign(e, { rawLastModDate: s, rawLastAccessDate: a, rawCreationDate: c }); let u = B9(s), f = B9(a), d = B9(c), p = { lastModDate: u, lastAccessDate: f, creationDate: d }; Object.assign(e, p), Object.assign(t, p) } } catch { } } function Mqe(e, t) { let n = Ba(e.data), i = jT(n, 0), o = [], r = []; (i & 1) == 1 && (o.push("lastModDate"), r.push("rawLastModDate")), (i & 2) == 2 && (o.push("lastAccessDate"), r.push("rawLastAccessDate")), (i & 4) == 4 && (o.push("creationDate"), r.push("rawCreationDate")); let s = 1; o.forEach((a, c) => { if (e.data.length >= s + 4) { let u = Rs(n, s); t[a] = e[a] = new Date(u * 1e3); let f = r[c]; e[f] = u } s += 4 }) } async function Lqe(e, t, n, i, o) { let r = new Uint8Array(4), s = Ba(r); Nqe(s, 0, t); let a = i + o; return await c(i) || await c(Math.min(a, n)); async function c(u) { let f = n - u, d = await mg(e, f, u); for (let p = d.length - i; p >= 0; p--)if (d[p] == r[0] && d[p + 1] == r[1] && d[p + 2] == r[2] && d[p + 3] == r[3]) return { offset: f + p, buffer: d.slice(p, p + i).buffer } } } function WT(e, t, n) { return t[n] === void 0 ? e.options[n] : t[n] } function Fqe(e) { let t = (e & 4294901760) >> 16, n = e & 65535; try { return new Date(1980 + ((t & 65024) >> 9), ((t & 480) >> 5) - 1, t & 31, (n & 63488) >> 11, (n & 2016) >> 5, (n & 31) * 2, 0) } catch { } } function B9(e) { return new Date(Number(e / BigInt(1e4) - BigInt(116444736e5))) } function jT(e, t) { return e.getUint8(t) } function Rl(e, t) { return e.getUint16(t, !0) } function Rs(e, t) { return e.getUint32(t, !0) } function C2(e, t) { return Number(e.getBigUint64(t, !0)) } function Nqe(e, t, n) { e.setUint32(t, n, !0) } function Ba(e) { return new DataView(e.buffer) } function mg(e, t, n) { return e.readUint8Array(t, n) } var Hqe = "File already exists", Gqe = "Zip file comment exceeds 64KB", Wqe = "File entry comment exceeds 64KB", jqe = "File entry name exceeds 64KB", ple = "Version exceeds 65535", qqe = "The strength must equal 1, 2, or 3", Yqe = "Extra field type exceeds 65535", Xqe = "Extra field data exceeds 64KB", j9 = "Zip64 is not supported", _le = new Uint8Array([7, 0, 2, 0, 65, 69, 3, 0, 0]), gle = 24, G9 = 0, O2 = class { constructor(t, n = {}) { Object.assign(this, { writer: t, options: n, config: n2(), files: new Map, offset: t.size, pendingCompressedSize: 0, pendingEntries: [], pendingAddFileCalls: new Set }) } async add(t = "", n, i = {}) { let o = this; if (G9 < o.config.maxWorkers) { G9++; let r; try { return r = Kqe(o, t, n, i), this.pendingAddFileCalls.add(r), await r } finally { this.pendingAddFileCalls.delete(r), G9--; let s = o.pendingEntries.shift(); s && o.add(s.name, s.reader, s.options).then(s.resolve).catch(s.reject) } } else return new Promise((r, s) => o.pendingEntries.push({ name: t, reader: n, options: i, resolve: r, reject: s })) } async close(t = new Uint8Array(0), n = {}) { for (; this.pendingAddFileCalls.size;)await Promise.all(Array.from(this.pendingAddFileCalls)); return await Qqe(this, t, n), this.writer.getData() } }; async function Kqe(e, t, n, i) { if (t = t.trim(), i.directory && !t.endsWith(GT) ? t += GT : i.directory = t.endsWith(GT), e.files.has(t)) throw new Error(Hqe); let o = cD(t); if (o.length > 65535) throw new Error(jqe); let r = i.comment || "", s = cD(r); if (s.length > 65535) throw new Error(Wqe); let a = e.options.version || i.version || 0; if (a > 65535) throw new Error(ple); let c = e.options.versionMadeBy || i.versionMadeBy || 20; if (c > 65535) throw new Error(ple); let u = na(e, i, "lastModDate") || new Date, f = na(e, i, "lastAccessDate"), d = na(e, i, "creationDate"), p = na(e, i, "password"), g = na(e, i, "encryptionStrength") || 3, m = na(e, i, "zipCrypto"); if (p !== void 0 && g !== void 0 && (g < 1 || g > 3)) throw new Error(qqe); let A = new Uint8Array(0), C = i.extraField; if (C) { let V = 0, z = 0; C.forEach(k => V += 4 + k.length), A = new Uint8Array(V), C.forEach((k, G) => { if (G > 65535) throw new Error(Yqe); if (k.length > 65535) throw new Error(Xqe); Ls(A, new Uint16Array([G]), z), Ls(A, new Uint16Array([k.length]), z + 2), Ls(A, k, z + 4), z += 4 + k.length }) } let x = na(e, i, "extendedTimestamp"); x === void 0 && (x = !0); let T = 0, b = na(e, i, "keepOrder"); b === void 0 && (b = !0); let S = 0, D = na(e, i, "msDosCompatible"); D === void 0 && (D = !0); let P = na(e, i, "internalFileAttribute") || 0, B = na(e, i, "externalFileAttribute") || 0; n && (n.initialized || await n.init(), S = n.size, T = eYe(S)); let R = i.zip64 || e.options.zip64 || !1; if (e.offset + e.pendingCompressedSize >= 4294967295 || S >= 4294967295 || T >= 4294967295) { if (i.zip64 === !1 || e.options.zip64 === !1 || !b) throw new Error(j9); R = !0 } e.pendingCompressedSize += T, await Promise.resolve(); let M = na(e, i, "level"), L = na(e, i, "useWebWorkers"), _ = na(e, i, "bufferedWrite"), E = na(e, i, "dataDescriptor"), w = na(e, i, "dataDescriptorSignature"), v = na(e, i, "signal"); E === void 0 && (E = !0), E && w === void 0 && (w = !1); let O = await Jqe(e, t, n, Object.assign({}, i, { rawFilename: o, rawComment: s, version: a, versionMadeBy: c, lastModDate: u, lastAccessDate: f, creationDate: d, rawExtraField: A, zip64: R, password: p, level: M, useWebWorkers: L, encryptionStrength: g, extendedTimestamp: x, zipCrypto: m, bufferedWrite: _, keepOrder: b, dataDescriptor: E, dataDescriptorSignature: w, signal: v, msDosCompatible: D, internalFileAttribute: P, externalFileAttribute: B })); return T && (e.pendingCompressedSize -= T), Object.assign(O, { name: t, comment: r, extraField: C }), new op(O) } async function Jqe(e, t, n, i) { let o = e.files, r = e.writer, s = Array.from(o.values()).pop(), a = {}, c, u, f; o.set(t, a); try { let d, p, g; if (i.keepOrder && (d = s && s.lock), a.lock = g = new Promise(m => f = m), i.bufferedWrite || e.lockWrite || !i.dataDescriptor ? (p = new HT, p.init(), c = !0) : (e.lockWrite = new Promise(m => u = m), r.initialized || await r.init(), p = r), a = await Zqe(n, p, e.config, i), a.lock = g, o.set(t, a), a.filename = t, c) { let m = 0, A = p.getData(); await Promise.all([e.lockWrite, d]); let C; do C = Array.from(o.values()).find(x => x.writingBufferedData), C && await C.lock; while (C && C.lock); if (a.writingBufferedData = !0, !i.dataDescriptor) { let T = await yle(A, 0, 26), b = new DataView(T); (!a.encrypted || i.zipCrypto) && no(b, 14, a.signature), a.zip64 ? (no(b, 18, 4294967295), no(b, 22, 4294967295)) : (no(b, 18, a.compressedSize), no(b, 22, a.uncompressedSize)), await r.writeUint8Array(new Uint8Array(T)), m = 26 } await $qe(r, A, m), delete a.writingBufferedData } if (a.offset = e.offset, a.zip64) { let m = Zf(a.rawExtraFieldZip64); Kc(m, 20, BigInt(a.offset)) } else if (a.offset >= 4294967295) throw new Error(j9); return e.offset += a.length, a } catch (d) { throw (c && a.writingBufferedData || !c && a.dataWritten) && (d.corruptedEntry = e.hasCorruptedEntries = !0, a.uncompressedSize && (e.offset += a.uncompressedSize)), o.delete(t), d } finally { f(), u && u() } } async function Zqe(e, t, n, i) { let { rawFilename: o, lastAccessDate: r, creationDate: s, password: a, level: c, zip64: u, zipCrypto: f, dataDescriptor: d, dataDescriptorSignature: p, directory: g, version: m, versionMadeBy: A, rawComment: C, rawExtraField: x, useWebWorkers: T, onprogress: b, signal: S, encryptionStrength: D, extendedTimestamp: P, msDosCompatible: B, internalFileAttribute: R, externalFileAttribute: M } = i, L = Boolean(a && a.length), _ = c !== 0 && !g, E; if (L && !f) { E = new Uint8Array(_le.length + 2); let Fe = Zf(E); Vo(Fe, 0, 39169), Ls(E, _le, 2), B2(Fe, 8, D) } else E = new Uint8Array(0); let w, v; if (P) { v = new Uint8Array(9 + (r ? 4 : 0) + (s ? 4 : 0)); let Fe = Zf(v); Vo(Fe, 0, 21589), Vo(Fe, 2, v.length - 4); let We = 1 + (r ? 2 : 0) + (s ? 4 : 0); B2(Fe, 4, We), no(Fe, 5, Math.floor(i.lastModDate.getTime() / 1e3)), r && no(Fe, 9, Math.floor(r.getTime() / 1e3)), s && no(Fe, 13, Math.floor(s.getTime() / 1e3)); try { w = new Uint8Array(36); let Lt = Zf(w), Gt = W9(i.lastModDate); Vo(Lt, 0, 10), Vo(Lt, 2, 32), Vo(Lt, 8, 1), Vo(Lt, 10, 24), Kc(Lt, 12, Gt), Kc(Lt, 20, W9(r) || Gt), Kc(Lt, 28, W9(s) || Gt) } catch { w = new Uint8Array(0) } } else w = v = new Uint8Array(0); let O = { version: m || 20, versionMadeBy: A, zip64: u, directory: Boolean(g), filenameUTF8: !0, rawFilename: o, commentUTF8: !0, rawComment: C, rawExtraFieldZip64: u ? new Uint8Array(gle + 4) : new Uint8Array(0), rawExtraFieldExtendedTimestamp: v, rawExtraFieldNTFS: w, rawExtraFieldAES: E, rawExtraField: x, extendedTimestamp: P, msDosCompatible: B, internalFileAttribute: R, externalFileAttribute: M }, V = O.uncompressedSize = 0, z = 2048; d && (z = z | 8); let k = 0; _ && (k = 8), u && (O.version = O.version > 45 ? O.version : 45), L && (z = z | 1, f || (O.version = O.version > 51 ? O.version : 51, k = 99, _ && (O.rawExtraFieldAES[9] = 8))), O.compressionMethod = k; let G = O.headerArray = new Uint8Array(26), N = Zf(G); Vo(N, 0, O.version), Vo(N, 2, z), Vo(N, 4, k); let X = new Uint32Array(1), q = Zf(X), J; i.lastModDate < v9 ? J = v9 : i.lastModDate > D9 ? J = D9 : J = i.lastModDate, Vo(q, 0, (J.getHours() << 6 | J.getMinutes()) << 5 | J.getSeconds() / 2), Vo(q, 2, (J.getFullYear() - 1980 << 4 | J.getMonth() + 1) << 5 | J.getDate()); let W = X[0]; no(N, 6, W), Vo(N, 22, o.length); let K = E.length + v.length + w.length + O.rawExtraField.length; Vo(N, 24, K); let Z = new Uint8Array(30 + o.length + K), de = Zf(Z); no(de, 0, 67324752), Ls(Z, G, 4), Ls(Z, o, 30), Ls(Z, E, 30 + o.length), Ls(Z, v, 30 + o.length + E.length), Ls(Z, w, 30 + o.length + E.length + v.length), Ls(Z, O.rawExtraField, 30 + o.length + E.length + v.length + w.length); let pe, oe = 0; if (e) { let Fe = await d2(n.Deflate, { codecType: l2, level: c, password: a, encryptionStrength: D, zipCrypto: L && f, passwordVerification: L && f && W >> 8 & 255, signed: !0, compressed: _, encrypted: L, useWebWorkers: T }, n); await t.writeUint8Array(Z), O.dataWritten = !0, pe = await h2(Fe, e, t, 0, () => e.size, n, { onprogress: b, signal: S }), V = O.uncompressedSize = e.size, oe = pe.length } else await t.writeUint8Array(Z), O.dataWritten = !0; let ue = new Uint8Array(0), ge, Ee = 0; if (d && (ue = new Uint8Array(u ? p ? 24 : 20 : p ? 16 : 12), ge = Zf(ue), p && (Ee = 4, no(ge, 0, 134695760))), e) { let Fe = pe.signature; if ((!L || f) && Fe !== void 0 && (no(N, 10, Fe), O.signature = Fe, d && no(ge, Ee, Fe)), u) { let We = Zf(O.rawExtraFieldZip64); Vo(We, 0, 1), Vo(We, 2, gle), no(N, 14, 4294967295), Kc(We, 12, BigInt(oe)), no(N, 18, 4294967295), Kc(We, 4, BigInt(V)), d && (Kc(ge, Ee + 4, BigInt(oe)), Kc(ge, Ee + 12, BigInt(V))) } else no(N, 14, oe), no(N, 18, V), d && (no(ge, Ee + 4, oe), no(ge, Ee + 8, V)) } d && await t.writeUint8Array(ue); let Ie = Z.length + oe + ue.length; return Object.assign(O, { compressedSize: oe, lastModDate: J, rawLastModDate: W, creationDate: s, lastAccessDate: r, encrypted: L, length: Ie }), O } async function Qqe(e, t, n) { let i = e.writer, o = e.files, r = 0, s = 0, a = e.offset, c = o.size; for (let [, p] of o) s += 46 + p.rawFilename.length + p.rawComment.length + p.rawExtraFieldZip64.length + p.rawExtraFieldAES.length + p.rawExtraFieldExtendedTimestamp.length + p.rawExtraFieldNTFS.length + p.rawExtraField.length; let u = n.zip64 || e.options.zip64 || !1; if (a >= 4294967295 || s >= 4294967295 || c >= 65535) { if (n.zip64 === !1 || e.options.zip64 === !1) throw new Error(j9); u = !0 } let f = new Uint8Array(s + (u ? 98 : 22)), d = Zf(f); if (t && t.length) if (t.length <= 65535) Vo(d, r + 20, t.length); else throw new Error(Gqe); for (let [p, g] of Array.from(o.values()).entries()) { let { rawFilename: m, rawExtraFieldZip64: A, rawExtraFieldAES: C, rawExtraField: x, rawComment: T, versionMadeBy: b, headerArray: S, directory: D, zip64: P, msDosCompatible: B, internalFileAttribute: R, externalFileAttribute: M } = g, L, _; if (g.extendedTimestamp) { _ = g.rawExtraFieldNTFS, L = new Uint8Array(9); let w = Zf(L); Vo(w, 0, 21589), Vo(w, 2, L.length - 4), B2(w, 4, 1), no(w, 5, Math.floor(g.lastModDate.getTime() / 1e3)) } else _ = L = new Uint8Array(0); let E = A.length + C.length + L.length + _.length + x.length; if (no(d, r, 33639248), Vo(d, r + 4, b), Ls(f, S, r + 6), Vo(d, r + 30, E), Vo(d, r + 32, T.length), no(d, r + 34, R), M ? no(d, r + 38, M) : D && B && B2(d, r + 38, 16), P ? no(d, r + 42, 4294967295) : no(d, r + 42, g.offset), Ls(f, m, r + 46), Ls(f, A, r + 46 + m.length), Ls(f, C, r + 46 + m.length + A.length), Ls(f, L, r + 46 + m.length + A.length + C.length), Ls(f, _, r + 46 + m.length + A.length + C.length + L.length), Ls(f, x, r + 46 + m.length + A.length + C.length + L.length + _.length), Ls(f, T, r + 46 + m.length + E), r += 46 + m.length + E + T.length, n.onprogress) try { n.onprogress(p + 1, o.size, new op(g)) } catch { } } u && (no(d, r, 101075792), Kc(d, r + 4, BigInt(44)), Vo(d, r + 12, 45), Vo(d, r + 14, 45), Kc(d, r + 24, BigInt(c)), Kc(d, r + 32, BigInt(c)), Kc(d, r + 40, BigInt(s)), Kc(d, r + 48, BigInt(a)), no(d, r + 56, 117853008), Kc(d, r + 64, BigInt(a) + BigInt(s)), no(d, r + 72, 1), c = 65535, a = 4294967295, s = 4294967295, r += 76), no(d, r, 101010256), Vo(d, r + 8, c), Vo(d, r + 10, c), no(d, r + 12, s), no(d, r + 16, a), await i.writeUint8Array(f), t && t.length && await i.writeUint8Array(t) } function yle(e, t, n) { if (e.arrayBuffer) return t || n ? e.slice(t, n).arrayBuffer() : e.arrayBuffer(); { let i = new FileReader; return new Promise((o, r) => { i.onload = s => o(s.target.result), i.onerror = () => r(i.error), i.readAsArrayBuffer(t || n ? e.slice(t, n) : e) }) } } async function $qe(e, t, n = 0) { await o(); async function o() { if (n < t.size) { let r = await yle(t, n, n + 536870912); await e.writeUint8Array(new Uint8Array(r)), n += 536870912, await o() } } } function W9(e) { if (e) return (BigInt(e.getTime()) + BigInt(116444736e5)) * BigInt(1e4) } function na(e, t, n) { return t[n] === void 0 ? e.options[n] : t[n] } function eYe(e) { return e + 5 * (Math.floor(e / 16383) + 1) } function B2(e, t, n) { e.setUint8(t, n) } function Vo(e, t, n) { e.setUint16(t, n, !0) } function no(e, t, n) { e.setUint32(t, n, !0) } function Kc(e, t, n) { e.setBigUint64(t, n, !0) } function Ls(e, t, n) { e.set(t, n) } function Zf(e) { return new DataView(e.buffer) } NT({ Deflate: uce, Inflate: Bce }); var q9 = 32, tYe = "http://www.opengis.net/kml/2.2", $f = "http://www.google.com/kml/ext/2.2", nYe = "http://www.w3.org/2000/xmlns/"; function R2(e) { this._files = {}, this._promises = [], this._count = 0, this._modelCallback = e } var iYe = /^data:image\/([^,;]+)/; R2.prototype.texture = function (e) { let t = this, n; if (typeof e == "string" || e instanceof Pe) { if (e = Pe.createIfNeeded(e), !e.isDataUri) return e.url; let i = e.url.match(iYe); n = `texture_${++this._count}`, l(i) && (n += `.${i[1]}`); let o = e.fetchBlob().then(function (r) { t._files[n] = r }); return this._promises.push(o), n } if (e instanceof HTMLCanvasElement) { n = `texture_${++this._count}.png`; let i = new Promise(o => { e.toBlob(function (r) { t._files[n] = r, o() }) }); return this._promises.push(i), n } return "" }; function oYe(e, t) { return function (n) { e._files[t] = n } } R2.prototype.model = function (e, t) { let n = this._modelCallback; if (!l(n)) throw new fe("Encountered a model entity while exporting to KML, but no model callback was supplied."); let i = {}, o = n(e, t, i); for (let r in i) if (i.hasOwnProperty(r)) { let s = Promise.resolve(i[r]); this._promises.push(s), s.then(oYe(this, r)) } return o }; Object.defineProperties(R2.prototype, { promise: { get: function () { return Promise.all(this._promises) } }, files: { get: function () { return this._files } } }); function M2(e) { this._time = e } M2.prototype.get = function (e, t, n) { let i; return l(e) && (i = l(e.getValue) ? e.getValue(this._time, n) : e), y(i, t) }; M2.prototype.getColor = function (e, t) { let n = this.get(e, t); if (l(n)) return Ny(n) }; M2.prototype.getMaterialType = function (e) { if (!!l(e)) return e.getType(this._time) }; function Y9() { this._ids = {}, this._styles = {}, this._count = 0 } Y9.prototype.get = function (e) { let t = this._ids, n = e.innerHTML; if (l(t[n])) return t[n]; let i = `style-${++this._count}`; return e.setAttribute("id", i), i = `#${i}`, t[n] = i, this._styles[n] = e, i }; Y9.prototype.save = function (e) { let t = this._styles, n = e.childNodes[0]; for (let i in t) t.hasOwnProperty(i) && e.insertBefore(t[i], n) }; function Tle() { this._ids = {} } Tle.prototype.get = function (e) { if (!l(e)) return this.get(Nn()); let t = this._ids; return l(t[e]) ? `${e.toString()}-${++t[e]}` : (t[e] = 0, e) }; function X9(e) { e = y(e, y.EMPTY_OBJECT); let t = e.entities, n = y(e.kmz, !1), i = X9._createState(e), o = t.values.filter(function (u) { return !l(u.parent) }), r = i.kmlDoc, s = r.documentElement; s.setAttributeNS(nYe, "xmlns:gx", $f); let a = r.createElement("Document"); s.appendChild(a), ble(i, a, o), i.styleCache.save(a); let c = i.externalFileHandler; return c.promise.then(function () { let f = new XMLSerializer().serializeToString(i.kmlDoc); return n ? rYe(f, c.files) : { kml: f, externalFiles: c.files } }) } function rYe(e, t) { let n = Jt("ThirdParty/Workers/z-worker-pako.js"); NT({ workerScripts: { deflate: [n, "./pako_deflate.min.js"], inflate: [n, "./pako_inflate.min.js"] } }); let i = new HT, o = new O2(i); return o.add("doc.kml", new _2(e)).then(function () { let r = Object.keys(t); return Ele(o, r, t, 0) }).then(function () { return o.close() }).then(function (r) { return { kmz: r } }) } function Ele(e, t, n, i) { if (t.length === i) return; let o = t[i]; return e.add(o, new Ly(n[o])).then(function () { return Ele(e, t, n, i + 1) }) } X9._createState = function (e) { let t = e.entities, n = new Y9, i = t.computeAvailability(), o = l(e.time) ? e.time : i.start, r = y(e.defaultAvailability, i), s = y(e.sampleDuration, 60); r.start === ke.MINIMUM_VALUE ? r.stop === ke.MAXIMUM_VALUE ? r = new yn : $.addSeconds(r.stop, -10 * s, r.start) : r.stop === ke.MAXIMUM_VALUE && $.addSeconds(r.start, 10 * s, r.stop); let a = new R2(e.modelCallback); return { kmlDoc: document.implementation.createDocument(tYe, "kml"), ellipsoid: y(e.ellipsoid, ie.WGS84), idManager: new Tle, styleCache: n, externalFileHandler: a, time: o, valueGetter: new M2(o), sampleDuration: s, defaultAvailability: new Ir([r]) } }; function ble(e, t, n) { let i = e.kmlDoc, o = e.styleCache, r = e.valueGetter, s = e.idManager, a = n.length, c, u, f; for (let d = 0; d < a; ++d) { let p = n[d]; c = [], u = [], f = [], sYe(e, p, u, f), aYe(e, p.polyline, u, f), xle(e, p.rectangle, u, f, c), xle(e, p.polygon, u, f, c), fYe(e, p, p.model, u, f); let g, m = p.availability; l(m) && (g = i.createElement("TimeSpan"), $.equals(m.start, ke.MINIMUM_VALUE) || g.appendChild(on(i, "begin", $.toIso8601(m.start))), $.equals(m.stop, ke.MAXIMUM_VALUE) || g.appendChild(on(i, "end", $.toIso8601(m.stop)))); for (let x = 0; x < c.length; ++x) { let T = c[x]; T.setAttribute("id", s.get(p.id)), T.appendChild(on(i, "name", p.name)), T.appendChild(on(i, "visibility", p.show)), T.appendChild(on(i, "description", p.description)), l(g) && T.appendChild(g), t.appendChild(T) } let A = u.length; if (A > 0) { let x = i.createElement("Placemark"); x.setAttribute("id", s.get(p.id)); let T = p.name, b = p.label; if (l(b)) { let D = i.createElement("LabelStyle"), P = r.get(b.text); T = l(P) && P.length > 0 ? P : T; let B = r.getColor(b.fillColor); l(B) && (D.appendChild(on(i, "color", B)), D.appendChild(on(i, "colorMode", "normal"))); let R = r.get(b.scale); l(R) && D.appendChild(on(i, "scale", R)), f.push(D) } x.appendChild(on(i, "name", T)), x.appendChild(on(i, "visibility", p.show)), x.appendChild(on(i, "description", p.description)), l(g) && x.appendChild(g), t.appendChild(x); let S = f.length; if (S > 0) { let D = i.createElement("Style"); for (let P = 0; P < S; ++P)D.appendChild(f[P]); x.appendChild(on(i, "styleUrl", o.get(D))) } if (u.length === 1) x.appendChild(u[0]); else if (u.length > 1) { let D = i.createElement("MultiGeometry"); for (let P = 0; P < A; ++P)D.appendChild(u[P]); x.appendChild(D) } } let C = p._children; if (C.length > 0) { let x = i.createElement("Folder"); x.setAttribute("id", s.get(p.id)), x.appendChild(on(i, "name", p.name)), x.appendChild(on(i, "visibility", p.show)), x.appendChild(on(i, "description", p.description)), t.appendChild(x), ble(e, x, C) } } } var Jc = new h, mc = new he, Qf = new $; function sYe(e, t, n, i) { let o = e.kmlDoc, r = e.ellipsoid, s = e.valueGetter, a = y(t.billboard, t.point); if (!l(a) && !l(t.path)) return; let c = t.position; if (!c.isConstant) { Sle(e, t, a, n, i); return } s.get(c, void 0, Jc); let u = on(o, "coordinates", Fy(Jc, r)), f = o.createElement("Point"), d = o.createElement("altitudeMode"); d.appendChild(Vy(e, a.heightReference)), f.appendChild(d), f.appendChild(u), n.push(f); let p = a instanceof ja ? Dle(e, a) : wle(e, a); i.push(p) } function Sle(e, t, n, i, o) { let r = e.kmlDoc, s = e.ellipsoid, a = e.valueGetter, c, u = t.position, f = !0; u instanceof $s ? (c = u.intervals, f = !1) : c = y(t.availability, e.defaultAvailability); let d = n instanceof zp, p, g, m, A = []; for (p = 0; p < c.length; ++p) { let x = c.get(p), T = f ? u : x.data, b = r.createElement("altitudeMode"); T instanceof ip ? (T = T._value, b.appendChild(Vy(e, ze.CLAMP_TO_GROUND))) : l(n) ? b.appendChild(Vy(e, n.heightReference)) : b.appendChild(Vy(e, ze.NONE)); let S = [], D = []; if (T.isConstant) { a.get(T, void 0, Jc); let B = on(r, "coordinates", Fy(Jc, s)); S.push($.toIso8601(x.start)), D.push(B), S.push($.toIso8601(x.stop)), D.push(B) } else if (T instanceof ea) for (m = T._property._times, g = 0; g < m.length; ++g)S.push($.toIso8601(m[g])), T.getValueInReferenceFrame(m[g], Ji.FIXED, Jc), D.push(Fy(Jc, s)); else if (T instanceof Bu) { m = T._times; let B = T._values; for (g = 0; g < m.length; ++g)S.push($.toIso8601(m[g])), h.fromArray(B, g * 3, Jc), D.push(Fy(Jc, s)) } else { let B = e.sampleDuration; x.start.clone(Qf), x.isStartIncluded || $.addSeconds(Qf, B, Qf); let R = x.stop; for (; $.lessThan(Qf, R);)T.getValue(Qf, Jc), S.push($.toIso8601(Qf)), D.push(Fy(Jc, s)), $.addSeconds(Qf, B, Qf); x.isStopIncluded && $.equals(Qf, R) && (T.getValue(Qf, Jc), S.push($.toIso8601(Qf)), D.push(Fy(Jc, s))) } let P = r.createElementNS($f, "Track"); P.appendChild(b); for (let B = 0; B < S.length; ++B) { let R = on(r, "when", S[B]), M = on(r, "coord", D[B], $f); P.appendChild(R), P.appendChild(M) } d && P.appendChild(vle(e, n)), A.push(P) } if (A.length === 1) i.push(A[0]); else if (A.length > 1) { let x = r.createElementNS($f, "MultiTrack"); for (p = 0; p < A.length; ++p)x.appendChild(A[p]); i.push(x) } if (l(n) && !d) { let x = n instanceof ja ? Dle(e, n) : wle(e, n); o.push(x) } let C = t.path; if (l(C)) { let x = a.get(C.width), T = C.material; if (l(T) || l(x)) { let b = r.createElement("LineStyle"); l(x) && b.appendChild(on(r, "width", x)), K9(e, T, b), o.push(b) } } } function wle(e, t) { let n = e.kmlDoc, i = e.valueGetter, o = n.createElement("IconStyle"), r = i.getColor(t.color); l(r) && (o.appendChild(on(n, "color", r)), o.appendChild(on(n, "colorMode", "normal"))); let s = i.get(t.pixelSize); return l(s) && o.appendChild(on(n, "scale", s / q9)), o } function Dle(e, t) { let n = e.kmlDoc, i = e.valueGetter, o = e.externalFileHandler, r = n.createElement("IconStyle"), s = i.get(t.image); if (l(s)) { s = o.texture(s); let p = n.createElement("Icon"); p.appendChild(on(n, "href", s)); let g = i.get(t.imageSubRegion); l(g) && (p.appendChild(on(n, "x", g.x, $f)), p.appendChild(on(n, "y", g.y, $f)), p.appendChild(on(n, "w", g.width, $f)), p.appendChild(on(n, "h", g.height, $f))), r.appendChild(p) } let a = i.getColor(t.color); l(a) && (r.appendChild(on(n, "color", a)), r.appendChild(on(n, "colorMode", "normal"))); let c = i.get(t.scale); l(c) && r.appendChild(on(n, "scale", c)); let u = i.get(t.pixelOffset); if (l(u)) { c = y(c, 1), H.divideByScalar(u, c, u); let p = i.get(t.width, q9), g = i.get(t.height, q9), m = i.get(t.horizontalOrigin, ai.CENTER); m === ai.CENTER ? u.x -= p * .5 : m === ai.RIGHT && (u.x -= p); let A = i.get(t.verticalOrigin, Sn.CENTER); A === Sn.TOP ? u.y += g : A === Sn.CENTER && (u.y += g * .5); let C = n.createElement("hotSpot"); C.setAttribute("x", -u.x), C.setAttribute("y", u.y), C.setAttribute("xunits", "pixels"), C.setAttribute("yunits", "pixels"), r.appendChild(C) } let f = i.get(t.rotation), d = i.get(t.alignedAxis); return l(f) && h.equals(h.UNIT_Z, d) && (f = I.toDegrees(-f), f === 0 && (f = 360), r.appendChild(on(n, "heading", f))), r } function aYe(e, t, n, i) { let o = e.kmlDoc, r = e.ellipsoid, s = e.valueGetter; if (!l(t)) return; let a = o.createElement("LineString"), c = o.createElement("altitudeMode"), u = s.get(t.clampToGround, !1), f; u ? (a.appendChild(on(o, "tessellate", !0)), f = o.createTextNode("clampToGround")) : f = o.createTextNode("absolute"), c.appendChild(f), a.appendChild(c); let d = t.positions, p = s.get(d), g = on(o, "coordinates", Fy(p, r)); a.appendChild(g); let m = s.get(t.zIndex); u && l(m) && a.appendChild(on(o, "drawOrder", m, $f)), n.push(a); let A = o.createElement("LineStyle"), C = s.get(t.width); l(C) && A.appendChild(on(o, "width", C)), K9(e, t.material, A), i.push(A) } function cYe(e, t, n) { let i = e.kmlDoc, o = e.valueGetter, r = o.get(t.height, 0); n > 0 && (r = n); let s = t.coordinates, a = o.get(s), c = [], u = [ce.northeast, ce.southeast, ce.southwest, ce.northwest]; for (let g = 0; g < 4; ++g)u[g](a, mc), c.push(`${I.toDegrees(mc.longitude)},${I.toDegrees(mc.latitude)},${r}`); let f = on(i, "coordinates", c.join(" ")), d = i.createElement("outerBoundaryIs"), p = i.createElement("LinearRing"); return p.appendChild(f), d.appendChild(p), [d] } function Cle(e, t, n, i) { let o = e.kmlDoc, r = e.ellipsoid, s = [], a = t.length; for (let f = 0; f < a; ++f)he.fromCartesian(t[f], r, mc), s.push(`${I.toDegrees(mc.longitude)},${I.toDegrees(mc.latitude)},${i ? mc.height : n}`); let c = on(o, "coordinates", s.join(" ")), u = o.createElement("LinearRing"); return u.appendChild(c), u } function lYe(e, t, n) { let i = e.kmlDoc, o = e.valueGetter, r = o.get(t.height, 0), s = o.get(t.perPositionHeight, !1); !s && n > 0 && (r = n); let a = [], c = t.hierarchy, u = o.get(c), f = Array.isArray(u) ? u : u.positions, d = i.createElement("outerBoundaryIs"); d.appendChild(Cle(e, f, r, s)), a.push(d); let p = u.holes; if (l(p)) { let g = p.length; for (let m = 0; m < g; ++m) { let A = i.createElement("innerBoundaryIs"); A.appendChild(Cle(e, p[m].positions, r, s)), a.push(A) } } return a } function xle(e, t, n, i, o) { let r = e.kmlDoc, s = e.valueGetter; if (!l(t)) return; let a = t instanceof Ld; if (a && s.getMaterialType(t.material) === "Image") { uYe(e, t, o); return } let c = r.createElement("Polygon"), u = s.get(t.extrudedHeight, 0); u > 0 && c.appendChild(on(r, "extrude", !0)); let f = a ? cYe(e, t, u) : lYe(e, t, u), d = f.length; for (let C = 0; C < d; ++C)c.appendChild(f[C]); let p = r.createElement("altitudeMode"); p.appendChild(Vy(e, t.heightReference)), c.appendChild(p), n.push(c); let g = r.createElement("PolyStyle"), m = s.get(t.fill, !1); m && g.appendChild(on(r, "fill", m)), K9(e, t.material, g); let A = s.get(t.outline, !1); if (A) { g.appendChild(on(r, "outline", A)); let C = r.createElement("LineStyle"), x = s.get(t.outlineWidth, 1); C.appendChild(on(r, "width", x)); let T = s.getColor(t.outlineColor, U.BLACK); C.appendChild(on(r, "color", T)), C.appendChild(on(r, "colorMode", "normal")), i.push(C) } i.push(g) } function uYe(e, t, n) { let i = e.kmlDoc, o = e.valueGetter, r = e.externalFileHandler, s = i.createElement("GroundOverlay"), a = i.createElement("altitudeMode"); a.appendChild(Vy(e, t.heightReference)), s.appendChild(a); let c = o.get(t.height); l(c) && s.appendChild(on(i, "altitude", c)); let u = o.get(t.coordinates), f = i.createElement("LatLonBox"); f.appendChild(on(i, "north", I.toDegrees(u.north))), f.appendChild(on(i, "south", I.toDegrees(u.south))), f.appendChild(on(i, "east", I.toDegrees(u.east))), f.appendChild(on(i, "west", I.toDegrees(u.west))), s.appendChild(f); let d = o.get(t.material), p = r.texture(d.image), g = i.createElement("Icon"); g.appendChild(on(i, "href", p)), s.appendChild(g); let m = d.color; l(m) && s.appendChild(on(i, "color", Ny(d.color))), n.push(s) } function vle(e, t) { let n = e.kmlDoc, i = e.valueGetter, o = e.externalFileHandler, r = n.createElement("Model"), s = i.get(t.scale); if (l(s)) { let u = n.createElement("scale"); u.appendChild(on(n, "x", s)), u.appendChild(on(n, "y", s)), u.appendChild(on(n, "z", s)), r.appendChild(u) } let a = n.createElement("Link"), c = o.model(t, e.time); return a.appendChild(on(n, "href", c)), r.appendChild(a), r } function fYe(e, t, n, i, o) { let r = e.kmlDoc, s = e.ellipsoid, a = e.valueGetter; if (!l(n)) return; let c = t.position; if (!c.isConstant) { Sle(e, t, n, i, o); return } let u = vle(e, n), f = r.createElement("altitudeMode"); f.appendChild(Vy(e, n.heightReference)), u.appendChild(f), a.get(c, void 0, Jc), he.fromCartesian(Jc, s, mc); let d = r.createElement("Location"); d.appendChild(on(r, "longitude", I.toDegrees(mc.longitude))), d.appendChild(on(r, "latitude", I.toDegrees(mc.latitude))), d.appendChild(on(r, "altitude", mc.height)), u.appendChild(d), i.push(u) } function K9(e, t, n) { let i = e.kmlDoc, o = e.valueGetter; if (!l(t)) return; let r = o.get(t); if (!l(r)) return; let s, a = o.getMaterialType(t), c, u; switch (a) { case "Image": s = Ny(U.WHITE); break; case "Color": case "Grid": case "PolylineGlow": case "PolylineArrow": case "PolylineDash": s = Ny(r.color); break; case "PolylineOutline": s = Ny(r.color), c = Ny(r.outlineColor), u = r.outlineWidth, n.appendChild(on(i, "outerColor", c, $f)), n.appendChild(on(i, "outerWidth", u, $f)); break; case "Stripe": s = Ny(r.oddColor); break }l(s) && (n.appendChild(on(i, "color", s)), n.appendChild(on(i, "colorMode", "normal"))) } function Vy(e, t) { let n = e.kmlDoc, o = e.valueGetter.get(t, ze.NONE), r; switch (o) { case ze.NONE: r = n.createTextNode("absolute"); break; case ze.CLAMP_TO_GROUND: r = n.createTextNode("clampToGround"); break; case ze.RELATIVE_TO_GROUND: r = n.createTextNode("relativeToGround"); break }return r } function Fy(e, t) { Array.isArray(e) || (e = [e]); let n = e.length, i = []; for (let o = 0; o < n; ++o)he.fromCartesian(e[o], t, mc), i.push(`${I.toDegrees(mc.longitude)},${I.toDegrees(mc.latitude)},${mc.height}`); return i.join(" ") } function on(e, t, n, i) { n = y(n, ""), typeof n == "boolean" && (n = n ? "1" : "0"); let o = l(i) ? e.createElementNS(i, t) : e.createElement(t), r = n === "string" && n.indexOf("<") !== -1 ? e.createCDATASection(n) : e.createTextNode(n); return o.appendChild(r), o } function Ny(e) { let t = "", n = e.toBytes(); for (let i = 3; i >= 0; --i)t += n[i] < 16 ? `0${n[i].toString(16)}` : n[i].toString(16); return t } var Ple = X9; function mD() { this._cache = {} } mD.prototype.fromColor = function (e, t) { return L2(void 0, void 0, e, t, this._cache) }; mD.prototype.fromUrl = function (e, t, n) { return L2(e, void 0, t, n, this._cache) }; mD.prototype.fromMakiIconId = function (e, t, n) { return L2(Jt(`Assets/Textures/maki/${encodeURIComponent(e)}.png`), void 0, t, n, this._cache) }; mD.prototype.fromText = function (e, t, n) { return L2(void 0, e, t, n, this._cache) }; var dYe = new U; function hYe(e, t, n) { e.save(), e.scale(n / 24, n / 24), e.fillStyle = t.toCssColorString(), e.strokeStyle = t.brighten(.6, dYe).toCssColorString(), e.lineWidth = .846, e.beginPath(), e.moveTo(6.72, .422), e.lineTo(17.28, .422), e.bezierCurveTo(18.553, .422, 19.577, 1.758, 19.577, 3.415), e.lineTo(19.577, 10.973), e.bezierCurveTo(19.577, 12.63, 18.553, 13.966, 17.282, 13.966), e.lineTo(14.386, 14.008), e.lineTo(11.826, 23.578), e.lineTo(9.614, 14.008), e.lineTo(6.719, 13.965), e.bezierCurveTo(5.446, 13.983, 4.422, 12.629, 4.422, 10.972), e.lineTo(4.422, 3.416), e.bezierCurveTo(4.423, 1.76, 5.447, .423, 6.718, .423), e.closePath(), e.fill(), e.stroke(), e.restore() } function Ile(e, t, n) { let i = n / 2.5, o = i, r = i; t.width > t.height ? r = i * (t.height / t.width) : t.width < t.height && (o = i * (t.width / t.height)); let s = Math.round((n - o) / 2), a = Math.round(7 / 24 * n - r / 2); e.globalCompositeOperation = "destination-out", e.drawImage(t, s - 1, a, o, r), e.drawImage(t, s, a - 1, o, r), e.drawImage(t, s + 1, a, o, r), e.drawImage(t, s, a + 1, o, r), e.globalCompositeOperation = "destination-over", e.fillStyle = U.BLACK.toCssColorString(), e.fillRect(s - 1, a - 1, o + 2, r + 2), e.globalCompositeOperation = "destination-out", e.drawImage(t, s, a, o, r), e.globalCompositeOperation = "destination-over", e.fillStyle = U.WHITE.toCssColorString(), e.fillRect(s - 1, a - 2, o + 2, r + 2) } var hD = new Array(4); function L2(e, t, n, i, o) { hD[0] = e, hD[1] = t, hD[2] = n, hD[3] = i; let r = JSON.stringify(hD), s = o[r]; if (l(s)) return s; let a = document.createElement("canvas"); a.width = i, a.height = i; let c = a.getContext("2d"); if (hYe(c, n, i), l(e)) { let f = Pe.createIfNeeded(e).fetchImage().then(function (d) { return Ile(c, d, i), o[r] = a, a }); return o[r] = f, f } else if (l(t)) { let u = Ax(t, { font: `bold ${i}px sans-serif` }); Ile(c, u, i) } return o[r] = a, a } var pg = mD; function J9(e) { return e } function F2(e) { if (e == null) return J9; var t, n, i = e.scale[0], o = e.scale[1], r = e.translate[0], s = e.translate[1]; return function (a, c) { c || (t = n = 0); var u = 2, f = a.length, d = new Array(f); for (d[0] = (t += a[0]) * i + r, d[1] = (n += a[1]) * o + s; u < f;)d[u] = a[u], ++u; return d } } function Ole(e, t) { for (var n, i = e.length, o = i - t; o < --i;)n = e[o], e[o++] = e[i], e[i] = n } function Z9(e, t) { return typeof t == "string" && (t = e.objects[t]), t.type === "GeometryCollection" ? { type: "FeatureCollection", features: t.geometries.map(function (n) { return Ble(e, n) }) } : Ble(e, t) } function Ble(e, t) { var n = t.id, i = t.bbox, o = t.properties == null ? {} : t.properties, r = Q9(e, t); return n == null && i == null ? { type: "Feature", properties: o, geometry: r } : i == null ? { type: "Feature", id: n, properties: o, geometry: r } : { type: "Feature", id: n, bbox: i, properties: o, geometry: r } } function Q9(e, t) { var n = F2(e.transform), i = e.arcs; function o(f, d) { d.length && d.pop(); for (var p = i[f < 0 ? ~f : f], g = 0, m = p.length; g < m; ++g)d.push(n(p[g], g)); f < 0 && Ole(d, m) } function r(f) { return n(f) } function s(f) { for (var d = [], p = 0, g = f.length; p < g; ++p)o(f[p], d); return d.length < 2 && d.push(d[0]), d } function a(f) { for (var d = s(f); d.length < 4;)d.push(d[0]); return d } function c(f) { return f.map(a) } function u(f) { var d = f.type, p; switch (d) { case "GeometryCollection": return { type: d, geometries: f.geometries.map(u) }; case "Point": p = r(f.coordinates); break; case "MultiPoint": p = f.coordinates.map(r); break; case "LineString": p = s(f.arcs); break; case "MultiLineString": p = f.arcs.map(s); break; case "Polygon": p = c(f.arcs); break; case "MultiPolygon": p = f.arcs.map(c); break; default: return null }return { type: d, coordinates: p } } return u(t) } function N2(e) { return h.fromDegrees(e[0], e[1], e[2]) } var $9 = { "urn:ogc:def:crs:OGC:1.3:CRS84": N2, "EPSG:4326": N2, "urn:ogc:def:crs:EPSG::4326": N2 }, Rle = {}, Mle = {}, eW = 48, tW, nW = U.ROYALBLUE, iW = U.YELLOW, oW = 2, rW = U.fromBytes(255, 255, 0, 100), sW = !1, yYe = { small: 24, medium: 48, large: 64 }, AYe = ["title", "description", "marker-size", "marker-symbol", "marker-color", "stroke", "stroke-opacity", "stroke-width", "fill", "fill-opacity"]; function Lle(e, t) { let n = ""; for (let i in e) if (e.hasOwnProperty(i)) { if (i === t || AYe.indexOf(i) !== -1) continue; let o = e[i]; l(o) && (typeof o == "object" ? n += `<tr><th>${i}</th><td>${Lle(o)}</td></tr>` : n += `<tr><th>${i}</th><td>${o}</td></tr>`) } return n.length > 0 && (n = `<table class="cesium-infoBox-defaultTable"><tbody>${n}</tbody></table>`), n } function CYe(e, t, n) { let i; return function (o, r) { return l(i) || (i = e(t, n)), i } } function xYe(e, t) { return new Nd(CYe(Lle, e, t), !0) } function V2(e, t, n) { let i = e.id; if (!l(i) || e.type !== "Feature") i = Nn(); else { let s = 2, a = i; for (; l(t.getById(a));)a = `${i}_${s}`, s++; i = a } let o = t.getOrCreateEntity(i), r = e.properties; if (l(r)) { o.properties = r; let s, a = r.title; if (l(a)) o.name = a, s = "title"; else { let u = Number.MAX_VALUE; for (let f in r) if (r.hasOwnProperty(f) && r[f]) { let d = f.toLowerCase(); if (u > 1 && d === "title") { u = 1, s = f; break } else u > 2 && d === "name" ? (u = 2, s = f) : u > 3 && /title/i.test(f) ? (u = 3, s = f) : u > 4 && /name/i.test(f) && (u = 4, s = f) } l(s) && (o.name = r[s]) } let c = r.description; c !== null && (o.description = l(c) ? new Yn(c) : n(r, s)) } return o } function aW(e, t) { let n = new Array(e.length); for (let i = 0; i < e.length; i++)n[i] = t(e[i]); return n } var Fle = { Feature: Vle, FeatureCollection: TYe, GeometryCollection: kle, LineString: Wle, MultiLineString: jle, MultiPoint: Hle, MultiPolygon: Xle, Point: zle, Polygon: Yle, Topology: Kle }, Nle = { GeometryCollection: kle, LineString: Wle, MultiLineString: jle, MultiPoint: Hle, MultiPolygon: Xle, Point: zle, Polygon: Yle, Topology: Kle }; function Vle(e, t, n, i, o) { if (t.geometry === null) { V2(t, e._entityCollection, o.describe); return } if (!l(t.geometry)) throw new fe("feature.geometry is required."); let r = t.geometry.type, s = Nle[r]; if (!l(s)) throw new fe(`Unknown geometry type: ${r}`); s(e, t, t.geometry, i, o) } function TYe(e, t, n, i, o) { let r = t.features; for (let s = 0, a = r.length; s < a; s++)Vle(e, r[s], void 0, i, o) } function kle(e, t, n, i, o) { let r = n.geometries; for (let s = 0, a = r.length; s < a; s++) { let c = r[s], u = c.type, f = Nle[u]; if (!l(f)) throw new fe(`Unknown geometry type: ${u}`); f(e, t, c, i, o) } } function Ule(e, t, n, i, o) { let r = o.markerSymbol, s = o.markerColor, a = o.markerSize, c = t.properties; if (l(c)) { let g = c["marker-color"]; l(g) && (s = U.fromCssColorString(g)), a = y(yYe[c["marker-size"]], a); let m = c["marker-symbol"]; l(m) && (r = m) } let u; l(r) ? r.length === 1 ? u = e._pinBuilder.fromText(r.toUpperCase(), s, a) : u = e._pinBuilder.fromMakiIconId(r, s, a) : u = e._pinBuilder.fromColor(s, a); let f = new ja; f.verticalOrigin = new Yn(Sn.BOTTOM), i.length === 2 && o.clampToGround && (f.heightReference = ze.CLAMP_TO_GROUND); let d = V2(t, e._entityCollection, o.describe); d.billboard = f, d.position = new Mc(n(i)); let p = Promise.resolve(u).then(function (g) { f.image = new Yn(g) }).catch(function () { f.image = new Yn(e._pinBuilder.fromColor(s, a)) }); e._promises.push(p) } function zle(e, t, n, i, o) { Ule(e, t, i, n.coordinates, o) } function Hle(e, t, n, i, o) { let r = n.coordinates; for (let s = 0; s < r.length; s++)Ule(e, t, i, r[s], o) } function Gle(e, t, n, i, o) { let r = o.strokeMaterialProperty, s = o.strokeWidthProperty, a = t.properties; if (l(a)) { let f = a["stroke-width"]; l(f) && (s = new Yn(f)); let d, p = a.stroke; l(p) && (d = U.fromCssColorString(p)); let g = a["stroke-opacity"]; l(g) && g !== 1 && (l(d) || (d = r.color.getValue().clone()), d.alpha = g), l(d) && (r = new Ot(d)) } let c = V2(t, e._entityCollection, o.describe), u = new ec; c.polyline = u, u.clampToGround = o.clampToGround, u.material = r, u.width = s, u.positions = new Yn(aW(i, n)), u.arcType = Yt.RHUMB } function Wle(e, t, n, i, o) { Gle(e, t, i, n.coordinates, o) } function jle(e, t, n, i, o) { let r = n.coordinates; for (let s = 0; s < r.length; s++)Gle(e, t, i, r[s], o) } function qle(e, t, n, i, o) { if (i.length === 0 || i[0].length === 0) return; let r = o.strokeMaterialProperty.color, s = o.fillMaterialProperty, a = o.strokeWidthProperty, c = t.properties; if (l(c)) { let g = c["stroke-width"]; l(g) && (a = new Yn(g)); let m, A = c.stroke; l(A) && (m = U.fromCssColorString(A)); let C = c["stroke-opacity"]; l(C) && C !== 1 && (l(m) || (m = r.getValue().clone()), m.alpha = C), l(m) && (r = new Yn(m)); let x, T = c.fill, b = s.color.getValue(); l(T) && (x = U.fromCssColorString(T), x.alpha = b.alpha), C = c["fill-opacity"], l(C) && C !== b.alpha && (l(x) || (x = b.clone()), x.alpha = C), l(x) && (s = new Ot(x)) } let u = new Md; u.outline = new Yn(!0), u.outlineColor = r, u.outlineWidth = a, u.material = s, u.arcType = Yt.RHUMB; let f = []; for (let g = 1, m = i.length; g < m; g++)f.push(new Lc(aW(i[g], n))); let d = i[0]; u.hierarchy = new Yn(new Lc(aW(d, n), f)), d[0].length > 2 ? u.perPositionHeight = new Yn(!0) : o.clampToGround || (u.height = 0); let p = V2(t, e._entityCollection, o.describe); p.polygon = u } function Yle(e, t, n, i, o) { qle(e, t, i, n.coordinates, o) } function Xle(e, t, n, i, o) { let r = n.coordinates; for (let s = 0; s < r.length; s++)qle(e, t, i, r[s], o) } function Kle(e, t, n, i, o) { for (let r in n.objects) if (n.objects.hasOwnProperty(r)) { let s = Z9(n, n.objects[r]), a = Fle[s.type]; a(e, s, s, i, o) } } function _g(e) { this._name = e, this._changed = new _e, this._error = new _e, this._isLoading = !1, this._loading = new _e, this._entityCollection = new vs(this), this._promises = [], this._pinBuilder = new pg, this._entityCluster = new Iu, this._credit = void 0, this._resourceCredits = [] } _g.load = function (e, t) { return new _g().load(e, t) }; Object.defineProperties(_g, { markerSize: { get: function () { return eW }, set: function (e) { eW = e } }, markerSymbol: { get: function () { return tW }, set: function (e) { tW = e } }, markerColor: { get: function () { return nW }, set: function (e) { nW = e } }, stroke: { get: function () { return iW }, set: function (e) { iW = e } }, strokeWidth: { get: function () { return oW }, set: function (e) { oW = e } }, fill: { get: function () { return rW }, set: function (e) { rW = e } }, clampToGround: { get: function () { return sW }, set: function (e) { sW = e } }, crsNames: { get: function () { return $9 } }, crsLinkHrefs: { get: function () { return Rle } }, crsLinkTypes: { get: function () { return Mle } } }); Object.defineProperties(_g.prototype, { name: { get: function () { return this._name }, set: function (e) { this._name !== e && (this._name = e, this._changed.raiseEvent(this)) } }, clock: { value: void 0, writable: !1 }, entities: { get: function () { return this._entityCollection } }, isLoading: { get: function () { return this._isLoading } }, changedEvent: { get: function () { return this._changed } }, errorEvent: { get: function () { return this._error } }, loadingEvent: { get: function () { return this._loading } }, show: { get: function () { return this._entityCollection.show }, set: function (e) { this._entityCollection.show = e } }, clustering: { get: function () { return this._entityCluster }, set: function (e) { this._entityCluster = e } }, credit: { get: function () { return this._credit } } }); _g.prototype.load = function (e, t) { return Jle(this, e, t, !0) }; _g.prototype.process = function (e, t) { return Jle(this, e, t, !1) }; function Jle(e, t, n, i) { Or.setLoading(e, !0), n = y(n, y.EMPTY_OBJECT); let o = n.credit; typeof o == "string" && (o = new Xt(o)), e._credit = o; let r = t, s = n.sourceUri; if (typeof t == "string" || t instanceof Pe) { t = Pe.createIfNeeded(t), r = t.fetchJson(), s = y(s, t.getUrlComponent()); let a = e._resourceCredits, c = t.credits; if (l(c)) { let u = c.length; for (let f = 0; f < u; f++)a.push(c[f]) } } return n = { describe: y(n.describe, xYe), markerSize: y(n.markerSize, eW), markerSymbol: y(n.markerSymbol, tW), markerColor: y(n.markerColor, nW), strokeWidthProperty: new Yn(y(n.strokeWidth, oW)), strokeMaterialProperty: new Ot(y(n.stroke, iW)), fillMaterialProperty: new Ot(y(n.fill, rW)), clampToGround: y(n.clampToGround, sW) }, Promise.resolve(r).then(function (a) { return EYe(e, a, n, s, i) }).catch(function (a) { throw Or.setLoading(e, !1), e._error.raiseEvent(e, a), a }) } _g.prototype.update = function (e) { return !0 }; function EYe(e, t, n, i, o) { let r; l(i) && (r = q_(i)), l(r) && e._name !== r && (e._name = r, e._changed.raiseEvent(e)); let s = Fle[t.type]; if (!l(s)) throw new fe(`Unsupported GeoJSON object type: ${t.type}`); let a = t.crs, c = a !== null ? N2 : null; if (l(a)) { if (!l(a.properties)) throw new fe("crs.properties is undefined."); let u = a.properties; if (a.type === "name") { if (c = $9[u.name], !l(c)) throw new fe(`Unknown crs name: ${u.name}`) } else if (a.type === "link") { let f = Rle[u.href]; if (l(f) || (f = Mle[u.type]), !l(f)) throw new fe(`Unable to resolve crs link: ${JSON.stringify(u)}`); c = f(u) } else if (a.type === "EPSG") { if (c = $9[`EPSG:${u.code}`], !l(c)) throw new fe(`Unknown crs EPSG code: ${u.code}`) } else throw new fe(`Unknown crs type: ${a.type}`) } return Promise.resolve(c).then(function (u) { return o && e._entityCollection.removeAll(), u !== null && s(e, t, t, u, n), Promise.all(e._promises).then(function () { return e._promises.length = 0, Or.setLoading(e, !1), e }) }) } var k2 = _g; var Zle = "3.16.2"; function Qle(e, t) { for (var n in t) t.hasOwnProperty(n) && e[n] === void 0 && (e[n] = t[n]); return e } function $le(e, t, n) { var i; return e.length > t && (n == null ? (n = "&hellip;", i = 3) : i = n.length, e = e.substring(0, t - i) + n), e } function cW(e, t) { if (Array.prototype.indexOf) return e.indexOf(t); for (var n = 0, i = e.length; n < i; n++)if (e[n] === t) return n; return -1 } function gg(e, t) { for (var n = e.length - 1; n >= 0; n--)t(e[n]) === !0 && e.splice(n, 1) } function eue(e, t) { if (!t.global) throw new Error("`splitRegex` must have the 'g' flag set"); for (var n = [], i = 0, o; o = t.exec(e);)n.push(e.substring(i, o.index)), n.push(o[0]), i = o.index + o[0].length; return n.push(e.substring(i)), n } function qT(e) { throw new Error("Unhandled case for value: '".concat(e, "'")) } var pD = function () { function e(t) { t === void 0 && (t = {}), this.tagName = "", this.attrs = {}, this.innerHTML = "", this.whitespaceRegex = /\s+/, this.tagName = t.tagName || "", this.attrs = t.attrs || {}, this.innerHTML = t.innerHtml || t.innerHTML || "" } return e.prototype.setTagName = function (t) { return this.tagName = t, this }, e.prototype.getTagName = function () { return this.tagName || "" }, e.prototype.setAttr = function (t, n) { var i = this.getAttrs(); return i[t] = n, this }, e.prototype.getAttr = function (t) { return this.getAttrs()[t] }, e.prototype.setAttrs = function (t) { return Object.assign(this.getAttrs(), t), this }, e.prototype.getAttrs = function () { return this.attrs || (this.attrs = {}) }, e.prototype.setClass = function (t) { return this.setAttr("class", t) }, e.prototype.addClass = function (t) { for (var n = this.getClass(), i = this.whitespaceRegex, o = n ? n.split(i) : [], r = t.split(i), s; s = r.shift();)cW(o, s) === -1 && o.push(s); return this.getAttrs().class = o.join(" "), this }, e.prototype.removeClass = function (t) { for (var n = this.getClass(), i = this.whitespaceRegex, o = n ? n.split(i) : [], r = t.split(i), s; o.length && (s = r.shift());) { var a = cW(o, s); a !== -1 && o.splice(a, 1) } return this.getAttrs().class = o.join(" "), this }, e.prototype.getClass = function () { return this.getAttrs().class || "" }, e.prototype.hasClass = function (t) { return (" " + this.getClass() + " ").indexOf(" " + t + " ") !== -1 }, e.prototype.setInnerHTML = function (t) { return this.innerHTML = t, this }, e.prototype.setInnerHtml = function (t) { return this.setInnerHTML(t) }, e.prototype.getInnerHTML = function () { return this.innerHTML || "" }, e.prototype.getInnerHtml = function () { return this.getInnerHTML() }, e.prototype.toAnchorString = function () { var t = this.getTagName(), n = this.buildAttrsStr(); return n = n ? " " + n : "", ["<", t, n, ">", this.getInnerHtml(), "</", t, ">"].join("") }, e.prototype.buildAttrsStr = function () { if (!this.attrs) return ""; var t = this.getAttrs(), n = []; for (var i in t) t.hasOwnProperty(i) && n.push(i + '="' + t[i] + '"'); return n.join(" ") }, e }(); function tue(e, t, n) { var i, o; n == null ? (n = "&hellip;", o = 3, i = 8) : (o = n.length, i = n.length); var r = function (T) { var b = {}, S = T, D = S.match(/^([a-z]+):\/\//i); return D && (b.scheme = D[1], S = S.substr(D[0].length)), D = S.match(/^(.*?)(?=(\?|#|\/|$))/i), D && (b.host = D[1], S = S.substr(D[0].length)), D = S.match(/^\/(.*?)(?=(\?|#|$))/i), D && (b.path = D[1], S = S.substr(D[0].length)), D = S.match(/^\?(.*?)(?=(#|$))/i), D && (b.query = D[1], S = S.substr(D[0].length)), D = S.match(/^#(.*?)$/i), D && (b.fragment = D[1]), b }, s = function (T) { var b = ""; return T.scheme && T.host && (b += T.scheme + "://"), T.host && (b += T.host), T.path && (b += "/" + T.path), T.query && (b += "?" + T.query), T.fragment && (b += "#" + T.fragment), b }, a = function (T, b) { var S = b / 2, D = Math.ceil(S), P = -1 * Math.floor(S), B = ""; return P < 0 && (B = T.substr(P)), T.substr(0, D) + n + B }; if (e.length <= t) return e; var c = t - o, u = r(e); if (u.query) { var f = u.query.match(/^(.*?)(?=(\?|\#))(.*?)$/i); f && (u.query = u.query.substr(0, f[1].length), e = s(u)) } if (e.length <= t || (u.host && (u.host = u.host.replace(/^www\./, ""), e = s(u)), e.length <= t)) return e; var d = ""; if (u.host && (d += u.host), d.length >= c) return u.host.length == t ? (u.host.substr(0, t - o) + n).substr(0, c + i) : a(d, c).substr(0, c + i); var p = ""; if (u.path && (p += "/" + u.path), u.query && (p += "?" + u.query), p) if ((d + p).length >= c) { if ((d + p).length == t) return (d + p).substr(0, t); var g = c - d.length; return (d + a(p, g)).substr(0, c + i) } else d += p; if (u.fragment) { var m = "#" + u.fragment; if ((d + m).length >= c) { if ((d + m).length == t) return (d + m).substr(0, t); var A = c - d.length; return (d + a(m, A)).substr(0, c + i) } else d += m } if (u.scheme && u.host) { var C = u.scheme + "://"; if ((d + C).length < c) return (C + d).substr(0, t) } if (d.length <= t) return d; var x = ""; return c > 0 && (x = d.substr(-1 * Math.floor(c / 2))), (d.substr(0, Math.ceil(c / 2)) + n + x).substr(0, c + i) } function nue(e, t, n) { if (e.length <= t) return e; var i, o; n == null ? (n = "&hellip;", i = 8, o = 3) : (i = n.length, o = n.length); var r = t - o, s = ""; return r > 0 && (s = e.substr(-1 * Math.floor(r / 2))), (e.substr(0, Math.ceil(r / 2)) + n + s).substr(0, r + i) } function iue(e, t, n) { return $le(e, t, n) } var lW = function () { function e(t) { t === void 0 && (t = {}), this.newWindow = !1, this.truncate = {}, this.className = "", this.newWindow = t.newWindow || !1, this.truncate = t.truncate || {}, this.className = t.className || "" } return e.prototype.build = function (t) { return new pD({ tagName: "a", attrs: this.createAttrs(t), innerHtml: this.processAnchorText(t.getAnchorText()) }) }, e.prototype.createAttrs = function (t) { var n = { href: t.getAnchorHref() }, i = this.createCssClass(t); return i && (n.class = i), this.newWindow && (n.target = "_blank", n.rel = "noopener noreferrer"), this.truncate && this.truncate.length && this.truncate.length < t.getAnchorText().length && (n.title = t.getAnchorHref()), n }, e.prototype.createCssClass = function (t) { var n = this.className; if (n) { for (var i = [n], o = t.getCssClassSuffixes(), r = 0, s = o.length; r < s; r++)i.push(n + "-" + o[r]); return i.join(" ") } else return "" }, e.prototype.processAnchorText = function (t) { return t = this.doTruncate(t), t }, e.prototype.doTruncate = function (t) { var n = this.truncate; if (!n || !n.length) return t; var i = n.length, o = n.location; return o === "smart" ? tue(t, i) : o === "middle" ? nue(t, i) : iue(t, i) }, e }(); var Hu = function () { function e(t) { this.__jsduckDummyDocProp = null, this.matchedText = "", this.offset = 0, this.tagBuilder = t.tagBuilder, this.matchedText = t.matchedText, this.offset = t.offset } return e.prototype.getMatchedText = function () { return this.matchedText }, e.prototype.setOffset = function (t) { this.offset = t }, e.prototype.getOffset = function () { return this.offset }, e.prototype.getCssClassSuffixes = function () { return [this.getType()] }, e.prototype.buildTag = function () { return this.tagBuilder.build(this) }, e }(); var wue = po(Sue(), 1), { __extends: es, __assign: Rr, __rest: h4n, __decorate: m4n, __param: p4n, __metadata: _4n, __awaiter: g4n, __generator: y4n, __exportStar: A4n, __createBinding: C4n, __values: x4n, __read: T4n, __spread: E4n, __spreadArrays: b4n, __spreadArray: S4n, __await: w4n, __asyncGenerator: D4n, __asyncDelegator: v4n, __asyncValues: P4n, __makeTemplateObject: I4n, __importStar: O4n, __importDefault: B4n, __classPrivateFieldGet: R4n, __classPrivateFieldSet: M4n, __classPrivateFieldIn: L4n } = wue.default; var G2 = function (e) { es(t, e); function t(n) { var i = e.call(this, n) || this; return i.email = "", i.email = n.email, i } return t.prototype.getType = function () { return "email" }, t.prototype.getEmail = function () { return this.email }, t.prototype.getAnchorHref = function () { return "mailto:" + this.email }, t.prototype.getAnchorText = function () { return this.email }, t }(Hu); var W2 = function (e) { es(t, e); function t(n) { var i = e.call(this, n) || this; return i.serviceName = "", i.hashtag = "", i.serviceName = n.serviceName, i.hashtag = n.hashtag, i } return t.prototype.getType = function () { return "hashtag" }, t.prototype.getServiceName = function () { return this.serviceName }, t.prototype.getHashtag = function () { return this.hashtag }, t.prototype.getAnchorHref = function () { var n = this.serviceName, i = this.hashtag; switch (n) { case "twitter": return "https://twitter.com/hashtag/" + i; case "facebook": return "https://www.facebook.com/hashtag/" + i; case "instagram": return "https://instagram.com/explore/tags/" + i; case "tiktok": return "https://www.tiktok.com/tag/" + i; default: throw new Error("Unknown service name to point hashtag to: " + n) } }, t.prototype.getAnchorText = function () { return "#" + this.hashtag }, t }(Hu); var j2 = function (e) { es(t, e); function t(n) { var i = e.call(this, n) || this; return i.serviceName = "twitter", i.mention = "", i.mention = n.mention, i.serviceName = n.serviceName, i } return t.prototype.getType = function () { return "mention" }, t.prototype.getMention = function () { return this.mention }, t.prototype.getServiceName = function () { return this.serviceName }, t.prototype.getAnchorHref = function () { switch (this.serviceName) { case "twitter": return "https://twitter.com/" + this.mention; case "instagram": return "https://instagram.com/" + this.mention; case "soundcloud": return "https://soundcloud.com/" + this.mention; case "tiktok": return "https://www.tiktok.com/@" + this.mention; default: throw new Error("Unknown service name to point mention to: " + this.serviceName) } }, t.prototype.getAnchorText = function () { return "@" + this.mention }, t.prototype.getCssClassSuffixes = function () { var n = e.prototype.getCssClassSuffixes.call(this), i = this.getServiceName(); return i && n.push(i), n }, t }(Hu); var q2 = function (e) { es(t, e); function t(n) { var i = e.call(this, n) || this; return i.number = "", i.plusSign = !1, i.number = n.number, i.plusSign = n.plusSign, i } return t.prototype.getType = function () { return "phone" }, t.prototype.getPhoneNumber = function () { return this.number }, t.prototype.getNumber = function () { return this.getPhoneNumber() }, t.prototype.getAnchorHref = function () { return "tel:" + (this.plusSign ? "+" : "") + this.number }, t.prototype.getAnchorText = function () { return this.matchedText }, t }(Hu); var Y2 = function (e) { es(t, e); function t(n) { var i = e.call(this, n) || this; return i.url = "", i.urlMatchType = "scheme", i.protocolUrlMatch = !1, i.protocolRelativeMatch = !1, i.stripPrefix = { scheme: !0, www: !0 }, i.stripTrailingSlash = !0, i.decodePercentEncoding = !0, i.schemePrefixRegex = /^(https?:\/\/)?/i, i.wwwPrefixRegex = /^(https?:\/\/)?(www\.)?/i, i.protocolRelativeRegex = /^\/\//, i.protocolPrepended = !1, i.urlMatchType = n.urlMatchType, i.url = n.url, i.protocolUrlMatch = n.protocolUrlMatch, i.protocolRelativeMatch = n.protocolRelativeMatch, i.stripPrefix = n.stripPrefix, i.stripTrailingSlash = n.stripTrailingSlash, i.decodePercentEncoding = n.decodePercentEncoding, i } return t.prototype.getType = function () { return "url" }, t.prototype.getUrlMatchType = function () { return this.urlMatchType }, t.prototype.getUrl = function () { var n = this.url; return !this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended && (n = this.url = "http://" + n, this.protocolPrepended = !0), n }, t.prototype.getAnchorHref = function () { var n = this.getUrl(); return n.replace(/&amp;/g, "&") }, t.prototype.getAnchorText = function () { var n = this.getMatchedText(); return this.protocolRelativeMatch && (n = this.stripProtocolRelativePrefix(n)), this.stripPrefix.scheme && (n = this.stripSchemePrefix(n)), this.stripPrefix.www && (n = this.stripWwwPrefix(n)), this.stripTrailingSlash && (n = this.removeTrailingSlash(n)), this.decodePercentEncoding && (n = this.removePercentEncoding(n)), n }, t.prototype.stripSchemePrefix = function (n) { return n.replace(this.schemePrefixRegex, "") }, t.prototype.stripWwwPrefix = function (n) { return n.replace(this.wwwPrefixRegex, "$1") }, t.prototype.stripProtocolRelativePrefix = function (n) { return n.replace(this.protocolRelativeRegex, "") }, t.prototype.removeTrailingSlash = function (n) { return n.charAt(n.length - 1) === "/" && (n = n.slice(0, -1)), n }, t.prototype.removePercentEncoding = function (n) { var i = n.replace(/%22/gi, "&quot;").replace(/%26/gi, "&amp;").replace(/%27/gi, "&#39;").replace(/%3C/gi, "&lt;").replace(/%3E/gi, "&gt;"); try { return decodeURIComponent(i) } catch { return i } }, t }(Hu); var Gu = function () { function e(t) { this.__jsduckDummyDocProp = null, this.tagBuilder = t.tagBuilder } return e }(); var K2 = /[A-Za-z]/, vue = /[\d]/, Pue = /[\D]/, yg = /\s/, J2 = /['"]/, Iue = /[\x00-\x1F\x7F]/, fW = /A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC/.source, bYe = /\u2700-\u27bf\udde6-\uddff\ud800-\udbff\udc00-\udfff\ufe0e\ufe0f\u0300-\u036f\ufe20-\ufe23\u20d0-\u20f0\ud83c\udffb-\udfff\u200d\u3299\u3297\u303d\u3030\u24c2\ud83c\udd70-\udd71\udd7e-\udd7f\udd8e\udd91-\udd9a\udde6-\uddff\ude01-\ude02\ude1a\ude2f\ude32-\ude3a\ude50-\ude51\u203c\u2049\u25aa-\u25ab\u25b6\u25c0\u25fb-\u25fe\u00a9\u00ae\u2122\u2139\udc04\u2600-\u26FF\u2b05\u2b06\u2b07\u2b1b\u2b1c\u2b50\u2b55\u231a\u231b\u2328\u23cf\u23e9-\u23f3\u23f8-\u23fa\udccf\u2935\u2934\u2190-\u21ff/.source, SYe = /\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F/.source, Oue = fW + bYe + SYe, X2 = /0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19/.source, Bue = Oue + X2, Eo = Oue + X2, XT = new RegExp("[".concat(Eo, "]")), wYe = "(?:[" + X2 + "]{1,3}\\.){3}[" + X2 + "]{1,3}", DYe = "[" + Eo + "](?:[" + Eo + "\\-_]{0,61}[" + Eo + "])?", Due = function (e) { return "(?=(" + DYe + "))\\" + e }, Z2 = function (e) { return "(?:" + Due(e) + "(?:\\." + Due(e + 1) + "){0,126}|" + wYe + ")" }, $4n = new RegExp("[" + Eo + ".\\-]*[" + Eo + "\\-]"), _D = XT; var Q2 = /(?:xn--vermgensberatung-pwb|xn--vermgensberater-ctb|xn--clchc0ea0b2g2a9gcd|xn--w4r85el8fhu5dnra|northwesternmutual|travelersinsurance|vermögensberatung|xn--5su34j936bgsg|xn--bck1b9a5dre4c|xn--mgbah1a3hjkrd|xn--mgbai9azgqp6j|xn--mgberp4a5d4ar|xn--xkc2dl3a5ee0h|vermögensberater|xn--fzys8d69uvgm|xn--mgba7c0bbn0a|xn--mgbcpq6gpa1a|xn--xkc2al3hye2a|americanexpress|kerryproperties|sandvikcoromant|xn--i1b6b1a6a2e|xn--kcrx77d1x4a|xn--lgbbat1ad8j|xn--mgba3a4f16a|xn--mgbaakc7dvf|xn--mgbc0a9azcg|xn--nqv7fs00ema|americanfamily|bananarepublic|cancerresearch|cookingchannel|kerrylogistics|weatherchannel|xn--54b7fta0cc|xn--6qq986b3xl|xn--80aqecdr1a|xn--b4w605ferd|xn--fiq228c5hs|xn--h2breg3eve|xn--jlq480n2rg|xn--jlq61u9w7b|xn--mgba3a3ejt|xn--mgbaam7a8h|xn--mgbayh7gpa|xn--mgbbh1a71e|xn--mgbca7dzdo|xn--mgbi4ecexp|xn--mgbx4cd0ab|xn--rvc1e0am3e|international|lifeinsurance|travelchannel|wolterskluwer|xn--cckwcxetd|xn--eckvdtc9d|xn--fpcrj9c3d|xn--fzc2c9e2c|xn--h2brj9c8c|xn--tiq49xqyj|xn--yfro4i67o|xn--ygbi2ammx|construction|lplfinancial|scholarships|versicherung|xn--3e0b707e|xn--45br5cyl|xn--4dbrk0ce|xn--80adxhks|xn--80asehdb|xn--8y0a063a|xn--gckr3f0f|xn--mgb9awbf|xn--mgbab2bd|xn--mgbgu82a|xn--mgbpl2fh|xn--mgbt3dhd|xn--mk1bu44c|xn--ngbc5azd|xn--ngbe9e0a|xn--ogbpf8fl|xn--qcka1pmc|accountants|barclaycard|blackfriday|blockbuster|bridgestone|calvinklein|contractors|creditunion|engineering|enterprises|foodnetwork|investments|kerryhotels|lamborghini|motorcycles|olayangroup|photography|playstation|productions|progressive|redumbrella|williamhill|xn--11b4c3d|xn--1ck2e1b|xn--1qqw23a|xn--2scrj9c|xn--3bst00m|xn--3ds443g|xn--3hcrj9c|xn--42c2d9a|xn--45brj9c|xn--55qw42g|xn--6frz82g|xn--80ao21a|xn--9krt00a|xn--cck2b3b|xn--czr694b|xn--d1acj3b|xn--efvy88h|xn--fct429k|xn--fjq720a|xn--flw351e|xn--g2xx48c|xn--gecrj9c|xn--gk3at1e|xn--h2brj9c|xn--hxt814e|xn--imr513n|xn--j6w193g|xn--jvr189m|xn--kprw13d|xn--kpry57d|xn--mgbbh1a|xn--mgbtx2b|xn--mix891f|xn--nyqy26a|xn--otu796d|xn--pgbs0dh|xn--q9jyb4c|xn--rhqv96g|xn--rovu88b|xn--s9brj9c|xn--ses554g|xn--t60b56a|xn--vuq861b|xn--w4rs40l|xn--xhq521b|xn--zfr164b|சிங்கப்பூர்|accountant|apartments|associates|basketball|bnpparibas|boehringer|capitalone|consulting|creditcard|cuisinella|eurovision|extraspace|foundation|healthcare|immobilien|industries|management|mitsubishi|nextdirect|properties|protection|prudential|realestate|republican|restaurant|schaeffler|tatamotors|technology|university|vlaanderen|volkswagen|xn--30rr7y|xn--3pxu8k|xn--45q11c|xn--4gbrim|xn--55qx5d|xn--5tzm5g|xn--80aswg|xn--90a3ac|xn--9dbq2a|xn--9et52u|xn--c2br7g|xn--cg4bki|xn--czrs0t|xn--czru2d|xn--fiq64b|xn--fiqs8s|xn--fiqz9s|xn--io0a7i|xn--kput3i|xn--mxtq1m|xn--o3cw4h|xn--pssy2u|xn--q7ce6a|xn--unup4y|xn--wgbh1c|xn--wgbl6a|xn--y9a3aq|accenture|alfaromeo|allfinanz|amsterdam|analytics|aquarelle|barcelona|bloomberg|christmas|community|directory|education|equipment|fairwinds|financial|firestone|fresenius|frontdoor|furniture|goldpoint|hisamitsu|homedepot|homegoods|homesense|institute|insurance|kuokgroup|lancaster|landrover|lifestyle|marketing|marshalls|melbourne|microsoft|panasonic|passagens|pramerica|richardli|shangrila|solutions|statebank|statefarm|stockholm|travelers|vacations|xn--90ais|xn--c1avg|xn--d1alf|xn--e1a4c|xn--fhbei|xn--j1aef|xn--j1amh|xn--l1acc|xn--ngbrx|xn--nqv7f|xn--p1acf|xn--qxa6a|xn--tckwe|xn--vhquv|yodobashi|موريتانيا|abudhabi|airforce|allstate|attorney|barclays|barefoot|bargains|baseball|boutique|bradesco|broadway|brussels|builders|business|capetown|catering|catholic|cipriani|cityeats|cleaning|clinique|clothing|commbank|computer|delivery|deloitte|democrat|diamonds|discount|discover|download|engineer|ericsson|etisalat|exchange|feedback|fidelity|firmdale|football|frontier|goodyear|grainger|graphics|guardian|hdfcbank|helsinki|holdings|hospital|infiniti|ipiranga|istanbul|jpmorgan|lighting|lundbeck|marriott|maserati|mckinsey|memorial|merckmsd|mortgage|observer|partners|pharmacy|pictures|plumbing|property|redstone|reliance|saarland|samsclub|security|services|shopping|showtime|softbank|software|stcgroup|supplies|training|vanguard|ventures|verisign|woodside|xn--90ae|xn--node|xn--p1ai|xn--qxam|yokohama|السعودية|abogado|academy|agakhan|alibaba|android|athleta|auction|audible|auspost|avianca|banamex|bauhaus|bentley|bestbuy|booking|brother|bugatti|capital|caravan|careers|channel|charity|chintai|citadel|clubmed|college|cologne|comcast|company|compare|contact|cooking|corsica|country|coupons|courses|cricket|cruises|dentist|digital|domains|exposed|express|farmers|fashion|ferrari|ferrero|finance|fishing|fitness|flights|florist|flowers|forsale|frogans|fujitsu|gallery|genting|godaddy|grocery|guitars|hamburg|hangout|hitachi|holiday|hosting|hoteles|hotmail|hyundai|ismaili|jewelry|juniper|kitchen|komatsu|lacaixa|lanxess|lasalle|latrobe|leclerc|limited|lincoln|markets|monster|netbank|netflix|network|neustar|okinawa|oldnavy|organic|origins|philips|pioneer|politie|realtor|recipes|rentals|reviews|rexroth|samsung|sandvik|schmidt|schwarz|science|shiksha|singles|staples|storage|support|surgery|systems|temasek|theater|theatre|tickets|tiffany|toshiba|trading|walmart|wanggou|watches|weather|website|wedding|whoswho|windows|winners|xfinity|yamaxun|youtube|zuerich|католик|اتصالات|البحرين|الجزائر|العليان|پاکستان|كاثوليك|இந்தியா|abarth|abbott|abbvie|africa|agency|airbus|airtel|alipay|alsace|alstom|amazon|anquan|aramco|author|bayern|beauty|berlin|bharti|bostik|boston|broker|camera|career|casino|center|chanel|chrome|church|circle|claims|clinic|coffee|comsec|condos|coupon|credit|cruise|dating|datsun|dealer|degree|dental|design|direct|doctor|dunlop|dupont|durban|emerck|energy|estate|events|expert|family|flickr|futbol|gallup|garden|george|giving|global|google|gratis|health|hermes|hiphop|hockey|hotels|hughes|imamat|insure|intuit|jaguar|joburg|juegos|kaufen|kinder|kindle|kosher|lancia|latino|lawyer|lefrak|living|locker|london|luxury|madrid|maison|makeup|market|mattel|mobile|monash|mormon|moscow|museum|mutual|nagoya|natura|nissan|nissay|norton|nowruz|office|olayan|online|oracle|orange|otsuka|pfizer|photos|physio|pictet|quebec|racing|realty|reisen|repair|report|review|rocher|rogers|ryukyu|safety|sakura|sanofi|school|schule|search|secure|select|shouji|soccer|social|stream|studio|supply|suzuki|swatch|sydney|taipei|taobao|target|tattoo|tennis|tienda|tjmaxx|tkmaxx|toyota|travel|unicom|viajes|viking|villas|virgin|vision|voting|voyage|vuelos|walter|webcam|xihuan|yachts|yandex|zappos|москва|онлайн|ابوظبي|ارامكو|الاردن|المغرب|امارات|فلسطين|مليسيا|भारतम्|இலங்கை|ファッション|actor|adult|aetna|amfam|amica|apple|archi|audio|autos|azure|baidu|beats|bible|bingo|black|boats|bosch|build|canon|cards|chase|cheap|cisco|citic|click|cloud|coach|codes|crown|cymru|dabur|dance|deals|delta|drive|dubai|earth|edeka|email|epson|faith|fedex|final|forex|forum|gallo|games|gifts|gives|glass|globo|gmail|green|gripe|group|gucci|guide|homes|honda|horse|house|hyatt|ikano|irish|jetzt|koeln|kyoto|lamer|lease|legal|lexus|lilly|linde|lipsy|loans|locus|lotte|lotto|macys|mango|media|miami|money|movie|music|nexus|nikon|ninja|nokia|nowtv|omega|osaka|paris|parts|party|phone|photo|pizza|place|poker|praxi|press|prime|promo|quest|radio|rehab|reise|ricoh|rocks|rodeo|rugby|salon|sener|seven|sharp|shell|shoes|skype|sling|smart|smile|solar|space|sport|stada|store|study|style|sucks|swiss|tatar|tires|tirol|tmall|today|tokyo|tools|toray|total|tours|trade|trust|tunes|tushu|ubank|vegas|video|vodka|volvo|wales|watch|weber|weibo|works|world|xerox|yahoo|ישראל|ایران|بازار|بھارت|سودان|سورية|همراه|भारोत|संगठन|বাংলা|భారత్|ഭാരതം|嘉里大酒店|aarp|able|adac|aero|akdn|ally|amex|arab|army|arpa|arte|asda|asia|audi|auto|baby|band|bank|bbva|beer|best|bike|bing|blog|blue|bofa|bond|book|buzz|cafe|call|camp|care|cars|casa|case|cash|cbre|cern|chat|citi|city|club|cool|coop|cyou|data|date|dclk|deal|dell|desi|diet|dish|docs|dvag|erni|fage|fail|fans|farm|fast|fiat|fido|film|fire|fish|flir|food|ford|free|fund|game|gbiz|gent|ggee|gift|gmbh|gold|golf|goog|guge|guru|hair|haus|hdfc|help|here|hgtv|host|hsbc|icbc|ieee|imdb|immo|info|itau|java|jeep|jobs|jprs|kddi|kids|kiwi|kpmg|kred|land|lego|lgbt|lidl|life|like|limo|link|live|loan|loft|love|ltda|luxe|maif|meet|meme|menu|mini|mint|mobi|moda|moto|name|navy|news|next|nico|nike|ollo|open|page|pars|pccw|pics|ping|pink|play|plus|pohl|porn|post|prod|prof|qpon|read|reit|rent|rest|rich|room|rsvp|ruhr|safe|sale|sarl|save|saxo|scot|seat|seek|sexy|shaw|shia|shop|show|silk|sina|site|skin|sncf|sohu|song|sony|spot|star|surf|talk|taxi|team|tech|teva|tiaa|tips|town|toys|tube|vana|visa|viva|vivo|vote|voto|wang|weir|wien|wiki|wine|work|xbox|yoga|zara|zero|zone|дети|сайт|بارت|بيتك|ڀارت|تونس|شبكة|عراق|عمان|موقع|भारत|ভারত|ভাৰত|ਭਾਰਤ|ભારત|ଭାରତ|ಭಾರತ|ලංකා|アマゾン|グーグル|クラウド|ポイント|组织机构|電訊盈科|香格里拉|aaa|abb|abc|aco|ads|aeg|afl|aig|anz|aol|app|art|aws|axa|bar|bbc|bbt|bcg|bcn|bet|bid|bio|biz|bms|bmw|bom|boo|bot|box|buy|bzh|cab|cal|cam|car|cat|cba|cbn|cbs|ceo|cfa|cfd|com|cpa|crs|dad|day|dds|dev|dhl|diy|dnp|dog|dot|dtv|dvr|eat|eco|edu|esq|eus|fan|fit|fly|foo|fox|frl|ftr|fun|fyi|gal|gap|gay|gdn|gea|gle|gmo|gmx|goo|gop|got|gov|hbo|hiv|hkt|hot|how|ibm|ice|icu|ifm|inc|ing|ink|int|ist|itv|jcb|jio|jll|jmp|jnj|jot|joy|kfh|kia|kim|kpn|krd|lat|law|lds|llc|llp|lol|lpl|ltd|man|map|mba|med|men|mil|mit|mlb|mls|mma|moe|moi|mom|mov|msd|mtn|mtr|nab|nba|nec|net|new|nfl|ngo|nhk|now|nra|nrw|ntt|nyc|obi|one|ong|onl|ooo|org|ott|ovh|pay|pet|phd|pid|pin|pnc|pro|pru|pub|pwc|red|ren|ril|rio|rip|run|rwe|sap|sas|sbi|sbs|sca|scb|ses|sew|sex|sfr|ski|sky|soy|spa|srl|stc|tab|tax|tci|tdk|tel|thd|tjx|top|trv|tui|tvs|ubs|uno|uol|ups|vet|vig|vin|vip|wed|win|wme|wow|wtc|wtf|xin|xxx|xyz|you|yun|zip|бел|ком|қаз|мкд|мон|орг|рус|срб|укр|հայ|קום|عرب|قطر|كوم|مصر|कॉम|नेट|คอม|ไทย|ລາວ|ストア|セール|みんな|中文网|亚马逊|天主教|我爱你|新加坡|淡马锡|诺基亚|飞利浦|ac|ad|ae|af|ag|ai|al|am|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|ss|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw|ελ|ευ|бг|ею|рф|გე|닷넷|닷컴|삼성|한국|コム|世界|中信|中国|中國|企业|佛山|信息|健康|八卦|公司|公益|台湾|台灣|商城|商店|商标|嘉里|在线|大拿|娱乐|家電|广东|微博|慈善|手机|招聘|政务|政府|新闻|时尚|書籍|机构|游戏|澳門|点看|移动|网址|网店|网站|网络|联通|谷歌|购物|通販|集团|食品|餐厅|香港)/; var vYe = new RegExp("[".concat(Eo, "!#$%&'*+/=?^_`{|}~-]")), PYe = new RegExp("^".concat(Q2.source, "$")), dW = function (e) { es(t, e); function t() { var n = e !== null && e.apply(this, arguments) || this; return n.localPartCharRegex = vYe, n.strictTldRegex = PYe, n } return t.prototype.parseMatches = function (n) { for (var i = this.tagBuilder, o = this.localPartCharRegex, r = this.strictTldRegex, s = [], a = n.length, c = new $2, u = { m: "a", a: "i", i: "l", l: "t", t: "o", o: ":" }, f = 0, d = 0, p = c; f < a;) { var g = n.charAt(f); switch (d) { case 0: m(g); break; case 1: A(n.charAt(f - 1), g); break; case 2: C(g); break; case 3: x(g); break; case 4: T(g); break; case 5: b(g); break; case 6: S(g); break; case 7: D(g); break; default: qT(d) }f++ } return R(), s; function m(M) { M === "m" ? P(1) : o.test(M) && P() } function A(M, L) { M === ":" ? o.test(L) ? (d = 2, p = new $2(Rr(Rr({}, p), { hasMailtoPrefix: !0 }))) : B() : u[M] === L || (o.test(L) ? d = 2 : L === "." ? d = 3 : L === "@" ? d = 4 : B()) } function C(M) { M === "." ? d = 3 : M === "@" ? d = 4 : o.test(M) || B() } function x(M) { M === "." || M === "@" ? B() : o.test(M) ? d = 2 : B() } function T(M) { _D.test(M) ? d = 5 : B() } function b(M) { M === "." ? d = 7 : M === "-" ? d = 6 : _D.test(M) || R() } function S(M) { M === "-" || M === "." ? R() : _D.test(M) ? d = 5 : R() } function D(M) { M === "." || M === "-" ? R() : _D.test(M) ? (d = 5, p = new $2(Rr(Rr({}, p), { hasDomainDot: !0 }))) : R() } function P(M) { M === void 0 && (M = 2), d = M, p = new $2({ idx: f }) } function B() { d = 0, p = c } function R() { if (p.hasDomainDot) { var M = n.slice(p.idx, f); /[-.]$/.test(M) && (M = M.slice(0, -1)); var L = p.hasMailtoPrefix ? M.slice(7) : M; _(L) && s.push(new G2({ tagBuilder: i, matchedText: M, offset: p.idx, email: L })) } B(); function _(E) { var w = E.split(".").pop() || "", v = w.toLowerCase(), O = r.test(v); return O } } }, t }(Gu); var $2 = function () { function e(t) { t === void 0 && (t = {}), this.idx = t.idx !== void 0 ? t.idx : -1, this.hasMailtoPrefix = !!t.hasMailtoPrefix, this.hasDomainDot = !!t.hasDomainDot } return e }(); var Rue = function () { function e() { } return e.isValid = function (t, n) { return !(n && !this.isValidUriScheme(n) || this.urlMatchDoesNotHaveProtocolOrDot(t, n) || this.urlMatchDoesNotHaveAtLeastOneWordChar(t, n) && !this.isValidIpAddress(t) || this.containsMultipleDots(t)) }, e.isValidIpAddress = function (t) { var n = new RegExp(this.hasFullProtocolRegex.source + this.ipRegex.source), i = t.match(n); return i !== null }, e.containsMultipleDots = function (t) { var n = t; return this.hasFullProtocolRegex.test(t) && (n = t.split("://")[1]), n.split("/")[0].indexOf("..") > -1 }, e.isValidUriScheme = function (t) { var n = t.match(this.uriSchemeRegex), i = n && n[0].toLowerCase(); return i !== "javascript:" && i !== "vbscript:" }, e.urlMatchDoesNotHaveProtocolOrDot = function (t, n) { return !!t && (!n || !this.hasFullProtocolRegex.test(n)) && t.indexOf(".") === -1 }, e.urlMatchDoesNotHaveAtLeastOneWordChar = function (t, n) { return t && n ? !this.hasFullProtocolRegex.test(n) && !this.hasWordCharAfterProtocolRegex.test(t) : !1 }, e.hasFullProtocolRegex = /^[A-Za-z][-.+A-Za-z0-9]*:\/\//, e.uriSchemeRegex = /^[A-Za-z][-.+A-Za-z0-9]*:/, e.hasWordCharAfterProtocolRegex = new RegExp(":[^\\s]*?[" + fW + "]"), e.ipRegex = /[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?(:[0-9]*)?\/?$/, e }(); var IYe = function () { var e = /(?:[A-Za-z][-.+A-Za-z0-9]{0,63}:(?![A-Za-z][-.+A-Za-z0-9]{0,63}:\/\/)(?!\d+\/?)(?:\/\/)?)/, t = /(?:www\.)/, n = new RegExp("[/?#](?:[" + Eo + "\\-+&@#/%=~_()|'$*\\[\\]{}?!:,.;^\u2713]*[" + Eo + "\\-+&@#/%=~_()|'$*\\[\\]{}\u2713])?"); return new RegExp(["(?:", "(", e.source, Z2(2), ")", "|", "(", "(//)?", t.source, Z2(6), ")", "|", "(", "(//)?", Z2(10) + "\\.", Q2.source, "(?![-" + Bue + "])", ")", ")", "(?::[0-9]+)?", "(?:" + n.source + ")?"].join(""), "gi") }(), OYe = new RegExp("[" + Eo + "]"), hW = function (e) { es(t, e); function t(n) { var i = e.call(this, n) || this; return i.stripPrefix = { scheme: !0, www: !0 }, i.stripTrailingSlash = !0, i.decodePercentEncoding = !0, i.matcherRegex = IYe, i.wordCharRegExp = OYe, i.stripPrefix = n.stripPrefix, i.stripTrailingSlash = n.stripTrailingSlash, i.decodePercentEncoding = n.decodePercentEncoding, i } return t.prototype.parseMatches = function (n) { for (var i = this.matcherRegex, o = this.stripPrefix, r = this.stripTrailingSlash, s = this.decodePercentEncoding, a = this.tagBuilder, c = [], u, f = function () { var p = u[0], g = u[1], m = u[4], A = u[5], C = u[9], x = u.index, T = A || C, b = n.charAt(x - 1); if (!Rue.isValid(p, g) || x > 0 && b === "@" || x > 0 && T && d.wordCharRegExp.test(b)) return "continue"; if (/\?$/.test(p) && (p = p.substr(0, p.length - 1)), d.matchHasUnbalancedClosingParen(p)) p = p.substr(0, p.length - 1); else { var S = d.matchHasInvalidCharAfterTld(p, g); S > -1 && (p = p.substr(0, S)) } var D = ["http://", "https://"].find(function (M) { return !!g && g.indexOf(M) !== -1 }); if (D) { var P = p.indexOf(D); p = p.substr(P), g = g.substr(P), x = x + P } var B = g ? "scheme" : m ? "www" : "tld", R = !!g; c.push(new Y2({ tagBuilder: a, matchedText: p, offset: x, urlMatchType: B, url: p, protocolUrlMatch: R, protocolRelativeMatch: !!T, stripPrefix: o, stripTrailingSlash: r, decodePercentEncoding: s })) }, d = this; (u = i.exec(n)) !== null;)f(); return c }, t.prototype.matchHasUnbalancedClosingParen = function (n) { var i = n.charAt(n.length - 1), o; if (i === ")") o = "("; else if (i === "]") o = "["; else if (i === "}") o = "{"; else return !1; for (var r = 0, s = 0, a = n.length - 1; s < a; s++) { var c = n.charAt(s); c === o ? r++ : c === i && (r = Math.max(r - 1, 0)) } return r === 0 }, t.prototype.matchHasInvalidCharAfterTld = function (n, i) { if (!n) return -1; var o = 0; i && (o = n.indexOf(":"), n = n.slice(o)); var r = new RegExp("^((.?//)?[-." + Eo + "]*[-" + Eo + "]\\.[-" + Eo + "]+)"), s = r.exec(n); return s === null ? -1 : (o += s[1].length, n = n.slice(s[1].length), /^[^-.A-Za-z0-9:\/?#]/.test(n) ? o : -1) }, t }(Gu); var Mue = new RegExp("[_".concat(Eo, "]")), mW = function (e) { es(t, e); function t(n) { var i = e.call(this, n) || this; return i.serviceName = "twitter", i.serviceName = n.serviceName, i } return t.prototype.parseMatches = function (n) { for (var i = this.tagBuilder, o = this.serviceName, r = [], s = n.length, a = 0, c = -1, u = 0; a < s;) { var f = n.charAt(a); switch (u) { case 0: d(f); break; case 1: p(f); break; case 2: g(f); break; case 3: m(f); break; default: qT(u) }a++ } return A(), r; function d(C) { C === "#" ? (u = 2, c = a) : XT.test(C) && (u = 1) } function p(C) { XT.test(C) || (u = 0) } function g(C) { Mue.test(C) ? u = 3 : XT.test(C) ? u = 1 : u = 0 } function m(C) { Mue.test(C) || (A(), c = -1, XT.test(C) ? u = 1 : u = 0) } function A() { if (c > -1 && a - c <= 140) { var C = n.slice(c, a), x = new W2({ tagBuilder: i, matchedText: C, offset: c, serviceName: o, hashtag: C.slice(1) }); r.push(x) } } }, t }(Gu); var Lue = ["twitter", "facebook", "instagram", "tiktok"]; var BYe = /(?:(?:(?:(\+)?\d{1,3}[-\040.]?)?\(?\d{3}\)?[-\040.]?\d{3}[-\040.]?\d{4})|(?:(\+)(?:9[976]\d|8[987530]\d|6[987]\d|5[90]\d|42\d|3[875]\d|2[98654321]\d|9[8543210]|8[6421]|6[6543210]|5[87654321]|4[987654310]|3[9643210]|2[70]|7|1)[-\040.]?(?:\d[-\040.]?){6,12}\d+))([,;]+[0-9]+#?)*/, RYe = /(0([1-9]{1}-?[1-9]\d{3}|[1-9]{2}-?\d{3}|[1-9]{2}\d{1}-?\d{2}|[1-9]{2}\d{2}-?\d{1})-?\d{4}|0[789]0-?\d{4}-?\d{4}|050-?\d{4}-?\d{4})/, MYe = new RegExp("".concat(BYe.source, "|").concat(RYe.source), "g"), pW = function (e) { es(t, e); function t() { var n = e !== null && e.apply(this, arguments) || this; return n.matcherRegex = MYe, n } return t.prototype.parseMatches = function (n) { for (var i = this.matcherRegex, o = this.tagBuilder, r = [], s; (s = i.exec(n)) !== null;) { var a = s[0], c = a.replace(/[^0-9,;#]/g, ""), u = !!(s[1] || s[2]), f = s.index == 0 ? "" : n.substr(s.index - 1, 1), d = n.substr(s.index + a.length, 1), p = !f.match(/\d/) && !d.match(/\d/); this.testMatch(s[3]) && this.testMatch(a) && p && r.push(new q2({ tagBuilder: o, matchedText: a, offset: s.index, number: c, plusSign: u })) } return r }, t.prototype.testMatch = function (n) { return Pue.test(n) }, t }(Gu); var LYe = new RegExp("@[_".concat(Eo, "]{1,50}(?![_").concat(Eo, "])"), "g"), FYe = new RegExp("@[_.".concat(Eo, "]{1,30}(?![_").concat(Eo, "])"), "g"), NYe = new RegExp("@[-_.".concat(Eo, "]{1,50}(?![-_").concat(Eo, "])"), "g"), VYe = new RegExp("@[_.".concat(Eo, "]{1,23}[_").concat(Eo, "](?![_").concat(Eo, "])"), "g"), kYe = new RegExp("[^" + Eo + "]"), _W = function (e) { es(t, e); function t(n) { var i = e.call(this, n) || this; return i.serviceName = "twitter", i.matcherRegexes = { twitter: LYe, instagram: FYe, soundcloud: NYe, tiktok: VYe }, i.nonWordCharRegex = kYe, i.serviceName = n.serviceName, i } return t.prototype.parseMatches = function (n) { var i = this.serviceName, o = this.matcherRegexes[this.serviceName], r = this.nonWordCharRegex, s = this.tagBuilder, a = [], c; if (!o) return a; for (; (c = o.exec(n)) !== null;) { var u = c.index, f = n.charAt(u - 1); if (u === 0 || r.test(f)) { var d = c[0].replace(/\.+$/g, ""), p = d.slice(1); a.push(new j2({ tagBuilder: s, matchedText: d, offset: u, serviceName: i, mention: p })) } } return a }, t }(Gu); function Fue(e, t) { for (var n = t.onOpenTag, i = t.onCloseTag, o = t.onText, r = t.onComment, s = t.onDoctype, a = new Ah, c = 0, u = e.length, f = 0, d = 0, p = a; c < u;) { var g = e.charAt(c); switch (f) { case 0: m(g); break; case 1: A(g); break; case 2: x(g); break; case 3: C(g); break; case 4: T(g); break; case 5: b(g); break; case 6: S(g); break; case 7: D(g); break; case 8: P(g); break; case 9: B(g); break; case 10: R(g); break; case 11: M(g); break; case 12: L(g); break; case 13: _(g); break; case 14: E(g); break; case 15: w(g); break; case 16: v(g); break; case 17: O(g); break; case 18: V(g); break; case 19: z(g); break; case 20: k(g); break; default: qT(f) }c++ } d < c && q(); function m(K) { K === "<" && N() } function A(K) { K === "!" ? f = 13 : K === "/" ? (f = 2, p = new Ah(Rr(Rr({}, p), { isClosing: !0 }))) : K === "<" ? N() : K2.test(K) ? (f = 3, p = new Ah(Rr(Rr({}, p), { isOpening: !0 }))) : (f = 0, p = a) } function C(K) { yg.test(K) ? (p = new Ah(Rr(Rr({}, p), { name: J() })), f = 4) : K === "<" ? N() : K === "/" ? (p = new Ah(Rr(Rr({}, p), { name: J() })), f = 12) : K === ">" ? (p = new Ah(Rr(Rr({}, p), { name: J() })), X()) : !K2.test(K) && !vue.test(K) && K !== ":" && G() } function x(K) { K === ">" ? G() : K2.test(K) ? f = 3 : G() } function T(K) { yg.test(K) || (K === "/" ? f = 12 : K === ">" ? X() : K === "<" ? N() : K === "=" || J2.test(K) || Iue.test(K) ? G() : f = 5) } function b(K) { yg.test(K) ? f = 6 : K === "/" ? f = 12 : K === "=" ? f = 7 : K === ">" ? X() : K === "<" ? N() : J2.test(K) && G() } function S(K) { yg.test(K) || (K === "/" ? f = 12 : K === "=" ? f = 7 : K === ">" ? X() : K === "<" ? N() : J2.test(K) ? G() : f = 5) } function D(K) { yg.test(K) || (K === '"' ? f = 8 : K === "'" ? f = 9 : /[>=`]/.test(K) ? G() : K === "<" ? N() : f = 10) } function P(K) { K === '"' && (f = 11) } function B(K) { K === "'" && (f = 11) } function R(K) { yg.test(K) ? f = 4 : K === ">" ? X() : K === "<" && N() } function M(K) { yg.test(K) ? f = 4 : K === "/" ? f = 12 : K === ">" ? X() : K === "<" ? N() : (f = 4, W()) } function L(K) { K === ">" ? (p = new Ah(Rr(Rr({}, p), { isClosing: !0 })), X()) : f = 4 } function _(K) { e.substr(c, 2) === "--" ? (c += 2, p = new Ah(Rr(Rr({}, p), { type: "comment" })), f = 14) : e.substr(c, 7).toUpperCase() === "DOCTYPE" ? (c += 7, p = new Ah(Rr(Rr({}, p), { type: "doctype" })), f = 20) : G() } function E(K) { K === "-" ? f = 15 : K === ">" ? G() : f = 16 } function w(K) { K === "-" ? f = 18 : K === ">" ? G() : f = 16 } function v(K) { K === "-" && (f = 17) } function O(K) { K === "-" ? f = 18 : f = 16 } function V(K) { K === ">" ? X() : K === "!" ? f = 19 : K === "-" || (f = 16) } function z(K) { K === "-" ? f = 17 : K === ">" ? X() : f = 16 } function k(K) { K === ">" ? X() : K === "<" && N() } function G() { f = 0, p = a } function N() { f = 1, p = new Ah({ idx: c }) } function X() { var K = e.slice(d, p.idx); K && o(K, d), p.type === "comment" ? r(p.idx) : p.type === "doctype" ? s(p.idx) : (p.isOpening && n(p.name, p.idx), p.isClosing && i(p.name, p.idx)), G(), d = c + 1 } function q() { var K = e.slice(d, c); o(K, d), d = c + 1 } function J() { var K = p.idx + (p.isClosing ? 2 : 1); return e.slice(K, c).toLowerCase() } function W() { c-- } } var Ah = function () { function e(t) { t === void 0 && (t = {}), this.idx = t.idx !== void 0 ? t.idx : -1, this.type = t.type || "tag", this.name = t.name || "", this.isOpening = !!t.isOpening, this.isClosing = !!t.isClosing } return e }(); var UYe = function () { function e(t) { t === void 0 && (t = {}), this.version = e.version, this.urls = {}, this.email = !0, this.phone = !0, this.hashtag = !1, this.mention = !1, this.newWindow = !0, this.stripPrefix = { scheme: !0, www: !0 }, this.stripTrailingSlash = !0, this.decodePercentEncoding = !0, this.truncate = { length: 0, location: "end" }, this.className = "", this.replaceFn = null, this.context = void 0, this.sanitizeHtml = !1, this.matchers = null, this.tagBuilder = null, this.urls = this.normalizeUrlsCfg(t.urls), this.email = typeof t.email == "boolean" ? t.email : this.email, this.phone = typeof t.phone == "boolean" ? t.phone : this.phone, this.hashtag = t.hashtag || this.hashtag, this.mention = t.mention || this.mention, this.newWindow = typeof t.newWindow == "boolean" ? t.newWindow : this.newWindow, this.stripPrefix = this.normalizeStripPrefixCfg(t.stripPrefix), this.stripTrailingSlash = typeof t.stripTrailingSlash == "boolean" ? t.stripTrailingSlash : this.stripTrailingSlash, this.decodePercentEncoding = typeof t.decodePercentEncoding == "boolean" ? t.decodePercentEncoding : this.decodePercentEncoding, this.sanitizeHtml = t.sanitizeHtml || !1; var n = this.mention; if (n !== !1 && ["twitter", "instagram", "soundcloud", "tiktok"].indexOf(n) === -1) throw new Error("invalid `mention` cfg '".concat(n, "' - see docs")); var i = this.hashtag; if (i !== !1 && Lue.indexOf(i) === -1) throw new Error("invalid `hashtag` cfg '".concat(i, "' - see docs")); this.truncate = this.normalizeTruncateCfg(t.truncate), this.className = t.className || this.className, this.replaceFn = t.replaceFn || this.replaceFn, this.context = t.context || this } return e.link = function (t, n) { var i = new e(n); return i.link(t) }, e.parse = function (t, n) { var i = new e(n); return i.parse(t) }, e.prototype.normalizeUrlsCfg = function (t) { return t == null && (t = !0), typeof t == "boolean" ? { schemeMatches: t, wwwMatches: t, tldMatches: t } : { schemeMatches: typeof t.schemeMatches == "boolean" ? t.schemeMatches : !0, wwwMatches: typeof t.wwwMatches == "boolean" ? t.wwwMatches : !0, tldMatches: typeof t.tldMatches == "boolean" ? t.tldMatches : !0 } }, e.prototype.normalizeStripPrefixCfg = function (t) { return t == null && (t = !0), typeof t == "boolean" ? { scheme: t, www: t } : { scheme: typeof t.scheme == "boolean" ? t.scheme : !0, www: typeof t.www == "boolean" ? t.www : !0 } }, e.prototype.normalizeTruncateCfg = function (t) { return typeof t == "number" ? { length: t, location: "end" } : Qle(t || {}, { length: Number.POSITIVE_INFINITY, location: "end" }) }, e.prototype.parse = function (t) { var n = this, i = ["a", "style", "script"], o = 0, r = []; return Fue(t, { onOpenTag: function (s) { i.indexOf(s) >= 0 && o++ }, onText: function (s, a) { if (o === 0) { var c = /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi, u = eue(s, c), f = a; u.forEach(function (d, p) { if (p % 2 === 0) { var g = n.parseText(d, f); r.push.apply(r, g) } f += d.length }) } }, onCloseTag: function (s) { i.indexOf(s) >= 0 && (o = Math.max(o - 1, 0)) }, onComment: function (s) { }, onDoctype: function (s) { } }), r = this.compactMatches(r), r = this.removeUnwantedMatches(r), r }, e.prototype.compactMatches = function (t) { t.sort(function (c, u) { return c.getOffset() - u.getOffset() }); for (var n = 0; n < t.length - 1;) { var i = t[n], o = i.getOffset(), r = i.getMatchedText().length, s = o + r; if (n + 1 < t.length) { if (t[n + 1].getOffset() === o) { var a = t[n + 1].getMatchedText().length > r ? n : n + 1; t.splice(a, 1); continue } if (t[n + 1].getOffset() < s) { t.splice(n + 1, 1); continue } } n++ } return t }, e.prototype.removeUnwantedMatches = function (t) { return this.hashtag || gg(t, function (n) { return n.getType() === "hashtag" }), this.email || gg(t, function (n) { return n.getType() === "email" }), this.phone || gg(t, function (n) { return n.getType() === "phone" }), this.mention || gg(t, function (n) { return n.getType() === "mention" }), this.urls.schemeMatches || gg(t, function (n) { return n.getType() === "url" && n.getUrlMatchType() === "scheme" }), this.urls.wwwMatches || gg(t, function (n) { return n.getType() === "url" && n.getUrlMatchType() === "www" }), this.urls.tldMatches || gg(t, function (n) { return n.getType() === "url" && n.getUrlMatchType() === "tld" }), t }, e.prototype.parseText = function (t, n) { n === void 0 && (n = 0), n = n || 0; for (var i = this.getMatchers(), o = [], r = 0, s = i.length; r < s; r++) { for (var a = i[r].parseMatches(t), c = 0, u = a.length; c < u; c++)a[c].setOffset(n + a[c].getOffset()); o.push.apply(o, a) } return o }, e.prototype.link = function (t) { if (!t) return ""; this.sanitizeHtml && (t = t.replace(/</g, "&lt;").replace(/>/g, "&gt;")); for (var n = this.parse(t), i = [], o = 0, r = 0, s = n.length; r < s; r++) { var a = n[r]; i.push(t.substring(o, a.getOffset())), i.push(this.createMatchReturnVal(a)), o = a.getOffset() + a.getMatchedText().length } return i.push(t.substring(o)), i.join("") }, e.prototype.createMatchReturnVal = function (t) { var n; if (this.replaceFn && (n = this.replaceFn.call(this.context, t)), typeof n == "string") return n; if (n === !1) return t.getMatchedText(); if (n instanceof pD) return n.toAnchorString(); var i = t.buildTag(); return i.toAnchorString() }, e.prototype.getMatchers = function () { if (this.matchers) return this.matchers; var t = this.getTagBuilder(), n = [new mW({ tagBuilder: t, serviceName: this.hashtag }), new dW({ tagBuilder: t }), new pW({ tagBuilder: t }), new _W({ tagBuilder: t, serviceName: this.mention }), new hW({ tagBuilder: t, stripPrefix: this.stripPrefix, stripTrailingSlash: this.stripTrailingSlash, decodePercentEncoding: this.decodePercentEncoding })]; return this.matchers = n }, e.prototype.getTagBuilder = function () { var t = this.tagBuilder; return t || (t = this.tagBuilder = new lW({ newWindow: this.newWindow, truncate: this.truncate, className: this.className })), t }, e.version = Zle, e.AnchorTagBuilder = lW, e.HtmlTag = pD, e.matcher = { Email: dW, Hashtag: mW, Matcher: Gu, Mention: _W, Phone: pW, Url: hW }, e.match = { Email: G2, Hashtag: W2, Match: Hu, Mention: j2, Phone: q2, Url: Y2 }, e }(), Nue = UYe; var e3 = Nue; var que; typeof DOMParser < "u" && (que = new DOMParser); var zYe = new e3({ stripPrefix: !1, email: !1, replaceFn: function (e, t) { if (!t.protocolUrlMatch) return !1 } }), t3 = 32, Vue = 2414016, kue = 1, Uue = 16093e3, zue = .1, HYe = [null, void 0, "http://www.topografix.com/GPX/1/1"], yo = { gpx: HYe }; function GYe(e) { return new Promise((t, n) => { let i = new FileReader; i.addEventListener("load", function () { t(i.result) }), i.addEventListener("error", function () { n(i.error) }), i.readAsText(e) }) } function gW(e, t) { let n = AD(e, "id"); return n = l(n) ? n : Nn(), t.getOrCreateEntity(n) } function yW(e) { let t = Hue(e, "lon"), n = Hue(e, "lat"), i = gD(e, "ele", yo.gpx); return h.fromDegrees(t, n, i) } function Hue(e, t) { if (!l(e)) return; let n = e.getAttribute(t); if (n !== null) { let i = parseFloat(n); return isNaN(i) ? void 0 : i } } function AD(e, t) { if (!l(e)) return; let n = e.getAttribute(t); return n !== null ? n : void 0 } function Ag(e, t, n) { if (!l(e)) return; let i = e.childNodes, o = i.length; for (let r = 0; r < o; r++) { let s = i[r]; if (s.localName === t && n.indexOf(s.namespaceURI) !== -1) return s } } function AW(e, t, n) { if (!l(e)) return; let i = [], o = e.getElementsByTagName(t), r = o.length; for (let s = 0; s < r; s++) { let a = o[s]; a.localName === t && n.indexOf(a.namespaceURI) !== -1 && i.push(a) } return i } function gD(e, t, n) { let i = Ag(e, t, n); if (l(i)) { let o = parseFloat(i.textContent); return isNaN(o) ? void 0 : o } } function Zc(e, t, n) { let i = Ag(e, t, n); if (l(i)) return i.textContent.trim() } function Yue(e) { let t = new ja; return t.width = t3, t.height = t3, t.scaleByDistance = new wt(Vue, kue, Uue, zue), t.pixelOffsetScaleByDistance = new wt(Vue, kue, Uue, zue), t.verticalOrigin = new Yn(Sn.BOTTOM), t.image = e, t } function WYe() { let e = new Rd; return e.translucencyByDistance = new wt(3e6, 1, 5e6, 0), e.pixelOffset = new H(17, 0), e.horizontalOrigin = ai.LEFT, e.font = "16px sans-serif", e.style = Fo.FILL_AND_OUTLINE, e } function Xue(e) { let t = new ec; return t.width = 4, t.material = new Cy, t.material.color = l(e) ? e : U.RED, t.material.outlineWidth = 2, t.material.outlineColor = U.BLACK, t } var Gue = { time: { text: "Time", tag: "time" }, comment: { text: "Comment", tag: "cmt" }, description: { text: "Description", tag: "desc" }, source: { text: "Source", tag: "src" }, number: { text: "GPS track/route number", tag: "number" }, type: { text: "Type", tag: "type" } }, yD; typeof document < "u" && (yD = document.createElement("div")); function CW(e, t) { let n, i = "", o = Object.keys(Gue), r = o.length; for (n = 0; n < r; n++) { let f = o[n], d = Gue[f]; d.value = y(Zc(e, d.tag, yo.gpx), ""), l(d.value) && d.value !== "" && (i = `${i}<p>${d.text}: ${d.value}</p>`) } if (!l(i) || i === "") return; i = zYe.link(i), yD.innerHTML = i; let s = yD.querySelectorAll("a"); for (n = 0; n < s.length; n++)s[n].setAttribute("target", "_blank"); let a = U.WHITE, c = U.BLACK, u = '<div class="cesium-infoBox-description-lighter" style="'; return u += "overflow:auto;", u += "word-wrap:break-word;", u += `background-color:${a.toCssColorString()};`, u += `color:${c.toCssColorString()};`, u += '">', u += `${yD.innerHTML}</div>`, yD.innerHTML = "", u } function Kue(e, t, n, i) { let o = yW(t), r = gW(t, n); r.position = o; let s = l(i.waypointImage) ? i.waypointImage : e._pinBuilder.fromMakiIconId("marker", U.RED, t3); r.billboard = Yue(s); let a = Zc(t, "name", yo.gpx); r.name = a, r.label = WYe(), r.label.text = a, r.description = CW(t, r), i.clampToGround && (r.billboard.heightReference = ze.CLAMP_TO_GROUND, r.label.heightReference = ze.CLAMP_TO_GROUND) } function jYe(e, t, n, i) { let o = gW(t, n); o.description = CW(t, o); let r = AW(t, "rtept", yo.gpx), s = new Array(r.length); for (let a = 0; a < r.length; a++)Kue(e, r[a], n, i), s[a] = yW(r[a]); o.polyline = Xue(i.routeColor), i.clampToGround && (o.polyline.clampToGround = !0), o.polyline.positions = s } function qYe(e, t, n, i) { let o = gW(t, n); o.description = CW(t, o); let r = AW(t, "trkseg", yo.gpx), s = [], a = [], c, u = !0, f = new ea; for (let d = 0; d < r.length; d++)c = YYe(r[d]), s = s.concat(c.positions), c.times.length > 0 ? (a = a.concat(c.times), f.addSamples(a, s), u = u && !0) : u = !1; if (u) { let d = l(i.waypointImage) ? i.waypointImage : e._pinBuilder.fromMakiIconId("marker", U.RED, t3); o.billboard = Yue(d), o.position = f, i.clampToGround && (o.billboard.heightReference = ze.CLAMP_TO_GROUND), o.availability = new Ir, o.availability.addInterval(new yn({ start: a[0], stop: a[a.length - 1] })) } o.polyline = Xue(i.trackColor), o.polyline.positions = s, i.clampToGround && (o.polyline.clampToGround = !0) } function YYe(e) { let t = { positions: [], times: [] }, n = AW(e, "trkpt", yo.gpx), i; for (let o = 0; o < n.length; o++) { let r = yW(n[o]); t.positions.push(r), i = Zc(n[o], "time", yo.gpx), l(i) && t.times.push($.fromIso8601(i)) } return t } function XYe(e) { let t = Ag(e, "metadata", yo.gpx); if (l(t)) { let n = { name: Zc(t, "name", yo.gpx), desc: Zc(t, "desc", yo.gpx), author: KYe(t), copyright: ZYe(t), link: Jue(t), time: Zc(t, "time", yo.gpx), keywords: Zc(t, "keywords", yo.gpx), bounds: QYe(t) }; if (l(n.name) || l(n.desc) || l(n.author) || l(n.copyright) || l(n.link) || l(n.time) || l(n.keywords) || l(n.bounds)) return n } } function KYe(e) { let t = Ag(e, "author", yo.gpx); if (l(t)) { let n = { name: Zc(t, "name", yo.gpx), email: JYe(t), link: Jue(t) }; if (l(n.name) || l(n.email) || l(n.link)) return n } } function JYe(e) { let t = Ag(e, "email", yo.gpx); if (l(t)) { let n = Zc(t, "id", yo.gpx), i = Zc(t, "domain", yo.gpx); return `${n}@${i}` } } function Jue(e) { let t = Ag(e, "link", yo.gpx); if (l(t)) { let n = { href: AD(t, "href"), text: Zc(t, "text", yo.gpx), mimeType: Zc(t, "type", yo.gpx) }; if (l(n.href) || l(n.text) || l(n.mimeType)) return n } } function ZYe(e) { let t = Ag(e, "copyright", yo.gpx); if (l(t)) { let n = { author: AD(t, "author"), year: Zc(t, "year", yo.gpx), license: Zc(t, "license", yo.gpx) }; if (l(n.author) || l(n.year) || l(n.license)) return n } } function QYe(e) { let t = Ag(e, "bounds", yo.gpx); if (l(t)) { let n = { minLat: gD(t, "minlat", yo.gpx), maxLat: gD(t, "maxlat", yo.gpx), minLon: gD(t, "minlon", yo.gpx), maxLon: gD(t, "maxlon", yo.gpx) }; if (l(n.minLat) || l(n.maxLat) || l(n.minLon) || l(n.maxLon)) return n } } var Wue = { wpt: Kue, rte: jYe, trk: qYe }; function $Ye(e, t, n, i) { let o = Object.keys(Wue), r = o.length; for (let s = 0; s < r; s++) { let a = o[s], c = Wue[a], u = t.childNodes, f = u.length; for (let d = 0; d < f; d++) { let p = u[d]; p.localName === a && yo.gpx.indexOf(p.namespaceURI) !== -1 && c(e, p, n, i) } } } function jue(e, t, n) { let i = e._entityCollection; i.removeAll(); let o = t.documentElement, r = AD(o, "version"), s = AD(o, "creator"), a, c = XYe(o); l(c) && (a = c.name), o.localName === "gpx" ? $Ye(e, o, i, n) : console.log(`GPX - Unsupported node: ${o.localName}`); let u, f = i.computeAvailability(), d = f.start, p = f.stop, g = $.equals(d, ke.MINIMUM_VALUE), m = $.equals(p, ke.MAXIMUM_VALUE); if (!g || !m) { let C; g && (C = new Date, C.setHours(0, 0, 0, 0), d = $.fromDate(C)), m && (C = new Date, C.setHours(24, 0, 0, 0), p = $.fromDate(C)), u = new ah, u.startTime = d, u.stopTime = p, u.currentTime = $.clone(d), u.clockRange = Br.LOOP_STOP, u.clockStep = uo.SYSTEM_CLOCK_MULTIPLIER, u.multiplier = Math.round(Math.min(Math.max($.secondsDifference(p, d) / 60, 1), 31556900)) } let A = !1; return e._name !== a && (e._name = a, A = !0), e._creator !== s && (e._creator = s, A = !0), eXe(e._metadata, c) && (e._metadata = c, A = !0), e._version !== r && (e._version = r, A = !0), u !== e._clock && (A = !0, e._clock = u), A && e._changed.raiseEvent(e), Or.setLoading(e, !1), e } function eXe(e, t) { return !l(e) && !l(t) ? !1 : l(e) && l(t) ? e.name !== t.name || e.dec !== t.desc || e.src !== t.src || e.author !== t.author || e.copyright !== t.copyright || e.link !== t.link || e.time !== t.time || e.bounds !== t.bounds : !0 } function tXe(e, t, n, i) { i = y(i, y.EMPTY_OBJECT); let o = n; if (typeof n == "string" || n instanceof Pe) { n = Pe.createIfNeeded(n), o = n.fetchBlob(); let r = e._resourceCredits, s = n.credits; if (l(s)) { let a = s.length; for (let c = 0; c < a; c++)r.push(s[c]) } } return Promise.resolve(o).then(function (r) { return r instanceof Blob ? GYe(r).then(function (s) { let a, c; try { a = que.parseFromString(s, "application/xml") } catch (u) { c = u.toString() } if (l(c) || a.body || a.documentElement.tagName === "parsererror") { let u = l(c) ? c : a.documentElement.firstChild.nodeValue; throw u || (u = a.body.innerText), new fe(u) } return jue(e, a, i) }) : jue(e, r, i) }).catch(function (r) { return e._error.raiseEvent(e, r), console.log(r), Promise.reject(r) }) } function KT() { this._changed = new _e, this._error = new _e, this._loading = new _e, this._clock = void 0, this._entityCollection = new vs, this._entityCluster = new Iu, this._name = void 0, this._version = void 0, this._creator = void 0, this._metadata = void 0, this._isLoading = !1, this._pinBuilder = new pg } KT.load = function (e, t) { return new KT().load(e, t) }; Object.defineProperties(KT.prototype, { name: { get: function () { return this._name } }, version: { get: function () { return this._version } }, creator: { get: function () { return this._creator } }, metadata: { get: function () { return this._metadata } }, clock: { get: function () { return this._clock } }, entities: { get: function () { return this._entityCollection } }, isLoading: { get: function () { return this._isLoading } }, changedEvent: { get: function () { return this._changed } }, errorEvent: { get: function () { return this._error } }, loadingEvent: { get: function () { return this._loading } }, show: { get: function () { return this._entityCollection.show }, set: function (e) { this._entityCollection.show = e } }, clustering: { get: function () { return this._entityCluster }, set: function (e) { this._entityCluster = e } } }); KT.prototype.update = function (e) { return !0 }; KT.prototype.load = function (e, t) { if (!l(e)) throw new ye("data is required."); t = y(t, y.EMPTY_OBJECT), Or.setLoading(this, !0); let n = this._name, i = this; return tXe(this, this._entityCollection, e, t).then(function () { let o, r = i._entityCollection.computeAvailability(), s = r.start, a = r.stop, c = $.equals(s, ke.MINIMUM_VALUE), u = $.equals(a, ke.MAXIMUM_VALUE); if (!c || !u) { let d; c && (d = new Date, d.setHours(0, 0, 0, 0), s = $.fromDate(d)), u && (d = new Date, d.setHours(24, 0, 0, 0), a = $.fromDate(d)), o = new ah, o.startTime = s, o.stopTime = a, o.currentTime = $.clone(s), o.clockRange = Br.LOOP_STOP, o.clockStep = uo.SYSTEM_CLOCK_MULTIPLIER, o.multiplier = Math.round(Math.min(Math.max($.secondsDifference(a, s) / 60, 1), 31556900)) } let f = !1; return o !== i._clock && (i._clock = o, f = !0), n !== i._name && (f = !0), f && i._changed.raiseEvent(i), Or.setLoading(i, !1), i }).catch(function (o) { return Or.setLoading(i, !1), i._error.raiseEvent(i, o), console.log(o), Promise.reject(o) }) }; var n3 = KT; function nXe(e, t) { this.position = e, this.headingPitchRoll = t } var i3 = nXe; var TD = po(al(), 1); function iXe(e) { return typeof e == "string" && (e = document.getElementById(e)), e } var vn = iXe; function oXe(e, t) { this.position = e, this.headingPitchRange = t } var o3 = oXe; function r3(e, t) { this.id = t, this.name = e, this.playlistIndex = 0, this.playlist = [], this.tourStart = new _e, this.tourEnd = new _e, this.entryStart = new _e, this.entryEnd = new _e, this._activeEntries = [] } r3.prototype.addPlaylistEntry = function (e) { this.playlist.push(e) }; r3.prototype.play = function (e, t) { this.tourStart.raiseEvent(); let n = this; Que.call(this, e, t, function (i) { n.playlistIndex = 0, i || Zue(n._activeEntries), n.tourEnd.raiseEvent(i) }) }; r3.prototype.stop = function () { Zue(this._activeEntries) }; function Zue(e) { for (let t = e.pop(); t !== void 0; t = e.pop())t.stop() } function Que(e, t, n) { let i = this.playlist[this.playlistIndex]; if (i) { let o = rXe.bind(this, e, t, n); if (this._activeEntries.push(i), this.entryStart.raiseEvent(i), i.blocking) i.play(o, e.scene.camera, t); else { let r = this; i.play(function () { r.entryEnd.raiseEvent(i); let s = r._activeEntries.indexOf(i); s >= 0 && r._activeEntries.splice(s, 1) }), o(e, t, n) } } else l(n) && n(!1) } function rXe(e, t, n, i) { let o = this.playlist[this.playlistIndex]; if (this.entryEnd.raiseEvent(o, i), i) n(i); else { let r = this._activeEntries.indexOf(o); r >= 0 && this._activeEntries.splice(r, 1), this.playlistIndex++, Que.call(this, e, t, n) } } var s3 = r3; var Si = { Linear: { None: function (e) { return e } }, Quadratic: { In: function (e) { return e * e }, Out: function (e) { return e * (2 - e) }, InOut: function (e) { return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1) } }, Cubic: { In: function (e) { return e * e * e }, Out: function (e) { return --e * e * e + 1 }, InOut: function (e) { return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2) } }, Quartic: { In: function (e) { return e * e * e * e }, Out: function (e) { return 1 - --e * e * e * e }, InOut: function (e) { return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2) } }, Quintic: { In: function (e) { return e * e * e * e * e }, Out: function (e) { return --e * e * e * e * e + 1 }, InOut: function (e) { return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2) } }, Sinusoidal: { In: function (e) { return 1 - Math.cos(e * Math.PI / 2) }, Out: function (e) { return Math.sin(e * Math.PI / 2) }, InOut: function (e) { return .5 * (1 - Math.cos(Math.PI * e)) } }, Exponential: { In: function (e) { return e === 0 ? 0 : Math.pow(1024, e - 1) }, Out: function (e) { return e === 1 ? 1 : 1 - Math.pow(2, -10 * e) }, InOut: function (e) { return e === 0 ? 0 : e === 1 ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (-Math.pow(2, -10 * (e - 1)) + 2) } }, Circular: { In: function (e) { return 1 - Math.sqrt(1 - e * e) }, Out: function (e) { return Math.sqrt(1 - --e * e) }, InOut: function (e) { return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1) } }, Elastic: { In: function (e) { return e === 0 ? 0 : e === 1 ? 1 : -Math.pow(2, 10 * (e - 1)) * Math.sin((e - 1.1) * 5 * Math.PI) }, Out: function (e) { return e === 0 ? 0 : e === 1 ? 1 : Math.pow(2, -10 * e) * Math.sin((e - .1) * 5 * Math.PI) + 1 }, InOut: function (e) { return e === 0 ? 0 : e === 1 ? 1 : (e *= 2, e < 1 ? -.5 * Math.pow(2, 10 * (e - 1)) * Math.sin((e - 1.1) * 5 * Math.PI) : .5 * Math.pow(2, -10 * (e - 1)) * Math.sin((e - 1.1) * 5 * Math.PI) + 1) } }, Back: { In: function (e) { var t = 1.70158; return e * e * ((t + 1) * e - t) }, Out: function (e) { var t = 1.70158; return --e * e * ((t + 1) * e + t) + 1 }, InOut: function (e) { var t = 2.5949095; return (e *= 2) < 1 ? .5 * (e * e * ((t + 1) * e - t)) : .5 * ((e -= 2) * e * ((t + 1) * e + t) + 2) } }, Bounce: { In: function (e) { return 1 - Si.Bounce.Out(1 - e) }, Out: function (e) { return e < .36363636363636365 ? 7.5625 * e * e : e < .7272727272727273 ? 7.5625 * (e -= .5454545454545454) * e + .75 : e < .9090909090909091 ? 7.5625 * (e -= .8181818181818182) * e + .9375 : 7.5625 * (e -= .9545454545454546) * e + .984375 }, InOut: function (e) { return e < .5 ? Si.Bounce.In(e * 2) * .5 : Si.Bounce.Out(e * 2 - 1) * .5 + .5 } } }, CD; typeof self > "u" && typeof process < "u" && process.hrtime ? CD = function () { var e = process.hrtime(); return e[0] * 1e3 + e[1] / 1e6 } : typeof self < "u" && self.performance !== void 0 && self.performance.now !== void 0 ? CD = self.performance.now.bind(self.performance) : Date.now !== void 0 ? CD = Date.now : CD = function () { return new Date().getTime() }; var JT = CD, sXe = function () { function e() { this._tweens = {}, this._tweensAddedDuringUpdate = {} } return e.prototype.getAll = function () { var t = this; return Object.keys(this._tweens).map(function (n) { return t._tweens[n] }) }, e.prototype.removeAll = function () { this._tweens = {} }, e.prototype.add = function (t) { this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t }, e.prototype.remove = function (t) { delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()] }, e.prototype.update = function (t, n) { t === void 0 && (t = JT()), n === void 0 && (n = !1); var i = Object.keys(this._tweens); if (i.length === 0) return !1; for (; i.length > 0;) { this._tweensAddedDuringUpdate = {}; for (var o = 0; o < i.length; o++) { var r = this._tweens[i[o]], s = !n; r && r.update(t, s) === !1 && !n && delete this._tweens[i[o]] } i = Object.keys(this._tweensAddedDuringUpdate) } return !0 }, e }(), xD = { Linear: function (e, t) { var n = e.length - 1, i = n * t, o = Math.floor(i), r = xD.Utils.Linear; return t < 0 ? r(e[0], e[1], i) : t > 1 ? r(e[n], e[n - 1], n - i) : r(e[o], e[o + 1 > n ? n : o + 1], i - o) }, Bezier: function (e, t) { for (var n = 0, i = e.length - 1, o = Math.pow, r = xD.Utils.Bernstein, s = 0; s <= i; s++)n += o(1 - t, i - s) * o(t, s) * e[s] * r(i, s); return n }, CatmullRom: function (e, t) { var n = e.length - 1, i = n * t, o = Math.floor(i), r = xD.Utils.CatmullRom; return e[0] === e[n] ? (t < 0 && (o = Math.floor(i = n * (1 + t))), r(e[(o - 1 + n) % n], e[o], e[(o + 1) % n], e[(o + 2) % n], i - o)) : t < 0 ? e[0] - (r(e[0], e[0], e[1], e[1], -i) - e[0]) : t > 1 ? e[n] - (r(e[n], e[n], e[n - 1], e[n - 1], i - n) - e[n]) : r(e[o ? o - 1 : 0], e[o], e[n < o + 1 ? n : o + 1], e[n < o + 2 ? n : o + 2], i - o) }, Utils: { Linear: function (e, t, n) { return (t - e) * n + e }, Bernstein: function (e, t) { var n = xD.Utils.Factorial; return n(e) / n(t) / n(e - t) }, Factorial: function () { var e = [1]; return function (t) { var n = 1; if (e[t]) return e[t]; for (var i = t; i > 1; i--)n *= i; return e[t] = n, n } }(), CatmullRom: function (e, t, n, i, o) { var r = (n - e) * .5, s = (i - t) * .5, a = o * o, c = o * a; return (2 * t - 2 * n + r + s) * c + (-3 * t + 3 * n - 2 * r - s) * a + r * o + t } } }, $ue = function () { function e() { } return e.nextId = function () { return e._nextId++ }, e._nextId = 0, e }(), efe = new sXe, tfe = function () { function e(t, n) { n === void 0 && (n = efe), this._object = t, this._group = n, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = Si.Linear.None, this._interpolationFunction = xD.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._id = $ue.nextId(), this._isChainStopped = !1, this._goToEnd = !1 } return e.prototype.getId = function () { return this._id }, e.prototype.isPlaying = function () { return this._isPlaying }, e.prototype.isPaused = function () { return this._isPaused }, e.prototype.to = function (t, n) { return this._valuesEnd = Object.create(t), n !== void 0 && (this._duration = n), this }, e.prototype.duration = function (t) { return this._duration = t, this }, e.prototype.start = function (t) { if (this._isPlaying) return this; if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) { this._reversed = !1; for (var n in this._valuesStartRepeat) this._swapEndStartRepeatValues(n), this._valuesStart[n] = this._valuesStartRepeat[n] } return this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t !== void 0 ? typeof t == "string" ? JT() + parseFloat(t) : t : JT(), this._startTime += this._delayTime, this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat), this }, e.prototype._setupProperties = function (t, n, i, o) { for (var r in i) { var s = t[r], a = Array.isArray(s), c = a ? "array" : typeof s, u = !a && Array.isArray(i[r]); if (!(c === "undefined" || c === "function")) { if (u) { var f = i[r]; if (f.length === 0) continue; f = f.map(this._handleRelativeValue.bind(this, s)), i[r] = [s].concat(f) } if ((c === "object" || a) && s && !u) { n[r] = a ? [] : {}; for (var d in s) n[r][d] = s[d]; o[r] = a ? [] : {}, this._setupProperties(s, n[r], i[r], o[r]) } else typeof n[r] > "u" && (n[r] = s), a || (n[r] *= 1), u ? o[r] = i[r].slice().reverse() : o[r] = n[r] || 0 } } }, e.prototype.stop = function () { return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this }, e.prototype.end = function () { return this._goToEnd = !0, this.update(1 / 0), this }, e.prototype.pause = function (t) { return t === void 0 && (t = JT()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this), this) }, e.prototype.resume = function (t) { return t === void 0 && (t = JT()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this) }, e.prototype.stopChainedTweens = function () { for (var t = 0, n = this._chainedTweens.length; t < n; t++)this._chainedTweens[t].stop(); return this }, e.prototype.group = function (t) { return this._group = t, this }, e.prototype.delay = function (t) { return this._delayTime = t, this }, e.prototype.repeat = function (t) { return this._initialRepeat = t, this._repeat = t, this }, e.prototype.repeatDelay = function (t) { return this._repeatDelayTime = t, this }, e.prototype.yoyo = function (t) { return this._yoyo = t, this }, e.prototype.easing = function (t) { return this._easingFunction = t, this }, e.prototype.interpolation = function (t) { return this._interpolationFunction = t, this }, e.prototype.chain = function () { for (var t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; return this._chainedTweens = t, this }, e.prototype.onStart = function (t) { return this._onStartCallback = t, this }, e.prototype.onUpdate = function (t) { return this._onUpdateCallback = t, this }, e.prototype.onRepeat = function (t) { return this._onRepeatCallback = t, this }, e.prototype.onComplete = function (t) { return this._onCompleteCallback = t, this }, e.prototype.onStop = function (t) { return this._onStopCallback = t, this }, e.prototype.update = function (t, n) { if (t === void 0 && (t = JT()), n === void 0 && (n = !0), this._isPaused) return !0; var i, o, r = this._startTime + this._duration; if (!this._goToEnd && !this._isPlaying) { if (t > r) return !1; n && this.start(t) } if (this._goToEnd = !1, t < this._startTime) return !0; this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), o = (t - this._startTime) / this._duration, o = this._duration === 0 || o > 1 ? 1 : o; var s = this._easingFunction(o); if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, s), this._onUpdateCallback && this._onUpdateCallback(this._object, o), o === 1) if (this._repeat > 0) { isFinite(this._repeat) && this._repeat--; for (i in this._valuesStartRepeat) !this._yoyo && typeof this._valuesEnd[i] == "string" && (this._valuesStartRepeat[i] = this._valuesStartRepeat[i] + parseFloat(this._valuesEnd[i])), this._yoyo && this._swapEndStartRepeatValues(i), this._valuesStart[i] = this._valuesStartRepeat[i]; return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), !0 } else { this._onCompleteCallback && this._onCompleteCallback(this._object); for (var a = 0, c = this._chainedTweens.length; a < c; a++)this._chainedTweens[a].start(this._startTime + this._duration); return this._isPlaying = !1, !1 } return !0 }, e.prototype._updateProperties = function (t, n, i, o) { for (var r in i) if (n[r] !== void 0) { var s = n[r] || 0, a = i[r], c = Array.isArray(t[r]), u = Array.isArray(a), f = !c && u; f ? t[r] = this._interpolationFunction(a, o) : typeof a == "object" && a ? this._updateProperties(t[r], s, a, o) : (a = this._handleRelativeValue(s, a), typeof a == "number" && (t[r] = s + (a - s) * o)) } }, e.prototype._handleRelativeValue = function (t, n) { return typeof n != "string" ? n : n.charAt(0) === "+" || n.charAt(0) === "-" ? t + parseFloat(n) : parseFloat(n) }, e.prototype._swapEndStartRepeatValues = function (t) { var n = this._valuesStartRepeat[t], i = this._valuesEnd[t]; typeof i == "string" ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(i) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = n }, e }(); var lGn = $ue.nextId, Ch = efe, uGn = Ch.getAll.bind(Ch), fGn = Ch.removeAll.bind(Ch), dGn = Ch.add.bind(Ch), hGn = Ch.remove.bind(Ch), mGn = Ch.update.bind(Ch); var aXe = { LINEAR_NONE: Si.Linear.None, QUADRATIC_IN: Si.Quadratic.In, QUADRATIC_OUT: Si.Quadratic.Out, QUADRATIC_IN_OUT: Si.Quadratic.InOut, CUBIC_IN: Si.Cubic.In, CUBIC_OUT: Si.Cubic.Out, CUBIC_IN_OUT: Si.Cubic.InOut, QUARTIC_IN: Si.Quartic.In, QUARTIC_OUT: Si.Quartic.Out, QUARTIC_IN_OUT: Si.Quartic.InOut, QUINTIC_IN: Si.Quintic.In, QUINTIC_OUT: Si.Quintic.Out, QUINTIC_IN_OUT: Si.Quintic.InOut, SINUSOIDAL_IN: Si.Sinusoidal.In, SINUSOIDAL_OUT: Si.Sinusoidal.Out, SINUSOIDAL_IN_OUT: Si.Sinusoidal.InOut, EXPONENTIAL_IN: Si.Exponential.In, EXPONENTIAL_OUT: Si.Exponential.Out, EXPONENTIAL_IN_OUT: Si.Exponential.InOut, CIRCULAR_IN: Si.Circular.In, CIRCULAR_OUT: Si.Circular.Out, CIRCULAR_IN_OUT: Si.Circular.InOut, ELASTIC_IN: Si.Elastic.In, ELASTIC_OUT: Si.Elastic.Out, ELASTIC_IN_OUT: Si.Elastic.InOut, BACK_IN: Si.Back.In, BACK_OUT: Si.Back.Out, BACK_IN_OUT: Si.Back.InOut, BOUNCE_IN: Si.Bounce.In, BOUNCE_OUT: Si.Bounce.Out, BOUNCE_IN_OUT: Si.Bounce.InOut }, Mr = Object.freeze(aXe); function a3(e, t, n) { this.type = "KmlTourFlyTo", this.blocking = !0, this.activeCamera = null, this.activeCallback = null, this.duration = e, this.view = n, this.flyToMode = t } a3.prototype.play = function (e, t, n) { if (this.activeCamera = t, l(e) && e !== null) { let o = this; this.activeCallback = function (r) { delete o.activeCallback, delete o.activeCamera, e(l(r) ? !1 : r) } } let i = this.getCameraOptions(n); if (this.view.headingPitchRoll) t.flyTo(i); else if (this.view.headingPitchRange) { let o = new re(this.view.position); t.flyToBoundingSphere(o, i) } }; a3.prototype.stop = function () { l(this.activeCamera) && this.activeCamera.cancelFlight(), l(this.activeCallback) && this.activeCallback(!0) }; a3.prototype.getCameraOptions = function (e) { let t = { duration: this.duration }; return l(this.activeCallback) && (t.complete = this.activeCallback), this.flyToMode === "smooth" && (t.easingFunction = Mr.LINEAR_NONE), this.view.headingPitchRoll ? (t.destination = this.view.position, t.orientation = this.view.headingPitchRoll) : this.view.headingPitchRange && (t.offset = this.view.headingPitchRange), l(e) && (t = yt(t, e)), t }; var c3 = a3; function xW(e) { this.type = "KmlTourWait", this.blocking = !0, this.duration = e, this.timeout = null } xW.prototype.play = function (e) { let t = this; this.activeCallback = e, this.timeout = setTimeout(function () { delete t.activeCallback, e(!1) }, this.duration * 1e3) }; xW.prototype.stop = function () { clearTimeout(this.timeout), l(this.activeCallback) && this.activeCallback(!0) }; var l3 = xW; var ffe = { avi: "video/x-msvideo", bmp: "image/bmp", bz2: "application/x-bzip2", chm: "application/vnd.ms-htmlhelp", css: "text/css", csv: "text/csv", doc: "application/msword", dvi: "application/x-dvi", eps: "application/postscript", flv: "video/x-flv", gif: "image/gif", gz: "application/x-gzip", htm: "text/html", html: "text/html", ico: "image/vnd.microsoft.icon", jnlp: "application/x-java-jnlp-file", jpeg: "image/jpeg", jpg: "image/jpeg", m3u: "audio/x-mpegurl", m4v: "video/mp4", mathml: "application/mathml+xml", mid: "audio/midi", midi: "audio/midi", mov: "video/quicktime", mp3: "audio/mpeg", mp4: "video/mp4", mp4v: "video/mp4", mpeg: "video/mpeg", mpg: "video/mpeg", odp: "application/vnd.oasis.opendocument.presentation", ods: "application/vnd.oasis.opendocument.spreadsheet", odt: "application/vnd.oasis.opendocument.text", ogg: "application/ogg", pdf: "application/pdf", png: "image/png", pps: "application/vnd.ms-powerpoint", ppt: "application/vnd.ms-powerpoint", ps: "application/postscript", qt: "video/quicktime", rdf: "application/rdf+xml", rss: "application/rss+xml", rtf: "application/rtf", svg: "image/svg+xml", swf: "application/x-shockwave-flash", text: "text/plain", tif: "image/tiff", tiff: "image/tiff", txt: "text/plain", wav: "audio/x-wav", wma: "audio/x-ms-wma", wmv: "video/x-ms-wmv", xml: "application/xml", zip: "application/zip", detectFromFilename: function (e) { let t = e.toLowerCase(); return t = jA(t), ffe[t] } }, vW; typeof DOMParser < "u" && (vW = new DOMParser); var cXe = new e3({ stripPrefix: !1, email: !1, replaceFn: function (e) { if (!e.protocolUrlMatch) return !1 } }), Cg = 32, nfe = 2414016, ife = 1, ofe = 16093e3, rfe = .1, sfe = [null, void 0, "http://www.opengis.net/kml/2.2", "http://earth.google.com/kml/2.2", "http://earth.google.com/kml/2.1", "http://earth.google.com/kml/2.0"], afe = ["http://www.google.com/kml/ext/2.2"], lXe = ["http://www.w3.org/2005/Atom"], ve = { kml: sfe, gx: afe, atom: lXe, kmlgx: sfe.concat(afe) }, PW = { Document: xfe, Folder: vXe, Placemark: PXe, NetworkLink: VXe, GroundOverlay: LXe, PhotoOverlay: bfe, ScreenOverlay: MXe, Tour: OXe }; function xh(e) { this._dataSource = e, this._deferred = js(), this._stack = [], this._promises = [], this._timeoutSet = !1, this._used = !1, this._started = 0, this._timeThreshold = 1e3 } Object.defineProperties(xh.prototype, { dataSource: { get: function () { return this._dataSource } } }); xh.prototype.addNodes = function (e, t) { this._stack.push({ nodes: e, index: 0, processingData: t }), this._used = !0 }; xh.prototype.addPromise = function (e) { this._promises.push(e) }; xh.prototype.wait = function () { let e = this._deferred; return this._used || e.resolve(), Promise.all([e.promise, Promise.all(this._promises)]) }; xh.prototype.process = function () { let e = this._stack.length === 1; return e && (this._started = Fl._getTimestamp()), this._process(e) }; xh.prototype._giveUpTime = function () { if (this._timeoutSet) return; this._timeoutSet = !0, this._timeThreshold = 50; let e = this; setTimeout(function () { e._timeoutSet = !1, e._started = Fl._getTimestamp(), e._process(!0) }, 0) }; xh.prototype._nextNode = function () { let e = this._stack, t = e[e.length - 1], n = t.index, i = t.nodes; if (n !== i.length) return ++t.index, i[n] }; xh.prototype._pop = function () { let e = this._stack; return e.pop(), e.length === 0 ? (this._deferred.resolve(), !1) : !0 }; xh.prototype._process = function (e) { let t = this.dataSource, n = this._stack[this._stack.length - 1].processingData, i = this._nextNode(); for (; l(i);) { let o = PW[i.localName]; if (l(o) && (ve.kml.indexOf(i.namespaceURI) !== -1 || ve.gx.indexOf(i.namespaceURI) !== -1) && (o(t, i, n, this), this._timeoutSet || Fl._getTimestamp() > this._started + this._timeThreshold)) { this._giveUpTime(); return } i = this._nextNode() } this._pop() && e && this._process(!0) }; function uXe(e) { let t = e.slice(0, Math.min(4, e.size)), n = js(), i = new FileReader; return i.addEventListener("load", function () { n.resolve(new DataView(i.result).getUint32(0, !1) === 1347093252) }), i.addEventListener("error", function () { n.reject(i.error) }), i.readAsArrayBuffer(t), n.promise } function fXe(e) { let t = js(), n = new FileReader; return n.addEventListener("load", function () { t.resolve(n.result) }), n.addEventListener("error", function () { t.reject(n.error) }), n.readAsText(e), t.promise } function dfe(e) { let t = { xsi: "http://www.w3.org/2001/XMLSchema-instance" }, n, i, o, r; for (let s in t) t.hasOwnProperty(s) && (o = RegExp(`[< ]${s}:`), r = `xmlns:${s}=`, o.test(e) && e.indexOf(r) === -1 && (l(n) || (n = e.substr(0, e.indexOf("<kml") + 4), i = e.substr(n.length)), n += ` ${r}"${t[s]}"`)); return l(n) && (e = n + i), e } function hfe(e) { let t = e.indexOf("xmlns:"), n = e.indexOf(">", t), i, o, r; for (; t !== -1 && t < n;)i = e.slice(t, e.indexOf('"', t)), o = t, t = e.indexOf(i, t + 1), t !== -1 ? (r = e.indexOf('"', e.indexOf('"', t) + 1), e = e.slice(0, t - 1) + e.slice(r + 1, e.length), t = e.indexOf("xmlns:", o - 1)) : t = e.indexOf("xmlns:", o + 1); return e } function dXe(e, t) { return Promise.resolve(e.getData(new g2)).then(function (n) { n = dfe(n), n = hfe(n), t.kml = vW.parseFromString(n, "application/xml") }) } function TW(e, t) { let n = y(ffe.detectFromFilename(e.filename), "application/octet-stream"); return Promise.resolve(e.getData(new y2(n))).then(function (i) { t[e.filename] = i }) } function Ml(e, t, n, i) { let o = i.keys, r = new TD.default("."), s = e.querySelectorAll(t); for (let a = 0; a < s.length; a++) { let c = s[a], u = c.getAttribute(n); if (l(u)) { let d = new TD.default(u).absoluteTo(r).toString(), p = o.indexOf(d); if (p !== -1) { let g = o[p]; c.setAttribute(n, i[g]), t === "a" && c.getAttribute("download") === null && c.setAttribute("download", g) } } } } function Ll(e, t, n, i) { let o = e.querySelectorAll(t); for (let r = 0; r < o.length; r++) { let s = o[r], a = s.getAttribute(n), c = IW(a, i); l(c) && s.setAttribute(n, c.url) } } function mfe(e, t, n) { let i = ts(e, "id"); i = l(i) && i.length !== 0 ? i : Nn(), l(n) && (i = n + i); let o = t.getById(i); return l(o) && (i = Nn(), l(n) && (i = n + i)), o = t.add(new Xo({ id: i })), l(o.kml) || (o.addProperty("kml"), o.kml = new HXe), o } function ED(e, t) { return e === "absolute" || e === "relativeToGround" || t === "relativeToSeaFloor" } function h3(e, t) { if (!l(e)) return h.fromDegrees(0, 0, 0, t); let n = e.match(/[^\s,\n]+/g); if (!l(n)) return h.fromDegrees(0, 0, 0, t); let i = parseFloat(n[0]), o = parseFloat(n[1]), r = parseFloat(n[2]); return i = isNaN(i) ? 0 : i, o = isNaN(o) ? 0 : o, r = isNaN(r) ? 0 : r, h.fromDegrees(i, o, r, t) } function u3(e, t) { if (!l(e)) return; let n = e.textContent.match(/[^\s\n]+/g); if (!l(n)) return; let i = n.length, o = new Array(i), r = 0; for (let s = 0; s < i; s++)o[r++] = h3(n[s], t); return o } function xg(e, t) { if (!l(e)) return; let n = e.getAttribute(t); if (n !== null) { let i = parseFloat(n); return isNaN(i) ? void 0 : i } } function ts(e, t) { if (!l(e)) return; let n = e.getAttribute(t); return n !== null ? n : void 0 } function hi(e, t, n) { if (!l(e)) return; let i = e.childNodes, o = i.length; for (let r = 0; r < o; r++) { let s = i[r]; if (s.localName === t && n.indexOf(s.namespaceURI) !== -1) return s } } function cfe(e, t, n) { if (!l(e)) return; let i = [], o = e.getElementsByTagNameNS("*", t), r = o.length; for (let s = 0; s < r; s++) { let a = o[s]; a.localName === t && n.indexOf(a.namespaceURI) !== -1 && i.push(a) } return i } function ed(e, t, n) { if (!l(e)) return []; let i = [], o = e.childNodes, r = o.length; for (let s = 0; s < r; s++) { let a = o[s]; a.localName === t && n.indexOf(a.namespaceURI) !== -1 && i.push(a) } return i } function Xn(e, t, n) { let i = hi(e, t, n); if (l(i)) { let o = parseFloat(i.textContent); return isNaN(o) ? void 0 : o } } function Tn(e, t, n) { let i = hi(e, t, n); if (l(i)) return i.textContent.trim() } function td(e, t, n) { let i = hi(e, t, n); if (l(i)) { let o = i.textContent.trim(); return o === "1" || /^true$/i.test(o) } } function IW(e, t, n) { if (!l(e)) return; let i; if (l(n)) { e = e.replace(/\\/g, "/"); let o = n[e]; if (l(o)) i = new Pe({ url: o }); else { let r = new TD.default(t.getUrlComponent()), s = new TD.default(e); o = n[s.absoluteTo(r)], l(o) && (i = new Pe({ url: o })) } } return l(i) || (i = t.getDerivedResource({ url: e })), i } var Qc = { maximumRed: void 0, red: void 0, maximumGreen: void 0, green: void 0, maximumBlue: void 0, blue: void 0 }; function wW(e, t) { if (!l(e) || /^\s*$/gm.test(e)) return; e[0] === "#" && (e = e.substring(1)); let n = parseInt(e.substring(0, 2), 16) / 255, i = parseInt(e.substring(2, 4), 16) / 255, o = parseInt(e.substring(4, 6), 16) / 255, r = parseInt(e.substring(6, 8), 16) / 255; return t ? (r > 0 ? (Qc.maximumRed = r, Qc.red = void 0) : (Qc.maximumRed = void 0, Qc.red = 0), o > 0 ? (Qc.maximumGreen = o, Qc.green = void 0) : (Qc.maximumGreen = void 0, Qc.green = 0), i > 0 ? (Qc.maximumBlue = i, Qc.blue = void 0) : (Qc.maximumBlue = void 0, Qc.blue = 0), Qc.alpha = n, U.fromRandom(Qc)) : new U(r, o, i, n) } function ky(e, t, n) { let i = Tn(e, t, n); if (!!l(i)) return wW(i, Tn(e, "colorMode", n) === "random") } function hXe(e) { let t = hi(e, "TimeStamp", ve.kmlgx), n = Tn(t, "when", ve.kmlgx); if (!l(t) || !l(n) || n.length === 0) return; let i = $.fromIso8601(n), o = new Ir; return o.addInterval(new yn({ start: i, stop: ke.MAXIMUM_VALUE })), o } function mXe(e) { let t = hi(e, "TimeSpan", ve.kmlgx); if (!l(t)) return; let n, i = hi(t, "begin", ve.kmlgx), o = l(i) ? $.fromIso8601(i.textContent) : void 0, r = hi(t, "end", ve.kmlgx), s = l(r) ? $.fromIso8601(r.textContent) : void 0; if (l(o) && l(s)) { if ($.lessThan(s, o)) { let a = o; o = s, s = a } n = new Ir, n.addInterval(new yn({ start: o, stop: s })) } else l(o) ? (n = new Ir, n.addInterval(new yn({ start: o, stop: ke.MAXIMUM_VALUE }))) : l(s) && (n = new Ir, n.addInterval(new yn({ start: ke.MINIMUM_VALUE, stop: s }))); return n } function pfe() { let e = new ja; return e.width = Cg, e.height = Cg, e.scaleByDistance = new wt(nfe, ife, ofe, rfe), e.pixelOffsetScaleByDistance = new wt(nfe, ife, ofe, rfe), e } function OW() { let e = new Md; return e.outline = !0, e.outlineColor = U.WHITE, e } function _fe() { let e = new Rd; return e.translucencyByDistance = new wt(3e6, 1, 5e6, 0), e.pixelOffset = new H(17, 0), e.horizontalOrigin = ai.LEFT, e.font = "16px sans-serif", e.style = Fo.FILL_AND_OUTLINE, e } function BW(e, t, n, i, o) { let r = Tn(e, "href", ve.kml); if (!l(r) || r.length === 0) return; if (r.indexOf("root://icons/palette-") === 0) { let a = r.charAt(21), c = y(Xn(e, "x", ve.gx), 0), u = y(Xn(e, "y", ve.gx), 0); c = Math.min(c / 32, 7), u = 7 - Math.min(u / 32, 7); let f = 8 * u + c; r = `https://maps.google.com/mapfiles/kml/pal${a}/icon${f}.png` } let s = IW(r, n, i); if (o) { let a = Tn(e, "refreshMode", ve.kml), c = Tn(e, "viewRefreshMode", ve.kml); a === "onInterval" || a === "onExpire" ? Pt(`kml-refreshMode-${a}`, `KML - Unsupported Icon refreshMode: ${a}`) : (c === "onStop" || c === "onRegion") && Pt(`kml-refreshMode-${c}`, `KML - Unsupported Icon viewRefreshMode: ${c}`); let u = y(Tn(e, "viewBoundScale", ve.kml), 1), f = c === "onStop" ? "BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]" : "", d = y(Tn(e, "viewFormat", ve.kml), f), p = Tn(e, "httpQuery", ve.kml); l(d) && s.setQueryParameters($l(d3(d))), l(p) && s.setQueryParameters($l(d3(p))); let g = t._ellipsoid; return MW(s, t.camera, t.canvas, u, t._lastCameraView.bbox, g), s } return s } function pXe(e, t, n, i, o) { let r = Xn(t, "scale", ve.kml), s = Xn(t, "heading", ve.kml), a = ky(t, "color", ve.kml), c = hi(t, "Icon", ve.kml), u = BW(c, e, i, o, !1); l(c) && !l(u) && (u = !1); let f = Xn(c, "x", ve.gx), d = Xn(c, "y", ve.gx), p = Xn(c, "w", ve.gx), g = Xn(c, "h", ve.gx), m = hi(t, "hotSpot", ve.kml), A = xg(m, "x"), C = xg(m, "y"), x = ts(m, "xunits"), T = ts(m, "yunits"), b = n.billboard; l(b) || (b = pfe(), n.billboard = b), b.image = u, b.scale = r, b.color = a, (l(f) || l(d) || l(p) || l(g)) && (b.imageSubRegion = new Ge(f, d, p, g)), l(s) && s !== 0 && (b.rotation = I.toRadians(-s), b.alignedAxis = h.UNIT_Z), r = y(r, 1); let S, D; l(A) && (x === "pixels" ? S = -A * r : x === "insetPixels" ? S = (A - Cg) * r : x === "fraction" && (S = -A * Cg * r), S += Cg * .5 * r), l(C) && (T === "pixels" ? D = C * r : T === "insetPixels" ? D = (-C + Cg) * r : T === "fraction" && (D = C * Cg * r), D -= Cg * .5 * r), (l(S) || l(D)) && (b.pixelOffset = new H(S, D)) } function f3(e, t, n, i, o) { for (let r = 0, s = t.childNodes.length; r < s; r++) { let a = t.childNodes.item(r); if (a.localName === "IconStyle") pXe(e, a, n, i, o); else if (a.localName === "LabelStyle") { let c = n.label; l(c) || (c = _fe(), n.label = c), c.scale = y(Xn(a, "scale", ve.kml), c.scale), c.fillColor = y(ky(a, "color", ve.kml), c.fillColor), c.text = n.name } else if (a.localName === "LineStyle") { let c = n.polyline; l(c) || (c = new ec, n.polyline = c), c.width = Xn(a, "width", ve.kml), c.material = ky(a, "color", ve.kml), l(ky(a, "outerColor", ve.gx)) && Pt("kml-gx:outerColor", "KML - gx:outerColor is not supported in a LineStyle"), l(Xn(a, "outerWidth", ve.gx)) && Pt("kml-gx:outerWidth", "KML - gx:outerWidth is not supported in a LineStyle"), l(Xn(a, "physicalWidth", ve.gx)) && Pt("kml-gx:physicalWidth", "KML - gx:physicalWidth is not supported in a LineStyle"), l(td(a, "labelVisibility", ve.gx)) && Pt("kml-gx:labelVisibility", "KML - gx:labelVisibility is not supported in a LineStyle") } else if (a.localName === "PolyStyle") { let c = n.polygon; l(c) || (c = OW(), n.polygon = c), c.material = y(ky(a, "color", ve.kml), c.material), c.fill = y(td(a, "fill", ve.kml), c.fill), c.outline = y(td(a, "outline", ve.kml), c.outline) } else if (a.localName === "BalloonStyle") { let c = y(wW(Tn(a, "bgColor", ve.kml)), U.WHITE), u = y(wW(Tn(a, "textColor", ve.kml)), U.BLACK), f = Tn(a, "text", ve.kml); n.addProperty("balloonStyle"), n.balloonStyle = { bgColor: c, textColor: u, text: f } } else if (a.localName === "ListStyle") { let c = Tn(a, "listItemType", ve.kml); (c === "radioFolder" || c === "checkOffOnly") && Pt(`kml-listStyle-${c}`, `KML - Unsupported ListStyle with listItemType: ${c}`) } } } function _Xe(e, t, n, i, o) { let r = new Xo, s, a = -1, c = t.childNodes, u = c.length; for (let d = 0; d < u; d++) { let p = c[d]; (p.localName === "Style" || p.localName === "StyleMap") && (a = d) } if (a !== -1) { let d = c[a]; if (d.localName === "Style") f3(e, d, r, i, o); else { let p = ed(d, "Pair", ve.kml); for (let g = 0; g < p.length; g++) { let m = p[g], A = Tn(m, "key", ve.kml); if (A === "normal") { let C = Tn(m, "styleUrl", ve.kml); if (l(C)) s = n.getById(C), l(s) || (s = n.getById(`#${C}`)), l(s) && r.merge(s); else { let x = hi(m, "Style", ve.kml); f3(e, x, r, i, o) } } else Pt(`kml-styleMap-${A}`, `KML - Unsupported StyleMap key: ${A}`) } } } let f = Tn(t, "styleUrl", ve.kml); if (l(f)) { let d = f; if (f[0] !== "#" && f.indexOf("#") !== -1) { let p = f.split("#"), g = p[0]; d = `${i.getDerivedResource({ url: g }).getUrlComponent()}#${p[1]}` } s = n.getById(d), l(s) || (s = n.getById(`#${d}`)), l(s) && r.merge(s) } return r } function gXe(e, t, n) { return t.fetchXML().then(function (i) { return gfe(e, i, n, t, !0) }) } function gfe(e, t, n, i, o, r) { let s, a, c, u, f = cfe(t, "Style", ve.kml); if (l(f)) { let A = f.length; for (s = 0; s < A; s++)u = f[s], a = ts(u, "id"), l(a) && (a = `#${a}`, o && l(i) && (a = i.getUrlComponent() + a), l(n.getById(a)) || (c = new Xo({ id: a }), n.add(c), f3(e, u, c, i, r))) } let d = cfe(t, "StyleMap", ve.kml); if (l(d)) { let A = d.length; for (s = 0; s < A; s++) { let C = d[s]; if (a = ts(C, "id"), l(a)) { let x = ed(C, "Pair", ve.kml); for (let T = 0; T < x.length; T++) { let b = x[T], S = Tn(b, "key", ve.kml); if (S === "normal") { if (a = `#${a}`, o && l(i) && (a = i.getUrlComponent() + a), !l(n.getById(a))) { c = n.getOrCreateEntity(a); let D = Tn(b, "styleUrl", ve.kml); if (l(D)) { D[0] !== "#" && (D = `#${D}`), o && l(i) && (D = i.getUrlComponent() + D); let P = n.getById(D); l(P) && c.merge(P) } else u = hi(b, "Style", ve.kml), f3(e, u, c, i, r) } } else Pt(`kml-styleMap-${S}`, `KML - Unsupported StyleMap key: ${S}`) } } } } let p = [], g = t.getElementsByTagName("styleUrl"), m = g.length; for (s = 0; s < m; s++) { let A = g[s].textContent; if (A[0] !== "#") { let C = A.split("#"); if (C.length === 2) { let x = C[0], T = i.getDerivedResource({ url: x }); p.push(gXe(e, T, n)) } } } return p } function RW(e, t, n) { let i = new K_(e, t.id, ["position"]), o = new ip(t.position); t.polyline = l(n.polyline) ? n.polyline.clone() : new ec, t.polyline.positions = new Y_([i, o]) } function yfe(e, t) { return !l(e) && !l(t) || e === "clampToGround" ? ze.CLAMP_TO_GROUND : e === "relativeToGround" ? ze.RELATIVE_TO_GROUND : e === "absolute" ? ze.NONE : t === "clampToSeaFloor" ? (Pt("kml-gx:altitudeMode-clampToSeaFloor", "KML - <gx:altitudeMode>:clampToSeaFloor is currently not supported, using <kml:altitudeMode>:clampToGround."), ze.CLAMP_TO_GROUND) : t === "relativeToSeaFloor" ? (Pt("kml-gx:altitudeMode-relativeToSeaFloor", "KML - <gx:altitudeMode>:relativeToSeaFloor is currently not supported, using <kml:altitudeMode>:relativeToGround."), ze.RELATIVE_TO_GROUND) : (l(e) ? Pt("kml-altitudeMode-unknown", `KML - Unknown <kml:altitudeMode>:${e}, using <kml:altitudeMode>:CLAMP_TO_GROUND.`) : Pt("kml-gx:altitudeMode-unknown", `KML - Unknown <gx:altitudeMode>:${t}, using <kml:altitudeMode>:CLAMP_TO_GROUND.`), ze.CLAMP_TO_GROUND) } function yXe(e, t, n) { return n === "relativeToSeaFloor" || t === "absolute" || t === "relativeToGround" ? e : ((l(t) && t !== "clampToGround" || l(n) && n !== "clampToSeaFloor") && Pt("kml-altitudeMode-unknown", `KML - Unknown altitudeMode: ${y(t, n)}`), new ip(e)) } function AXe(e, t, n, i) { if (!l(e)) return; if (n === "relativeToSeaFloor" || t === "absolute" || t === "relativeToGround") return e; (l(t) && t !== "clampToGround" || l(n) && n !== "clampToSeaFloor") && Pt("kml-altitudeMode-unknown", `KML - Unknown altitudeMode: ${y(t, n)}`); let o = e.length; for (let r = 0; r < o; r++) { let s = e[r]; i.scaleToGeodeticSurface(s, s) } return e } function m3(e, t, n, i) { let o = t.label; l(o) || (o = l(n.label) ? n.label.clone() : _fe(), t.label = o), o.text = t.name; let r = t.billboard; l(r) || (r = l(n.billboard) ? n.billboard.clone() : pfe(), t.billboard = r), l(r.image) ? r.image.getValue() || (r.image = void 0) : r.image = e._pinBuilder.fromColor(U.YELLOW, 64); let s = 1; l(r.scale) && (s = r.scale.getValue(), s !== 0 ? o.pixelOffset = new H(s * 16 + 1, 0) : (o.pixelOffset = void 0, o.horizontalOrigin = void 0)), l(i) && e._clampToGround && (r.heightReference = i, o.heightReference = i) } function Afe(e, t) { let n = e.path; l(n) || (n = new Hp, n.leadTime = 0, e.path = n); let i = t.polyline; l(i) && (n.material = i.material, n.width = i.width) } function CXe(e, t, n, i, o) { let r = Tn(n, "coordinates", ve.kml), s = Tn(n, "altitudeMode", ve.kml), a = Tn(n, "altitudeMode", ve.gx), c = td(n, "extrude", ve.kml), u = e._ellipsoid, f = h3(r, u); return i.position = f, m3(e, i, o, yfe(s, a)), c && ED(s, a) && RW(t, i, o), !0 } function lfe(e, t, n, i, o) { let r = hi(n, "coordinates", ve.kml), s = Tn(n, "altitudeMode", ve.kml), a = Tn(n, "altitudeMode", ve.gx), c = td(n, "extrude", ve.kml), u = td(n, "tessellate", ve.kml), f = ED(s, a), d = Xn(n, "drawOrder", ve.gx), p = e._ellipsoid, g = u3(r, p), m = o.polyline; if (f && c) { let A = new Gp; i.wall = A, A.positions = g; let C = o.polygon; l(C) && (A.fill = C.fill, A.material = C.material), A.outline = !0, l(m) ? (A.outlineColor = l(m.material) ? m.material.color : U.WHITE, A.outlineWidth = m.width) : l(C) && (A.outlineColor = l(C.material) ? C.material.color : U.WHITE) } else if (e._clampToGround && !f && u) { let A = new ec; A.clampToGround = !0, i.polyline = A, A.positions = g, l(m) ? (A.material = l(m.material) ? m.material.color.getValue(ke.MINIMUM_VALUE) : U.WHITE, A.width = y(m.width, 1)) : (A.material = U.WHITE, A.width = 1), A.zIndex = d } else l(d) && Pt("kml-gx:drawOrder", "KML - gx:drawOrder is not supported in LineStrings when clampToGround is false"), e._clampToGround && !u && Pt("kml-line-tesselate", "Ignoring clampToGround for KML lines without the tessellate flag."), m = l(m) ? m.clone() : new ec, i.polyline = m, m.positions = AXe(g, s, a, p), (!u || f) && (m.arcType = Yt.NONE); return !0 } function xXe(e, t, n, i, o) { let r = hi(n, "outerBoundaryIs", ve.kml), s = hi(r, "LinearRing", ve.kml), a = hi(s, "coordinates", ve.kml), c = e._ellipsoid, u = u3(a, c), f = td(n, "extrude", ve.kml), d = Tn(n, "altitudeMode", ve.kml), p = Tn(n, "altitudeMode", ve.gx), g = ED(d, p), m = l(o.polygon) ? o.polygon.clone() : OW(), A = o.polyline; if (l(A) && (m.outlineColor = l(A.material) ? A.material.color : U.WHITE, m.outlineWidth = A.width), i.polygon = m, g ? (m.perPositionHeight = !0, m.extrudedHeight = f ? 0 : void 0) : e._clampToGround || (m.height = 0), l(u)) { let C = new Lc(u), x = ed(n, "innerBoundaryIs", ve.kml); for (let T = 0; T < x.length; T++) { s = ed(x[T], "LinearRing", ve.kml); for (let b = 0; b < s.length; b++)a = hi(s[b], "coordinates", ve.kml), u = u3(a, c), l(u) && C.holes.push(new Lc(u)) } m.hierarchy = C } return !0 } function TXe(e, t, n, i, o) { let r = Tn(n, "altitudeMode", ve.kml), s = Tn(n, "altitudeMode", ve.gx), a = ed(n, "coord", ve.gx), c = ed(n, "angles", ve.gx), u = ed(n, "when", ve.kml), f = td(n, "extrude", ve.kml), d = ED(r, s), p = e._ellipsoid; c.length > 0 && Pt("kml-gx:angles", "KML - gx:angles are not supported in gx:Tracks"); let g = Math.min(a.length, u.length), m = [], A = []; for (let x = 0; x < g; x++) { let T = h3(a[x].textContent, p); m.push(T), A.push($.fromIso8601(u[x].textContent)) } let C = new ea; return C.addSamples(A, m), i.position = C, m3(e, i, o, yfe(r, s)), Afe(i, o), i.availability = new Ir, u.length > 0 && i.availability.addInterval(new yn({ start: A[0], stop: A[A.length - 1] })), d && f && RW(t, i, o), !0 } function ufe(e, t, n, i, o, r, s, a, c) { let u = e[0], f = e[e.length - 1], d = new ea; d.addSamples(e, t), n.intervals.addInterval(new yn({ start: u, stop: f, isStartIncluded: c, isStopIncluded: c, data: yXe(d, s, a) })), i.addInterval(new yn({ start: u, stop: f, isStartIncluded: c, isStopIncluded: c })), o.intervals.addInterval(new yn({ start: u, stop: f, isStartIncluded: c, isStopIncluded: c, data: r })) } function EXe(e, t, n, i, o) { let r = td(n, "interpolate", ve.gx), s = ed(n, "Track", ve.gx), a, c, u, f = !1, d = new Q_, p = new Ir, g = new $s, m = e._ellipsoid; for (let A = 0, C = s.length; A < C; A++) { let x = s[A], T = ed(x, "when", ve.kml), b = ed(x, "coord", ve.gx), S = Tn(x, "altitudeMode", ve.kml), D = Tn(x, "altitudeMode", ve.gx), P = ED(S, D), B = td(x, "extrude", ve.kml), R = Math.min(b.length, T.length), M = []; a = []; for (let L = 0; L < R; L++) { let _ = h3(b[L].textContent, m); M.push(_), a.push($.fromIso8601(T[L].textContent)) } r && (l(c) && ufe([c, a[0]], [u, M[0]], g, p, d, !1, "absolute", void 0, !1), c = a[R - 1], u = M[M.length - 1]), ufe(a, M, g, p, d, P && B, S, D, !0), f = f || P && B } return i.availability = p, i.position = g, m3(e, i, o), Afe(i, o), f && (RW(t, i, o), i.polyline.show = d), !0 } var Cfe = { Point: CXe, LineString: lfe, LinearRing: lfe, Polygon: xXe, Track: TXe, MultiTrack: EXe, MultiGeometry: bXe, Model: SXe }; function bXe(e, t, n, i, o, r) { let s = n.childNodes, a = !1; for (let c = 0, u = s.length; c < u; c++) { let f = s.item(c), d = Cfe[f.localName]; if (l(d)) { let p = mfe(f, t, r); p.parent = i, p.name = i.name, p.availability = i.availability, p.description = i.description, p.kml = i.kml, d(e, t, f, p, o) && (a = !0) } } return a } function SXe(e, t, n, i, o) { return Pt("kml-unsupportedGeometry", `KML - Unsupported geometry: ${n.localName}`), !1 } function wXe(e, t) { let n = hi(e, "ExtendedData", ve.kml); if (!l(n)) return; l(hi(n, "SchemaData", ve.kml)) && Pt("kml-schemaData", "KML - SchemaData is unsupported"), l(ts(n, "xmlns:prefix")) && Pt("kml-extendedData", "KML - ExtendedData with xmlns:prefix is unsupported"); let i = {}, o = ed(n, "Data", ve.kml); if (l(o)) { let r = o.length; for (let s = 0; s < r; s++) { let a = o[s], c = ts(a, "name"); l(c) && (i[c] = { displayName: Tn(a, "displayName", ve.kml), value: Tn(a, "value", ve.kml) }) } } t.kml.extendedData = i } var io; typeof document < "u" && (io = document.createElement("div")); function DXe(e, t, n, i, o) { let r, s, a, c = t.kml, u = c.extendedData, f = Tn(e, "description", ve.kml), d = y(t.balloonStyle, n.balloonStyle), p = U.WHITE, g = U.BLACK, m = f; l(d) && (p = y(d.bgColor, U.WHITE), g = y(d.textColor, U.BLACK), m = y(d.text, f)); let A; if (l(m)) { if (m = m.replace("$[name]", y(t.name, "")), m = m.replace("$[description]", y(f, "")), m = m.replace("$[address]", y(c.address, "")), m = m.replace("$[Snippet]", y(c.snippet, "")), m = m.replace("$[id]", t.id), m = m.replace("$[geDirections]", ""), l(u)) { let T = m.match(/\$\[.+?\]/g); if (T !== null) for (r = 0; r < T.length; r++) { let b = T[r], S = b.substr(2, b.length - 3), D = /\/displayName$/.test(S); S = S.replace(/\/displayName$/, ""), A = u[S], l(A) && (A = D ? A.displayName : A.value), l(A) && (m = m.replace(b, y(A, ""))) } } } else if (l(u) && (a = Object.keys(u), a.length > 0)) { for (m = '<table class="cesium-infoBox-defaultTable cesium-infoBox-defaultTable-lighter"><tbody>', r = 0; r < a.length; r++)s = a[r], A = u[s], m += `<tr><th>${y(A.displayName, s)}</th><td>${y(A.value, "")}</td></tr>`; m += "</tbody></table>" } if (!l(m)) return; m = cXe.link(m), io.innerHTML = m; let C = io.querySelectorAll("a"); for (r = 0; r < C.length; r++)C[r].setAttribute("target", "_blank"); l(i) && i.keys.length > 1 && (Ml(io, "a", "href", i), Ml(io, "link", "href", i), Ml(io, "area", "href", i), Ml(io, "img", "src", i), Ml(io, "iframe", "src", i), Ml(io, "video", "src", i), Ml(io, "audio", "src", i), Ml(io, "source", "src", i), Ml(io, "track", "src", i), Ml(io, "input", "src", i), Ml(io, "embed", "src", i), Ml(io, "script", "src", i), Ml(io, "video", "poster", i)), Ll(io, "a", "href", o), Ll(io, "link", "href", o), Ll(io, "area", "href", o), Ll(io, "img", "src", o), Ll(io, "iframe", "src", o), Ll(io, "video", "src", o), Ll(io, "audio", "src", o), Ll(io, "source", "src", o), Ll(io, "track", "src", o), Ll(io, "input", "src", o), Ll(io, "embed", "src", o), Ll(io, "script", "src", o), Ll(io, "video", "poster", o); let x = '<div class="cesium-infoBox-description-lighter" style="'; x += "overflow:auto;", x += "word-wrap:break-word;", x += `background-color:${p.toCssColorString()};`, x += `color:${g.toCssColorString()};`, x += '">', x += `${io.innerHTML}</div>`, io.innerHTML = "", t.description = x } function p3(e, t, n) { let i = n.entityCollection, o = n.parentEntity, r = n.sourceResource, s = n.uriResolver, a = mfe(t, i, n.context), c = a.kml, u = _Xe(e, t, n.styleCollection, r, s), f = Tn(t, "name", ve.kml); a.name = f, a.parent = o; let d = mXe(t); l(d) || (d = hXe(t)), a.availability = d, FW(a); function p(b) { return b ? b.show && p(b.parent) : !0 } let g = td(t, "visibility", ve.kml); a.show = p(o) && y(g, !0); let m = hi(t, "author", ve.atom), A = c.author; A.name = Tn(m, "name", ve.atom), A.uri = Tn(m, "uri", ve.atom), A.email = Tn(m, "email", ve.atom); let C = hi(t, "link", ve.atom), x = c.link; x.href = ts(C, "href"), x.hreflang = ts(C, "hreflang"), x.rel = ts(C, "rel"), x.type = ts(C, "type"), x.title = ts(C, "title"), x.length = ts(C, "length"), c.address = Tn(t, "address", ve.kml), c.phoneNumber = Tn(t, "phoneNumber", ve.kml), c.snippet = Tn(t, "Snippet", ve.kml), wXe(t, a), DXe(t, a, u, s, r); let T = e._ellipsoid; return Efe(t, a, T), Tfe(t, a, T), l(hi(t, "Region", ve.kml)) && Pt("kml-region", "KML - Placemark Regions are unsupported"), { entity: a, styleEntity: u } } function xfe(e, t, n, i) { i.addNodes(t.childNodes, n), i.process() } function vXe(e, t, n, i) { let o = p3(e, t, n), r = tt(n); r.parentEntity = o.entity, xfe(e, t, r, i) } function PXe(e, t, n, i) { let o = p3(e, t, n), r = o.entity, s = o.styleEntity, a = !1, c = t.childNodes; for (let u = 0, f = c.length; u < f && !a; u++) { let d = c.item(u), p = Cfe[d.localName]; l(p) && (p(e, n.entityCollection, d, r, s, r.id), a = !0) } a || (r.merge(s), m3(e, r, s)) } var IXe = { FlyTo: RXe, Wait: BXe, SoundCue: EW, AnimatedUpdate: EW, TourControl: EW }; function OXe(e, t, n, i) { let o = Tn(t, "name", ve.kml), r = ts(t, "id"), s = new s3(o, r), a = hi(t, "Playlist", ve.gx); if (a) { let c = e._ellipsoid, u = a.childNodes; for (let f = 0; f < u.length; f++) { let d = u[f]; if (d.localName) { let p = IXe[d.localName]; p ? p(s, d, c) : console.log(`Unknown KML Tour playlist entry type ${d.localName}`) } } } e._kmlTours.push(s) } function EW(e, t) { Pt(`KML Tour unsupported node ${t.localName}`) } function BXe(e, t) { let n = Xn(t, "duration", ve.gx); e.addPlaylistEntry(new l3(n)) } function RXe(e, t, n) { let i = Xn(t, "duration", ve.gx), o = Tn(t, "flyToMode", ve.gx), r = { kml: {} }; Efe(t, r, n), Tfe(t, r, n); let s = r.kml.lookAt || r.kml.camera, a = new c3(i, o, s); e.addPlaylistEntry(a) } function Tfe(e, t, n) { let i = hi(e, "Camera", ve.kml); if (l(i)) { let o = y(Xn(i, "longitude", ve.kml), 0), r = y(Xn(i, "latitude", ve.kml), 0), s = y(Xn(i, "altitude", ve.kml), 0), a = y(Xn(i, "heading", ve.kml), 0), c = y(Xn(i, "tilt", ve.kml), 0), u = y(Xn(i, "roll", ve.kml), 0), f = h.fromDegrees(o, r, s, n), d = lf.fromDegrees(a, c - 90, u); t.kml.camera = new i3(f, d) } } function Efe(e, t, n) { let i = hi(e, "LookAt", ve.kml); if (l(i)) { let o = y(Xn(i, "longitude", ve.kml), 0), r = y(Xn(i, "latitude", ve.kml), 0), s = y(Xn(i, "altitude", ve.kml), 0), a = Xn(i, "heading", ve.kml), c = Xn(i, "tilt", ve.kml), u = y(Xn(i, "range", ve.kml), 0); c = I.toRadians(y(c, 0)), a = I.toRadians(y(a, 0)); let f = new ku(a, c - I.PI_OVER_TWO, u), d = h.fromDegrees(o, r, s, n); t.kml.lookAt = new o3(d, f) } } function MXe(e, t, n, i) { let o = n.screenOverlayContainer; if (!l(o)) return; let r = n.sourceResource, s = n.uriResolver, a = hi(t, "Icon", ve.kml), c = BW(a, e, r, s, !1); if (!l(c)) return; let u = document.createElement("img"); e._screenOverlays.push(u), u.src = c.url, u.onload = function () { let f = ["position: absolute"], d = hi(t, "screenXY", ve.kml), p = hi(t, "overlayXY", ve.kml), g = hi(t, "size", ve.kml), m, A, C, x, T, b; l(g) && (m = xg(g, "x"), A = xg(g, "y"), C = ts(g, "xunits"), x = ts(g, "yunits"), l(m) && m !== -1 && m !== 0 && (C === "fraction" ? T = `width: ${Math.floor(m * 100)}%` : C === "pixels" && (T = `width: ${m}px`), f.push(T)), l(A) && A !== -1 && A !== 0 && (x === "fraction" ? b = `height: ${Math.floor(A * 100)}%` : x === "pixels" && (b = `height: ${A}px`), f.push(b))), u.style = f.join(";"); let S = 0, D = u.height; l(p) && (m = xg(p, "x"), A = xg(p, "y"), C = ts(p, "xunits"), x = ts(p, "yunits"), l(m) && (C === "fraction" ? S = m * u.width : (C === "pixels" || C === "insetPixels") && (S = m)), l(A) && (x === "fraction" ? D = A * u.height : (x === "pixels" || x === "insetPixels") && (D = A))), l(d) && (m = xg(d, "x"), A = xg(d, "y"), C = ts(d, "xunits"), x = ts(d, "yunits"), l(m) && (C === "fraction" ? T = `left: calc(${Math.floor(m * 100)}% - ${S}px)` : C === "pixels" ? T = `left: ${m - S}px` : C === "insetPixels" && (T = `right: ${m - S}px`), f.push(T)), l(A) && (x === "fraction" ? b = `bottom: calc(${Math.floor(A * 100)}% - ${D}px)` : x === "pixels" ? b = `bottom: ${A - D}px` : x === "insetPixels" && (b = `top: ${A - D}px`), f.push(b))), u.style = f.join(";") }, o.appendChild(u) } function LXe(e, t, n, i) { let r = p3(e, t, n).entity, s, a = !1, c = e._ellipsoid, u = u3(hi(t, "LatLonQuad", ve.gx), c), f = Xn(t, "drawOrder", ve.kml); if (l(u)) s = OW(), s.hierarchy = new Lc(u), s.zIndex = f, r.polygon = s, a = !0; else { s = new Ld, s.zIndex = f, r.rectangle = s; let m = hi(t, "LatLonBox", ve.kml); if (l(m)) { let A = Xn(m, "west", ve.kml), C = Xn(m, "south", ve.kml), x = Xn(m, "east", ve.kml), T = Xn(m, "north", ve.kml); l(A) && (A = I.negativePiToPi(I.toRadians(A))), l(C) && (C = I.clampToLatitudeRange(I.toRadians(C))), l(x) && (x = I.negativePiToPi(I.toRadians(x))), l(T) && (T = I.clampToLatitudeRange(I.toRadians(T))), s.coordinates = new ce(A, C, x, T); let b = Xn(m, "rotation", ve.kml); if (l(b)) { let S = I.toRadians(b); s.rotation = S, s.stRotation = S } } } let d = hi(t, "Icon", ve.kml), p = BW(d, e, n.sourceResource, n.uriResolver, !0); if (l(p)) { a && Pt("kml-gx:LatLonQuad", "KML - gx:LatLonQuad Icon does not support texture projection."); let m = Xn(d, "x", ve.gx), A = Xn(d, "y", ve.gx), C = Xn(d, "w", ve.gx), x = Xn(d, "h", ve.gx); (l(m) || l(A) || l(C) || l(x)) && Pt("kml-groundOverlay-xywh", "KML - gx:x, gx:y, gx:w, gx:h aren't supported for GroundOverlays"), s.material = p, s.material.color = ky(t, "color", ve.kml), s.material.transparent = !0 } else s.material = ky(t, "color", ve.kml); let g = Tn(t, "altitudeMode", ve.kml); l(g) ? g === "absolute" ? (s.height = Xn(t, "altitude", ve.kml), s.zIndex = void 0) : g !== "clampToGround" && Pt("kml-altitudeMode-unknown", `KML - Unknown altitudeMode: ${g}`) : (g = Tn(t, "altitudeMode", ve.gx), g === "relativeToSeaFloor" ? (Pt("kml-altitudeMode-relativeToSeaFloor", "KML - altitudeMode relativeToSeaFloor is currently not supported, treating as absolute."), s.height = Xn(t, "altitude", ve.kml), s.zIndex = void 0) : g === "clampToSeaFloor" ? Pt("kml-altitudeMode-clampToSeaFloor", "KML - altitudeMode clampToSeaFloor is currently not supported, treating as clampToGround.") : l(g) && Pt("kml-altitudeMode-unknown", `KML - Unknown altitudeMode: ${g}`)) } function bfe(e, t, n, i) { e._unsupportedNode.raiseEvent(e, n.parentEntity, t, n.entityCollection, n.styleCollection, n.sourceResource, n.uriResolver), Pt(`kml-unsupportedFeature-${t.nodeName}`, `KML - Unsupported feature: ${t.nodeName}`) } var Tg = { INTERVAL: 0, EXPIRE: 1, STOP: 2 }; function d3(e) { if (!l(e) || e.length === 0) return ""; let t = e[0]; return (t === "&" || t === "?") && (e = e.substring(1)), e } var FXe = new ce, ZT = new he, bW = new H, NXe = new h; function MW(e, t, n, i, o, r) { function s(u) { return u < -I.PI_OVER_TWO ? -I.PI_OVER_TWO : u > I.PI_OVER_TWO ? I.PI_OVER_TWO : u } function a(u) { return u > I.PI ? u - I.TWO_PI : u < -I.PI ? u + I.TWO_PI : u } let c = KA(e.queryParameters); if (c = c.replace(/%5B/g, "[").replace(/%5D/g, "]"), l(t) && t._mode !== ee.MORPHING) { let u, f; if (o = y(o, FXe), l(n) && (bW.x = n.clientWidth * .5, bW.y = n.clientHeight * .5, u = t.pickEllipsoid(bW, r, NXe)), l(u) ? f = r.cartesianToCartographic(u, ZT) : (f = ce.center(o, ZT), u = r.cartographicToCartesian(f)), l(i) && !I.equalsEpsilon(i, 1, I.EPSILON9)) { let x = o.width * i * .5, T = o.height * i * .5; o = new ce(a(f.longitude - x), s(f.latitude - T), a(f.longitude + x), s(f.latitude + T)) } c = c.replace("[bboxWest]", I.toDegrees(o.west).toString()), c = c.replace("[bboxSouth]", I.toDegrees(o.south).toString()), c = c.replace("[bboxEast]", I.toDegrees(o.east).toString()), c = c.replace("[bboxNorth]", I.toDegrees(o.north).toString()); let d = I.toDegrees(f.longitude).toString(), p = I.toDegrees(f.latitude).toString(); c = c.replace("[lookatLon]", d), c = c.replace("[lookatLat]", p), c = c.replace("[lookatTilt]", I.toDegrees(t.pitch).toString()), c = c.replace("[lookatHeading]", I.toDegrees(t.heading).toString()), c = c.replace("[lookatRange]", h.distance(t.positionWC, u)), c = c.replace("[lookatTerrainLon]", d), c = c.replace("[lookatTerrainLat]", p), c = c.replace("[lookatTerrainAlt]", f.height.toString()), r.cartesianToCartographic(t.positionWC, ZT), c = c.replace("[cameraLon]", I.toDegrees(ZT.longitude).toString()), c = c.replace("[cameraLat]", I.toDegrees(ZT.latitude).toString()), c = c.replace("[cameraAlt]", I.toDegrees(ZT.height).toString()); let g = t.frustum, m = g.aspectRatio, A = "", C = ""; if (l(m)) { let x = I.toDegrees(g.fov); m > 1 ? (A = x, C = x / m) : (C = x, A = x * m) } c = c.replace("[horizFov]", A.toString()), c = c.replace("[vertFov]", C.toString()) } else c = c.replace("[bboxWest]", "-180"), c = c.replace("[bboxSouth]", "-90"), c = c.replace("[bboxEast]", "180"), c = c.replace("[bboxNorth]", "90"), c = c.replace("[lookatLon]", ""), c = c.replace("[lookatLat]", ""), c = c.replace("[lookatRange]", ""), c = c.replace("[lookatTilt]", ""), c = c.replace("[lookatHeading]", ""), c = c.replace("[lookatTerrainLon]", ""), c = c.replace("[lookatTerrainLat]", ""), c = c.replace("[lookatTerrainAlt]", ""), c = c.replace("[cameraLon]", ""), c = c.replace("[cameraLat]", ""), c = c.replace("[cameraAlt]", ""), c = c.replace("[horizFov]", ""), c = c.replace("[vertFov]", ""); l(n) ? (c = c.replace("[horizPixels]", n.clientWidth), c = c.replace("[vertPixels]", n.clientHeight)) : (c = c.replace("[horizPixels]", ""), c = c.replace("[vertPixels]", "")), c = c.replace("[terrainEnabled]", "1"), c = c.replace("[clientVersion]", "1"), c = c.replace("[kmlVersion]", "2.2"), c = c.replace("[clientName]", "Cesium"), c = c.replace("[language]", "English"), e.setQueryParameters($l(c)) } function VXe(e, t, n, i) { let r = p3(e, t, n).entity, s = n.sourceResource, a = n.uriResolver, c = hi(t, "Link", ve.kml); if (l(c) || (c = hi(t, "Url", ve.kml)), l(c)) { let u = Tn(c, "href", ve.kml), f, d; if (l(u)) { let p = u; if (u = IW(u, s, n.uriResolver), /^data:/.test(u.getUrlComponent())) /\.kmz/i.test(s.getUrlComponent()) || (p = s.getDerivedResource({ url: p })); else { if (p = u.clone(), f = Tn(c, "viewRefreshMode", ve.kml), f === "onRegion") { Pt("kml-refrehMode-onRegion", "KML - Unsupported viewRefreshMode: onRegion"); return } d = y(Tn(c, "viewBoundScale", ve.kml), 1); let C = f === "onStop" ? "BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]" : "", x = y(Tn(c, "viewFormat", ve.kml), C), T = Tn(c, "httpQuery", ve.kml); l(x) && u.setQueryParameters($l(d3(x))), l(T) && u.setQueryParameters($l(d3(T))); let b = e._ellipsoid; MW(u, e.camera, e.canvas, d, e._lastCameraView.bbox, b) } let g = { sourceUri: p, uriResolver: a, context: r.id, screenOverlayContainer: n.screenOverlayContainer }, m = new vs, A = LW(e, m, u, g).then(function (C) { let x = e._entityCollection, T = m.values; x.suspendEvents(); for (let D = 0; D < T.length; D++) { let P = T[D]; l(P.parent) || (P.parent = r, FW(P)), x.add(P) } x.resumeEvents(); let b = Tn(c, "refreshMode", ve.kml), S = y(Xn(c, "refreshInterval", ve.kml), 0); if (b === "onInterval" && S > 0 || b === "onExpire" || f === "onStop") { let D = hi(C, "NetworkLinkControl", ve.kml), P = l(D), B = $.now(), R = { id: Nn(), href: u, cookie: {}, lastUpdated: B, updating: !1, entity: r, viewBoundScale: d, needsUpdate: !1, cameraUpdateTime: B }, M = 0; if (P && (R.cookie = $l(y(Tn(D, "cookie", ve.kml), "")), M = y(Xn(D, "minRefreshPeriod", ve.kml), 0)), b === "onInterval") P && (S = Math.max(M, S)), R.refreshMode = Tg.INTERVAL, R.time = S; else if (b === "onExpire") { let L; if (P && (L = Tn(D, "expires", ve.kml)), l(L)) try { let _ = $.fromIso8601(L), E = $.secondsDifference(_, B); E > 0 && E < M && $.addSeconds(B, M, _), R.refreshMode = Tg.EXPIRE, R.time = _ } catch { Pt("kml-refreshMode-onInterval-onExpire", "KML - NetworkLinkControl expires is not a valid date") } else Pt("kml-refreshMode-onExpire", "KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element") } else l(e.camera) ? (R.refreshMode = Tg.STOP, R.time = y(Xn(c, "viewRefreshTime", ve.kml), 0)) : Pt("kml-refrehMode-onStop-noCamera", "A NetworkLink with viewRefreshMode=onStop requires the `camera` property to be defined."); l(R.refreshMode) && e._networkLinks.set(R.id, R) } }).catch(function (C) { Pt(`An error occured during loading ${u.url}`), e._error.raiseEvent(e, C) }); i.addPromise(A) } } } function kXe(e, t, n, i) { let o = PW[t.localName]; return l(o) ? o(e, t, n, i) : bfe(e, t, n, i) } function DW(e, t, n, i, o, r, s) { t.removeAll(); let a = n.documentElement, c = a.localName === "Document" ? a : hi(a, "Document", ve.kml), u = Tn(c, "name", ve.kml); l(u) || (u = q_(i.getUrlComponent())), l(e._name) || (e._name = u); let f = new Fl._DeferredLoading(e), d = new vs(e); return Promise.all(gfe(e, n, d, i, !1, o)).then(function () { let p = n.documentElement; if (p.localName === "kml") { let m = p.childNodes; for (let A = 0; A < m.length; A++) { let C = m[A]; if (l(PW[C.localName])) { p = C; break } } } let g = { parentEntity: void 0, entityCollection: t, styleCollection: d, sourceResource: i, uriResolver: o, context: s, screenOverlayContainer: r }; return t.suspendEvents(), kXe(e, p, g, f), t.resumeEvents(), f.wait().then(function () { return n.documentElement }) }) } function UXe(e, t, n, i, o) { let r = Jt("ThirdParty/Workers/z-worker-pako.js"); NT({ workerScripts: { deflate: [r, "./pako_deflate.min.js"], inflate: [r, "./pako_inflate.min.js"] } }); let s = new v2(new Ly(n)); return Promise.resolve(s.getEntries()).then(function (a) { let c = [], u = {}, f; for (let d = 0; d < a.length; d++) { let p = a[d]; p.directory || (/\.kml$/i.test(p.filename) && (!l(f) || !/\//i.test(p.filename)) ? (l(f) && c.push(TW(f, u)), f = p) : c.push(TW(p, u))) } return l(f) && c.push(dXe(f, u)), Promise.all(c).then(function () { if (s.close(), !l(u.kml)) throw new fe("KMZ file does not contain a KML document."); return u.keys = Object.keys(u), DW(e, t, u.kml, i, u, o) }) }) } function LW(e, t, n, i) { i = y(i, y.EMPTY_OBJECT); let o = i.sourceUri, r = i.uriResolver, s = i.context, a = i.screenOverlayContainer, c = n; if (typeof n == "string" || n instanceof Pe) { n = Pe.createIfNeeded(n), c = n.fetchBlob(), o = y(o, n.clone()); let u = e._resourceCredits, f = n.credits; if (l(f)) { let d = f.length; for (let p = 0; p < d; p++)u.push(f[p]) } } else o = y(o, Pe.DEFAULT.clone()); return o = Pe.createIfNeeded(o), l(a) && (a = vn(a)), Promise.resolve(c).then(function (u) { return u instanceof Blob ? uXe(u).then(function (f) { return f ? UXe(e, t, u, o, a) : fXe(u).then(function (d) { d = dfe(d), d = hfe(d); let p, g; try { p = vW.parseFromString(d, "application/xml") } catch (m) { g = m.toString() } if (l(g) || p.body || p.documentElement.tagName === "parsererror") { let m = l(g) ? g : p.documentElement.firstChild.nodeValue; throw m || (m = p.body.innerText), new fe(m) } return DW(e, t, p, o, r, a, s) }) }) : DW(e, t, u, o, r, a, s) }).catch(function (u) { return e._error.raiseEvent(e, u), console.log(u), Promise.reject(u) }) } function Fl(e) { e = y(e, y.EMPTY_OBJECT); let t = e.camera, n = e.canvas; this._changed = new _e, this._error = new _e, this._loading = new _e, this._refresh = new _e, this._unsupportedNode = new _e, this._clock = void 0, this._entityCollection = new vs(this), this._name = void 0, this._isLoading = !1, this._pinBuilder = new pg, this._networkLinks = new Ct, this._entityCluster = new Iu, this.canvas = n, this.camera = t, this._lastCameraView = { position: l(t) ? h.clone(t.positionWC) : void 0, direction: l(t) ? h.clone(t.directionWC) : void 0, up: l(t) ? h.clone(t.upWC) : void 0, bbox: l(t) ? t.computeViewRectangle() : ce.clone(ce.MAX_VALUE) }, this._ellipsoid = y(e.ellipsoid, ie.WGS84); let i = e.credit; typeof i == "string" && (i = new Xt(i)), this._credit = i, this._resourceCredits = [], this._kmlTours = [], this._screenOverlays = [] } Fl.load = function (e, t) { return t = y(t, y.EMPTY_OBJECT), new Fl(t).load(e, t) }; Object.defineProperties(Fl.prototype, { name: { get: function () { return this._name }, set: function (e) { this._name !== e && (this._name = e, this._changed.raiseEvent(this)) } }, clock: { get: function () { return this._clock } }, entities: { get: function () { return this._entityCollection } }, isLoading: { get: function () { return this._isLoading } }, changedEvent: { get: function () { return this._changed } }, errorEvent: { get: function () { return this._error } }, loadingEvent: { get: function () { return this._loading } }, refreshEvent: { get: function () { return this._refresh } }, unsupportedNodeEvent: { get: function () { return this._unsupportedNode } }, show: { get: function () { return this._entityCollection.show }, set: function (e) { this._entityCollection.show = e } }, clustering: { get: function () { return this._entityCluster }, set: function (e) { this._entityCluster = e } }, credit: { get: function () { return this._credit } }, kmlTours: { get: function () { return this._kmlTours } } }); Fl.prototype.load = function (e, t) { t = y(t, y.EMPTY_OBJECT), Or.setLoading(this, !0); let n = this._name; this._name = void 0, this._clampToGround = y(t.clampToGround, !1); let i = this; return LW(this, this._entityCollection, e, t).then(function () { let o, r = i._entityCollection.computeAvailability(), s = r.start, a = r.stop, c = $.equals(s, ke.MINIMUM_VALUE), u = $.equals(a, ke.MAXIMUM_VALUE); if (!c || !u) { let d; c && (d = new Date, d.setHours(0, 0, 0, 0), s = $.fromDate(d)), u && (d = new Date, d.setHours(24, 0, 0, 0), a = $.fromDate(d)), o = new ah, o.startTime = s, o.stopTime = a, o.currentTime = $.clone(s), o.clockRange = Br.LOOP_STOP, o.clockStep = uo.SYSTEM_CLOCK_MULTIPLIER, o.multiplier = Math.round(Math.min(Math.max($.secondsDifference(a, s) / 60, 1), 31556900)) } let f = !1; return o !== i._clock && (i._clock = o, f = !0), n !== i._name && (f = !0), f && i._changed.raiseEvent(i), Or.setLoading(i, !1), i }).catch(function (o) { return Or.setLoading(i, !1), i._error.raiseEvent(i, o), console.log(o), Promise.reject(o) }) }; Fl.prototype.destroy = function () { for (; this._screenOverlays.length > 0;)this._screenOverlays.pop().remove() }; function FW(e) { let t = e.parent; if (l(t)) { let n = t.availability; if (l(n)) { let i = e.availability; l(i) ? i.intersect(n) : e.availability = n } } } function zXe(e, t, n, i, o) { return function (r) { if (!i.contains(t.id)) return; let s = !1, a = hi(r, "NetworkLinkControl", ve.kml), c = l(a), u = 0; if (c) { if (l(hi(a, "Update", ve.kml))) { Pt("kml-networkLinkControl-update", "KML - NetworkLinkControl updates aren't supported."), t.updating = !1, i.remove(t.id); return } t.cookie = $l(y(Tn(a, "cookie", ve.kml), "")), u = y(Xn(a, "minRefreshPeriod", ve.kml), 0) } let f = $.now(), d = t.refreshMode; if (d === Tg.INTERVAL) l(a) && (t.time = Math.max(u, t.time)); else if (d === Tg.EXPIRE) { let B; if (l(a) && (B = Tn(a, "expires", ve.kml)), l(B)) try { let R = $.fromIso8601(B), M = $.secondsDifference(R, f); M > 0 && M < u && $.addSeconds(f, u, R), t.time = R } catch { Pt("kml-networkLinkControl-expires", "KML - NetworkLinkControl expires is not a valid date"), s = !0 } else Pt("kml-refreshMode-onExpire", "KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element"), s = !0 } let p = t.entity, g = e._entityCollection, m = n.values; function A(B) { g.remove(B); let R = B._children, M = R.length; for (let L = 0; L < M; ++L)A(R[L]) } g.suspendEvents(); let C = g.values.slice(), x; for (x = 0; x < C.length; ++x) { let B = C[x]; B.parent === p && (B.parent = void 0, A(B)) } for (g.resumeEvents(), g.suspendEvents(), x = 0; x < m.length; x++) { let B = m[x]; l(B.parent) || (B.parent = p, FW(B)), g.add(B) } g.resumeEvents(), s ? i.remove(t.id) : t.lastUpdated = f; let T = g.computeAvailability(), b = T.start, S = T.stop, D = $.equals(b, ke.MINIMUM_VALUE), P = $.equals(S, ke.MAXIMUM_VALUE); if (!D || !P) { let B = e._clock; (B.startTime !== b || B.stopTime !== S) && (B.startTime = b, B.stopTime = S, e._changed.raiseEvent(e)) } t.updating = !1, t.needsUpdate = !1, e._refresh.raiseEvent(e, o.getUrlComponent(!0)) } } var SW = new Ct; Fl.prototype.update = function (e) { let t = this._networkLinks; if (t.length === 0) return !0; let n = $.now(), i = this; SW.removeAll(); function o(f) { let d = f._children, p = d.length; for (let g = 0; g < p; ++g) { let m = d[g]; SW.set(m.id, m), o(m) } } let r = !1, s = this._lastCameraView, a = this.camera; l(a) && !(a.positionWC.equalsEpsilon(s.position, I.EPSILON7) && a.directionWC.equalsEpsilon(s.direction, I.EPSILON7) && a.upWC.equalsEpsilon(s.up, I.EPSILON7)) && (s.position = h.clone(a.positionWC), s.direction = h.clone(a.directionWC), s.up = h.clone(a.upWC), s.bbox = a.computeViewRectangle(), r = !0); let c = new Ct, u = !1; return t.values.forEach(function (f) { let d = f.entity; if (!SW.contains(d.id)) { if (!f.updating) { let p = !1; if (f.refreshMode === Tg.INTERVAL ? $.secondsDifference(n, f.lastUpdated) > f.time && (p = !0) : f.refreshMode === Tg.EXPIRE ? $.greaterThan(n, f.time) && (p = !0) : f.refreshMode === Tg.STOP && (r && (f.needsUpdate = !0, f.cameraUpdateTime = n), f.needsUpdate && $.secondsDifference(n, f.cameraUpdateTime) >= f.time && (p = !0)), p) { o(d), f.updating = !0; let g = new vs, m = f.href.clone(); m.setQueryParameters(f.cookie); let A = y(i._ellipsoid, ie.WGS84); MW(m, i.camera, i.canvas, f.viewBoundScale, s.bbox, A), LW(i, g, m, { context: d.id }).then(zXe(i, f, g, c, m)).catch(function (C) { let x = `NetworkLink ${f.href} refresh failed: ${C}`; console.log(x), i._error.raiseEvent(i, x) }), u = !0 } } c.set(f.id, f) } }), u && (this._networkLinks = c, this._changed.raiseEvent(this)), !0 }; function HXe() { this.author = { name: void 0, uri: void 0, email: void 0 }, this.link = { href: void 0, hreflang: void 0, rel: void 0, type: void 0, title: void 0, length: void 0 }, this.address = void 0, this.phoneNumber = void 0, this.snippet = void 0, this.extendedData = void 0 } Fl._DeferredLoading = xh; Fl._getTimestamp = Ei; var _3 = Fl; function bD() { ye.throwInstantiationError() } bD.prototype.update = ye.throwInstantiationError; bD.prototype.getBoundingSphere = ye.throwInstantiationError; bD.prototype.isDestroyed = ye.throwInstantiationError; bD.prototype.destroy = ye.throwInstantiationError; var Sfe = bD; var QT = `attribute vec4 position;
attribute vec2 textureCoordinates;
varying vec2 v_textureCoordinates;
void main()
{
gl_Position = position;
v_textureCoordinates = textureCoordinates;
}
`; function g3(e) { this._context = e } var SD, GXe = new $e({ primitiveType: Oe.TRIANGLES }), WXe = new ti({ color: new U(0, 0, 0, 0) }); function jXe(e, t) { return new Js({ context: e, colorTextures: [t], destroyAttachments: !1 }) } function qXe(e, t) { return qt.fromCache({ context: e, vertexShaderSource: QT, fragmentShaderSource: t, attributeLocations: { position: 0, textureCoordinates: 1 } }) } function YXe(e, t) { return (!l(SD) || SD.viewport.width !== e || SD.viewport.height !== t) && (SD = Ve.fromCache({ viewport: new Ge(0, 0, e, t) })), SD } g3.prototype.execute = function (e) { l(e.preExecute) && e.preExecute(e); let t = e.outputTexture, n = t.width, i = t.height, o = this._context, r = l(e.vertexArray) ? e.vertexArray : o.getViewportQuadVertexArray(), s = l(e.shaderProgram) ? e.shaderProgram : qXe(o, e.fragmentShaderSource), a = jXe(o, t), c = YXe(n, i), u = e.uniformMap, f = WXe; f.framebuffer = a, f.renderState = c, f.execute(o); let d = GXe; d.vertexArray = r, d.renderState = c, d.shaderProgram = s, d.uniformMap = u, d.framebuffer = a, d.execute(o), a.destroy(), e.persists || (s.destroy(), l(e.vertexArray) && r.destroy()), l(e.postExecute) && e.postExecute(t) }; g3.prototype.isDestroyed = function () { return !1 }; g3.prototype.destroy = function () { return le(this) }; var y3 = g3; function XXe(e) { this.context = e, this.framebuffer = void 0, this.blendingEnabled = void 0, this.scissorTest = void 0, this.viewport = void 0 } var pc = XXe; function nd(e) { this._context = e, this._shaders = {}, this._numberOfShaders = 0, this._shadersToRelease = {} } Object.defineProperties(nd.prototype, { numberOfShaders: { get: function () { return this._numberOfShaders } } }); nd.prototype.replaceShaderProgram = function (e) { return l(e.shaderProgram) && e.shaderProgram.destroy(), this.getShaderProgram(e) }; function KXe(e) { let t = Object.keys(e).sort(); return JSON.stringify(e, t) } nd.prototype.getShaderProgram = function (e) { let t = e.vertexShaderSource, n = e.fragmentShaderSource, i = e.attributeLocations; typeof t == "string" && (t = new Ue({ sources: [t] })), typeof n == "string" && (n = new Ue({ sources: [n] })); let o = t.getCacheKey(), r = n.getCacheKey(), s = l(i) ? KXe(i) : "", a = `${o}:${r}:${s}`, c; if (l(this._shaders[a])) c = this._shaders[a], delete this._shadersToRelease[a]; else { let u = this._context, f = t.createCombinedVertexShader(u), d = n.createCombinedFragmentShader(u), p = new qt({ gl: u._gl, logShaderCompilation: u.logShaderCompilation, debugShaders: u.debugShaders, vertexShaderSource: t, vertexShaderText: f, fragmentShaderSource: n, fragmentShaderText: d, attributeLocations: i }); c = { cache: this, shaderProgram: p, keyword: a, derivedKeywords: [], count: 0 }, p._cachedShader = c, this._shaders[a] = c, ++this._numberOfShaders } return ++c.count, c.shaderProgram }; nd.prototype.replaceDerivedShaderProgram = function (e, t, n) { let i = e._cachedShader, o = t + i.keyword, r = this._shaders[o]; if (l(r)) { NW(this, r); let s = i.derivedKeywords.indexOf(t); s > -1 && i.derivedKeywords.splice(s, 1) } return this.createDerivedShaderProgram(e, t, n) }; nd.prototype.getDerivedShaderProgram = function (e, t) { let n = e._cachedShader, i = t + n.keyword, o = this._shaders[i]; if (!!l(o)) return o.shaderProgram }; nd.prototype.createDerivedShaderProgram = function (e, t, n) { let i = e._cachedShader, o = t + i.keyword, r = n.vertexShaderSource, s = n.fragmentShaderSource, a = n.attributeLocations; typeof r == "string" && (r = new Ue({ sources: [r] })), typeof s == "string" && (s = new Ue({ sources: [s] })); let c = this._context, u = r.createCombinedVertexShader(c), f = s.createCombinedFragmentShader(c), d = new qt({ gl: c._gl, logShaderCompilation: c.logShaderCompilation, debugShaders: c.debugShaders, vertexShaderSource: r, vertexShaderText: u, fragmentShaderSource: s, fragmentShaderText: f, attributeLocations: a }), p = { cache: this, shaderProgram: d, keyword: o, derivedKeywords: [], count: 0 }; return i.derivedKeywords.push(t), d._cachedShader = p, this._shaders[o] = p, d }; function NW(e, t) { let n = t.derivedKeywords, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o] + t.keyword, s = e._shaders[r]; NW(e, s) } delete e._shaders[t.keyword], t.shaderProgram.finalDestroy() } nd.prototype.destroyReleasedShaderPrograms = function () { let e = this._shadersToRelease; for (let t in e) if (e.hasOwnProperty(t)) { let n = e[t]; NW(this, n), --this._numberOfShaders } this._shadersToRelease = {} }; nd.prototype.releaseShaderProgram = function (e) { if (l(e)) { let t = e._cachedShader; t && --t.count === 0 && (this._shadersToRelease[t.keyword] = t) } }; nd.prototype.isDestroyed = function () { return !1 }; nd.prototype.destroy = function () { let e = this._shaders; for (let t in e) e.hasOwnProperty(t) && e[t].shaderProgram.finalDestroy(); return le(this) }; var A3 = nd; function Uy() { this._textures = {}, this._numberOfTextures = 0, this._texturesToRelease = {} } Object.defineProperties(Uy.prototype, { numberOfTextures: { get: function () { return this._numberOfTextures } } }); Uy.prototype.getTexture = function (e) { let t = this._textures[e]; if (!!l(t)) return delete this._texturesToRelease[e], ++t.count, t.texture }; Uy.prototype.addTexture = function (e, t) { let n = { texture: t, count: 1 }; t.finalDestroy = t.destroy; let i = this; t.destroy = function () { --n.count === 0 && (i._texturesToRelease[e] = n) }, this._textures[e] = n, ++this._numberOfTextures }; Uy.prototype.destroyReleasedTextures = function () { let e = this._texturesToRelease; for (let t in e) if (e.hasOwnProperty(t)) { let n = e[t]; delete this._textures[t], n.texture.finalDestroy(), --this._numberOfTextures } this._texturesToRelease = {} }; Uy.prototype.isDestroyed = function () { return !1 }; Uy.prototype.destroy = function () { let e = this._textures; for (let t in e) e.hasOwnProperty(t) && e[t].texture.finalDestroy(); return le(this) }; var C3 = Uy; var VW = {}; function JXe(e) { let t = 6.239996 + .0172019696544 * e; return .001657 * Math.sin(t + .01671 * Math.sin(t)) } var ZXe = 32.184, QXe = 2451545; function Wfe(e, t) { t = $.addSeconds(e, ZXe, t); let n = $.totalDays(t) - QXe; return t = $.addSeconds(t, JXe(n), t), t } var x3 = new $(2451545, 0, Hn.TAI), $Xe = 1e3, Wu = I.RADIANS_PER_DEGREE, Nl = I.RADIANS_PER_ARCSECOND, ia = 14959787e4, wfe = new Q; function jfe(e, t, n, i, o, r, s) { n < 0 && (n = -n, o += I.PI); let a = e * (1 - t), c = i - o, u = o, f = tKe(r - i, t), d = eKe(t, 0); sKe(c, n, u, wfe); let p = a * (1 + t), g = Math.cos(f), m = Math.sin(f), A = 1 + t * g, C = p / A; return l(s) ? (s.x = C * g, s.y = C * m, s.z = 0) : s = new h(C * g, C * m, 0), Q.multiplyByVector(wfe, s, s) } function eKe(e, t) { return e <= t ? "Circular" : e < 1 - t ? "Elliptical" : e <= 1 + t ? "Parabolic" : "Hyperbolic" } function tKe(e, t) { let n = oKe(e, t); return rKe(n, t) } var nKe = 50, iKe = I.EPSILON8; function oKe(e, t) { let n = Math.floor(e / I.TWO_PI); e -= n * I.TWO_PI; let i = e + t * Math.sin(e) / (1 - Math.sin(e + t) + Math.sin(e)), o = Number.MAX_VALUE, r; for (r = 0; r < nKe && Math.abs(o - i) > iKe; ++r) { o = i; let s = o - t * Math.sin(o) - e, a = 1 - t * Math.cos(o); i = o - s / a } return o = i + n * I.TWO_PI, o } function rKe(e, t) { let n = Math.floor(e / I.TWO_PI); e -= n * I.TWO_PI; let i = Math.cos(e) - t, o = Math.sin(e) * Math.sqrt(1 - t * t), r = Math.atan2(o, i); return r = I.zeroToTwoPi(r), e < 0 && (r -= I.TWO_PI), r += n * I.TWO_PI, r } function sKe(e, t, n, i) { let o = Math.cos(e), r = Math.sin(e), s = Math.cos(t), a = Math.sin(t), c = Math.cos(n), u = Math.sin(n); return l(i) ? (i[0] = c * o - u * r * s, i[1] = u * o + c * r * s, i[2] = r * a, i[3] = -c * r - u * o * s, i[4] = -u * r + c * o * s, i[5] = o * a, i[6] = u * a, i[7] = -c * a, i[8] = s) : i = new Q(c * o - u * r * s, -c * r - u * o * s, u * a, u * o + c * r * s, -u * r + c * o * s, -c * a, r * a, o * a, s), i } var aKe = 1.0000010178 * ia, cKe = 100.46645683 * Wu, lKe = 129597742283429e-5 * Nl, Dfe = 16002, vfe = 21863, Pfe = 32004, Ife = 10931, Ofe = 14529, Bfe = 16368, Rfe = 15318, Mfe = 32794, uKe = 64 * 1e-7 * ia, fKe = -152 * 1e-7 * ia, dKe = 62 * 1e-7 * ia, hKe = -8 * 1e-7 * ia, mKe = 32 * 1e-7 * ia, pKe = -41 * 1e-7 * ia, _Ke = 19 * 1e-7 * ia, gKe = -11 * 1e-7 * ia, yKe = -150 * 1e-7 * ia, AKe = -46 * 1e-7 * ia, CKe = 68 * 1e-7 * ia, xKe = 54 * 1e-7 * ia, TKe = 14 * 1e-7 * ia, EKe = 24 * 1e-7 * ia, bKe = -28 * 1e-7 * ia, SKe = 22 * 1e-7 * ia, Lfe = 10, Ffe = 16002, Nfe = 21863, Vfe = 10931, kfe = 1473, Ufe = 32004, zfe = 4387, Hfe = 73, wKe = -325 * 1e-7, DKe = -322 * 1e-7, vKe = -79 * 1e-7, PKe = 232 * 1e-7, IKe = -52 * 1e-7, OKe = 97 * 1e-7, BKe = 55 * 1e-7, RKe = -41 * 1e-7, MKe = -105 * 1e-7, LKe = -137 * 1e-7, FKe = 258 * 1e-7, NKe = 35 * 1e-7, VKe = -116 * 1e-7, kKe = -88 * 1e-7, UKe = -112 * 1e-7, zKe = -80 * 1e-7, $T = new $(0, 0, Hn.TAI); function HKe(e, t) { Wfe(e, $T); let i = ($T.dayNumber - x3.dayNumber + ($T.secondsOfDay - x3.secondsOfDay) / jn.SECONDS_PER_DAY) / (jn.DAYS_PER_JULIAN_CENTURY * 10), o = .3595362 * i, r = aKe + uKe * Math.cos(Dfe * o) + yKe * Math.sin(Dfe * o) + fKe * Math.cos(vfe * o) + AKe * Math.sin(vfe * o) + dKe * Math.cos(Pfe * o) + CKe * Math.sin(Pfe * o) + hKe * Math.cos(Ife * o) + xKe * Math.sin(Ife * o) + mKe * Math.cos(Ofe * o) + TKe * Math.sin(Ofe * o) + pKe * Math.cos(Bfe * o) + EKe * Math.sin(Bfe * o) + _Ke * Math.cos(Rfe * o) + bKe * Math.sin(Rfe * o) + gKe * Math.cos(Mfe * o) + SKe * Math.sin(Mfe * o), s = cKe + lKe * i + wKe * Math.cos(Lfe * o) + MKe * Math.sin(Lfe * o) + DKe * Math.cos(Ffe * o) + LKe * Math.sin(Ffe * o) + vKe * Math.cos(Nfe * o) + FKe * Math.sin(Nfe * o) + PKe * Math.cos(Vfe * o) + NKe * Math.sin(Vfe * o) + IKe * Math.cos(kfe * o) + VKe * Math.sin(kfe * o) + OKe * Math.cos(Ufe * o) + kKe * Math.sin(Ufe * o) + BKe * Math.cos(zfe * o) + UKe * Math.sin(zfe * o) + RKe * Math.cos(Hfe * o) + zKe * Math.sin(Hfe * o), a = .0167086342 - .0004203654 * i, c = 102.93734808 * Wu + 11612.3529 * Nl * i, u = 469.97289 * Nl * i, f = 174.87317577 * Wu - 8679.27034 * Nl * i; return jfe(r, a, u, c, f, s, t) } function qfe(e, t) { Wfe(e, $T); let i = ($T.dayNumber - x3.dayNumber + ($T.secondsOfDay - x3.secondsOfDay) / jn.SECONDS_PER_DAY) / jn.DAYS_PER_JULIAN_CENTURY, o = i * i, r = o * i, s = r * i, a = 383397.7725 + .004 * i, c = .055545526 - 16e-9 * i, u = 5.15668983 * Wu, f = -8e-5 * i + .02966 * o - 42e-6 * r - 13e-8 * s, d = 83.35324312 * Wu, p = 146434202669e-4 * i - 38.2702 * o - .045047 * r + 21301e-8 * s, g = 125.04455501 * Wu, m = -69679193631e-4 * i + 6.3602 * o + .007625 * r - 3586e-8 * s, A = 218.31664563 * Wu, C = 17325593434847e-4 * i - 6.391 * o + .006588 * r - 3169e-8 * s, x = 297.85019547 * Wu + Nl * (1602961601209e-3 * i - 6.3706 * o + .006593 * r - 3169e-8 * s), T = 93.27209062 * Wu + Nl * (17395272628478e-4 * i - 12.7512 * o - .001037 * r + 417e-8 * s), b = 134.96340251 * Wu + Nl * (17179159232178e-4 * i + 31.8792 * o + .051635 * r - 2447e-7 * s), S = 357.52910918 * Wu + Nl * (1295965810481e-4 * i - .5532 * o + 136e-6 * r - 1149e-8 * s), D = 310.17137918 * Wu - Nl * (6967051436e-3 * i + 6.2068 * o + .007618 * r - 3219e-8 * s), P = 2 * x, B = 4 * x, R = 6 * x, M = 2 * b, L = 3 * b, _ = 4 * b, E = 2 * T; a += 3400.4 * Math.cos(P) - 635.6 * Math.cos(P - b) - 235.6 * Math.cos(b) + 218.1 * Math.cos(P - S) + 181 * Math.cos(P + b), c += .014216 * Math.cos(P - b) + .008551 * Math.cos(P - M) - .001383 * Math.cos(b) + .001356 * Math.cos(P + b) - .001147 * Math.cos(B - L) - 914e-6 * Math.cos(B - M) + 869e-6 * Math.cos(P - S - b) - 627e-6 * Math.cos(P) - 394e-6 * Math.cos(B - _) + 282e-6 * Math.cos(P - S - M) - 279e-6 * Math.cos(x - b) - 236e-6 * Math.cos(M) + 231e-6 * Math.cos(B) + 229e-6 * Math.cos(R - _) - 201e-6 * Math.cos(M - E), f += 486.26 * Math.cos(P - E) - 40.13 * Math.cos(P) + 37.51 * Math.cos(E) + 25.73 * Math.cos(M - E) + 19.97 * Math.cos(P - S - E), p += -55609 * Math.sin(P - b) - 34711 * Math.sin(P - M) - 9792 * Math.sin(b) + 9385 * Math.sin(B - L) + 7505 * Math.sin(B - M) + 5318 * Math.sin(P + b) + 3484 * Math.sin(B - _) - 3417 * Math.sin(P - S - b) - 2530 * Math.sin(R - _) - 2376 * Math.sin(P) - 2075 * Math.sin(P - L) - 1883 * Math.sin(M) - 1736 * Math.sin(R - 5 * b) + 1626 * Math.sin(S) - 1370 * Math.sin(R - L), m += -5392 * Math.sin(P - E) - 540 * Math.sin(S) - 441 * Math.sin(P) + 423 * Math.sin(E) - 288 * Math.sin(M - E), C += -3332.9 * Math.sin(P) + 1197.4 * Math.sin(P - b) - 662.5 * Math.sin(S) + 396.3 * Math.sin(b) - 218 * Math.sin(P - S); let w = 2 * D, v = 3 * D; f += 46.997 * Math.cos(D) * i - .614 * Math.cos(P - E + D) * i + .614 * Math.cos(P - E - D) * i - .0297 * Math.cos(w) * o - .0335 * Math.cos(D) * o + .0012 * Math.cos(P - E + w) * o - 16e-5 * Math.cos(D) * r + 4e-5 * Math.cos(v) * r + 4e-5 * Math.cos(w) * r; let O = 2.116 * Math.sin(D) * i - .111 * Math.sin(P - E - D) * i - .0015 * Math.sin(D) * o; p += O, C += O, m += -520.77 * Math.sin(D) * i + 13.66 * Math.sin(P - E + D) * i + 1.12 * Math.sin(P - D) * i - 1.06 * Math.sin(E - D) * i + .66 * Math.sin(w) * o + .371 * Math.sin(D) * o - .035 * Math.sin(P - E + w) * o - .015 * Math.sin(P - E + D) * o + .0014 * Math.sin(D) * r - .0011 * Math.sin(v) * r - 9e-4 * Math.sin(w) * r, a *= $Xe; let V = u + f * Nl, z = d + p * Nl, k = A + C * Nl, G = g + m * Nl; return jfe(a, c, V, z, G, k, t) } var Gfe = .012300034, GKe = Gfe / (Gfe + 1) * -1; function WKe(e, t) { return t = qfe(e, t), h.multiplyByScalar(t, GKe, t) } var Yfe = new Q(1.0000000000000002, 5619723173785822e-31, 4690511510146299e-34, -5154129427414611e-31, .9174820620691819, -.39777715593191376, -223970096136568e-30, .39777715593191376, .9174820620691819), wD = new h; VW.computeSunPositionInEarthInertialFrame = function (e, t) { return l(e) || (e = $.now()), l(t) || (t = new h), wD = HKe(e, wD), t = h.negate(wD, t), WKe(e, wD), h.subtract(t, wD, t), Q.multiplyByVector(Yfe, t, t), t }; VW.computeMoonPositionInEarthInertialFrame = function (e, t) { return l(e) || (e = $.now()), t = qfe(e, t), Q.multiplyByVector(Yfe, t, t), t }; var zy = VW; function jKe(e) { e = y(e, y.EMPTY_OBJECT), this.color = U.clone(y(e.color, U.WHITE)), this.intensity = y(e.intensity, 2) } var Eg = jKe; function eE() { this.globeDepthTexture = void 0, this.gamma = void 0, this._viewport = new Ge, this._viewportCartesian4 = new se, this._viewportDirty = !1, this._viewportOrthographicMatrix = F.clone(F.IDENTITY), this._viewportTransformation = F.clone(F.IDENTITY), this._model = F.clone(F.IDENTITY), this._view = F.clone(F.IDENTITY), this._inverseView = F.clone(F.IDENTITY), this._projection = F.clone(F.IDENTITY), this._infiniteProjection = F.clone(F.IDENTITY), this._entireFrustum = new H, this._currentFrustum = new H, this._frustumPlanes = new se, this._farDepthFromNearPlusOne = void 0, this._log2FarDepthFromNearPlusOne = void 0, this._oneOverLog2FarDepthFromNearPlusOne = void 0, this._frameState = void 0, this._temeToPseudoFixed = Q.clone(F.IDENTITY), this._view3DDirty = !0, this._view3D = new F, this._inverseView3DDirty = !0, this._inverseView3D = new F, this._inverseModelDirty = !0, this._inverseModel = new F, this._inverseTransposeModelDirty = !0, this._inverseTransposeModel = new Q, this._viewRotation = new Q, this._inverseViewRotation = new Q, this._viewRotation3D = new Q, this._inverseViewRotation3D = new Q, this._inverseProjectionDirty = !0, this._inverseProjection = new F, this._modelViewDirty = !0, this._modelView = new F, this._modelView3DDirty = !0, this._modelView3D = new F, this._modelViewRelativeToEyeDirty = !0, this._modelViewRelativeToEye = new F, this._inverseModelViewDirty = !0, this._inverseModelView = new F, this._inverseModelView3DDirty = !0, this._inverseModelView3D = new F, this._viewProjectionDirty = !0, this._viewProjection = new F, this._inverseViewProjectionDirty = !0, this._inverseViewProjection = new F, this._modelViewProjectionDirty = !0, this._modelViewProjection = new F, this._inverseModelViewProjectionDirty = !0, this._inverseModelViewProjection = new F, this._modelViewProjectionRelativeToEyeDirty = !0, this._modelViewProjectionRelativeToEye = new F, this._modelViewInfiniteProjectionDirty = !0, this._modelViewInfiniteProjection = new F, this._normalDirty = !0, this._normal = new Q, this._normal3DDirty = !0, this._normal3D = new Q, this._inverseNormalDirty = !0, this._inverseNormal = new Q, this._inverseNormal3DDirty = !0, this._inverseNormal3D = new Q, this._encodedCameraPositionMCDirty = !0, this._encodedCameraPositionMC = new Vn, this._cameraPosition = new h, this._sunPositionWC = new h, this._sunPositionColumbusView = new h, this._sunDirectionWC = new h, this._sunDirectionEC = new h, this._moonDirectionEC = new h, this._lightDirectionWC = new h, this._lightDirectionEC = new h, this._lightColor = new h, this._lightColorHdr = new h, this._pass = void 0, this._mode = void 0, this._mapProjection = void 0, this._ellipsoid = void 0, this._cameraDirection = new h, this._cameraRight = new h, this._cameraUp = new h, this._frustum2DWidth = 0, this._eyeHeight = 0, this._eyeHeight2D = new H, this._pixelRatio = 1, this._orthographicIn3D = !1, this._backgroundColor = new U, this._brdfLut = void 0, this._environmentMap = void 0, this._sphericalHarmonicCoefficients = void 0, this._specularEnvironmentMaps = void 0, this._specularEnvironmentMapsDimensions = new H, this._specularEnvironmentMapsMaximumLOD = void 0, this._fogDensity = void 0, this._invertClassificationColor = void 0, this._splitPosition = 0, this._pixelSizePerMeter = void 0, this._geometricToleranceOverMeter = void 0, this._minimumDisableDepthTestDistance = void 0 } Object.defineProperties(eE.prototype, { frameState: { get: function () { return this._frameState } }, viewport: { get: function () { return this._viewport }, set: function (e) { if (!Ge.equals(e, this._viewport)) { Ge.clone(e, this._viewport); let t = this._viewport, n = this._viewportCartesian4; n.x = t.x, n.y = t.y, n.z = t.width, n.w = t.height, this._viewportDirty = !0 } } }, viewportCartesian4: { get: function () { return this._viewportCartesian4 } }, viewportOrthographic: { get: function () { return Xfe(this), this._viewportOrthographicMatrix } }, viewportTransformation: { get: function () { return Xfe(this), this._viewportTransformation } }, model: { get: function () { return this._model }, set: function (e) { F.clone(e, this._model), this._modelView3DDirty = !0, this._inverseModelView3DDirty = !0, this._inverseModelDirty = !0, this._inverseTransposeModelDirty = !0, this._modelViewDirty = !0, this._inverseModelViewDirty = !0, this._modelViewRelativeToEyeDirty = !0, this._inverseModelViewDirty = !0, this._modelViewProjectionDirty = !0, this._inverseModelViewProjectionDirty = !0, this._modelViewProjectionRelativeToEyeDirty = !0, this._modelViewInfiniteProjectionDirty = !0, this._normalDirty = !0, this._inverseNormalDirty = !0, this._normal3DDirty = !0, this._inverseNormal3DDirty = !0, this._encodedCameraPositionMCDirty = !0 } }, inverseModel: { get: function () { return this._inverseModelDirty && (this._inverseModelDirty = !1, F.inverse(this._model, this._inverseModel)), this._inverseModel } }, inverseTransposeModel: { get: function () { let e = this._inverseTransposeModel; return this._inverseTransposeModelDirty && (this._inverseTransposeModelDirty = !1, F.getMatrix3(this.inverseModel, e), Q.transpose(e, e)), e } }, view: { get: function () { return this._view } }, view3D: { get: function () { return kW(this), this._view3D } }, viewRotation: { get: function () { return kW(this), this._viewRotation } }, viewRotation3D: { get: function () { return kW(this), this._viewRotation3D } }, inverseView: { get: function () { return this._inverseView } }, inverseView3D: { get: function () { return Zfe(this), this._inverseView3D } }, inverseViewRotation: { get: function () { return this._inverseViewRotation } }, inverseViewRotation3D: { get: function () { return Zfe(this), this._inverseViewRotation3D } }, projection: { get: function () { return this._projection } }, inverseProjection: { get: function () { return tJe(this), this._inverseProjection } }, infiniteProjection: { get: function () { return this._infiniteProjection } }, modelView: { get: function () { return nJe(this), this._modelView } }, modelView3D: { get: function () { return iJe(this), this._modelView3D } }, modelViewRelativeToEye: { get: function () { return lJe(this), this._modelViewRelativeToEye } }, inverseModelView: { get: function () { return oJe(this), this._inverseModelView } }, inverseModelView3D: { get: function () { return rJe(this), this._inverseModelView3D } }, viewProjection: { get: function () { return sJe(this), this._viewProjection } }, inverseViewProjection: { get: function () { return aJe(this), this._inverseViewProjection } }, modelViewProjection: { get: function () { return cJe(this), this._modelViewProjection } }, inverseModelViewProjection: { get: function () { return uJe(this), this._inverseModelViewProjection } }, modelViewProjectionRelativeToEye: { get: function () { return fJe(this), this._modelViewProjectionRelativeToEye } }, modelViewInfiniteProjection: { get: function () { return dJe(this), this._modelViewInfiniteProjection } }, normal: { get: function () { return hJe(this), this._normal } }, normal3D: { get: function () { return mJe(this), this._normal3D } }, inverseNormal: { get: function () { return pJe(this), this._inverseNormal } }, inverseNormal3D: { get: function () { return _Je(this), this._inverseNormal3D } }, entireFrustum: { get: function () { return this._entireFrustum } }, currentFrustum: { get: function () { return this._currentFrustum } }, frustumPlanes: { get: function () { return this._frustumPlanes } }, farDepthFromNearPlusOne: { get: function () { return this._farDepthFromNearPlusOne } }, log2FarDepthFromNearPlusOne: { get: function () { return this._log2FarDepthFromNearPlusOne } }, oneOverLog2FarDepthFromNearPlusOne: { get: function () { return this._oneOverLog2FarDepthFromNearPlusOne } }, eyeHeight: { get: function () { return this._eyeHeight } }, eyeHeight2D: { get: function () { return this._eyeHeight2D } }, sunPositionWC: { get: function () { return this._sunPositionWC } }, sunPositionColumbusView: { get: function () { return this._sunPositionColumbusView } }, sunDirectionWC: { get: function () { return this._sunDirectionWC } }, sunDirectionEC: { get: function () { return this._sunDirectionEC } }, moonDirectionEC: { get: function () { return this._moonDirectionEC } }, lightDirectionWC: { get: function () { return this._lightDirectionWC } }, lightDirectionEC: { get: function () { return this._lightDirectionEC } }, lightColor: { get: function () { return this._lightColor } }, lightColorHdr: { get: function () { return this._lightColorHdr } }, encodedCameraPositionMCHigh: { get: function () { return Jfe(this), this._encodedCameraPositionMC.high } }, encodedCameraPositionMCLow: { get: function () { return Jfe(this), this._encodedCameraPositionMC.low } }, temeToPseudoFixedMatrix: { get: function () { return this._temeToPseudoFixed } }, pixelRatio: { get: function () { return this._pixelRatio } }, fogDensity: { get: function () { return this._fogDensity } }, geometricToleranceOverMeter: { get: function () { return this._geometricToleranceOverMeter } }, pass: { get: function () { return this._pass } }, backgroundColor: { get: function () { return this._backgroundColor } }, brdfLut: { get: function () { return this._brdfLut } }, environmentMap: { get: function () { return this._environmentMap } }, sphericalHarmonicCoefficients: { get: function () { return this._sphericalHarmonicCoefficients } }, specularEnvironmentMaps: { get: function () { return this._specularEnvironmentMaps } }, specularEnvironmentMapsDimensions: { get: function () { return this._specularEnvironmentMapsDimensions } }, specularEnvironmentMapsMaximumLOD: { get: function () { return this._specularEnvironmentMapsMaximumLOD } }, splitPosition: { get: function () { return this._splitPosition } }, minimumDisableDepthTestDistance: { get: function () { return this._minimumDisableDepthTestDistance } }, invertClassificationColor: { get: function () { return this._invertClassificationColor } }, orthographicIn3D: { get: function () { return this._orthographicIn3D } }, ellipsoid: { get: function () { return y(this._ellipsoid, ie.WGS84) } } }); function qKe(e, t) { F.clone(t, e._view), F.getMatrix3(t, e._viewRotation), e._view3DDirty = !0, e._inverseView3DDirty = !0, e._modelViewDirty = !0, e._modelView3DDirty = !0, e._modelViewRelativeToEyeDirty = !0, e._inverseModelViewDirty = !0, e._inverseModelView3DDirty = !0, e._viewProjectionDirty = !0, e._inverseViewProjectionDirty = !0, e._modelViewProjectionDirty = !0, e._modelViewProjectionRelativeToEyeDirty = !0, e._modelViewInfiniteProjectionDirty = !0, e._normalDirty = !0, e._inverseNormalDirty = !0, e._normal3DDirty = !0, e._inverseNormal3DDirty = !0 } function YKe(e, t) { F.clone(t, e._inverseView), F.getMatrix3(t, e._inverseViewRotation) } function XKe(e, t) { F.clone(t, e._projection), e._inverseProjectionDirty = !0, e._viewProjectionDirty = !0, e._inverseViewProjectionDirty = !0, e._modelViewProjectionDirty = !0, e._modelViewProjectionRelativeToEyeDirty = !0 } function KKe(e, t) { F.clone(t, e._infiniteProjection), e._modelViewInfiniteProjectionDirty = !0 } function JKe(e, t) { h.clone(t.positionWC, e._cameraPosition), h.clone(t.directionWC, e._cameraDirection), h.clone(t.rightWC, e._cameraRight), h.clone(t.upWC, e._cameraUp); let n = t.positionCartographic; l(n) ? e._eyeHeight = n.height : e._eyeHeight = -e._ellipsoid.maximumRadius, e._encodedCameraPositionMCDirty = !0 } var DD = new Q, ZKe = new he; function QKe(e, t) { l(It.computeIcrfToFixedMatrix(t.time, DD)) || (DD = It.computeTemeToPseudoFixedMatrix(t.time, DD)); let n = zy.computeSunPositionInEarthInertialFrame(t.time, e._sunPositionWC); Q.multiplyByVector(DD, n, n), h.normalize(n, e._sunDirectionWC), n = Q.multiplyByVector(e.viewRotation3D, n, e._sunDirectionEC), h.normalize(n, n), n = zy.computeMoonPositionInEarthInertialFrame(t.time, e._moonDirectionEC), Q.multiplyByVector(DD, n, n), Q.multiplyByVector(e.viewRotation3D, n, n), h.normalize(n, n); let i = t.mapProjection, r = i.ellipsoid.cartesianToCartographic(e._sunPositionWC, ZKe); i.project(r, e._sunPositionColumbusView) } eE.prototype.updateCamera = function (e) { qKe(this, e.viewMatrix), YKe(this, e.inverseViewMatrix), JKe(this, e), this._entireFrustum.x = e.frustum.near, this._entireFrustum.y = e.frustum.far, this.updateFrustum(e.frustum), this._orthographicIn3D = this._mode !== ee.SCENE2D && e.frustum instanceof Zt }; eE.prototype.updateFrustum = function (e) { XKe(this, e.projectionMatrix), l(e.infiniteProjectionMatrix) && KKe(this, e.infiniteProjectionMatrix), this._currentFrustum.x = e.near, this._currentFrustum.y = e.far, this._farDepthFromNearPlusOne = e.far - e.near + 1, this._log2FarDepthFromNearPlusOne = I.log2(this._farDepthFromNearPlusOne), this._oneOverLog2FarDepthFromNearPlusOne = 1 / this._log2FarDepthFromNearPlusOne, l(e._offCenterFrustum) && (e = e._offCenterFrustum), this._frustumPlanes.x = e.top, this._frustumPlanes.y = e.bottom, this._frustumPlanes.z = e.left, this._frustumPlanes.w = e.right }; eE.prototype.updatePass = function (e) { this._pass = e }; var $Ke = [], eJe = new Eg; eE.prototype.update = function (e) { this._mode = e.mode, this._mapProjection = e.mapProjection, this._ellipsoid = e.mapProjection.ellipsoid, this._pixelRatio = e.pixelRatio; let t = e.camera; this.updateCamera(t), e.mode === ee.SCENE2D ? (this._frustum2DWidth = t.frustum.right - t.frustum.left, this._eyeHeight2D.x = this._frustum2DWidth * .5, this._eyeHeight2D.y = this._eyeHeight2D.x * this._eyeHeight2D.x) : (this._frustum2DWidth = 0, this._eyeHeight2D.x = 0, this._eyeHeight2D.y = 0), QKe(this, e); let n = y(e.light, eJe); n instanceof Eg ? (this._lightDirectionWC = h.clone(this._sunDirectionWC, this._lightDirectionWC), this._lightDirectionEC = h.clone(this._sunDirectionEC, this._lightDirectionEC)) : (this._lightDirectionWC = h.normalize(h.negate(n.direction, this._lightDirectionWC), this._lightDirectionWC), this._lightDirectionEC = Q.multiplyByVector(this.viewRotation3D, this._lightDirectionWC, this._lightDirectionEC)); let i = n.color, o = h.fromElements(i.red, i.green, i.blue, this._lightColorHdr); o = h.multiplyByScalar(o, n.intensity, o); let r = h.maximumComponent(o); r > 1 ? h.divideByScalar(o, r, this._lightColor) : h.clone(o, this._lightColor); let s = e.brdfLutGenerator, a = l(s) ? s.colorTexture : void 0; this._brdfLut = a, this._environmentMap = y(e.environmentMap, e.context.defaultCubeMap), this._sphericalHarmonicCoefficients = y(e.sphericalHarmonicCoefficients, $Ke), this._specularEnvironmentMaps = e.specularEnvironmentMaps, this._specularEnvironmentMapsMaximumLOD = e.specularEnvironmentMapsMaximumLOD, l(this._specularEnvironmentMaps) && H.clone(this._specularEnvironmentMaps.dimensions, this._specularEnvironmentMapsDimensions), this._fogDensity = e.fog.density, this._invertClassificationColor = e.invertClassificationColor, this._frameState = e, this._temeToPseudoFixed = It.computeTemeToPseudoFixedMatrix(e.time, this._temeToPseudoFixed), this._splitPosition = e.splitPosition * e.context.drawingBufferWidth; let c = t.frustum.fov, u = this._viewport, f; l(c) ? u.height > u.width ? f = Math.tan(.5 * c) * 2 / u.height : f = Math.tan(.5 * c) * 2 / u.width : f = 1 / Math.max(u.width, u.height), this._geometricToleranceOverMeter = f * e.maximumScreenSpaceError, U.clone(e.backgroundColor, this._backgroundColor), this._minimumDisableDepthTestDistance = e.minimumDisableDepthTestDistance, this._minimumDisableDepthTestDistance *= this._minimumDisableDepthTestDistance, this._minimumDisableDepthTestDistance === Number.POSITIVE_INFINITY && (this._minimumDisableDepthTestDistance = -1) }; function Xfe(e) { if (e._viewportDirty) { let t = e._viewport; F.computeOrthographicOffCenter(t.x, t.x + t.width, t.y, t.y + t.height, 0, 1, e._viewportOrthographicMatrix), F.computeViewportTransformation(t, 0, 1, e._viewportTransformation), e._viewportDirty = !1 } } function tJe(e) { e._inverseProjectionDirty && (e._inverseProjectionDirty = !1, e._mode !== ee.SCENE2D && e._mode !== ee.MORPHING && !e._orthographicIn3D ? F.inverse(e._projection, e._inverseProjection) : F.clone(F.ZERO, e._inverseProjection)) } function nJe(e) { e._modelViewDirty && (e._modelViewDirty = !1, F.multiplyTransformation(e._view, e._model, e._modelView)) } function iJe(e) { e._modelView3DDirty && (e._modelView3DDirty = !1, F.multiplyTransformation(e.view3D, e._model, e._modelView3D)) } function oJe(e) { e._inverseModelViewDirty && (e._inverseModelViewDirty = !1, F.inverse(e.modelView, e._inverseModelView)) } function rJe(e) { e._inverseModelView3DDirty && (e._inverseModelView3DDirty = !1, F.inverse(e.modelView3D, e._inverseModelView3D)) } function sJe(e) { e._viewProjectionDirty && (e._viewProjectionDirty = !1, F.multiply(e._projection, e._view, e._viewProjection)) } function aJe(e) { e._inverseViewProjectionDirty && (e._inverseViewProjectionDirty = !1, F.inverse(e.viewProjection, e._inverseViewProjection)) } function cJe(e) { e._modelViewProjectionDirty && (e._modelViewProjectionDirty = !1, F.multiply(e._projection, e.modelView, e._modelViewProjection)) } function lJe(e) { if (e._modelViewRelativeToEyeDirty) { e._modelViewRelativeToEyeDirty = !1; let t = e.modelView, n = e._modelViewRelativeToEye; n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = 0, n[13] = 0, n[14] = 0, n[15] = t[15] } } function uJe(e) { e._inverseModelViewProjectionDirty && (e._inverseModelViewProjectionDirty = !1, F.inverse(e.modelViewProjection, e._inverseModelViewProjection)) } function fJe(e) { e._modelViewProjectionRelativeToEyeDirty && (e._modelViewProjectionRelativeToEyeDirty = !1, F.multiply(e._projection, e.modelViewRelativeToEye, e._modelViewProjectionRelativeToEye)) } function dJe(e) { e._modelViewInfiniteProjectionDirty && (e._modelViewInfiniteProjectionDirty = !1, F.multiply(e._infiniteProjection, e.modelView, e._modelViewInfiniteProjection)) } function hJe(e) { if (e._normalDirty) { e._normalDirty = !1; let t = e._normal; F.getMatrix3(e.inverseModelView, t), Q.getRotation(t, t), Q.transpose(t, t) } } function mJe(e) { if (e._normal3DDirty) { e._normal3DDirty = !1; let t = e._normal3D; F.getMatrix3(e.inverseModelView3D, t), Q.getRotation(t, t), Q.transpose(t, t) } } function pJe(e) { e._inverseNormalDirty && (e._inverseNormalDirty = !1, F.getMatrix3(e.inverseModelView, e._inverseNormal), Q.getRotation(e._inverseNormal, e._inverseNormal)) } function _Je(e) { e._inverseNormal3DDirty && (e._inverseNormal3DDirty = !1, F.getMatrix3(e.inverseModelView3D, e._inverseNormal3D), Q.getRotation(e._inverseNormal3D, e._inverseNormal3D)) } var Kfe = new h; function Jfe(e) { e._encodedCameraPositionMCDirty && (e._encodedCameraPositionMCDirty = !1, F.multiplyByPoint(e.inverseModel, e._cameraPosition, Kfe), Vn.fromCartesian(Kfe, e._encodedCameraPositionMC)) } var gJe = new h, yJe = new h, AJe = new h, CJe = new h, xJe = new he, TJe = new h, EJe = new F; function bJe(e, t, n, i, o, r, s, a) { let c = gJe; c.x = e.y, c.y = e.z, c.z = e.x; let u = yJe; u.x = n.y, u.y = n.z, u.z = n.x; let f = AJe; f.x = i.y, f.y = i.z, f.z = i.x; let d = CJe; d.x = t.y, d.y = t.z, d.z = t.x, r === ee.SCENE2D && (c.z = o * .5); let p = s.unproject(c, xJe); p.longitude = I.clamp(p.longitude, -Math.PI, Math.PI), p.latitude = I.clamp(p.latitude, -I.PI_OVER_TWO, I.PI_OVER_TWO); let g = s.ellipsoid, m = g.cartographicToCartesian(p, TJe), A = It.eastNorthUpToFixedFrame(m, g, EJe); return F.multiplyByPointAsVector(A, u, u), F.multiplyByPointAsVector(A, f, f), F.multiplyByPointAsVector(A, d, d), l(a) || (a = new F), a[0] = u.x, a[1] = f.x, a[2] = -d.x, a[3] = 0, a[4] = u.y, a[5] = f.y, a[6] = -d.y, a[7] = 0, a[8] = u.z, a[9] = f.z, a[10] = -d.z, a[11] = 0, a[12] = -h.dot(u, m), a[13] = -h.dot(f, m), a[14] = h.dot(d, m), a[15] = 1, a } function kW(e) { e._view3DDirty && (e._mode === ee.SCENE3D ? F.clone(e._view, e._view3D) : bJe(e._cameraPosition, e._cameraDirection, e._cameraRight, e._cameraUp, e._frustum2DWidth, e._mode, e._mapProjection, e._view3D), F.getMatrix3(e._view3D, e._viewRotation3D), e._view3DDirty = !1) } function Zfe(e) { e._inverseView3DDirty && (F.inverseTransformation(e.view3D, e._inverseView3D), F.getMatrix3(e._inverseView3D, e._inverseViewRotation3D), e._inverseView3DDirty = !1) } var T3 = eE; function SJe(e, t) { let n = "WebGL Error:  "; switch (t) { case e.INVALID_ENUM: n += "INVALID_ENUM"; break; case e.INVALID_VALUE: n += "INVALID_VALUE"; break; case e.INVALID_OPERATION: n += "INVALID_OPERATION"; break; case e.OUT_OF_MEMORY: n += "OUT_OF_MEMORY"; break; case e.CONTEXT_LOST_WEBGL: n += "CONTEXT_LOST_WEBGL lost"; break; default: n += `Unknown (${t})` }return n } function wJe(e, t, n, i) { let o = `${SJe(e, i)}: ${t.name}(`; for (let r = 0; r < n.length; ++r)r !== 0 && (o += ", "), o += n[r]; return o += ");", o } function DJe(e, t, n) { let i = e.getError(); if (i !== e.NO_ERROR) throw new fe(wJe(e, t, n, i)) } function vJe(e, t, n) { return { get: function () { let i = e[t]; return n(e, `get: ${t}`, i), e[t] }, set: function (i) { e[t] = i, n(e, `set: ${t}`, i) } } } function PJe(e, t) { if (!l(t)) return e; function n(o) { return function () { let r = o.apply(e, arguments); return t(e, o, arguments), r } } let i = {}; for (let o in e) { let r = e[o]; r instanceof Function ? i[o] = n(r) : Object.defineProperty(i, o, vJe(e, o, t)) } return i } function xr(e, t) { let n = t.length; for (let i = 0; i < n; ++i) { let o = e.getExtension(t[i]); if (o) return o } } function ju(e, t) { if (typeof WebGLRenderingContext > "u") throw new fe("The browser does not support WebGL.  Visit http://get.webgl.org."); this._canvas = e, t = tt(t, !0), t = y(t, {}), t.allowTextureFilterAnisotropic = y(t.allowTextureFilterAnisotropic, !0); let n = y(t.webgl, {}); n.alpha = y(n.alpha, !1), n.stencil = y(n.stencil, !0); let i = y(t.requestWebgl2, !1) && typeof WebGL2RenderingContext < "u", o = !1, r, s = t.getWebGLStub; if (l(s)) r = s(e, n); else if (i && (r = e.getContext("webgl2", n) || e.getContext("experimental-webgl2", n) || void 0, l(r) && (o = !0)), l(r) || (r = e.getContext("webgl", n) || e.getContext("experimental-webgl", n) || void 0), !l(r)) throw new fe("The browser supports WebGL, but initialization failed."); this._originalGLContext = r, this._gl = r, this._webgl2 = o, this._id = Nn(), this.validateFramebuffer = !1, this.validateShaderProgram = !1, this.logShaderCompilation = !1, this._throwOnWebGLError = !1, this._shaderCache = new A3(this), this._textureCache = new C3; let a = r; this._stencilBits = a.getParameter(a.STENCIL_BITS), Ut._maximumCombinedTextureImageUnits = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS), Ut._maximumCubeMapSize = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE), Ut._maximumFragmentUniformVectors = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS), Ut._maximumTextureImageUnits = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS), Ut._maximumRenderbufferSize = a.getParameter(a.MAX_RENDERBUFFER_SIZE), Ut._maximumTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE), Ut._maximumVaryingVectors = a.getParameter(a.MAX_VARYING_VECTORS), Ut._maximumVertexAttributes = a.getParameter(a.MAX_VERTEX_ATTRIBS), Ut._maximumVertexTextureImageUnits = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS), Ut._maximumVertexUniformVectors = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS), Ut._maximumSamples = this._webgl2 ? a.getParameter(a.MAX_SAMPLES) : 0; let c = a.getParameter(a.ALIASED_LINE_WIDTH_RANGE); Ut._minimumAliasedLineWidth = c[0], Ut._maximumAliasedLineWidth = c[1]; let u = a.getParameter(a.ALIASED_POINT_SIZE_RANGE); Ut._minimumAliasedPointSize = u[0], Ut._maximumAliasedPointSize = u[1]; let f = a.getParameter(a.MAX_VIEWPORT_DIMS); Ut._maximumViewportWidth = f[0], Ut._maximumViewportHeight = f[1]; let d = a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT); Ut._highpFloatSupported = d.precision !== 0; let p = a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_INT); Ut._highpIntSupported = p.rangeMax !== 0, this._antialias = a.getContextAttributes().antialias, this._standardDerivatives = !!xr(a, ["OES_standard_derivatives"]), this._blendMinmax = !!xr(a, ["EXT_blend_minmax"]), this._elementIndexUint = !!xr(a, ["OES_element_index_uint"]), this._depthTexture = !!xr(a, ["WEBGL_depth_texture", "WEBKIT_WEBGL_depth_texture"]), this._fragDepth = !!xr(a, ["EXT_frag_depth"]), this._debugShaders = xr(a, ["WEBGL_debug_shaders"]), this._textureFloat = !!xr(a, ["OES_texture_float"]), this._textureHalfFloat = !!xr(a, ["OES_texture_half_float"]), this._textureFloatLinear = !!xr(a, ["OES_texture_float_linear"]), this._textureHalfFloatLinear = !!xr(a, ["OES_texture_half_float_linear"]), this._colorBufferFloat = !!xr(a, ["EXT_color_buffer_float", "WEBGL_color_buffer_float"]), this._floatBlend = !!xr(a, ["EXT_float_blend"]), this._colorBufferHalfFloat = !!xr(a, ["EXT_color_buffer_half_float"]), this._s3tc = !!xr(a, ["WEBGL_compressed_texture_s3tc", "MOZ_WEBGL_compressed_texture_s3tc", "WEBKIT_WEBGL_compressed_texture_s3tc"]), this._pvrtc = !!xr(a, ["WEBGL_compressed_texture_pvrtc", "WEBKIT_WEBGL_compressed_texture_pvrtc"]), this._astc = !!xr(a, ["WEBGL_compressed_texture_astc"]), this._etc = !!xr(a, ["WEBG_compressed_texture_etc"]), this._etc1 = !!xr(a, ["WEBGL_compressed_texture_etc1"]), this._bc7 = !!xr(a, ["EXT_texture_compression_bptc"]), ul.setKTX2SupportedFormats(this._s3tc, this._pvrtc, this._astc, this._etc, this._etc1, this._bc7); let g = t.allowTextureFilterAnisotropic ? xr(a, ["EXT_texture_filter_anisotropic", "WEBKIT_EXT_texture_filter_anisotropic"]) : void 0; this._textureFilterAnisotropic = g, Ut._maximumTextureFilterAnisotropy = l(g) ? a.getParameter(g.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1; let m, A, C, x, T, b, S, D, P, B; if (o) { let _ = this; m = function () { return _._gl.createVertexArray() }, A = function (E) { _._gl.bindVertexArray(E) }, C = function (E) { _._gl.deleteVertexArray(E) }, x = function (E, w, v, O, V) { a.drawElementsInstanced(E, w, v, O, V) }, T = function (E, w, v, O) { a.drawArraysInstanced(E, w, v, O) }, b = function (E, w) { a.vertexAttribDivisor(E, w) }, S = function (E) { a.drawBuffers(E) } } else D = xr(a, ["OES_vertex_array_object"]), l(D) && (m = function () { return D.createVertexArrayOES() }, A = function (_) { D.bindVertexArrayOES(_) }, C = function (_) { D.deleteVertexArrayOES(_) }), P = xr(a, ["ANGLE_instanced_arrays"]), l(P) && (x = function (_, E, w, v, O) { P.drawElementsInstancedANGLE(_, E, w, v, O) }, T = function (_, E, w, v) { P.drawArraysInstancedANGLE(_, E, w, v) }, b = function (_, E) { P.vertexAttribDivisorANGLE(_, E) }), B = xr(a, ["WEBGL_draw_buffers"]), l(B) && (S = function (_) { B.drawBuffersWEBGL(_) }); this.glCreateVertexArray = m, this.glBindVertexArray = A, this.glDeleteVertexArray = C, this.glDrawElementsInstanced = x, this.glDrawArraysInstanced = T, this.glVertexAttribDivisor = b, this.glDrawBuffers = S, this._vertexArrayObject = !!D, this._instancedArrays = !!P, this._drawBuffers = !!B, Ut._maximumDrawBuffers = this.drawBuffers ? a.getParameter(te.MAX_DRAW_BUFFERS) : 1, Ut._maximumColorAttachments = this.drawBuffers ? a.getParameter(te.MAX_COLOR_ATTACHMENTS) : 1, this._clearColor = new U(0, 0, 0, 0), this._clearDepth = 1, this._clearStencil = 0; let R = new T3, M = new pc(this), L = Ve.fromCache(); this._defaultPassState = M, this._defaultRenderState = L, this._defaultTexture = void 0, this._defaultEmissiveTexture = void 0, this._defaultNormalTexture = void 0, this._defaultCubeMap = void 0, this._us = R, this._currentRenderState = L, this._currentPassState = M, this._currentFramebuffer = void 0, this._maxFrameTextureUnitIndex = 0, this._vertexAttribDivisors = [], this._previousDrawInstanced = !1; for (let _ = 0; _ < Ut._maximumVertexAttributes; _++)this._vertexAttribDivisors.push(0); this._pickObjects = {}, this._nextPickColor = new Uint32Array(1), this.options = t, this.cache = {}, Ve.apply(a, L, M) } var IJe = {}; Object.defineProperties(ju.prototype, { id: { get: function () { return this._id } }, webgl2: { get: function () { return this._webgl2 } }, canvas: { get: function () { return this._canvas } }, shaderCache: { get: function () { return this._shaderCache } }, textureCache: { get: function () { return this._textureCache } }, uniformState: { get: function () { return this._us } }, stencilBits: { get: function () { return this._stencilBits } }, stencilBuffer: { get: function () { return this._stencilBits >= 8 } }, antialias: { get: function () { return this._antialias } }, msaa: { get: function () { return this._webgl2 } }, standardDerivatives: { get: function () { return this._standardDerivatives || this._webgl2 } }, floatBlend: { get: function () { return this._floatBlend } }, blendMinmax: { get: function () { return this._blendMinmax || this._webgl2 } }, elementIndexUint: { get: function () { return this._elementIndexUint || this._webgl2 } }, depthTexture: { get: function () { return this._depthTexture || this._webgl2 } }, floatingPointTexture: { get: function () { return this._webgl2 || this._textureFloat } }, halfFloatingPointTexture: { get: function () { return this._webgl2 || this._textureHalfFloat } }, textureFloatLinear: { get: function () { return this._textureFloatLinear } }, textureHalfFloatLinear: { get: function () { return this._webgl2 && this._textureFloatLinear || !this._webgl2 && this._textureHalfFloatLinear } }, textureFilterAnisotropic: { get: function () { return !!this._textureFilterAnisotropic } }, s3tc: { get: function () { return this._s3tc } }, pvrtc: { get: function () { return this._pvrtc } }, astc: { get: function () { return this._astc } }, etc: { get: function () { return this._etc } }, etc1: { get: function () { return this._etc1 } }, bc7: { get: function () { return this._bc7 } }, supportsBasis: { get: function () { return this._s3tc || this._pvrtc || this._astc || this._etc || this._etc1 || this._bc7 } }, vertexArrayObject: { get: function () { return this._vertexArrayObject || this._webgl2 } }, fragmentDepth: { get: function () { return this._fragDepth || this._webgl2 } }, instancedArrays: { get: function () { return this._instancedArrays || this._webgl2 } }, colorBufferFloat: { get: function () { return this._colorBufferFloat } }, colorBufferHalfFloat: { get: function () { return this._webgl2 && this._colorBufferFloat || !this._webgl2 && this._colorBufferHalfFloat } }, drawBuffers: { get: function () { return this._drawBuffers || this._webgl2 } }, debugShaders: { get: function () { return this._debugShaders } }, throwOnWebGLError: { get: function () { return this._throwOnWebGLError }, set: function (e) { this._throwOnWebGLError = e, this._gl = PJe(this._originalGLContext, e ? DJe : void 0) } }, defaultTexture: { get: function () { return this._defaultTexture === void 0 && (this._defaultTexture = new Rt({ context: this, source: { width: 1, height: 1, arrayBufferView: new Uint8Array([255, 255, 255, 255]) }, flipY: !1 })), this._defaultTexture } }, defaultEmissiveTexture: { get: function () { return this._defaultEmissiveTexture === void 0 && (this._defaultEmissiveTexture = new Rt({ context: this, pixelFormat: ht.RGB, source: { width: 1, height: 1, arrayBufferView: new Uint8Array([0, 0, 0]) }, flipY: !1 })), this._defaultEmissiveTexture } }, defaultNormalTexture: { get: function () { return this._defaultNormalTexture === void 0 && (this._defaultNormalTexture = new Rt({ context: this, pixelFormat: ht.RGB, source: { width: 1, height: 1, arrayBufferView: new Uint8Array([128, 128, 255]) }, flipY: !1 })), this._defaultNormalTexture } }, defaultCubeMap: { get: function () { if (this._defaultCubeMap === void 0) { let e = { width: 1, height: 1, arrayBufferView: new Uint8Array([255, 255, 255, 255]) }; this._defaultCubeMap = new Xa({ context: this, source: { positiveX: e, negativeX: e, positiveY: e, negativeY: e, positiveZ: e, negativeZ: e }, flipY: !1 }) } return this._defaultCubeMap } }, drawingBufferHeight: { get: function () { return this._gl.drawingBufferHeight } }, drawingBufferWidth: { get: function () { return this._gl.drawingBufferWidth } }, defaultFramebuffer: { get: function () { return IJe } } }); function Qfe(e, t, n, i) { let o = e._currentRenderState, r = e._currentPassState; e._currentRenderState = t, e._currentPassState = n, Ve.partialApply(e._gl, o, t, r, n, i) } var UW; typeof WebGLRenderingContext < "u" && (UW = [te.BACK]); function zW(e, t) { if (t !== e._currentFramebuffer) { e._currentFramebuffer = t; let n = UW; if (l(t)) t._bind(), n = t._getActiveColorAttachments(); else { let i = e._gl; i.bindFramebuffer(i.FRAMEBUFFER, null) } e.drawBuffers && e.glDrawBuffers(n) } } var OJe = new ti; ju.prototype.clear = function (e, t) { e = y(e, OJe), t = y(t, this._defaultPassState); let n = this._gl, i = 0, o = e.color, r = e.depth, s = e.stencil; l(o) && (U.equals(this._clearColor, o) || (U.clone(o, this._clearColor), n.clearColor(o.red, o.green, o.blue, o.alpha)), i |= n.COLOR_BUFFER_BIT), l(r) && (r !== this._clearDepth && (this._clearDepth = r, n.clearDepth(r)), i |= n.DEPTH_BUFFER_BIT), l(s) && (s !== this._clearStencil && (this._clearStencil = s, n.clearStencil(s)), i |= n.STENCIL_BUFFER_BIT); let a = y(e.renderState, this._defaultRenderState); Qfe(this, a, t, !0); let c = y(e.framebuffer, t.framebuffer); zW(this, c), n.clear(i) }; function BJe(e, t, n, i, o) { zW(e, t), Qfe(e, o, n, !1), i._bind(), e._maxFrameTextureUnitIndex = Math.max(e._maxFrameTextureUnitIndex, i.maximumTextureUnitIndex) } function RJe(e, t, n, i) { let o = t._primitiveType, r = t._vertexArray, s = t._offset, a = t._count, c = t.instanceCount; e._us.model = y(t._modelMatrix, F.IDENTITY), n._setUniforms(i, e._us, e.validateShaderProgram), r._bind(); let u = r.indexBuffer; l(u) ? (s = s * u.bytesPerIndex, a = y(a, u.numberOfIndices), c === 0 ? e._gl.drawElements(o, a, u.indexDatatype, s) : e.glDrawElementsInstanced(o, a, u.indexDatatype, s, c)) : (a = y(a, r.numberOfVertices), c === 0 ? e._gl.drawArrays(o, s, a) : e.glDrawArraysInstanced(o, s, a, c)), r._unBind() } ju.prototype.draw = function (e, t, n, i) { t = y(t, this._defaultPassState); let o = y(e._framebuffer, t.framebuffer), r = y(e._renderState, this._defaultRenderState); n = y(n, e._shaderProgram), i = y(i, e._uniformMap), BJe(this, o, t, n, r), RJe(this, e, n, i) }; ju.prototype.endFrame = function () { let e = this._gl; e.useProgram(null), this._currentFramebuffer = void 0, e.bindFramebuffer(e.FRAMEBUFFER, null); let t = UW; this.drawBuffers && this.glDrawBuffers(t); let n = this._maxFrameTextureUnitIndex; this._maxFrameTextureUnitIndex = 0; for (let i = 0; i < n; ++i)e.activeTexture(e.TEXTURE0 + i), e.bindTexture(e.TEXTURE_2D, null), e.bindTexture(e.TEXTURE_CUBE_MAP, null) }; ju.prototype.readPixels = function (e) { let t = this._gl; e = y(e, y.EMPTY_OBJECT); let n = Math.max(y(e.x, 0), 0), i = Math.max(y(e.y, 0), 0), o = y(e.width, t.drawingBufferWidth), r = y(e.height, t.drawingBufferHeight), s = e.framebuffer, a = Ye.UNSIGNED_BYTE; l(s) && s.numberOfColorAttachments > 0 && (a = s.getColorTexture(0).pixelDatatype); let c = ht.createTypedArray(ht.RGBA, a, o, r); return zW(this, s), t.readPixels(n, i, o, r, ht.RGBA, Ye.toWebGLConstant(a, this), c), c }; var $fe = { position: 0, textureCoordinates: 1 }; ju.prototype.getViewportQuadVertexArray = function () { let e = this.cache.viewportQuad_vertexArray; if (!l(e)) { let t = new st({ attributes: { position: new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: [-1, -1, 1, -1, 1, 1, -1, 1] }), textureCoordinates: new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: [0, 0, 1, 0, 1, 1, 0, 1] }) }, indices: new Uint16Array([0, 1, 2, 0, 2, 3]), primitiveType: Oe.TRIANGLES }); e = Qn.fromGeometry({ context: this, geometry: t, attributeLocations: $fe, bufferUsage: Re.STATIC_DRAW, interleave: !0 }), this.cache.viewportQuad_vertexArray = e } return e }; ju.prototype.createViewportQuadCommand = function (e, t) { return t = y(t, y.EMPTY_OBJECT), new $e({ vertexArray: this.getViewportQuadVertexArray(), primitiveType: Oe.TRIANGLES, renderState: t.renderState, shaderProgram: qt.fromCache({ context: this, vertexShaderSource: QT, fragmentShaderSource: e, attributeLocations: $fe }), uniformMap: t.uniformMap, owner: t.owner, framebuffer: t.framebuffer, pass: t.pass }) }; ju.prototype.getObjectByPickColor = function (e) { return this._pickObjects[e.toRgba()] }; function HW(e, t, n) { this._pickObjects = e, this.key = t, this.color = n } Object.defineProperties(HW.prototype, { object: { get: function () { return this._pickObjects[this.key] }, set: function (e) { this._pickObjects[this.key] = e } } }); HW.prototype.destroy = function () { delete this._pickObjects[this.key] }; ju.prototype.createPickId = function (e) { ++this._nextPickColor[0]; let t = this._nextPickColor[0]; if (t === 0) throw new fe("Out of unique Pick IDs."); return this._pickObjects[t] = e, new HW(this._pickObjects, t, U.fromRgba(t)) }; ju.prototype.isDestroyed = function () { return !1 }; ju.prototype.destroy = function () { let e = this.cache; for (let t in e) if (e.hasOwnProperty(t)) { let n = e[t]; l(n.destroy) && n.destroy() } return this._shaderCache = this._shaderCache.destroy(), this._textureCache = this._textureCache.destroy(), this._defaultTexture = this._defaultTexture && this._defaultTexture.destroy(), this._defaultEmissiveTexture = this._defaultEmissiveTexture && this._defaultEmissiveTexture.destroy(), this._defaultNormalTexture = this._defaultNormalTexture && this._defaultNormalTexture.destroy(), this._defaultCubeMap = this._defaultCubeMap && this._defaultCubeMap.destroy(), le(this) }; var E3 = ju; function MJe(e, t, n) { let i = { flipY: !0, skipColorSpaceConversion: n, preferImageBitmap: !0 }, o = [Pe.createIfNeeded(t.positiveX).fetchImage(i), Pe.createIfNeeded(t.negativeX).fetchImage(i), Pe.createIfNeeded(t.positiveY).fetchImage(i), Pe.createIfNeeded(t.negativeY).fetchImage(i), Pe.createIfNeeded(t.positiveZ).fetchImage(i), Pe.createIfNeeded(t.negativeZ).fetchImage(i)]; return Promise.all(o).then(function (r) { return new Xa({ context: e, source: { positiveX: r[0], negativeX: r[1], positiveY: r[2], negativeY: r[3], positiveZ: r[4], negativeZ: r[5] } }) }) } var b3 = MJe; var LJe = { NONE: 0, LERC: 1 }, rp = Object.freeze(LJe); var FJe = { NONE: 0, BITS12: 1 }, Fs = Object.freeze(FJe); var Hy = new h, NJe = new h, qu = new H, S3 = new F, VJe = new F, kJe = Math.pow(2, 12); function Ra(e, t, n, i, o, r, s, a, c, u) { let f = Fs.NONE, d, p; if (l(t) && l(n) && l(i) && l(o)) { let g = t.minimum, m = t.maximum, A = h.subtract(m, g, NJe), C = i - n; Math.max(h.maximumComponent(A), C) < kJe - 1 ? f = Fs.BITS12 : f = Fs.NONE, d = F.inverseTransformation(o, new F); let T = h.negate(g, Hy); F.multiply(F.fromTranslation(T, S3), d, d); let b = Hy; b.x = 1 / A.x, b.y = 1 / A.y, b.z = 1 / A.z, F.multiply(F.fromScale(b, S3), d, d), p = F.clone(o), F.setTranslation(p, h.ZERO, p), o = F.clone(o, new F); let S = F.fromTranslation(g, S3), D = F.fromScale(A, VJe), P = F.multiply(S, D, S3); F.multiply(o, P, o), F.multiply(p, P, p) } this.quantization = f, this.minimumHeight = n, this.maximumHeight = i, this.center = h.clone(e), this.toScaledENU = d, this.fromScaledENU = o, this.matrix = p, this.hasVertexNormals = r, this.hasWebMercatorT = y(s, !1), this.hasGeodeticSurfaceNormals = y(a, !1), this.exaggeration = y(c, 1), this.exaggerationRelativeHeight = y(u, 0), this.stride = 0, this._offsetGeodeticSurfaceNormal = 0, this._offsetVertexNormal = 0, this._calculateStrideAndOffsets() } Ra.prototype.encode = function (e, t, n, i, o, r, s, a) { let c = i.x, u = i.y; if (this.quantization === Fs.BITS12) { n = F.multiplyByPoint(this.toScaledENU, n, Hy), n.x = I.clamp(n.x, 0, 1), n.y = I.clamp(n.y, 0, 1), n.z = I.clamp(n.z, 0, 1); let f = this.maximumHeight - this.minimumHeight, d = I.clamp((o - this.minimumHeight) / f, 0, 1); H.fromElements(n.x, n.y, qu); let p = kn.compressTextureCoordinates(qu); H.fromElements(n.z, d, qu); let g = kn.compressTextureCoordinates(qu); H.fromElements(c, u, qu); let m = kn.compressTextureCoordinates(qu); if (e[t++] = p, e[t++] = g, e[t++] = m, this.hasWebMercatorT) { H.fromElements(s, 0, qu); let A = kn.compressTextureCoordinates(qu); e[t++] = A } } else h.subtract(n, this.center, Hy), e[t++] = Hy.x, e[t++] = Hy.y, e[t++] = Hy.z, e[t++] = o, e[t++] = c, e[t++] = u, this.hasWebMercatorT && (e[t++] = s); return this.hasVertexNormals && (e[t++] = kn.octPackFloat(r)), this.hasGeodeticSurfaceNormals && (e[t++] = a.x, e[t++] = a.y, e[t++] = a.z), t }; var UJe = new h, ede = new h; Ra.prototype.addGeodeticSurfaceNormals = function (e, t, n) { if (this.hasGeodeticSurfaceNormals) return; let i = this.stride, o = e.length / i; this.hasGeodeticSurfaceNormals = !0, this._calculateStrideAndOffsets(); let r = this.stride; for (let s = 0; s < o; s++) { for (let f = 0; f < i; f++) { let d = s * i + f, p = s * r + f; t[p] = e[d] } let a = this.decodePosition(t, s, UJe), c = n.geodeticSurfaceNormal(a, ede), u = s * r + this._offsetGeodeticSurfaceNormal; t[u] = c.x, t[u + 1] = c.y, t[u + 2] = c.z } }; Ra.prototype.removeGeodeticSurfaceNormals = function (e, t) { if (!this.hasGeodeticSurfaceNormals) return; let n = this.stride, i = e.length / n; this.hasGeodeticSurfaceNormals = !1, this._calculateStrideAndOffsets(); let o = this.stride; for (let r = 0; r < i; r++)for (let s = 0; s < o; s++) { let a = r * n + s, c = r * o + s; t[c] = e[a] } }; Ra.prototype.decodePosition = function (e, t, n) { if (l(n) || (n = new h), t *= this.stride, this.quantization === Fs.BITS12) { let i = kn.decompressTextureCoordinates(e[t], qu); n.x = i.x, n.y = i.y; let o = kn.decompressTextureCoordinates(e[t + 1], qu); return n.z = o.x, F.multiplyByPoint(this.fromScaledENU, n, n) } return n.x = e[t], n.y = e[t + 1], n.z = e[t + 2], h.add(n, this.center, n) }; Ra.prototype.getExaggeratedPosition = function (e, t, n) { n = this.decodePosition(e, t, n); let i = this.exaggeration, o = this.exaggerationRelativeHeight; if (i !== 1 && this.hasGeodeticSurfaceNormals) { let s = this.decodeGeodeticSurfaceNormal(e, t, ede), a = this.decodeHeight(e, t), c = Ic.getHeight(a, i, o) - a; n.x += s.x * c, n.y += s.y * c, n.z += s.z * c } return n }; Ra.prototype.decodeTextureCoordinates = function (e, t, n) { return l(n) || (n = new H), t *= this.stride, this.quantization === Fs.BITS12 ? kn.decompressTextureCoordinates(e[t + 2], n) : H.fromElements(e[t + 4], e[t + 5], n) }; Ra.prototype.decodeHeight = function (e, t) { return t *= this.stride, this.quantization === Fs.BITS12 ? kn.decompressTextureCoordinates(e[t + 1], qu).y * (this.maximumHeight - this.minimumHeight) + this.minimumHeight : e[t + 3] }; Ra.prototype.decodeWebMercatorT = function (e, t) { return t *= this.stride, this.quantization === Fs.BITS12 ? kn.decompressTextureCoordinates(e[t + 3], qu).x : e[t + 6] }; Ra.prototype.getOctEncodedNormal = function (e, t, n) { t = t * this.stride + this._offsetVertexNormal; let i = e[t] / 256, o = Math.floor(i), r = (i - o) * 256; return H.fromElements(o, r, n) }; Ra.prototype.decodeGeodeticSurfaceNormal = function (e, t, n) { return t = t * this.stride + this._offsetGeodeticSurfaceNormal, n.x = e[t], n.y = e[t + 1], n.z = e[t + 2], n }; Ra.prototype._calculateStrideAndOffsets = function () { let e = 0; switch (this.quantization) { case Fs.BITS12: e += 3; break; default: e += 6 }this.hasWebMercatorT && (e += 1), this.hasVertexNormals && (this._offsetVertexNormal = e, e += 1), this.hasGeodeticSurfaceNormals && (this._offsetGeodeticSurfaceNormal = e, e += 3), this.stride = e }; var w3 = { position3DAndHeight: 0, textureCoordAndEncodedNormals: 1, geodeticSurfaceNormal: 2 }, D3 = { compressed0: 0, compressed1: 1, geodeticSurfaceNormal: 2 }; Ra.prototype.getAttributes = function (e) { let t = Y.FLOAT, n = Y.getSizeInBytes(t), i = this.stride * n, o = 0, r = []; function s(a, c) { r.push({ index: a, vertexBuffer: e, componentDatatype: t, componentsPerAttribute: c, offsetInBytes: o, strideInBytes: i }), o += c * n } if (this.quantization === Fs.NONE) { s(w3.position3DAndHeight, 4); let a = 2; a += this.hasWebMercatorT ? 1 : 0, a += this.hasVertexNormals ? 1 : 0, s(w3.textureCoordAndEncodedNormals, a), this.hasGeodeticSurfaceNormals && s(w3.geodeticSurfaceNormal, 3) } else { let a = this.hasWebMercatorT || this.hasVertexNormals, c = this.hasWebMercatorT && this.hasVertexNormals; s(D3.compressed0, a ? 4 : 3), c && s(D3.compressed1, 1), this.hasGeodeticSurfaceNormals && s(D3.geodeticSurfaceNormal, 3) } return r }; Ra.prototype.getAttributeLocations = function () { return this.quantization === Fs.NONE ? w3 : D3 }; Ra.clone = function (e, t) { if (!!l(e)) return l(t) || (t = new Ra), t.quantization = e.quantization, t.minimumHeight = e.minimumHeight, t.maximumHeight = e.maximumHeight, t.center = h.clone(e.center), t.toScaledENU = F.clone(e.toScaledENU), t.fromScaledENU = F.clone(e.fromScaledENU), t.matrix = F.clone(e.matrix), t.hasVertexNormals = e.hasVertexNormals, t.hasWebMercatorT = e.hasWebMercatorT, t.hasGeodeticSurfaceNormals = e.hasGeodeticSurfaceNormals, t.exaggeration = e.exaggeration, t.exaggerationRelativeHeight = e.exaggerationRelativeHeight, t._calculateStrideAndOffsets(), t }; var _c = Ra; var Th = {}; Th.DEFAULT_STRUCTURE = Object.freeze({ heightScale: 1, heightOffset: 0, elementsPerHeight: 1, stride: 1, elementMultiplier: 256, isBigEndian: !1 }); var GW = new h, zJe = new F, HJe = new h, GJe = new h; Th.computeVertices = function (e) { let t = Math.cos, n = Math.sin, i = Math.sqrt, o = Math.atan, r = Math.exp, s = I.PI_OVER_TWO, a = I.toRadians, c = e.heightmap, u = e.width, f = e.height, d = e.skirtHeight, p = d > 0, g = y(e.isGeographic, !0), m = y(e.ellipsoid, ie.WGS84), A = 1 / m.maximumRadius, C = ce.clone(e.nativeRectangle), x = ce.clone(e.rectangle), T, b, S, D; l(x) ? (T = x.west, b = x.south, S = x.east, D = x.north) : g ? (T = a(C.west), b = a(C.south), S = a(C.east), D = a(C.north)) : (T = C.west * A, b = s - 2 * o(r(-C.south * A)), S = C.east * A, D = s - 2 * o(r(-C.north * A))); let P = e.relativeToCenter, B = l(P); P = B ? P : h.ZERO; let R = y(e.includeWebMercatorT, !1), M = y(e.exaggeration, 1), L = y(e.exaggerationRelativeHeight, 0), E = M !== 1, w = y(e.structure, Th.DEFAULT_STRUCTURE), v = y(w.heightScale, Th.DEFAULT_STRUCTURE.heightScale), O = y(w.heightOffset, Th.DEFAULT_STRUCTURE.heightOffset), V = y(w.elementsPerHeight, Th.DEFAULT_STRUCTURE.elementsPerHeight), z = y(w.stride, Th.DEFAULT_STRUCTURE.stride), k = y(w.elementMultiplier, Th.DEFAULT_STRUCTURE.elementMultiplier), G = y(w.isBigEndian, Th.DEFAULT_STRUCTURE.isBigEndian), N = ce.computeWidth(C), X = ce.computeHeight(C), q = N / (u - 1), J = X / (f - 1); g || (N *= A, X *= A); let W = m.radiiSquared, K = W.x, Z = W.y, de = W.z, pe = 65536, oe = -65536, ue = It.eastNorthUpToFixedFrame(P, m), ge = F.inverseTransformation(ue, zJe), Ee, Ie; R && (Ee = Ri.geodeticLatitudeToMercatorAngle(b), Ie = 1 / (Ri.geodeticLatitudeToMercatorAngle(D) - Ee)); let Fe = HJe; Fe.x = Number.POSITIVE_INFINITY, Fe.y = Number.POSITIVE_INFINITY, Fe.z = Number.POSITIVE_INFINITY; let We = GJe; We.x = Number.NEGATIVE_INFINITY, We.y = Number.NEGATIVE_INFINITY, We.z = Number.NEGATIVE_INFINITY; let Lt = Number.POSITIVE_INFINITY, Gt = u * f, cn = d > 0 ? u * 2 + f * 2 : 0, _t = Gt + cn, Pn = new Array(_t), Jn = new Array(_t), at = new Array(_t), Ne = R ? new Array(_t) : [], nt = E ? new Array(_t) : [], Ce = 0, je = f, ut = 0, Wn = u; p && (--Ce, ++je, --ut, ++Wn); let Zn = 1e-5; for (let qe = Ce; qe < je; ++qe) { let mt = qe; mt < 0 && (mt = 0), mt >= f && (mt = f - 1); let Ft = C.north - J * mt; g ? Ft = a(Ft) : Ft = s - 2 * o(r(-Ft * A)); let Cn = (Ft - b) / (D - b); Cn = I.clamp(Cn, 0, 1); let ro = qe === Ce, So = qe === je - 1; d > 0 && (ro ? Ft += Zn * X : So && (Ft -= Zn * X)); let Ao = t(Ft), Hs = n(Ft), nr = de * Hs, Oi; R && (Oi = (Ri.geodeticLatitudeToMercatorAngle(Ft) - Ee) * Ie); for (let Wr = ut; Wr < Wn; ++Wr) { let jr = Wr; jr < 0 && (jr = 0), jr >= u && (jr = u - 1); let Xl = mt * (u * z) + jr * z, Ni; if (V === 1) Ni = c[Xl]; else { Ni = 0; let Vi; if (G) for (Vi = 0; Vi < V; ++Vi)Ni = Ni * k + c[Xl + Vi]; else for (Vi = V - 1; Vi >= 0; --Vi)Ni = Ni * k + c[Xl + Vi] } Ni = Ni * v + O, oe = Math.max(oe, Ni), pe = Math.min(pe, Ni); let Er = C.west + q * jr; g ? Er = a(Er) : Er = Er * A; let Oo = (Er - T) / (S - T); Oo = I.clamp(Oo, 0, 1); let ir = mt * u + jr; if (d > 0) { let Vi = Wr === ut, Hh = Wr === Wn - 1, $E = ro || So || Vi || Hh; if ((ro || So) && (Vi || Hh)) continue; $E && (Ni -= d, Vi ? (ir = Gt + (f - mt - 1), Er -= Zn * N) : So ? ir = Gt + f + (u - jr - 1) : Hh ? (ir = Gt + f + u + mt, Er += Zn * N) : ro && (ir = Gt + f + u + f + jr)) } let Uh = Ao * t(Er), br = Ao * n(Er), Kl = K * Uh, Jl = Z * br, n0 = i(Kl * Uh + Jl * br + nr * Hs), qr = 1 / n0, Bo = Kl * qr, vA = Jl * qr, rs = nr * qr, zh = new h; zh.x = Bo + Uh * Ni, zh.y = vA + br * Ni, zh.z = rs + Hs * Ni, F.multiplyByPoint(ge, zh, GW), h.minimumByComponent(GW, Fe, Fe), h.maximumByComponent(GW, We, We), Lt = Math.min(Lt, Ni), Pn[ir] = zh, at[ir] = new H(Oo, Cn), Jn[ir] = Ni, R && (Ne[ir] = Oi), E && (nt[ir] = m.geodeticSurfaceNormal(zh)) } } let Fi = re.fromPoints(Pn), mo; l(x) && (mo = di.fromRectangle(x, pe, oe, m)); let bo; B && (bo = new j_(m).computeHorizonCullingPointPossiblyUnderEllipsoid(P, Pn, pe)); let Ii = new h0(Fe, We, P), Le = new _c(P, Ii, Lt, oe, ue, !1, R, E, M, L), et = new Float32Array(_t * Le.stride), Ke = 0; for (let qe = 0; qe < _t; ++qe)Ke = Le.encode(et, Ke, Pn[qe], at[qe], Jn[qe], void 0, Ne[qe], nt[qe]); return { vertices: et, maximumHeight: oe, minimumHeight: pe, encoding: Le, boundingSphere3D: Fi, orientedBoundingBox: mo, occludeePointInScaledSpace: bo } }; var vD = Th; function bg() { ye.throwInstantiationError() } Object.defineProperties(bg.prototype, { credits: { get: ye.throwInstantiationError }, waterMask: { get: ye.throwInstantiationError } }); bg.prototype.interpolateHeight = ye.throwInstantiationError; bg.prototype.isChildAvailable = ye.throwInstantiationError; bg.prototype.createMesh = ye.throwInstantiationError; bg.prototype.upsample = ye.throwInstantiationError; bg.prototype.wasCreatedByUpsampling = ye.throwInstantiationError; bg.maximumAsynchronousTasks = 5; var Eh = bg; function WJe(e, t, n, i, o, r, s, a, c, u, f, d, p, g, m, A) { this.center = e, this.vertices = t, this.stride = y(u, 6), this.indices = n, this.indexCountWithoutSkirts = i, this.vertexCountWithoutSkirts = o, this.minimumHeight = r, this.maximumHeight = s, this.boundingSphere3D = a, this.occludeePointInScaledSpace = c, this.orientedBoundingBox = f, this.encoding = d, this.westIndicesSouthToNorth = p, this.southIndicesEastToWest = g, this.eastIndicesNorthToSouth = m, this.northIndicesWestToEast = A } var id = WJe; function gc() { ye.throwInstantiationError() } Object.defineProperties(gc.prototype, { errorEvent: { get: ye.throwInstantiationError }, credit: { get: ye.throwInstantiationError }, tilingScheme: { get: ye.throwInstantiationError }, ready: { get: ye.throwInstantiationError }, readyPromise: { get: ye.throwInstantiationError }, hasWaterMask: { get: ye.throwInstantiationError }, hasVertexNormals: { get: ye.throwInstantiationError }, availability: { get: ye.throwInstantiationError } }); var tde = []; gc.getRegularGridIndices = function (e, t) { let n = tde[e]; l(n) || (tde[e] = n = []); let i = n[t]; return l(i) || (e * t < I.SIXTY_FOUR_KILOBYTES ? i = n[t] = new Uint16Array((e - 1) * (t - 1) * 6) : i = n[t] = new Uint32Array((e - 1) * (t - 1) * 6), rde(e, t, i, 0)), i }; var nde = []; gc.getRegularGridIndicesAndEdgeIndices = function (e, t) { let n = nde[e]; l(n) || (nde[e] = n = []); let i = n[t]; if (!l(i)) { let o = gc.getRegularGridIndices(e, t), r = ode(e, t), s = r.westIndicesSouthToNorth, a = r.southIndicesEastToWest, c = r.eastIndicesNorthToSouth, u = r.northIndicesWestToEast; i = n[t] = { indices: o, westIndicesSouthToNorth: s, southIndicesEastToWest: a, eastIndicesNorthToSouth: c, northIndicesWestToEast: u } } return i }; var ide = []; gc.getRegularGridAndSkirtIndicesAndEdgeIndices = function (e, t) { let n = ide[e]; l(n) || (ide[e] = n = []); let i = n[t]; if (!l(i)) { let o = e * t, r = (e - 1) * (t - 1) * 6, s = e * 2 + t * 2, a = Math.max(0, s - 4) * 6, c = o + s, u = r + a, f = ode(e, t), d = f.westIndicesSouthToNorth, p = f.southIndicesEastToWest, g = f.eastIndicesNorthToSouth, m = f.northIndicesWestToEast, A = Me.createTypedArray(c, u); rde(e, t, A, 0), gc.addSkirtIndices(d, p, g, m, o, A, r), i = n[t] = { indices: A, westIndicesSouthToNorth: d, southIndicesEastToWest: p, eastIndicesNorthToSouth: g, northIndicesWestToEast: m, indexCountWithoutSkirts: r } } return i }; gc.addSkirtIndices = function (e, t, n, i, o, r, s) { let a = o; s = v3(e, a, r, s), a += e.length, s = v3(t, a, r, s), a += t.length, s = v3(n, a, r, s), a += n.length, v3(i, a, r, s) }; function ode(e, t) { let n = new Array(t), i = new Array(e), o = new Array(t), r = new Array(e), s; for (s = 0; s < e; ++s)r[s] = s, i[s] = e * t - 1 - s; for (s = 0; s < t; ++s)o[s] = (s + 1) * e - 1, n[s] = (t - s - 1) * e; return { westIndicesSouthToNorth: n, southIndicesEastToWest: i, eastIndicesNorthToSouth: o, northIndicesWestToEast: r } } function rde(e, t, n, i) { let o = 0; for (let r = 0; r < t - 1; ++r) { for (let s = 0; s < e - 1; ++s) { let a = o, c = a + e, u = c + 1, f = a + 1; n[i++] = a, n[i++] = c, n[i++] = f, n[i++] = f, n[i++] = c, n[i++] = u, ++o } ++o } } function v3(e, t, n, i) { let o = e[0], r = e.length; for (let s = 1; s < r; ++s) { let a = e[s]; n[i++] = o, n[i++] = a, n[i++] = t, n[i++] = t, n[i++] = a, n[i++] = t + 1, o = a, ++t } return i } gc.heightmapTerrainQuality = .25; gc.getEstimatedLevelZeroGeometricErrorForAHeightmap = function (e, t, n) { return e.maximumRadius * 2 * Math.PI * gc.heightmapTerrainQuality / (t * n) }; gc.prototype.requestTileGeometry = ye.throwInstantiationError; gc.prototype.getLevelMaximumGeometricError = ye.throwInstantiationError; gc.prototype.getTileDataAvailable = ye.throwInstantiationError; gc.prototype.loadTileDataAvailability = ye.throwInstantiationError; var Hr = gc; function sp(e) { this._buffer = e.buffer, this._width = e.width, this._height = e.height, this._childTileMask = y(e.childTileMask, 15), this._encoding = y(e.encoding, rp.NONE); let t = vD.DEFAULT_STRUCTURE, n = e.structure; l(n) ? n !== t && (n.heightScale = y(n.heightScale, t.heightScale), n.heightOffset = y(n.heightOffset, t.heightOffset), n.elementsPerHeight = y(n.elementsPerHeight, t.elementsPerHeight), n.stride = y(n.stride, t.stride), n.elementMultiplier = y(n.elementMultiplier, t.elementMultiplier), n.isBigEndian = y(n.isBigEndian, t.isBigEndian)) : n = t, this._structure = n, this._createdByUpsampling = y(e.createdByUpsampling, !1), this._waterMask = e.waterMask, this._skirtHeight = void 0, this._bufferType = this._encoding === rp.LERC ? Float32Array : this._buffer.constructor, this._mesh = void 0 } Object.defineProperties(sp.prototype, { credits: { get: function () { } }, waterMask: { get: function () { return this._waterMask } }, childTileMask: { get: function () { return this._childTileMask } } }); var sde = "createVerticesFromHeightmap", jJe = new yi(sde), qJe = new yi(sde, Eh.maximumAsynchronousTasks); sp.prototype.createMesh = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.tilingScheme, n = e.x, i = e.y, o = e.level, r = y(e.exaggeration, 1), s = y(e.exaggerationRelativeHeight, 0), a = y(e.throttle, !0), c = t.ellipsoid, u = t.tileXYToNativeRectangle(n, i, o), f = t.tileXYToRectangle(n, i, o), d = c.cartographicToCartesian(ce.center(f)), p = this._structure, m = Hr.getEstimatedLevelZeroGeometricErrorForAHeightmap(c, this._width, t.getNumberOfXTilesAtLevel(0)) / (1 << o); this._skirtHeight = Math.min(m * 4, 1e3); let C = (a ? qJe : jJe).scheduleTask({ heightmap: this._buffer, structure: p, includeWebMercatorT: !0, width: this._width, height: this._height, nativeRectangle: u, rectangle: f, relativeToCenter: d, ellipsoid: c, skirtHeight: this._skirtHeight, isGeographic: t.projection instanceof _i, exaggeration: r, exaggerationRelativeHeight: s, encoding: this._encoding }); if (!l(C)) return; let x = this; return Promise.resolve(C).then(function (T) { let b; x._skirtHeight > 0 ? b = Hr.getRegularGridAndSkirtIndicesAndEdgeIndices(T.gridWidth, T.gridHeight) : b = Hr.getRegularGridIndicesAndEdgeIndices(T.gridWidth, T.gridHeight); let S = T.gridWidth * T.gridHeight; return x._mesh = new id(d, new Float32Array(T.vertices), b.indices, b.indexCountWithoutSkirts, S, T.minimumHeight, T.maximumHeight, re.clone(T.boundingSphere3D), h.clone(T.occludeePointInScaledSpace), T.numberOfAttributes, di.clone(T.orientedBoundingBox), _c.clone(T.encoding), b.westIndicesSouthToNorth, b.southIndicesEastToWest, b.eastIndicesNorthToSouth, b.northIndicesWestToEast), x._buffer = void 0, x._mesh }) }; sp.prototype._createMeshSync = function (e) { let t = e.tilingScheme, n = e.x, i = e.y, o = e.level, r = y(e.exaggeration, 1), s = y(e.exaggerationRelativeHeight, 0), a = t.ellipsoid, c = t.tileXYToNativeRectangle(n, i, o), u = t.tileXYToRectangle(n, i, o), f = a.cartographicToCartesian(ce.center(u)), d = this._structure, g = Hr.getEstimatedLevelZeroGeometricErrorForAHeightmap(a, this._width, t.getNumberOfXTilesAtLevel(0)) / (1 << o); this._skirtHeight = Math.min(g * 4, 1e3); let m = vD.computeVertices({ heightmap: this._buffer, structure: d, includeWebMercatorT: !0, width: this._width, height: this._height, nativeRectangle: c, rectangle: u, relativeToCenter: f, ellipsoid: a, skirtHeight: this._skirtHeight, isGeographic: t.projection instanceof _i, exaggeration: r, exaggerationRelativeHeight: s }); this._buffer = void 0; let A; this._skirtHeight > 0 ? A = Hr.getRegularGridAndSkirtIndicesAndEdgeIndices(this._width, this._height) : A = Hr.getRegularGridIndicesAndEdgeIndices(this._width, this._height); let C = m.gridWidth * m.gridHeight; return this._mesh = new id(f, m.vertices, A.indices, A.indexCountWithoutSkirts, C, m.minimumHeight, m.maximumHeight, m.boundingSphere3D, m.occludeePointInScaledSpace, m.encoding.stride, m.orientedBoundingBox, m.encoding, A.westIndicesSouthToNorth, A.southIndicesEastToWest, A.eastIndicesNorthToSouth, A.northIndicesWestToEast), this._mesh }; sp.prototype.interpolateHeight = function (e, t, n) { let i = this._width, o = this._height, r = this._structure, s = r.stride, a = r.elementsPerHeight, c = r.elementMultiplier, u = r.isBigEndian, f = r.heightOffset, d = r.heightScale, p = l(this._mesh), g = this._encoding === rp.LERC; if (!p && g) return; let A; if (p) { let C = this._mesh.vertices, x = this._mesh.encoding; A = ade(C, x, f, d, e, i, o, t, n) } else A = YJe(this._buffer, a, c, s, u, e, i, o, t, n), A = A * d + f; return A }; sp.prototype.upsample = function (e, t, n, i, o, r, s) { let a = this._mesh; if (!l(a)) return; let c = this._width, u = this._height, f = this._structure, d = f.stride, p = new this._bufferType(c * u * d), g = a.vertices, m = a.encoding, A = e.tileXYToRectangle(t, n, i), C = e.tileXYToRectangle(o, r, s), x = f.heightOffset, T = f.heightScale, b = f.elementsPerHeight, S = f.elementMultiplier, D = f.isBigEndian, P = Math.pow(S, b - 1); for (let B = 0; B < u; ++B) { let R = I.lerp(C.north, C.south, B / (u - 1)); for (let M = 0; M < c; ++M) { let L = I.lerp(C.west, C.east, M / (c - 1)), _ = ade(g, m, x, T, A, c, u, L, R); _ = _ < f.lowestEncodedHeight ? f.lowestEncodedHeight : _, _ = _ > f.highestEncodedHeight ? f.highestEncodedHeight : _, XJe(p, b, S, P, d, D, B * c + M, _) } } return Promise.resolve(new sp({ buffer: p, width: c, height: u, childTileMask: 0, structure: this._structure, createdByUpsampling: !0 })) }; sp.prototype.isChildAvailable = function (e, t, n, i) { let o = 2; return n !== e * 2 && ++o, i !== t * 2 && (o -= 2), (this._childTileMask & 1 << o) !== 0 }; sp.prototype.wasCreatedByUpsampling = function () { return this._createdByUpsampling }; function YJe(e, t, n, i, o, r, s, a, c, u) { let f = (c - r.west) * (s - 1) / (r.east - r.west), d = (u - r.south) * (a - 1) / (r.north - r.south), p = f | 0, g = p + 1; g >= s && (g = s - 1, p = s - 2); let m = d | 0, A = m + 1; A >= a && (A = a - 1, m = a - 2); let C = f - p, x = d - m; m = a - 1 - m, A = a - 1 - A; let T = P3(e, t, n, i, o, m * s + p), b = P3(e, t, n, i, o, m * s + g), S = P3(e, t, n, i, o, A * s + p), D = P3(e, t, n, i, o, A * s + g); return cde(C, x, T, b, S, D) } function ade(e, t, n, i, o, r, s, a, c) { let u = (a - o.west) * (r - 1) / (o.east - o.west), f = (c - o.south) * (s - 1) / (o.north - o.south), d = u | 0, p = d + 1; p >= r && (p = r - 1, d = r - 2); let g = f | 0, m = g + 1; m >= s && (m = s - 1, g = s - 2); let A = u - d, C = f - g; g = s - 1 - g, m = s - 1 - m; let x = (t.decodeHeight(e, g * r + d) - n) / i, T = (t.decodeHeight(e, g * r + p) - n) / i, b = (t.decodeHeight(e, m * r + d) - n) / i, S = (t.decodeHeight(e, m * r + p) - n) / i; return cde(A, C, x, T, b, S) } function cde(e, t, n, i, o, r) { return t < e ? n + e * (i - n) + t * (r - i) : n + e * (r - o) + t * (o - n) } function P3(e, t, n, i, o, r) { r *= i; let s = 0, a; if (o) for (a = 0; a < t; ++a)s = s * n + e[r + a]; else for (a = t - 1; a >= 0; --a)s = s * n + e[r + a]; return s } function XJe(e, t, n, i, o, r, s, a) { s *= o; let c; if (r) for (c = 0; c < t - 1; ++c)e[s + c] = a / i | 0, a -= e[s + c] * i, i /= n; else for (c = t - 1; c > 0; --c)e[s + c] = a / i | 0, a -= e[s + c] * i, i /= n; e[s + c] = a } var Ma = sp; function iE(e, t) { this._tilingScheme = e, this._maximumLevel = t, this._rootNodes = [] } var Gy = new ce; function KJe(e, t, n, i) { let o = i.length; for (let r = 0; r < o; ++r) { let s = i[r]; if (s.x === t && s.y === n && s.level === e) return !0 } return !1 } iE.prototype.addAvailableTileRange = function (e, t, n, i, o) { let r = this._tilingScheme, s = this._rootNodes; if (e === 0) for (let p = n; p <= o; ++p)for (let g = t; g <= i; ++g)KJe(e, g, p, s) || s.push(new tE(r, void 0, 0, g, p)); r.tileXYToRectangle(t, n, e, Gy); let a = Gy.west, c = Gy.north; r.tileXYToRectangle(i, o, e, Gy); let u = Gy.east, f = Gy.south, d = new eZe(e, a, f, u, c); for (let p = 0; p < s.length; ++p) { let g = s[p]; WW(g.extent, d) && tZe(this._maximumLevel, g, d) } }; iE.prototype.computeMaximumLevelAtPosition = function (e) { let t; for (let n = 0; n < this._rootNodes.length; ++n) { let i = this._rootNodes[n]; if (nE(i.extent, e)) { t = i; break } } return l(t) ? PD(void 0, t, e) : -1 }; var JJe = [], ZJe = [], QJe = new ce, $Je = new ce; iE.prototype.computeBestAvailableLevelOverRectangle = function (e) { let t = JJe; t.length = 0, e.east < e.west ? (t.push(ce.fromRadians(-Math.PI, e.south, e.east, e.north, QJe)), t.push(ce.fromRadians(e.west, e.south, Math.PI, e.north, $Je))) : t.push(e); let n = ZJe; n.length = 0; let i; for (i = 0; i < this._rootNodes.length; ++i)ID(n, this._rootNodes[i], t); for (i = n.length - 1; i >= 0; --i)if (l(n[i]) && n[i].length === 0) return i; return 0 }; var lde = new he; iE.prototype.isTileAvailable = function (e, t, n) { let i = this._tilingScheme.tileXYToRectangle(t, n, e, Gy); return ce.center(i, lde), this.computeMaximumLevelAtPosition(lde) >= e }; iE.prototype.computeChildMaskForTile = function (e, t, n) { let i = e + 1; if (i >= this._maximumLevel) return 0; let o = 0; return o |= this.isTileAvailable(i, 2 * t, 2 * n + 1) ? 1 : 0, o |= this.isTileAvailable(i, 2 * t + 1, 2 * n + 1) ? 2 : 0, o |= this.isTileAvailable(i, 2 * t, 2 * n) ? 4 : 0, o |= this.isTileAvailable(i, 2 * t + 1, 2 * n) ? 8 : 0, o }; function tE(e, t, n, i, o) { this.tilingScheme = e, this.parent = t, this.level = n, this.x = i, this.y = o, this.extent = e.tileXYToRectangle(i, o, n), this.rectangles = [], this._sw = void 0, this._se = void 0, this._nw = void 0, this._ne = void 0 } Object.defineProperties(tE.prototype, { nw: { get: function () { return this._nw || (this._nw = new tE(this.tilingScheme, this, this.level + 1, this.x * 2, this.y * 2)), this._nw } }, ne: { get: function () { return this._ne || (this._ne = new tE(this.tilingScheme, this, this.level + 1, this.x * 2 + 1, this.y * 2)), this._ne } }, sw: { get: function () { return this._sw || (this._sw = new tE(this.tilingScheme, this, this.level + 1, this.x * 2, this.y * 2 + 1)), this._sw } }, se: { get: function () { return this._se || (this._se = new tE(this.tilingScheme, this, this.level + 1, this.x * 2 + 1, this.y * 2 + 1)), this._se } } }); function eZe(e, t, n, i, o) { this.level = e, this.west = t, this.south = n, this.east = i, this.north = o } function WW(e, t) { let n = Math.max(e.west, t.west), i = Math.max(e.south, t.south), o = Math.min(e.east, t.east), r = Math.min(e.north, t.north); return i < r && n < o } function tZe(e, t, n) { for (; t.level < e;)if (I3(t.nw.extent, n)) t = t.nw; else if (I3(t.ne.extent, n)) t = t.ne; else if (I3(t.sw.extent, n)) t = t.sw; else if (I3(t.se.extent, n)) t = t.se; else break; if (t.rectangles.length === 0 || t.rectangles[t.rectangles.length - 1].level <= n.level) t.rectangles.push(n); else { let i = Wo(t.rectangles, n.level, nZe); i < 0 && (i = ~i), t.rectangles.splice(i, 0, n) } } function nZe(e, t) { return e.level - t } function I3(e, t) { return t.west >= e.west && t.east <= e.east && t.south >= e.south && t.north <= e.north } function nE(e, t) { return t.longitude >= e.west && t.longitude <= e.east && t.latitude >= e.south && t.latitude <= e.north } function PD(e, t, n) { let i = 0, o = !1; for (; !o;) { let r = t._nw && nE(t._nw.extent, n), s = t._ne && nE(t._ne.extent, n), a = t._sw && nE(t._sw.extent, n), c = t._se && nE(t._se.extent, n); if (r + s + a + c > 1) { r && (i = Math.max(i, PD(t, t._nw, n))), s && (i = Math.max(i, PD(t, t._ne, n))), a && (i = Math.max(i, PD(t, t._sw, n))), c && (i = Math.max(i, PD(t, t._se, n))); break } else r ? t = t._nw : s ? t = t._ne : a ? t = t._sw : c ? t = t._se : o = !0 } for (; t !== e;) { let r = t.rectangles; for (let s = r.length - 1; s >= 0 && r[s].level > i; --s) { let a = r[s]; nE(a, n) && (i = a.level) } t = t.parent } return i } function ID(e, t, n) { if (!t) return; let i, o = !1; for (i = 0; i < n.length; ++i)o = o || WW(t.extent, n[i]); if (!o) return; let r = t.rectangles; for (i = 0; i < r.length; ++i) { let s = r[i]; e[s.level] || (e[s.level] = n), e[s.level] = iZe(e[s.level], s) } ID(e, t._nw, n), ID(e, t._ne, n), ID(e, t._sw, n), ID(e, t._se, n) } function iZe(e, t) { let n = []; for (let i = 0; i < e.length; ++i) { let o = e[i]; WW(o, t) ? (o.west < t.west && n.push(new ce(o.west, o.south, t.west, o.north)), o.east > t.east && n.push(new ce(t.east, o.south, o.east, o.north)), o.south < t.south && n.push(new ce(Math.max(t.west, o.west), o.south, Math.min(t.east, o.east), t.south)), o.north > t.north && n.push(new ce(Math.max(t.west, o.west), t.north, Math.min(t.east, o.east), o.north))) : n.push(o) } return n } var bh = iE; function oZe(e) {
        let t, n = e.name, i = e.message; l(n) && l(i) ? t = `${n}: ${i}` : t = e.toString(); let o = e.stack; return l(o) && (t += `
${o}`), t
    } var ap = oZe; function O3(e, t, n, i, o, r, s) { this.provider = e, this.message = t, this.x = n, this.y = i, this.level = o, this.timesRetried = y(r, 0), this.retry = !1, this.error = s } O3.reportError = function (e, t, n, i, o, r, s, a) { let c = e; return l(e) ? (c.provider = t, c.message = i, c.x = o, c.y = r, c.level = s, c.retry = !1, c.error = a, ++c.timesRetried) : c = new O3(t, i, o, r, s, 0, a), n.numberOfListeners > 0 ? n.raiseEvent(c) : console.log(`An error occurred in "${t.constructor.name}": ${ap(i)}`), c }; O3.reportSuccess = function (e) { l(e) && (e.timesRetried = -1) }; var Gn = O3; function Sg(e) { if (e = y(e, y.EMPTY_OBJECT), this._ellipsoid = y(e.ellipsoid, ie.WGS84), this._numberOfLevelZeroTilesX = y(e.numberOfLevelZeroTilesX, 1), this._numberOfLevelZeroTilesY = y(e.numberOfLevelZeroTilesY, 1), this._projection = new Ri(this._ellipsoid), l(e.rectangleSouthwestInMeters) && l(e.rectangleNortheastInMeters)) this._rectangleSouthwestInMeters = e.rectangleSouthwestInMeters, this._rectangleNortheastInMeters = e.rectangleNortheastInMeters; else { let i = this._ellipsoid.maximumRadius * Math.PI; this._rectangleSouthwestInMeters = new H(-i, -i), this._rectangleNortheastInMeters = new H(i, i) } let t = this._projection.unproject(this._rectangleSouthwestInMeters), n = this._projection.unproject(this._rectangleNortheastInMeters); this._rectangle = new ce(t.longitude, t.latitude, n.longitude, n.latitude) } Object.defineProperties(Sg.prototype, { ellipsoid: { get: function () { return this._ellipsoid } }, rectangle: { get: function () { return this._rectangle } }, projection: { get: function () { return this._projection } } }); Sg.prototype.getNumberOfXTilesAtLevel = function (e) { return this._numberOfLevelZeroTilesX << e }; Sg.prototype.getNumberOfYTilesAtLevel = function (e) { return this._numberOfLevelZeroTilesY << e }; Sg.prototype.rectangleToNativeRectangle = function (e, t) { let n = this._projection, i = n.project(ce.southwest(e)), o = n.project(ce.northeast(e)); return l(t) ? (t.west = i.x, t.south = i.y, t.east = o.x, t.north = o.y, t) : new ce(i.x, i.y, o.x, o.y) }; Sg.prototype.tileXYToNativeRectangle = function (e, t, n, i) { let o = this.getNumberOfXTilesAtLevel(n), r = this.getNumberOfYTilesAtLevel(n), s = (this._rectangleNortheastInMeters.x - this._rectangleSouthwestInMeters.x) / o, a = this._rectangleSouthwestInMeters.x + e * s, c = this._rectangleSouthwestInMeters.x + (e + 1) * s, u = (this._rectangleNortheastInMeters.y - this._rectangleSouthwestInMeters.y) / r, f = this._rectangleNortheastInMeters.y - t * u, d = this._rectangleNortheastInMeters.y - (t + 1) * u; return l(i) ? (i.west = a, i.south = d, i.east = c, i.north = f, i) : new ce(a, d, c, f) }; Sg.prototype.tileXYToRectangle = function (e, t, n, i) { let o = this.tileXYToNativeRectangle(e, t, n, i), r = this._projection, s = r.unproject(new H(o.west, o.south)), a = r.unproject(new H(o.east, o.north)); return o.west = s.longitude, o.south = s.latitude, o.east = a.longitude, o.north = a.latitude, o }; Sg.prototype.positionToTileXY = function (e, t, n) { let i = this._rectangle; if (!ce.contains(i, e)) return; let o = this.getNumberOfXTilesAtLevel(t), r = this.getNumberOfYTilesAtLevel(t), a = (this._rectangleNortheastInMeters.x - this._rectangleSouthwestInMeters.x) / o, u = (this._rectangleNortheastInMeters.y - this._rectangleSouthwestInMeters.y) / r, d = this._projection.project(e), p = d.x - this._rectangleSouthwestInMeters.x, g = this._rectangleNortheastInMeters.y - d.y, m = p / a | 0; m >= o && (m = o - 1); let A = g / u | 0; return A >= r && (A = r - 1), l(n) ? (n.x = m, n.y = A, n) : new H(m, A) }; var Gr = Sg; var rZe = 15; function oE(e) { this._resource = void 0, this._credit = void 0, this._tilingScheme = void 0, this._levelZeroMaximumGeometricError = void 0, this._maxLevel = void 0, this._terrainDataStructure = void 0, this._ready = !1, this._width = void 0, this._height = void 0, this._encoding = void 0; let t = e.token; this._hasAvailability = !1, this._tilesAvailable = void 0, this._tilesAvailablityLoaded = void 0, this._availableCache = {}; let n = this, i = y(e.ellipsoid, ie.WGS84); this._readyPromise = Promise.resolve(e.url).then(function (o) { let r = Pe.createIfNeeded(o); return r.appendForwardSlash(), l(t) && (r = r.getDerivedResource({ queryParameters: { token: t } })), n._resource = r, r.getDerivedResource({ queryParameters: { f: "pjson" } }).fetchJson() }).then(function (o) { let r = o.copyrightText; l(r) && (n._credit = new Xt(r)); let s = o.spatialReference, a = y(s.latestWkid, s.wkid), c = o.extent, u = { ellipsoid: i }; if (a === 4326) u.rectangle = ce.fromDegrees(c.xmin, c.ymin, c.xmax, c.ymax), n._tilingScheme = new Hi(u); else if (a === 3857) u.rectangleSouthwestInMeters = new H(c.xmin, c.ymin), u.rectangleNortheastInMeters = new H(c.xmax, c.ymax), n._tilingScheme = new Gr(u); else return Promise.reject(new fe("Invalid spatial reference")); let f = o.tileInfo; return l(f) ? (n._width = f.rows + 1, n._height = f.cols + 1, n._encoding = f.format === "LERC" ? rp.LERC : rp.NONE, n._lodCount = f.lods.length - 1, (n._hasAvailability = o.capabilities.indexOf("Tilemap") !== -1) && (n._tilesAvailable = new bh(n._tilingScheme, n._lodCount), n._tilesAvailable.addAvailableTileRange(0, 0, 0, n._tilingScheme.getNumberOfXTilesAtLevel(0), n._tilingScheme.getNumberOfYTilesAtLevel(0)), n._tilesAvailablityLoaded = new bh(n._tilingScheme, n._lodCount)), n._levelZeroMaximumGeometricError = Hr.getEstimatedLevelZeroGeometricErrorForAHeightmap(n._tilingScheme.ellipsoid, n._width, n._tilingScheme.getNumberOfXTilesAtLevel(0)), o.bandCount > 1 && console.log("ArcGISTiledElevationTerrainProvider: Terrain data has more than 1 band. Using the first one."), n._terrainDataStructure = { elementMultiplier: 1, lowestEncodedHeight: o.minValues[0], highestEncodedHeight: o.maxValues[0] }, n._ready = !0, !0) : Promise.reject(new fe("tileInfo is required")) }).catch(function (o) { let r = `An error occurred while accessing ${n._resource.url}.`; return Gn.reportError(void 0, n, n._errorEvent, r), Promise.reject(o) }), this._errorEvent = new _e } Object.defineProperties(oE.prototype, { errorEvent: { get: function () { return this._errorEvent } }, credit: { get: function () { return this._credit } }, tilingScheme: { get: function () { return this._tilingScheme } }, ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } }, hasWaterMask: { get: function () { return !1 } }, hasVertexNormals: { get: function () { return !1 } }, availability: { get: function () { return this._tilesAvailable } } }); oE.prototype.requestTileGeometry = function (e, t, n, i) { let o = this._resource.getDerivedResource({ url: `tile/${n}/${t}/${e}`, request: i }), r = this._hasAvailability, s = Promise.resolve(!0), a; if (r && !l(jW(this, n + 1, e * 2, t * 2))) { let d = ude(this, n + 1, e * 2, t * 2); s = d.promise, a = d.request } let c = o.fetchArrayBuffer(); if (!l(c) || !l(s)) return; let u = this, f = this._tilesAvailable; return Promise.all([c, s]).then(function (d) { return new Ma({ buffer: d[0], width: u._width, height: u._height, childTileMask: r ? f.computeChildMaskForTile(n, e, t) : rZe, structure: u._terrainDataStructure, encoding: u._encoding }) }).catch(function (d) { return l(a) && a.state === ri.CANCELLED ? (i.cancel(), i.deferred.promise.finally(function () { return i.state = ri.CANCELLED, Promise.reject(d) })) : Promise.reject(d) }) }; function jW(e, t, n, i) { if (!e._hasAvailability) return; let o = e._tilesAvailablityLoaded, r = e._tilesAvailable; if (t > e._lodCount) return !1; if (r.isTileAvailable(t, n, i)) return !0; if (o.isTileAvailable(t, n, i)) return !1 } oE.prototype.getLevelMaximumGeometricError = function (e) { return this._levelZeroMaximumGeometricError / (1 << e) }; oE.prototype.getTileDataAvailable = function (e, t, n) { if (!this._hasAvailability) return; let i = jW(this, n, e, t); if (l(i)) return i; ude(this, n, e, t) }; oE.prototype.loadTileDataAvailability = function (e, t, n) { }; function sZe(e, t, n, i) { let o = t - 1, r = n - 1, s = i[e.y * t + e.x], a = [], c = { startX: e.x, startY: e.y, endX: 0, endY: 0 }, u = new H(e.x + 1, e.y + 1), f = !1, d = !1; for (; !(f && d);) { let p = u.x, g = d ? u.y + 1 : u.y; if (!f) { for (let m = e.y; m < g; ++m)if (i[m * t + u.x] !== s) { f = !0; break } f ? (a.push(new H(u.x, e.y)), --u.x, --p, c.endX = u.x) : u.x === o ? (c.endX = u.x, f = !0) : ++u.x } if (!d) { let m = u.y * t; for (let A = e.x; A <= p; ++A)if (i[m + A] !== s) { d = !0; break } d ? (a.push(new H(e.x, u.y)), --u.y, c.endY = u.y) : u.y === r ? (c.endY = u.y, d = !0) : ++u.y } } return { endingIndices: a, range: c, value: s } } function aZe(e, t, n, i, o) { let r = []; if (o.every(function (c) { return c === o[0] })) return o[0] === 1 && r.push({ startX: e, startY: t, endX: e + n - 1, endY: t + i - 1 }), r; let a = [new H(0, 0)]; for (; a.length > 0;) { let c = a.pop(), u = sZe(c, n, i, o); if (u.value === 1) { let d = u.range; d.startX += e, d.endX += e, d.startY += t, d.endY += t, r.push(d) } let f = u.endingIndices; f.length > 0 && (a = a.concat(f)) } return r } function ude(e, t, n, i) { if (!e._hasAvailability) return {}; let o = Math.floor(n / 128) * 128, r = Math.floor(i / 128) * 128, s = Math.min(1 << t, 128), a = `tilemap/${t}/${r}/${o}/${s}/${s}`, c = e._availableCache; if (l(c[a])) return c[a]; let u = new jo({ throttle: !1, throttleByServer: !0, type: Xr.TERRAIN }), d = e._resource.getDerivedResource({ url: a, request: u }).fetchJson(); return l(d) ? (d = d.then(function (p) { let g = aZe(o, r, s, s, p.data); e._tilesAvailablityLoaded.addAvailableTileRange(t, o, r, o + s, r + s); let m = e._tilesAvailable; for (let A = 0; A < g.length; ++A) { let C = g[A]; m.addAvailableTileRange(t, C.startX, C.startY, C.endX, C.endY) } return jW(e, t, n, i) }), c[a] = { promise: d, request: u }, d = d.finally(function (p) { return delete c[a], p }), { promise: d, request: u }) : {} } var fde = oE; var dde = "https://dev.virtualearth.net/REST/v1/Locations"; function qW(e) { e = y(e, y.EMPTY_OBJECT); let t = e.key; this._key = t; let n = { key: t }; l(e.culture) && (n.culture = e.culture), this._resource = new Pe({ url: dde, queryParameters: n }) } Object.defineProperties(qW.prototype, { url: { get: function () { return dde } }, key: { get: function () { return this._key } } }); qW.prototype.geocode = function (e) { return this._resource.getDerivedResource({ queryParameters: { query: e } }).fetchJsonp("jsonp").then(function (n) { return n.resourceSets.length === 0 ? [] : n.resourceSets[0].resources.map(function (o) { let r = o.bbox, s = r[0], a = r[1], c = r[2], u = r[3]; return { displayName: o.name, destination: ce.fromDegrees(a, s, u, c) } }) }) }; var hde = qW; var cp; typeof cancelAnimationFrame < "u" && (cp = cancelAnimationFrame); (function () { if (!l(cp) && typeof window < "u") { let e = ["webkit", "moz", "ms", "o"], t = 0, n = e.length; for (; t < n && !l(cp);)cp = window[`${e[t]}CancelAnimationFrame`], l(cp) || (cp = window[`${e[t]}CancelRequestAnimationFrame`]), ++t } l(cp) || (cp = clearTimeout) })(); function cZe(e) { Jr("Cesium.cancelAnimationFrame", "Cesium.cancelAnimationFrame was deprecated in CesiumJS 1.96 and will be removed in 1.99. Use the native cancelAnimationFrame method instead."), cp(e) } var mde = cZe; function pde() { } pde.prototype.geocode = function (e) { let t = e.match(/[^\s,\n]+/g); if (t.length === 2 || t.length === 3) { let n = +t[0], i = +t[1], o = t.length === 3 ? +t[2] : 300; if (isNaN(n) && isNaN(i)) { let r = /^(\d+.?\d*)([nsew])/i; for (let s = 0; s < t.length; ++s) { let a = t[s].match(r); r.test(t[s]) && a.length === 3 && (/^[ns]/i.test(a[2]) ? i = /^[n]/i.test(a[2]) ? +a[1] : -a[1] : /^[ew]/i.test(a[2]) && (n = /^[e]/i.test(a[2]) ? +a[1] : -a[1])) } } if (!isNaN(n) && !isNaN(i) && !isNaN(o)) { let r = { displayName: e, destination: h.fromDegrees(n, i, o) }; return Promise.resolve([r]) } } return Promise.resolve([]) }; var B3 = pde; var lZe = new se, _de = new h, rE = new h; function uZe(e) { let t = e.points, n = e.times; if (t.length < 3) { let i = n[0], o = 1 / (n[1] - i), r = t[0], s = t[1]; return function (a, c) { l(c) || (c = new h); let u = (a - i) * o; return h.lerp(r, s, u, c) } } return function (i, o) { l(o) || (o = new h); let r = e._lastTimeIndex = e.findTimeInterval(i, e._lastTimeIndex), s = (i - n[r]) / (n[r + 1] - n[r]), a = lZe; a.z = s, a.y = s * s, a.x = a.y * s, a.w = 1; let c, u, f, d, p; return r === 0 ? (c = t[0], u = t[1], f = e.firstTangent, d = h.subtract(t[2], c, _de), h.multiplyByScalar(d, .5, d), p = F.multiplyByVector(H0.hermiteCoefficientMatrix, a, a)) : r === t.length - 2 ? (c = t[r], u = t[r + 1], d = e.lastTangent, f = h.subtract(u, t[r - 1], _de), h.multiplyByScalar(f, .5, f), p = F.multiplyByVector(H0.hermiteCoefficientMatrix, a, a)) : (c = t[r - 1], u = t[r], f = t[r + 1], d = t[r + 2], p = F.multiplyByVector(wg.catmullRomCoefficientMatrix, a, a)), o = h.multiplyByScalar(c, p.x, o), h.multiplyByScalar(u, p.y, rE), h.add(o, rE, o), h.multiplyByScalar(f, p.z, rE), h.add(o, rE, o), h.multiplyByScalar(d, p.w, rE), h.add(o, rE, o) } } var fZe = new h, dZe = new h; function wg(e) { e = y(e, y.EMPTY_OBJECT); let t = e.points, n = e.times, i = e.firstTangent, o = e.lastTangent; if (t.length > 2 && (l(i) || (i = fZe, h.multiplyByScalar(t[1], 2, i), h.subtract(i, t[2], i), h.subtract(i, t[0], i), h.multiplyByScalar(i, .5, i)), !l(o))) { let r = t.length - 1; o = dZe, h.multiplyByScalar(t[r - 1], 2, o), h.subtract(t[r], o, o), h.add(o, t[r - 2], o), h.multiplyByScalar(o, .5, o) } this._times = n, this._points = t, this._firstTangent = h.clone(i), this._lastTangent = h.clone(o), this._evaluateFunction = uZe(this), this._lastTimeIndex = 0 } Object.defineProperties(wg.prototype, { times: { get: function () { return this._times } }, points: { get: function () { return this._points } }, firstTangent: { get: function () { return this._firstTangent } }, lastTangent: { get: function () { return this._lastTangent } } }); wg.catmullRomCoefficientMatrix = new F(-.5, 1, -.5, 0, 1.5, -2.5, 0, 1, -1.5, 2, .5, 0, .5, -.5, 0, 0); wg.prototype.findTimeInterval = Qi.prototype.findTimeInterval; wg.prototype.wrapTime = Qi.prototype.wrapTime; wg.prototype.clampTime = Qi.prototype.clampTime; wg.prototype.evaluate = function (e, t) { return this._evaluateFunction(e, t) }; var gde = wg; var R3 = {}; R3.clipTriangleAtAxisAlignedThreshold = function (e, t, n, i, o, r) { l(r) ? r.length = 0 : r = []; let s, a, c; t ? (s = n < e, a = i < e, c = o < e) : (s = n > e, a = i > e, c = o > e); let u = s + a + c, f, d, p, g, m, A; return u === 1 ? s ? (f = (e - n) / (i - n), d = (e - n) / (o - n), r.push(1), r.push(2), d !== 1 && (r.push(-1), r.push(0), r.push(2), r.push(d)), f !== 1 && (r.push(-1), r.push(0), r.push(1), r.push(f))) : a ? (p = (e - i) / (o - i), g = (e - i) / (n - i), r.push(2), r.push(0), g !== 1 && (r.push(-1), r.push(1), r.push(0), r.push(g)), p !== 1 && (r.push(-1), r.push(1), r.push(2), r.push(p))) : c && (m = (e - o) / (n - o), A = (e - o) / (i - o), r.push(0), r.push(1), A !== 1 && (r.push(-1), r.push(2), r.push(1), r.push(A)), m !== 1 && (r.push(-1), r.push(2), r.push(0), r.push(m))) : u === 2 ? !s && n !== e ? (g = (e - i) / (n - i), m = (e - o) / (n - o), r.push(0), r.push(-1), r.push(1), r.push(0), r.push(g), r.push(-1), r.push(2), r.push(0), r.push(m)) : !a && i !== e ? (A = (e - o) / (i - o), f = (e - n) / (i - n), r.push(1), r.push(-1), r.push(2), r.push(1), r.push(A), r.push(-1), r.push(0), r.push(1), r.push(f)) : !c && o !== e && (d = (e - n) / (o - n), p = (e - i) / (o - i), r.push(2), r.push(-1), r.push(0), r.push(2), r.push(d), r.push(-1), r.push(1), r.push(2), r.push(p)) : u !== 3 && (r.push(0), r.push(1), r.push(2)), r }; R3.computeBarycentricCoordinates = function (e, t, n, i, o, r, s, a, c) { let u = n - s, f = s - o, d = r - a, p = i - a, g = 1 / (d * u + f * p), m = t - a, A = e - s, C = (d * A + f * m) * g, x = (-p * A + u * m) * g, T = 1 - C - x; return l(c) ? (c.x = C, c.y = x, c.z = T, c) : new h(C, x, T) }; R3.computeLineSegmentLineSegmentIntersection = function (e, t, n, i, o, r, s, a, c) { let u = (s - o) * (t - r) - (a - r) * (e - o), f = (n - e) * (t - r) - (i - t) * (e - o), d = (a - r) * (n - e) - (s - o) * (i - t); if (d === 0) return; let p = u / d, g = f / d; if (p >= 0 && p <= 1 && g >= 0 && g <= 1) return l(c) || (c = new H), c.x = e + p * (n - e), c.y = t + p * (i - t), c }; var Dg = R3; function vg(e) { this._quantizedVertices = e.quantizedVertices, this._encodedNormals = e.encodedNormals, this._indices = e.indices, this._minimumHeight = e.minimumHeight, this._maximumHeight = e.maximumHeight, this._boundingSphere = e.boundingSphere, this._orientedBoundingBox = e.orientedBoundingBox, this._horizonOcclusionPoint = e.horizonOcclusionPoint, this._credits = e.credits; let t = this._quantizedVertices.length / 3, n = this._uValues = this._quantizedVertices.subarray(0, t), i = this._vValues = this._quantizedVertices.subarray(t, 2 * t); this._heightValues = this._quantizedVertices.subarray(2 * t, 3 * t); function o(s, a) { return i[s] - i[a] } function r(s, a) { return n[s] - n[a] } this._westIndices = L3(e.westIndices, o, t), this._southIndices = L3(e.southIndices, r, t), this._eastIndices = L3(e.eastIndices, o, t), this._northIndices = L3(e.northIndices, r, t), this._westSkirtHeight = e.westSkirtHeight, this._southSkirtHeight = e.southSkirtHeight, this._eastSkirtHeight = e.eastSkirtHeight, this._northSkirtHeight = e.northSkirtHeight, this._childTileMask = y(e.childTileMask, 15), this._createdByUpsampling = y(e.createdByUpsampling, !1), this._waterMask = e.waterMask, this._mesh = void 0 } Object.defineProperties(vg.prototype, { credits: { get: function () { return this._credits } }, waterMask: { get: function () { return this._waterMask } }, childTileMask: { get: function () { return this._childTileMask } }, canUpsample: { get: function () { return l(this._mesh) } } }); var M3 = []; function L3(e, t, n) { M3.length = e.length; let i = !1; for (let o = 0, r = e.length; o < r; ++o)M3[o] = e[o], i = i || o > 0 && t(e[o - 1], e[o]) > 0; return i ? (M3.sort(t), Me.createTypedArray(n, M3)) : e } var yde = "createVerticesFromQuantizedTerrainMesh", hZe = new yi(yde), mZe = new yi(yde, Eh.maximumAsynchronousTasks); vg.prototype.createMesh = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.tilingScheme, n = e.x, i = e.y, o = e.level, r = y(e.exaggeration, 1), s = y(e.exaggerationRelativeHeight, 0), a = y(e.throttle, !0), c = t.ellipsoid, u = t.tileXYToRectangle(n, i, o), d = (a ? mZe : hZe).scheduleTask({ minimumHeight: this._minimumHeight, maximumHeight: this._maximumHeight, quantizedVertices: this._quantizedVertices, octEncodedNormals: this._encodedNormals, includeWebMercatorT: !0, indices: this._indices, westIndices: this._westIndices, southIndices: this._southIndices, eastIndices: this._eastIndices, northIndices: this._northIndices, westSkirtHeight: this._westSkirtHeight, southSkirtHeight: this._southSkirtHeight, eastSkirtHeight: this._eastSkirtHeight, northSkirtHeight: this._northSkirtHeight, rectangle: u, relativeToCenter: this._boundingSphere.center, ellipsoid: c, exaggeration: r, exaggerationRelativeHeight: s }); if (!l(d)) return; let p = this; return Promise.resolve(d).then(function (g) { let m = p._quantizedVertices.length / 3, A = m + p._westIndices.length + p._southIndices.length + p._eastIndices.length + p._northIndices.length, C = Me.createTypedArray(A, g.indices), x = new Float32Array(g.vertices), T = g.center, b = g.minimumHeight, S = g.maximumHeight, D = p._boundingSphere, P = p._orientedBoundingBox, B = y(h.clone(g.occludeePointInScaledSpace), p._horizonOcclusionPoint), R = g.vertexStride, M = _c.clone(g.encoding); return p._mesh = new id(T, x, C, g.indexCountWithoutSkirts, m, b, S, D, B, R, P, M, g.westIndicesSouthToNorth, g.southIndicesEastToWest, g.eastIndicesNorthToSouth, g.northIndicesWestToEast), p._quantizedVertices = void 0, p._encodedNormals = void 0, p._indices = void 0, p._uValues = void 0, p._vValues = void 0, p._heightValues = void 0, p._westIndices = void 0, p._southIndices = void 0, p._eastIndices = void 0, p._northIndices = void 0, p._mesh }) }; var pZe = new yi("upsampleQuantizedTerrainMesh", Eh.maximumAsynchronousTasks); vg.prototype.upsample = function (e, t, n, i, o, r, s) { let a = this._mesh; if (!l(this._mesh)) return; let c = t * 2 !== o, u = n * 2 === r, f = e.ellipsoid, d = e.tileXYToRectangle(o, r, s), p = pZe.scheduleTask({ vertices: a.vertices, vertexCountWithoutSkirts: a.vertexCountWithoutSkirts, indices: a.indices, indexCountWithoutSkirts: a.indexCountWithoutSkirts, encoding: a.encoding, minimumHeight: this._minimumHeight, maximumHeight: this._maximumHeight, isEastChild: c, isNorthChild: u, childRectangle: d, ellipsoid: f }); if (!l(p)) return; let g = Math.min(this._westSkirtHeight, this._eastSkirtHeight); g = Math.min(g, this._southSkirtHeight), g = Math.min(g, this._northSkirtHeight); let m = c ? g * .5 : this._westSkirtHeight, A = u ? g * .5 : this._southSkirtHeight, C = c ? this._eastSkirtHeight : g * .5, x = u ? this._northSkirtHeight : g * .5, T = this._credits; return Promise.resolve(p).then(function (b) { let S = new Uint16Array(b.vertices), D = Me.createTypedArray(S.length / 3, b.indices), P; return l(b.encodedNormals) && (P = new Uint8Array(b.encodedNormals)), new vg({ quantizedVertices: S, indices: D, encodedNormals: P, minimumHeight: b.minimumHeight, maximumHeight: b.maximumHeight, boundingSphere: re.clone(b.boundingSphere), orientedBoundingBox: di.clone(b.orientedBoundingBox), horizonOcclusionPoint: h.clone(b.horizonOcclusionPoint), westIndices: b.westIndices, southIndices: b.southIndices, eastIndices: b.eastIndices, northIndices: b.northIndices, westSkirtHeight: m, southSkirtHeight: A, eastSkirtHeight: C, northSkirtHeight: x, childTileMask: 0, credits: T, createdByUpsampling: !0 }) }) }; var YW = 32767, Ade = new h; vg.prototype.interpolateHeight = function (e, t, n) { let i = I.clamp((t - e.west) / e.width, 0, 1); i *= YW; let o = I.clamp((n - e.south) / e.height, 0, 1); return o *= YW, l(this._mesh) ? AZe(this, i, o) : CZe(this, i, o) }; function Cde(e, t, n, i, o, r, s, a) { let c = Math.min(n, o, s), u = Math.max(n, o, s), f = Math.min(i, r, a), d = Math.max(i, r, a); return e >= c && e <= u && t >= f && t <= d } var _Ze = new H, gZe = new H, yZe = new H; function AZe(e, t, n) { let i = e._mesh, o = i.vertices, r = i.encoding, s = i.indices; for (let a = 0, c = s.length; a < c; a += 3) { let u = s[a], f = s[a + 1], d = s[a + 2], p = r.decodeTextureCoordinates(o, u, _Ze), g = r.decodeTextureCoordinates(o, f, gZe), m = r.decodeTextureCoordinates(o, d, yZe); if (Cde(t, n, p.x, p.y, g.x, g.y, m.x, m.y)) { let A = Dg.computeBarycentricCoordinates(t, n, p.x, p.y, g.x, g.y, m.x, m.y, Ade); if (A.x >= -1e-15 && A.y >= -1e-15 && A.z >= -1e-15) { let C = r.decodeHeight(o, u), x = r.decodeHeight(o, f), T = r.decodeHeight(o, d); return A.x * C + A.y * x + A.z * T } } } } function CZe(e, t, n) { let i = e._uValues, o = e._vValues, r = e._heightValues, s = e._indices; for (let a = 0, c = s.length; a < c; a += 3) { let u = s[a], f = s[a + 1], d = s[a + 2], p = i[u], g = i[f], m = i[d], A = o[u], C = o[f], x = o[d]; if (Cde(t, n, p, A, g, C, m, x)) { let T = Dg.computeBarycentricCoordinates(t, n, p, A, g, C, m, x, Ade); if (T.x >= -1e-15 && T.y >= -1e-15 && T.z >= -1e-15) { let b = T.x * r[u] + T.y * r[f] + T.z * r[d]; return I.lerp(e._minimumHeight, e._maximumHeight, b / YW) } } } } vg.prototype.isChildAvailable = function (e, t, n, i) { let o = 2; return n !== e * 2 && ++o, i !== t * 2 && (o -= 2), (this._childTileMask & 1 << o) !== 0 }; vg.prototype.wasCreatedByUpsampling = function () { return this._createdByUpsampling }; var sE = vg; function xZe(e) { this.resource = e.resource, this.version = e.version, this.isHeightmap = e.isHeightmap, this.tileUrlTemplates = e.tileUrlTemplates, this.availability = e.availability, this.hasVertexNormals = e.hasVertexNormals, this.hasWaterMask = e.hasWaterMask, this.hasMetadata = e.hasMetadata, this.availabilityLevels = e.availabilityLevels, this.availabilityTilesLoaded = e.availabilityTilesLoaded, this.littleEndianExtensionSize = e.littleEndianExtensionSize, this.availabilityPromiseCache = {} } function Wy(e) { this._heightmapWidth = 65, this._heightmapStructure = void 0, this._hasWaterMask = !1, this._hasVertexNormals = !1, this._ellipsoid = e.ellipsoid, this._requestVertexNormals = y(e.requestVertexNormals, !1), this._requestWaterMask = y(e.requestWaterMask, !1), this._requestMetadata = y(e.requestMetadata, !0), this._errorEvent = new _e; let t = e.credit; typeof t == "string" && (t = new Xt(t)), this._credit = t, this._availability = void 0, this._ready = !1, this._tileCredits = void 0; let n = this, i, o, r, s = this._layers = [], a = "", c = [], u = 0; this._readyPromise = Promise.resolve(e.url).then(function (A) { let C = Pe.createIfNeeded(A); return C.appendForwardSlash(), i = C, o = i.getDerivedResource({ url: "layer.json" }), n._tileCredits = C.credits, m() }); function f(A) { let C; if (!A.format) return C = "The tile format is not specified in the layer.json file.", r = Gn.reportError(r, n, n._errorEvent, C), r.retry ? m() : Promise.reject(new fe(C)); if (!A.tiles || A.tiles.length === 0) return C = "The layer.json file does not specify any tile URL templates.", r = Gn.reportError(r, n, n._errorEvent, C), r.retry ? m() : Promise.reject(new fe(C)); let x = !1, T = !1, b = !1, S = !0, D = !1; if (A.format === "heightmap-1.0") D = !0, l(n._heightmapStructure) || (n._heightmapStructure = { heightScale: 1 / 5, heightOffset: -1e3, elementsPerHeight: 1, stride: 1, elementMultiplier: 256, isBigEndian: !1, lowestEncodedHeight: 0, highestEncodedHeight: 256 * 256 - 1 }), T = !0, n._requestWaterMask = !0; else if (A.format.indexOf("quantized-mesh-1.") !== 0) return C = `The tile format "${A.format}" is invalid or not supported.`, r = Gn.reportError(r, n, n._errorEvent, C), r.retry ? m() : Promise.reject(new fe(C)); let P = A.tiles, B = A.maxzoom; if (u = Math.max(u, B), !A.projection || A.projection === "EPSG:4326") n._tilingScheme = new Hi({ numberOfLevelZeroTilesX: 2, numberOfLevelZeroTilesY: 1, ellipsoid: n._ellipsoid }); else if (A.projection === "EPSG:3857") n._tilingScheme = new Gr({ numberOfLevelZeroTilesX: 1, numberOfLevelZeroTilesY: 1, ellipsoid: n._ellipsoid }); else return C = `The projection "${A.projection}" is invalid or not supported.`, r = Gn.reportError(r, n, n._errorEvent, C), r.retry ? m() : Promise.reject(new fe(C)); if (n._levelZeroMaximumGeometricError = Hr.getEstimatedLevelZeroGeometricErrorForAHeightmap(n._tilingScheme.ellipsoid, n._heightmapWidth, n._tilingScheme.getNumberOfXTilesAtLevel(0)), !A.scheme || A.scheme === "tms" || A.scheme === "slippyMap") n._scheme = A.scheme; else return C = `The scheme "${A.scheme}" is invalid or not supported.`, r = Gn.reportError(r, n, n._errorEvent, C), r.retry ? m() : Promise.reject(new fe(C)); let R; l(A.extensions) && A.extensions.indexOf("octvertexnormals") !== -1 ? x = !0 : l(A.extensions) && A.extensions.indexOf("vertexnormals") !== -1 && (x = !0, S = !1), l(A.extensions) && A.extensions.indexOf("watermask") !== -1 && (T = !0), l(A.extensions) && A.extensions.indexOf("metadata") !== -1 && (b = !0); let M = A.metadataAvailability, L = A.available, _; if (l(L) && !l(M)) { _ = new bh(n._tilingScheme, L.length); for (let w = 0; w < L.length; ++w) { let v = L[w], O = n._tilingScheme.getNumberOfYTilesAtLevel(w); l(c[w]) || (c[w] = []); for (let V = 0; V < v.length; ++V) { let z = v[V], k = O - z.endY - 1, G = O - z.startY - 1; c[w].push([z.startX, k, z.endX, G]), _.addAvailableTileRange(w, z.startX, k, z.endX, G) } } } else l(M) && (R = new bh(n._tilingScheme, B), _ = new bh(n._tilingScheme, B), c[0] = [[0, 0, 1, 0]], _.addAvailableTileRange(0, 0, 0, 1, 0)); n._hasWaterMask = n._hasWaterMask || T, n._hasVertexNormals = n._hasVertexNormals || x, n._hasMetadata = n._hasMetadata || b, l(A.attribution) && (a.length > 0 && (a += " "), a += A.attribution), s.push(new xZe({ resource: i, version: A.version, isHeightmap: D, tileUrlTemplates: P, availability: _, hasVertexNormals: x, hasWaterMask: T, hasMetadata: b, availabilityLevels: M, availabilityTilesLoaded: R, littleEndianExtensionSize: S })); let E = A.parentUrl; if (l(E)) { if (!l(_)) return console.log("A layer.json can't have a parentUrl if it does't have an available array."), Promise.resolve(!0); i = i.getDerivedResource({ url: E }), i.appendForwardSlash(), o = i.getDerivedResource({ url: "layer.json" }); let w = o.fetchJson(); return Promise.resolve(w).then(f).catch(d) } return Promise.resolve(!0) } function d(A) { let C = `An error occurred while accessing ${o.url}.`; return r = Gn.reportError(r, n, n._errorEvent, C), r.retry ? m() : Promise.reject(new fe(C)) } function p(A) { return f(A).then(function () { if (l(r)) return; let C = c.length; if (C > 0) { let x = n._availability = new bh(n._tilingScheme, u); for (let T = 0; T < C; ++T) { let b = c[T]; for (let S = 0; S < b.length; ++S) { let D = b[S]; x.addAvailableTileRange(T, D[0], D[1], D[2], D[3]) } } } if (a.length > 0) { let x = new Xt(a); l(n._tileCredits) ? n._tileCredits.push(x) : n._tileCredits = [x] } return n._ready = !0, Promise.resolve(!0) }) } function g(A) { return l(A) && A.statusCode === 404 ? p({ tilejson: "2.1.0", format: "heightmap-1.0", version: "1.0.0", scheme: "tms", tiles: ["{z}/{x}/{y}.terrain?v={version}"] }) : d(A) } function m() { return Promise.resolve(o.fetchJson()).then(p).catch(g) } } var XW = { OCT_VERTEX_NORMALS: 1, WATER_MASK: 2, METADATA: 4 }; function xde(e) { return !l(e) || e.length === 0 ? { Accept: "application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01" } : { Accept: `application/vnd.quantized-mesh;extensions=${e.join("-")},application/octet-stream;q=0.9,*/*;q=0.01` } } function TZe(e, t, n, i, o) { let r = new Uint16Array(t, 0, e._heightmapWidth * e._heightmapWidth); return new Ma({ buffer: r, childTileMask: new Uint8Array(t, r.byteLength, 1)[0], waterMask: new Uint8Array(t, r.byteLength + 1, t.byteLength - r.byteLength - 1), width: e._heightmapWidth, height: e._heightmapWidth, structure: e._heightmapStructure, credits: e._tileCredits }) } function EZe(e, t, n, i, o, r) { let s = r.littleEndianExtensionSize, a = 0, c = 3, u = c + 1, f = Float64Array.BYTES_PER_ELEMENT * c, d = Float64Array.BYTES_PER_ELEMENT * u, p = 3, g = Uint16Array.BYTES_PER_ELEMENT * p, m = 3, A = Uint16Array.BYTES_PER_ELEMENT, C = A * m, x = new DataView(t), T = new h(x.getFloat64(a, !0), x.getFloat64(a + 8, !0), x.getFloat64(a + 16, !0)); a += f; let b = x.getFloat32(a, !0); a += Float32Array.BYTES_PER_ELEMENT; let S = x.getFloat32(a, !0); a += Float32Array.BYTES_PER_ELEMENT; let D = new re(new h(x.getFloat64(a, !0), x.getFloat64(a + 8, !0), x.getFloat64(a + 16, !0)), x.getFloat64(a + f, !0)); a += d; let P = new h(x.getFloat64(a, !0), x.getFloat64(a + 8, !0), x.getFloat64(a + 16, !0)); a += f; let B = x.getUint32(a, !0); a += Uint32Array.BYTES_PER_ELEMENT; let R = new Uint16Array(t, a, B * 3); a += B * g, B > 64 * 1024 && (A = Uint32Array.BYTES_PER_ELEMENT, C = A * m); let M = R.subarray(0, B), L = R.subarray(B, 2 * B), _ = R.subarray(B * 2, 3 * B); kn.zigZagDeltaDecode(M, L, _), a % A !== 0 && (a += A - a % A); let E = x.getUint32(a, !0); a += Uint32Array.BYTES_PER_ELEMENT; let w = Me.createTypedArrayFromArrayBuffer(B, t, a, E * m); a += E * C; let v = 0, O = w.length; for (let oe = 0; oe < O; ++oe) { let ue = w[oe]; w[oe] = v - ue, ue === 0 && ++v } let V = x.getUint32(a, !0); a += Uint32Array.BYTES_PER_ELEMENT; let z = Me.createTypedArrayFromArrayBuffer(B, t, a, V); a += V * A; let k = x.getUint32(a, !0); a += Uint32Array.BYTES_PER_ELEMENT; let G = Me.createTypedArrayFromArrayBuffer(B, t, a, k); a += k * A; let N = x.getUint32(a, !0); a += Uint32Array.BYTES_PER_ELEMENT; let X = Me.createTypedArrayFromArrayBuffer(B, t, a, N); a += N * A; let q = x.getUint32(a, !0); a += Uint32Array.BYTES_PER_ELEMENT; let J = Me.createTypedArrayFromArrayBuffer(B, t, a, q); a += q * A; let W, K; for (; a < x.byteLength;) { let oe = x.getUint8(a, !0); a += Uint8Array.BYTES_PER_ELEMENT; let ue = x.getUint32(a, s); if (a += Uint32Array.BYTES_PER_ELEMENT, oe === XW.OCT_VERTEX_NORMALS && e._requestVertexNormals) W = new Uint8Array(t, a, B * 2); else if (oe === XW.WATER_MASK && e._requestWaterMask) K = new Uint8Array(t, a, ue); else if (oe === XW.METADATA && e._requestMetadata) { let ge = x.getUint32(a, !0); if (ge > 0) { let Ie = Ko(new Uint8Array(t), a + Uint32Array.BYTES_PER_ELEMENT, ge).available; if (l(Ie)) for (let Fe = 0; Fe < Ie.length; ++Fe) { let We = n + Fe + 1, Lt = Ie[Fe], Gt = e._tilingScheme.getNumberOfYTilesAtLevel(We); for (let cn = 0; cn < Lt.length; ++cn) { let _t = Lt[cn], Pn = Gt - _t.endY - 1, Jn = Gt - _t.startY - 1; e.availability.addAvailableTileRange(We, _t.startX, Pn, _t.endX, Jn), r.availability.addAvailableTileRange(We, _t.startX, Pn, _t.endX, Jn) } } } r.availabilityTilesLoaded.addAvailableTileRange(n, i, o, i, o) } a += ue } let Z = e.getLevelMaximumGeometricError(n) * 5, de = e._tilingScheme.tileXYToRectangle(i, o, n), pe = di.fromRectangle(de, b, S, e._tilingScheme.ellipsoid); return new sE({ center: T, minimumHeight: b, maximumHeight: S, boundingSphere: D, orientedBoundingBox: pe, horizonOcclusionPoint: P, quantizedVertices: R, encodedNormals: W, indices: w, westIndices: z, southIndices: G, eastIndices: X, northIndices: J, westSkirtHeight: Z, southSkirtHeight: Z, eastSkirtHeight: Z, northSkirtHeight: Z, childTileMask: e.availability.computeChildMaskForTile(n, i, o), waterMask: K, credits: e._tileCredits }) } Wy.prototype.requestTileGeometry = function (e, t, n, i) { let o = this._layers, r, s = o.length; if (s === 1) r = o[0]; else for (let a = 0; a < s; ++a) { let c = o[a]; if (!l(c.availability) || c.availability.isTileAvailable(n, e, t)) { r = c; break } } return Tde(this, e, t, n, r, i) }; function Tde(e, t, n, i, o, r) { if (!l(o)) return Promise.reject(new fe("Terrain tile doesn't exist")); let s = o.tileUrlTemplates; if (s.length === 0) return; let a; !e._scheme || e._scheme === "tms" ? a = e._tilingScheme.getNumberOfYTilesAtLevel(i) - n - 1 : a = n; let c = []; e._requestVertexNormals && o.hasVertexNormals && c.push(o.littleEndianExtensionSize ? "octvertexnormals" : "vertexnormals"), e._requestWaterMask && o.hasWaterMask && c.push("watermask"), e._requestMetadata && o.hasMetadata && c.push("metadata"); let u, f, d = s[(t + a + i) % s.length], p = o.resource; l(p._ionEndpoint) && !l(p._ionEndpoint.externalType) ? (c.length !== 0 && (f = { extensions: c.join("-") }), u = xde(void 0)) : u = xde(c); let g = p.getDerivedResource({ url: d, templateValues: { version: o.version, z: i, x: t, y: a }, queryParameters: f, headers: u, request: r }).fetchArrayBuffer(); if (!!l(g)) return g.then(function (m) { return l(m) ? l(e._heightmapStructure) ? TZe(e, m, i, t, n) : EZe(e, m, i, t, n, o) : Promise.reject(new fe("Mesh buffer doesn't exist.")) }) } Object.defineProperties(Wy.prototype, { errorEvent: { get: function () { return this._errorEvent } }, credit: { get: function () { return this._credit } }, tilingScheme: { get: function () { return this._tilingScheme } }, ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } }, hasWaterMask: { get: function () { return this._hasWaterMask && this._requestWaterMask } }, hasVertexNormals: { get: function () { return this._hasVertexNormals && this._requestVertexNormals } }, hasMetadata: { get: function () { return this._hasMetadata && this._requestMetadata } }, requestVertexNormals: { get: function () { return this._requestVertexNormals } }, requestWaterMask: { get: function () { return this._requestWaterMask } }, requestMetadata: { get: function () { return this._requestMetadata } }, availability: { get: function () { return this._availability } } }); Wy.prototype.getLevelMaximumGeometricError = function (e) { return this._levelZeroMaximumGeometricError / (1 << e) }; Wy.prototype.getTileDataAvailable = function (e, t, n) { if (!l(this._availability)) return; if (n > this._availability._maximumLevel) return !1; if (this._availability.isTileAvailable(n, e, t)) return !0; if (!this._hasMetadata) return !1; let i = this._layers, o = i.length; for (let r = 0; r < o; ++r)if (Ede(this, e, t, n, i[r], r === 0).result) return; return !1 }; Wy.prototype.loadTileDataAvailability = function (e, t, n) { if (!l(this._availability) || n > this._availability._maximumLevel || this._availability.isTileAvailable(n, e, t) || !this._hasMetadata) return; let i = this._layers, o = i.length; for (let r = 0; r < o; ++r) { let s = Ede(this, e, t, n, i[r], r === 0); if (l(s.promise)) return s.promise } }; function KW(e, t, n, i) { if (i === 0) return; let o = e.availabilityLevels, r = i % o === 0 ? i - o : (i / o | 0) * o, s = 1 << i - r, a = t / s | 0, c = n / s | 0; return { level: r, x: a, y: c } } function Ede(e, t, n, i, o, r) { if (!l(o.availabilityLevels)) return { result: !1 }; let s, a = function () { delete o.availabilityPromiseCache[s] }, c = o.availabilityTilesLoaded, u = o.availability, f = KW(o, t, n, i); for (; l(f);) { if (u.isTileAvailable(f.level, f.x, f.y) && !c.isTileAvailable(f.level, f.x, f.y)) { let d; if (!r && (s = `${f.level}-${f.x}-${f.y}`, d = o.availabilityPromiseCache[s], !l(d))) { let p = new jo({ throttle: !1, throttleByServer: !0, type: Xr.TERRAIN }); d = Tde(e, f.x, f.y, f.level, o, p), l(d) && (o.availabilityPromiseCache[s] = d, d.then(a)) } return { result: !0, promise: d } } f = KW(o, f.x, f.y, f.level) } return { result: !1 } } Wy._getAvailabilityTile = KW; var F3 = Wy; function lp(e) { e = y(e, y.EMPTY_OBJECT); let t = e.radius, n = { center: e.center, semiMajorAxis: t, semiMinorAxis: t, ellipsoid: e.ellipsoid, height: e.height, extrudedHeight: e.extrudedHeight, granularity: e.granularity, vertexFormat: e.vertexFormat, stRotation: e.stRotation, shadowVolume: e.shadowVolume }; this._ellipseGeometry = new Yc(n), this._workerName = "createCircleGeometry" } lp.packedLength = Yc.packedLength; lp.pack = function (e, t, n) { return Yc.pack(e._ellipseGeometry, t, n) }; var bZe = new Yc({ center: new h, semiMajorAxis: 1, semiMinorAxis: 1 }), La = { center: new h, radius: void 0, ellipsoid: ie.clone(ie.UNIT_SPHERE), height: void 0, extrudedHeight: void 0, granularity: void 0, vertexFormat: new we, stRotation: void 0, semiMajorAxis: void 0, semiMinorAxis: void 0, shadowVolume: void 0 }; lp.unpack = function (e, t, n) { let i = Yc.unpack(e, t, bZe); return La.center = h.clone(i._center, La.center), La.ellipsoid = ie.clone(i._ellipsoid, La.ellipsoid), La.height = i._height, La.extrudedHeight = i._extrudedHeight, La.granularity = i._granularity, La.vertexFormat = we.clone(i._vertexFormat, La.vertexFormat), La.stRotation = i._stRotation, La.shadowVolume = i._shadowVolume, l(n) ? (La.semiMajorAxis = i._semiMajorAxis, La.semiMinorAxis = i._semiMinorAxis, n._ellipseGeometry = new Yc(La), n) : (La.radius = i._semiMajorAxis, new lp(La)) }; lp.createGeometry = function (e) { return Yc.createGeometry(e._ellipseGeometry) }; lp.createShadowVolume = function (e, t, n) { let i = e._ellipseGeometry._granularity, o = e._ellipseGeometry._ellipsoid, r = t(i, o), s = n(i, o); return new lp({ center: e._ellipseGeometry._center, radius: e._ellipseGeometry._semiMajorAxis, ellipsoid: o, stRotation: e._ellipseGeometry._stRotation, granularity: i, extrudedHeight: r, height: s, vertexFormat: we.POSITION_ONLY, shadowVolume: !0 }) }; Object.defineProperties(lp.prototype, { rectangle: { get: function () { return this._ellipseGeometry.rectangle } }, textureCoordinateRotationPoints: { get: function () { return this._ellipseGeometry.textureCoordinateRotationPoints } } }); var bde = lp; function aE(e) { e = y(e, y.EMPTY_OBJECT); let t = e.radius, n = { center: e.center, semiMajorAxis: t, semiMinorAxis: t, ellipsoid: e.ellipsoid, height: e.height, extrudedHeight: e.extrudedHeight, granularity: e.granularity, numberOfVerticalLines: e.numberOfVerticalLines }; this._ellipseGeometry = new Mu(n), this._workerName = "createCircleOutlineGeometry" } aE.packedLength = Mu.packedLength; aE.pack = function (e, t, n) { return Mu.pack(e._ellipseGeometry, t, n) }; var SZe = new Mu({ center: new h, semiMajorAxis: 1, semiMinorAxis: 1 }), Vl = { center: new h, radius: void 0, ellipsoid: ie.clone(ie.UNIT_SPHERE), height: void 0, extrudedHeight: void 0, granularity: void 0, numberOfVerticalLines: void 0, semiMajorAxis: void 0, semiMinorAxis: void 0 }; aE.unpack = function (e, t, n) { let i = Mu.unpack(e, t, SZe); return Vl.center = h.clone(i._center, Vl.center), Vl.ellipsoid = ie.clone(i._ellipsoid, Vl.ellipsoid), Vl.height = i._height, Vl.extrudedHeight = i._extrudedHeight, Vl.granularity = i._granularity, Vl.numberOfVerticalLines = i._numberOfVerticalLines, l(n) ? (Vl.semiMajorAxis = i._semiMajorAxis, Vl.semiMinorAxis = i._semiMinorAxis, n._ellipseGeometry = new Mu(Vl), n) : (Vl.radius = i._semiMajorAxis, new aE(Vl)) }; aE.createGeometry = function (e) { return Mu.createGeometry(e._ellipseGeometry) }; var Sde = aE; var ZW = po(al(), 1); var JW, wde = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJjYjNlMTg5Zi1hMzc2LTRmZjktOGEwZC00NGEzNTM0MTAzZGUiLCJpZCI6MjU5LCJpYXQiOjE1MTgxOTE2NTV9.qaP8-_Ej6AihGnv5iB990Hm6lHr8F_rrC3_EPxdT6MQ", N3 = {}; N3.defaultAccessToken = wde; N3.defaultServer = new Pe({ url: "https://api.cesium.com/" }); N3.getDefaultTokenCredit = function (e) { if (e === wde) { if (!l(JW)) { let t = `<b>             This application is using Cesium's default ion access token. Please assign <i>Cesium.Ion.defaultAccessToken</i>             with an access token from your ion account before making any Cesium API calls.             You can sign up for a free ion account at <a href="https://cesium.com">https://cesium.com</a>.</b>`; JW = new Xt(t, !0) } return JW } }; var Sh = N3; function yc(e, t) { let n, i = e.externalType, o = l(i); if (!o) n = { url: e.url, retryAttempts: 1, retryCallback: wZe }; else if (i === "3DTILES" || i === "STK_TERRAIN_SERVER") n = { url: e.options.url }; else throw new fe("Ion.createResource does not support external imagery assets; use IonImageryProvider instead."); Pe.call(this, n), this._ionEndpoint = e, this._ionEndpointDomain = o ? void 0 : new ZW.default(e.url).authority(), this._ionEndpointResource = t, this._ionRoot = void 0, this._pendingPromise = void 0, this._credits = void 0, this._isExternal = o } l(Object.create) && (yc.prototype = Object.create(Pe.prototype), yc.prototype.constructor = yc); yc.fromAssetId = function (e, t) { let n = yc._createEndpointResource(e, t); return n.fetchJson().then(function (i) { return new yc(i, n) }) }; Object.defineProperties(yc.prototype, { credits: { get: function () { return l(this._ionRoot) ? this._ionRoot.credits : l(this._credits) ? this._credits : (this._credits = yc.getCreditsFromEndpoint(this._ionEndpoint, this._ionEndpointResource), this._credits) } } }); yc.getCreditsFromEndpoint = function (e, t) { let n = e.attributions.map(Xt.getIonCredit), i = Sh.getDefaultTokenCredit(t.queryParameters.access_token); return l(i) && n.push(Xt.clone(i)), n }; yc.prototype.clone = function (e) { let t = y(this._ionRoot, this); return l(e) || (e = new yc(t._ionEndpoint, t._ionEndpointResource)), e = Pe.prototype.clone.call(this, e), e._ionRoot = t, e._isExternal = this._isExternal, e }; yc.prototype.fetchImage = function (e) { if (!this._isExternal) { let t = e; e = { preferBlob: !0 }, l(t) && (e.flipY = t.flipY, e.preferImageBitmap = t.preferImageBitmap) } return Pe.prototype.fetchImage.call(this, e) }; yc.prototype._makeRequest = function (e) { return this._isExternal || new ZW.default(this.url).authority() !== this._ionEndpointDomain ? Pe.prototype._makeRequest.call(this, e) : (l(e.headers) || (e.headers = {}), e.headers.Authorization = `Bearer ${this._ionEndpoint.accessToken}`, Pe.prototype._makeRequest.call(this, e)) }; yc._createEndpointResource = function (e, t) { t = y(t, y.EMPTY_OBJECT); let n = y(t.server, Sh.defaultServer), i = y(t.accessToken, Sh.defaultAccessToken); n = Pe.createIfNeeded(n); let o = { url: `v1/assets/${e}/endpoint` }; return l(i) && (o.queryParameters = { access_token: i }), n.getDerivedResource(o) }; function wZe(e, t) { let n = y(e._ionRoot, e), i = n._ionEndpointResource, o = typeof Image < "u"; return !l(t) || t.statusCode !== 401 && !(o && t.target instanceof Image) ? Promise.resolve(!1) : (l(n._pendingPromise) || (n._pendingPromise = i.fetchJson().then(function (r) { return n._ionEndpoint = r, r }).finally(function (r) { return n._pendingPromise = void 0, r })), n._pendingPromise.then(function (r) { return e._ionEndpoint = r, !0 })) } var wh = yc; function DZe(e) { return e = y(e, y.EMPTY_OBJECT), new F3({ url: wh.fromAssetId(1), requestVertexNormals: y(e.requestVertexNormals, !1), requestWaterMask: y(e.requestWaterMask, !1) }) } var V3 = DZe; function cE(e) { e = y(e, y.EMPTY_OBJECT), this._callback = e.callback, this._tilingScheme = e.tilingScheme, l(this._tilingScheme) || (this._tilingScheme = new Hi({ ellipsoid: y(e.ellipsoid, ie.WGS84) })), this._width = e.width, this._height = e.height; let t = Math.max(this._width, this._height); this._levelZeroMaximumGeometricError = Hr.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid, t, this._tilingScheme.getNumberOfXTilesAtLevel(0)), this._errorEvent = new _e; let n = e.credit; typeof n == "string" && (n = new Xt(n)), this._credit = n, this._readyPromise = Promise.resolve(!0) } Object.defineProperties(cE.prototype, { errorEvent: { get: function () { return this._errorEvent } }, credit: { get: function () { return this._credit } }, tilingScheme: { get: function () { return this._tilingScheme } }, ready: { get: function () { return !0 } }, readyPromise: { get: function () { return this._readyPromise } }, hasWaterMask: { get: function () { return !1 } }, hasVertexNormals: { get: function () { return !1 } }, width: { get: function () { return this._width } }, height: { get: function () { return this._height } } }); cE.prototype.requestTileGeometry = function (e, t, n, i) { let o = this._callback(e, t, n); if (!l(o)) return; let r = this._width, s = this._height; return Promise.resolve(o).then(function (a) { let c = a; return Array.isArray(c) && (c = new Float64Array(c)), new Ma({ buffer: c, width: r, height: s }) }) }; cE.prototype.getLevelMaximumGeometricError = function (e) { return this._levelZeroMaximumGeometricError / (1 << e) }; cE.prototype.getTileDataAvailable = function (e, t, n) { }; cE.prototype.loadTileDataAvailability = function (e, t, n) { }; var Dde = cE; var vZe = 1953029805, PZe = 2917034100; function QW(e, t) { if (QW.passThroughDataForTesting) return t; let n = e.byteLength; if (n === 0 || n % 4 !== 0) throw new fe("The length of key must be greater than 0 and a multiple of 4."); let i = new DataView(t), o = i.getUint32(0, !0); if (o === vZe || o === PZe) return t; let r = new DataView(e), s = 0, a = t.byteLength, c = a - a % 8, u = n, f, d = 8; for (; s < c;)for (d = (d + 8) % 24, f = d; s < c && f < u;)i.setUint32(s, i.getUint32(s, !0) ^ r.getUint32(f, !0), !0), i.setUint32(s + 4, i.getUint32(s + 4, !0) ^ r.getUint32(f + 4, !0), !0), s += 8, f += 24; if (s < a) for (f >= u && (d = (d + 8) % 24, f = d); s < a;)i.setUint8(s, i.getUint8(s) ^ r.getUint8(f)), s++, f++ } QW.passThroughDataForTesting = !1; var k3 = QW; function vde(e) { this.proxy = e } vde.prototype.getURL = function (e) { let t = this.proxy.indexOf("?") === -1 ? "?" : ""; return this.proxy + t + encodeURIComponent(e) }; var Pde = vde; function od(e) { this._comparator = e.comparator, this._maximumLength = e.maximumLength, this._array = l(e.maximumLength) ? new Array(e.maximumLength) : [], this._length = 0 } Object.defineProperties(od.prototype, { length: { get: function () { return this._length } }, maximumLength: { get: function () { return this._maximumLength }, set: function (e) { if (l(e)) { for (; this._length > e;)this.removeMinimum(); this._array.length = e } this._maximumLength = e } }, internalArray: { get: function () { return this._array } }, comparator: { get: function () { return this._comparator } } }); od.prototype.clone = function () { let e = this._maximumLength, t = this._comparator, n = this._array, i = this._length, o = new od({ comparator: t, maximumLength: e }); o._length = i; for (let r = 0; r < i; r++)o._array[r] = n[r]; return o }; od.prototype.reset = function () { this._length = 0; let e = this._maximumLength; if (l(e)) for (let t = 0; t < e; t++)this._array[t] = void 0; else this._array.length = 0 }; od.prototype.resort = function () { let e = this._length; for (let t = 0; t < e; t++)Ide(this, t) }; od.prototype.insert = function (e) { let t, n = this._maximumLength; if (l(n)) { if (n === 0) return; if (this._length === n) { let o = this._array[0]; if (this._comparator(e, o) <= 0) return e; t = this.removeMinimum() } } let i = this._length; return this._array[i] = e, this._length++, Ide(this, i), t }; od.prototype.removeMinimum = function () { let e = this._length; if (e === 0) return; this._length--; let t = this._array[0]; return e >= 2 && (this._array[0] = this._array[e - 1], Ode(this, 0)), this._array[e - 1] = void 0, t }; od.prototype.removeMaximum = function () { let e = this._length; if (e === 0) return; this._length--; let t; if (e <= 2) t = this._array[e - 1]; else { let n = $W(this, 1, 2) ? 1 : 2; t = this._array[n], this._array[n] = this._array[e - 1], e >= 4 && Ode(this, n) } return this._array[e - 1] = void 0, t }; od.prototype.getMinimum = function () { if (this._length !== 0) return this._array[0] }; od.prototype.getMaximum = function () { let e = this._length; if (e !== 0) return e <= 2 ? this._array[e - 1] : this._array[$W(this, 1, 2) ? 1 : 2] }; function U3(e, t, n) { let i = e._array, o = i[t]; i[t] = i[n], i[n] = o } function OD(e, t, n) { return e._comparator(e._array[t], e._array[n]) < 0 } function $W(e, t, n) { return e._comparator(e._array[t], e._array[n]) > 0 } function Ide(e, t) { if (t === 0) return; let n = Math.floor(I.log2(t + 1)) % 2 === 0, i = Math.floor((t - 1) / 2), o = OD(e, t, i); for (o !== n && (U3(e, t, i), t = i); t >= 3;) { let r = Math.floor((t - 3) / 4); if (OD(e, t, r) !== o) break; U3(e, t, r), t = r } } function Ode(e, t) { let n = e._length, i = Math.floor(I.log2(t + 1)) % 2 === 0, o; for (; (o = 2 * t + 1) < n;) { let r = o, s = o + 1; if (s < n) { OD(e, s, r) === i && (r = s); let a = 2 * o + 1, c = Math.max(Math.min(n - a, 4), 0); for (let u = 0; u < c; u++) { let f = a + u; OD(e, f, r) === i && (r = f) } } if (OD(e, r, t) === i && (U3(e, r, t), r !== o && r !== s)) { let a = Math.floor((r - 1) / 2); $W(e, r, a) === i && U3(e, r, a) } t = r } } var Bde = od; function lE(e) { e = y(e, y.EMPTY_OBJECT), this._tilingScheme = e.tilingScheme, l(this._tilingScheme) || (this._tilingScheme = new Hi({ ellipsoid: y(e.ellipsoid, ie.WGS84) })), this._levelZeroMaximumGeometricError = Hr.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid, 64, this._tilingScheme.getNumberOfXTilesAtLevel(0)), this._errorEvent = new _e, this._readyPromise = Promise.resolve(!0) } Object.defineProperties(lE.prototype, { errorEvent: { get: function () { return this._errorEvent } }, credit: { get: function () { } }, tilingScheme: { get: function () { return this._tilingScheme } }, ready: { get: function () { return !0 } }, readyPromise: { get: function () { return this._readyPromise } }, hasWaterMask: { get: function () { return !1 } }, hasVertexNormals: { get: function () { return !1 } }, availability: { get: function () { } } }); lE.prototype.requestTileGeometry = function (e, t, n, i) { return Promise.resolve(new Ma({ buffer: new Uint8Array(16 * 16), width: 16, height: 16 })) }; lE.prototype.getLevelMaximumGeometricError = function (e) { return this._levelZeroMaximumGeometricError / (1 << e) }; lE.prototype.getTileDataAvailable = function (e, t, n) { }; lE.prototype.loadTileDataAvailability = function (e, t, n) { }; var Pg = lE; function Dh(e) { e = y(e, y.EMPTY_OBJECT), this.left = e.left, this._left = void 0, this.right = e.right, this._right = void 0, this.top = e.top, this._top = void 0, this.bottom = e.bottom, this._bottom = void 0, this.near = y(e.near, 1), this._near = this.near, this.far = y(e.far, 5e8), this._far = this.far, this._cullingVolume = new Xs, this._perspectiveMatrix = new F, this._infinitePerspective = new F } function e7(e) { let t = e.top, n = e.bottom, i = e.right, o = e.left, r = e.near, s = e.far; (t !== e._top || n !== e._bottom || o !== e._left || i !== e._right || r !== e._near || s !== e._far) && (e._left = o, e._right = i, e._top = t, e._bottom = n, e._near = r, e._far = s, e._perspectiveMatrix = F.computePerspectiveOffCenter(o, i, n, t, r, s, e._perspectiveMatrix), e._infinitePerspective = F.computeInfinitePerspectiveOffCenter(o, i, n, t, r, e._infinitePerspective)) } Object.defineProperties(Dh.prototype, { projectionMatrix: { get: function () { return e7(this), this._perspectiveMatrix } }, infiniteProjectionMatrix: { get: function () { return e7(this), this._infinitePerspective } } }); var IZe = new h, OZe = new h, BZe = new h, RZe = new h; Dh.prototype.computeCullingVolume = function (e, t, n) { let i = this._cullingVolume.planes, o = this.top, r = this.bottom, s = this.right, a = this.left, c = this.near, u = this.far, f = h.cross(t, n, IZe), d = OZe; h.multiplyByScalar(t, c, d), h.add(e, d, d); let p = BZe; h.multiplyByScalar(t, u, p), h.add(e, p, p); let g = RZe; h.multiplyByScalar(f, a, g), h.add(d, g, g), h.subtract(g, e, g), h.normalize(g, g), h.cross(g, n, g), h.normalize(g, g); let m = i[0]; return l(m) || (m = i[0] = new se), m.x = g.x, m.y = g.y, m.z = g.z, m.w = -h.dot(g, e), h.multiplyByScalar(f, s, g), h.add(d, g, g), h.subtract(g, e, g), h.cross(n, g, g), h.normalize(g, g), m = i[1], l(m) || (m = i[1] = new se), m.x = g.x, m.y = g.y, m.z = g.z, m.w = -h.dot(g, e), h.multiplyByScalar(n, r, g), h.add(d, g, g), h.subtract(g, e, g), h.cross(f, g, g), h.normalize(g, g), m = i[2], l(m) || (m = i[2] = new se), m.x = g.x, m.y = g.y, m.z = g.z, m.w = -h.dot(g, e), h.multiplyByScalar(n, o, g), h.add(d, g, g), h.subtract(g, e, g), h.cross(g, f, g), h.normalize(g, g), m = i[3], l(m) || (m = i[3] = new se), m.x = g.x, m.y = g.y, m.z = g.z, m.w = -h.dot(g, e), m = i[4], l(m) || (m = i[4] = new se), m.x = t.x, m.y = t.y, m.z = t.z, m.w = -h.dot(t, d), h.negate(t, g), m = i[5], l(m) || (m = i[5] = new se), m.x = g.x, m.y = g.y, m.z = g.z, m.w = -h.dot(g, p), this._cullingVolume }; Dh.prototype.getPixelDimensions = function (e, t, n, i, o) { e7(this); let r = 1 / this.near, s = this.top * r, a = 2 * i * n * s / t; s = this.right * r; let c = 2 * i * n * s / e; return o.x = c, o.y = a, o }; Dh.prototype.clone = function (e) { return l(e) || (e = new Dh), e.right = this.right, e.left = this.left, e.top = this.top, e.bottom = this.bottom, e.near = this.near, e.far = this.far, e._left = void 0, e._right = void 0, e._top = void 0, e._bottom = void 0, e._near = void 0, e._far = void 0, e }; Dh.prototype.equals = function (e) { return l(e) && e instanceof Dh && this.right === e.right && this.left === e.left && this.top === e.top && this.bottom === e.bottom && this.near === e.near && this.far === e.far }; Dh.prototype.equalsEpsilon = function (e, t, n) { return e === this || l(e) && e instanceof Dh && I.equalsEpsilon(this.right, e.right, t, n) && I.equalsEpsilon(this.left, e.left, t, n) && I.equalsEpsilon(this.top, e.top, t, n) && I.equalsEpsilon(this.bottom, e.bottom, t, n) && I.equalsEpsilon(this.near, e.near, t, n) && I.equalsEpsilon(this.far, e.far, t, n) }; var $c = Dh; function el(e) { e = y(e, y.EMPTY_OBJECT), this._offCenterFrustum = new $c, this.fov = e.fov, this._fov = void 0, this._fovy = void 0, this._sseDenominator = void 0, this.aspectRatio = e.aspectRatio, this._aspectRatio = void 0, this.near = y(e.near, 1), this._near = this.near, this.far = y(e.far, 5e8), this._far = this.far, this.xOffset = y(e.xOffset, 0), this._xOffset = this.xOffset, this.yOffset = y(e.yOffset, 0), this._yOffset = this.yOffset } el.packedLength = 6; el.pack = function (e, t, n) { return n = y(n, 0), t[n++] = e.fov, t[n++] = e.aspectRatio, t[n++] = e.near, t[n++] = e.far, t[n++] = e.xOffset, t[n] = e.yOffset, t }; el.unpack = function (e, t, n) { return t = y(t, 0), l(n) || (n = new el), n.fov = e[t++], n.aspectRatio = e[t++], n.near = e[t++], n.far = e[t++], n.xOffset = e[t++], n.yOffset = e[t], n }; function vh(e) { let t = e._offCenterFrustum; (e.fov !== e._fov || e.aspectRatio !== e._aspectRatio || e.near !== e._near || e.far !== e._far || e.xOffset !== e._xOffset || e.yOffset !== e._yOffset) && (e._aspectRatio = e.aspectRatio, e._fov = e.fov, e._fovy = e.aspectRatio <= 1 ? e.fov : Math.atan(Math.tan(e.fov * .5) / e.aspectRatio) * 2, e._near = e.near, e._far = e.far, e._sseDenominator = 2 * Math.tan(.5 * e._fovy), e._xOffset = e.xOffset, e._yOffset = e.yOffset, t.top = e.near * Math.tan(.5 * e._fovy), t.bottom = -t.top, t.right = e.aspectRatio * t.top, t.left = -t.right, t.near = e.near, t.far = e.far, t.right += e.xOffset, t.left += e.xOffset, t.top += e.yOffset, t.bottom += e.yOffset) } Object.defineProperties(el.prototype, { projectionMatrix: { get: function () { return vh(this), this._offCenterFrustum.projectionMatrix } }, infiniteProjectionMatrix: { get: function () { return vh(this), this._offCenterFrustum.infiniteProjectionMatrix } }, fovy: { get: function () { return vh(this), this._fovy } }, sseDenominator: { get: function () { return vh(this), this._sseDenominator } } }); el.prototype.computeCullingVolume = function (e, t, n) { return vh(this), this._offCenterFrustum.computeCullingVolume(e, t, n) }; el.prototype.getPixelDimensions = function (e, t, n, i, o) { return vh(this), this._offCenterFrustum.getPixelDimensions(e, t, n, i, o) }; el.prototype.clone = function (e) { return l(e) || (e = new el), e.aspectRatio = this.aspectRatio, e.fov = this.fov, e.near = this.near, e.far = this.far, e._aspectRatio = void 0, e._fov = void 0, e._near = void 0, e._far = void 0, this._offCenterFrustum.clone(e._offCenterFrustum), e }; el.prototype.equals = function (e) { return !l(e) || !(e instanceof el) ? !1 : (vh(this), vh(e), this.fov === e.fov && this.aspectRatio === e.aspectRatio && this._offCenterFrustum.equals(e._offCenterFrustum)) }; el.prototype.equalsEpsilon = function (e, t, n) { return !l(e) || !(e instanceof el) ? !1 : (vh(this), vh(e), I.equalsEpsilon(this.fov, e.fov, t, n) && I.equalsEpsilon(this.aspectRatio, e.aspectRatio, t, n) && this._offCenterFrustum.equalsEpsilon(e._offCenterFrustum, t, n)) }; var mi = el; var z3 = 0, MZe = 1; function jy(e) { let t = e.frustum, n = e.orientation, i = e.origin, o = y(e.vertexFormat, we.DEFAULT), r = y(e._drawNearPlane, !0), s, a; t instanceof mi ? (s = z3, a = mi.packedLength) : t instanceof Zt && (s = MZe, a = Zt.packedLength), this._frustumType = s, this._frustum = t.clone(), this._origin = h.clone(i), this._orientation = Be.clone(n), this._drawNearPlane = r, this._vertexFormat = o, this._workerName = "createFrustumGeometry", this.packedLength = 2 + a + h.packedLength + Be.packedLength + we.packedLength } jy.pack = function (e, t, n) { n = y(n, 0); let i = e._frustumType, o = e._frustum; return t[n++] = i, i === z3 ? (mi.pack(o, t, n), n += mi.packedLength) : (Zt.pack(o, t, n), n += Zt.packedLength), h.pack(e._origin, t, n), n += h.packedLength, Be.pack(e._orientation, t, n), n += Be.packedLength, we.pack(e._vertexFormat, t, n), n += we.packedLength, t[n] = e._drawNearPlane ? 1 : 0, t }; var LZe = new mi, FZe = new Zt, NZe = new Be, VZe = new h, kZe = new we; jy.unpack = function (e, t, n) { t = y(t, 0); let i = e[t++], o; i === z3 ? (o = mi.unpack(e, t, LZe), t += mi.packedLength) : (o = Zt.unpack(e, t, FZe), t += Zt.packedLength); let r = h.unpack(e, t, VZe); t += h.packedLength; let s = Be.unpack(e, t, NZe); t += Be.packedLength; let a = we.unpack(e, t, kZe); t += we.packedLength; let c = e[t] === 1; if (!l(n)) return new jy({ frustum: o, origin: r, orientation: s, vertexFormat: a, _drawNearPlane: c }); let u = i === n._frustumType ? n._frustum : void 0; return n._frustum = o.clone(u), n._frustumType = i, n._origin = h.clone(r, n._origin), n._orientation = Be.clone(s, n._orientation), n._vertexFormat = we.clone(a, n._vertexFormat), n._drawNearPlane = c, n }; function uE(e, t, n, i, o, r, s, a) { let c = e / 3 * 2; for (let u = 0; u < 4; ++u)l(t) && (t[e] = r.x, t[e + 1] = r.y, t[e + 2] = r.z), l(n) && (n[e] = s.x, n[e + 1] = s.y, n[e + 2] = s.z), l(i) && (i[e] = a.x, i[e + 1] = a.y, i[e + 2] = a.z), e += 3; o[c] = 0, o[c + 1] = 0, o[c + 2] = 1, o[c + 3] = 0, o[c + 4] = 1, o[c + 5] = 1, o[c + 6] = 0, o[c + 7] = 1 } var UZe = new Q, zZe = new F, t7 = new F, Rde = new h, Mde = new h, Lde = new h, HZe = new h, GZe = new h, WZe = new h, Ig = new Array(3), BD = new Array(4); BD[0] = new se(-1, -1, 1, 1); BD[1] = new se(1, -1, 1, 1); BD[2] = new se(1, 1, 1, 1); BD[3] = new se(-1, 1, 1, 1); var Fde = new Array(4); for (let e = 0; e < 4; ++e)Fde[e] = new se; jy._computeNearFarPlanes = function (e, t, n, i, o, r, s, a) { let c = Q.fromQuaternion(t, UZe), u = y(r, Rde), f = y(s, Mde), d = y(a, Lde); u = Q.getColumn(c, 0, u), f = Q.getColumn(c, 1, f), d = Q.getColumn(c, 2, d), h.normalize(u, u), h.normalize(f, f), h.normalize(d, d), h.negate(u, u); let p = F.computeView(e, d, f, u, zZe), g, m; if (n === z3) { let A = i.projectionMatrix, C = F.multiply(A, p, t7); m = F.inverse(C, t7) } else g = F.inverseTransformation(p, t7); l(m) ? (Ig[0] = i.near, Ig[1] = i.far) : (Ig[0] = 0, Ig[1] = i.near, Ig[2] = i.far); for (let A = 0; A < 2; ++A)for (let C = 0; C < 4; ++C) { let x = se.clone(BD[C], Fde[C]); if (l(m)) { x = F.multiplyByVector(m, x, x); let T = 1 / x.w; h.multiplyByScalar(x, T, x), h.subtract(x, e, x), h.normalize(x, x); let b = h.dot(d, x); h.multiplyByScalar(x, Ig[A] / b, x), h.add(x, e, x) } else { l(i._offCenterFrustum) && (i = i._offCenterFrustum); let T = Ig[A], b = Ig[A + 1]; x.x = (x.x * (i.right - i.left) + i.left + i.right) * .5, x.y = (x.y * (i.top - i.bottom) + i.bottom + i.top) * .5, x.z = (x.z * (T - b) - T - b) * .5, x.w = 1, F.multiplyByVector(g, x, x) } o[12 * A + C * 3] = x.x, o[12 * A + C * 3 + 1] = x.y, o[12 * A + C * 3 + 2] = x.z } }; jy.createGeometry = function (e) { let t = e._frustumType, n = e._frustum, i = e._origin, o = e._orientation, r = e._drawNearPlane, s = e._vertexFormat, a = r ? 6 : 5, c = new Float64Array(3 * 4 * 6); jy._computeNearFarPlanes(i, o, t, n, c); let u = 3 * 4 * 2; c[u] = c[3 * 4], c[u + 1] = c[3 * 4 + 1], c[u + 2] = c[3 * 4 + 2], c[u + 3] = c[0], c[u + 4] = c[1], c[u + 5] = c[2], c[u + 6] = c[3 * 3], c[u + 7] = c[3 * 3 + 1], c[u + 8] = c[3 * 3 + 2], c[u + 9] = c[3 * 7], c[u + 10] = c[3 * 7 + 1], c[u + 11] = c[3 * 7 + 2], u += 3 * 4, c[u] = c[3 * 5], c[u + 1] = c[3 * 5 + 1], c[u + 2] = c[3 * 5 + 2], c[u + 3] = c[3], c[u + 4] = c[3 + 1], c[u + 5] = c[3 + 2], c[u + 6] = c[0], c[u + 7] = c[1], c[u + 8] = c[2], c[u + 9] = c[3 * 4], c[u + 10] = c[3 * 4 + 1], c[u + 11] = c[3 * 4 + 2], u += 3 * 4, c[u] = c[3], c[u + 1] = c[3 + 1], c[u + 2] = c[3 + 2], c[u + 3] = c[3 * 5], c[u + 4] = c[3 * 5 + 1], c[u + 5] = c[3 * 5 + 2], c[u + 6] = c[3 * 6], c[u + 7] = c[3 * 6 + 1], c[u + 8] = c[3 * 6 + 2], c[u + 9] = c[3 * 2], c[u + 10] = c[3 * 2 + 1], c[u + 11] = c[3 * 2 + 2], u += 3 * 4, c[u] = c[3 * 2], c[u + 1] = c[3 * 2 + 1], c[u + 2] = c[3 * 2 + 2], c[u + 3] = c[3 * 6], c[u + 4] = c[3 * 6 + 1], c[u + 5] = c[3 * 6 + 2], c[u + 6] = c[3 * 7], c[u + 7] = c[3 * 7 + 1], c[u + 8] = c[3 * 7 + 2], c[u + 9] = c[3 * 3], c[u + 10] = c[3 * 3 + 1], c[u + 11] = c[3 * 3 + 2], r || (c = c.subarray(3 * 4)); let f = new sn({ position: new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: c }) }); if (l(s.normal) || l(s.tangent) || l(s.bitangent) || l(s.st)) { let p = l(s.normal) ? new Float32Array(12 * a) : void 0, g = l(s.tangent) ? new Float32Array(3 * 4 * a) : void 0, m = l(s.bitangent) ? new Float32Array(3 * 4 * a) : void 0, A = l(s.st) ? new Float32Array(2 * 4 * a) : void 0, C = Rde, x = Mde, T = Lde, b = h.negate(C, HZe), S = h.negate(x, GZe), D = h.negate(T, WZe); u = 0, r && (uE(u, p, g, m, A, D, C, x), u += 3 * 4), uE(u, p, g, m, A, T, b, x), u += 3 * 4, uE(u, p, g, m, A, b, D, x), u += 3 * 4, uE(u, p, g, m, A, S, D, b), u += 3 * 4, uE(u, p, g, m, A, C, T, x), u += 3 * 4, uE(u, p, g, m, A, x, T, b), l(p) && (f.normal = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: p })), l(g) && (f.tangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: g })), l(m) && (f.bitangent = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: m })), l(A) && (f.st = new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 2, values: A })) } let d = new Uint16Array(6 * a); for (let p = 0; p < a; ++p) { let g = p * 6, m = p * 4; d[g] = m, d[g + 1] = m + 1, d[g + 2] = m + 2, d[g + 3] = m, d[g + 4] = m + 2, d[g + 5] = m + 3 } return new st({ attributes: f, indices: d, primitiveType: Oe.TRIANGLES, boundingSphere: re.fromVertices(c) }) }; var fE = jy; var n7 = 0, jZe = 1; function RD(e) { let t = e.frustum, n = e.orientation, i = e.origin, o = y(e._drawNearPlane, !0), r, s; t instanceof mi ? (r = n7, s = mi.packedLength) : t instanceof Zt && (r = jZe, s = Zt.packedLength), this._frustumType = r, this._frustum = t.clone(), this._origin = h.clone(i), this._orientation = Be.clone(n), this._drawNearPlane = o, this._workerName = "createFrustumOutlineGeometry", this.packedLength = 2 + s + h.packedLength + Be.packedLength } RD.pack = function (e, t, n) { n = y(n, 0); let i = e._frustumType, o = e._frustum; return t[n++] = i, i === n7 ? (mi.pack(o, t, n), n += mi.packedLength) : (Zt.pack(o, t, n), n += Zt.packedLength), h.pack(e._origin, t, n), n += h.packedLength, Be.pack(e._orientation, t, n), n += Be.packedLength, t[n] = e._drawNearPlane ? 1 : 0, t }; var qZe = new mi, YZe = new Zt, XZe = new Be, KZe = new h; RD.unpack = function (e, t, n) { t = y(t, 0); let i = e[t++], o; i === n7 ? (o = mi.unpack(e, t, qZe), t += mi.packedLength) : (o = Zt.unpack(e, t, YZe), t += Zt.packedLength); let r = h.unpack(e, t, KZe); t += h.packedLength; let s = Be.unpack(e, t, XZe); t += Be.packedLength; let a = e[t] === 1; if (!l(n)) return new RD({ frustum: o, origin: r, orientation: s, _drawNearPlane: a }); let c = i === n._frustumType ? n._frustum : void 0; return n._frustum = o.clone(c), n._frustumType = i, n._origin = h.clone(r, n._origin), n._orientation = Be.clone(s, n._orientation), n._drawNearPlane = a, n }; RD.createGeometry = function (e) { let t = e._frustumType, n = e._frustum, i = e._origin, o = e._orientation, r = e._drawNearPlane, s = new Float64Array(3 * 4 * 2); fE._computeNearFarPlanes(i, o, t, n, s); let a = new sn({ position: new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: s }) }), c, u, f = r ? 2 : 1, d = new Uint16Array(8 * (f + 1)), p = r ? 0 : 1; for (; p < 2; ++p)c = r ? p * 8 : 0, u = p * 4, d[c] = u, d[c + 1] = u + 1, d[c + 2] = u + 1, d[c + 3] = u + 2, d[c + 4] = u + 2, d[c + 5] = u + 3, d[c + 6] = u + 3, d[c + 7] = u; for (p = 0; p < 2; ++p)c = (f + p) * 8, u = p * 4, d[c] = u, d[c + 1] = u + 4, d[c + 2] = u + 1, d[c + 3] = u + 5, d[c + 4] = u + 2, d[c + 5] = u + 6, d[c + 6] = u + 3, d[c + 7] = u + 7; return new st({ attributes: a, indices: d, primitiveType: Oe.LINES, boundingSphere: re.fromVertices(s) }) }; var H3 = RD; function Nde() { } Nde.prototype.geocode = ye.throwInstantiationError; var Vde = Nde; var JZe = { SEARCH: 0, AUTOCOMPLETE: 1 }, qy = Object.freeze(JZe); function kde() { ye.throwInstantiationError() } kde.createGeometry = function (e) { ye.throwInstantiationError() }; var Ude = kde; function ZZe(e, t, n) { let i = new Uint8ClampedArray(e.buffer), o = new ImageData(i, t, n), r = document.createElement("canvas"); return r.width = t, r.height = n, r.getContext("2d").putImageData(o, 0, 0), r } var G3 = ZZe; var iQe = po(i7(), 1); function QZe(e, t) { return (e & t) !== 0 } var Ac = QZe; var $Ze = [1, 2, 4, 8], zde = 15, eQe = 16, tQe = 64, nQe = 128; function Ph(e, t, n, i, o, r) { this._bits = e, this.cnodeVersion = t, this.imageryVersion = n, this.terrainVersion = i, this.imageryProvider = o, this.terrainProvider = r, this.ancestorHasTerrain = !1, this.terrainState = void 0 } Ph.clone = function (e, t) { return l(t) ? (t._bits = e._bits, t.cnodeVersion = e.cnodeVersion, t.imageryVersion = e.imageryVersion, t.terrainVersion = e.terrainVersion, t.imageryProvider = e.imageryProvider, t.terrainProvider = e.terrainProvider) : t = new Ph(e._bits, e.cnodeVersion, e.imageryVersion, e.terrainVersion, e.imageryProvider, e.terrainProvider), t.ancestorHasTerrain = e.ancestorHasTerrain, t.terrainState = e.terrainState, t }; Ph.prototype.setParent = function (e) { this.ancestorHasTerrain = e.ancestorHasTerrain || this.hasTerrain() }; Ph.prototype.hasSubtree = function () { return Ac(this._bits, eQe) }; Ph.prototype.hasImagery = function () { return Ac(this._bits, tQe) }; Ph.prototype.hasTerrain = function () { return Ac(this._bits, nQe) }; Ph.prototype.hasChildren = function () { return Ac(this._bits, zde) }; Ph.prototype.hasChild = function (e) { return Ac(this._bits, $Ze[e]) }; Ph.prototype.getChildBitmask = function () { return this._bits & zde }; var W3 = Ph; function oQe(e) { let t = e.length, n = new ArrayBuffer(t), i = new Uint8Array(n); for (let o = 0; o < t; ++o)i[o] = e.charCodeAt(o); return n } var rQe = oQe(`E\xF4\xBD\vy\xE2jE"\x92,\xCDq\xF8IFgQ\0B%\xC6\xE8a,f)\b\xC64\xDCjb%y
wmi\xD6\xF0\x9Ck\x93\xA1\xBDNu\xE0A[\xDF@V\f\xD9\xBBr\x9B\x81|3S\xEEOl\xD4q\xB0{\xC0\x7FEVZ\xADwUe\v3\x92*\xACl5\xC50s\xF83>mF8J\xB4\xDD\xF0.\xDDu\xDA\x8CDt"\xFAa"\f3"So\xAF9D\v\x8C9\xD99L\xB9\xBF\x7F\xAB\\\x8CP_\x9F"ux\xE9\x07q\x91h;\xC1\xC4\x9B\x7F\xF0<VqH\x82'UfYNe\x98u\xA3aF}a?A\0\x9F\xD7\xB44M\xCE\x87F\xB0\xD5\xB8\x8A'{\x8B\xDC+\xBBMg0\xC8\xD1\xF6\\\x8FP\xFA[/F\x9Bn5/'C.\xEB
\f^\xA5s\x1Be4\xE5l.jC'c#U\xA9?q{gC}:\xAF\xCD\xE2TU\x9C\xFDK\xC6\xE2\x9F/(\xED\xCB\\\xC6-f\x07\x88\xA7;/*"N\xB0k.\xDD\r\x95}}G\xBAC\xB2\xB2+>M\xAA>}\xE6\xCEI\x89\xC6\xE6x\fa1-\xA4O\xA5~q \x88\xEC\r1\xE8N\v\0nPh}=\b\r\x95\xA6n\xA3h\x97$[k\xF3#\xF3\xB6s\xB3\r\v@\xC0\x9F\xD8Q]\xFA".j\xDFI\0\xB9\xA0wU\xC6\xEFj\xBF{GL\x7F\x83\xEE\xDC\xDCF\x85\xA9\xADS\x07+S4\x07\xFF\x94Y\xE48\xE81\x83N\xB9XFk\xCB-#\x86\x92p\x005\x88"\xCF1\xB2&/\xE7\xC3u-6,rt\xB0#G\xB7\xD3\xD1&\x857r\xE2\0\x8CD\xCF\xDA3-\xDE\`\x86i#i*|\xCDKQ\r\x95T9w.)\xEA\x1B\xA6P\xA2j\x8FoP\x99\\>T\xFB\xEFP[\v\x07E\x89m(w7\xDB\x8EJfJo\x99 \xE5p\xE2\xB9q~\fmI-z\xFEr\xC7\xF2Y0\x8F\xBB]s\xE5\xC9 \xEAx\xEC \x90\xF0\x8A\x7FB|G\`\xB0\xBD&\xB7q\xB6\xC7\x9F\xD13\x82=\xD3\xAB\xEEc\x99\xC8+S\xA0D\\q\xC6\xCCD2O<\xCA\xC0)=R\xD3aX\xA9}e\xB4\xDC\xCF\r\xF4=\xF1\b\xA9B\xDA#	\xD8\xBF^PI\xF8M\xC0\xCBGLO\xF7{+\xD8\xC51\x92;\xB5o\xDCl\r\x92\x88\xD1\x9E\xDB?\xE2\xE9\xDA_\xD4\x84\xE2FaZ\xDEU\xCF\xA4\0\xBE\xFD\xCEg\xF1Ji\x97\xE6 H\xD8]\x7F~\xAEq N\xAE\xC0V\xA9\x91<\x82r\xE7v\xEC)I\xD6]-\x83\xE3\xDB6\xA9;f\x97\x87j\xD5\xB6=P^R\xB9K\xC7sWx\xC9\xF4.Y\x07\x95\x93o\xD0KW>''\xC7\`\xDB;\xED\x9ASD>?\x8D\x92mw\xA2
\xEB?R\xA8\xC6U^1I7\x85\xF4\xC5&-\xA9\xBF\x8B'T\xDA\xC3j \xE5*x\xB0\xD6\x90pr\xAA\x8Bh\xBD\x88\xF7_H\xB1~\xC0XL?f\xF9>\xE1e\xC0p\xA7\xCF8i\xAF\xF0VldI\x9C'\xADxtO\xC2\x87\xDEV9\0\xDAw\v\xCB-\x1B\x89\xFB5O\xF5\bQ\`\xC1
ZGM&30x\xDA\xC0\x9CFG\xE2[y\`In7gS
>\xE9\xECF9\xB2\xF14\r\xC6\x84Sun\xE1\fY\xD9\xDE)\x85{II\xA5wy\xBEIV.6\xE7\v:\xBBOb{\xD2M1\x95/\xBD8{\xA8O!\xE1\xECFpv\x95})"x\x88
\x90\xDD\x9D\\\xDA\xDEQ\xCF\xF0\xFCYRe|3\xDF\xF3H\xDA\xBB*u\xDB\`\xB2\xD4\xFC\xED\x1B\xEC\x7F5\xA8\xFF(1\x07-\xC8\xDC\x88F|\x8A["`); function rd(e) { let t = e; typeof t != "string" && !(t instanceof Pe) && (t = e.url); let n = Pe.createIfNeeded(t); n.appendForwardSlash(), this._resource = n, this.imageryPresent = !0, this.protoImagery = void 0, this.terrainPresent = !0, this.negativeAltitudeExponentBias = 32, this.negativeAltitudeThreshold = I.EPSILON12, this.providers = {}, this.key = void 0, this._quadPacketVersion = 1, this._tileInfo = {}, this._subtreePromises = {}; let i = this; this._readyPromise = sQe(this).then(function () { return i.getQuadTreePacket("", i._quadPacketVersion) }).then(function () { return !0 }).catch(function (o) { let r = `An error occurred while accessing ${Gde(i, "", 1).url}.`; return Promise.reject(new fe(r)) }) } Object.defineProperties(rd.prototype, { url: { get: function () { return this._resource.url } }, proxy: { get: function () { return this._resource.proxy } }, resource: { get: function () { return this._resource } }, readyPromise: { get: function () { return this._readyPromise } } }); rd.tileXYToQuadKey = function (e, t, n) { let i = ""; for (let o = n; o >= 0; --o) { let r = 1 << o, s = 0; Ac(t, r) ? Ac(e, r) && (s |= 1) : (s |= 2, Ac(e, r) || (s |= 1)), i += s } return i }; rd.quadKeyToTileXY = function (e) { let t = 0, n = 0, i = e.length - 1; for (let o = i; o >= 0; --o) { let r = 1 << o, s = +e[i - o]; Ac(s, 2) ? Ac(s, 1) || (t |= r) : (n |= r, Ac(s, 1) && (t |= r)) } return { x: t, y: n, level: i } }; rd.prototype.isValid = function (e) { let t = this.getTileInformationFromQuadKey(e); if (l(t)) return t !== null; let n = !0, i = e, o; for (; i.length > 1;)if (o = i.substring(i.length - 1), i = i.substring(0, i.length - 1), t = this.getTileInformationFromQuadKey(i), l(t)) { !t.hasSubtree() && !t.hasChild(parseInt(o)) && (n = !1); break } else if (t === null) { n = !1; break } return n }; var Hde = new yi("decodeGoogleEarthEnterprisePacket"); rd.prototype.getQuadTreePacket = function (e, t, n) { t = y(t, 1), e = y(e, ""); let o = Gde(this, e, t, n).fetchArrayBuffer(); if (!l(o)) return; let r = this._tileInfo, s = this.key; return o.then(function (a) { return Hde.scheduleTask({ buffer: a, quadKey: e, type: "Metadata", key: s }, [a]).then(function (u) { let f, d = -1; if (e !== "") { d = e.length + 1; let m = u[e]; f = r[e], f._bits |= m._bits, delete u[e] } let p = Object.keys(u); p.sort(function (m, A) { return m.length - A.length }); let g = p.length; for (let m = 0; m < g; ++m) { let A = p[m]; if (u[A] !== null) { let x = W3.clone(u[A]), T = A.length; if (T === d) x.setParent(f); else if (T > 1) { let b = r[A.substring(0, A.length - 1)]; x.setParent(b) } r[A] = x } else r[A] = null } }) }) }; rd.prototype.populateSubtree = function (e, t, n, i) { let o = rd.tileXYToQuadKey(e, t, n); return s7(this, o, i) }; function s7(e, t, n) { let i = e._tileInfo, o = t, r = i[o]; if (l(r) && (!r.hasSubtree() || r.hasChildren())) return r; for (; r === void 0 && o.length > 1;)o = o.substring(0, o.length - 1), r = i[o]; let s, a = e._subtreePromises, c = a[o]; if (l(c)) return c.then(function () { return s = new jo({ throttle: n.throttle, throttleByServer: n.throttleByServer, type: n.type, priorityFunction: n.priorityFunction }), s7(e, t, s) }); if (!l(r) || !r.hasSubtree()) return Promise.reject(new fe(`Couldn't load metadata for tile ${t}`)); if (c = e.getQuadTreePacket(o, r.cnodeVersion, n), !!l(c)) return a[o] = c, c.then(function () { return s = new jo({ throttle: n.throttle, throttleByServer: n.throttleByServer, type: n.type, priorityFunction: n.priorityFunction }), s7(e, t, s) }).finally(function () { delete a[o] }) } rd.prototype.getTileInformation = function (e, t, n) { let i = rd.tileXYToQuadKey(e, t, n); return this._tileInfo[i] }; rd.prototype.getTileInformationFromQuadKey = function (e) { return this._tileInfo[e] }; function Gde(e, t, n, i) { return e._resource.getDerivedResource({ url: `flatfile?q2-0${t}-q.${n.toString()}`, request: i }) } var o7, r7; function sQe(e) { let t = e._resource.getDerivedResource({ url: "dbRoot.v5", queryParameters: { output: "proto" } }); if (!l(r7)) { let n = Jt("ThirdParty/google-earth-dbroot-parser.js"), i = window.cesiumGoogleEarthDbRootParser; r7 = XA(n).then(function () { o7 = window.cesiumGoogleEarthDbRootParser(iQe), l(i) ? window.cesiumGoogleEarthDbRootParser = i : delete window.cesiumGoogleEarthDbRootParser }) } return r7.then(function () { return t.fetchArrayBuffer() }).then(function (n) { let i = o7.EncryptedDbRootProto.decode(new Uint8Array(n)), o = i.encryptionData, r = o.byteOffset, s = r + o.byteLength, a = e.key = o.buffer.slice(r, s); o = i.dbrootData, r = o.byteOffset, s = r + o.byteLength; let c = o.buffer.slice(r, s); return Hde.scheduleTask({ buffer: c, type: "DbRoot", key: a }, [c]) }).then(function (n) { let i = o7.DbRootProto.decode(new Uint8Array(n.buffer)); if (e.imageryPresent = y(i.imageryPresent, e.imageryPresent), e.protoImagery = i.protoImagery, e.terrainPresent = y(i.terrainPresent, e.terrainPresent), l(i.endSnippet) && l(i.endSnippet.model)) { let a = i.endSnippet.model; e.negativeAltitudeExponentBias = y(a.negativeAltitudeExponentBias, e.negativeAltitudeExponentBias), e.negativeAltitudeThreshold = y(a.compressedNegativeAltitudeThreshold, e.negativeAltitudeThreshold) } l(i.databaseVersion) && (e._quadPacketVersion = y(i.databaseVersion.quadtreeVersion, e._quadPacketVersion)); let o = e.providers, r = y(i.providerInfo, []), s = r.length; for (let a = 0; a < s; ++a) { let c = r[a], u = c.copyrightString; l(u) && (o[c.providerId] = new Xt(u.value)) } }).catch(function () { console.log(`Failed to retrieve ${t.url}. Using defaults.`), e.key = rQe }) } var Ih = rd; function Yy(e) { e = y(e, y.EMPTY_OBJECT), this._buffer = e.buffer, this._credits = e.credits, this._negativeAltitudeExponentBias = e.negativeAltitudeExponentBias, this._negativeElevationThreshold = e.negativeElevationThreshold; let t = y(e.childTileMask, 15), n = t & 3; n |= t & 4 ? 8 : 0, n |= t & 8 ? 4 : 0, this._childTileMask = n, this._createdByUpsampling = y(e.createdByUpsampling, !1), this._skirtHeight = void 0, this._bufferType = this._buffer.constructor, this._mesh = void 0, this._minimumHeight = void 0, this._maximumHeight = void 0 } Object.defineProperties(Yy.prototype, { credits: { get: function () { return this._credits } }, waterMask: { get: function () { } } }); var qde = "createVerticesFromGoogleEarthEnterpriseBuffer", aQe = new yi(qde), cQe = new yi(qde, Eh.maximumAsynchronousTasks), Wde = new ce, a7 = new ce; Yy.prototype.createMesh = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.tilingScheme, n = e.x, i = e.y, o = e.level, r = y(e.exaggeration, 1), s = y(e.exaggerationRelativeHeight, 0), a = y(e.throttle, !0), c = t.ellipsoid; t.tileXYToNativeRectangle(n, i, o, Wde), t.tileXYToRectangle(n, i, o, a7); let u = c.cartographicToCartesian(ce.center(a7)), d = 40075.16 / (1 << o); this._skirtHeight = Math.min(d * 8, 1e3); let g = (a ? cQe : aQe).scheduleTask({ buffer: this._buffer, nativeRectangle: Wde, rectangle: a7, relativeToCenter: u, ellipsoid: c, skirtHeight: this._skirtHeight, exaggeration: r, exaggerationRelativeHeight: s, includeWebMercatorT: !0, negativeAltitudeExponentBias: this._negativeAltitudeExponentBias, negativeElevationThreshold: this._negativeElevationThreshold }); if (!l(g)) return; let m = this; return g.then(function (A) { return m._mesh = new id(u, new Float32Array(A.vertices), new Uint16Array(A.indices), A.indexCountWithoutSkirts, A.vertexCountWithoutSkirts, A.minimumHeight, A.maximumHeight, re.clone(A.boundingSphere3D), h.clone(A.occludeePointInScaledSpace), A.numberOfAttributes, di.clone(A.orientedBoundingBox), _c.clone(A.encoding), A.westIndicesSouthToNorth, A.southIndicesEastToWest, A.eastIndicesNorthToSouth, A.northIndicesWestToEast), m._minimumHeight = A.minimumHeight, m._maximumHeight = A.maximumHeight, m._buffer = void 0, m._mesh }) }; Yy.prototype.interpolateHeight = function (e, t, n) { let i = I.clamp((t - e.west) / e.width, 0, 1), o = I.clamp((n - e.south) / e.height, 0, 1); return l(this._mesh) ? hQe(this, i, o) : _Qe(this, i, o, e) }; var lQe = new yi("upsampleQuantizedTerrainMesh", Eh.maximumAsynchronousTasks); Yy.prototype.upsample = function (e, t, n, i, o, r, s) { let a = this._mesh; if (!l(this._mesh)) return; let c = t * 2 !== o, u = n * 2 === r, f = e.ellipsoid, d = e.tileXYToRectangle(o, r, s), p = lQe.scheduleTask({ vertices: a.vertices, indices: a.indices, indexCountWithoutSkirts: a.indexCountWithoutSkirts, vertexCountWithoutSkirts: a.vertexCountWithoutSkirts, encoding: a.encoding, minimumHeight: this._minimumHeight, maximumHeight: this._maximumHeight, isEastChild: c, isNorthChild: u, childRectangle: d, ellipsoid: f }); if (!l(p)) return; let g = this; return p.then(function (m) { let A = new Uint16Array(m.vertices), C = Me.createTypedArray(A.length / 3, m.indices), x = g._skirtHeight; return new sE({ quantizedVertices: A, indices: C, minimumHeight: m.minimumHeight, maximumHeight: m.maximumHeight, boundingSphere: re.clone(m.boundingSphere), orientedBoundingBox: di.clone(m.orientedBoundingBox), horizonOcclusionPoint: h.clone(m.horizonOcclusionPoint), westIndices: m.westIndices, southIndices: m.southIndices, eastIndices: m.eastIndices, northIndices: m.northIndices, westSkirtHeight: x, southSkirtHeight: x, eastSkirtHeight: x, northSkirtHeight: x, childTileMask: 0, createdByUpsampling: !0, credits: g._credits }) }) }; Yy.prototype.isChildAvailable = function (e, t, n, i) { let o = 2; return n !== e * 2 && ++o, i !== t * 2 && (o -= 2), (this._childTileMask & 1 << o) !== 0 }; Yy.prototype.wasCreatedByUpsampling = function () { return this._createdByUpsampling }; var uQe = new H, fQe = new H, dQe = new H, Yde = new h; function hQe(e, t, n) { let i = e._mesh, o = i.vertices, r = i.encoding, s = i.indices; for (let a = 0, c = s.length; a < c; a += 3) { let u = s[a], f = s[a + 1], d = s[a + 2], p = r.decodeTextureCoordinates(o, u, uQe), g = r.decodeTextureCoordinates(o, f, fQe), m = r.decodeTextureCoordinates(o, d, dQe), A = Dg.computeBarycentricCoordinates(t, n, p.x, p.y, g.x, g.y, m.x, m.y, Yde); if (A.x >= -1e-15 && A.y >= -1e-15 && A.z >= -1e-15) { let C = r.decodeHeight(o, u), x = r.decodeHeight(o, f), T = r.decodeHeight(o, d); return A.x * C + A.y * x + A.z * T } } } var mQe = Uint16Array.BYTES_PER_ELEMENT, jde = Uint32Array.BYTES_PER_ELEMENT, c7 = Int32Array.BYTES_PER_ELEMENT, pQe = Float32Array.BYTES_PER_ELEMENT, l7 = Float64Array.BYTES_PER_ELEMENT; function _Qe(e, t, n, i) { let o = e._buffer, r = 0, s = 0, a = 0; n > .5 ? (t > .5 ? (r = 2, s = .5) : r = 3, a = .5) : t > .5 && (r = 1, s = .5); let c = new DataView(o), u = 0; for (let D = 0; D < r; ++D)u += c.getUint32(u, !0), u += jde; u += jde, u += 2 * l7; let f = I.toRadians(c.getFloat64(u, !0) * 180); u += l7; let d = I.toRadians(c.getFloat64(u, !0) * 180); u += l7; let p = i.width / f / 2, g = i.height / d / 2, m = c.getInt32(u, !0); u += c7; let A = c.getInt32(u, !0) * 3; u += c7, u += c7; let C = new Array(m), x = new Array(m), T = new Array(m), b; for (b = 0; b < m; ++b)C[b] = s + c.getUint8(u++) * p, x[b] = a + c.getUint8(u++) * g, T[b] = c.getFloat32(u, !0) * 6371010, u += pQe; let S = new Array(A); for (b = 0; b < A; ++b)S[b] = c.getUint16(u, !0), u += mQe; for (b = 0; b < A; b += 3) { let D = S[b], P = S[b + 1], B = S[b + 2], R = C[D], M = C[P], L = C[B], _ = x[D], E = x[P], w = x[B], v = Dg.computeBarycentricCoordinates(t, n, R, _, M, E, L, w, Yde); if (v.x >= -1e-15 && v.y >= -1e-15 && v.z >= -1e-15) return v.x * T[D] + v.y * T[P] + v.z * T[B] } } var MD = Yy; var Yu = { UNKNOWN: 0, NONE: 1, SELF: 2, PARENT: 3 }, j3 = new $; function q3() { this._terrainCache = {}, this._lastTidy = $.now() } q3.prototype.add = function (e, t) { this._terrainCache[e] = { buffer: t, timestamp: $.now() } }; q3.prototype.get = function (e) { let n = this._terrainCache[e]; if (l(n)) return delete this._terrainCache[e], n.buffer }; q3.prototype.tidy = function () { if ($.now(j3), $.secondsDifference(j3, this._lastTidy) > 10) { let e = this._terrainCache, t = Object.keys(e), n = t.length; for (let i = 0; i < n; ++i) { let o = t[i], r = e[o]; $.secondsDifference(j3, r.timestamp) > 10 && delete e[o] } $.clone(j3, this._lastTidy) } }; function dE(e) { e = y(e, y.EMPTY_OBJECT); let t; if (l(e.metadata)) t = e.metadata; else { let r = Pe.createIfNeeded(e.url); t = new Ih(r) } this._metadata = t, this._tilingScheme = new Hi({ numberOfLevelZeroTilesX: 2, numberOfLevelZeroTilesY: 2, rectangle: new ce(-I.PI, -I.PI, I.PI, I.PI), ellipsoid: e.ellipsoid }); let n = e.credit; typeof n == "string" && (n = new Xt(n)), this._credit = n, this._levelZeroMaximumGeometricError = 40075.16, this._terrainCache = new q3, this._terrainPromises = {}, this._terrainRequests = {}, this._errorEvent = new _e, this._ready = !1; let i = this, o; this._readyPromise = t.readyPromise.then(function (r) { if (!t.terrainPresent) { let s = new fe(`The server ${t.url} doesn't have terrain`); return o = Gn.reportError(o, i, i._errorEvent, s.message, void 0, void 0, void 0, s), Promise.reject(s) } return Gn.reportSuccess(o), i._ready = r, r }).catch(function (r) { return o = Gn.reportError(o, i, i._errorEvent, r.message, void 0, void 0, void 0, r), Promise.reject(r) }) } Object.defineProperties(dE.prototype, { url: { get: function () { return this._metadata.url } }, proxy: { get: function () { return this._metadata.proxy } }, tilingScheme: { get: function () { return this._tilingScheme } }, errorEvent: { get: function () { return this._errorEvent } }, ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } }, credit: { get: function () { return this._credit } }, hasWaterMask: { get: function () { return !1 } }, hasVertexNormals: { get: function () { return !1 } }, availability: { get: function () { } } }); var gQe = new yi("decodeGoogleEarthEnterprisePacket"); function Xde(e, t, n) { let i = t.getChildBitmask(); if (t.terrainState === Yu.PARENT) { i = 0; for (let o = 0; o < 4; ++o) { let r = n.getTileInformationFromQuadKey(e + o.toString()); l(r) && r.hasTerrain() && (i |= 1 << o) } } return i } dE.prototype.requestTileGeometry = function (e, t, n, i) { let o = Ih.tileXYToQuadKey(e, t, n), r = this._terrainCache, s = this._metadata, a = s.getTileInformationFromQuadKey(o); if (!l(a)) return Promise.reject(new fe("Terrain tile doesn't exist")); let c = a.terrainState; l(c) || (c = a.terrainState = Yu.UNKNOWN); let u = r.get(o); if (l(u)) { let x = s.providers[a.terrainProvider]; return Promise.resolve(new MD({ buffer: u, childTileMask: Xde(o, a, s), credits: l(x) ? [x] : void 0, negativeAltitudeExponentBias: s.negativeAltitudeExponentBias, negativeElevationThreshold: s.negativeAltitudeThreshold })) } if (r.tidy(), a.ancestorHasTerrain) { if (c === Yu.NONE) return Promise.reject(new fe("Terrain tile doesn't exist")) } else return Promise.resolve(new Ma({ buffer: new Uint8Array(16 * 16), width: 16, height: 16 })); let f, d = o, p = -1; switch (c) { case Yu.SELF: p = a.terrainVersion; break; case Yu.PARENT: d = d.substring(0, d.length - 1), f = s.getTileInformationFromQuadKey(d), p = f.terrainVersion; break; case Yu.UNKNOWN: a.hasTerrain() ? p = a.terrainVersion : (d = d.substring(0, d.length - 1), f = s.getTileInformationFromQuadKey(d), l(f) && f.hasTerrain() && (p = f.terrainVersion)); break }if (p < 0) return Promise.reject(new fe("Terrain tile doesn't exist")); let g = this._terrainPromises, m = this._terrainRequests, A, C; if (l(g[d])) A = g[d], C = m[d]; else { C = i; let x = yQe(this, d, p, C).fetchArrayBuffer(); if (!l(x)) return; A = x.then(function (T) { return l(T) ? gQe.scheduleTask({ buffer: T, type: "Terrain", key: s.key }, [T]).then(function (b) { let S = s.getTileInformationFromQuadKey(d); S.terrainState = Yu.SELF, r.add(d, b[0]); let D = S.terrainProvider, P = b.length - 1; for (let B = 0; B < P; ++B) { let R = d + B.toString(), M = s.getTileInformationFromQuadKey(R); l(M) && (r.add(R, b[B + 1]), M.terrainState = Yu.PARENT, M.terrainProvider === 0 && (M.terrainProvider = D)) } }) : Promise.reject(new fe("Failed to load terrain.")) }), g[d] = A, m[d] = C, A = A.finally(function () { delete g[d], delete m[d] }) } return A.then(function () { let x = r.get(o); if (l(x)) { let T = s.providers[a.terrainProvider]; return new MD({ buffer: x, childTileMask: Xde(o, a, s), credits: l(T) ? [T] : void 0, negativeAltitudeExponentBias: s.negativeAltitudeExponentBias, negativeElevationThreshold: s.negativeAltitudeThreshold }) } return Promise.reject(new fe("Failed to load terrain.")) }).catch(function (x) { return C.state === ri.CANCELLED ? (i.state = C.state, Promise.reject(x)) : (a.terrainState = Yu.NONE, Promise.reject(x)) }) }; dE.prototype.getLevelMaximumGeometricError = function (e) { return this._levelZeroMaximumGeometricError / (1 << e) }; dE.prototype.getTileDataAvailable = function (e, t, n) { let i = this._metadata, o = Ih.tileXYToQuadKey(e, t, n), r = i.getTileInformation(e, t, n); if (r === null) return !1; if (l(r)) { if (!r.ancestorHasTerrain) return !0; let s = r.terrainState; if (s === Yu.NONE) return !1; if ((!l(s) || s === Yu.UNKNOWN) && (r.terrainState = Yu.UNKNOWN, !r.hasTerrain())) { o = o.substring(0, o.length - 1); let a = i.getTileInformationFromQuadKey(o); if (!l(a) || !a.hasTerrain()) return !1 } return !0 } if (i.isValid(o)) { let s = new jo({ throttle: !1, throttleByServer: !0, type: Xr.TERRAIN }); i.populateSubtree(e, t, n, s) } return !1 }; dE.prototype.loadTileDataAvailability = function (e, t, n) { }; function yQe(e, t, n, i) { return n = l(n) && n > 0 ? n : 1, e._metadata.resource.getDerivedResource({ url: `flatfile?f1c-0${t}-t.${n.toString()}`, request: i }) } var Kde = dE; function AQe(e, t, n, i) { this.rightAscension = e, this.declination = t, this.rotation = n, this.rotationRate = i } var Y3 = AQe; var lhe = {}, CQe = 32.184, xQe = 2451545, Jde = -.0529921, Zde = -.1059842, Qde = 13.0120009, $de = 13.3407154, ehe = .9856003, the = 26.4057084, nhe = 13.064993, ihe = .3287146, ohe = 1.7484877, rhe = -.1589763, she = .0036096, ahe = .1643573, che = 12.9590088, u7 = new $; lhe.ComputeMoon = function (e, t) { l(e) || (e = $.now()), u7 = $.addSeconds(e, CQe, u7); let n = $.totalDays(u7) - xQe, i = n / jn.DAYS_PER_JULIAN_CENTURY, o = (125.045 + Jde * n) * I.RADIANS_PER_DEGREE, r = (250.089 + Zde * n) * I.RADIANS_PER_DEGREE, s = (260.008 + Qde * n) * I.RADIANS_PER_DEGREE, a = (176.625 + $de * n) * I.RADIANS_PER_DEGREE, c = (357.529 + ehe * n) * I.RADIANS_PER_DEGREE, u = (311.589 + the * n) * I.RADIANS_PER_DEGREE, f = (134.963 + nhe * n) * I.RADIANS_PER_DEGREE, d = (276.617 + ihe * n) * I.RADIANS_PER_DEGREE, p = (34.226 + ohe * n) * I.RADIANS_PER_DEGREE, g = (15.134 + rhe * n) * I.RADIANS_PER_DEGREE, m = (119.743 + she * n) * I.RADIANS_PER_DEGREE, A = (239.961 + ahe * n) * I.RADIANS_PER_DEGREE, C = (25.053 + che * n) * I.RADIANS_PER_DEGREE, x = Math.sin(o), T = Math.sin(r), b = Math.sin(s), S = Math.sin(a), D = Math.sin(c), P = Math.sin(u), B = Math.sin(f), R = Math.sin(d), M = Math.sin(p), L = Math.sin(g), _ = Math.sin(m), E = Math.sin(A), w = Math.sin(C), v = Math.cos(o), O = Math.cos(r), V = Math.cos(s), z = Math.cos(a), k = Math.cos(c), G = Math.cos(u), N = Math.cos(f), X = Math.cos(d), q = Math.cos(p), J = Math.cos(g), W = Math.cos(m), K = Math.cos(A), Z = Math.cos(C), de = (269.9949 + .0031 * i - 3.8787 * x - .1204 * T + .07 * b - .0172 * S + .0072 * P - .0052 * L + .0043 * w) * I.RADIANS_PER_DEGREE, pe = (66.5392 + .013 * i + 1.5419 * v + .0239 * O - .0278 * V + .0068 * z - .0029 * G + 9e-4 * N + 8e-4 * J - 9e-4 * Z) * I.RADIANS_PER_DEGREE, oe = (38.3213 + 13.17635815 * n - 14e-13 * n * n + 3.561 * x + .1208 * T - .0642 * b + .0158 * S + .0252 * D - .0066 * P - .0047 * B - .0046 * R + .0028 * M + .0052 * L + .004 * _ + .0019 * E - .0044 * w) * I.RADIANS_PER_DEGREE, ue = (13.17635815 - 14e-13 * (2 * n) + 3.561 * v * Jde + .1208 * O * Zde - .0642 * V * Qde + .0158 * z * $de + .0252 * k * ehe - .0066 * G * the - .0047 * N * nhe - .0046 * X * ihe + .0028 * q * ohe + .0052 * J * rhe + .004 * W * she + .0019 * K * ahe - .0044 * Z * che) / 86400 * I.RADIANS_PER_DEGREE; return l(t) || (t = new Y3), t.rightAscension = de, t.declination = pe, t.rotation = oe, t.rotationRate = ue, t }; var X3 = lhe; function uhe(e) { (!l(e) || typeof e != "function") && (e = X3.ComputeMoon), this._computeFunction = e } var TQe = new h, EQe = new h, bQe = new h; function SQe(e, t, n) { let i = TQe; i.x = Math.cos(e + I.PI_OVER_TWO), i.y = Math.sin(e + I.PI_OVER_TWO), i.z = 0; let o = Math.cos(t), r = bQe; r.x = o * Math.cos(e), r.y = o * Math.sin(e), r.z = Math.sin(t); let s = h.cross(r, i, EQe); return l(n) || (n = new Q), n[0] = i.x, n[1] = s.x, n[2] = r.x, n[3] = i.y, n[4] = s.y, n[5] = r.y, n[6] = i.z, n[7] = s.z, n[8] = r.z, n } var wQe = new Q, DQe = new Be; uhe.prototype.evaluate = function (e, t) { l(e) || (e = $.now()); let n = this._computeFunction(e), i = SQe(n.rightAscension, n.declination, t), o = I.zeroToTwoPi(n.rotation), r = Be.fromAxisAngle(h.UNIT_Z, o, DQe), s = Q.fromQuaternion(Be.conjugate(r, r), wQe); return Q.multiply(s, i, i) }; var K3 = uhe; var LD = {}; LD.type = void 0; LD.getRequiredDataPoints = ye.throwInstantiationError; LD.interpolateOrderZero = ye.throwInstantiationError; LD.interpolate = ye.throwInstantiationError; var fhe = LD; function f7(e) { this._url = Pe.createIfNeeded(e), this._url.appendForwardSlash() } Object.defineProperties(f7.prototype, { url: { get: function () { return this._url } } }); f7.prototype.geocode = function (e, t) { return this._url.getDerivedResource({ url: t === qy.AUTOCOMPLETE ? "autocomplete" : "search", queryParameters: { text: e } }).fetchJson().then(function (i) { return i.features.map(function (o) { let r, s = o.bbox; if (l(s)) r = ce.fromDegrees(s[0], s[1], s[2], s[3]); else { let a = o.geometry.coordinates[0], c = o.geometry.coordinates[1]; r = h.fromDegrees(a, c) } return { displayName: o.properties.label, destination: r } }) }) }; var J3 = f7; function dhe(e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.accessToken, Sh.defaultAccessToken), n = Pe.createIfNeeded(y(e.server, Sh.defaultServer)); n.appendForwardSlash(); let i = Sh.getDefaultTokenCredit(t); l(i) && e.scene.frameState.creditDisplay.addDefaultCredit(Xt.clone(i)); let o = n.getDerivedResource({ url: "v1/geocode" }); l(t) && o.appendQueryParameters({ access_token: t }), this._accessToken = t, this._server = n, this._pelias = new J3(o) } dhe.prototype.geocode = function (e, t) { return this._pelias.geocode(e, t) }; var Z3 = dhe; var vQe = { SHIFT: 0, CTRL: 1, ALT: 2 }, oa = Object.freeze(vQe); function Q3() { ye.throwInstantiationError() } Object.defineProperties(Q3.prototype, { ellipsoid: { get: ye.throwInstantiationError } }); Q3.prototype.project = ye.throwInstantiationError; Q3.prototype.unproject = ye.throwInstantiationError; var hhe = Q3; var d7 = [], h7 = []; function PQe(e, t, n, i, o, r) { let s = o - i + 1, a = r - o, c = d7, u = h7, f, d; for (f = 0; f < s; ++f)c[f] = e[i + f]; for (d = 0; d < a; ++d)u[d] = e[o + d + 1]; f = 0, d = 0; for (let p = i; p <= r; ++p) { let g = c[f], m = u[d]; f < s && (d >= a || t(g, m, n) <= 0) ? (e[p] = g, ++f) : d < a && (e[p] = m, ++d) } } function m7(e, t, n, i, o) { if (i >= o) return; let r = Math.floor((i + o) * .5); m7(e, t, n, i, r), m7(e, t, n, r + 1, o), PQe(e, t, n, i, r, o) } function IQe(e, t, n) { let i = e.length, o = Math.ceil(i * .5); d7.length = o, h7.length = o, m7(e, t, n, 0, i - 1), d7.length = 0, h7.length = 0 } var Xy = IQe; function hE(e) { e = y(e, y.EMPTY_OBJECT); let t = e.weights, n = e.times; this._times = n, this._weights = t, this._count = t.length / n.length, this._lastTimeIndex = 0 } Object.defineProperties(hE.prototype, { times: { get: function () { return this._times } }, weights: { get: function () { return this._weights } } }); hE.prototype.findTimeInterval = Qi.prototype.findTimeInterval; hE.prototype.wrapTime = Qi.prototype.wrapTime; hE.prototype.clampTime = Qi.prototype.clampTime; hE.prototype.evaluate = function (e, t) { let n = this.weights, i = this.times, o = this._lastTimeIndex = this.findTimeInterval(e, this._lastTimeIndex), r = (e - i[o]) / (i[o + 1] - i[o]); l(t) || (t = new Array(this._count)); for (let s = 0; s < this._count; s++) { let a = o * this._count + s; t[s] = n[a] * (1 - r) + n[a + this._count] * r } return t }; var mhe = hE; var OQe = { NONE: -1, PARTIAL: 0, FULL: 1 }, lr = Object.freeze(OQe); function Fa(e, t) { this._occluderPosition = h.clone(e.center), this._occluderRadius = e.radius, this._horizonDistance = 0, this._horizonPlaneNormal = void 0, this._horizonPlanePosition = void 0, this._cameraPosition = void 0, this.cameraPosition = t } var $3 = new h; Object.defineProperties(Fa.prototype, { position: { get: function () { return this._occluderPosition } }, radius: { get: function () { return this._occluderRadius } }, cameraPosition: { set: function (e) { e = h.clone(e, this._cameraPosition); let t = h.subtract(this._occluderPosition, e, $3), n = h.magnitudeSquared(t), i = this._occluderRadius * this._occluderRadius, o, r, s; if (n > i) { o = Math.sqrt(n - i), n = 1 / Math.sqrt(n), r = h.multiplyByScalar(t, n, $3); let a = o * o * n; s = h.add(e, h.multiplyByScalar(r, a, $3), $3) } else o = Number.MAX_VALUE; this._horizonDistance = o, this._horizonPlaneNormal = r, this._horizonPlanePosition = s, this._cameraPosition = e } } }); Fa.fromBoundingSphere = function (e, t, n) { return l(n) ? (h.clone(e.center, n._occluderPosition), n._occluderRadius = e.radius, n.cameraPosition = t, n) : new Fa(e, t) }; var _he = new h; Fa.prototype.isPointVisible = function (e) { if (this._horizonDistance !== Number.MAX_VALUE) { let t = h.subtract(e, this._occluderPosition, _he), n = this._occluderRadius; if (n = h.magnitudeSquared(t) - n * n, n > 0) return n = Math.sqrt(n) + this._horizonDistance, t = h.subtract(e, this._cameraPosition, t), n * n > h.magnitudeSquared(t) } return !1 }; var BQe = new h; Fa.prototype.isBoundingSphereVisible = function (e) { let t = h.clone(e.center, BQe), n = e.radius; if (this._horizonDistance !== Number.MAX_VALUE) { let i = h.subtract(t, this._occluderPosition, _he), o = this._occluderRadius - n; if (o = h.magnitudeSquared(i) - o * o, n < this._occluderRadius) return o > 0 ? (o = Math.sqrt(o) + this._horizonDistance, i = h.subtract(t, this._cameraPosition, i), o * o + n * n > h.magnitudeSquared(i)) : !1; if (o > 0) { i = h.subtract(t, this._cameraPosition, i); let r = h.magnitudeSquared(i), s = this._occluderRadius * this._occluderRadius, a = n * n; return (this._horizonDistance * this._horizonDistance + s) * a > r * s ? !0 : (o = Math.sqrt(o) + this._horizonDistance, o * o + a > r) } return !0 } return !1 }; var RQe = new h; Fa.prototype.computeVisibility = function (e) { let t = h.clone(e.center), n = e.radius; if (n > this._occluderRadius) return lr.FULL; if (this._horizonDistance !== Number.MAX_VALUE) { let i = h.subtract(t, this._occluderPosition, RQe), o = this._occluderRadius - n, r = h.magnitudeSquared(i); if (o = r - o * o, o > 0) { o = Math.sqrt(o) + this._horizonDistance, i = h.subtract(t, this._cameraPosition, i); let s = h.magnitudeSquared(i); return o * o + n * n < s ? lr.NONE : (o = this._occluderRadius + n, o = r - o * o, o > 0 ? (o = Math.sqrt(o) + this._horizonDistance, s < o * o + n * n ? lr.FULL : lr.PARTIAL) : (i = h.subtract(t, this._horizonPlanePosition, i), h.dot(i, this._horizonPlaneNormal) > -n ? lr.PARTIAL : lr.FULL)) } } return lr.NONE }; var eV = new h; Fa.computeOccludeePoint = function (e, t, n) { let i = h.clone(t), o = h.clone(e.center), r = e.radius, s = n.length, a = h.normalize(h.subtract(i, o, eV), eV), c = -h.dot(a, o), u = Fa._anyRotationVector(o, a, c), f = Fa._horizonToPlaneNormalDotProduct(e, a, c, u, n[0]); if (!f) return; let d; for (let g = 1; g < s; ++g) { if (d = Fa._horizonToPlaneNormalDotProduct(e, a, c, u, n[g]), !d) return; d < f && (f = d) } if (f < .0017453283658983088) return; let p = r / f; return h.add(o, h.multiplyByScalar(a, p, eV), eV) }; var MQe = []; Fa.computeOccludeePointFromRectangle = function (e, t) { t = y(t, ie.WGS84); let n = ce.subsample(e, t, 0, MQe), i = re.fromPoints(n), o = h.ZERO; if (!h.equals(o, i.center)) return Fa.computeOccludeePoint(new re(o, t.minimumRadius), i.center, n) }; var LQe = new h; Fa._anyRotationVector = function (e, t, n) { let i = h.abs(t, LQe), o = i.x > i.y ? 0 : 1; (o === 0 && i.z > i.x || o === 1 && i.z > i.y) && (o = 2); let r = new h, s; o === 0 ? (i.x = e.x, i.y = e.y + 1, i.z = e.z + 1, s = h.UNIT_X) : o === 1 ? (i.x = e.x + 1, i.y = e.y, i.z = e.z + 1, s = h.UNIT_Y) : (i.x = e.x + 1, i.y = e.y + 1, i.z = e.z, s = h.UNIT_Z); let a = (h.dot(t, i) + n) / -h.dot(t, s); return h.normalize(h.subtract(h.add(i, h.multiplyByScalar(s, a, r), i), e, i), i) }; var FQe = new h; Fa._rotationVector = function (e, t, n, i, o) { let r = h.subtract(i, e, FQe); if (r = h.normalize(r, r), h.dot(t, r) < .9999999847691291) { let s = h.cross(t, r, r); if (h.magnitude(s) > I.EPSILON13) return h.normalize(s, new h) } return o }; var p7 = new h, NQe = new h, tV = new h, phe = new h; Fa._horizonToPlaneNormalDotProduct = function (e, t, n, i, o) { let r = h.clone(o, p7), s = h.clone(e.center, NQe), a = e.radius, c = h.subtract(s, r, tV), u = h.magnitudeSquared(c), f = a * a; if (u < f) return !1; let d = u - f, p = Math.sqrt(d), g = Math.sqrt(u), m = 1 / g, C = p * m * p; c = h.normalize(c, c); let x = h.add(r, h.multiplyByScalar(c, C, phe), phe), T = Math.sqrt(d - C * C), b = this._rotationVector(s, t, n, r, i), S = h.fromElements(b.x * b.x * c.x + (b.x * b.y - b.z) * c.y + (b.x * b.z + b.y) * c.z, (b.x * b.y + b.z) * c.x + b.y * b.y * c.y + (b.y * b.z - b.x) * c.z, (b.x * b.z - b.y) * c.x + (b.y * b.z + b.x) * c.y + b.z * b.z * c.z, p7); S = h.normalize(S, S); let D = h.multiplyByScalar(S, T, p7); b = h.normalize(h.subtract(h.add(x, D, tV), s, tV), tV); let P = h.dot(t, b); b = h.normalize(h.subtract(h.subtract(x, D, b), s, b), b); let B = h.dot(t, b); return P < B ? P : B }; var nV = Fa; function _7(e, t, n) { e = Pe.createIfNeeded(e), e.appendForwardSlash(), e.setQueryParameters({ key: t }), this._url = e, this._params = y(n, {}) } Object.defineProperties(_7.prototype, { url: { get: function () { return this._url } }, params: { get: function () { return this._params } } }); _7.prototype.geocode = function (e) { return this._url.getDerivedResource({ url: "json", queryParameters: yt(this._params, { q: e }) }).fetchJson().then(function (n) { return n.results.map(function (i) { let o, r = i.bounds; if (l(r)) o = ce.fromDegrees(r.southwest.lng, r.southwest.lat, r.northeast.lng, r.northeast.lat); else { let s = i.geometry.lat, a = i.geometry.lng; o = h.fromDegrees(s, a) } return { displayName: i.formatted, destination: o } }) }) }; var ghe = _7; var VQe = { packedLength: void 0, pack: ye.throwInstantiationError, unpack: ye.throwInstantiationError }, yhe = VQe; var kQe = { packedInterpolationLength: void 0, convertPackedArrayForInterpolation: ye.throwInstantiationError, unpackInterpolationResult: ye.throwInstantiationError }, Ahe = kQe; var UQe = new h; function zQe(e, t, n, i) { let o = dC(e, t, n, i, UQe); return l(o) ? o.x > 0 && o.y > 0 && o.z > 0 : !1 } var Che = zQe; function xhe() { ye.throwInstantiationError() } xhe.prototype.getURL = ye.throwInstantiationError; var The = xhe; var Ky; typeof requestAnimationFrame < "u" && (Ky = requestAnimationFrame); (function () { if (!l(Ky) && typeof window < "u") { let e = ["webkit", "moz", "ms", "o"], t = 0, n = e.length; for (; t < n && !l(Ky);)Ky = window[`${e[t]}RequestAnimationFrame`], ++t } if (!l(Ky)) { let e = 16.666666666666668, t = 0; Ky = function (n) { let i = Ei(), o = Math.max(e - (i - t), 0); return t = i + o, setTimeout(function () { n(t) }, o) } } })(); function HQe(e) { return Jr("Cesium.requestAnimationFrame", "Cesium.requestAnimationFrame was deprecated in CesiumJS 1.96 and will be removed in 1.99. Use the native requestAnimationFrame method instead."), Ky(e) } var Ehe = HQe; var GQe = { LEFT_DOWN: 0, LEFT_UP: 1, LEFT_CLICK: 2, LEFT_DOUBLE_CLICK: 3, RIGHT_DOWN: 5, RIGHT_UP: 6, RIGHT_CLICK: 7, MIDDLE_DOWN: 10, MIDDLE_UP: 11, MIDDLE_CLICK: 12, MOUSE_MOVE: 15, WHEEL: 16, PINCH_START: 17, PINCH_END: 18, PINCH_MOVE: 19 }, pn = Object.freeze(GQe); function Og(e, t, n) { let i = e._element; if (i === document) return n.x = t.clientX, n.y = t.clientY, n; let o = i.getBoundingClientRect(); return n.x = t.clientX - o.left, n.y = t.clientY - o.top, n } function T7(e, t) { let n = e; return l(t) && (n += `+${t}`), n } function Jy(e) { if (e.shiftKey) return oa.SHIFT; if (e.ctrlKey) return oa.CTRL; if (e.altKey) return oa.ALT } var ns = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }; function kl(e, t, n, i) { function o(r) { i(e, r) } Nt.isInternetExplorer() ? n.addEventListener(t, o, !1) : n.addEventListener(t, o, { capture: !1, passive: !1 }), e._removalFunctions.push(function () { n.removeEventListener(t, o, !1) }) } function WQe(e) { let t = e._element, n = l(t.disableRootEvents) ? t : document; Nt.supportsPointerEvents() ? (kl(e, "pointerdown", t, JQe), kl(e, "pointerup", t, Rhe), kl(e, "pointermove", t, ZQe), kl(e, "pointercancel", t, Rhe)) : (kl(e, "mousedown", t, Mhe), kl(e, "mouseup", n, Lhe), kl(e, "mousemove", n, Fhe), kl(e, "touchstart", t, XQe), kl(e, "touchend", n, vhe), kl(e, "touchmove", n, KQe), kl(e, "touchcancel", n, vhe)), kl(e, "dblclick", t, qQe); let i; "onwheel" in t ? i = "wheel" : document.onmousewheel !== void 0 ? i = "mousewheel" : i = "DOMMouseScroll", kl(e, i, t, YQe) } function jQe(e) { let t = e._removalFunctions; for (let n = 0; n < t.length; ++n)t[n]() } var bhe = { position: new H }; function E7(e) { e._lastSeenTouchEvent = Ei() } function b7(e) { return Ei() - e._lastSeenTouchEvent > sd.mouseEmulationIgnoreMilliseconds } function x7(e, t, n) { let i = e.x - t.x, o = e.y - t.y; return Math.sqrt(i * i + o * o) < n } function Mhe(e, t) { if (!b7(e)) return; let n = t.button; e._buttonDown[n] = !0; let i; if (n === ns.LEFT) i = pn.LEFT_DOWN; else if (n === ns.MIDDLE) i = pn.MIDDLE_DOWN; else if (n === ns.RIGHT) i = pn.RIGHT_DOWN; else return; let o = Og(e, t, e._primaryPosition); H.clone(o, e._primaryStartPosition), H.clone(o, e._primaryPreviousPosition); let r = Jy(t), s = e.getInputAction(i, r); l(s) && (H.clone(o, bhe.position), s(bhe), t.preventDefault()) } var She = { position: new H }, whe = { position: new H }; function g7(e, t, n, i) { let o = Jy(i), r = e.getInputAction(t, o), s = e.getInputAction(n, o); if (l(r) || l(s)) { let a = Og(e, i, e._primaryPosition); if (l(r) && (H.clone(a, She.position), r(She)), l(s)) { let c = e._primaryStartPosition; x7(c, a, e._clickPixelTolerance) && (H.clone(a, whe.position), s(whe)) } } } function Lhe(e, t) { if (!b7(e)) return; let n = t.button; n !== ns.LEFT && n !== ns.MIDDLE && n !== ns.RIGHT || (e._buttonDown[ns.LEFT] && (g7(e, pn.LEFT_UP, pn.LEFT_CLICK, t), e._buttonDown[ns.LEFT] = !1), e._buttonDown[ns.MIDDLE] && (g7(e, pn.MIDDLE_UP, pn.MIDDLE_CLICK, t), e._buttonDown[ns.MIDDLE] = !1), e._buttonDown[ns.RIGHT] && (g7(e, pn.RIGHT_UP, pn.RIGHT_CLICK, t), e._buttonDown[ns.RIGHT] = !1)) } var y7 = { startPosition: new H, endPosition: new H }; function Fhe(e, t) { if (!b7(e)) return; let n = Jy(t), i = Og(e, t, e._primaryPosition), o = e._primaryPreviousPosition, r = e.getInputAction(pn.MOUSE_MOVE, n); l(r) && (H.clone(o, y7.startPosition), H.clone(i, y7.endPosition), r(y7)), H.clone(i, o), (e._buttonDown[ns.LEFT] || e._buttonDown[ns.MIDDLE] || e._buttonDown[ns.RIGHT]) && t.preventDefault() } var Dhe = { position: new H }; function qQe(e, t) { let n = t.button, i; if (n === ns.LEFT) i = pn.LEFT_DOUBLE_CLICK; else return; let o = Jy(t), r = e.getInputAction(i, o); l(r) && (Og(e, t, Dhe.position), r(Dhe)) } function YQe(e, t) { let n; if (l(t.deltaY)) { let r = t.deltaMode; r === t.DOM_DELTA_PIXEL ? n = -t.deltaY : r === t.DOM_DELTA_LINE ? n = -t.deltaY * 40 : n = -t.deltaY * 120 } else t.detail > 0 ? n = t.detail * -120 : n = t.wheelDelta; if (!l(n)) return; let i = Jy(t), o = e.getInputAction(pn.WHEEL, i); l(o) && (o(n), t.preventDefault()) } function XQe(e, t) { E7(e); let n = t.changedTouches, i, o = n.length, r, s, a = e._positions; for (i = 0; i < o; ++i)r = n[i], s = r.identifier, a.set(s, Og(e, r, new H)); iV(e, t); let c = e._previousPositions; for (i = 0; i < o; ++i)r = n[i], s = r.identifier, c.set(s, H.clone(a.get(s))) } function vhe(e, t) { E7(e); let n = t.changedTouches, i, o = n.length, r, s, a = e._positions; for (i = 0; i < o; ++i)r = n[i], s = r.identifier, a.remove(s); iV(e, t); let c = e._previousPositions; for (i = 0; i < o; ++i)r = n[i], s = r.identifier, c.remove(s) } var Phe = { position: new H }, A7 = { position1: new H, position2: new H }, Ihe = { position: new H }, Ohe = { position: new H }, Bhe = { position: new H }; function iV(e, t) { let n = Jy(t), i = e._positions, o = i.length, r, s, a = e._isPinching; if (o !== 1 && e._buttonDown[ns.LEFT]) { if (e._buttonDown[ns.LEFT] = !1, l(e._touchHoldTimer) && (clearTimeout(e._touchHoldTimer), e._touchHoldTimer = void 0), r = e.getInputAction(pn.LEFT_UP, n), l(r) && (H.clone(e._primaryPosition, Ihe.position), r(Ihe)), o === 0 && !e._isTouchHolding && (s = e.getInputAction(pn.LEFT_CLICK, n), l(s))) { let c = e._primaryStartPosition, u = e._previousPositions.values[0]; x7(c, u, e._clickPixelTolerance) && (H.clone(e._primaryPosition, Ohe.position), s(Ohe)) } e._isTouchHolding = !1 } if (o === 0 && a && (e._isPinching = !1, r = e.getInputAction(pn.PINCH_END, n), l(r) && r()), o === 1 && !a) { let c = i.values[0]; H.clone(c, e._primaryPosition), H.clone(c, e._primaryStartPosition), H.clone(c, e._primaryPreviousPosition), e._buttonDown[ns.LEFT] = !0, r = e.getInputAction(pn.LEFT_DOWN, n), l(r) && (H.clone(c, Phe.position), r(Phe)), e._touchHoldTimer = setTimeout(function () { if (!e.isDestroyed() && (e._touchHoldTimer = void 0, e._isTouchHolding = !0, s = e.getInputAction(pn.RIGHT_CLICK, n), l(s))) { let u = e._primaryStartPosition, f = e._previousPositions.values[0]; x7(u, f, e._holdPixelTolerance) && (H.clone(e._primaryPosition, Bhe.position), s(Bhe)) } }, sd.touchHoldDelayMilliseconds), t.preventDefault() } o === 2 && !a && (e._isPinching = !0, r = e.getInputAction(pn.PINCH_START, n), l(r) && (H.clone(i.values[0], A7.position1), H.clone(i.values[1], A7.position2), r(A7), t.preventDefault())) } function KQe(e, t) { E7(e); let n = t.changedTouches, i, o = n.length, r, s, a = e._positions; for (i = 0; i < o; ++i) { r = n[i], s = r.identifier; let u = a.get(s); l(u) && Og(e, r, u) } Nhe(e, t); let c = e._previousPositions; for (i = 0; i < o; ++i)r = n[i], s = r.identifier, H.clone(a.get(s), c.get(s)) } var C7 = { startPosition: new H, endPosition: new H }, FD = { distance: { startPosition: new H, endPosition: new H }, angleAndHeight: { startPosition: new H, endPosition: new H } }; function Nhe(e, t) { let n = Jy(t), i = e._positions, o = e._previousPositions, r = i.length, s; if (r === 1 && e._buttonDown[ns.LEFT]) { let a = i.values[0]; H.clone(a, e._primaryPosition); let c = e._primaryPreviousPosition; s = e.getInputAction(pn.MOUSE_MOVE, n), l(s) && (H.clone(c, C7.startPosition), H.clone(a, C7.endPosition), s(C7)), H.clone(a, c), t.preventDefault() } else if (r === 2 && e._isPinching && (s = e.getInputAction(pn.PINCH_MOVE, n), l(s))) { let a = i.values[0], c = i.values[1], u = o.values[0], f = o.values[1], d = c.x - a.x, p = c.y - a.y, g = Math.sqrt(d * d + p * p) * .25, m = f.x - u.x, A = f.y - u.y, C = Math.sqrt(m * m + A * A) * .25, x = (c.y + a.y) * .125, T = (f.y + u.y) * .125, b = Math.atan2(p, d), S = Math.atan2(A, m); H.fromElements(0, C, FD.distance.startPosition), H.fromElements(0, g, FD.distance.endPosition), H.fromElements(S, T, FD.angleAndHeight.startPosition), H.fromElements(b, x, FD.angleAndHeight.endPosition), s(FD) } } function JQe(e, t) { if (t.target.setPointerCapture(t.pointerId), t.pointerType === "touch") { let n = e._positions, i = t.pointerId; n.set(i, Og(e, t, new H)), iV(e, t), e._previousPositions.set(i, H.clone(n.get(i))) } else Mhe(e, t) } function Rhe(e, t) { if (t.pointerType === "touch") { let n = e._positions, i = t.pointerId; n.remove(i), iV(e, t), e._previousPositions.remove(i) } else Lhe(e, t) } function ZQe(e, t) { if (t.pointerType === "touch") { let n = e._positions, i = t.pointerId, o = n.get(i); if (!l(o)) return; Og(e, t, o), Nhe(e, t); let r = e._previousPositions; H.clone(n.get(i), r.get(i)) } else Fhe(e, t) } function sd(e) { this._inputEvents = {}, this._buttonDown = { LEFT: !1, MIDDLE: !1, RIGHT: !1 }, this._isPinching = !1, this._isTouchHolding = !1, this._lastSeenTouchEvent = -sd.mouseEmulationIgnoreMilliseconds, this._primaryStartPosition = new H, this._primaryPosition = new H, this._primaryPreviousPosition = new H, this._positions = new Ct, this._previousPositions = new Ct, this._removalFunctions = [], this._touchHoldTimer = void 0, this._clickPixelTolerance = 5, this._holdPixelTolerance = 25, this._element = y(e, document), WQe(this) } sd.prototype.setInputAction = function (e, t, n) { let i = T7(t, n); this._inputEvents[i] = e }; sd.prototype.getInputAction = function (e, t) { let n = T7(e, t); return this._inputEvents[n] }; sd.prototype.removeInputAction = function (e, t) { let n = T7(e, t); delete this._inputEvents[n] }; sd.prototype.isDestroyed = function () { return !1 }; sd.prototype.destroy = function () { return jQe(this), le(this) }; sd.mouseEmulationIgnoreMilliseconds = 800; sd.touchHoldDelayMilliseconds = 1500; var Xu = sd; function QQe(e, t, n, i, o, r, s) { let a = xi.numberOfPoints(e, t, o), c, u = n.red, f = n.green, d = n.blue, p = n.alpha, g = i.red, m = i.green, A = i.blue, C = i.alpha; if (U.equals(n, i)) { for (c = 0; c < a; c++)r[s++] = U.floatToByte(u), r[s++] = U.floatToByte(f), r[s++] = U.floatToByte(d), r[s++] = U.floatToByte(p); return s } let x = (g - u) / a, T = (m - f) / a, b = (A - d) / a, S = (C - p) / a, D = s; for (c = 0; c < a; c++)r[D++] = U.floatToByte(u + c * x), r[D++] = U.floatToByte(f + c * T), r[D++] = U.floatToByte(d + c * b), r[D++] = U.floatToByte(p + c * S); return D } function ND(e) { e = y(e, y.EMPTY_OBJECT); let t = e.positions, n = e.colors, i = y(e.colorsPerVertex, !1); this._positions = t, this._colors = n, this._colorsPerVertex = i, this._arcType = y(e.arcType, Yt.GEODESIC), this._granularity = y(e.granularity, I.RADIANS_PER_DEGREE), this._ellipsoid = y(e.ellipsoid, ie.WGS84), this._workerName = "createSimplePolylineGeometry"; let o = 1 + t.length * h.packedLength; o += l(n) ? 1 + n.length * U.packedLength : 1, this.packedLength = o + ie.packedLength + 3 } ND.pack = function (e, t, n) { n = y(n, 0); let i, o = e._positions, r = o.length; for (t[n++] = r, i = 0; i < r; ++i, n += h.packedLength)h.pack(o[i], t, n); let s = e._colors; for (r = l(s) ? s.length : 0, t[n++] = r, i = 0; i < r; ++i, n += U.packedLength)U.pack(s[i], t, n); return ie.pack(e._ellipsoid, t, n), n += ie.packedLength, t[n++] = e._colorsPerVertex ? 1 : 0, t[n++] = e._arcType, t[n] = e._granularity, t }; ND.unpack = function (e, t, n) { t = y(t, 0); let i, o = e[t++], r = new Array(o); for (i = 0; i < o; ++i, t += h.packedLength)r[i] = h.unpack(e, t); o = e[t++]; let s = o > 0 ? new Array(o) : void 0; for (i = 0; i < o; ++i, t += U.packedLength)s[i] = U.unpack(e, t); let a = ie.unpack(e, t); t += ie.packedLength; let c = e[t++] === 1, u = e[t++], f = e[t]; return l(n) ? (n._positions = r, n._colors = s, n._ellipsoid = a, n._colorsPerVertex = c, n._arcType = u, n._granularity = f, n) : new ND({ positions: r, colors: s, ellipsoid: a, colorsPerVertex: c, arcType: u, granularity: f }) }; var oV = new Array(2), rV = new Array(2), $Qe = { positions: oV, height: rV, ellipsoid: void 0, minDistance: void 0, granularity: void 0 }; ND.createGeometry = function (e) { let t = e._positions, n = e._colors, i = e._colorsPerVertex, o = e._arcType, r = e._granularity, s = e._ellipsoid, a = I.chordLength(r, s.maximumRadius), c = l(n) && !i, u, f = t.length, d, p, g, m, A = 0; if (o === Yt.GEODESIC || o === Yt.RHUMB) { let S, D, P; o === Yt.GEODESIC ? (S = I.chordLength(r, s.maximumRadius), D = xi.numberOfPoints, P = xi.generateArc) : (S = r, D = xi.numberOfPointsRhumbLine, P = xi.generateRhumbArc); let B = xi.extractHeights(t, s), R = $Qe; if (o === Yt.GEODESIC ? R.minDistance = a : R.granularity = r, R.ellipsoid = s, c) { let M = 0; for (u = 0; u < f - 1; u++)M += D(t[u], t[u + 1], S) + 1; d = new Float64Array(M * 3), g = new Uint8Array(M * 4), R.positions = oV, R.height = rV; let L = 0; for (u = 0; u < f - 1; ++u) { oV[0] = t[u], oV[1] = t[u + 1], rV[0] = B[u], rV[1] = B[u + 1]; let _ = P(R); if (l(n)) { let E = _.length / 3; m = n[u]; for (let w = 0; w < E; ++w)g[L++] = U.floatToByte(m.red), g[L++] = U.floatToByte(m.green), g[L++] = U.floatToByte(m.blue), g[L++] = U.floatToByte(m.alpha) } d.set(_, A), A += _.length } } else if (R.positions = t, R.height = B, d = new Float64Array(P(R)), l(n)) { for (g = new Uint8Array(d.length / 3 * 4), u = 0; u < f - 1; ++u) { let L = t[u], _ = t[u + 1], E = n[u], w = n[u + 1]; A = QQe(L, _, E, w, a, g, A) } let M = n[f - 1]; g[A++] = U.floatToByte(M.red), g[A++] = U.floatToByte(M.green), g[A++] = U.floatToByte(M.blue), g[A++] = U.floatToByte(M.alpha) } } else { p = c ? f * 2 - 2 : f, d = new Float64Array(p * 3), g = l(n) ? new Uint8Array(p * 4) : void 0; let S = 0, D = 0; for (u = 0; u < f; ++u) { let P = t[u]; if (c && u > 0 && (h.pack(P, d, S), S += 3, m = n[u - 1], g[D++] = U.floatToByte(m.red), g[D++] = U.floatToByte(m.green), g[D++] = U.floatToByte(m.blue), g[D++] = U.floatToByte(m.alpha)), c && u === f - 1) break; h.pack(P, d, S), S += 3, l(n) && (m = n[u], g[D++] = U.floatToByte(m.red), g[D++] = U.floatToByte(m.green), g[D++] = U.floatToByte(m.blue), g[D++] = U.floatToByte(m.alpha)) } } let C = new sn; C.position = new be({ componentDatatype: Y.DOUBLE, componentsPerAttribute: 3, values: d }), l(n) && (C.color = new be({ componentDatatype: Y.UNSIGNED_BYTE, componentsPerAttribute: 4, values: g, normalize: !0 })), p = d.length / 3; let x = (p - 1) * 2, T = Me.createTypedArray(p, x), b = 0; for (u = 0; u < p - 1; ++u)T[b++] = u, T[b++] = u + 1; return new st({ attributes: C, indices: T, primitiveType: Oe.LINES, boundingSphere: re.fromPoints(t) }) }; var Vhe = ND; function mE(e) { let t = y(e.radius, 1), i = { radii: new h(t, t, t), stackPartitions: e.stackPartitions, slicePartitions: e.slicePartitions, vertexFormat: e.vertexFormat }; this._ellipsoidGeometry = new Bs(i), this._workerName = "createSphereGeometry" } mE.packedLength = Bs.packedLength; mE.pack = function (e, t, n) { return Bs.pack(e._ellipsoidGeometry, t, n) }; var e$e = new Bs, Bg = { radius: void 0, radii: new h, vertexFormat: new we, stackPartitions: void 0, slicePartitions: void 0 }; mE.unpack = function (e, t, n) { let i = Bs.unpack(e, t, e$e); return Bg.vertexFormat = we.clone(i._vertexFormat, Bg.vertexFormat), Bg.stackPartitions = i._stackPartitions, Bg.slicePartitions = i._slicePartitions, l(n) ? (h.clone(i._radii, Bg.radii), n._ellipsoidGeometry = new Bs(Bg), n) : (Bg.radius = i._radii.x, new mE(Bg)) }; mE.createGeometry = function (e) { return Bs.createGeometry(e._ellipsoidGeometry) }; var khe = mE; var t$e = { WEST: 0, NORTH: 1, EAST: 2, SOUTH: 3, NORTHWEST: 4, NORTHEAST: 5, SOUTHWEST: 6, SOUTHEAST: 7 }, un = t$e; function Rg(e) { } Object.defineProperties(Rg.prototype, { ellipsoid: { get: ye.throwInstantiationError }, rectangle: { get: ye.throwInstantiationError }, projection: { get: ye.throwInstantiationError } }); Rg.prototype.getNumberOfXTilesAtLevel = ye.throwInstantiationError; Rg.prototype.getNumberOfYTilesAtLevel = ye.throwInstantiationError; Rg.prototype.rectangleToNativeRectangle = ye.throwInstantiationError; Rg.prototype.tileXYToNativeRectangle = ye.throwInstantiationError; Rg.prototype.tileXYToRectangle = ye.throwInstantiationError; Rg.prototype.positionToTileXY = ye.throwInstantiationError; var Uhe = Rg; function Zy(e) { e = y(e, y.EMPTY_OBJECT), this._clock = void 0, this._element = void 0, this._clockSubscription = void 0, this._seekFunction = void 0, this._lastPlaybackRate = void 0, this.clock = e.clock, this.element = e.element, this.epoch = y(e.epoch, ke.MINIMUM_VALUE), this.tolerance = y(e.tolerance, 1), this._seeking = !1, this._seekFunction = void 0, this._firstTickAfterSeek = !1 } Object.defineProperties(Zy.prototype, { clock: { get: function () { return this._clock }, set: function (e) { let t = this._clock; t !== e && (l(t) && (this._clockSubscription(), this._clockSubscription = void 0), l(e) && (this._clockSubscription = e.onTick.addEventListener(Zy.prototype._onTick, this)), this._clock = e) } }, element: { get: function () { return this._element }, set: function (e) { let t = this._element; t !== e && (l(t) && t.removeEventListener("seeked", this._seekFunction, !1), l(e) && (this._seeking = !1, this._seekFunction = n$e(this), e.addEventListener("seeked", this._seekFunction, !1)), this._element = e, this._seeking = !1, this._firstTickAfterSeek = !1) } } }); Zy.prototype.destroy = function () { return this.element = void 0, this.clock = void 0, le(this) }; Zy.prototype.isDestroyed = function () { return !1 }; Zy.prototype._trySetPlaybackRate = function (e) { if (this._lastPlaybackRate === e.multiplier) return; let t = this._element; try { t.playbackRate = e.multiplier } catch { t.playbackRate = 0 } this._lastPlaybackRate = e.multiplier }; Zy.prototype._onTick = function (e) { let t = this._element; if (!l(t) || t.readyState < 2) return; let n = t.paused, i = e.shouldAnimate; if (i === n && (i ? t.play() : t.pause()), this._seeking || this._firstTickAfterSeek) { this._firstTickAfterSeek = !1; return } this._trySetPlaybackRate(e); let o = e.currentTime, r = y(this.epoch, ke.MINIMUM_VALUE), s = $.secondsDifference(o, r), a = t.duration, c, u = t.currentTime; t.loop ? (s = s % a, s < 0 && (s = a - s), c = s) : s > a ? c = a : s < 0 ? c = 0 : c = s; let f = i ? y(this.tolerance, 1) : .001; Math.abs(c - u) > f && (this._seeking = !0, t.currentTime = c) }; function n$e(e) { return function () { e._seeking = !1, e._firstTickAfterSeek = !0 } } var zhe = Zy; function i$e(e, t) { this.rectangle = e, this.maxLevel = t } function pE(e) { e = y(e, y.EMPTY_OBJECT); let t = Pe.createIfNeeded(e.url); this._resource = t, this._errorEvent = new _e, this._ready = !1, this._terrainDataStructure = { heightScale: 1 / 1e3, heightOffset: -1e3, elementsPerHeight: 3, stride: 4, elementMultiplier: 256, isBigEndian: !0, lowestEncodedHeight: 0, highestEncodedHeight: 256 * 256 * 256 - 1 }; let n = e.credit; typeof n == "string" && (n = new Xt(n)), this._credit = n, this._tilingScheme = void 0, this._rectangles = []; let i = this, o, r = y(e.ellipsoid, ie.WGS84); function s(u) { let f = u.getElementsByTagName("SRS")[0].textContent; if (f === "EPSG:4326") i._tilingScheme = new Hi({ ellipsoid: r }); else return Promise.reject(new fe(`SRS ${f} is not supported.`)); let d = u.getElementsByTagName("TileFormat")[0]; i._heightmapWidth = parseInt(d.getAttribute("width"), 10), i._heightmapHeight = parseInt(d.getAttribute("height"), 10), i._levelZeroMaximumGeometricError = Hr.getEstimatedLevelZeroGeometricErrorForAHeightmap(r, Math.min(i._heightmapWidth, i._heightmapHeight), i._tilingScheme.getNumberOfXTilesAtLevel(0)); let p = u.getElementsByTagName("DataExtent"); for (let g = 0; g < p.length; ++g) { let m = p[g], A = I.toRadians(parseFloat(m.getAttribute("minx"))), C = I.toRadians(parseFloat(m.getAttribute("miny"))), x = I.toRadians(parseFloat(m.getAttribute("maxx"))), T = I.toRadians(parseFloat(m.getAttribute("maxy"))), b = parseInt(m.getAttribute("maxlevel"), 10); i._rectangles.push(new i$e(new ce(A, C, x, T), b)) } return i._ready = !0, Promise.resolve(!0) } function a(u) { let f = y(l(u) ? u.message : void 0, `An error occurred while accessing ${i._resource.url}.`); return o = Gn.reportError(o, i, i._errorEvent, f), o.retry ? c() : Promise.reject(new fe(f)) } function c() { return i._resource.fetchXML().then(s).catch(a) } this._readyPromise = c() } Object.defineProperties(pE.prototype, { errorEvent: { get: function () { return this._errorEvent } }, credit: { get: function () { return this._credit } }, tilingScheme: { get: function () { return this._tilingScheme } }, ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } }, hasWaterMask: { get: function () { return !1 } }, hasVertexNormals: { get: function () { return !1 } }, availability: { get: function () { } } }); pE.prototype.requestTileGeometry = function (e, t, n, i) { let o = this._tilingScheme.getNumberOfYTilesAtLevel(n), s = this._resource.getDerivedResource({ url: `${n}/${e}/${o - t - 1}.tif`, queryParameters: { cesium: !0 }, request: i }).fetchImage({ preferImageBitmap: !0 }); if (!l(s)) return; let a = this; return Promise.resolve(s).then(function (c) { return new Ma({ buffer: Ad(c), width: a._heightmapWidth, height: a._heightmapHeight, childTileMask: o$e(a, e, t, n), structure: a._terrainDataStructure }) }) }; pE.prototype.getLevelMaximumGeometricError = function (e) { return this._levelZeroMaximumGeometricError / (1 << e) }; var Hhe = new ce; function o$e(e, t, n, i) { let o = e._tilingScheme, r = e._rectangles, s = o.tileXYToRectangle(t, n, i), a = 0; for (let c = 0; c < r.length && a !== 15; ++c) { let u = r[c]; if (u.maxLevel <= i) continue; let f = u.rectangle, d = ce.intersection(f, s, Hhe); l(d) && (sV(o, f, t * 2, n * 2, i + 1) && (a |= 4), sV(o, f, t * 2 + 1, n * 2, i + 1) && (a |= 8), sV(o, f, t * 2, n * 2 + 1, i + 1) && (a |= 1), sV(o, f, t * 2 + 1, n * 2 + 1, i + 1) && (a |= 2)) } return a } function sV(e, t, n, i, o) { let r = e.tileXYToRectangle(n, i, o); return l(ce.intersection(r, t, Hhe)) } pE.prototype.getTileDataAvailable = function (e, t, n) { }; pE.prototype.loadTileDataAvailability = function (e, t, n) { }; var Ghe = pE; var r$e = { VK_FORMAT_UNDEFINED: 0, VK_FORMAT_R4G4_UNORM_PACK8: 1, VK_FORMAT_R4G4B4A4_UNORM_PACK16: 2, VK_FORMAT_B4G4R4A4_UNORM_PACK16: 3, VK_FORMAT_R5G6B5_UNORM_PACK16: 4, VK_FORMAT_B5G6R5_UNORM_PACK16: 5, VK_FORMAT_R5G5B5A1_UNORM_PACK16: 6, VK_FORMAT_B5G5R5A1_UNORM_PACK16: 7, VK_FORMAT_A1R5G5B5_UNORM_PACK16: 8, VK_FORMAT_R8_UNORM: 9, VK_FORMAT_R8_SNORM: 10, VK_FORMAT_R8_USCALED: 11, VK_FORMAT_R8_SSCALED: 12, VK_FORMAT_R8_UINT: 13, VK_FORMAT_R8_SINT: 14, VK_FORMAT_R8_SRGB: 15, VK_FORMAT_R8G8_UNORM: 16, VK_FORMAT_R8G8_SNORM: 17, VK_FORMAT_R8G8_USCALED: 18, VK_FORMAT_R8G8_SSCALED: 19, VK_FORMAT_R8G8_UINT: 20, VK_FORMAT_R8G8_SINT: 21, VK_FORMAT_R8G8_SRGB: 22, VK_FORMAT_R8G8B8_UNORM: 23, VK_FORMAT_R8G8B8_SNORM: 24, VK_FORMAT_R8G8B8_USCALED: 25, VK_FORMAT_R8G8B8_SSCALED: 26, VK_FORMAT_R8G8B8_UINT: 27, VK_FORMAT_R8G8B8_SINT: 28, VK_FORMAT_R8G8B8_SRGB: 29, VK_FORMAT_B8G8R8_UNORM: 30, VK_FORMAT_B8G8R8_SNORM: 31, VK_FORMAT_B8G8R8_USCALED: 32, VK_FORMAT_B8G8R8_SSCALED: 33, VK_FORMAT_B8G8R8_UINT: 34, VK_FORMAT_B8G8R8_SINT: 35, VK_FORMAT_B8G8R8_SRGB: 36, VK_FORMAT_R8G8B8A8_UNORM: 37, VK_FORMAT_R8G8B8A8_SNORM: 38, VK_FORMAT_R8G8B8A8_USCALED: 39, VK_FORMAT_R8G8B8A8_SSCALED: 40, VK_FORMAT_R8G8B8A8_UINT: 41, VK_FORMAT_R8G8B8A8_SINT: 42, VK_FORMAT_R8G8B8A8_SRGB: 43, VK_FORMAT_B8G8R8A8_UNORM: 44, VK_FORMAT_B8G8R8A8_SNORM: 45, VK_FORMAT_B8G8R8A8_USCALED: 46, VK_FORMAT_B8G8R8A8_SSCALED: 47, VK_FORMAT_B8G8R8A8_UINT: 48, VK_FORMAT_B8G8R8A8_SINT: 49, VK_FORMAT_B8G8R8A8_SRGB: 50, VK_FORMAT_A8B8G8R8_UNORM_PACK32: 51, VK_FORMAT_A8B8G8R8_SNORM_PACK32: 52, VK_FORMAT_A8B8G8R8_USCALED_PACK32: 53, VK_FORMAT_A8B8G8R8_SSCALED_PACK32: 54, VK_FORMAT_A8B8G8R8_UINT_PACK32: 55, VK_FORMAT_A8B8G8R8_SINT_PACK32: 56, VK_FORMAT_A8B8G8R8_SRGB_PACK32: 57, VK_FORMAT_A2R10G10B10_UNORM_PACK32: 58, VK_FORMAT_A2R10G10B10_SNORM_PACK32: 59, VK_FORMAT_A2R10G10B10_USCALED_PACK32: 60, VK_FORMAT_A2R10G10B10_SSCALED_PACK32: 61, VK_FORMAT_A2R10G10B10_UINT_PACK32: 62, VK_FORMAT_A2R10G10B10_SINT_PACK32: 63, VK_FORMAT_A2B10G10R10_UNORM_PACK32: 64, VK_FORMAT_A2B10G10R10_SNORM_PACK32: 65, VK_FORMAT_A2B10G10R10_USCALED_PACK32: 66, VK_FORMAT_A2B10G10R10_SSCALED_PACK32: 67, VK_FORMAT_A2B10G10R10_UINT_PACK32: 68, VK_FORMAT_A2B10G10R10_SINT_PACK32: 69, VK_FORMAT_R16_UNORM: 70, VK_FORMAT_R16_SNORM: 71, VK_FORMAT_R16_USCALED: 72, VK_FORMAT_R16_SSCALED: 73, VK_FORMAT_R16_UINT: 74, VK_FORMAT_R16_SINT: 75, VK_FORMAT_R16_SFLOAT: 76, VK_FORMAT_R16G16_UNORM: 77, VK_FORMAT_R16G16_SNORM: 78, VK_FORMAT_R16G16_USCALED: 79, VK_FORMAT_R16G16_SSCALED: 80, VK_FORMAT_R16G16_UINT: 81, VK_FORMAT_R16G16_SINT: 82, VK_FORMAT_R16G16_SFLOAT: 83, VK_FORMAT_R16G16B16_UNORM: 84, VK_FORMAT_R16G16B16_SNORM: 85, VK_FORMAT_R16G16B16_USCALED: 86, VK_FORMAT_R16G16B16_SSCALED: 87, VK_FORMAT_R16G16B16_UINT: 88, VK_FORMAT_R16G16B16_SINT: 89, VK_FORMAT_R16G16B16_SFLOAT: 90, VK_FORMAT_R16G16B16A16_UNORM: 91, VK_FORMAT_R16G16B16A16_SNORM: 92, VK_FORMAT_R16G16B16A16_USCALED: 93, VK_FORMAT_R16G16B16A16_SSCALED: 94, VK_FORMAT_R16G16B16A16_UINT: 95, VK_FORMAT_R16G16B16A16_SINT: 96, VK_FORMAT_R16G16B16A16_SFLOAT: 97, VK_FORMAT_R32_UINT: 98, VK_FORMAT_R32_SINT: 99, VK_FORMAT_R32_SFLOAT: 100, VK_FORMAT_R32G32_UINT: 101, VK_FORMAT_R32G32_SINT: 102, VK_FORMAT_R32G32_SFLOAT: 103, VK_FORMAT_R32G32B32_UINT: 104, VK_FORMAT_R32G32B32_SINT: 105, VK_FORMAT_R32G32B32_SFLOAT: 106, VK_FORMAT_R32G32B32A32_UINT: 107, VK_FORMAT_R32G32B32A32_SINT: 108, VK_FORMAT_R32G32B32A32_SFLOAT: 109, VK_FORMAT_R64_UINT: 110, VK_FORMAT_R64_SINT: 111, VK_FORMAT_R64_SFLOAT: 112, VK_FORMAT_R64G64_UINT: 113, VK_FORMAT_R64G64_SINT: 114, VK_FORMAT_R64G64_SFLOAT: 115, VK_FORMAT_R64G64B64_UINT: 116, VK_FORMAT_R64G64B64_SINT: 117, VK_FORMAT_R64G64B64_SFLOAT: 118, VK_FORMAT_R64G64B64A64_UINT: 119, VK_FORMAT_R64G64B64A64_SINT: 120, VK_FORMAT_R64G64B64A64_SFLOAT: 121, VK_FORMAT_B10G11R11_UFLOAT_PACK32: 122, VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: 123, VK_FORMAT_D16_UNORM: 124, VK_FORMAT_X8_D24_UNORM_PACK32: 125, VK_FORMAT_D32_SFLOAT: 126, VK_FORMAT_S8_UINT: 127, VK_FORMAT_D16_UNORM_S8_UINT: 128, VK_FORMAT_D24_UNORM_S8_UINT: 129, VK_FORMAT_D32_SFLOAT_S8_UINT: 130, VK_FORMAT_BC1_RGB_UNORM_BLOCK: 131, VK_FORMAT_BC1_RGB_SRGB_BLOCK: 132, VK_FORMAT_BC1_RGBA_UNORM_BLOCK: 133, VK_FORMAT_BC1_RGBA_SRGB_BLOCK: 134, VK_FORMAT_BC2_UNORM_BLOCK: 135, VK_FORMAT_BC2_SRGB_BLOCK: 136, VK_FORMAT_BC3_UNORM_BLOCK: 137, VK_FORMAT_BC3_SRGB_BLOCK: 138, VK_FORMAT_BC4_UNORM_BLOCK: 139, VK_FORMAT_BC4_SNORM_BLOCK: 140, VK_FORMAT_BC5_UNORM_BLOCK: 141, VK_FORMAT_BC5_SNORM_BLOCK: 142, VK_FORMAT_BC6H_UFLOAT_BLOCK: 143, VK_FORMAT_BC6H_SFLOAT_BLOCK: 144, VK_FORMAT_BC7_UNORM_BLOCK: 145, VK_FORMAT_BC7_SRGB_BLOCK: 146, VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: 147, VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: 148, VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: 149, VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: 150, VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: 151, VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: 152, VK_FORMAT_EAC_R11_UNORM_BLOCK: 153, VK_FORMAT_EAC_R11_SNORM_BLOCK: 154, VK_FORMAT_EAC_R11G11_UNORM_BLOCK: 155, VK_FORMAT_EAC_R11G11_SNORM_BLOCK: 156, VK_FORMAT_ASTC_4x4_UNORM_BLOCK: 157, VK_FORMAT_ASTC_4x4_SRGB_BLOCK: 158, VK_FORMAT_ASTC_5x4_UNORM_BLOCK: 159, VK_FORMAT_ASTC_5x4_SRGB_BLOCK: 160, VK_FORMAT_ASTC_5x5_UNORM_BLOCK: 161, VK_FORMAT_ASTC_5x5_SRGB_BLOCK: 162, VK_FORMAT_ASTC_6x5_UNORM_BLOCK: 163, VK_FORMAT_ASTC_6x5_SRGB_BLOCK: 164, VK_FORMAT_ASTC_6x6_UNORM_BLOCK: 165, VK_FORMAT_ASTC_6x6_SRGB_BLOCK: 166, VK_FORMAT_ASTC_8x5_UNORM_BLOCK: 167, VK_FORMAT_ASTC_8x5_SRGB_BLOCK: 168, VK_FORMAT_ASTC_8x6_UNORM_BLOCK: 169, VK_FORMAT_ASTC_8x6_SRGB_BLOCK: 170, VK_FORMAT_ASTC_8x8_UNORM_BLOCK: 171, VK_FORMAT_ASTC_8x8_SRGB_BLOCK: 172, VK_FORMAT_ASTC_10x5_UNORM_BLOCK: 173, VK_FORMAT_ASTC_10x5_SRGB_BLOCK: 174, VK_FORMAT_ASTC_10x6_UNORM_BLOCK: 175, VK_FORMAT_ASTC_10x6_SRGB_BLOCK: 176, VK_FORMAT_ASTC_10x8_UNORM_BLOCK: 177, VK_FORMAT_ASTC_10x8_SRGB_BLOCK: 178, VK_FORMAT_ASTC_10x10_UNORM_BLOCK: 179, VK_FORMAT_ASTC_10x10_SRGB_BLOCK: 180, VK_FORMAT_ASTC_12x10_UNORM_BLOCK: 181, VK_FORMAT_ASTC_12x10_SRGB_BLOCK: 182, VK_FORMAT_ASTC_12x12_UNORM_BLOCK: 183, VK_FORMAT_ASTC_12x12_SRGB_BLOCK: 184, VK_FORMAT_G8B8G8R8_422_UNORM: 1000156e3, VK_FORMAT_B8G8R8G8_422_UNORM: 1000156001, VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM: 1000156002, VK_FORMAT_G8_B8R8_2PLANE_420_UNORM: 1000156003, VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM: 1000156004, VK_FORMAT_G8_B8R8_2PLANE_422_UNORM: 1000156005, VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM: 1000156006, VK_FORMAT_R10X6_UNORM_PACK16: 1000156007, VK_FORMAT_R10X6G10X6_UNORM_2PACK16: 1000156008, VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: 1000156009, VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: 1000156010, VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: 1000156011, VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: 1000156012, VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: 1000156013, VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: 1000156014, VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: 1000156015, VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: 1000156016, VK_FORMAT_R12X4_UNORM_PACK16: 1000156017, VK_FORMAT_R12X4G12X4_UNORM_2PACK16: 1000156018, VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: 1000156019, VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: 1000156020, VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: 1000156021, VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: 1000156022, VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: 1000156023, VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: 1000156024, VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: 1000156025, VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: 1000156026, VK_FORMAT_G16B16G16R16_422_UNORM: 1000156027, VK_FORMAT_B16G16R16G16_422_UNORM: 1000156028, VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM: 1000156029, VK_FORMAT_G16_B16R16_2PLANE_420_UNORM: 1000156030, VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM: 1000156031, VK_FORMAT_G16_B16R16_2PLANE_422_UNORM: 1000156032, VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM: 1000156033, VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: 1000054e3, VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: 1000054001, VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: 1000054002, VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: 1000054003, VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: 1000054004, VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: 1000054005, VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: 1000054006, VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: 1000054007, VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: 1000066e3, VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: 1000066001, VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: 1000066002, VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: 1000066003, VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: 1000066004, VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: 1000066005, VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: 1000066006, VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: 1000066007, VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: 1000066008, VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: 1000066009, VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: 1000066010, VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: 1000066011, VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: 1000066012, VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: 1000066013, VK_FORMAT_G8B8G8R8_422_UNORM_KHR: 1000156e3, VK_FORMAT_B8G8R8G8_422_UNORM_KHR: 1000156001, VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR: 1000156002, VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR: 1000156003, VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR: 1000156004, VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR: 1000156005, VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR: 1000156006, VK_FORMAT_R10X6_UNORM_PACK16_KHR: 1000156007, VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR: 1000156008, VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR: 1000156009, VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR: 1000156010, VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR: 1000156011, VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR: 1000156012, VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR: 1000156013, VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR: 1000156014, VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR: 1000156015, VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR: 1000156016, VK_FORMAT_R12X4_UNORM_PACK16_KHR: 1000156017, VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR: 1000156018, VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR: 1000156019, VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR: 1000156020, VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR: 1000156021, VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR: 1000156022, VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR: 1000156023, VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR: 1000156024, VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR: 1000156025, VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR: 1000156026, VK_FORMAT_G16B16G16R16_422_UNORM_KHR: 1000156027, VK_FORMAT_B16G16R16G16_422_UNORM_KHR: 1000156028, VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR: 1000156029, VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR: 1000156030, VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR: 1000156031, VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR: 1000156032, VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR: 1000156033 }, Whe = Object.freeze(r$e); function s$e(e) { switch (e) { case te.FLOAT: return "float"; case te.FLOAT_VEC2: return "vec2"; case te.FLOAT_VEC3: return "vec3"; case te.FLOAT_VEC4: return "vec4"; case te.FLOAT_MAT2: return "mat2"; case te.FLOAT_MAT3: return "mat3"; case te.FLOAT_MAT4: return "mat4"; case te.SAMPLER_2D: return "sampler2D"; case te.BOOL: return "bool" } } var jhe = s$e; function a$e(e, t, n) { return function () { n.apply(e, arguments), t.apply(e, arguments) } } var aV = a$e; var VD; typeof ko < "u" && (VD = ko); (function () {/*!
 * Knockout JavaScript library v3.5.1
 * (c) The Knockout.js team - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */(function () {
            (function (e) {
                var t = this || (0, eval)("this"), n = t.document, i = t.navigator, o = t.jQuery, r = t.JSON; o || typeof jQuery > "u" || (o = jQuery), function (s) { s(t.ko = {}) }(function (s, a) {
                    function c(_, E) { return _ === null || typeof _ in A ? _ === E : !1 } function u(_, E) { var w; return function () { w || (w = m.a.setTimeout(function () { w = e, _() }, E)) } } function f(_, E) { var w; return function () { clearTimeout(w), w = m.a.setTimeout(_, E) } } function d(_, E) { E && E !== "change" ? E === "beforeChange" ? this.pc(_) : this.gb(_, E) : this.qc(_) } function p(_, E) { E !== null && E.s && E.s() } function g(_, E) { var w = this.qd, v = w[S]; v.ra || (this.Qb && this.mb[E] ? (w.uc(E, _, this.mb[E]), this.mb[E] = null, --this.Qb) : v.I[E] || w.uc(E, _, v.J ? { da: _ } : w.$c(_)), _.Ja && _.gd()) } var m = typeof s < "u" ? s : {}; m.b = function (_, E) { for (var w = _.split("."), v = m, O = 0; O < w.length - 1; O++)v = v[w[O]]; v[w[w.length - 1]] = E }, m.L = function (_, E, w) { _[E] = w }, m.version = "3.5.1", m.b("version", m.version), m.options = { deferUpdates: !1, useOnlyNativeEvents: !1, foreachHidesDestroyed: !1 }, m.a = function () { function _(W, K) { for (var Z in W) O.call(W, Z) && K(Z, W[Z]) } function E(W, K) { if (K) for (var Z in K) O.call(K, Z) && (W[Z] = K[Z]); return W } function w(W, K) { return W.__proto__ = K, W } function v(W, K, Z, de) { var pe = W[K].match(q) || []; m.a.D(Z.match(q), function (oe) { m.a.Na(pe, oe, de) }), W[K] = pe.join(" ") } var O = Object.prototype.hasOwnProperty, V = { __proto__: [] } instanceof Array, z = typeof Symbol == "function", k = {}, G = {}; k[i && /Firefox\/2/i.test(i.userAgent) ? "KeyboardEvent" : "UIEvents"] = ["keyup", "keydown", "keypress"], k.MouseEvents = "click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" "), _(k, function (W, K) { if (K.length) for (var Z = 0, de = K.length; Z < de; Z++)G[K[Z]] = W }); var N = { propertychange: !0 }, X = n && function () { for (var W = 3, K = n.createElement("div"), Z = K.getElementsByTagName("i"); K.innerHTML = "<!--[if gt IE " + ++W + "]><i></i><![endif]-->", Z[0];); return 4 < W ? W : e }(), q = /\S+/g, J; return { Jc: ["authenticity_token", /^__RequestVerificationToken(_.*)?$/], D: function (W, K, Z) { for (var de = 0, pe = W.length; de < pe; de++)K.call(Z, W[de], de, W) }, A: typeof Array.prototype.indexOf == "function" ? function (W, K) { return Array.prototype.indexOf.call(W, K) } : function (W, K) { for (var Z = 0, de = W.length; Z < de; Z++)if (W[Z] === K) return Z; return -1 }, Lb: function (W, K, Z) { for (var de = 0, pe = W.length; de < pe; de++)if (K.call(Z, W[de], de, W)) return W[de]; return e }, Pa: function (W, K) { var Z = m.a.A(W, K); 0 < Z ? W.splice(Z, 1) : Z === 0 && W.shift() }, wc: function (W) { var K = []; return W && m.a.D(W, function (Z) { 0 > m.a.A(K, Z) && K.push(Z) }), K }, Mb: function (W, K, Z) { var de = []; if (W) for (var pe = 0, oe = W.length; pe < oe; pe++)de.push(K.call(Z, W[pe], pe)); return de }, jb: function (W, K, Z) { var de = []; if (W) for (var pe = 0, oe = W.length; pe < oe; pe++)K.call(Z, W[pe], pe) && de.push(W[pe]); return de }, Nb: function (W, K) { if (K instanceof Array) W.push.apply(W, K); else for (var Z = 0, de = K.length; Z < de; Z++)W.push(K[Z]); return W }, Na: function (W, K, Z) { var de = m.a.A(m.a.bc(W), K); 0 > de ? Z && W.push(K) : Z || W.splice(de, 1) }, Ba: V, extend: E, setPrototypeOf: w, Ab: V ? w : E, P: _, Ga: function (W, K, Z) { if (!W) return W; var de = {}, pe; for (pe in W) O.call(W, pe) && (de[pe] = K.call(Z, W[pe], pe, W)); return de }, Tb: function (W) { for (; W.firstChild;)m.removeNode(W.firstChild) }, Yb: function (W) { W = m.a.la(W); for (var K = (W[0] && W[0].ownerDocument || n).createElement("div"), Z = 0, de = W.length; Z < de; Z++)K.appendChild(m.oa(W[Z])); return K }, Ca: function (W, K) { for (var Z = 0, de = W.length, pe = []; Z < de; Z++) { var oe = W[Z].cloneNode(!0); pe.push(K ? m.oa(oe) : oe) } return pe }, va: function (W, K) { if (m.a.Tb(W), K) for (var Z = 0, de = K.length; Z < de; Z++)W.appendChild(K[Z]) }, Xc: function (W, K) { var Z = W.nodeType ? [W] : W; if (0 < Z.length) { for (var de = Z[0], pe = de.parentNode, oe = 0, ue = K.length; oe < ue; oe++)pe.insertBefore(K[oe], de); for (oe = 0, ue = Z.length; oe < ue; oe++)m.removeNode(Z[oe]) } }, Ua: function (W, K) { if (W.length) { for (K = K.nodeType === 8 && K.parentNode || K; W.length && W[0].parentNode !== K;)W.splice(0, 1); for (; 1 < W.length && W[W.length - 1].parentNode !== K;)W.length--; if (1 < W.length) { var Z = W[0], de = W[W.length - 1]; for (W.length = 0; Z !== de;)W.push(Z), Z = Z.nextSibling; W.push(de) } } return W }, Zc: function (W, K) { 7 > X ? W.setAttribute("selected", K) : W.selected = K }, Db: function (W) { return W === null || W === e ? "" : W.trim ? W.trim() : W.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g, "") }, Ud: function (W, K) { return W = W || "", K.length > W.length ? !1 : W.substring(0, K.length) === K }, vd: function (W, K) { if (W === K) return !0; if (W.nodeType === 11) return !1; if (K.contains) return K.contains(W.nodeType !== 1 ? W.parentNode : W); if (K.compareDocumentPosition) return (K.compareDocumentPosition(W) & 16) == 16; for (; W && W != K;)W = W.parentNode; return !!W }, Sb: function (W) { return m.a.vd(W, W.ownerDocument.documentElement) }, kd: function (W) { return !!m.a.Lb(W, m.a.Sb) }, R: function (W) { return W && W.tagName && W.tagName.toLowerCase() }, Ac: function (W) { return m.onError ? function () { try { return W.apply(this, arguments) } catch (K) { throw m.onError && m.onError(K), K } } : W }, setTimeout: function (W, K) { return setTimeout(m.a.Ac(W), K) }, Gc: function (W) { setTimeout(function () { throw m.onError && m.onError(W), W }, 0) }, B: function (W, K, Z) { var de = m.a.Ac(Z); if (Z = N[K], m.options.useOnlyNativeEvents || Z || !o) if (Z || typeof W.addEventListener != "function") if (typeof W.attachEvent < "u") { var pe = function (ue) { de.call(W, ue) }, oe = "on" + K; W.attachEvent(oe, pe), m.a.K.za(W, function () { W.detachEvent(oe, pe) }) } else throw Error("Browser doesn't support addEventListener or attachEvent"); else W.addEventListener(K, de, !1); else J || (J = typeof o(W).on == "function" ? "on" : "bind"), o(W)[J](K, de) }, Fb: function (W, K) { if (!W || !W.nodeType) throw Error("element must be a DOM node when calling triggerEvent"); var Z; if (m.a.R(W) === "input" && W.type && K.toLowerCase() == "click" ? (Z = W.type, Z = Z == "checkbox" || Z == "radio") : Z = !1, m.options.useOnlyNativeEvents || !o || Z) if (typeof n.createEvent == "function") if (typeof W.dispatchEvent == "function") Z = n.createEvent(G[K] || "HTMLEvents"), Z.initEvent(K, !0, !0, t, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, W), W.dispatchEvent(Z); else throw Error("The supplied element doesn't support dispatchEvent"); else if (Z && W.click) W.click(); else if (typeof W.fireEvent < "u") W.fireEvent("on" + K); else throw Error("Browser doesn't support triggering events"); else o(W).trigger(K) }, f: function (W) { return m.O(W) ? W() : W }, bc: function (W) { return m.O(W) ? W.v() : W }, Eb: function (W, K, Z) { var de; K && (typeof W.classList == "object" ? (de = W.classList[Z ? "add" : "remove"], m.a.D(K.match(q), function (pe) { de.call(W.classList, pe) })) : typeof W.className.baseVal == "string" ? v(W.className, "baseVal", K, Z) : v(W, "className", K, Z)) }, Bb: function (W, K) { var Z = m.a.f(K); (Z === null || Z === e) && (Z = ""); var de = m.h.firstChild(W); !de || de.nodeType != 3 || m.h.nextSibling(de) ? m.h.va(W, [W.ownerDocument.createTextNode(Z)]) : de.data = Z, m.a.Ad(W) }, Yc: function (W, K) { if (W.name = K, 7 >= X) try { var Z = W.name.replace(/[&<>'"]/g, function (de) { return "&#" + de.charCodeAt(0) + ";" }); W.mergeAttributes(n.createElement("<input name='" + Z + "'/>"), !1) } catch { } }, Ad: function (W) { 9 <= X && (W = W.nodeType == 1 ? W : W.parentNode, W.style && (W.style.zoom = W.style.zoom)) }, wd: function (W) { if (X) { var K = W.style.width; W.style.width = 0, W.style.width = K } }, Pd: function (W, K) { W = m.a.f(W), K = m.a.f(K); for (var Z = [], de = W; de <= K; de++)Z.push(de); return Z }, la: function (W) { for (var K = [], Z = 0, de = W.length; Z < de; Z++)K.push(W[Z]); return K }, Da: function (W) { return z ? Symbol(W) : W }, Zd: X === 6, $d: X === 7, W: X, Lc: function (W, K) { for (var Z = m.a.la(W.getElementsByTagName("input")).concat(m.a.la(W.getElementsByTagName("textarea"))), de = typeof K == "string" ? function (ue) { return ue.name === K } : function (ue) { return K.test(ue.name) }, pe = [], oe = Z.length - 1; 0 <= oe; oe--)de(Z[oe]) && pe.push(Z[oe]); return pe }, Nd: function (W) { return typeof W == "string" && (W = m.a.Db(W)) ? r && r.parse ? r.parse(W) : new Function("return " + W)() : null }, hc: function (W, K, Z) { if (!r || !r.stringify) throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js"); return r.stringify(m.a.f(W), K, Z) }, Od: function (W, K, Z) { Z = Z || {}; var de = Z.params || {}, pe = Z.includeFields || this.Jc, oe = W; if (typeof W == "object" && m.a.R(W) === "form") for (var oe = W.action, ue = pe.length - 1; 0 <= ue; ue--)for (var ge = m.a.Lc(W, pe[ue]), Ee = ge.length - 1; 0 <= Ee; Ee--)de[ge[Ee].name] = ge[Ee].value; K = m.a.f(K); var Ie = n.createElement("form"); Ie.style.display = "none", Ie.action = oe, Ie.method = "post"; for (var Fe in K) W = n.createElement("input"), W.type = "hidden", W.name = Fe, W.value = m.a.hc(m.a.f(K[Fe])), Ie.appendChild(W); _(de, function (We, Lt) { var Gt = n.createElement("input"); Gt.type = "hidden", Gt.name = We, Gt.value = Lt, Ie.appendChild(Gt) }), n.body.appendChild(Ie), Z.submitter ? Z.submitter(Ie) : Ie.submit(), setTimeout(function () { Ie.parentNode.removeChild(Ie) }, 0) } } }(), m.b("utils", m.a), m.b("utils.arrayForEach", m.a.D), m.b("utils.arrayFirst", m.a.Lb), m.b("utils.arrayFilter", m.a.jb), m.b("utils.arrayGetDistinctValues", m.a.wc), m.b("utils.arrayIndexOf", m.a.A), m.b("utils.arrayMap", m.a.Mb), m.b("utils.arrayPushAll", m.a.Nb), m.b("utils.arrayRemoveItem", m.a.Pa), m.b("utils.cloneNodes", m.a.Ca), m.b("utils.createSymbolOrString", m.a.Da), m.b("utils.extend", m.a.extend), m.b("utils.fieldsIncludedWithJsonPost", m.a.Jc), m.b("utils.getFormFields", m.a.Lc), m.b("utils.objectMap", m.a.Ga), m.b("utils.peekObservable", m.a.bc), m.b("utils.postJson", m.a.Od), m.b("utils.parseJson", m.a.Nd), m.b("utils.registerEventHandler", m.a.B), m.b("utils.stringifyJson", m.a.hc), m.b("utils.range", m.a.Pd), m.b("utils.toggleDomNodeCssClass", m.a.Eb), m.b("utils.triggerEvent", m.a.Fb), m.b("utils.unwrapObservable", m.a.f), m.b("utils.objectForEach", m.a.P), m.b("utils.addOrRemoveItem", m.a.Na), m.b("utils.setTextContent", m.a.Bb), m.b("unwrap", m.a.f), Function.prototype.bind || (Function.prototype.bind = function (_) { var E = this; if (arguments.length === 1) return function () { return E.apply(_, arguments) }; var w = Array.prototype.slice.call(arguments, 1); return function () { var v = w.slice(0); return v.push.apply(v, arguments), E.apply(_, v) } }), m.a.g = new function () { var _ = 0, E = "__ko__" + new Date().getTime(), w = {}, v, O; return m.a.W ? (v = function (V, z) { var k = V[E]; if (!k || k === "null" || !w[k]) { if (!z) return e; k = V[E] = "ko" + _++, w[k] = {} } return w[k] }, O = function (V) { var z = V[E]; return z ? (delete w[z], V[E] = null, !0) : !1 }) : (v = function (V, z) { var k = V[E]; return !k && z && (k = V[E] = {}), k }, O = function (V) { return V[E] ? (delete V[E], !0) : !1 }), { get: function (V, z) { var k = v(V, !1); return k && k[z] }, set: function (V, z, k) { (V = v(V, k !== e)) && (V[z] = k) }, Ub: function (V, z, k) { return V = v(V, !0), V[z] || (V[z] = k) }, clear: O, Z: function () { return _++ + E } } }, m.b("utils.domData", m.a.g), m.b("utils.domData.clear", m.a.g.clear), m.a.K = new function () { function _(z, k) { var G = m.a.g.get(z, v); return G === e && k && (G = [], m.a.g.set(z, v, G)), G } function E(z) { var k = _(z, !1); if (k) for (var k = k.slice(0), G = 0; G < k.length; G++)k[G](z); m.a.g.clear(z), m.a.K.cleanExternalData(z), V[z.nodeType] && w(z.childNodes, !0) } function w(z, k) { for (var G = [], N, X = 0; X < z.length; X++)if ((!k || z[X].nodeType === 8) && (E(G[G.length] = N = z[X]), z[X] !== N)) for (; X-- && m.a.A(G, z[X]) == -1;); } var v = m.a.g.Z(), O = { 1: !0, 8: !0, 9: !0 }, V = { 1: !0, 9: !0 }; return { za: function (z, k) { if (typeof k != "function") throw Error("Callback must be a function"); _(z, !0).push(k) }, yb: function (z, k) { var G = _(z, !1); G && (m.a.Pa(G, k), G.length == 0 && m.a.g.set(z, v, e)) }, oa: function (z) { return m.u.G(function () { O[z.nodeType] && (E(z), V[z.nodeType] && w(z.getElementsByTagName("*"))) }), z }, removeNode: function (z) { m.oa(z), z.parentNode && z.parentNode.removeChild(z) }, cleanExternalData: function (z) { o && typeof o.cleanData == "function" && o.cleanData([z]) } } }, m.oa = m.a.K.oa, m.removeNode = m.a.K.removeNode, m.b("cleanNode", m.oa), m.b("removeNode", m.removeNode), m.b("utils.domNodeDisposal", m.a.K), m.b("utils.domNodeDisposal.addDisposeCallback", m.a.K.za), m.b("utils.domNodeDisposal.removeDisposeCallback", m.a.K.yb), function () { var _ = [0, "", ""], E = [1, "<table>", "</table>"], w = [3, "<table><tbody><tr>", "</tr></tbody></table>"], v = [1, "<select multiple='multiple'>", "</select>"], O = { thead: E, tbody: E, tfoot: E, tr: [2, "<table><tbody>", "</tbody></table>"], td: w, th: w, option: v, optgroup: v }, V = 8 >= m.a.W; m.a.ua = function (z, k) { var G; if (o) { if (o.parseHTML) G = o.parseHTML(z, k) || []; else if ((G = o.clean([z], k)) && G[0]) { for (var N = G[0]; N.parentNode && N.parentNode.nodeType !== 11;)N = N.parentNode; N.parentNode && N.parentNode.removeChild(N) } } else { (G = k) || (G = n); var N = G.parentWindow || G.defaultView || t, X = m.a.Db(z).toLowerCase(), q = G.createElement("div"), J; for (J = (X = X.match(/^(?:\x3c!--.*?--\x3e\s*?)*?<([a-z]+)[\s>]/)) && O[X[1]] || _, X = J[0], J = "ignored<div>" + J[1] + z + J[2] + "</div>", typeof N.innerShiv == "function" ? q.appendChild(N.innerShiv(J)) : (V && G.body.appendChild(q), q.innerHTML = J, V && q.parentNode.removeChild(q)); X--;)q = q.lastChild; G = m.a.la(q.lastChild.childNodes) } return G }, m.a.Md = function (z, k) { var G = m.a.ua(z, k); return G.length && G[0].parentElement || m.a.Yb(G) }, m.a.fc = function (z, k) { if (m.a.Tb(z), k = m.a.f(k), k !== null && k !== e) if (typeof k != "string" && (k = k.toString()), o) o(z).html(k); else for (var G = m.a.ua(k, z.ownerDocument), N = 0; N < G.length; N++)z.appendChild(G[N]) } }(), m.b("utils.parseHtmlFragment", m.a.ua), m.b("utils.setHtml", m.a.fc), m.aa = function () { function _(w, v) { if (w) { if (w.nodeType == 8) { var O = m.aa.Uc(w.nodeValue); O != null && v.push({ ud: w, Kd: O }) } else if (w.nodeType == 1) for (var O = 0, V = w.childNodes, z = V.length; O < z; O++)_(V[O], v) } } var E = {}; return { Xb: function (w) { if (typeof w != "function") throw Error("You can only pass a function to ko.memoization.memoize()"); var v = (4294967296 * (1 + Math.random()) | 0).toString(16).substring(1) + (4294967296 * (1 + Math.random()) | 0).toString(16).substring(1); return E[v] = w, "<!--[ko_memo:" + v + "]-->" }, bd: function (w, v) { var O = E[w]; if (O === e) throw Error("Couldn't find any memo with ID " + w + ". Perhaps it's already been unmemoized."); try { return O.apply(null, v || []), !0 } finally { delete E[w] } }, cd: function (w, v) { var O = []; _(w, O); for (var V = 0, z = O.length; V < z; V++) { var k = O[V].ud, G = [k]; v && m.a.Nb(G, v), m.aa.bd(O[V].Kd, G), k.nodeValue = "", k.parentNode && k.parentNode.removeChild(k) } }, Uc: function (w) { return (w = w.match(/^\[ko_memo\:(.*?)\]$/)) ? w[1] : null } } }(), m.b("memoization", m.aa), m.b("memoization.memoize", m.aa.Xb), m.b("memoization.unmemoize", m.aa.bd), m.b("memoization.parseMemoText", m.aa.Uc), m.b("memoization.unmemoizeDomNodeAndDescendants", m.aa.cd), m.na = function () { function _() { if (O) { for (var k = O, G = 0, N; z < O;)if (N = v[z++]) { if (z > k) { if (5e3 <= ++G) { z = O, m.a.Gc(Error("'Too much recursion' after processing " + G + " task groups.")); break } k = O } try { N() } catch (X) { m.a.Gc(X) } } } } function E() { _(), z = O = v.length = 0 } var w, v = [], O = 0, V = 1, z = 0; return t.MutationObserver ? w = function (k) { var G = n.createElement("div"); return new MutationObserver(k).observe(G, { attributes: !0 }), function () { G.classList.toggle("foo") } }(E) : w = n && "onreadystatechange" in n.createElement("script") ? function (k) { var G = n.createElement("script"); G.onreadystatechange = function () { G.onreadystatechange = null, n.documentElement.removeChild(G), G = null, k() }, n.documentElement.appendChild(G) } : function (k) { setTimeout(k, 0) }, { scheduler: w, zb: function (k) { return O || m.na.scheduler(E), v[O++] = k, V++ }, cancel: function (k) { k = k - (V - O), k >= z && k < O && (v[k] = null) }, resetForTesting: function () { var k = O - z; return z = O = v.length = 0, k }, Sd: _ } }(), m.b("tasks", m.na), m.b("tasks.schedule", m.na.zb), m.b("tasks.runEarly", m.na.Sd), m.Ta = { throttle: function (_, E) { _.throttleEvaluation = E; var w = null; return m.$({ read: _, write: function (v) { clearTimeout(w), w = m.a.setTimeout(function () { _(v) }, E) } }) }, rateLimit: function (_, E) { var w, v, O; typeof E == "number" ? w = E : (w = E.timeout, v = E.method), _.Hb = !1, O = typeof v == "function" ? v : v == "notifyWhenChangesStop" ? f : u, _.ub(function (V) { return O(V, w, E) }) }, deferred: function (_, E) { if (E !== !0) throw Error("The 'deferred' extender only accepts the value 'true', because it is not supported to turn deferral off once enabled."); _.Hb || (_.Hb = !0, _.ub(function (w) { var v, O = !1; return function () { if (!O) { m.na.cancel(v), v = m.na.zb(w); try { O = !0, _.notifySubscribers(e, "dirty") } finally { O = !1 } } } })) }, notify: function (_, E) { _.equalityComparer = E == "always" ? null : c } }; var A = { undefined: 1, boolean: 1, number: 1, string: 1 }; m.b("extenders", m.Ta), m.ic = function (_, E, w) { this.da = _, this.lc = E, this.mc = w, this.Ib = !1, this.fb = this.Jb = null, m.L(this, "dispose", this.s), m.L(this, "disposeWhenNodeIsRemoved", this.l) }, m.ic.prototype.s = function () { this.Ib || (this.fb && m.a.K.yb(this.Jb, this.fb), this.Ib = !0, this.mc(), this.da = this.lc = this.mc = this.Jb = this.fb = null) }, m.ic.prototype.l = function (_) { this.Jb = _, m.a.K.za(_, this.fb = this.s.bind(this)) }, m.T = function () { m.a.Ab(this, C), C.qb(this) }; var C = { qb: function (_) { _.U = { change: [] }, _.sc = 1 }, subscribe: function (_, E, w) { var v = this; w = w || "change"; var O = new m.ic(v, E ? _.bind(E) : _, function () { m.a.Pa(v.U[w], O), v.hb && v.hb(w) }); return v.Qa && v.Qa(w), v.U[w] || (v.U[w] = []), v.U[w].push(O), O }, notifySubscribers: function (_, E) { if (E = E || "change", E === "change" && this.Gb(), this.Wa(E)) { var w = E === "change" && this.ed || this.U[E].slice(0); try { m.u.xc(); for (var v = 0, O; O = w[v]; ++v)O.Ib || O.lc(_) } finally { m.u.end() } } }, ob: function () { return this.sc }, Dd: function (_) { return this.ob() !== _ }, Gb: function () { ++this.sc }, ub: function (_) { var E = this, w = m.O(E), v, O, V, z, k; E.gb || (E.gb = E.notifySubscribers, E.notifySubscribers = d); var G = _(function () { E.Ja = !1, w && z === E && (z = E.nc ? E.nc() : E()); var N = O || k && E.sb(V, z); k = O = v = !1, N && E.gb(V = z) }); E.qc = function (N, X) { X && E.Ja || (k = !X), E.ed = E.U.change.slice(0), E.Ja = v = !0, z = N, G() }, E.pc = function (N) { v || (V = N, E.gb(N, "beforeChange")) }, E.rc = function () { k = !0 }, E.gd = function () { E.sb(V, E.v(!0)) && (O = !0) } }, Wa: function (_) { return this.U[_] && this.U[_].length }, Bd: function (_) { if (_) return this.U[_] && this.U[_].length || 0; var E = 0; return m.a.P(this.U, function (w, v) { w !== "dirty" && (E += v.length) }), E }, sb: function (_, E) { return !this.equalityComparer || !this.equalityComparer(_, E) }, toString: function () { return "[object Object]" }, extend: function (_) { var E = this; return _ && m.a.P(_, function (w, v) { var O = m.Ta[w]; typeof O == "function" && (E = O(E, v) || E) }), E } }; m.L(C, "init", C.qb), m.L(C, "subscribe", C.subscribe), m.L(C, "extend", C.extend), m.L(C, "getSubscriptionsCount", C.Bd), m.a.Ba && m.a.setPrototypeOf(C, Function.prototype), m.T.fn = C, m.Qc = function (_) { return _ != null && typeof _.subscribe == "function" && typeof _.notifySubscribers == "function" }, m.b("subscribable", m.T), m.b("isSubscribable", m.Qc), m.S = m.u = function () { function _(V) { w.push(v), v = V } function E() { v = w.pop() } var w = [], v, O = 0; return { xc: _, end: E, cc: function (V) { if (v) { if (!m.Qc(V)) throw Error("Only subscribable things can act as dependencies"); v.od.call(v.pd, V, V.fd || (V.fd = ++O)) } }, G: function (V, z, k) { try { return _(), V.apply(z, k || []) } finally { E() } }, qa: function () { if (v) return v.o.qa() }, Va: function () { if (v) return v.o.Va() }, Ya: function () { if (v) return v.Ya }, o: function () { if (v) return v.o } } }(), m.b("computedContext", m.S), m.b("computedContext.getDependenciesCount", m.S.qa), m.b("computedContext.getDependencies", m.S.Va), m.b("computedContext.isInitial", m.S.Ya), m.b("computedContext.registerDependency", m.S.cc), m.b("ignoreDependencies", m.Yd = m.u.G); var x = m.a.Da("_latestValue"); m.ta = function (_) { function E() { return 0 < arguments.length ? (E.sb(E[x], arguments[0]) && (E.ya(), E[x] = arguments[0], E.xa()), this) : (m.u.cc(E), E[x]) } return E[x] = _, m.a.Ba || m.a.extend(E, m.T.fn), m.T.fn.qb(E), m.a.Ab(E, T), m.options.deferUpdates && m.Ta.deferred(E, !0), E }; var T = { equalityComparer: c, v: function () { return this[x] }, xa: function () { this.notifySubscribers(this[x], "spectate"), this.notifySubscribers(this[x]) }, ya: function () { this.notifySubscribers(this[x], "beforeChange") } }; m.a.Ba && m.a.setPrototypeOf(T, m.T.fn); var b = m.ta.Ma = "__ko_proto__"; T[b] = m.ta, m.O = function (_) { if ((_ = typeof _ == "function" && _[b]) && _ !== T[b] && _ !== m.o.fn[b]) throw Error("Invalid object that looks like an observable; possibly from another Knockout instance"); return !!_ }, m.Za = function (_) { return typeof _ == "function" && (_[b] === T[b] || _[b] === m.o.fn[b] && _.Nc) }, m.b("observable", m.ta), m.b("isObservable", m.O), m.b("isWriteableObservable", m.Za), m.b("isWritableObservable", m.Za), m.b("observable.fn", T), m.L(T, "peek", T.v), m.L(T, "valueHasMutated", T.xa), m.L(T, "valueWillMutate", T.ya), m.Ha = function (_) { if (_ = _ || [], typeof _ != "object" || !("length" in _)) throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined."); return _ = m.ta(_), m.a.Ab(_, m.Ha.fn), _.extend({ trackArrayChanges: !0 }) }, m.Ha.fn = { remove: function (_) { for (var E = this.v(), w = [], v = typeof _ != "function" || m.O(_) ? function (z) { return z === _ } : _, O = 0; O < E.length; O++) { var V = E[O]; if (v(V)) { if (w.length === 0 && this.ya(), E[O] !== V) throw Error("Array modified during remove; cannot remove item"); w.push(V), E.splice(O, 1), O-- } } return w.length && this.xa(), w }, removeAll: function (_) { if (_ === e) { var E = this.v(), w = E.slice(0); return this.ya(), E.splice(0, E.length), this.xa(), w } return _ ? this.remove(function (v) { return 0 <= m.a.A(_, v) }) : [] }, destroy: function (_) { var E = this.v(), w = typeof _ != "function" || m.O(_) ? function (V) { return V === _ } : _; this.ya(); for (var v = E.length - 1; 0 <= v; v--) { var O = E[v]; w(O) && (O._destroy = !0) } this.xa() }, destroyAll: function (_) { return _ === e ? this.destroy(function () { return !0 }) : _ ? this.destroy(function (E) { return 0 <= m.a.A(_, E) }) : [] }, indexOf: function (_) { var E = this(); return m.a.A(E, _) }, replace: function (_, E) { var w = this.indexOf(_); 0 <= w && (this.ya(), this.v()[w] = E, this.xa()) }, sorted: function (_) { var E = this().slice(0); return _ ? E.sort(_) : E.sort() }, reversed: function () { return this().slice(0).reverse() } }, m.a.Ba && m.a.setPrototypeOf(m.Ha.fn, m.ta.fn), m.a.D("pop push reverse shift sort splice unshift".split(" "), function (_) { m.Ha.fn[_] = function () { var E = this.v(); this.ya(), this.zc(E, _, arguments); var w = E[_].apply(E, arguments); return this.xa(), w === E ? this : w } }), m.a.D(["slice"], function (_) { m.Ha.fn[_] = function () { var E = this(); return E[_].apply(E, arguments) } }), m.Pc = function (_) { return m.O(_) && typeof _.remove == "function" && typeof _.push == "function" }, m.b("observableArray", m.Ha), m.b("isObservableArray", m.Pc), m.Ta.trackArrayChanges = function (_, E) { function w() { function q() { if (k) { var J = [].concat(_.v() || []), W; _.Wa("arrayChange") && ((!O || 1 < k) && (O = m.a.Pb(G, J, _.Ob)), W = O), G = J, O = null, k = 0, W && W.length && _.notifySubscribers(W, "arrayChange") } } v ? q() : (v = !0, z = _.subscribe(function () { ++k }, null, "spectate"), G = [].concat(_.v() || []), O = null, V = _.subscribe(q)) } if (_.Ob = {}, E && typeof E == "object" && m.a.extend(_.Ob, E), _.Ob.sparse = !0, !_.zc) { var v = !1, O = null, V, z, k = 0, G, N = _.Qa, X = _.hb; _.Qa = function (q) { N && N.call(_, q), q === "arrayChange" && w() }, _.hb = function (q) { X && X.call(_, q), q !== "arrayChange" || _.Wa("arrayChange") || (V && V.s(), z && z.s(), z = V = null, v = !1, G = e) }, _.zc = function (q, J, W) { function K(Ie, Fe, We) { return Z[Z.length] = { status: Ie, value: Fe, index: We } } if (v && !k) { var Z = [], de = q.length, pe = W.length, oe = 0; switch (J) { case "push": oe = de; case "unshift": for (J = 0; J < pe; J++)K("added", W[J], oe + J); break; case "pop": oe = de - 1; case "shift": de && K("deleted", q[oe], oe); break; case "splice": J = Math.min(Math.max(0, 0 > W[0] ? de + W[0] : W[0]), de); for (var de = pe === 1 ? de : Math.min(J + (W[1] || 0), de), pe = J + pe - 2, oe = Math.max(de, pe), ue = [], ge = [], Ee = 2; J < oe; ++J, ++Ee)J < de && ge.push(K("deleted", q[J], J)), J < pe && ue.push(K("added", W[Ee], J)); m.a.Kc(ge, ue); break; default: return }O = Z } } } }; var S = m.a.Da("_state"); m.o = m.$ = function (_, E, w) { function v() { if (0 < arguments.length) { if (typeof O == "function") O.apply(V.nb, arguments); else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters."); return this } return V.ra || m.u.cc(v), (V.ka || V.J && v.Xa()) && v.ha(), V.X } if (typeof _ == "object" ? w = _ : (w = w || {}, _ && (w.read = _)), typeof w.read != "function") throw Error("Pass a function that returns the value of the ko.computed"); var O = w.write, V = { X: e, sa: !0, ka: !0, rb: !1, jc: !1, ra: !1, wb: !1, J: !1, Wc: w.read, nb: E || w.owner, l: w.disposeWhenNodeIsRemoved || w.l || null, Sa: w.disposeWhen || w.Sa, Rb: null, I: {}, V: 0, Ic: null }; return v[S] = V, v.Nc = typeof O == "function", m.a.Ba || m.a.extend(v, m.T.fn), m.T.fn.qb(v), m.a.Ab(v, D), w.pure ? (V.wb = !0, V.J = !0, m.a.extend(v, P)) : w.deferEvaluation && m.a.extend(v, B), m.options.deferUpdates && m.Ta.deferred(v, !0), V.l && (V.jc = !0, V.l.nodeType || (V.l = null)), V.J || w.deferEvaluation || v.ha(), V.l && v.ja() && m.a.K.za(V.l, V.Rb = function () { v.s() }), v }; var D = { equalityComparer: c, qa: function () { return this[S].V }, Va: function () { var _ = []; return m.a.P(this[S].I, function (E, w) { _[w.Ka] = w.da }), _ }, Vb: function (_) { if (!this[S].V) return !1; var E = this.Va(); return m.a.A(E, _) !== -1 ? !0 : !!m.a.Lb(E, function (w) { return w.Vb && w.Vb(_) }) }, uc: function (_, E, w) { if (this[S].wb && E === this) throw Error("A 'pure' computed must not be called recursively"); this[S].I[_] = w, w.Ka = this[S].V++, w.La = E.ob() }, Xa: function () { var _, E, w = this[S].I; for (_ in w) if (Object.prototype.hasOwnProperty.call(w, _) && (E = w[_], this.Ia && E.da.Ja || E.da.Dd(E.La))) return !0 }, Jd: function () { this.Ia && !this[S].rb && this.Ia(!1) }, ja: function () { var _ = this[S]; return _.ka || 0 < _.V }, Rd: function () { this.Ja ? this[S].ka && (this[S].sa = !0) : this.Hc() }, $c: function (_) { if (_.Hb) { var E = _.subscribe(this.Jd, this, "dirty"), w = _.subscribe(this.Rd, this); return { da: _, s: function () { E.s(), w.s() } } } return _.subscribe(this.Hc, this) }, Hc: function () { var _ = this, E = _.throttleEvaluation; E && 0 <= E ? (clearTimeout(this[S].Ic), this[S].Ic = m.a.setTimeout(function () { _.ha(!0) }, E)) : _.Ia ? _.Ia(!0) : _.ha(!0) }, ha: function (_) { var E = this[S], w = E.Sa, v = !1; if (!E.rb && !E.ra) { if (E.l && !m.a.Sb(E.l) || w && w()) { if (!E.jc) { this.s(); return } } else E.jc = !1; E.rb = !0; try { v = this.zd(_) } finally { E.rb = !1 } return v } }, zd: function (_) { var E = this[S], v = !1, w = E.wb ? e : !E.V, v = { qd: this, mb: E.I, Qb: E.V }; m.u.xc({ pd: v, od: g, o: this, Ya: w }), E.I = {}, E.V = 0; var O = this.yd(E, v); return E.V ? v = this.sb(E.X, O) : (this.s(), v = !0), v && (E.J ? this.Gb() : this.notifySubscribers(E.X, "beforeChange"), E.X = O, this.notifySubscribers(E.X, "spectate"), !E.J && _ && this.notifySubscribers(E.X), this.rc && this.rc()), w && this.notifySubscribers(E.X, "awake"), v }, yd: function (_, E) { try { var w = _.Wc; return _.nb ? w.call(_.nb) : w() } finally { m.u.end(), E.Qb && !_.J && m.a.P(E.mb, p), _.sa = _.ka = !1 } }, v: function (_) { var E = this[S]; return (E.ka && (_ || !E.V) || E.J && this.Xa()) && this.ha(), E.X }, ub: function (_) { m.T.fn.ub.call(this, _), this.nc = function () { return this[S].J || (this[S].sa ? this.ha() : this[S].ka = !1), this[S].X }, this.Ia = function (E) { this.pc(this[S].X), this[S].ka = !0, E && (this[S].sa = !0), this.qc(this, !E) } }, s: function () { var _ = this[S]; !_.J && _.I && m.a.P(_.I, function (E, w) { w.s && w.s() }), _.l && _.Rb && m.a.K.yb(_.l, _.Rb), _.I = e, _.V = 0, _.ra = !0, _.sa = !1, _.ka = !1, _.J = !1, _.l = e, _.Sa = e, _.Wc = e, this.Nc || (_.nb = e) } }, P = { Qa: function (_) { var E = this, w = E[S]; if (!w.ra && w.J && _ == "change") { if (w.J = !1, w.sa || E.Xa()) w.I = null, w.V = 0, E.ha() && E.Gb(); else { var v = []; m.a.P(w.I, function (O, V) { v[V.Ka] = O }), m.a.D(v, function (O, V) { var z = w.I[O], k = E.$c(z.da); k.Ka = V, k.La = z.La, w.I[O] = k }), E.Xa() && E.ha() && E.Gb() } w.ra || E.notifySubscribers(w.X, "awake") } }, hb: function (_) { var E = this[S]; E.ra || _ != "change" || this.Wa("change") || (m.a.P(E.I, function (w, v) { v.s && (E.I[w] = { da: v.da, Ka: v.Ka, La: v.La }, v.s()) }), E.J = !0, this.notifySubscribers(e, "asleep")) }, ob: function () { var _ = this[S]; return _.J && (_.sa || this.Xa()) && this.ha(), m.T.fn.ob.call(this) } }, B = { Qa: function (_) { _ != "change" && _ != "beforeChange" || this.v() } }; m.a.Ba && m.a.setPrototypeOf(D, m.T.fn); var R = m.ta.Ma; D[R] = m.o, m.Oc = function (_) { return typeof _ == "function" && _[R] === D[R] }, m.Fd = function (_) { return m.Oc(_) && _[S] && _[S].wb }, m.b("computed", m.o), m.b("dependentObservable", m.o), m.b("isComputed", m.Oc), m.b("isPureComputed", m.Fd), m.b("computed.fn", D), m.L(D, "peek", D.v), m.L(D, "dispose", D.s), m.L(D, "isActive", D.ja), m.L(D, "getDependenciesCount", D.qa), m.L(D, "getDependencies", D.Va), m.xb = function (_, E) { return typeof _ == "function" ? m.o(_, E, { pure: !0 }) : (_ = m.a.extend({}, _), _.pure = !0, m.o(_, E)) }, m.b("pureComputed", m.xb), function () { function _(v, O, V) { if (V = V || new w, v = O(v), typeof v != "object" || v === null || v === e || v instanceof RegExp || v instanceof Date || v instanceof String || v instanceof Number || v instanceof Boolean) return v; var z = v instanceof Array ? [] : {}; return V.save(v, z), E(v, function (k) { var G = O(v[k]); switch (typeof G) { case "boolean": case "number": case "string": case "function": z[k] = G; break; case "object": case "undefined": var N = V.get(G); z[k] = N !== e ? N : _(G, O, V) } }), z } function E(v, O) { if (v instanceof Array) { for (var V = 0; V < v.length; V++)O(V); typeof v.toJSON == "function" && O("toJSON") } else for (V in v) O(V) } function w() { this.keys = [], this.values = [] } m.ad = function (v) { if (arguments.length == 0) throw Error("When calling ko.toJS, pass the object you want to convert."); return _(v, function (O) { for (var V = 0; m.O(O) && 10 > V; V++)O = O(); return O }) }, m.toJSON = function (v, O, V) { return v = m.ad(v), m.a.hc(v, O, V) }, w.prototype = { constructor: w, save: function (v, O) { var V = m.a.A(this.keys, v); 0 <= V ? this.values[V] = O : (this.keys.push(v), this.values.push(O)) }, get: function (v) { return v = m.a.A(this.keys, v), 0 <= v ? this.values[v] : e } } }(), m.b("toJS", m.ad), m.b("toJSON", m.toJSON), m.Wd = function (_, E, w) { function v(O) { var V = m.xb(_, w).extend({ ma: "always" }), z = V.subscribe(function (k) { k && (z.s(), O(k)) }); return V.notifySubscribers(V.v()), z } return typeof Promise != "function" || E ? v(E.bind(w)) : new Promise(v) }, m.b("when", m.Wd), function () { m.w = { M: function (_) { switch (m.a.R(_)) { case "option": return _.__ko__hasDomDataOptionValue__ === !0 ? m.a.g.get(_, m.c.options.$b) : 7 >= m.a.W ? _.getAttributeNode("value") && _.getAttributeNode("value").specified ? _.value : _.text : _.value; case "select": return 0 <= _.selectedIndex ? m.w.M(_.options[_.selectedIndex]) : e; default: return _.value } }, cb: function (_, E, w) { switch (m.a.R(_)) { case "option": typeof E == "string" ? (m.a.g.set(_, m.c.options.$b, e), "__ko__hasDomDataOptionValue__" in _ && delete _.__ko__hasDomDataOptionValue__, _.value = E) : (m.a.g.set(_, m.c.options.$b, E), _.__ko__hasDomDataOptionValue__ = !0, _.value = typeof E == "number" ? E : ""); break; case "select": (E === "" || E === null) && (E = e); for (var v = -1, O = 0, V = _.options.length, z; O < V; ++O)if (z = m.w.M(_.options[O]), z == E || z === "" && E === e) { v = O; break } (w || 0 <= v || E === e && 1 < _.size) && (_.selectedIndex = v, m.a.W === 6 && m.a.setTimeout(function () { _.selectedIndex = v }, 0)); break; default: (E === null || E === e) && (E = ""), _.value = E } } } }(), m.b("selectExtensions", m.w), m.b("selectExtensions.readValue", m.w.M), m.b("selectExtensions.writeValue", m.w.cb), m.m = function () {
                        function _(k) {
                            k = m.a.Db(k), k.charCodeAt(0) === 123 && (k = k.slice(1, -1)), k += `
,`; var G = [], N = k.match(v), X, q = [], J = 0; if (1 < N.length) { for (var W = 0, K; K = N[W]; ++W) { var Z = K.charCodeAt(0); if (Z === 44) { if (0 >= J) { G.push(X && q.length ? { key: X, value: q.join("") } : { unknown: X || q.join("") }), X = J = 0, q = []; continue } } else if (Z === 58) { if (!J && !X && q.length === 1) { X = q.pop(); continue } } else { if (Z === 47 && 1 < K.length && (K.charCodeAt(1) === 47 || K.charCodeAt(1) === 42)) continue; Z === 47 && W && 1 < K.length ? (Z = N[W - 1].match(O)) && !V[Z[0]] && (k = k.substr(k.indexOf(K) + 1), N = k.match(v), W = -1, K = "/") : Z === 40 || Z === 123 || Z === 91 ? ++J : Z === 41 || Z === 125 || Z === 93 ? --J : X || q.length || Z !== 34 && Z !== 39 || (K = K.slice(1, -1)) } q.push(K) } if (0 < J) throw Error("Unbalanced parentheses, braces, or brackets") } return G
                        } var E = ["true", "false", "null", "undefined"], w = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i, v = RegExp(`"(?:\\\\.|[^"])*"|'(?:\\\\.|[^'])*'|\`(?:\\\\.|[^\`])*\`|/\\*(?:[^*]|\\*+[^*/])*\\*+/|//.*
|/(?:\\\\.|[^/])+/w*|[^\\s:,/][^,"'\`{}()/:[\\]]*[^\\s,"'\`{}()/:[\\]]|[^\\s]`, "g"), O = /[\])"'A-Za-z0-9_$]+$/, V = { in: 1, return: 1, typeof: 1 }, z = {}; return { Ra: [], wa: z, ac: _, vb: function (k, G) { function N(Z, de) { var pe; if (!W) { var oe = m.getBindingHandler(Z); if (oe && oe.preprocess && !(de = oe.preprocess(de, Z, N))) return; (oe = z[Z]) && (pe = de, 0 <= m.a.A(E, pe) ? pe = !1 : (oe = pe.match(w), pe = oe === null ? !1 : oe[1] ? "Object(" + oe[1] + ")" + oe[2] : pe), oe = pe), oe && q.push("'" + (typeof z[Z] == "string" ? z[Z] : Z) + "':function(_z){" + pe + "=_z}") } J && (de = "function(){return " + de + " }"), X.push("'" + Z + "':" + de) } G = G || {}; var X = [], q = [], J = G.valueAccessors, W = G.bindingParams, K = typeof k == "string" ? _(k) : k; return m.a.D(K, function (Z) { N(Z.key || Z.unknown, Z.value) }), q.length && N("_ko_property_writers", "{" + q.join(",") + " }"), X.join(",") }, Id: function (k, G) { for (var N = 0; N < k.length; N++)if (k[N].key == G) return !0; return !1 }, eb: function (k, G, N, X, q) { k && m.O(k) ? !m.Za(k) || q && k.v() === X || k(X) : (k = G.get("_ko_property_writers")) && k[N] && k[N](X) } }
                    }(), m.b("expressionRewriting", m.m), m.b("expressionRewriting.bindingRewriteValidators", m.m.Ra), m.b("expressionRewriting.parseObjectLiteral", m.m.ac), m.b("expressionRewriting.preProcessBindings", m.m.vb), m.b("expressionRewriting._twoWayBindings", m.m.wa), m.b("jsonExpressionRewriting", m.m), m.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson", m.m.vb), function () { function _(N) { return N.nodeType == 8 && V.test(O ? N.text : N.nodeValue) } function E(N) { return N.nodeType == 8 && z.test(O ? N.text : N.nodeValue) } function w(N, X) { for (var q = N, J = 1, W = []; q = q.nextSibling;) { if (E(q) && (m.a.g.set(q, G, !0), J--, J === 0)) return W; W.push(q), _(q) && J++ } if (!X) throw Error("Cannot find closing comment tag to match: " + N.nodeValue); return null } function v(N, X) { var q = w(N, X); return q ? 0 < q.length ? q[q.length - 1].nextSibling : N.nextSibling : null } var O = n && n.createComment("test").text === "<!--test-->", V = O ? /^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/ : /^\s*ko(?:\s+([\s\S]+))?\s*$/, z = O ? /^\x3c!--\s*\/ko\s*--\x3e$/ : /^\s*\/ko\s*$/, k = { ul: !0, ol: !0 }, G = "__ko_matchedEndComment__"; m.h = { ea: {}, childNodes: function (N) { return _(N) ? w(N) : N.childNodes }, Ea: function (N) { if (_(N)) { N = m.h.childNodes(N); for (var X = 0, q = N.length; X < q; X++)m.removeNode(N[X]) } else m.a.Tb(N) }, va: function (N, X) { if (_(N)) { m.h.Ea(N); for (var q = N.nextSibling, J = 0, W = X.length; J < W; J++)q.parentNode.insertBefore(X[J], q) } else m.a.va(N, X) }, Vc: function (N, X) { var q; _(N) ? (q = N.nextSibling, N = N.parentNode) : q = N.firstChild, q ? X !== q && N.insertBefore(X, q) : N.appendChild(X) }, Wb: function (N, X, q) { q ? (q = q.nextSibling, _(N) && (N = N.parentNode), q ? X !== q && N.insertBefore(X, q) : N.appendChild(X)) : m.h.Vc(N, X) }, firstChild: function (N) { if (_(N)) return !N.nextSibling || E(N.nextSibling) ? null : N.nextSibling; if (N.firstChild && E(N.firstChild)) throw Error("Found invalid end comment, as the first child of " + N); return N.firstChild }, nextSibling: function (N) { if (_(N) && (N = v(N)), N.nextSibling && E(N.nextSibling)) { var X = N.nextSibling; if (E(X) && !m.a.g.get(X, G)) throw Error("Found end comment without a matching opening comment, as child of " + N); return null } return N.nextSibling }, Cd: _, Vd: function (N) { return (N = (O ? N.text : N.nodeValue).match(V)) ? N[1] : null }, Sc: function (N) { if (k[m.a.R(N)]) { var X = N.firstChild; if (X) do if (X.nodeType === 1) { var q; q = X.firstChild; var J = null; if (q) do if (J) J.push(q); else if (_(q)) { var W = v(q, !0); W ? q = W : J = [q] } else E(q) && (J = [q]); while (q = q.nextSibling); if (q = J) for (J = X.nextSibling, W = 0; W < q.length; W++)J ? N.insertBefore(q[W], J) : N.appendChild(q[W]) } while (X = X.nextSibling) } } } }(), m.b("virtualElements", m.h), m.b("virtualElements.allowedBindings", m.h.ea), m.b("virtualElements.emptyNode", m.h.Ea), m.b("virtualElements.insertAfter", m.h.Wb), m.b("virtualElements.prepend", m.h.Vc), m.b("virtualElements.setDomNodeChildren", m.h.va), function () {
                        m.ga = function () { this.nd = {} }, m.a.extend(m.ga.prototype, {
                            nodeHasBindings: function (_) { switch (_.nodeType) { case 1: return _.getAttribute("data-bind") != null || m.j.getComponentNameForNode(_); case 8: return m.h.Cd(_); default: return !1 } }, getBindings: function (_, E) { var w = this.getBindingsString(_, E), w = w ? this.parseBindingsString(w, E, _) : null; return m.j.tc(w, _, E, !1) }, getBindingAccessors: function (_, E) { var w = this.getBindingsString(_, E), w = w ? this.parseBindingsString(w, E, _, { valueAccessors: !0 }) : null; return m.j.tc(w, _, E, !0) }, getBindingsString: function (_) { switch (_.nodeType) { case 1: return _.getAttribute("data-bind"); case 8: return m.h.Vd(_); default: return null } }, parseBindingsString: function (_, E, w, v) {
                                try { var O = this.nd, V = _ + (v && v.valueAccessors || ""), z; if (!(z = O[V])) { var k, G = "with($context){with($data||{}){return{" + m.m.vb(_, v) + "}}}"; k = new Function("$context", "$element", G), z = O[V] = k } return z(E, w) } catch (N) {
                                    throw N.message = `Unable to parse bindings.
Bindings value: `+ _ + `
Message: `+ N.message, N
                                }
                            }
                        }), m.ga.instance = new m.ga
                    }(), m.b("bindingProvider", m.ga), function () {
                        function _(oe) { var ue = (oe = m.a.g.get(oe, pe)) && oe.N; ue && (oe.N = null, ue.Tc()) } function E(oe, ue, ge) { this.node = oe, this.yc = ue, this.kb = [], this.H = !1, ue.N || m.a.K.za(oe, _), ge && ge.N && (ge.N.kb.push(oe), this.Kb = ge) } function w(oe) { return function () { return oe } } function v(oe) { return oe() } function O(oe) { return m.a.Ga(m.u.G(oe), function (ue, ge) { return function () { return oe()[ge] } }) } function V(oe, ue, ge) { return typeof oe == "function" ? O(oe.bind(null, ue, ge)) : m.a.Ga(oe, w) } function z(oe, ue) { return O(this.getBindings.bind(this, oe, ue)) } function k(oe, ue) { var ge = m.h.firstChild(ue); if (ge) { var Ee, Ie = m.ga.instance, Fe = Ie.preprocessNode; if (Fe) { for (; Ee = ge;)ge = m.h.nextSibling(Ee), Fe.call(Ie, Ee); ge = m.h.firstChild(ue) } for (; Ee = ge;)ge = m.h.nextSibling(Ee), G(oe, Ee) } m.i.ma(ue, m.i.H) } function G(oe, ue) { var ge = oe, Ee = ue.nodeType === 1; Ee && m.h.Sc(ue), (Ee || m.ga.instance.nodeHasBindings(ue)) && (ge = X(ue, null, oe).bindingContextForDescendants), ge && !Z[m.a.R(ue)] && k(ge, ue) } function N(oe) { var ue = [], ge = {}, Ee = []; return m.a.P(oe, function Ie(Fe) { if (!ge[Fe]) { var We = m.getBindingHandler(Fe); We && (We.after && (Ee.push(Fe), m.a.D(We.after, function (Lt) { if (oe[Lt]) { if (m.a.A(Ee, Lt) !== -1) throw Error("Cannot combine the following bindings, because they have a cyclic dependency: " + Ee.join(", ")); Ie(Lt) } }), Ee.length--), ue.push({ key: Fe, Mc: We })), ge[Fe] = !0 } }), ue } function X(oe, ue, ge) {
                            var Ee = m.a.g.Ub(oe, pe, {}), Ie = Ee.hd; if (!ue) { if (Ie) throw Error("You cannot apply bindings multiple times to the same element."); Ee.hd = !0 } Ie || (Ee.context = ge), Ee.Zb || (Ee.Zb = {}); var Fe; if (ue && typeof ue != "function") Fe = ue; else { var We = m.ga.instance, Lt = We.getBindingAccessors || z, Gt = m.$(function () { return (Fe = ue ? ue(ge, oe) : Lt.call(We, oe, ge)) && (ge[J] && ge[J](), ge[K] && ge[K]()), Fe }, null, { l: oe }); Fe && Gt.ja() || (Gt = null) } var cn = ge, _t; if (Fe) {
                                var Pn = function () { return m.a.Ga(Gt ? Gt() : Fe, v) }, Jn = Gt ? function (at) { return function () { return v(Gt()[at]) } } : function (at) { return Fe[at] }; Pn.get = function (at) { return Fe[at] && v(Jn(at)) }, Pn.has = function (at) { return at in Fe }, m.i.H in Fe && m.i.subscribe(oe, m.i.H, function () { var at = (0, Fe[m.i.H])(); if (at) { var Ne = m.h.childNodes(oe); Ne.length && at(Ne, m.Ec(Ne[0])) } }), m.i.pa in Fe && (cn = m.i.Cb(oe, ge), m.i.subscribe(oe, m.i.pa, function () { var at = (0, Fe[m.i.pa])(); at && m.h.firstChild(oe) && at(oe) })), Ee = N(Fe), m.a.D(Ee, function (at) {
                                    var Ne = at.Mc.init, nt = at.Mc.update, Ce = at.key; if (oe.nodeType === 8 && !m.h.ea[Ce]) throw Error("The binding '" + Ce + "' cannot be used with virtual elements"); try { typeof Ne == "function" && m.u.G(function () { var je = Ne(oe, Jn(Ce), Pn, cn.$data, cn); if (je && je.controlsDescendantBindings) { if (_t !== e) throw Error("Multiple bindings (" + _t + " and " + Ce + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element."); _t = Ce } }), typeof nt == "function" && m.$(function () { nt(oe, Jn(Ce), Pn, cn.$data, cn) }, null, { l: oe }) } catch (je) {
                                        throw je.message = 'Unable to process binding "' + Ce + ": " + Fe[Ce] + `"
Message: `+ je.message, je
                                    }
                                })
                            } return Ee = _t === e, { shouldBindDescendants: Ee, bindingContextForDescendants: Ee && cn }
                        } function q(oe, ue) { return oe && oe instanceof m.fa ? oe : new m.fa(oe, e, e, ue) } var J = m.a.Da("_subscribable"), W = m.a.Da("_ancestorBindingInfo"), K = m.a.Da("_dataDependency"); m.c = {}; var Z = { script: !0, textarea: !0, template: !0 }; m.getBindingHandler = function (oe) { return m.c[oe] }; var de = {}; m.fa = function (oe, ue, ge, Ee, Ie) { function Fe() { var Jn = cn ? Gt() : Gt, at = m.a.f(Jn); return ue ? (m.a.extend(We, ue), W in ue && (We[W] = ue[W])) : (We.$parents = [], We.$root = at, We.ko = m), We[J] = _t, Lt ? at = We.$data : (We.$rawData = Jn, We.$data = at), ge && (We[ge] = at), Ee && Ee(We, ue, at), ue && ue[J] && !m.S.o().Vb(ue[J]) && ue[J](), Pn && (We[K] = Pn), We.$data } var We = this, Lt = oe === de, Gt = Lt ? e : oe, cn = typeof Gt == "function" && !m.O(Gt), _t, Pn = Ie && Ie.dataDependency; Ie && Ie.exportDependencies ? Fe() : (_t = m.xb(Fe), _t.v(), _t.ja() ? _t.equalityComparer = null : We[J] = e) }, m.fa.prototype.createChildContext = function (oe, ue, ge, Ee) { if (!Ee && ue && typeof ue == "object" && (Ee = ue, ue = Ee.as, ge = Ee.extend), ue && Ee && Ee.noChildContext) { var Ie = typeof oe == "function" && !m.O(oe); return new m.fa(de, this, null, function (Fe) { ge && ge(Fe), Fe[ue] = Ie ? oe() : oe }, Ee) } return new m.fa(oe, this, ue, function (Fe, We) { Fe.$parentContext = We, Fe.$parent = We.$data, Fe.$parents = (We.$parents || []).slice(0), Fe.$parents.unshift(Fe.$parent), ge && ge(Fe) }, Ee) }, m.fa.prototype.extend = function (oe, ue) { return new m.fa(de, this, null, function (ge) { m.a.extend(ge, typeof oe == "function" ? oe(ge) : oe) }, ue) }; var pe = m.a.g.Z(); E.prototype.Tc = function () { this.Kb && this.Kb.N && this.Kb.N.sd(this.node) }, E.prototype.sd = function (oe) { m.a.Pa(this.kb, oe), !this.kb.length && this.H && this.Cc() }, E.prototype.Cc = function () { this.H = !0, this.yc.N && !this.kb.length && (this.yc.N = null, m.a.K.yb(this.node, _), m.i.ma(this.node, m.i.pa), this.Tc()) }, m.i = { H: "childrenComplete", pa: "descendantsComplete", subscribe: function (oe, ue, ge, Ee, Ie) { var Fe = m.a.g.Ub(oe, pe, {}); return Fe.Fa || (Fe.Fa = new m.T), Ie && Ie.notifyImmediately && Fe.Zb[ue] && m.u.G(ge, Ee, [oe]), Fe.Fa.subscribe(ge, Ee, ue) }, ma: function (oe, ue) { var ge = m.a.g.get(oe, pe); if (ge && (ge.Zb[ue] = !0, ge.Fa && ge.Fa.notifySubscribers(oe, ue), ue == m.i.H)) { if (ge.N) ge.N.Cc(); else if (ge.N === e && ge.Fa && ge.Fa.Wa(m.i.pa)) throw Error("descendantsComplete event not supported for bindings on this node") } }, Cb: function (oe, ue) { var ge = m.a.g.Ub(oe, pe, {}); return ge.N || (ge.N = new E(oe, ge, ue[W])), ue[W] == ge ? ue : ue.extend(function (Ee) { Ee[W] = ge }) } }, m.Td = function (oe) { return (oe = m.a.g.get(oe, pe)) && oe.context }, m.ib = function (oe, ue, ge) { return oe.nodeType === 1 && m.h.Sc(oe), X(oe, ue, q(ge)) }, m.ld = function (oe, ue, ge) { return ge = q(ge), m.ib(oe, V(ue, ge, oe), ge) }, m.Oa = function (oe, ue) { ue.nodeType !== 1 && ue.nodeType !== 8 || k(q(oe), ue) }, m.vc = function (oe, ue, ge) { if (!o && t.jQuery && (o = t.jQuery), 2 > arguments.length) { if (ue = n.body, !ue) throw Error("ko.applyBindings: could not find document.body; has the document been loaded?") } else if (!ue || ue.nodeType !== 1 && ue.nodeType !== 8) throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node"); G(q(oe, ge), ue) }, m.Dc = function (oe) { return !oe || oe.nodeType !== 1 && oe.nodeType !== 8 ? e : m.Td(oe) }, m.Ec = function (oe) { return (oe = m.Dc(oe)) ? oe.$data : e }, m.b("bindingHandlers", m.c), m.b("bindingEvent", m.i), m.b("bindingEvent.subscribe", m.i.subscribe), m.b("bindingEvent.startPossiblyAsyncContentBinding", m.i.Cb), m.b("applyBindings", m.vc), m.b("applyBindingsToDescendants", m.Oa), m.b("applyBindingAccessorsToNode", m.ib), m.b("applyBindingsToNode", m.ld), m.b("contextFor", m.Dc), m.b("dataFor", m.Ec)
                    }(), function (_) { function E(z, k) { var G = Object.prototype.hasOwnProperty.call(O, z) ? O[z] : _, N; G ? G.subscribe(k) : (G = O[z] = new m.T, G.subscribe(k), w(z, function (X, q) { var J = !(!q || !q.synchronous); V[z] = { definition: X, Gd: J }, delete O[z], N || J ? G.notifySubscribers(X) : m.na.zb(function () { G.notifySubscribers(X) }) }), N = !0) } function w(z, k) { v("getConfig", [z], function (G) { G ? v("loadComponent", [z, G], function (N) { k(N, G) }) : k(null, null) }) } function v(z, k, G, N) { N || (N = m.j.loaders.slice(0)); var X = N.shift(); if (X) { var q = X[z]; if (q) { var J = !1; if (q.apply(X, k.concat(function (W) { J ? G(null) : W !== null ? G(W) : v(z, k, G, N) })) !== _ && (J = !0, !X.suppressLoaderExceptions)) throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.") } else v(z, k, G, N) } else G(null) } var O = {}, V = {}; m.j = { get: function (z, k) { var G = Object.prototype.hasOwnProperty.call(V, z) ? V[z] : _; G ? G.Gd ? m.u.G(function () { k(G.definition) }) : m.na.zb(function () { k(G.definition) }) : E(z, k) }, Bc: function (z) { delete V[z] }, oc: v }, m.j.loaders = [], m.b("components", m.j), m.b("components.get", m.j.get), m.b("components.clearCachedDefinition", m.j.Bc) }(), function () { function _(G, N, X, q) { function J() { --K === 0 && q(W) } var W = {}, K = 2, Z = X.template; X = X.viewModel, Z ? O(N, Z, function (de) { m.j.oc("loadTemplate", [G, de], function (pe) { W.template = pe, J() }) }) : J(), X ? O(N, X, function (de) { m.j.oc("loadViewModel", [G, de], function (pe) { W[k] = pe, J() }) }) : J() } function E(G, N, X) { if (typeof N == "function") X(function (J) { return new N(J) }); else if (typeof N[k] == "function") X(N[k]); else if ("instance" in N) { var q = N.instance; X(function () { return q }) } else "viewModel" in N ? E(G, N.viewModel, X) : G("Unknown viewModel value: " + N) } function w(G) { switch (m.a.R(G)) { case "script": return m.a.ua(G.text); case "textarea": return m.a.ua(G.value); case "template": if (v(G.content)) return m.a.Ca(G.content.childNodes) }return m.a.Ca(G.childNodes) } function v(G) { return t.DocumentFragment ? G instanceof DocumentFragment : G && G.nodeType === 11 } function O(G, N, X) { typeof N.require == "string" ? a || t.require ? (a || t.require)([N.require], function (q) { q && typeof q == "object" && q.Xd && q.default && (q = q.default), X(q) }) : G("Uses require, but no AMD loader is present") : X(N) } function V(G) { return function (N) { throw Error("Component '" + G + "': " + N) } } var z = {}; m.j.register = function (G, N) { if (!N) throw Error("Invalid configuration for " + G); if (m.j.tb(G)) throw Error("Component " + G + " is already registered"); z[G] = N }, m.j.tb = function (G) { return Object.prototype.hasOwnProperty.call(z, G) }, m.j.unregister = function (G) { delete z[G], m.j.Bc(G) }, m.j.Fc = { getConfig: function (G, N) { N(m.j.tb(G) ? z[G] : null) }, loadComponent: function (G, N, X) { var q = V(G); O(q, N, function (J) { _(G, q, J, X) }) }, loadTemplate: function (G, N, X) { if (G = V(G), typeof N == "string") X(m.a.ua(N)); else if (N instanceof Array) X(N); else if (v(N)) X(m.a.la(N.childNodes)); else if (N.element) if (N = N.element, t.HTMLElement ? N instanceof HTMLElement : N && N.tagName && N.nodeType === 1) X(w(N)); else if (typeof N == "string") { var q = n.getElementById(N); q ? X(w(q)) : G("Cannot find element with ID " + N) } else G("Unknown element type: " + N); else G("Unknown template value: " + N) }, loadViewModel: function (G, N, X) { E(V(G), N, X) } }; var k = "createViewModel"; m.b("components.register", m.j.register), m.b("components.isRegistered", m.j.tb), m.b("components.unregister", m.j.unregister), m.b("components.defaultLoader", m.j.Fc), m.j.loaders.push(m.j.Fc), m.j.dd = z }(), function () { function _(w, v) { var O = w.getAttribute("params"); if (O) { var O = E.parseBindingsString(O, v, w, { valueAccessors: !0, bindingParams: !0 }), O = m.a.Ga(O, function (k) { return m.o(k, null, { l: w }) }), V = m.a.Ga(O, function (k) { var G = k.v(); return k.ja() ? m.o({ read: function () { return m.a.f(k()) }, write: m.Za(G) && function (N) { k()(N) }, l: w }) : G }); return Object.prototype.hasOwnProperty.call(V, "$raw") || (V.$raw = O), V } return { $raw: {} } } m.j.getComponentNameForNode = function (w) { var v = m.a.R(w); if (m.j.tb(v) && (v.indexOf("-") != -1 || "" + w == "[object HTMLUnknownElement]" || 8 >= m.a.W && w.tagName === v)) return v }, m.j.tc = function (w, v, O, V) { if (v.nodeType === 1) { var z = m.j.getComponentNameForNode(v); if (z) { if (w = w || {}, w.component) throw Error('Cannot use the "component" binding on a custom element matching a component'); var k = { name: z, params: _(v, O) }; w.component = V ? function () { return k } : k } } return w }; var E = new m.ga; 9 > m.a.W && (m.j.register = function (w) { return function (v) { return w.apply(this, arguments) } }(m.j.register), n.createDocumentFragment = function (w) { return function () { var v = w(), O = m.j.dd, V; for (V in O); return v } }(n.createDocumentFragment)) }(), function () { function _(v, O, V) { if (O = O.template, !O) throw Error("Component '" + v + "' has no template"); v = m.a.Ca(O), m.h.va(V, v) } function E(v, O, V) { var z = v.createViewModel; return z ? z.call(v, O, V) : O } var w = 0; m.c.component = { init: function (v, O, V, z, k) { function G() { var W = N && N.dispose; typeof W == "function" && W.call(N), q && q.s(), X = N = q = null } var N, X, q, J = m.a.la(m.h.childNodes(v)); return m.h.Ea(v), m.a.K.za(v, G), m.o(function () { var W = m.a.f(O()), K, Z; if (typeof W == "string" ? K = W : (K = m.a.f(W.name), Z = m.a.f(W.params)), !K) throw Error("No component name specified"); var de = m.i.Cb(v, k), pe = X = ++w; m.j.get(K, function (oe) { if (X === pe) { if (G(), !oe) throw Error("Unknown component '" + K + "'"); _(K, oe, v); var ue = E(oe, Z, { element: v, templateNodes: J }); oe = de.createChildContext(ue, { extend: function (ge) { ge.$component = ue, ge.$componentTemplateNodes = J } }), ue && ue.koDescendantsComplete && (q = m.i.subscribe(v, m.i.pa, ue.koDescendantsComplete, ue)), N = ue, m.Oa(oe, v) } }) }, null, { l: v }), { controlsDescendantBindings: !0 } } }, m.h.ea.component = !0 }(); var M = { class: "className", for: "htmlFor" }; m.c.attr = { update: function (_, E) { var w = m.a.f(E()) || {}; m.a.P(w, function (v, O) { O = m.a.f(O); var V = v.indexOf(":"), V = "lookupNamespaceURI" in _ && 0 < V && _.lookupNamespaceURI(v.substr(0, V)), z = O === !1 || O === null || O === e; z ? V ? _.removeAttributeNS(V, v) : _.removeAttribute(v) : O = O.toString(), 8 >= m.a.W && v in M ? (v = M[v], z ? _.removeAttribute(v) : _[v] = O) : z || (V ? _.setAttributeNS(V, v, O) : _.setAttribute(v, O)), v === "name" && m.a.Yc(_, z ? "" : O) }) } }, function () { m.c.checked = { after: ["value", "attr"], init: function (_, E, w) { function v() { var W = _.checked, K = V(); if (!m.S.Ya() && (W || !k && !m.S.qa())) { var Z = m.u.G(E); if (N) { var de = X ? Z.v() : Z, pe = J; J = K, pe !== K ? W && (m.a.Na(de, K, !0), m.a.Na(de, pe, !1)) : m.a.Na(de, K, W), X && m.Za(Z) && Z(de) } else z && (K === e ? K = W : W || (K = e)), m.m.eb(Z, w, "checked", K, !0) } } function O() { var W = m.a.f(E()), K = V(); N ? (_.checked = 0 <= m.a.A(W, K), J = K) : _.checked = z && K === e ? !!W : V() === W } var V = m.xb(function () { if (w.has("checkedValue")) return m.a.f(w.get("checkedValue")); if (q) return w.has("value") ? m.a.f(w.get("value")) : _.value }), z = _.type == "checkbox", k = _.type == "radio"; if (z || k) { var G = E(), N = z && m.a.f(G) instanceof Array, X = !(N && G.push && G.splice), q = k || N, J = N ? V() : e; k && !_.name && m.c.uniqueName.init(_, function () { return !0 }), m.o(v, null, { l: _ }), m.a.B(_, "click", v), m.o(O, null, { l: _ }), G = e } } }, m.m.wa.checked = !0, m.c.checkedValue = { update: function (_, E) { _.value = m.a.f(E()) } } }(), m.c.class = { update: function (_, E) { var w = m.a.Db(m.a.f(E())); m.a.Eb(_, _.__ko__cssValue, !1), _.__ko__cssValue = w, m.a.Eb(_, w, !0) } }, m.c.css = { update: function (_, E) { var w = m.a.f(E()); w !== null && typeof w == "object" ? m.a.P(w, function (v, O) { O = m.a.f(O), m.a.Eb(_, v, O) }) : m.c.class.update(_, E) } }, m.c.enable = { update: function (_, E) { var w = m.a.f(E()); w && _.disabled ? _.removeAttribute("disabled") : w || _.disabled || (_.disabled = !0) } }, m.c.disable = { update: function (_, E) { m.c.enable.update(_, function () { return !m.a.f(E()) }) } }, m.c.event = { init: function (_, E, w, v, O) { var V = E() || {}; m.a.P(V, function (z) { typeof z == "string" && m.a.B(_, z, function (k) { var G, N = E()[z]; if (N) { try { var X = m.a.la(arguments); v = O.$data, X.unshift(v), G = N.apply(v, X) } finally { G !== !0 && (k.preventDefault ? k.preventDefault() : k.returnValue = !1) } w.get(z + "Bubble") === !1 && (k.cancelBubble = !0, k.stopPropagation && k.stopPropagation()) } }) }) } }, m.c.foreach = { Rc: function (_) { return function () { var E = _(), w = m.a.bc(E); return !w || typeof w.length == "number" ? { foreach: E, templateEngine: m.ba.Ma } : (m.a.f(E), { foreach: w.data, as: w.as, noChildContext: w.noChildContext, includeDestroyed: w.includeDestroyed, afterAdd: w.afterAdd, beforeRemove: w.beforeRemove, afterRender: w.afterRender, beforeMove: w.beforeMove, afterMove: w.afterMove, templateEngine: m.ba.Ma }) } }, init: function (_, E) { return m.c.template.init(_, m.c.foreach.Rc(E)) }, update: function (_, E, w, v, O) { return m.c.template.update(_, m.c.foreach.Rc(E), w, v, O) } }, m.m.Ra.foreach = !1, m.h.ea.foreach = !0, m.c.hasfocus = { init: function (_, E, w) { function v(z) { _.__ko_hasfocusUpdating = !0; var k = _.ownerDocument; if ("activeElement" in k) { var G; try { G = k.activeElement } catch { G = k.body } z = G === _ } k = E(), m.m.eb(k, w, "hasfocus", z, !0), _.__ko_hasfocusLastValue = z, _.__ko_hasfocusUpdating = !1 } var O = v.bind(null, !0), V = v.bind(null, !1); m.a.B(_, "focus", O), m.a.B(_, "focusin", O), m.a.B(_, "blur", V), m.a.B(_, "focusout", V), _.__ko_hasfocusLastValue = !1 }, update: function (_, E) { var w = !!m.a.f(E()); _.__ko_hasfocusUpdating || _.__ko_hasfocusLastValue === w || (w ? _.focus() : _.blur(), !w && _.__ko_hasfocusLastValue && _.ownerDocument.body.focus(), m.u.G(m.a.Fb, null, [_, w ? "focusin" : "focusout"])) } }, m.m.wa.hasfocus = !0, m.c.hasFocus = m.c.hasfocus, m.m.wa.hasFocus = "hasfocus", m.c.html = { init: function () { return { controlsDescendantBindings: !0 } }, update: function (_, E) { m.a.fc(_, E()) } }, function () { function _(E, w, v) { m.c[E] = { init: function (O, V, z, k, G) { var N, X, q = {}, J, W, K; if (w) { k = z.get("as"); var Z = z.get("noChildContext"); K = !(k && Z), q = { as: k, noChildContext: Z, exportDependencies: K } } return W = (J = z.get("completeOn") == "render") || z.has(m.i.pa), m.o(function () { var de = m.a.f(V()), pe = !v != !de, oe = !X, ue; (K || pe !== N) && (W && (G = m.i.Cb(O, G)), pe && ((!w || K) && (q.dataDependency = m.S.o()), ue = w ? G.createChildContext(typeof de == "function" ? de : V, q) : m.S.qa() ? G.extend(null, q) : G), oe && m.S.qa() && (X = m.a.Ca(m.h.childNodes(O), !0)), pe ? (oe || m.h.va(O, m.a.Ca(X)), m.Oa(ue, O)) : (m.h.Ea(O), J || m.i.ma(O, m.i.H)), N = pe) }, null, { l: O }), { controlsDescendantBindings: !0 } } }, m.m.Ra[E] = !1, m.h.ea[E] = !0 } _("if"), _("ifnot", !1, !0), _("with", !0) }(), m.c.let = { init: function (_, E, w, v, O) { return E = O.extend(E), m.Oa(E, _), { controlsDescendantBindings: !0 } } }, m.h.ea.let = !0; var L = {}; m.c.options = { init: function (_) { if (m.a.R(_) !== "select") throw Error("options binding applies only to SELECT elements"); for (; 0 < _.length;)_.remove(0); return { controlsDescendantBindings: !0 } }, update: function (_, E, w) { function v() { return m.a.jb(_.options, function (Z) { return Z.selected }) } function O(Z, de, pe) { var oe = typeof de; return oe == "function" ? de(Z) : oe == "string" ? Z[de] : pe } function V(Z, de) { if (W && N) m.i.ma(_, m.i.H); else if (J.length) { var pe = 0 <= m.a.A(J, m.w.M(de[0])); m.a.Zc(de[0], pe), W && !pe && m.u.G(m.a.Fb, null, [_, "change"]) } } var z = _.multiple, k = _.length != 0 && z ? _.scrollTop : null, G = m.a.f(E()), N = w.get("valueAllowUnset") && w.has("value"), X = w.get("optionsIncludeDestroyed"); E = {}; var q, J = []; N || (z ? J = m.a.Mb(v(), m.w.M) : 0 <= _.selectedIndex && J.push(m.w.M(_.options[_.selectedIndex]))), G && (typeof G.length > "u" && (G = [G]), q = m.a.jb(G, function (Z) { return X || Z === e || Z === null || !m.a.f(Z._destroy) }), w.has("optionsCaption") && (G = m.a.f(w.get("optionsCaption")), G !== null && G !== e && q.unshift(L))); var W = !1; if (E.beforeRemove = function (Z) { _.removeChild(Z) }, G = V, w.has("optionsAfterRender") && typeof w.get("optionsAfterRender") == "function" && (G = function (Z, de) { V(0, de), m.u.G(w.get("optionsAfterRender"), null, [de[0], Z !== L ? Z : e]) }), m.a.ec(_, q, function (Z, de, pe) { return pe.length && (J = !N && pe[0].selected ? [m.w.M(pe[0])] : [], W = !0), de = _.ownerDocument.createElement("option"), Z === L ? (m.a.Bb(de, w.get("optionsCaption")), m.w.cb(de, e)) : (pe = O(Z, w.get("optionsValue"), Z), m.w.cb(de, m.a.f(pe)), Z = O(Z, w.get("optionsText"), pe), m.a.Bb(de, Z)), [de] }, E, G), !N) { var K; z ? K = J.length && v().length < J.length : K = J.length && 0 <= _.selectedIndex ? m.w.M(_.options[_.selectedIndex]) !== J[0] : J.length || 0 <= _.selectedIndex, K && m.u.G(m.a.Fb, null, [_, "change"]) } (N || m.S.Ya()) && m.i.ma(_, m.i.H), m.a.wd(_), k && 20 < Math.abs(k - _.scrollTop) && (_.scrollTop = k) } }, m.c.options.$b = m.a.g.Z(), m.c.selectedOptions = { init: function (_, E, w) { function v() { var z = E(), k = []; m.a.D(_.getElementsByTagName("option"), function (G) { G.selected && k.push(m.w.M(G)) }), m.m.eb(z, w, "selectedOptions", k) } function O() { var z = m.a.f(E()), k = _.scrollTop; z && typeof z.length == "number" && m.a.D(_.getElementsByTagName("option"), function (G) { var N = 0 <= m.a.A(z, m.w.M(G)); G.selected != N && m.a.Zc(G, N) }), _.scrollTop = k } if (m.a.R(_) != "select") throw Error("selectedOptions binding applies only to SELECT elements"); var V; m.i.subscribe(_, m.i.H, function () { V ? v() : (m.a.B(_, "change", v), V = m.o(O, null, { l: _ })) }, null, { notifyImmediately: !0 }) }, update: function () { } }, m.m.wa.selectedOptions = !0, m.c.style = { update: function (_, E) { var w = m.a.f(E() || {}); m.a.P(w, function (v, O) { if (O = m.a.f(O), (O === null || O === e || O === !1) && (O = ""), o) o(_).css(v, O); else if (/^--/.test(v)) _.style.setProperty(v, O); else { v = v.replace(/-(\w)/g, function (z, k) { return k.toUpperCase() }); var V = _.style[v]; _.style[v] = O, O === V || _.style[v] != V || isNaN(O) || (_.style[v] = O + "px") } }) } }, m.c.submit = { init: function (_, E, w, v, O) { if (typeof E() != "function") throw Error("The value for a submit binding must be a function"); m.a.B(_, "submit", function (V) { var z, k = E(); try { z = k.call(O.$data, _) } finally { z !== !0 && (V.preventDefault ? V.preventDefault() : V.returnValue = !1) } }) } }, m.c.text = { init: function () { return { controlsDescendantBindings: !0 } }, update: function (_, E) { m.a.Bb(_, E()) } }, m.h.ea.text = !0, function () { if (t && t.navigator) { var _ = function (q) { if (q) return parseFloat(q[1]) }, E = t.navigator.userAgent, w, v, O, V, z; (w = t.opera && t.opera.version && parseInt(t.opera.version())) || (z = _(E.match(/Edge\/([^ ]+)$/))) || _(E.match(/Chrome\/([^ ]+)/)) || (v = _(E.match(/Version\/([^ ]+) Safari/))) || (O = _(E.match(/Firefox\/([^ ]+)/))) || (V = m.a.W || _(E.match(/MSIE ([^ ]+)/))) || (V = _(E.match(/rv:([^ )]+)/))) } if (8 <= V && 10 > V) var k = m.a.g.Z(), G = m.a.g.Z(), N = function (q) { var J = this.activeElement; (J = J && m.a.g.get(J, G)) && J(q) }, X = function (q, J) { var W = q.ownerDocument; m.a.g.get(W, k) || (m.a.g.set(W, k, !0), m.a.B(W, "selectionchange", N)), m.a.g.set(q, G, J) }; m.c.textInput = { init: function (q, J, W) { function K(Fe, We) { m.a.B(q, Fe, We) } function Z() { var Fe = m.a.f(J()); (Fe === null || Fe === e) && (Fe = ""), ge !== e && Fe === ge ? m.a.setTimeout(Z, 4) : q.value !== Fe && (Ie = !0, q.value = Fe, Ie = !1, oe = q.value) } function de() { ue || (ge = q.value, ue = m.a.setTimeout(pe, 4)) } function pe() { clearTimeout(ue), ge = ue = e; var Fe = q.value; oe !== Fe && (oe = Fe, m.m.eb(J(), W, "textInput", Fe)) } var oe = q.value, ue, ge, Ee = m.a.W == 9 ? de : pe, Ie = !1; V && K("keypress", pe), 11 > V && K("propertychange", function (Fe) { Ie || Fe.propertyName !== "value" || Ee(Fe) }), V == 8 && (K("keyup", pe), K("keydown", pe)), X && (X(q, Ee), K("dragend", de)), (!V || 9 <= V) && K("input", Ee), 5 > v && m.a.R(q) === "textarea" ? (K("keydown", de), K("paste", de), K("cut", de)) : 11 > w ? K("keydown", de) : 4 > O ? (K("DOMAutoComplete", pe), K("dragdrop", pe), K("drop", pe)) : z && q.type === "number" && K("keydown", de), K("change", pe), K("blur", pe), m.o(Z, null, { l: q }) } }, m.m.wa.textInput = !0, m.c.textinput = { preprocess: function (q, J, W) { W("textInput", q) } } }(), m.c.uniqueName = { init: function (_, E) { if (E()) { var w = "ko_unique_" + ++m.c.uniqueName.rd; m.a.Yc(_, w) } } }, m.c.uniqueName.rd = 0, m.c.using = { init: function (_, E, w, v, O) { var V; return w.has("as") && (V = { as: w.get("as"), noChildContext: w.get("noChildContext") }), E = O.createChildContext(E, V), m.Oa(E, _), { controlsDescendantBindings: !0 } } }, m.h.ea.using = !0, m.c.value = { init: function (_, E, w) { var v = m.a.R(_), O = v == "input"; if (!O || _.type != "checkbox" && _.type != "radio") { var V = [], z = w.get("valueUpdate"), k = !1, G = null; z && (typeof z == "string" ? V = [z] : V = m.a.wc(z), m.a.Pa(V, "change")); var N = function () { G = null, k = !1; var J = E(), W = m.w.M(_); m.m.eb(J, w, "value", W) }; !m.a.W || !O || _.type != "text" || _.autocomplete == "off" || _.form && _.form.autocomplete == "off" || m.a.A(V, "propertychange") != -1 || (m.a.B(_, "propertychange", function () { k = !0 }), m.a.B(_, "focus", function () { k = !1 }), m.a.B(_, "blur", function () { k && N() })), m.a.D(V, function (J) { var W = N; m.a.Ud(J, "after") && (W = function () { G = m.w.M(_), m.a.setTimeout(N, 0) }, J = J.substring(5)), m.a.B(_, J, W) }); var X; if (X = O && _.type == "file" ? function () { var J = m.a.f(E()); J === null || J === e || J === "" ? _.value = "" : m.u.G(N) } : function () { var J = m.a.f(E()), W = m.w.M(_); G !== null && J === G ? m.a.setTimeout(X, 0) : (J !== W || W === e) && (v === "select" ? (W = w.get("valueAllowUnset"), m.w.cb(_, J, W), W || J === m.w.M(_) || m.u.G(N)) : m.w.cb(_, J)) }, v === "select") { var q; m.i.subscribe(_, m.i.H, function () { q ? w.get("valueAllowUnset") ? X() : N() : (m.a.B(_, "change", N), q = m.o(X, null, { l: _ })) }, null, { notifyImmediately: !0 }) } else m.a.B(_, "change", N), m.o(X, null, { l: _ }) } else m.ib(_, { checkedValue: E }) }, update: function () { } }, m.m.wa.value = !0, m.c.visible = { update: function (_, E) { var w = m.a.f(E()), v = _.style.display != "none"; w && !v ? _.style.display = "" : !w && v && (_.style.display = "none") } }, m.c.hidden = { update: function (_, E) { m.c.visible.update(_, function () { return !m.a.f(E()) }) } }, function (_) { m.c[_] = { init: function (E, w, v, O, V) { return m.c.event.init.call(this, E, function () { var z = {}; return z[_] = w(), z }, v, O, V) } } }("click"), m.ca = function () { }, m.ca.prototype.renderTemplateSource = function () { throw Error("Override renderTemplateSource") }, m.ca.prototype.createJavaScriptEvaluatorBlock = function () { throw Error("Override createJavaScriptEvaluatorBlock") }, m.ca.prototype.makeTemplateSource = function (_, E) { if (typeof _ == "string") { E = E || n; var w = E.getElementById(_); if (!w) throw Error("Cannot find template with ID " + _); return new m.C.F(w) } if (_.nodeType == 1 || _.nodeType == 8) return new m.C.ia(_); throw Error("Unknown template type: " + _) }, m.ca.prototype.renderTemplate = function (_, E, w, v) { return _ = this.makeTemplateSource(_, v), this.renderTemplateSource(_, E, w, v) }, m.ca.prototype.isTemplateRewritten = function (_, E) { return this.allowTemplateRewriting === !1 ? !0 : this.makeTemplateSource(_, E).data("isRewritten") }, m.ca.prototype.rewriteTemplate = function (_, E, w) { _ = this.makeTemplateSource(_, w), E = E(_.text()), _.text(E), _.data("isRewritten", !0) }, m.b("templateEngine", m.ca), m.kc = function () { function _(v, O, V, z) { v = m.m.ac(v); for (var k = m.m.Ra, G = 0; G < v.length; G++) { var N = v[G].key; if (Object.prototype.hasOwnProperty.call(k, N)) { var X = k[N]; if (typeof X == "function") { if (N = X(v[G].value)) throw Error(N) } else if (!X) throw Error("This template engine does not support the '" + N + "' binding within its templates") } } return V = "ko.__tr_ambtns(function($context,$element){return(function(){return{ " + m.m.vb(v, { valueAccessors: !0 }) + " } })()},'" + V.toLowerCase() + "')", z.createJavaScriptEvaluatorBlock(V) + O } var E = /(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi, w = /\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g; return { xd: function (v, O, V) { O.isTemplateRewritten(v, V) || O.rewriteTemplate(v, function (z) { return m.kc.Ld(z, O) }, V) }, Ld: function (v, O) { return v.replace(E, function (V, z, k, G, N) { return _(N, z, k, O) }).replace(w, function (V, z) { return _(z, "<!-- ko -->", "#comment", O) }) }, md: function (v, O) { return m.aa.Xb(function (V, z) { var k = V.nextSibling; k && k.nodeName.toLowerCase() === O && m.ib(k, v, z) }) } } }(), m.b("__tr_ambtns", m.kc.md), function () { m.C = {}, m.C.F = function (w) { if (this.F = w) { var v = m.a.R(w); this.ab = v === "script" ? 1 : v === "textarea" ? 2 : v == "template" && w.content && w.content.nodeType === 11 ? 3 : 4 } }, m.C.F.prototype.text = function () { var w = this.ab === 1 ? "text" : this.ab === 2 ? "value" : "innerHTML"; if (arguments.length == 0) return this.F[w]; var v = arguments[0]; w === "innerHTML" ? m.a.fc(this.F, v) : this.F[w] = v }; var _ = m.a.g.Z() + "_"; m.C.F.prototype.data = function (w) { if (arguments.length === 1) return m.a.g.get(this.F, _ + w); m.a.g.set(this.F, _ + w, arguments[1]) }; var E = m.a.g.Z(); m.C.F.prototype.nodes = function () { var w = this.F; if (arguments.length == 0) { var v = m.a.g.get(w, E) || {}, O = v.lb || (this.ab === 3 ? w.content : this.ab === 4 ? w : e); if (!O || v.jd) { var V = this.text(); V && V !== v.bb && (O = m.a.Md(V, w.ownerDocument), m.a.g.set(w, E, { lb: O, bb: V, jd: !0 })) } return O } v = arguments[0], this.ab !== e && this.text(""), m.a.g.set(w, E, { lb: v }) }, m.C.ia = function (w) { this.F = w }, m.C.ia.prototype = new m.C.F, m.C.ia.prototype.constructor = m.C.ia, m.C.ia.prototype.text = function () { if (arguments.length == 0) { var w = m.a.g.get(this.F, E) || {}; return w.bb === e && w.lb && (w.bb = w.lb.innerHTML), w.bb } m.a.g.set(this.F, E, { bb: arguments[0] }) }, m.b("templateSources", m.C), m.b("templateSources.domElement", m.C.F), m.b("templateSources.anonymousTemplate", m.C.ia) }(), function () { function _(G, N, X) { var q; for (N = m.h.nextSibling(N); G && (q = G) !== N;)G = m.h.nextSibling(q), X(q, G) } function E(G, N) { if (G.length) { var X = G[0], q = G[G.length - 1], J = X.parentNode, W = m.ga.instance, K = W.preprocessNode; if (K) { if (_(X, q, function (Z, de) { var pe = Z.previousSibling, oe = K.call(W, Z); oe && (Z === X && (X = oe[0] || de), Z === q && (q = oe[oe.length - 1] || pe)) }), G.length = 0, !X) return; X === q ? G.push(X) : (G.push(X, q), m.a.Ua(G, J)) } _(X, q, function (Z) { Z.nodeType !== 1 && Z.nodeType !== 8 || m.vc(N, Z) }), _(X, q, function (Z) { Z.nodeType !== 1 && Z.nodeType !== 8 || m.aa.cd(Z, [N]) }), m.a.Ua(G, J) } } function w(G) { return G.nodeType ? G : 0 < G.length ? G[0] : null } function v(G, N, X, q, J) { J = J || {}; var W = (G && w(G) || X || {}).ownerDocument, K = J.templateEngine || V; if (m.kc.xd(X, K, W), X = K.renderTemplate(X, q, J, W), typeof X.length != "number" || 0 < X.length && typeof X[0].nodeType != "number") throw Error("Template engine must return an array of DOM nodes"); switch (W = !1, N) { case "replaceChildren": m.h.va(G, X), W = !0; break; case "replaceNode": m.a.Xc(G, X), W = !0; break; case "ignoreTargetNode": break; default: throw Error("Unknown renderMode: " + N) }return W && (E(X, q), J.afterRender && m.u.G(J.afterRender, null, [X, q[J.as || "$data"]]), N == "replaceChildren" && m.i.ma(G, m.i.H)), X } function O(G, N, X) { return m.O(G) ? G() : typeof G == "function" ? G(N, X) : G } var V; m.gc = function (G) { if (G != e && !(G instanceof m.ca)) throw Error("templateEngine must inherit from ko.templateEngine"); V = G }, m.dc = function (G, N, X, q, J) { if (X = X || {}, (X.templateEngine || V) == e) throw Error("Set a template engine before calling renderTemplate"); if (J = J || "replaceChildren", q) { var W = w(q); return m.$(function () { var Z = N && N instanceof m.fa ? N : new m.fa(N, null, null, null, { exportDependencies: !0 }), K = O(G, Z.$data, Z), Z = v(q, J, K, Z, X); J == "replaceNode" && (q = Z, W = w(q)) }, null, { Sa: function () { return !W || !m.a.Sb(W) }, l: W && J == "replaceNode" ? W.parentNode : W }) } return m.aa.Xb(function (K) { m.dc(G, N, X, K, "replaceNode") }) }, m.Qd = function (G, N, X, q, J) { function W(ge, Ee) { m.u.G(m.a.ec, null, [q, ge, Z, X, K, Ee]), m.i.ma(q, m.i.H) } function K(ge, Ee) { E(Ee, de), X.afterRender && X.afterRender(Ee, ge), de = null } function Z(ge, Ee) { de = J.createChildContext(ge, { as: pe, noChildContext: X.noChildContext, extend: function (Fe) { Fe.$index = Ee, pe && (Fe[pe + "Index"] = Ee) } }); var Ie = O(G, ge, de); return v(q, "ignoreTargetNode", Ie, de, X) } var de, pe = X.as, oe = X.includeDestroyed === !1 || m.options.foreachHidesDestroyed && !X.includeDestroyed; if (oe || X.beforeRemove || !m.Pc(N)) return m.$(function () { var ge = m.a.f(N) || []; typeof ge.length > "u" && (ge = [ge]), oe && (ge = m.a.jb(ge, function (Ee) { return Ee === e || Ee === null || !m.a.f(Ee._destroy) })), W(ge) }, null, { l: q }); W(N.v()); var ue = N.subscribe(function (ge) { W(N(), ge) }, null, "arrayChange"); return ue.l(q), ue }; var z = m.a.g.Z(), k = m.a.g.Z(); m.c.template = { init: function (G, N) { var X = m.a.f(N()); if (typeof X == "string" || "name" in X) m.h.Ea(G); else if ("nodes" in X) { if (X = X.nodes || [], m.O(X)) throw Error('The "nodes" option must be a plain, non-observable array.'); var q = X[0] && X[0].parentNode; q && m.a.g.get(q, k) || (q = m.a.Yb(X), m.a.g.set(q, k, !0)), new m.C.ia(G).nodes(q) } else if (X = m.h.childNodes(G), 0 < X.length) q = m.a.Yb(X), new m.C.ia(G).nodes(q); else throw Error("Anonymous template defined, but no template content was provided"); return { controlsDescendantBindings: !0 } }, update: function (G, N, X, q, J) { var W = N(); N = m.a.f(W), X = !0, q = null, typeof N == "string" ? N = {} : (W = "name" in N ? N.name : G, "if" in N && (X = m.a.f(N.if)), X && "ifnot" in N && (X = !m.a.f(N.ifnot)), X && !W && (X = !1)), "foreach" in N ? q = m.Qd(W, X && N.foreach || [], N, G, J) : X ? (X = J, "data" in N && (X = J.createChildContext(N.data, { as: N.as, noChildContext: N.noChildContext, exportDependencies: !0 })), q = m.dc(W, X, N, G)) : m.h.Ea(G), J = q, (N = m.a.g.get(G, z)) && typeof N.s == "function" && N.s(), m.a.g.set(G, z, !J || J.ja && !J.ja() ? e : J) } }, m.m.Ra.template = function (G) { return G = m.m.ac(G), G.length == 1 && G[0].unknown || m.m.Id(G, "name") ? null : "This template engine does not support anonymous templates nested within its templates" }, m.h.ea.template = !0 }(), m.b("setTemplateEngine", m.gc), m.b("renderTemplate", m.dc), m.a.Kc = function (_, E, w) { if (_.length && E.length) { var v, O, V, z, k; for (v = O = 0; (!w || v < w) && (z = _[O]); ++O) { for (V = 0; k = E[V]; ++V)if (z.value === k.value) { z.moved = k.index, k.moved = z.index, E.splice(V, 1), v = V = 0; break } v += V } } }, m.a.Pb = function () { function _(E, w, v, O, V) { var z = Math.min, k = Math.max, G = [], N, X = E.length, q, J = w.length, W = J - X || 1, K = X + J + 1, Z, de, pe; for (N = 0; N <= X; N++)for (de = Z, G.push(Z = []), pe = z(J, N + W), q = k(0, N - 1); q <= pe; q++)Z[q] = q ? N ? E[N - 1] === w[q - 1] ? de[q - 1] : z(de[q] || K, Z[q - 1] || K) + 1 : q + 1 : N + 1; for (z = [], k = [], W = [], N = X, q = J; N || q;)J = G[N][q] - 1, q && J === G[N][q - 1] ? k.push(z[z.length] = { status: v, value: w[--q], index: q }) : N && J === G[N - 1][q] ? W.push(z[z.length] = { status: O, value: E[--N], index: N }) : (--q, --N, V.sparse || z.push({ status: "retained", value: w[q] })); return m.a.Kc(W, k, !V.dontLimitMoves && 10 * X), z.reverse() } return function (E, w, v) { return v = typeof v == "boolean" ? { dontLimitMoves: v } : v || {}, E = E || [], w = w || [], E.length < w.length ? _(E, w, "added", "deleted", v) : _(w, E, "deleted", "added", v) } }(), m.b("utils.compareArrays", m.a.Pb), function () { function _(v, O, V, z, k) { var G = [], N = m.$(function () { var X = O(V, k, m.a.Ua(G, v)) || []; 0 < G.length && (m.a.Xc(G, X), z && m.u.G(z, null, [V, X, k])), G.length = 0, m.a.Nb(G, X) }, null, { l: v, Sa: function () { return !m.a.kd(G) } }); return { Y: G, $: N.ja() ? N : e } } var E = m.a.g.Z(), w = m.a.g.Z(); m.a.ec = function (v, O, V, z, k, G) { function N(at) { Ie = { Aa: at, pb: m.ta(de++) }, K.push(Ie), W || Ee.push(Ie) } function X(at) { Ie = J[at], de !== Ie.pb.v() && ge.push(Ie), Ie.pb(de++), m.a.Ua(Ie.Y, v), K.push(Ie) } function q(at, Ne) { if (at) for (var nt = 0, Ce = Ne.length; nt < Ce; nt++)m.a.D(Ne[nt].Y, function (je) { at(je, nt, Ne[nt].Aa) }) } O = O || [], typeof O.length > "u" && (O = [O]), z = z || {}; var J = m.a.g.get(v, E), W = !J, K = [], Z = 0, de = 0, pe = [], oe = [], ue = [], ge = [], Ee = [], Ie, Fe = 0; if (W) m.a.D(O, N); else { if (!G || J && J._countWaitingForRemove) { var We = m.a.Mb(J, function (at) { return at.Aa }); G = m.a.Pb(We, O, { dontLimitMoves: z.dontLimitMoves, sparse: !0 }) } for (var We = 0, Lt, Gt, cn; Lt = G[We]; We++)switch (Gt = Lt.moved, cn = Lt.index, Lt.status) { case "deleted": for (; Z < cn;)X(Z++); Gt === e && (Ie = J[Z], Ie.$ && (Ie.$.s(), Ie.$ = e), m.a.Ua(Ie.Y, v).length && (z.beforeRemove && (K.push(Ie), Fe++, Ie.Aa === w ? Ie = null : ue.push(Ie)), Ie && pe.push.apply(pe, Ie.Y))), Z++; break; case "added": for (; de < cn;)X(Z++); Gt !== e ? (oe.push(K.length), X(Gt)) : N(Lt.value) }for (; de < O.length;)X(Z++); K._countWaitingForRemove = Fe } m.a.g.set(v, E, K), q(z.beforeMove, ge), m.a.D(pe, z.beforeRemove ? m.oa : m.removeNode); var _t, Pn, Jn; try { Jn = v.ownerDocument.activeElement } catch { } if (oe.length) for (; (We = oe.shift()) != e;) { for (Ie = K[We], _t = e; We;)if ((Pn = K[--We].Y) && Pn.length) { _t = Pn[Pn.length - 1]; break } for (O = 0; Z = Ie.Y[O]; _t = Z, O++)m.h.Wb(v, Z, _t) } for (We = 0; Ie = K[We]; We++) { for (Ie.Y || m.a.extend(Ie, _(v, V, Ie.Aa, k, Ie.pb)), O = 0; Z = Ie.Y[O]; _t = Z, O++)m.h.Wb(v, Z, _t); !Ie.Ed && k && (k(Ie.Aa, Ie.Y, Ie.pb), Ie.Ed = !0, _t = Ie.Y[Ie.Y.length - 1]) } for (Jn && v.ownerDocument.activeElement != Jn && Jn.focus(), q(z.beforeRemove, ue), We = 0; We < ue.length; ++We)ue[We].Aa = w; q(z.afterMove, ge), q(z.afterAdd, Ee) } }(), m.b("utils.setDomNodeChildrenFromArrayMapping", m.a.ec), m.ba = function () { this.allowTemplateRewriting = !1 }, m.ba.prototype = new m.ca, m.ba.prototype.constructor = m.ba, m.ba.prototype.renderTemplateSource = function (_, E, w, v) { return (E = !(9 > m.a.W) && _.nodes ? _.nodes() : null) ? m.a.la(E.cloneNode(!0).childNodes) : (_ = _.text(), m.a.ua(_, v)) }, m.ba.Ma = new m.ba, m.gc(m.ba.Ma), m.b("nativeTemplateEngine", m.ba), function () { m.$a = function () { var E = this.Hd = function () { if (!o || !o.tmpl) return 0; try { if (0 <= o.tmpl.tag.tmpl.open.toString().indexOf("__")) return 2 } catch { } return 1 }(); this.renderTemplateSource = function (w, v, O, V) { if (V = V || n, O = O || {}, 2 > E) throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later."); var z = w.data("precompiled"); return z || (z = w.text() || "", z = o.template(null, "{{ko_with $item.koBindingContext}}" + z + "{{/ko_with}}"), w.data("precompiled", z)), w = [v.$data], v = o.extend({ koBindingContext: v }, O.templateOptions), v = o.tmpl(z, w, v), v.appendTo(V.createElement("div")), o.fragments = {}, v }, this.createJavaScriptEvaluatorBlock = function (w) { return "{{ko_code ((function() { return " + w + " })()) }}" }, this.addTemplate = function (w, v) { n.write("<script type='text/html' id='" + w + "'>" + v + "<\/script>") }, 0 < E && (o.tmpl.tag.ko_code = { open: "__.push($1 || '');" }, o.tmpl.tag.ko_with = { open: "with($1) {", close: "} " }) }, m.$a.prototype = new m.ca, m.$a.prototype.constructor = m.$a; var _ = new m.$a; 0 < _.Hd && m.gc(_), m.b("jqueryTmplTemplateEngine", m.$a) }()
                })
            })()
        })()
    })(); var c$e = ko; typeof window < "u" ? (ko = window.ko, typeof VD < "u" ? window.ko = VD : delete window.ko) : (ko = global.ko, typeof VD < "u" ? global.ko = VD : delete global.ko); var _E = c$e;/**
 * @license
 * Knockout ES5 plugin - https://github.com/SteveSanderson/knockout-es5
 * Copyright (c) Steve Sanderson
 * MIT license
 */var S7 = "__knockoutObservables", w7 = "__knockoutSubscribable"; function qhe(e, t) { if (!e) throw new Error("When calling ko.track, you must pass an object as the first parameter."); var n = this, i = Yhe(e, !0); return t = t || Object.getOwnPropertyNames(e), t.forEach(function (o) { if (!(o === S7 || o === w7) && !(o in i)) { var r = e[o], s = r instanceof Array, a = n.isObservable(r) ? r : s ? n.observableArray(r) : n.observable(r); Object.defineProperty(e, o, { configurable: !0, enumerable: !0, get: a, set: n.isWriteableObservable(a) ? a : void 0 }), i[o] = a, s && u$e(n, a) } }), e } function Yhe(e, t) { var n = e[S7]; return !n && t && (n = {}, Object.defineProperty(e, S7, { value: n })), n } function l$e(e, t, n) { var i = this, o = { owner: e, deferEvaluation: !0 }; if (typeof n == "function") o.read = n; else { if ("value" in n) throw new Error('For ko.defineProperty, you must not specify a "value" for the property. You must provide a "get" function.'); if (typeof n.get != "function") throw new Error('For ko.defineProperty, the third parameter must be either an evaluator function, or an options object containing a function called "get".'); o.read = n.get, o.write = n.set } return e[t] = i.computed(o), qhe.call(i, e, [t]), e } function u$e(e, t) { var n = null; e.computed(function () { n && (n.dispose(), n = null); var i = t(); i instanceof Array && (n = f$e(e, t, i)) }) } function f$e(e, t, n) { var i = d$e(e, n); return i.subscribe(t) } function d$e(e, t) { var n = t[w7]; if (!n) { n = new e.subscribable, Object.defineProperty(t, w7, { value: n }); var i = {}; h$e(t, n, i), m$e(e, t, n, i) } return n } function h$e(e, t, n) { ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"].forEach(function (i) { var o = e[i]; e[i] = function () { var r = o.apply(this, arguments); return n.pause !== !0 && t.notifySubscribers(this), r } }) } function m$e(e, t, n, i) { ["remove", "removeAll", "destroy", "destroyAll", "replace"].forEach(function (o) { Object.defineProperty(t, o, { enumerable: !1, value: function () { var r; i.pause = !0; try { r = e.observableArray.fn[o].apply(e.observableArray(t), arguments) } finally { i.pause = !1 } return n.notifySubscribers(t), r } }) }) } function Xhe(e, t) { if (!e) return null; var n = Yhe(e, !1); return n && n[t] || null } function p$e(e, t) { var n = Xhe(e, t); n && n.valueHasMutated() } function _$e(e) { e.track = qhe, e.getObservable = Xhe, e.valueHasMutated = p$e, e.defineProperty = l$e } var cV = { attachToKo: _$e }; var Khe = "http://www.w3.org/2000/svg", Jhe = "cesium-svgPath-svg", g$e = { register: function (e) { e.bindingHandlers.cesiumSvgPath = { init: function (t, n) { let i = document.createElementNS(Khe, "svg:svg"); i.setAttribute("class", Jhe); let o = document.createElementNS(Khe, "path"); return i.appendChild(o), e.virtualElements.setDomNodeChildren(t, [i]), e.computed({ read: function () { let r = e.unwrap(n()); o.setAttribute("d", e.unwrap(r.path)); let s = e.unwrap(r.width), a = e.unwrap(r.height); i.setAttribute("width", s), i.setAttribute("height", a), i.setAttribute("viewBox", `0 0 ${s} ${a}`), r.css && i.setAttribute("class", `${Jhe} ${e.unwrap(r.css)}`) }, disposeWhenNodeIsRemoved: t }), { controlsDescendantBindings: !0 } } }, e.virtualElements.allowedBindings.cesiumSvgPath = !0 } }, lV = g$e; cV.attachToKo(_E); lV.register(_E); var Ae = _E; function D7(e) { e = y(e, y.EMPTY_OBJECT), this._pixelsToCheck = e.pixelsToCheck, this._missingImagePixels = void 0, this._missingImageByteLength = void 0, this._isReady = !1; let t = Pe.createIfNeeded(e.missingImageUrl), n = this; function i(r) { l(r.blob) && (n._missingImageByteLength = r.blob.size); let s = Ad(r); if (e.disableCheckIfAllPixelsAreTransparent) { let a = !0, c = r.width, u = e.pixelsToCheck; for (let f = 0, d = u.length; a && f < d; ++f) { let p = u[f], g = p.x * 4 + p.y * c; s[g + 3] > 0 && (a = !1) } a && (s = void 0) } n._missingImagePixels = s, n._isReady = !0 } function o() { n._missingImagePixels = void 0, n._isReady = !0 } t.fetchImage({ preferBlob: !0, preferImageBitmap: !0, flipY: !0 }).then(i).catch(o) } D7.prototype.isReady = function () { return this._isReady }; D7.prototype.shouldDiscardImage = function (e) { let t = this._pixelsToCheck, n = this._missingImagePixels; if (!l(n) || l(e.blob) && e.blob.size !== this._missingImageByteLength) return !1; let i = Ad(e), o = e.width; for (let r = 0, s = t.length; r < s; ++r) { let a = t[r], c = a.x * 4 + a.y * o; for (let u = 0; u < 4; ++u) { let f = c + u; if (i[f] !== n[f]) return !1 } } return !0 }; var uV = D7; function v7() { this.name = void 0, this.description = void 0, this.position = void 0, this.data = void 0, this.imageryLayer = void 0 } v7.prototype.configureNameFromProperties = function (e) { let t = 10, n; for (let i in e) if (e.hasOwnProperty(i) && e[i]) { let o = i.toLowerCase(); t > 1 && o === "name" ? (t = 1, n = i) : t > 2 && o === "title" ? (t = 2, n = i) : t > 3 && /name/i.test(i) ? (t = 3, n = i) : t > 4 && /title/i.test(i) && (t = 4, n = i) } l(n) && (this.name = e[n]) }; v7.prototype.configureDescriptionFromProperties = function (e) { function t(n) { let i = '<table class="cesium-infoBox-defaultTable">'; for (let o in n) if (n.hasOwnProperty(o)) { let r = n[o]; l(r) && (typeof r == "object" ? i += `<tr><td>${o}</td><td>${t(r)}</td></tr>` : i += `<tr><td>${o}</td><td>${r}</td></tr>`) } return i += "</table>", i } this.description = t(e) }; var Oh = v7; function gE() { this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0, ye.throwInstantiationError() } Object.defineProperties(gE.prototype, { ready: { get: ye.throwInstantiationError }, readyPromise: { get: ye.throwInstantiationError }, rectangle: { get: ye.throwInstantiationError }, tileWidth: { get: ye.throwInstantiationError }, tileHeight: { get: ye.throwInstantiationError }, maximumLevel: { get: ye.throwInstantiationError }, minimumLevel: { get: ye.throwInstantiationError }, tilingScheme: { get: ye.throwInstantiationError }, tileDiscardPolicy: { get: ye.throwInstantiationError }, errorEvent: { get: ye.throwInstantiationError }, credit: { get: ye.throwInstantiationError }, proxy: { get: ye.throwInstantiationError }, hasAlphaChannel: { get: ye.throwInstantiationError } }); gE.prototype.getTileCredits = function (e, t, n) { ye.throwInstantiationError() }; gE.prototype.requestImage = function (e, t, n, i) { ye.throwInstantiationError() }; gE.prototype.pickFeatures = function (e, t, n, i, o) { ye.throwInstantiationError() }; var y$e = /\.ktx2$/i; gE.loadImage = function (e, t) { let n = Pe.createIfNeeded(t); return y$e.test(n.url) ? ul(n) : l(e) && l(e.tileDiscardPolicy) ? n.fetchImage({ preferBlob: !0, preferImageBitmap: !0, flipY: !0 }) : n.fetchImage({ preferImageBitmap: !0, flipY: !0 }) }; var tl = gE; function kD(e) { e = y(e, y.EMPTY_OBJECT), this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0; let t = Pe.createIfNeeded(e.url); t.appendForwardSlash(), l(e.token) && t.setQueryParameters({ token: e.token }), this._resource = t, this._tileDiscardPolicy = e.tileDiscardPolicy, this._tileWidth = y(e.tileWidth, 256), this._tileHeight = y(e.tileHeight, 256), this._maximumLevel = e.maximumLevel, this._tilingScheme = y(e.tilingScheme, new Hi({ ellipsoid: e.ellipsoid })), this._useTiles = y(e.usePreCachedTilesIfAvailable, !0), this._rectangle = y(e.rectangle, this._tilingScheme.rectangle), this._layers = e.layers; let n = e.credit; typeof n == "string" && (n = new Xt(n)), this._credit = n, this.enablePickFeatures = y(e.enablePickFeatures, !0), this._errorEvent = new _e, this._ready = !1; let i = this, o; function r(c) { let u = c.tileInfo; if (!l(u)) i._useTiles = !1; else { if (i._tileWidth = u.rows, i._tileHeight = u.cols, u.spatialReference.wkid === 102100 || u.spatialReference.wkid === 102113) i._tilingScheme = new Gr({ ellipsoid: e.ellipsoid }); else if (c.tileInfo.spatialReference.wkid === 4326) i._tilingScheme = new Hi({ ellipsoid: e.ellipsoid }); else { let f = `Tile spatial reference WKID ${c.tileInfo.spatialReference.wkid} is not supported.`; return o = Gn.reportError(o, i, i._errorEvent, f, void 0, void 0, void 0), o.retry ? a() : Promise.reject(new fe(f)) } if (i._maximumLevel = c.tileInfo.lods.length - 1, l(c.fullExtent)) { if (l(c.fullExtent.spatialReference) && l(c.fullExtent.spatialReference.wkid)) if (c.fullExtent.spatialReference.wkid === 102100 || c.fullExtent.spatialReference.wkid === 102113) { let f = new Ri, d = c.fullExtent, p = f.unproject(new h(Math.max(d.xmin, -i._tilingScheme.ellipsoid.maximumRadius * Math.PI), Math.max(d.ymin, -i._tilingScheme.ellipsoid.maximumRadius * Math.PI), 0)), g = f.unproject(new h(Math.min(d.xmax, i._tilingScheme.ellipsoid.maximumRadius * Math.PI), Math.min(d.ymax, i._tilingScheme.ellipsoid.maximumRadius * Math.PI), 0)); i._rectangle = new ce(p.longitude, p.latitude, g.longitude, g.latitude) } else if (c.fullExtent.spatialReference.wkid === 4326) i._rectangle = ce.fromDegrees(c.fullExtent.xmin, c.fullExtent.ymin, c.fullExtent.xmax, c.fullExtent.ymax); else { let f = `fullExtent.spatialReference WKID ${c.fullExtent.spatialReference.wkid} is not supported.`; return o = Gn.reportError(o, i, i._errorEvent, f, void 0, void 0, void 0), o.retry ? a() : Promise.reject(new fe(f)) } } else i._rectangle = i._tilingScheme.rectangle; l(i._tileDiscardPolicy) || (i._tileDiscardPolicy = new uV({ missingImageUrl: Zhe(i, 0, 0, i._maximumLevel).url, pixelsToCheck: [new H(0, 0), new H(200, 20), new H(20, 200), new H(80, 110), new H(160, 130)], disableCheckIfAllPixelsAreTransparent: !0 })), i._useTiles = !0 } return l(c.copyrightText) && c.copyrightText.length > 0 && (i._credit = new Xt(c.copyrightText)), i._ready = !0, Gn.reportSuccess(o), Promise.resolve(!0) } function s(c) { let u = `An error occurred while accessing ${i._resource.url}.`; return o = Gn.reportError(o, i, i._errorEvent, u, void 0, void 0, void 0), Promise.reject(new fe(u)) } function a() { return i._resource.getDerivedResource({ queryParameters: { f: "json" } }).fetchJsonp().then(r).catch(s) } this._useTiles ? this._readyPromise = a() : (this._ready = !0, this._readyPromise = Promise.resolve(!0)) } function Zhe(e, t, n, i, o) { let r; if (e._useTiles) r = e._resource.getDerivedResource({ url: `tile/${i}/${n}/${t}`, request: o }); else { let s = e._tilingScheme.tileXYToNativeRectangle(t, n, i), c = { bbox: `${s.west},${s.south},${s.east},${s.north}`, size: `${e._tileWidth},${e._tileHeight}`, format: "png32", transparent: !0, f: "image" }; e._tilingScheme.projection instanceof _i ? (c.bboxSR = 4326, c.imageSR = 4326) : (c.bboxSR = 3857, c.imageSR = 3857), e.layers && (c.layers = `show:${e.layers}`), r = e._resource.getDerivedResource({ url: "export", request: o, queryParameters: c }) } return r } Object.defineProperties(kD.prototype, { url: { get: function () { return this._resource._url } }, token: { get: function () { return this._resource.queryParameters.token } }, proxy: { get: function () { return this._resource.proxy } }, tileWidth: { get: function () { return this._tileWidth } }, tileHeight: { get: function () { return this._tileHeight } }, maximumLevel: { get: function () { return this._maximumLevel } }, minimumLevel: { get: function () { return 0 } }, tilingScheme: { get: function () { return this._tilingScheme } }, rectangle: { get: function () { return this._rectangle } }, tileDiscardPolicy: { get: function () { return this._tileDiscardPolicy } }, errorEvent: { get: function () { return this._errorEvent } }, ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } }, credit: { get: function () { return this._credit } }, usingPrecachedTiles: { get: function () { return this._useTiles } }, hasAlphaChannel: { get: function () { return !0 } }, layers: { get: function () { return this._layers } } }); kD.prototype.getTileCredits = function (e, t, n) { }; kD.prototype.requestImage = function (e, t, n, i) { return tl.loadImage(this, Zhe(this, e, t, n, i)) }; kD.prototype.pickFeatures = function (e, t, n, i, o) { if (!this.enablePickFeatures) return; let r = this._tilingScheme.tileXYToNativeRectangle(e, t, n), s, a, c; if (this._tilingScheme.projection instanceof _i) s = I.toDegrees(i), a = I.toDegrees(o), c = "4326"; else { let p = this._tilingScheme.projection.project(new he(i, o, 0)); s = p.x, a = p.y, c = "3857" } let u = "visible"; l(this._layers) && (u += `:${this._layers}`); let f = { f: "json", tolerance: 2, geometryType: "esriGeometryPoint", geometry: `${s},${a}`, mapExtent: `${r.west},${r.south},${r.east},${r.north}`, imageDisplay: `${this._tileWidth},${this._tileHeight},96`, sr: c, layers: u }; return this._resource.getDerivedResource({ url: "identify", queryParameters: f }).fetchJson().then(function (p) { let g = [], m = p.results; if (!l(m)) return g; for (let A = 0; A < m.length; ++A) { let C = m[A], x = new Oh; if (x.data = C, x.name = C.value, x.properties = C.attributes, x.configureDescriptionFromProperties(C.attributes), C.geometryType === "esriGeometryPoint" && C.geometry) { let T = C.geometry.spatialReference && C.geometry.spatialReference.wkid ? C.geometry.spatialReference.wkid : 4326; if (T === 4326 || T === 4283) x.position = he.fromDegrees(C.geometry.x, C.geometry.y, C.geometry.z); else if (T === 102100 || T === 900913 || T === 3857) { let b = new Ri; x.position = b.unproject(new h(C.geometry.x, C.geometry.y, C.geometry.z)) } } g.push(x) } return g }) }; var Mg = kD; function Qy() { this._uniformMap = void 0, this._command = void 0, this._colorTexture = void 0, this._depthTexture = void 0, this._ready = !1, this._name = "czm_autoexposure", this._logDepthChanged = void 0, this._useLogDepth = void 0, this._framebuffers = void 0, this._previousLuminance = new si, this._commands = void 0, this._clearCommand = void 0, this._minMaxLuminance = new H, this.enabled = !0, this._enabled = !0, this.minimumLuminance = .1, this.maximumLuminance = 10 } Object.defineProperties(Qy.prototype, { ready: { get: function () { return this._ready } }, name: { get: function () { return this._name } }, outputTexture: { get: function () { let e = this._framebuffers; if (!!l(e)) return e[e.length - 1].getColorTexture(0) } } }); function Qhe(e) { let t = e._framebuffers; if (!l(t)) return; let n = t.length; for (let i = 0; i < n; ++i)t[i].destroy(); e._framebuffers = void 0, e._previousLuminance.destroy(), e._previousLuminance = void 0 } function A$e(e, t) { Qhe(e); let n = e._width, i = e._height, o = t.halfFloatingPointTexture ? Ye.HALF_FLOAT : Ye.FLOAT, r = Math.ceil(Math.log(Math.max(n, i)) / Math.log(3)), s = new Array(r); for (let c = 0; c < r; ++c)n = Math.max(Math.ceil(n / 3), 1), i = Math.max(Math.ceil(i / 3), 1), s[c] = new si, s[c].update(t, n, i, 1, o); let a = s[r - 1].getColorTexture(0); e._previousLuminance.update(t, a.width, a.height, 1, o), e._framebuffers = s } function $he(e) { let t = e._commands; if (!l(t)) return; let n = t.length; for (let i = 0; i < n; ++i)t[i].shaderProgram.destroy(); e._commands = void 0 } function C$e(e, t) { let n; if (t === 0) n = { colorTexture: function () { return e._colorTexture }, colorTextureDimensions: function () { return e._colorTexture.dimensions } }; else { let i = e._framebuffers[t - 1].getColorTexture(0); n = { colorTexture: function () { return i }, colorTextureDimensions: function () { return i.dimensions } } } return n.minMaxLuminance = function () { return e._minMaxLuminance }, n.previousLuminance = function () { return e._previousLuminance.getColorTexture(0) }, n } function x$e(e, t) {
        let n = `uniform sampler2D colorTexture; 
varying vec2 v_textureCoordinates; 
float sampleTexture(vec2 offset) { 
`; return e === 0 ? n += `    vec4 color = texture2D(colorTexture, v_textureCoordinates + offset); 
    return czm_luminance(color.rgb); 
`: n += `    return texture2D(colorTexture, v_textureCoordinates + offset).r; 
`, n += `}

`, n += `uniform vec2 colorTextureDimensions; 
uniform vec2 minMaxLuminance; 
uniform sampler2D previousLuminance; 
void main() { 
    float color = 0.0; 
    float xStep = 1.0 / colorTextureDimensions.x; 
    float yStep = 1.0 / colorTextureDimensions.y; 
    int count = 0; 
    for (int i = 0; i < 3; ++i) { 
        for (int j = 0; j < 3; ++j) { 
            vec2 offset; 
            offset.x = -xStep + float(i) * xStep; 
            offset.y = -yStep + float(j) * yStep; 
            if (offset.x < 0.0 || offset.x > 1.0 || offset.y < 0.0 || offset.y > 1.0) { 
                continue; 
            } 
            color += sampleTexture(offset); 
            ++count; 
        } 
    } 
    if (count > 0) { 
        color /= float(count); 
    } 
`, e === t - 1 && (n += `    float previous = texture2D(previousLuminance, vec2(0.5)).r; 
    color = clamp(color, minMaxLuminance.x, minMaxLuminance.y); 
    color = previous + (color - previous) / (60.0 * 1.5); 
    color = clamp(color, minMaxLuminance.x, minMaxLuminance.y); 
`), n += `    gl_FragColor = vec4(color); 
} 
`, n
    } function T$e(e, t) { $he(e); let n = e._framebuffers, i = n.length, o = new Array(i); for (let r = 0; r < i; ++r)o[r] = t.createViewportQuadCommand(x$e(r, i), { framebuffer: n[r].framebuffer, uniformMap: C$e(e, r) }); e._commands = o } Qy.prototype.clear = function (e) { let t = this._framebuffers; if (!l(t)) return; let n = this._clearCommand; l(n) || (n = this._clearCommand = new ti({ color: new U(0, 0, 0, 0), framebuffer: void 0 })); let i = t.length; for (let o = 0; o < i; ++o)t[o].clear(e, n) }; Qy.prototype.update = function (e) { let t = e.drawingBufferWidth, n = e.drawingBufferHeight; (t !== this._width || n !== this._height) && (this._width = t, this._height = n, A$e(this, e), T$e(this, e), this._ready || (this._ready = !0)), this._minMaxLuminance.x = this.minimumLuminance, this._minMaxLuminance.y = this.maximumLuminance; let i = this._framebuffers, o = i[i.length - 1]; i[i.length - 1] = this._previousLuminance, this._commands[this._commands.length - 1].framebuffer = this._previousLuminance.framebuffer, this._previousLuminance = o }; Qy.prototype.execute = function (e, t) { this._colorTexture = t; let n = this._commands; if (!l(n)) return; let i = n.length; for (let o = 0; o < i; ++o)n[o].execute(e) }; Qy.prototype.isDestroyed = function () { return !1 }; Qy.prototype.destroy = function () { return Qhe(this), $he(this), le(this) }; var fV = Qy; var E$e = { AERIAL: "Aerial", AERIAL_WITH_LABELS: "AerialWithLabels", AERIAL_WITH_LABELS_ON_DEMAND: "AerialWithLabelsOnDemand", ROAD: "Road", ROAD_ON_DEMAND: "RoadOnDemand", CANVAS_DARK: "CanvasDark", CANVAS_LIGHT: "CanvasLight", CANVAS_GRAY: "CanvasGray", ORDNANCE_SURVEY: "OrdnanceSurvey", COLLINS_BART: "CollinsBart" }, dV = Object.freeze(E$e); function UD(e) { } UD.prototype.isReady = function () { return !0 }; UD.prototype.shouldDiscardImage = function (e) { return UD.EMPTY_IMAGE === e }; var hV; Object.defineProperties(UD, { EMPTY_IMAGE: { get: function () { return l(hV) || (hV = new Image, hV.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="), hV } } }); var zD = UD; function Ns(e) { e = y(e, y.EMPTY_OBJECT); let t = e.key; this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = 1, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0, this._key = t, this._resource = Pe.createIfNeeded(e.url), this._resource.appendForwardSlash(), this._tileProtocol = e.tileProtocol, this._mapStyle = y(e.mapStyle, dV.AERIAL), this._culture = y(e.culture, ""), this._tileDiscardPolicy = e.tileDiscardPolicy, l(this._tileDiscardPolicy) || (this._tileDiscardPolicy = new zD), this._proxy = e.proxy, this._credit = new Xt(`<a href="http://www.bing.com"><img src="${Ns.logoUrl}" title="Bing Imagery"/></a>`), this._tilingScheme = new Gr({ numberOfLevelZeroTilesX: 2, numberOfLevelZeroTilesY: 2, ellipsoid: e.ellipsoid }), this._tileWidth = void 0, this._tileHeight = void 0, this._maximumLevel = void 0, this._imageUrlTemplate = void 0, this._imageUrlSubdomains = void 0, this._errorEvent = new _e, this._ready = !1; let n = this._tileProtocol; l(n) ? n.length > 0 && n[n.length - 1] === ":" && (n = n.substr(0, n.length - 1)) : n = document.location.protocol === "http:" ? "http" : "https"; let i = this._resource.getDerivedResource({ url: `REST/v1/Imagery/Metadata/${this._mapStyle}`, queryParameters: { incl: "ImageryProviders", key: this._key, uriScheme: n } }), o = this, r; function s(d) { if (d.resourceSets.length !== 1) return a(); let p = d.resourceSets[0].resources[0]; o._tileWidth = p.imageWidth, o._tileHeight = p.imageHeight, o._maximumLevel = p.zoomMax - 1, o._imageUrlSubdomains = p.imageUrlSubdomains, o._imageUrlTemplate = p.imageUrl; let g = o._attributionList = p.imageryProviders; g || (g = o._attributionList = []); for (let m = 0, A = g.length; m < A; ++m) { let C = g[m]; if (C.credit instanceof Xt) break; C.credit = new Xt(C.attribution); let x = C.coverageAreas; for (let T = 0, b = C.coverageAreas.length; T < b; ++T) { let S = x[T], D = S.bbox; S.bbox = new ce(I.toRadians(D[1]), I.toRadians(D[0]), I.toRadians(D[3]), I.toRadians(D[2])) } } return o._ready = !0, Gn.reportSuccess(r), Promise.resolve(!0) } function a(d) { let p = `An error occurred while accessing ${i.url}.`; return r = Gn.reportError(r, o, o._errorEvent, p, void 0, void 0, void 0), r.retry ? u() : Promise.reject(new fe(p)) } let c = i.url; function u() { let d = i.fetchJsonp("jsonp"); return Ns._metadataCache[c] = d, d.then(s).catch(a) } let f = Ns._metadataCache[c]; l(f) ? this._readyPromise = f.then(s).catch(a) : this._readyPromise = u() } Object.defineProperties(Ns.prototype, { url: { get: function () { return this._resource.url } }, proxy: { get: function () { return this._resource.proxy } }, key: { get: function () { return this._key } }, mapStyle: { get: function () { return this._mapStyle } }, culture: { get: function () { return this._culture } }, tileWidth: { get: function () { return this._tileWidth } }, tileHeight: { get: function () { return this._tileHeight } }, maximumLevel: { get: function () { return this._maximumLevel } }, minimumLevel: { get: function () { return 0 } }, tilingScheme: { get: function () { return this._tilingScheme } }, rectangle: { get: function () { return this._tilingScheme.rectangle } }, tileDiscardPolicy: { get: function () { return this._tileDiscardPolicy } }, errorEvent: { get: function () { return this._errorEvent } }, ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } }, credit: { get: function () { return this._credit } }, hasAlphaChannel: { get: function () { return !1 } } }); var b$e = new ce; Ns.prototype.getTileCredits = function (e, t, n) { let i = this._tilingScheme.tileXYToRectangle(e, t, n, b$e); return D$e(this._attributionList, n, i) }; Ns.prototype.requestImage = function (e, t, n, i) { let o = tl.loadImage(this, S$e(this, e, t, n, i)); if (l(o)) return o.catch(function (r) { return l(r.blob) && r.blob.size === 0 ? zD.EMPTY_IMAGE : Promise.reject(r) }) }; Ns.prototype.pickFeatures = function (e, t, n, i, o) { }; Ns.tileXYToQuadKey = function (e, t, n) { let i = ""; for (let o = n; o >= 0; --o) { let r = 1 << o, s = 0; (e & r) !== 0 && (s |= 1), (t & r) !== 0 && (s |= 2), i += s } return i }; Ns.quadKeyToTileXY = function (e) { let t = 0, n = 0, i = e.length - 1; for (let o = i; o >= 0; --o) { let r = 1 << o, s = +e[i - o]; (s & 1) !== 0 && (t |= r), (s & 2) !== 0 && (n |= r) } return { x: t, y: n, level: i } }; Ns._logoUrl = void 0; Object.defineProperties(Ns, { logoUrl: { get: function () { return l(Ns._logoUrl) || (Ns._logoUrl = Jt("Assets/Images/bing_maps_credit.png")), Ns._logoUrl }, set: function (e) { Ns._logoUrl = e } } }); function S$e(e, t, n, i, o) { let r = e._imageUrlTemplate, s = e._imageUrlSubdomains, a = (t + n + i) % s.length; return e._resource.getDerivedResource({ url: r, request: o, templateValues: { quadkey: Ns.tileXYToQuadKey(t, n, i), subdomain: s[a], culture: e._culture }, queryParameters: { n: "z" } }) } var w$e = new ce; function D$e(e, t, n) { ++t; let i = []; for (let o = 0, r = e.length; o < r; ++o) { let s = e[o], a = s.coverageAreas, c = !1; for (let u = 0, f = s.coverageAreas.length; !c && u < f; ++u) { let d = a[u]; if (t >= d.zoomMin && t <= d.zoomMax) { let p = ce.intersection(n, d.bbox, w$e); l(p) && (c = !0) } } c && i.push(s.credit) } return i } Ns._metadataCache = {}; var mV = Ns; var v$e = new h(1, 1, 1); function P7(e) { e = y(e, v$e), this._dimensions = h.clone(e) } Object.defineProperties(P7.prototype, { dimensions: { get: function () { return this._dimensions }, set: function (e) { h.clone(e, this._dimensions) } } }); var P$e = new h; P7.prototype.emit = function (e) { let t = this._dimensions, n = h.multiplyByScalar(t, .5, P$e), i = I.randomBetween(-n.x, n.x), o = I.randomBetween(-n.y, n.y), r = I.randomBetween(-n.z, n.z); e.position = h.fromElements(i, o, r, e.position), e.velocity = h.normalize(e.position, e.velocity) }; var eme = P7; var pV = `varying vec2 v_textureCoordinates;
const float M_PI = 3.141592653589793;
float vdcRadicalInverse(int i)
{
float r;
float base = 2.0;
float value = 0.0;
float invBase = 1.0 / base;
float invBi = invBase;
for (int x = 0; x < 100; x++)
{
if (i <= 0)
{
break;
}
r = mod(float(i), base);
value += r * invBi;
invBi *= invBase;
i = int(float(i) * invBase);
}
return value;
}
vec2 hammersley2D(int i, int N)
{
return vec2(float(i) / float(N), vdcRadicalInverse(i));
}
vec3 importanceSampleGGX(vec2 xi, float roughness, vec3 N)
{
float a = roughness * roughness;
float phi = 2.0 * M_PI * xi.x;
float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (a * a - 1.0) * xi.y));
float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
vec3 H = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
vec3 upVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
vec3 tangentX = normalize(cross(upVector, N));
vec3 tangentY = cross(N, tangentX);
return tangentX * H.x + tangentY * H.y + N * H.z;
}
float G1_Smith(float NdotV, float k)
{
return NdotV / (NdotV * (1.0 - k) + k);
}
float G_Smith(float roughness, float NdotV, float NdotL)
{
float k = roughness * roughness / 2.0;
return G1_Smith(NdotV, k) * G1_Smith(NdotL, k);
}
vec2 integrateBrdf(float roughness, float NdotV)
{
vec3 V = vec3(sqrt(1.0 - NdotV * NdotV), 0.0, NdotV);
float A = 0.0;
float B = 0.0;
const int NumSamples = 1024;
for (int i = 0; i < NumSamples; i++)
{
vec2 xi = hammersley2D(i, NumSamples);
vec3 H = importanceSampleGGX(xi, roughness, vec3(0.0, 0.0, 1.0));
vec3 L = 2.0 * dot(V, H) * H - V;
float NdotL = clamp(L.z, 0.0, 1.0);
float NdotH = clamp(H.z, 0.0, 1.0);
float VdotH = clamp(dot(V, H), 0.0, 1.0);
if (NdotL > 0.0)
{
float G = G_Smith(roughness, NdotV, NdotL);
float G_Vis = G * VdotH / (NdotH * NdotV);
float Fc = pow(1.0 - VdotH, 5.0);
A += (1.0 - Fc) * G_Vis;
B += Fc * G_Vis;
}
}
return vec2(A, B) / float(NumSamples);
}
void main()
{
gl_FragColor = vec4(integrateBrdf(v_textureCoordinates.y, v_textureCoordinates.x), 0.0, 1.0);
}
`; function HD() { this._colorTexture = void 0, this._drawCommand = void 0 } Object.defineProperties(HD.prototype, { colorTexture: { get: function () { return this._colorTexture } } }); function I$e(e, t, n) { let i = t.createViewportQuadCommand(pV, { framebuffer: n, renderState: Ve.fromCache({ viewport: new Ge(0, 0, 256, 256) }) }); e._drawCommand = i } HD.prototype.update = function (e) { if (!l(this._colorTexture)) { let t = e.context, n = new Rt({ context: t, width: 256, height: 256, pixelFormat: ht.RGBA, pixelDatatype: Ye.UNSIGNED_BYTE, sampler: dn.NEAREST }); this._colorTexture = n; let i = new Js({ context: t, colorTextures: [n], destroyAttachments: !1 }); I$e(this, t, i), this._drawCommand.execute(t), i.destroy(), this._drawCommand.shaderProgram = this._drawCommand.shaderProgram && this._drawCommand.shaderProgram.destroy() } }; HD.prototype.isDestroyed = function () { return !1 }; HD.prototype.destroy = function () { return this._colorTexture = this._colorTexture && this._colorTexture.destroy(), le(this) }; var _V = HD; var ome = {}; function O$e(e, t, n) { let i, o, r; if (e instanceof mi) { let s = Math.tan(.5 * e.fovy); return i = e.near, o = e.near * s, r = e.aspectRatio * o, Math.max(t * i / r, n * i / o) } else if (e instanceof $c) return i = e.near, o = e.top, r = e.right, Math.max(t * i / r, n * i / o); return Math.max(t, n) } var B$e = new h, tme = new h; function rme(e, t, n, i) { if (l(i) && n(.5) > i) { let o = n(0), r = n(1), s = n(.5), a = s - o, c = s - r; return function (u) { let f = n(u); if (u <= .5) { let p = (f - o) / a; return I.lerp(e, -I.PI_OVER_TWO, p) } let d = (f - r) / c; return I.lerp(-I.PI_OVER_TWO, t, 1 - d) } } return function (o) { return I.lerp(e, t, o) } } function O7(e, t, n, i, o) { let r = o, s = Math.max(n, i); if (!l(r)) { let a = e.position, c = t, u = e.up, f = e.right, d = e.frustum, p = h.subtract(a, c, B$e), g = h.magnitude(h.multiplyByScalar(u, h.dot(p, u), tme)), m = h.magnitude(h.multiplyByScalar(f, h.dot(p, f), tme)); r = Math.min(O$e(d, g, m) * .2, 1e9) } if (s < r) { let u = -Math.pow((r - n) * 1e6, .125), f = Math.pow((r - i) * 1e6, 1 / 8); return function (d) { let p = d * (f - u) + u; return -Math.pow(p, 8) / 1e6 + r } } return function (a) { return I.lerp(n, i, a) } } function GD(e, t) { return I.equalsEpsilon(e, I.TWO_PI, I.EPSILON11) && (e = 0), t > e + Math.PI ? e += I.TWO_PI : t < e - Math.PI && (e -= I.TWO_PI), e } var sme = new h; function R$e(e, t, n, i, o, r, s, a) { let c = e.camera, u = h.clone(c.position, sme), f = c.pitch, d = GD(c.heading, i), p = GD(c.roll, r), g = O7(c, n, u.z, n.z, s), m = rme(f, o, g, a); function A(C) { let x = C.time / t; c.setView({ orientation: { heading: I.lerp(d, i, x), pitch: m(x), roll: I.lerp(p, r, x) } }), H.lerp(u, n, x, c.position), c.position.z = g(x) } return A } function M$e(e, t) { e.longitude < t.longitude ? e.longitude += I.TWO_PI : t.longitude += I.TWO_PI } function L$e(e, t) { let n = e.longitude - t.longitude; n < -I.PI ? e.longitude += I.TWO_PI : n > I.PI && (t.longitude += I.TWO_PI) } var F$e = new he, N$e = new he; function V$e(e, t, n, i, o, r, s, a, c, u) { let f = e.camera, p = e.mapProjection.ellipsoid, g = he.clone(f.positionCartographic, F$e), m = f.pitch, A = GD(f.heading, i), C = GD(f.roll, r), x = p.cartesianToCartographic(n, N$e); g.longitude = I.zeroToTwoPi(g.longitude), x.longitude = I.zeroToTwoPi(x.longitude); let T = !1; if (l(a)) { let P = I.zeroToTwoPi(a), B = Math.min(g.longitude, x.longitude), R = Math.max(g.longitude, x.longitude), M = P >= B && P <= R; if (l(c)) { let L = Math.abs(g.longitude - x.longitude), _ = I.TWO_PI - L; (M ? L : _) < (M ? _ : L) * c && !M && (T = !0) } else M || (T = !0) } T ? M$e(g, x) : L$e(g, x); let b = O7(f, n, g.height, x.height, s), S = rme(m, o, b, u); function D() { let P = g.longitude, B = x.longitude, R = g.latitude, M = x.latitude; return function (_) { let E = _.time / t, w = h.fromRadians(I.lerp(P, B, E), I.lerp(R, M, E), b(E), p); f.setView({ destination: w, orientation: { heading: I.lerp(A, i, E), pitch: S(E), roll: I.lerp(C, r, E) } }) } } return D() } function k$e(e, t, n, i, o, r, s) { let a = e.camera, c = h.clone(a.position, sme), u = GD(a.heading, i), f = a.frustum.right - a.frustum.left, d = O7(a, n, f, n.z, s); function p(g) { let m = g.time / t; a.setView({ orientation: { heading: I.lerp(u, i, m) } }), H.lerp(c, n, m, a.position); let A = d(m), C = a.frustum, x = C.top / C.right, T = (A - (C.right - C.left)) * .5; C.right += T, C.left -= T, C.top = x * C.right, C.bottom = -C.top } return p } var nme = new he, U$e = new h; function I7(e, t) { return { startObject: {}, stopObject: {}, duration: 0, complete: e, cancel: t } } function ime(e, t) { function n() { typeof t == "function" && t(), e.enableInputs = !0 } return n } ome.createTween = function (e, t) { t = y(t, y.EMPTY_OBJECT); let n = t.destination, i = e.mode; if (i === ee.MORPHING) return I7(); let o = y(t.convert, !0), r = e.mapProjection, s = r.ellipsoid, a = t.maximumHeight, c = t.flyOverLongitude, u = t.flyOverLongitudeWeight, f = t.pitchAdjustHeight, d = t.easingFunction; o && i !== ee.SCENE3D && (s.cartesianToCartographic(n, nme), n = r.project(nme, U$e)); let p = e.camera, g = t.endTransform; l(g) && p._setTransform(g); let m = t.duration; l(m) || (m = Math.ceil(h.distance(p.position, n) / 1e6) + 2, m = Math.min(m, 3)); let A = y(t.heading, 0), C = y(t.pitch, -I.PI_OVER_TWO), x = y(t.roll, 0), T = e.screenSpaceCameraController; T.enableInputs = !1; let b = ime(T, t.complete), S = ime(T, t.cancel), D = p.frustum, P = e.mode === ee.SCENE2D; if (P = P && H.equalsEpsilon(p.position, n, I.EPSILON6), P = P && I.equalsEpsilon(Math.max(D.right - D.left, D.top - D.bottom), n.z, I.EPSILON6), P = P || e.mode !== ee.SCENE2D && h.equalsEpsilon(n, p.position, I.EPSILON10), P = P && I.equalsEpsilon(I.negativePiToPi(A), I.negativePiToPi(p.heading), I.EPSILON10) && I.equalsEpsilon(I.negativePiToPi(C), I.negativePiToPi(p.pitch), I.EPSILON10) && I.equalsEpsilon(I.negativePiToPi(x), I.negativePiToPi(p.roll), I.EPSILON10), P) return I7(b, S); let B = new Array(4); if (B[ee.SCENE2D] = k$e, B[ee.SCENE3D] = V$e, B[ee.COLUMBUS_VIEW] = R$e, m <= 0) return I7(function () { B[i](e, 1, n, A, C, x, a, c, u, f)({ time: 1 }), typeof b == "function" && b() }, S); let R = B[i](e, m, n, A, C, x, a, c, u, f); if (!l(d)) { let M = p.positionCartographic.height, L = i === ee.SCENE3D ? s.cartesianToCartographic(n).height : n.z; M > L && M > 11500 ? d = Mr.CUBIC_OUT : d = Mr.QUINTIC_IN_OUT } return { duration: m, easingFunction: d, startObject: { time: 0 }, stopObject: { time: m }, update: R, complete: b, cancel: S } }; var gV = ome; var z$e = { ROTATE: 0, INFINITE_SCROLL: 1 }, Ul = Object.freeze(z$e); function jt(e) { this._scene = e, this._transform = F.clone(F.IDENTITY), this._invTransform = F.clone(F.IDENTITY), this._actualTransform = F.clone(F.IDENTITY), this._actualInvTransform = F.clone(F.IDENTITY), this._transformChanged = !1, this.position = new h, this._position = new h, this._positionWC = new h, this._positionCartographic = new he, this._oldPositionWC = void 0, this.positionWCDeltaMagnitude = 0, this.positionWCDeltaMagnitudeLastFrame = 0, this.timeSinceMoved = 0, this._lastMovedTimestamp = 0, this.direction = new h, this._direction = new h, this._directionWC = new h, this.up = new h, this._up = new h, this._upWC = new h, this.right = new h, this._right = new h, this._rightWC = new h, this.frustum = new mi, this.frustum.aspectRatio = e.drawingBufferWidth / e.drawingBufferHeight, this.frustum.fov = I.toRadians(60), this.defaultMoveAmount = 1e5, this.defaultLookAmount = Math.PI / 60, this.defaultRotateAmount = Math.PI / 3600, this.defaultZoomAmount = 1e5, this.constrainedAxis = void 0, this.maximumZoomFactor = 1.5, this._moveStart = new _e, this._moveEnd = new _e, this._changed = new _e, this._changedPosition = void 0, this._changedDirection = void 0, this._changedFrustum = void 0, this._changedHeading = void 0, this.percentageChanged = .5, this._viewMatrix = new F, this._invViewMatrix = new F, mme(this), this._mode = ee.SCENE3D, this._modeChanged = !0; let t = e.mapProjection; this._projection = t, this._maxCoord = t.project(new he(Math.PI, I.PI_OVER_TWO)), this._max2Dfrustum = void 0, wme(this, jt.DEFAULT_VIEW_RECTANGLE, this.position, !0); let n = h.magnitude(this.position); n += n * jt.DEFAULT_VIEW_FACTOR, h.normalize(this.position, this.position), h.multiplyByScalar(this.position, n, this.position) } jt.TRANSFORM_2D = new F(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1); jt.TRANSFORM_2D_INVERSE = F.inverseTransformation(jt.TRANSFORM_2D, new F); jt.DEFAULT_VIEW_RECTANGLE = ce.fromDegrees(-95, -20, -70, 90); jt.DEFAULT_VIEW_FACTOR = .5; jt.DEFAULT_OFFSET = new ku(0, -I.PI_OVER_FOUR, 0); function mme(e) { F.computeView(e._position, e._direction, e._up, e._right, e._viewMatrix), F.multiply(e._viewMatrix, e._actualInvTransform, e._viewMatrix), F.inverseTransformation(e._viewMatrix, e._invViewMatrix) } function H$e(e) { if (!l(e._oldPositionWC)) e._oldPositionWC = h.clone(e.positionWC, e._oldPositionWC); else { e.positionWCDeltaMagnitudeLastFrame = e.positionWCDeltaMagnitude; let t = h.subtract(e.positionWC, e._oldPositionWC, e._oldPositionWC); e.positionWCDeltaMagnitude = h.magnitude(t), e._oldPositionWC = h.clone(e.positionWC, e._oldPositionWC), e.positionWCDeltaMagnitude > 0 ? (e.timeSinceMoved = 0, e._lastMovedTimestamp = Ei()) : e.timeSinceMoved = Math.max(Ei() - e._lastMovedTimestamp, 0) / 1e3 } } jt.prototype.canPreloadFlight = function () { return l(this._currentFlight) && this._mode !== ee.SCENE2D }; jt.prototype._updateCameraChanged = function () { let e = this; if (H$e(e), e._changed.numberOfListeners === 0) return; let t = e.percentageChanged, n = e.heading; l(e._changedHeading) || (e._changedHeading = n); let i = Math.abs(e._changedHeading - n) % I.TWO_PI; i = i > I.PI ? I.TWO_PI - i : i; let o = i / Math.PI; if (o > t && (e._changed.raiseEvent(o), e._changedHeading = n), e._mode === ee.SCENE2D) { if (!l(e._changedFrustum)) { e._changedPosition = h.clone(e.position, e._changedPosition), e._changedFrustum = e.frustum.clone(); return } let u = e.position, f = e._changedPosition, d = e.frustum, p = e._changedFrustum, g = u.x + d.left, m = u.x + d.right, A = f.x + p.left, C = f.x + p.right, x = u.y + d.bottom, T = u.y + d.top, b = f.y + p.bottom, S = f.y + p.top, D = Math.max(g, A), P = Math.min(m, C), B = Math.max(x, b), R = Math.min(T, S), M; if (D >= P || B >= T) M = 1; else { let L = p; g < A && m > C && x < b && T > S && (L = d), M = 1 - (P - D) * (R - B) / ((L.right - L.left) * (L.top - L.bottom)) } M > t && (e._changed.raiseEvent(M), e._changedPosition = h.clone(e.position, e._changedPosition), e._changedFrustum = e.frustum.clone(e._changedFrustum)); return } if (!l(e._changedDirection)) { e._changedPosition = h.clone(e.positionWC, e._changedPosition), e._changedDirection = h.clone(e.directionWC, e._changedDirection); return } let r = I.acosClamped(h.dot(e.directionWC, e._changedDirection)), s; l(e.frustum.fovy) ? s = r / (e.frustum.fovy * .5) : s = r; let c = h.distance(e.positionWC, e._changedPosition) / e.positionCartographic.height; (s > t || c > t) && (e._changed.raiseEvent(Math.max(s, c)), e._changedPosition = h.clone(e.positionWC, e._changedPosition), e._changedDirection = h.clone(e.directionWC, e._changedDirection)) }; function G$e(e) { It.basisTo2D(e._projection, e._transform, e._actualTransform) } var W$e = new he, j$e = new h, yV = new h, q$e = new se, Y$e = new se, X$e = new se, K$e = new se, J$e = new se; function Z$e(e) { let t = e._projection, n = t.ellipsoid, i = F.getColumn(e._transform, 3, q$e), o = n.cartesianToCartographic(i, W$e), r = t.project(o, j$e), s = Y$e; s.x = r.z, s.y = r.x, s.z = r.y, s.w = 1; let a = se.clone(se.UNIT_X, J$e), c = se.add(F.getColumn(e._transform, 0, yV), i, yV); n.cartesianToCartographic(c, o), t.project(o, r); let u = X$e; u.x = r.z, u.y = r.x, u.z = r.y, u.w = 0, h.subtract(u, s, u), u.x = 0; let f = K$e; if (h.magnitudeSquared(u) > I.EPSILON10) h.cross(a, u, f); else { let d = se.add(F.getColumn(e._transform, 1, yV), i, yV); n.cartesianToCartographic(d, o), t.project(o, r), f.x = r.z, f.y = r.x, f.z = r.y, f.w = 0, h.subtract(f, s, f), f.x = 0, h.magnitudeSquared(f) < I.EPSILON10 && (se.clone(se.UNIT_Y, u), se.clone(se.UNIT_Z, f)) } h.cross(f, a, u), h.normalize(u, u), h.cross(a, u, f), h.normalize(f, f), F.setColumn(e._actualTransform, 0, u, e._actualTransform), F.setColumn(e._actualTransform, 1, f, e._actualTransform), F.setColumn(e._actualTransform, 2, a, e._actualTransform), F.setColumn(e._actualTransform, 3, s, e._actualTransform) } var B7 = new h; function Va(e) { let t = e._mode, n = !1, i = 0; t === ee.SCENE2D && (i = e.frustum.right - e.frustum.left, n = i !== e._positionCartographic.height); let o = e._position, r = !h.equals(o, e.position) || n; r && (o = h.clone(e.position, e._position)); let s = e._direction, a = !h.equals(s, e.direction); a && (h.normalize(e.direction, e.direction), s = h.clone(e.direction, e._direction)); let c = e._up, u = !h.equals(c, e.up); u && (h.normalize(e.up, e.up), c = h.clone(e.up, e._up)); let f = e._right, d = !h.equals(f, e.right); d && (h.normalize(e.right, e.right), f = h.clone(e.right, e._right)); let p = e._transformChanged || e._modeChanged; e._transformChanged = !1, p && (F.inverseTransformation(e._transform, e._invTransform), e._mode === ee.COLUMBUS_VIEW || e._mode === ee.SCENE2D ? F.equals(F.IDENTITY, e._transform) ? F.clone(jt.TRANSFORM_2D, e._actualTransform) : e._mode === ee.COLUMBUS_VIEW ? G$e(e) : Z$e(e) : F.clone(e._transform, e._actualTransform), F.inverseTransformation(e._actualTransform, e._actualInvTransform), e._modeChanged = !1); let g = e._actualTransform; if (r || p) if (e._positionWC = F.multiplyByPoint(g, o, e._positionWC), t === ee.SCENE3D || t === ee.MORPHING) e._positionCartographic = e._projection.ellipsoid.cartesianToCartographic(e._positionWC, e._positionCartographic); else { let m = B7; m.x = e._positionWC.y, m.y = e._positionWC.z, m.z = e._positionWC.x, t === ee.SCENE2D && (m.z = i), e._projection.unproject(m, e._positionCartographic) } if (a || u || d) { let m = h.dot(s, h.cross(c, f, B7)); if (Math.abs(1 - m) > I.EPSILON2) { let A = 1 / h.magnitudeSquared(c), C = h.dot(c, s) * A, x = h.multiplyByScalar(s, C, B7); c = h.normalize(h.subtract(c, x, e._up), e._up), h.clone(c, e.up), f = h.cross(s, c, e._right), h.clone(f, e.right) } } (a || p) && (e._directionWC = F.multiplyByPointAsVector(g, s, e._directionWC), h.normalize(e._directionWC, e._directionWC)), (u || p) && (e._upWC = F.multiplyByPointAsVector(g, c, e._upWC), h.normalize(e._upWC, e._upWC)), (d || p) && (e._rightWC = F.multiplyByPointAsVector(g, f, e._rightWC), h.normalize(e._rightWC, e._rightWC)), (r || a || u || d || p) && mme(e) } function pme(e, t) { let n; return I.equalsEpsilon(Math.abs(e.z), 1, I.EPSILON3) ? n = Math.atan2(t.y, t.x) - I.PI_OVER_TWO : n = Math.atan2(e.y, e.x) - I.PI_OVER_TWO, I.TWO_PI - I.zeroToTwoPi(n) } function _me(e) { return I.PI_OVER_TWO - I.acosClamped(e.z) } function gme(e, t, n) { let i = 0; return I.equalsEpsilon(Math.abs(e.z), 1, I.EPSILON3) || (i = Math.atan2(-n.z, t.z), i = I.zeroToTwoPi(i + I.TWO_PI)), i } var xV = new F, TV = new F; Object.defineProperties(jt.prototype, { transform: { get: function () { return this._transform } }, inverseTransform: { get: function () { return Va(this), this._invTransform } }, viewMatrix: { get: function () { return Va(this), this._viewMatrix } }, inverseViewMatrix: { get: function () { return Va(this), this._invViewMatrix } }, positionCartographic: { get: function () { return Va(this), this._positionCartographic } }, positionWC: { get: function () { return Va(this), this._positionWC } }, directionWC: { get: function () { return Va(this), this._directionWC } }, upWC: { get: function () { return Va(this), this._upWC } }, rightWC: { get: function () { return Va(this), this._rightWC } }, heading: { get: function () { if (this._mode !== ee.MORPHING) { let e = this._projection.ellipsoid, t = F.clone(this._transform, xV), n = It.eastNorthUpToFixedFrame(this.positionWC, e, TV); this._setTransform(n); let i = pme(this.direction, this.up); return this._setTransform(t), i } } }, pitch: { get: function () { if (this._mode !== ee.MORPHING) { let e = this._projection.ellipsoid, t = F.clone(this._transform, xV), n = It.eastNorthUpToFixedFrame(this.positionWC, e, TV); this._setTransform(n); let i = _me(this.direction); return this._setTransform(t), i } } }, roll: { get: function () { if (this._mode !== ee.MORPHING) { let e = this._projection.ellipsoid, t = F.clone(this._transform, xV), n = It.eastNorthUpToFixedFrame(this.positionWC, e, TV); this._setTransform(n); let i = gme(this.direction, this.up, this.right); return this._setTransform(t), i } } }, moveStart: { get: function () { return this._moveStart } }, moveEnd: { get: function () { return this._moveEnd } }, changed: { get: function () { return this._changed } } }); jt.prototype.update = function (e) { let t = !1; if (e !== this._mode && (this._mode = e, this._modeChanged = e !== ee.MORPHING, t = this._mode === ee.SCENE2D), t) { let n = this._max2Dfrustum = this.frustum.clone(), i = 2, o = n.top / n.right; n.right = this._maxCoord.x * i, n.left = -n.right, n.top = o * n.right, n.bottom = -n.top } this._mode === ee.SCENE2D && xme(this, this.position) }; var Q$e = new h, $$e = new h, eet = new h; jt.prototype._setTransform = function (e) { let t = h.clone(this.positionWC, Q$e), n = h.clone(this.upWC, $$e), i = h.clone(this.directionWC, eet); F.clone(e, this._transform), this._transformChanged = !0, Va(this); let o = this._actualInvTransform; F.multiplyByPoint(o, t, this.position), F.multiplyByPointAsVector(o, i, this.direction), F.multiplyByPointAsVector(o, n, this.up), h.cross(this.direction, this.up, this.right), Va(this) }; var tet = new H, net = new En, iet = new h, oet = new h; function yme(e) { if (!F.equals(F.IDENTITY, e.transform)) return h.magnitude(e.position); let t = e._scene, n = t.globe, i = tet; i.x = t.drawingBufferWidth / 2, i.y = t.drawingBufferHeight / 2; let o; if (l(n)) { let a = e.getPickRay(i, net); o = n.pickWorldCoordinates(a, t, !0, iet) } let r; t.pickPositionSupported && (r = t.pickPositionWorldCoordinates(i, oet)); let s; if (l(o) || l(r)) { let a = l(r) ? h.distance(r, e.positionWC) : Number.POSITIVE_INFINITY, c = l(o) ? h.distance(o, e.positionWC) : Number.POSITIVE_INFINITY; s = Math.min(a, c) } else s = Math.max(e.positionCartographic.height, 0); return s } jt.prototype._adjustOrthographicFrustum = function (e) { this.frustum instanceof Zt && (!e && this._positionCartographic.height < 15e4 || (this.frustum.width = yme(this))) }; var EV = new h, N7 = new F, ret = new F, V7 = new Be, k7 = new Q, Ame = new he; function set(e, t, n) { let i = F.clone(e.transform, N7), o = It.eastNorthUpToFixedFrame(t, e._projection.ellipsoid, ret); e._setTransform(o), h.clone(h.ZERO, e.position), n.heading = n.heading - I.PI_OVER_TWO; let r = Be.fromHeadingPitchRoll(n, V7), s = Q.fromQuaternion(r, k7); Q.getColumn(s, 0, e.direction), Q.getColumn(s, 2, e.up), h.cross(e.direction, e.up, e.right), e._setTransform(i), e._adjustOrthographicFrustum(!0) } function aet(e, t, n, i) { let o = F.clone(e.transform, N7); if (e._setTransform(F.IDENTITY), !h.equals(t, e.positionWC)) { if (i) { let a = e._projection, c = a.ellipsoid.cartesianToCartographic(t, Ame); t = a.project(c, EV) } h.clone(t, e.position) } n.heading = n.heading - I.PI_OVER_TWO; let r = Be.fromHeadingPitchRoll(n, V7), s = Q.fromQuaternion(r, k7); Q.getColumn(s, 0, e.direction), Q.getColumn(s, 2, e.up), h.cross(e.direction, e.up, e.right), e._setTransform(o), e._adjustOrthographicFrustum(!0) } function cet(e, t, n, i) { let o = F.clone(e.transform, N7); if (e._setTransform(F.IDENTITY), !h.equals(t, e.positionWC)) { if (i) { let c = e._projection, u = c.ellipsoid.cartesianToCartographic(t, Ame); t = c.project(u, EV) } H.clone(t, e.position); let r = -t.z * .5, s = -r, a = e.frustum; if (s > r) { let c = a.top / a.right; a.right = s, a.left = r, a.top = a.right * c, a.bottom = -a.top } } if (e._scene.mapMode2D === Ul.ROTATE) { n.heading = n.heading - I.PI_OVER_TWO, n.pitch = -I.PI_OVER_TWO, n.roll = 0; let r = Be.fromHeadingPitchRoll(n, V7), s = Q.fromQuaternion(r, k7); Q.getColumn(s, 2, e.up), h.cross(e.direction, e.up, e.right) } e._setTransform(o) } var uet = new h, fet = new h, det = new h; function Cme(e, t, n, i) { let o = h.clone(n.direction, uet), r = h.clone(n.up, fet); if (e._scene.mode === ee.SCENE3D) { let a = e._projection.ellipsoid, c = It.eastNorthUpToFixedFrame(t, a, xV), u = F.inverseTransformation(c, TV); F.multiplyByPointAsVector(u, o, o), F.multiplyByPointAsVector(u, r, r) } let s = h.cross(o, r, det); return i.heading = pme(o, r), i.pitch = _me(o), i.roll = gme(o, r, s), i } var F7 = { destination: void 0, orientation: { direction: void 0, up: void 0, heading: void 0, pitch: void 0, roll: void 0 }, convert: void 0, endTransform: void 0 }, yE = new lf; jt.prototype.setView = function (e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.orientation, y.EMPTY_OBJECT), n = this._mode; if (n === ee.MORPHING) return; l(e.endTransform) && this._setTransform(e.endTransform); let i = y(e.convert, !0), o = y(e.destination, h.clone(this.positionWC, EV)); l(o) && l(o.west) && (o = this.getRectangleCameraCoordinates(o, EV), i = !1), l(t.direction) && (t = Cme(this, o, t, F7.orientation)), yE.heading = y(t.heading, 0), yE.pitch = y(t.pitch, -I.PI_OVER_TWO), yE.roll = y(t.roll, 0), n === ee.SCENE3D ? set(this, o, yE) : n === ee.SCENE2D ? cet(this, o, yE, i) : aet(this, o, yE, i) }; var het = new h; jt.prototype.flyHome = function (e) { let t = this._mode; if (t === ee.MORPHING && this._scene.completeMorph(), t === ee.SCENE2D) this.flyTo({ destination: jt.DEFAULT_VIEW_RECTANGLE, duration: e, endTransform: F.IDENTITY }); else if (t === ee.SCENE3D) { let n = this.getRectangleCameraCoordinates(jt.DEFAULT_VIEW_RECTANGLE), i = h.magnitude(n); i += i * jt.DEFAULT_VIEW_FACTOR, h.normalize(n, n), h.multiplyByScalar(n, i, n), this.flyTo({ destination: n, duration: e, endTransform: F.IDENTITY }) } else if (t === ee.COLUMBUS_VIEW) { let n = this._projection.ellipsoid.maximumRadius, i = new h(0, -1, 1); i = h.multiplyByScalar(h.normalize(i, i), 5 * n, i), this.flyTo({ destination: i, duration: e, orientation: { heading: 0, pitch: -Math.acos(h.normalize(i, het).z), roll: 0 }, endTransform: F.IDENTITY, convert: !1 }) } }; jt.prototype.worldToCameraCoordinates = function (e, t) { return l(t) || (t = new se), Va(this), F.multiplyByVector(this._actualInvTransform, e, t) }; jt.prototype.worldToCameraCoordinatesPoint = function (e, t) { return l(t) || (t = new h), Va(this), F.multiplyByPoint(this._actualInvTransform, e, t) }; jt.prototype.worldToCameraCoordinatesVector = function (e, t) { return l(t) || (t = new h), Va(this), F.multiplyByPointAsVector(this._actualInvTransform, e, t) }; jt.prototype.cameraToWorldCoordinates = function (e, t) { return l(t) || (t = new se), Va(this), F.multiplyByVector(this._actualTransform, e, t) }; jt.prototype.cameraToWorldCoordinatesPoint = function (e, t) { return l(t) || (t = new h), Va(this), F.multiplyByPoint(this._actualTransform, e, t) }; jt.prototype.cameraToWorldCoordinatesVector = function (e, t) { return l(t) || (t = new h), Va(this), F.multiplyByPointAsVector(this._actualTransform, e, t) }; function xme(e, t) { let n = e._scene.mapMode2D === Ul.ROTATE, i = e._maxCoord.x, o = e._maxCoord.y, r, s; n ? (s = i, r = -s) : (s = t.x - i * 2, r = t.x + i * 2), t.x > i && (t.x = s), t.x < -i && (t.x = r), t.y > o && (t.y = o), t.y < -o && (t.y = -o) } var ame = new h; jt.prototype.move = function (e, t) { let n = this.position; h.multiplyByScalar(e, t, ame), h.add(n, ame, n), this._mode === ee.SCENE2D && xme(this, n), this._adjustOrthographicFrustum(!0) }; jt.prototype.moveForward = function (e) { e = y(e, this.defaultMoveAmount), this._mode === ee.SCENE2D ? bV(this, e) : this.move(this.direction, e) }; jt.prototype.moveBackward = function (e) { e = y(e, this.defaultMoveAmount), this._mode === ee.SCENE2D ? bV(this, -e) : this.move(this.direction, -e) }; jt.prototype.moveUp = function (e) { e = y(e, this.defaultMoveAmount), this.move(this.up, e) }; jt.prototype.moveDown = function (e) { e = y(e, this.defaultMoveAmount), this.move(this.up, -e) }; jt.prototype.moveRight = function (e) { e = y(e, this.defaultMoveAmount), this.move(this.right, e) }; jt.prototype.moveLeft = function (e) { e = y(e, this.defaultMoveAmount), this.move(this.right, -e) }; jt.prototype.lookLeft = function (e) { e = y(e, this.defaultLookAmount), this._mode !== ee.SCENE2D && this.look(this.up, -e) }; jt.prototype.lookRight = function (e) { e = y(e, this.defaultLookAmount), this._mode !== ee.SCENE2D && this.look(this.up, e) }; jt.prototype.lookUp = function (e) { e = y(e, this.defaultLookAmount), this._mode !== ee.SCENE2D && this.look(this.right, -e) }; jt.prototype.lookDown = function (e) { e = y(e, this.defaultLookAmount), this._mode !== ee.SCENE2D && this.look(this.right, e) }; var met = new Be, pet = new Q; jt.prototype.look = function (e, t) { let n = y(t, this.defaultLookAmount), i = Be.fromAxisAngle(e, -n, met), o = Q.fromQuaternion(i, pet), r = this.direction, s = this.up, a = this.right; Q.multiplyByVector(o, r, r), Q.multiplyByVector(o, s, s), Q.multiplyByVector(o, a, a) }; jt.prototype.twistLeft = function (e) { e = y(e, this.defaultLookAmount), this.look(this.direction, e) }; jt.prototype.twistRight = function (e) { e = y(e, this.defaultLookAmount), this.look(this.direction, -e) }; var _et = new Be, get = new Q; jt.prototype.rotate = function (e, t) { let n = y(t, this.defaultRotateAmount), i = Be.fromAxisAngle(e, -n, _et), o = Q.fromQuaternion(i, get); Q.multiplyByVector(o, this.position, this.position), Q.multiplyByVector(o, this.direction, this.direction), Q.multiplyByVector(o, this.up, this.up), h.cross(this.direction, this.up, this.right), h.cross(this.right, this.direction, this.up), this._adjustOrthographicFrustum(!1) }; jt.prototype.rotateDown = function (e) { e = y(e, this.defaultRotateAmount), Tme(this, e) }; jt.prototype.rotateUp = function (e) { e = y(e, this.defaultRotateAmount), Tme(this, -e) }; var yet = new h, Aet = new h, Cet = new h, cme = new h; function Tme(e, t) { let n = e.position; if (l(e.constrainedAxis) && !h.equalsEpsilon(e.position, h.ZERO, I.EPSILON2)) { let i = h.normalize(n, yet), o = h.equalsEpsilon(i, e.constrainedAxis, I.EPSILON2), r = h.equalsEpsilon(i, h.negate(e.constrainedAxis, cme), I.EPSILON2); if (!o && !r) { let s = h.normalize(e.constrainedAxis, Aet), a = h.dot(i, s), c = I.acosClamped(a); t > 0 && t > c && (t = c - I.EPSILON4), a = h.dot(i, h.negate(s, cme)), c = I.acosClamped(a), t < 0 && -t > c && (t = -c + I.EPSILON4); let u = h.cross(s, i, Cet); e.rotate(u, t) } else (o && t < 0 || r && t > 0) && e.rotate(e.right, t) } else e.rotate(e.right, t) } jt.prototype.rotateRight = function (e) { e = y(e, this.defaultRotateAmount), Eme(this, -e) }; jt.prototype.rotateLeft = function (e) { e = y(e, this.defaultRotateAmount), Eme(this, e) }; function Eme(e, t) { l(e.constrainedAxis) ? e.rotate(e.constrainedAxis, t) : e.rotate(e.up, t) } function bV(e, t) { let n = e.frustum, i; if (t = t * .5, Math.abs(n.top) + Math.abs(n.bottom) > Math.abs(n.left) + Math.abs(n.right)) { let o = n.top - t, r = n.bottom + t, s = e._maxCoord.y; e._scene.mapMode2D === Ul.ROTATE && (s *= e.maximumZoomFactor), r > s && (r = s, o = -s), o <= r && (o = 1, r = -1), i = n.right / n.top, n.top = o, n.bottom = r, n.right = n.top * i, n.left = -n.right } else { let o = n.right - t, r = n.left + t, s = e._maxCoord.x; e._scene.mapMode2D === Ul.ROTATE && (s *= e.maximumZoomFactor), o > s && (o = s, r = -s), o <= r && (o = 1, r = -1), i = n.top / n.right, n.right = o, n.left = r, n.top = n.right * i, n.bottom = -n.top } } function bme(e, t) { e.move(e.direction, t) } jt.prototype.zoomIn = function (e) { e = y(e, this.defaultZoomAmount), this._mode === ee.SCENE2D ? bV(this, e) : bme(this, e) }; jt.prototype.zoomOut = function (e) { e = y(e, this.defaultZoomAmount), this._mode === ee.SCENE2D ? bV(this, -e) : bme(this, -e) }; jt.prototype.getMagnitude = function () { if (this._mode === ee.SCENE3D) return h.magnitude(this.position); if (this._mode === ee.COLUMBUS_VIEW) return Math.abs(this.position.z); if (this._mode === ee.SCENE2D) return Math.max(this.frustum.right - this.frustum.left, this.frustum.top - this.frustum.bottom) }; var xet = new F; jt.prototype.lookAt = function (e, t) { let n = It.eastNorthUpToFixedFrame(e, ie.WGS84, xet); this.lookAtTransform(n, t) }; var Tet = new h, Eet = new Be, bet = new Be, wet = new Q; function Sme(e, t, n) { t = I.clamp(t, -I.PI_OVER_TWO, I.PI_OVER_TWO), e = I.zeroToTwoPi(e) - I.PI_OVER_TWO; let i = Be.fromAxisAngle(h.UNIT_Y, -t, Eet), o = Be.fromAxisAngle(h.UNIT_Z, -e, bet), r = Be.multiply(o, i, o), s = Q.fromQuaternion(r, wet), a = h.clone(h.UNIT_X, Tet); return Q.multiplyByVector(s, a, a), h.negate(a, a), h.multiplyByScalar(a, n, a), a } jt.prototype.lookAtTransform = function (e, t) { if (this._setTransform(e), !l(t)) return; let n; if (l(t.heading) ? n = Sme(t.heading, t.pitch, t.range) : n = t, this._mode === ee.SCENE2D) { H.clone(H.ZERO, this.position), h.negate(n, this.up), this.up.z = 0, h.magnitudeSquared(this.up) < I.EPSILON10 && h.clone(h.UNIT_Y, this.up), h.normalize(this.up, this.up), this._setTransform(F.IDENTITY), h.negate(h.UNIT_Z, this.direction), h.cross(this.direction, this.up, this.right), h.normalize(this.right, this.right); let i = this.frustum, o = i.top / i.right; i.right = h.magnitude(n) * .5, i.left = -i.right, i.top = o * i.right, i.bottom = -i.top, this._setTransform(e); return } h.clone(n, this.position), h.negate(this.position, this.direction), h.normalize(this.direction, this.direction), h.cross(this.direction, h.UNIT_Z, this.right), h.magnitudeSquared(this.right) < I.EPSILON10 && h.clone(h.UNIT_X, this.right), h.normalize(this.right, this.right), h.cross(this.right, this.direction, this.up), h.normalize(this.up, this.up), this._adjustOrthographicFrustum(!0) }; var WD = new he, Det = new he, vet = new h, Pet = new h, Iet = new h, Oet = new h, Bet = new h, Ret = new h, Met = new h, R7 = new h, Let = { direction: new h, right: new h, up: new h }, lme; function Na(e, t, n, i) { return Math.abs(h.dot(t, n)) / i - h.dot(e, n) } function wme(e, t, n, i) { let o = e._projection.ellipsoid, r = i ? e : Let, s = t.north, a = t.south, c = t.east, u = t.west; u > c && (c += I.TWO_PI); let f = (u + c) * .5, d; if (a < -I.PI_OVER_TWO + I.RADIANS_PER_DEGREE && s > I.PI_OVER_TWO - I.RADIANS_PER_DEGREE) d = 0; else { let M = WD; M.longitude = f, M.latitude = s, M.height = 0; let L = Det; L.longitude = f, L.latitude = a, L.height = 0; let _ = lme; (!l(_) || _.ellipsoid !== o) && (lme = _ = new mf(void 0, void 0, o)), _.setEndPoints(M, L), d = _.interpolateUsingFraction(.5, WD).latitude } let p = WD; p.longitude = f, p.latitude = d, p.height = 0; let g = o.cartographicToCartesian(p, Met), m = WD; m.longitude = c, m.latitude = s; let A = o.cartographicToCartesian(m, vet); m.longitude = u; let C = o.cartographicToCartesian(m, Iet); m.longitude = f; let x = o.cartographicToCartesian(m, Bet); m.latitude = a; let T = o.cartographicToCartesian(m, Ret); m.longitude = c; let b = o.cartographicToCartesian(m, Oet); m.longitude = u; let S = o.cartographicToCartesian(m, Pet); h.subtract(C, g, C), h.subtract(b, g, b), h.subtract(A, g, A), h.subtract(S, g, S), h.subtract(x, g, x), h.subtract(T, g, T); let D = o.geodeticSurfaceNormal(g, r.direction); h.negate(D, D); let P = h.cross(D, h.UNIT_Z, r.right); h.normalize(P, P); let B = h.cross(P, D, r.up), R; if (e.frustum instanceof Zt) { let M = Math.max(h.distance(A, C), h.distance(b, S)), L = Math.max(h.distance(A, b), h.distance(C, S)), _, E, w = e.frustum._offCenterFrustum.right / e.frustum._offCenterFrustum.top, v = L * w; M > v ? (_ = M, E = _ / w) : (E = L, _ = v), R = Math.max(_, E) } else { let M = Math.tan(e.frustum.fovy * .5), L = e.frustum.aspectRatio * M; if (R = Math.max(Na(D, B, C, M), Na(D, B, b, M), Na(D, B, A, M), Na(D, B, S, M), Na(D, B, x, M), Na(D, B, T, M), Na(D, P, C, L), Na(D, P, b, L), Na(D, P, A, L), Na(D, P, S, L), Na(D, P, x, L), Na(D, P, T, L)), a < 0 && s > 0) { let _ = WD; _.longitude = u, _.latitude = 0, _.height = 0; let E = o.cartographicToCartesian(_, R7); h.subtract(E, g, E), R = Math.max(R, Na(D, B, E, M), Na(D, P, E, L)), _.longitude = c, E = o.cartographicToCartesian(_, R7), h.subtract(E, g, E), R = Math.max(R, Na(D, B, E, M), Na(D, P, E, L)) } } return h.add(g, h.multiplyByScalar(D, -R, R7), n) } var Fet = new he, Net = new h, Vet = new h; function ket(e, t, n) { let i = e._projection; t.west > t.east && (t = ce.MAX_VALUE); let o = e._actualTransform, r = e._actualInvTransform, s = Fet; s.longitude = t.east, s.latitude = t.north; let a = i.project(s, Net); F.multiplyByPoint(o, a, a), F.multiplyByPoint(r, a, a), s.longitude = t.west, s.latitude = t.south; let c = i.project(s, Vet); if (F.multiplyByPoint(o, c, c), F.multiplyByPoint(r, c, c), n.x = (a.x - c.x) * .5 + c.x, n.y = (a.y - c.y) * .5 + c.y, l(e.frustum.fovy)) { let u = Math.tan(e.frustum.fovy * .5), f = e.frustum.aspectRatio * u; n.z = Math.max((a.x - c.x) / f, (a.y - c.y) / u) * .5 } else { let u = a.x - c.x, f = a.y - c.y; n.z = Math.max(u, f) } return n } var Uet = new he, zet = new h, Het = new h; function Get(e, t, n) { let i = e._projection, o = t.east; t.west > t.east && (e._scene.mapMode2D === Ul.INFINITE_SCROLL ? o += I.TWO_PI : (t = ce.MAX_VALUE, o = t.east)); let r = Uet; r.longitude = o, r.latitude = t.north; let s = i.project(r, zet); r.longitude = t.west, r.latitude = t.south; let a = i.project(r, Het), c = Math.abs(s.x - a.x) * .5, u = Math.abs(s.y - a.y) * .5, f, d, p = e.frustum.right / e.frustum.top, g = u * p; return c > g ? (f = c, d = f / p) : (d = u, f = g), u = Math.max(2 * f, 2 * d), n.x = (s.x - a.x) * .5 + a.x, n.y = (s.y - a.y) * .5 + a.y, r = i.unproject(n, r), r.height = u, n = i.project(r, n), n } jt.prototype.getRectangleCameraCoordinates = function (e, t) { let n = this._mode; if (l(t) || (t = new h), n === ee.SCENE3D) return wme(this, e, t); if (n === ee.COLUMBUS_VIEW) return ket(this, e, t); if (n === ee.SCENE2D) return Get(this, e, t) }; var Wet = new En; function jet(e, t, n, i) { n = y(n, ie.WGS84); let o = e.getPickRay(t, Wet), r = Gi.rayEllipsoid(o, n); if (!r) return; let s = r.start > 0 ? r.start : r.stop; return En.getPoint(o, s, i) } var qet = new En; function Yet(e, t, n, i) { let r = e.getPickRay(t, qet).origin; r = h.fromElements(r.y, r.z, 0, r); let s = n.unproject(r); if (!(s.latitude < -I.PI_OVER_TWO || s.latitude > I.PI_OVER_TWO)) return n.ellipsoid.cartographicToCartesian(s, i) } var Xet = new En; function Ket(e, t, n, i) { let o = e.getPickRay(t, Xet), r = -o.origin.x / o.direction.x; En.getPoint(o, r, i); let s = n.unproject(new h(i.y, i.z, 0)); if (!(s.latitude < -I.PI_OVER_TWO || s.latitude > I.PI_OVER_TWO || s.longitude < -Math.PI || s.longitude > Math.PI)) return n.ellipsoid.cartographicToCartesian(s, i) } jt.prototype.pickEllipsoid = function (e, t, n) { let i = this._scene.canvas; if (!(i.clientWidth === 0 || i.clientHeight === 0)) { if (l(n) || (n = new h), t = y(t, ie.WGS84), this._mode === ee.SCENE3D) n = jet(this, e, t, n); else if (this._mode === ee.SCENE2D) n = Yet(this, e, this._projection, n); else if (this._mode === ee.COLUMBUS_VIEW) n = Ket(this, e, this._projection, n); else return; return n } }; var Jet = new h, Zet = new h, Qet = new h; function $et(e, t, n) { let i = e._scene.canvas, o = i.clientWidth, r = i.clientHeight, s = Math.tan(e.frustum.fovy * .5), a = e.frustum.aspectRatio * s, c = e.frustum.near, u = 2 / o * t.x - 1, f = 2 / r * (r - t.y) - 1, d = e.positionWC; h.clone(d, n.origin); let p = h.multiplyByScalar(e.directionWC, c, Jet); h.add(d, p, p); let g = h.multiplyByScalar(e.rightWC, u * c * a, Zet), m = h.multiplyByScalar(e.upWC, f * c * s, Qet), A = h.add(p, g, n.direction); return h.add(A, m, A), h.subtract(A, d, A), h.normalize(A, A), n } var AV = new h; function ett(e, t, n) { let i = e._scene.canvas, o = i.clientWidth, r = i.clientHeight, s = e.frustum; l(s._offCenterFrustum) && (s = s._offCenterFrustum); let a = 2 / o * t.x - 1; a *= (s.right - s.left) * .5; let c = 2 / r * (r - t.y) - 1; c *= (s.top - s.bottom) * .5; let u = n.origin; return h.clone(e.position, u), h.multiplyByScalar(e.right, a, AV), h.add(AV, u, u), h.multiplyByScalar(e.up, c, AV), h.add(AV, u, u), h.clone(e.directionWC, n.direction), (e._mode === ee.COLUMBUS_VIEW || e._mode === ee.SCENE2D) && h.fromElements(n.origin.z, n.origin.x, n.origin.y, n.origin), n } jt.prototype.getPickRay = function (e, t) { l(t) || (t = new En); let n = this._scene.canvas; if (n.clientWidth <= 0 || n.clientHeight <= 0) return; let i = this.frustum; return l(i.aspectRatio) && l(i.fov) && l(i.near) ? $et(this, e, t) : ett(this, e, t) }; var ttt = new h, ntt = new h; jt.prototype.distanceToBoundingSphere = function (e) { let t = h.subtract(this.positionWC, e.center, ttt), n = h.multiplyByScalar(this.directionWC, h.dot(t, this.directionWC), ntt); return Math.max(0, h.magnitude(n) - e.radius) }; var itt = new H; jt.prototype.getPixelSize = function (e, t, n) { let i = this.distanceToBoundingSphere(e), o = this.frustum.getPixelDimensions(t, n, i, this._scene.pixelRatio, itt); return Math.max(o.x, o.y) }; function ott(e, t, n, i, o, r) { let s = h.clone(t); n.y > i ? s.y -= n.y - i : n.y < -i && (s.y += -i - n.y), n.z > o ? s.z -= n.z - o : n.z < -o && (s.z += -o - n.z); function a(c) { let u = h.lerp(t, s, c.time, new h); e.worldToCameraCoordinatesPoint(u, e.position) } return { easingFunction: Mr.EXPONENTIAL_OUT, startObject: { time: 0 }, stopObject: { time: 1 }, duration: r, update: a } } var rtt = new h, ume = new h, stt = new h, att = new h; function ctt(e, t) { let n = e.position, i = e.direction, o = e.worldToCameraCoordinatesVector(h.UNIT_X, rtt), r = -h.dot(o, n) / h.dot(o, i), s = h.add(n, h.multiplyByScalar(i, r, ume), ume); e.cameraToWorldCoordinatesPoint(s, s), n = e.cameraToWorldCoordinatesPoint(e.position, stt); let a = Math.tan(e.frustum.fovy * .5), c = e.frustum.aspectRatio * a, u = h.magnitude(h.subtract(n, s, att)), f = c * u, d = a * u, p = e._maxCoord.x, g = e._maxCoord.y, m = Math.max(f - p, p), A = Math.max(d - g, g); if (n.z < -m || n.z > m || n.y < -A || n.y > A) { let C = s.y < -m || s.y > m, x = s.z < -A || s.z > A; if (C || x) return ott(e, n, s, m, A, t) } } jt.prototype.createCorrectPositionTween = function (e) { if (this._mode === ee.COLUMBUS_VIEW) return ctt(this, e) }; var ltt = new h, ps = { destination: void 0, heading: void 0, pitch: void 0, roll: void 0, duration: void 0, complete: void 0, cancel: void 0, endTransform: void 0, maximumHeight: void 0, easingFunction: void 0 }; jt.prototype.cancelFlight = function () { l(this._currentFlight) && (this._currentFlight.cancelTween(), this._currentFlight = void 0) }; jt.prototype.completeFlight = function () { if (l(this._currentFlight)) { this._currentFlight.cancelTween(); let e = { destination: void 0, orientation: { heading: void 0, pitch: void 0, roll: void 0 } }; e.destination = ps.destination, e.orientation.heading = ps.heading, e.orientation.pitch = ps.pitch, e.orientation.roll = ps.roll, this.setView(e), l(this._currentFlight.complete) && this._currentFlight.complete(), this._currentFlight = void 0 } }; jt.prototype.flyTo = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.destination; if (this._mode === ee.MORPHING) return; this.cancelFlight(); let i = t instanceof ce; i && (t = this.getRectangleCameraCoordinates(t, ltt)); let o = y(e.orientation, y.EMPTY_OBJECT); if (l(o.direction) && (o = Cme(this, t, o, F7.orientation)), l(e.duration) && e.duration <= 0) { let f = F7; f.destination = e.destination, f.orientation.heading = o.heading, f.orientation.pitch = o.pitch, f.orientation.roll = o.roll, f.convert = e.convert, f.endTransform = e.endTransform, this.setView(f), typeof e.complete == "function" && e.complete(); return } let r = this, s; ps.destination = t, ps.heading = o.heading, ps.pitch = o.pitch, ps.roll = o.roll, ps.duration = e.duration, ps.complete = function () { s === r._currentFlight && (r._currentFlight = void 0), l(e.complete) && e.complete() }, ps.cancel = e.cancel, ps.endTransform = e.endTransform, ps.convert = i ? !1 : e.convert, ps.maximumHeight = e.maximumHeight, ps.pitchAdjustHeight = e.pitchAdjustHeight, ps.flyOverLongitude = e.flyOverLongitude, ps.flyOverLongitudeWeight = e.flyOverLongitudeWeight, ps.easingFunction = e.easingFunction; let a = this._scene, c = gV.createTween(a, ps); if (c.duration === 0) { typeof c.complete == "function" && c.complete(); return } s = a.tweens.add(c), this._currentFlight = s; let u = this._scene.preloadFlightCamera; this._mode !== ee.SCENE2D && (l(u) || (u = jt.clone(this)), u.setView({ destination: t, orientation: o }), this._scene.preloadFlightCullingVolume = u.frustum.computeCullingVolume(u.positionWC, u.directionWC, u.upWC)) }; function utt(e, t) { let n = e.frustum, i = Math.tan(n.fovy * .5), o = n.aspectRatio * i; return Math.max(t / o, t / i) } function ftt(e, t) { let n = e.frustum; l(n._offCenterFrustum) && (n = n._offCenterFrustum); let i, o, r = n.right / n.top, s = t * r; return t > s ? (i = t, o = i / r) : (o = t, i = s), Math.max(i, o) * 1.5 } var dtt = 100; function Dme(e, t, n) { n = ku.clone(l(n) ? n : jt.DEFAULT_OFFSET); let i = e._scene.screenSpaceCameraController.minimumZoomDistance, o = e._scene.screenSpaceCameraController.maximumZoomDistance, r = n.range; if (!l(r) || r === 0) { let s = t.radius; s === 0 ? n.range = dtt : e.frustum instanceof Zt || e._mode === ee.SCENE2D ? n.range = ftt(e, s) : n.range = utt(e, s), n.range = I.clamp(n.range, i, o) } return n } jt.prototype.viewBoundingSphere = function (e, t) { t = Dme(this, e, t), this.lookAt(e.center, t) }; var htt = new F, mtt = new h, ptt = new h, _tt = new h, gtt = new h, ytt = new se, Att = new Be, Ctt = new Q; jt.prototype.flyToBoundingSphere = function (e, t) { t = y(t, y.EMPTY_OBJECT); let n = this._mode === ee.SCENE2D || this._mode === ee.COLUMBUS_VIEW; this._setTransform(F.IDENTITY); let i = Dme(this, e, t.offset), o; n ? o = h.multiplyByScalar(h.UNIT_Z, i.range, mtt) : o = Sme(i.heading, i.pitch, i.range); let r = It.eastNorthUpToFixedFrame(e.center, ie.WGS84, htt); F.multiplyByPoint(r, o, o); let s, a; if (!n) { if (s = h.subtract(e.center, o, ptt), h.normalize(s, s), a = F.multiplyByPointAsVector(r, h.UNIT_Z, _tt), 1 - Math.abs(h.dot(s, a)) < I.EPSILON6) { let u = Be.fromAxisAngle(s, i.heading, Att), f = Q.fromQuaternion(u, Ctt); h.fromCartesian4(F.getColumn(r, 1, ytt), a), Q.multiplyByVector(f, a, a) } let c = h.cross(s, a, gtt); h.cross(c, s, a), h.normalize(a, a) } this.flyTo({ destination: o, orientation: { direction: s, up: a }, duration: t.duration, complete: t.complete, cancel: t.cancel, endTransform: t.endTransform, maximumHeight: t.maximumHeight, easingFunction: t.easingFunction, flyOverLongitude: t.flyOverLongitude, flyOverLongitudeWeight: t.flyOverLongitudeWeight, pitchAdjustHeight: t.pitchAdjustHeight }) }; var fme = new h, dme = new h, M7 = new h, hme = new h, jD = [new h, new h, new h, new h]; function xtt(e, t) { let n = t.radii, i = e.positionWC, o = h.multiplyComponents(t.oneOverRadii, i, fme), r = h.magnitude(o), s = h.normalize(o, dme), a, c; h.equalsEpsilon(s, h.UNIT_Z, I.EPSILON10) ? (a = new h(0, 1, 0), c = new h(0, 0, 1)) : (a = h.normalize(h.cross(h.UNIT_Z, s, M7), M7), c = h.normalize(h.cross(s, a, hme), hme)); let u = Math.sqrt(h.magnitudeSquared(o) - 1), f = h.multiplyByScalar(s, 1 / r, fme), d = u / r, p = h.multiplyByScalar(a, d, dme), g = h.multiplyByScalar(c, d, M7), m = h.add(f, g, jD[0]); h.subtract(m, p, m), h.multiplyComponents(n, m, m); let A = h.subtract(f, g, jD[1]); h.subtract(A, p, A), h.multiplyComponents(n, A, A); let C = h.subtract(f, g, jD[2]); h.add(C, p, C), h.multiplyComponents(n, C, C); let x = h.add(f, g, jD[3]); return h.add(x, p, x), h.multiplyComponents(n, x, x), jD } var L7 = new H, Ttt = new h, Lg = [new he, new he, new he, new he]; function CV(e, t, n, i, o, r) { L7.x = e, L7.y = t; let s = i.pickEllipsoid(L7, o, Ttt); return l(s) ? (Lg[n] = o.cartesianToCartographic(s, Lg[n]), 1) : (Lg[n] = o.cartesianToCartographic(r[n], Lg[n]), 0) } jt.prototype.computeViewRectangle = function (e, t) { e = y(e, ie.WGS84); let n = this.frustum.computeCullingVolume(this.positionWC, this.directionWC, this.upWC), i = new re(h.ZERO, e.maximumRadius); if (n.computeVisibility(i) === Kt.OUTSIDE) return; let r = this._scene.canvas, s = r.clientWidth, a = r.clientHeight, c = 0, u = xtt(this, e); if (c += CV(0, 0, 0, this, e, u), c += CV(0, a, 1, this, e, u), c += CV(s, a, 2, this, e, u), c += CV(s, 0, 3, this, e, u), c < 2) return ce.MAX_VALUE; t = ce.fromCartographicArray(Lg, t); let f = 0, d = Lg[3].longitude; for (let p = 0; p < 4; ++p) { let g = Lg[p].longitude, m = Math.abs(g - d); m > I.PI ? f += I.TWO_PI - m : f += m, d = g } return I.equalsEpsilon(Math.abs(f), I.TWO_PI, I.EPSILON9) && (t.west = -I.PI, t.east = I.PI, Lg[0].latitude >= 0 ? t.north = I.PI_OVER_TWO : t.south = -I.PI_OVER_TWO), t }; jt.prototype.switchToPerspectiveFrustum = function () { if (this._mode === ee.SCENE2D || this.frustum instanceof mi) return; let e = this._scene; this.frustum = new mi, this.frustum.aspectRatio = e.drawingBufferWidth / e.drawingBufferHeight, this.frustum.fov = I.toRadians(60) }; jt.prototype.switchToOrthographicFrustum = function () { if (this._mode === ee.SCENE2D || this.frustum instanceof Zt) return; let e = yme(this), t = this._scene; this.frustum = new Zt, this.frustum.aspectRatio = t.drawingBufferWidth / t.drawingBufferHeight, this.frustum.width = e }; jt.clone = function (e, t) { return l(t) || (t = new jt(e._scene)), h.clone(e.position, t.position), h.clone(e.direction, t.direction), h.clone(e.up, t.up), h.clone(e.right, t.right), F.clone(e._transform, t.transform), t._transformChanged = !0, t.frustum = e.frustum.clone(), t }; var oo = jt; var Ett = { LEFT_DRAG: 0, RIGHT_DRAG: 1, MIDDLE_DRAG: 2, WHEEL: 3, PINCH: 4 }, wi = Object.freeze(Ett); function ka(e, t) { let n = e; return l(t) && (n += `+${t}`), n } function btt(e, t) { H.clone(e.distance.startPosition, t.distance.startPosition), H.clone(e.distance.endPosition, t.distance.endPosition), H.clone(e.angleAndHeight.startPosition, t.angleAndHeight.startPosition), H.clone(e.angleAndHeight.endPosition, t.angleAndHeight.endPosition) } function vme(e, t, n) { let i = ka(wi.PINCH, t), o = e._update, r = e._isDown, s = e._eventStartPosition, a = e._pressTime, c = e._releaseTime; o[i] = !0, r[i] = !1, s[i] = new H; let u = e._movement[i]; l(u) || (u = e._movement[i] = {}), u.distance = { startPosition: new H, endPosition: new H }, u.angleAndHeight = { startPosition: new H, endPosition: new H }, u.prevAngle = 0, e._eventHandler.setInputAction(function (f) { e._buttonsDown++, r[i] = !0, a[i] = new Date, H.lerp(f.position1, f.position2, .5, s[i]) }, pn.PINCH_START, t), e._eventHandler.setInputAction(function () { e._buttonsDown = Math.max(e._buttonsDown - 1, 0), r[i] = !1, c[i] = new Date }, pn.PINCH_END, t), e._eventHandler.setInputAction(function (f) { if (r[i]) { o[i] ? (btt(f, u), o[i] = !1, u.prevAngle = u.angleAndHeight.startPosition.x) : (H.clone(f.distance.endPosition, u.distance.endPosition), H.clone(f.angleAndHeight.endPosition, u.angleAndHeight.endPosition)); let d = u.angleAndHeight.endPosition.x, p = u.prevAngle, g = Math.PI * 2; for (; d >= p + Math.PI;)d -= g; for (; d < p - Math.PI;)d += g; u.angleAndHeight.endPosition.x = -d * n.clientWidth / 12, u.angleAndHeight.startPosition.x = -p * n.clientWidth / 12 } }, pn.PINCH_MOVE, t) } function Pme(e, t) { let n = ka(wi.WHEEL, t), i = e._update; i[n] = !0; let o = e._movement[n]; l(o) || (o = e._movement[n] = {}), o.startPosition = new H, o.endPosition = new H, e._eventHandler.setInputAction(function (r) { let s = 15 * I.toRadians(r); i[n] ? (H.clone(H.ZERO, o.startPosition), o.endPosition.x = 0, o.endPosition.y = s, i[n] = !1) : o.endPosition.y = o.endPosition.y + s }, pn.WHEEL, t) } function AE(e, t, n) { let i = ka(n, t), o = e._isDown, r = e._eventStartPosition, s = e._pressTime, a = e._releaseTime; o[i] = !1, r[i] = new H; let c = e._lastMovement[i]; l(c) || (c = e._lastMovement[i] = { startPosition: new H, endPosition: new H, valid: !1 }); let u, f; n === wi.LEFT_DRAG ? (u = pn.LEFT_DOWN, f = pn.LEFT_UP) : n === wi.RIGHT_DRAG ? (u = pn.RIGHT_DOWN, f = pn.RIGHT_UP) : n === wi.MIDDLE_DRAG && (u = pn.MIDDLE_DOWN, f = pn.MIDDLE_UP), e._eventHandler.setInputAction(function (d) { e._buttonsDown++, c.valid = !1, o[i] = !0, s[i] = new Date, H.clone(d.position, r[i]) }, u, t), e._eventHandler.setInputAction(function () { e._buttonsDown = Math.max(e._buttonsDown - 1, 0), o[i] = !1, a[i] = new Date }, f, t) } function Ime(e, t) { H.clone(e.startPosition, t.startPosition), H.clone(e.endPosition, t.endPosition) } function Ome(e, t) { let n = e._update, i = e._movement, o = e._lastMovement, r = e._isDown; for (let s in wi) if (wi.hasOwnProperty(s)) { let a = wi[s]; if (l(a)) { let c = ka(a, t); n[c] = !0, l(e._lastMovement[c]) || (e._lastMovement[c] = { startPosition: new H, endPosition: new H, valid: !1 }), l(e._movement[c]) || (e._movement[c] = { startPosition: new H, endPosition: new H }) } } e._eventHandler.setInputAction(function (s) { for (let a in wi) if (wi.hasOwnProperty(a)) { let c = wi[a]; if (l(c)) { let u = ka(c, t); r[u] && (n[u] ? (Ime(i[u], o[u]), o[u].valid = !0, Ime(s, i[u]), n[u] = !1) : H.clone(s.endPosition, i[u].endPosition)) } } H.clone(s.endPosition, e._currentMousePosition) }, pn.MOUSE_MOVE, t) } function Ku(e) { this._eventHandler = new Xu(e), this._update = {}, this._movement = {}, this._lastMovement = {}, this._isDown = {}, this._eventStartPosition = {}, this._pressTime = {}, this._releaseTime = {}, this._buttonsDown = 0, this._currentMousePosition = new H, Pme(this, void 0), vme(this, void 0, e), AE(this, void 0, wi.LEFT_DRAG), AE(this, void 0, wi.RIGHT_DRAG), AE(this, void 0, wi.MIDDLE_DRAG), Ome(this, void 0); for (let t in oa) if (oa.hasOwnProperty(t)) { let n = oa[t]; l(n) && (Pme(this, n), vme(this, n, e), AE(this, n, wi.LEFT_DRAG), AE(this, n, wi.RIGHT_DRAG), AE(this, n, wi.MIDDLE_DRAG), Ome(this, n)) } } Object.defineProperties(Ku.prototype, { currentMousePosition: { get: function () { return this._currentMousePosition } }, anyButtonDown: { get: function () { let e = !this._update[ka(wi.WHEEL)] || !this._update[ka(wi.WHEEL, oa.SHIFT)] || !this._update[ka(wi.WHEEL, oa.CTRL)] || !this._update[ka(wi.WHEEL, oa.ALT)]; return this._buttonsDown > 0 || e } } }); Ku.prototype.isMoving = function (e, t) { let n = ka(e, t); return !this._update[n] }; Ku.prototype.getMovement = function (e, t) { let n = ka(e, t); return this._movement[n] }; Ku.prototype.getLastMovement = function (e, t) { let n = ka(e, t), i = this._lastMovement[n]; if (i.valid) return i }; Ku.prototype.isButtonDown = function (e, t) { let n = ka(e, t); return this._isDown[n] }; Ku.prototype.getStartMousePosition = function (e, t) { if (e === wi.WHEEL) return this._currentMousePosition; let n = ka(e, t); return this._eventStartPosition[n] }; Ku.prototype.getButtonPressTime = function (e, t) { let n = ka(e, t); return this._pressTime[n] }; Ku.prototype.getButtonReleaseTime = function (e, t) { let n = ka(e, t); return this._releaseTime[n] }; Ku.prototype.reset = function () { for (let e in this._update) this._update.hasOwnProperty(e) && (this._update[e] = !0) }; Ku.prototype.isDestroyed = function () { return !1 }; Ku.prototype.destroy = function () { return this._eventHandler = this._eventHandler && this._eventHandler.destroy(), le(this) }; var SV = Ku; function up() { this.featurePropertiesDirty = !1 } Object.defineProperties(up.prototype, { featuresLength: { get: function () { ye.throwInstantiationError() } }, pointsLength: { get: function () { ye.throwInstantiationError() } }, trianglesLength: { get: function () { ye.throwInstantiationError() } }, geometryByteLength: { get: function () { ye.throwInstantiationError() } }, texturesByteLength: { get: function () { ye.throwInstantiationError() } }, batchTableByteLength: { get: function () { ye.throwInstantiationError() } }, innerContents: { get: function () { ye.throwInstantiationError() } }, readyPromise: { get: function () { ye.throwInstantiationError() } }, tileset: { get: function () { ye.throwInstantiationError() } }, tile: { get: function () { ye.throwInstantiationError() } }, url: { get: function () { ye.throwInstantiationError() } }, batchTable: { get: function () { ye.throwInstantiationError() } }, metadata: { get: function () { ye.throwInstantiationError() }, set: function (e) { ye.throwInstantiationError() } }, group: { get: function () { ye.throwInstantiationError() }, set: function (e) { ye.throwInstantiationError() } } }); up.prototype.hasProperty = function (e, t) { ye.throwInstantiationError() }; up.prototype.getFeature = function (e) { ye.throwInstantiationError() }; up.prototype.applyDebugSettings = function (e, t) { ye.throwInstantiationError() }; up.prototype.applyStyle = function (e) { ye.throwInstantiationError() }; up.prototype.update = function (e, t) { ye.throwInstantiationError() }; up.prototype.isDestroyed = function () { ye.throwInstantiationError() }; up.prototype.destroy = function () { ye.throwInstantiationError() }; var Bme = up; function Stt(e) { this.pass = e.pass, this.commandList = e.commandList, this.camera = e.camera, this.cullingVolume = e.cullingVolume, this.ready = !1 } var ad = Stt; function CE(e, t) { this._conditionsExpression = tt(e, !0), this._conditions = e.conditions, this._runtimeConditions = void 0, Dtt(this, t) } Object.defineProperties(CE.prototype, { conditionsExpression: { get: function () { return this._conditionsExpression } } }); function wtt(e, t) { this.condition = e, this.expression = t } function Dtt(e, t) { let n = [], i = e._conditions; if (!l(i)) return; let o = i.length; for (let r = 0; r < o; ++r) { let s = i[r], a = String(s[0]), c = String(s[1]); n.push(new wtt(new gf(a, t), new gf(c, t))) } e._runtimeConditions = n } CE.prototype.evaluate = function (e, t) { let n = this._runtimeConditions; if (!l(n)) return; let i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; if (r.condition.evaluate(e)) return r.expression.evaluate(e, t) } }; CE.prototype.evaluateColor = function (e, t) { let n = this._runtimeConditions; if (!l(n)) return; let i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; if (r.condition.evaluate(e)) return r.expression.evaluateColor(e, t) } }; CE.prototype.getShaderFunction = function (e, t, n, i) {
        let o = this._runtimeConditions; if (!l(o) || o.length === 0) return; let r = "", s = o.length; for (let a = 0; a < s; ++a) {
            let c = o[a], u = c.condition.getShaderExpression(t, n), f = c.expression.getShaderExpression(t, n); r += `    ${a === 0 ? "if" : "else if"} (${u})
    {
        return ${f};
    }
`} return r = `${i} ${e}
{
${r}    return ${i}(1.0);
}
`, r
    }; CE.prototype.getVariables = function () { let e = [], t = this._runtimeConditions; if (!l(t) || t.length === 0) return e; let n = t.length; for (let i = 0; i < n; ++i) { let o = t[i]; e.push.apply(e, o.condition.getVariables()), e.push.apply(e, o.expression.getVariables()) } return e = e.filter(function (i, o, r) { return r.indexOf(i) === o }), e }; var wV = CE; function Fg(e) { this._style = {}, this._ready = !1, this._show = void 0, this._color = void 0, this._pointSize = void 0, this._pointOutlineColor = void 0, this._pointOutlineWidth = void 0, this._labelColor = void 0, this._labelOutlineColor = void 0, this._labelOutlineWidth = void 0, this._font = void 0, this._labelStyle = void 0, this._labelText = void 0, this._backgroundColor = void 0, this._backgroundPadding = void 0, this._backgroundEnabled = void 0, this._scaleByDistance = void 0, this._translucencyByDistance = void 0, this._distanceDisplayCondition = void 0, this._heightOffset = void 0, this._anchorLineEnabled = void 0, this._anchorLineColor = void 0, this._image = void 0, this._disableDepthTestDistance = void 0, this._horizontalOrigin = void 0, this._verticalOrigin = void 0, this._labelHorizontalOrigin = void 0, this._labelVerticalOrigin = void 0, this._meta = void 0, this._colorShaderFunction = void 0, this._showShaderFunction = void 0, this._pointSizeShaderFunction = void 0, this._colorShaderFunctionReady = !1, this._showShaderFunctionReady = !1, this._pointSizeShaderFunctionReady = !1, this._colorShaderTranslucent = !1, vtt(this, e) } function vtt(e, t) { t = y(tt(t, !0), e._style), e._style = t, e.show = t.show, e.color = t.color, e.pointSize = t.pointSize, e.pointOutlineColor = t.pointOutlineColor, e.pointOutlineWidth = t.pointOutlineWidth, e.labelColor = t.labelColor, e.labelOutlineColor = t.labelOutlineColor, e.labelOutlineWidth = t.labelOutlineWidth, e.labelStyle = t.labelStyle, e.font = t.font, e.labelText = t.labelText, e.backgroundColor = t.backgroundColor, e.backgroundPadding = t.backgroundPadding, e.backgroundEnabled = t.backgroundEnabled, e.scaleByDistance = t.scaleByDistance, e.translucencyByDistance = t.translucencyByDistance, e.distanceDisplayCondition = t.distanceDisplayCondition, e.heightOffset = t.heightOffset, e.anchorLineEnabled = t.anchorLineEnabled, e.anchorLineColor = t.anchorLineColor, e.image = t.image, e.disableDepthTestDistance = t.disableDepthTestDistance, e.horizontalOrigin = t.horizontalOrigin, e.verticalOrigin = t.verticalOrigin, e.labelHorizontalOrigin = t.labelHorizontalOrigin, e.labelVerticalOrigin = t.labelVerticalOrigin; let n = {}; if (l(t.meta)) { let i = t.defines, o = y(t.meta, y.EMPTY_OBJECT); for (let r in o) o.hasOwnProperty(r) && (n[r] = new gf(o[r], i)) } e._meta = n, e._ready = !0 } function Uo(e, t) { let n = y(e._style, y.EMPTY_OBJECT).defines; if (l(t)) { if (typeof t == "boolean" || typeof t == "number") return new gf(String(t)); if (typeof t == "string") return new gf(t, n); if (l(t.conditions)) return new wV(t, n) } else return; return t } function zo(e) { if (l(e)) { if (l(e.expression)) return e.expression; if (l(e.conditionsExpression)) return tt(e.conditionsExpression, !0) } else return; return e } Object.defineProperties(Fg.prototype, { style: { get: function () { return this._style } }, show: { get: function () { return this._show }, set: function (e) { this._show = Uo(this, e), this._style.show = zo(this._show), this._showShaderFunctionReady = !1 } }, color: { get: function () { return this._color }, set: function (e) { this._color = Uo(this, e), this._style.color = zo(this._color), this._colorShaderFunctionReady = !1 } }, pointSize: { get: function () { return this._pointSize }, set: function (e) { this._pointSize = Uo(this, e), this._style.pointSize = zo(this._pointSize), this._pointSizeShaderFunctionReady = !1 } }, pointOutlineColor: { get: function () { return this._pointOutlineColor }, set: function (e) { this._pointOutlineColor = Uo(this, e), this._style.pointOutlineColor = zo(this._pointOutlineColor) } }, pointOutlineWidth: { get: function () { return this._pointOutlineWidth }, set: function (e) { this._pointOutlineWidth = Uo(this, e), this._style.pointOutlineWidth = zo(this._pointOutlineWidth) } }, labelColor: { get: function () { return this._labelColor }, set: function (e) { this._labelColor = Uo(this, e), this._style.labelColor = zo(this._labelColor) } }, labelOutlineColor: { get: function () { return this._labelOutlineColor }, set: function (e) { this._labelOutlineColor = Uo(this, e), this._style.labelOutlineColor = zo(this._labelOutlineColor) } }, labelOutlineWidth: { get: function () { return this._labelOutlineWidth }, set: function (e) { this._labelOutlineWidth = Uo(this, e), this._style.labelOutlineWidth = zo(this._labelOutlineWidth) } }, font: { get: function () { return this._font }, set: function (e) { this._font = Uo(this, e), this._style.font = zo(this._font) } }, labelStyle: { get: function () { return this._labelStyle }, set: function (e) { this._labelStyle = Uo(this, e), this._style.labelStyle = zo(this._labelStyle) } }, labelText: { get: function () { return this._labelText }, set: function (e) { this._labelText = Uo(this, e), this._style.labelText = zo(this._labelText) } }, backgroundColor: { get: function () { return this._backgroundColor }, set: function (e) { this._backgroundColor = Uo(this, e), this._style.backgroundColor = zo(this._backgroundColor) } }, backgroundPadding: { get: function () { return this._backgroundPadding }, set: function (e) { this._backgroundPadding = Uo(this, e), this._style.backgroundPadding = zo(this._backgroundPadding) } }, backgroundEnabled: { get: function () { return this._backgroundEnabled }, set: function (e) { this._backgroundEnabled = Uo(this, e), this._style.backgroundEnabled = zo(this._backgroundEnabled) } }, scaleByDistance: { get: function () { return this._scaleByDistance }, set: function (e) { this._scaleByDistance = Uo(this, e), this._style.scaleByDistance = zo(this._scaleByDistance) } }, translucencyByDistance: { get: function () { return this._translucencyByDistance }, set: function (e) { this._translucencyByDistance = Uo(this, e), this._style.translucencyByDistance = zo(this._translucencyByDistance) } }, distanceDisplayCondition: { get: function () { return this._distanceDisplayCondition }, set: function (e) { this._distanceDisplayCondition = Uo(this, e), this._style.distanceDisplayCondition = zo(this._distanceDisplayCondition) } }, heightOffset: { get: function () { return this._heightOffset }, set: function (e) { this._heightOffset = Uo(this, e), this._style.heightOffset = zo(this._heightOffset) } }, anchorLineEnabled: { get: function () { return this._anchorLineEnabled }, set: function (e) { this._anchorLineEnabled = Uo(this, e), this._style.anchorLineEnabled = zo(this._anchorLineEnabled) } }, anchorLineColor: { get: function () { return this._anchorLineColor }, set: function (e) { this._anchorLineColor = Uo(this, e), this._style.anchorLineColor = zo(this._anchorLineColor) } }, image: { get: function () { return this._image }, set: function (e) { this._image = Uo(this, e), this._style.image = zo(this._image) } }, disableDepthTestDistance: { get: function () { return this._disableDepthTestDistance }, set: function (e) { this._disableDepthTestDistance = Uo(this, e), this._style.disableDepthTestDistance = zo(this._disableDepthTestDistance) } }, horizontalOrigin: { get: function () { return this._horizontalOrigin }, set: function (e) { this._horizontalOrigin = Uo(this, e), this._style.horizontalOrigin = zo(this._horizontalOrigin) } }, verticalOrigin: { get: function () { return this._verticalOrigin }, set: function (e) { this._verticalOrigin = Uo(this, e), this._style.verticalOrigin = zo(this._verticalOrigin) } }, labelHorizontalOrigin: { get: function () { return this._labelHorizontalOrigin }, set: function (e) { this._labelHorizontalOrigin = Uo(this, e), this._style.labelHorizontalOrigin = zo(this._labelHorizontalOrigin) } }, labelVerticalOrigin: { get: function () { return this._labelVerticalOrigin }, set: function (e) { this._labelVerticalOrigin = Uo(this, e), this._style.labelVerticalOrigin = zo(this._labelVerticalOrigin) } }, meta: { get: function () { return this._meta }, set: function (e) { this._meta = e } } }); Fg.fromUrl = function (e) { return Pe.createIfNeeded(e).fetchJson(e).then(function (n) { return new Fg(n) }) }; Fg.prototype.getColorShaderFunction = function (e, t, n) { return this._colorShaderFunctionReady ? (n.translucent = this._colorShaderTranslucent, this._colorShaderFunction) : (this._colorShaderFunctionReady = !0, l(this.color) && l(this.color.getShaderFunction) ? this._colorShaderFunction = this.color.getShaderFunction(e, t, n, "vec4") : this._colorShaderFunction = void 0, this._colorShaderTranslucent = n.translucent, this._colorShaderFunction) }; Fg.prototype.getShowShaderFunction = function (e, t, n) { return this._showShaderFunctionReady ? this._showShaderFunction : (this._showShaderFunctionReady = !0, l(this.show) && l(this.show.getShaderFunction) ? this._showShaderFunction = this.show.getShaderFunction(e, t, n, "bool") : this._showShaderFunction = void 0, this._showShaderFunction) }; Fg.prototype.getPointSizeShaderFunction = function (e, t, n) { return this._pointSizeShaderFunctionReady ? this._pointSizeShaderFunction : (this._pointSizeShaderFunctionReady = !0, l(this.pointSize) && l(this.pointSize.getShaderFunction) ? this._pointSizeShaderFunction = this.pointSize.getShaderFunction(e, t, n, "float") : this._pointSizeShaderFunction = void 0, this._pointSizeShaderFunction) }; Fg.prototype.getVariables = function () { let e = []; return l(this.color) && l(this.color.getVariables) && e.push.apply(e, this.color.getVariables()), l(this.show) && l(this.show.getVariables) && e.push.apply(e, this.show.getVariables()), l(this.pointSize) && l(this.pointSize.getVariables) && e.push.apply(e, this.pointSize.getVariables()), e = e.filter(function (t, n, i) { return i.indexOf(t) === n }), e }; var xE = Fg; function U7(e) { e = y(e, 1), this._radius = y(e, 1) } Object.defineProperties(U7.prototype, { radius: { get: function () { return this._radius }, set: function (e) { this._radius = e } } }); U7.prototype.emit = function (e) { let t = I.randomBetween(0, I.TWO_PI), n = I.randomBetween(0, this._radius), i = n * Math.cos(t), o = n * Math.sin(t), r = 0; e.position = h.fromElements(i, o, r, e.position), e.velocity = h.clone(h.UNIT_Z, e.velocity) }; var DV = U7; var z7 = { CUMULUS: 0 }; z7.validate = function (e) { return e === z7.CUMULUS }; var qD = Object.freeze(z7); var vV = `uniform sampler2D u_noiseTexture;
uniform vec3 u_noiseTextureDimensions;
uniform float u_noiseDetail;
varying vec2 v_offset;
varying vec3 v_maximumSize;
varying vec4 v_color;
varying float v_slice;
varying float v_brightness;
float wrap(float value, float rangeLength) {
if(value < 0.0) {
float absValue = abs(value);
float modValue = mod(absValue, rangeLength);
return mod(rangeLength - modValue, rangeLength);
}
return mod(value, rangeLength);
}
vec3 wrapVec(vec3 value, float rangeLength) {
return vec3(wrap(value.x, rangeLength),
wrap(value.y, rangeLength),
wrap(value.z, rangeLength));
}
float textureSliceWidth = u_noiseTextureDimensions.x;
float noiseTextureRows = u_noiseTextureDimensions.y;
float inverseNoiseTextureRows = u_noiseTextureDimensions.z;
float textureSliceWidthSquared = textureSliceWidth * textureSliceWidth;
vec2 inverseNoiseTextureDimensions = vec2(noiseTextureRows / textureSliceWidthSquared,
inverseNoiseTextureRows / textureSliceWidth);
vec2 voxelToUV(vec3 voxelIndex) {
vec3 wrappedIndex = wrapVec(voxelIndex, textureSliceWidth);
float column = mod(wrappedIndex.z, textureSliceWidth * inverseNoiseTextureRows);
float row = floor(wrappedIndex.z / textureSliceWidth * noiseTextureRows);
float xPixelCoord = wrappedIndex.x + column * textureSliceWidth;
float yPixelCoord = wrappedIndex.y + row * textureSliceWidth;
return vec2(xPixelCoord, yPixelCoord) * inverseNoiseTextureDimensions;
}
vec4 lerpSamplesX(vec3 voxelIndex, float x) {
vec2 uv0 = voxelToUV(voxelIndex);
vec2 uv1 = voxelToUV(voxelIndex + vec3(1.0, 0.0, 0.0));
vec4 sample0 = texture2D(u_noiseTexture, uv0);
vec4 sample1 = texture2D(u_noiseTexture, uv1);
return mix(sample0, sample1, x);
}
vec4 sampleNoiseTexture(vec3 position) {
vec3 recenteredPos = position + vec3(textureSliceWidth / 2.0);
vec3 lerpValue = fract(recenteredPos);
vec3 voxelIndex = floor(recenteredPos);
vec4 xLerp00 = lerpSamplesX(voxelIndex, lerpValue.x);
vec4 xLerp01 = lerpSamplesX(voxelIndex + vec3(0.0, 0.0, 1.0), lerpValue.x);
vec4 xLerp10 = lerpSamplesX(voxelIndex + vec3(0.0, 1.0, 0.0), lerpValue.x);
vec4 xLerp11 = lerpSamplesX(voxelIndex + vec3(0.0, 1.0, 1.0), lerpValue.x);
vec4 yLerp0 = mix(xLerp00, xLerp10, lerpValue.y);
vec4 yLerp1 = mix(xLerp01, xLerp11, lerpValue.y);
return mix(yLerp0, yLerp1, lerpValue.z);
}
bool intersectSphere(vec3 origin, vec3 dir, float slice,
out vec3 point, out vec3 normal) {
float A = dot(dir, dir);
float B = dot(origin, dir);
float C = dot(origin, origin) - 0.25;
float discriminant = (B * B) - (A * C);
if(discriminant < 0.0) {
return false;
}
float root = sqrt(discriminant);
float t = (-B - root) / A;
if(t < 0.0) {
t = (-B + root) / A;
}
point = origin + t * dir;
if(slice >= 0.0) {
point.z = (slice / 2.0) - 0.5;
if(length(point) > 0.5) {
return false;
}
}
normal = normalize(point);
point -= czm_epsilon2 * normal;
return true;
}
bool intersectEllipsoid(vec3 origin, vec3 dir, vec3 center, vec3 scale, float slice,
out vec3 point, out vec3 normal) {
if(scale.x <= 0.01 || scale.y < 0.01 || scale.z < 0.01) {
return false;
}
vec3 o = (origin - center) / scale;
vec3 d = dir / scale;
vec3 p, n;
bool intersected = intersectSphere(o, d, slice, p, n);
if(intersected) {
point = (p * scale) + center;
normal = n;
}
return intersected;
}
vec2 phaseShift2D(vec2 p, vec2 freq) {
return (czm_pi / 2.0) * sin(freq.yx * p.yx);
}
vec2 phaseShift3D(vec3 p, vec2 freq) {
return phaseShift2D(p.xy, freq) + czm_pi * vec2(sin(freq.x * p.z));
}
const float T0    = 0.6;
const float k     = 0.1;
const float C0    = 0.8;
const float FX0   = 0.6;
const float FY0   = 0.6;
const int octaves = 5;
float T(vec3 point) {
vec2 sum = vec2(0.0);
float Ci = C0;
vec2 FXY = vec2(FX0, FY0);
vec2 PXY = vec2(0.0);
for(int i = 1; i <= octaves; i++) {
PXY = phaseShift3D(point, FXY);
Ci *= 0.707;
FXY *= 2.0;
vec2 sinTerm = sin(FXY * point.xy + PXY);
sum += Ci * sinTerm + vec2(T0);
}
return k * sum.x * sum.y;
}
const float a = 0.5;
const float t = 0.4;
const float s = 0.25;
float I(float Id, float Is, float It) {
return (1.0 - a) * ((1.0 - t) * ((1.0 - s) * Id + s * Is) + t * It) + a;
}
const vec3 lightDir = normalize(vec3(0.2, -1.0, 0.7));
vec4 drawCloud(vec3 rayOrigin, vec3 rayDir, vec3 cloudCenter, vec3 cloudScale, float cloudSlice,
float brightness) {
vec3 cloudPoint, cloudNormal;
if(!intersectEllipsoid(rayOrigin, rayDir, cloudCenter, cloudScale, cloudSlice,
cloudPoint, cloudNormal)) {
return vec4(0.0);
}
float Id = clamp(dot(cloudNormal, -lightDir), 0.0, 1.0);
float Is = max(pow(dot(-lightDir, -rayDir), 2.0), 0.0);
float It = T(cloudPoint);
float intensity = I(Id, Is, It);
vec3 color = vec3(intensity * clamp(brightness, 0.1, 1.0));
vec4 noise = sampleNoiseTexture(u_noiseDetail * cloudPoint);
float W = noise.x;
float W2 = noise.y;
float W3 = noise.z;
float ndDot = clamp(dot(cloudNormal, -rayDir), 0.0, 1.0);
float TR = pow(ndDot, 3.0) - W;
TR *= 1.3;
float minusDot = 0.5 - ndDot;
TR -= min(minusDot * W2, 0.0);
TR -= 0.8 * (minusDot + 0.25) * W3;
float shading = mix(1.0 - 0.8 * W * W, 1.0, Id * TR);
shading = clamp(shading + 0.2, 0.3, 1.0);
vec3 finalColor = mix(vec3(0.5), shading * color, 1.15);
return vec4(finalColor, clamp(TR, 0.0, 1.0)) * v_color;
}
void main() {
#ifdef DEBUG_BILLBOARDS
gl_FragColor = vec4(0.0, 0.5, 0.5, 1.0);
#endif
vec2 coordinate = v_maximumSize.xy * v_offset;
vec3 ellipsoidScale = 0.82 * v_maximumSize;
vec3 ellipsoidCenter = vec3(0.0);
float zOffset = max(ellipsoidScale.z - 10.0, 0.0);
vec3 eye = vec3(0, 0, -10.0 - zOffset);
vec3 rayDir = normalize(vec3(coordinate, 1.0) - eye);
vec3 rayOrigin = eye;
#ifdef DEBUG_ELLIPSOIDS
vec3 point, normal;
if(intersectEllipsoid(rayOrigin, rayDir, ellipsoidCenter, ellipsoidScale, v_slice,
point, normal)) {
gl_FragColor = v_brightness * v_color;
}
#else
#ifndef DEBUG_BILLBOARDS
vec4 cloud = drawCloud(rayOrigin, rayDir,
ellipsoidCenter, ellipsoidScale, v_slice, v_brightness);
if(cloud.w < 0.01) {
discard;
}
gl_FragColor = cloud;
#endif
#endif
}
`; var PV = `#ifdef INSTANCED
attribute vec2 direction;
#endif
attribute vec4 positionHighAndScaleX;
attribute vec4 positionLowAndScaleY;
attribute vec4 packedAttribute0;
attribute vec4 packedAttribute1;
attribute vec4 color;
varying vec2 v_offset;
varying vec3 v_maximumSize;
varying vec4 v_color;
varying float v_slice;
varying float v_brightness;
void main() {
vec3 positionHigh = positionHighAndScaleX.xyz;
vec3 positionLow = positionLowAndScaleY.xyz;
vec2 scale = vec2(positionHighAndScaleX.w, positionLowAndScaleY.w);
float show = packedAttribute0.x;
float brightness = packedAttribute0.y;
vec2 coordinates = packedAttribute0.wz;
vec3 maximumSize = packedAttribute1.xyz;
float slice = packedAttribute1.w;
#ifdef INSTANCED
vec2 dir = direction;
#else
vec2 dir = coordinates;
#endif
vec2 offset = dir - vec2(0.5, 0.5);
vec2 scaledOffset = scale * offset;
vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
vec4 positionEC = czm_modelViewRelativeToEye * p;
positionEC.xy += scaledOffset;
positionEC.xyz *= show;
gl_Position = czm_projection * positionEC;
v_offset = offset;
v_maximumSize = maximumSize;
v_color = color;
v_slice = slice;
v_brightness = brightness;
}
`; var IV = `uniform vec3 u_noiseTextureDimensions;
uniform float u_noiseDetail;
uniform vec3 u_noiseOffset;
varying vec2 v_position;
float textureSliceWidth = u_noiseTextureDimensions.x;
float inverseNoiseTextureRows = u_noiseTextureDimensions.z;
float wrap(float value, float rangeLength) {
if(value < 0.0) {
float absValue = abs(value);
float modValue = mod(absValue, rangeLength);
return mod(rangeLength - modValue, rangeLength);
}
return mod(value, rangeLength);
}
vec3 wrapVec(vec3 value, float rangeLength) {
return vec3(wrap(value.x, rangeLength),
wrap(value.y, rangeLength),
wrap(value.z, rangeLength));
}
vec3 random3(vec3 p) {
float dot1 = dot(p, vec3(127.1, 311.7, 932.8));
float dot2 = dot(p, vec3(269.5, 183.3, 421.4));
return fract(vec3(sin(dot1 - dot2), cos(dot1 * dot2), dot1 * dot2));
}
vec3 getWorleyCellPoint(vec3 centerCell, vec3 offset, float freq) {
vec3 cell = centerCell + offset;
cell = wrapVec(cell, textureSliceWidth / u_noiseDetail);
cell += floor(u_noiseOffset / u_noiseDetail);
vec3 p = offset + random3(cell);
return p;
}
float worleyNoise(vec3 p, float freq) {
vec3 centerCell = floor(p * freq);
vec3 pointInCell = fract(p * freq);
float shortestDistance = 1000.0;
for(float z = -1.0; z <= 1.0; z++) {
for(float y = -1.0; y <= 1.0; y++) {
for(float x = -1.0; x <= 1.0; x++) {
vec3 offset = vec3(x, y, z);
vec3 point = getWorleyCellPoint(centerCell, offset, freq);
float distance = length(pointInCell - point);
if(distance < shortestDistance) {
shortestDistance = distance;
}
}
}
}
return shortestDistance;
}
const float MAX_FBM_ITERATIONS = 10.0;
float worleyFBMNoise(vec3 p, float octaves, float scale) {
float noise = 0.0;
float freq = 1.0;
float persistence = 0.625;
for(float i = 0.0; i < MAX_FBM_ITERATIONS; i++) {
if(i >= octaves) {
break;
}
noise += worleyNoise(p * scale, freq * scale) * persistence;
persistence *= 0.5;
freq *= 2.0;
}
return noise;
}
void main() {
float x = mod(v_position.x, textureSliceWidth);
float y = mod(v_position.y, textureSliceWidth);
float sliceRow = floor(v_position.y / textureSliceWidth);
float z = floor(v_position.x / textureSliceWidth) + sliceRow * inverseNoiseTextureRows * textureSliceWidth;
vec3 position = vec3(x, y, z);
position /= u_noiseDetail;
float worley0 = clamp(worleyFBMNoise(position, 3.0, 1.0), 0.0, 1.0);
float worley1 = clamp(worleyFBMNoise(position, 3.0, 2.0), 0.0, 1.0);
float worley2 = clamp(worleyFBMNoise(position, 3.0, 3.0), 0.0, 1.0);
gl_FragColor = vec4(worley0, worley1, worley2, 1.0);
}
`; var OV = `uniform vec3 u_noiseTextureDimensions;
attribute vec2 position;
varying vec2 v_position;
void main()
{
gl_Position = vec4(position, 0.1, 1.0);
float textureSliceWidth = u_noiseTextureDimensions.x;
float noiseTextureRows = u_noiseTextureDimensions.y;
float inverseNoiseTextureRows = u_noiseTextureDimensions.z;
vec2 transformedPos = (position * 0.5) + vec2(0.5);
transformedPos *= textureSliceWidth;
transformedPos.x *= textureSliceWidth * inverseNoiseTextureRows;
transformedPos.y *= noiseTextureRows;
v_position = transformedPos;
}
`; function cd(e, t) { if (e = y(e, y.EMPTY_OBJECT), this._show = y(e.show, !0), this._position = h.clone(y(e.position, h.ZERO)), !l(e.scale) && l(e.maximumSize)) this._maximumSize = h.clone(e.maximumSize), this._scale = new H(this._maximumSize.x, this._maximumSize.y); else { this._scale = H.clone(y(e.scale, new H(20, 12))); let n = new h(this._scale.x, this._scale.y, Math.min(this._scale.x, this._scale.y) / 1.5); this._maximumSize = h.clone(y(e.maximumSize, n)) } this._slice = y(e.slice, -1), this._color = U.clone(y(e.color, U.WHITE)), this._brightness = y(e.brightness, 1), this._cloudCollection = t, this._index = -1 } var Ptt = cd.SHOW_INDEX = 0, Itt = cd.POSITION_INDEX = 1, Ott = cd.SCALE_INDEX = 2, Btt = cd.MAXIMUM_SIZE_INDEX = 3, Rtt = cd.SLICE_INDEX = 4, Mtt = cd.BRIGHTNESS_INDEX = 5, Ltt = cd.COLOR_INDEX = 6; cd.NUMBER_OF_PROPERTIES = 7; function $y(e, t) { let n = e._cloudCollection; l(n) && (n._updateCloud(e, t), e._dirty = !0) } Object.defineProperties(cd.prototype, { show: { get: function () { return this._show }, set: function (e) { this._show !== e && (this._show = e, $y(this, Ptt)) } }, position: { get: function () { return this._position }, set: function (e) { let t = this._position; h.equals(t, e) || (h.clone(e, t), $y(this, Itt)) } }, scale: { get: function () { return this._scale }, set: function (e) { let t = this._scale; H.equals(t, e) || (H.clone(e, t), $y(this, Ott)) } }, maximumSize: { get: function () { return this._maximumSize }, set: function (e) { let t = this._maximumSize; h.equals(t, e) || (h.clone(e, t), $y(this, Btt)) } }, color: { get: function () { return this._color }, set: function (e) { let t = this._color; U.equals(t, e) || (U.clone(e, t), $y(this, Ltt)) } }, slice: { get: function () { return this._slice }, set: function (e) { this._slice !== e && (this._slice = e, $y(this, Rtt)) } }, brightness: { get: function () { return this._brightness }, set: function (e) { this._brightness !== e && (this._brightness = e, $y(this, Mtt)) } } }); cd.prototype._destroy = function () { this._cloudCollection = void 0 }; var Ju = cd; var zl, BV = new h, Ftt = { positionHighAndScaleX: 0, positionLowAndScaleY: 1, packedAttribute0: 2, packedAttribute1: 3, color: 4 }, Ntt = { direction: 0, positionHighAndScaleX: 1, positionLowAndScaleY: 2, packedAttribute0: 3, packedAttribute1: 4, color: 5 }, Vtt = Ju.SHOW_INDEX, ktt = Ju.POSITION_INDEX, Utt = Ju.SCALE_INDEX, ztt = Ju.MAXIMUM_SIZE_INDEX, Htt = Ju.SLICE_INDEX, Gtt = Ju.BRIGHTNESS_INDEX, Wtt = Ju.NUMBER_OF_PROPERTIES, jtt = Ju.COLOR_INDEX; function ld(e) { e = y(e, y.EMPTY_OBJECT), this._clouds = [], this._cloudsToUpdate = [], this._cloudsToUpdateIndex = 0, this._cloudsRemoved = !1, this._createVertexArray = !1, this._propertiesChanged = new Uint32Array(Wtt), this._noiseTexture = void 0, this._textureSliceWidth = 128, this._noiseTextureRows = 4, this.noiseDetail = y(e.noiseDetail, 16), this.noiseOffset = h.clone(y(e.noiseOffset, h.ZERO)), this._loading = !1, this._ready = !1; let t = this; this._uniforms = { u_noiseTexture: function () { return t._noiseTexture }, u_noiseTextureDimensions: Rme(t), u_noiseDetail: function () { return t.noiseDetail } }, this._vaNoise = void 0, this._spNoise = void 0, this._spCreated = !1, this._sp = void 0, this._rs = void 0, this.show = y(e.show, !0), this._colorCommands = [], this.debugBillboards = y(e.debugBillboards, !1), this._compiledDebugBillboards = !1, this.debugEllipsoids = y(e.debugEllipsoids, !1), this._compiledDebugEllipsoids = !1 } function Rme(e) { return function () { return BV.x = e._textureSliceWidth, BV.y = e._noiseTextureRows, BV.z = 1 / e._noiseTextureRows, BV } } Object.defineProperties(ld.prototype, { length: { get: function () { return G7(this), this._clouds.length } } }); function Mme(e) { let t = e.length; for (let n = 0; n < t; ++n)e[n] && e[n]._destroy() } ld.prototype.add = function (e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.cloudType, qD.CUMULUS), n; return t === qD.CUMULUS && (n = new Ju(e, this), n._index = this._clouds.length, this._clouds.push(n), this._createVertexArray = !0), n }; ld.prototype.remove = function (e) { return this.contains(e) ? (this._clouds[e._index] = void 0, this._cloudsRemoved = !0, this._createVertexArray = !0, e._destroy(), !0) : !1 }; ld.prototype.removeAll = function () { Mme(this._clouds), this._clouds = [], this._cloudsToUpdate = [], this._cloudsToUpdateIndex = 0, this._cloudsRemoved = !1, this._createVertexArray = !0 }; function G7(e) { if (e._cloudsRemoved) { e._cloudsRemoved = !1; let t = [], n = e._clouds, i = n.length; for (let o = 0, r = 0; o < i; ++o) { let s = n[o]; l(s) && (n._index = r++, t.push(s)) } e._clouds = t } } ld.prototype._updateCloud = function (e, t) { e._dirty || (this._cloudsToUpdate[this._cloudsToUpdateIndex++] = e), ++this._propertiesChanged[t] }; ld.prototype.contains = function (e) { return l(e) && e._cloudCollection === this }; ld.prototype.get = function (e) { return G7(this), this._clouds[e] }; var qtt = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), Ytt = new Uint16Array([0, 1, 2, 0, 2, 3]); function Xtt(e) { let t = ct.createVertexBuffer({ context: e, typedArray: qtt, usage: Re.STATIC_DRAW }), n = ct.createIndexBuffer({ context: e, typedArray: Ytt, usage: Re.STATIC_DRAW, indexDatatype: Me.UNSIGNED_SHORT }), i = [{ index: 0, vertexBuffer: t, componentsPerAttribute: 2, componentDatatype: Y.FLOAT }]; return new Qn({ context: e, attributes: i, indexBuffer: n }) } var W7; function Ktt(e) { let n = e.cache.cloudCollection_indexBufferBatched; if (l(n)) return n; let i = 16384 * 6 - 6, o = new Uint16Array(i); for (let r = 0, s = 0; r < i; r += 6, s += 4)o[r] = s, o[r + 1] = s + 1, o[r + 2] = s + 2, o[r + 3] = s, o[r + 4] = s + 2, o[r + 5] = s + 3; return n = ct.createIndexBuffer({ context: e, typedArray: o, usage: Re.STATIC_DRAW, indexDatatype: Me.UNSIGNED_SHORT }), n.vertexArrayDestroyable = !1, e.cache.cloudCollection_indexBufferBatched = n, n } function Jtt(e) { let t = e.cache.cloudCollection_indexBufferInstanced; return l(t) || (t = ct.createIndexBuffer({ context: e, typedArray: new Uint16Array([0, 1, 2, 0, 2, 3]), usage: Re.STATIC_DRAW, indexDatatype: Me.UNSIGNED_SHORT }), t.vertexArrayDestroyable = !1, e.cache.cloudCollection_indexBufferInstanced = t), t } function Ztt(e) { let t = e.cache.cloudCollection_vertexBufferInstanced; return l(t) || (t = ct.createVertexBuffer({ context: e, typedArray: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), usage: Re.STATIC_DRAW }), t.vertexArrayDestroyable = !1, e.cache.cloudCollection_vertexBufferInstanced = t), t } function Qtt(e, t, n) { let i = [{ index: zl.positionHighAndScaleX, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: Re.STATIC_DRAW }, { index: zl.positionLowAndScaleY, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: Re.STATIC_DRAW }, { index: zl.packedAttribute0, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: Re.STATIC_DRAW }, { index: zl.packedAttribute1, componentsPerAttribute: 4, componentDatatype: Y.FLOAT, usage: Re.STATIC_DRAW }, { index: zl.color, componentsPerAttribute: 4, componentDatatype: Y.UNSIGNED_BYTE, normalize: !0, usage: Re.STATIC_DRAW }]; n && i.push({ index: zl.direction, componentsPerAttribute: 2, componentDatatype: Y.FLOAT, vertexBuffer: Ztt(e) }); let o = n ? t : 4 * t; return new E_(e, i, o, n) } var H7 = new Vn; function Lme(e, t, n, i) { let o, r = n[zl.positionHighAndScaleX], s = n[zl.positionLowAndScaleY], a = i.position; Vn.fromCartesian(a, H7); let c = i.scale, u = H7.high, f = H7.low; e._instanced ? (o = i._index, r(o, u.x, u.y, u.z, c.x), s(o, f.x, f.y, f.z, c.y)) : (o = i._index * 4, r(o + 0, u.x, u.y, u.z, c.x), r(o + 1, u.x, u.y, u.z, c.x), r(o + 2, u.x, u.y, u.z, c.x), r(o + 3, u.x, u.y, u.z, c.x), s(o + 0, f.x, f.y, f.z, c.y), s(o + 1, f.x, f.y, f.z, c.y), s(o + 2, f.x, f.y, f.z, c.y), s(o + 3, f.x, f.y, f.z, c.y)) } function Fme(e, t, n, i) { let o, r = n[zl.packedAttribute0], s = i.show, a = i.brightness; e._instanced ? (o = i._index, r(o, s, a, 0, 0)) : (o = i._index * 4, r(o + 0, s, a, 0, 0), r(o + 1, s, a, 1, 0), r(o + 2, s, a, 1, 1), r(o + 3, s, a, 0, 1)) } function Nme(e, t, n, i) { let o, r = n[zl.packedAttribute1], s = i.maximumSize, a = i.slice; e._instanced ? (o = i._index, r(o, s.x, s.y, s.z, a)) : (o = i._index * 4, r(o + 0, s.x, s.y, s.z, a), r(o + 1, s.x, s.y, s.z, a), r(o + 2, s.x, s.y, s.z, a), r(o + 3, s.x, s.y, s.z, a)) } function Vme(e, t, n, i) { let o, r = n[zl.color], s = i.color, a = U.floatToByte(s.red), c = U.floatToByte(s.green), u = U.floatToByte(s.blue), f = U.floatToByte(s.alpha); e._instanced ? (o = i._index, r(o, a, c, u, f)) : (o = i._index * 4, r(o + 0, a, c, u, f), r(o + 1, a, c, u, f), r(o + 2, a, c, u, f), r(o + 3, a, c, u, f)) } function $tt(e, t, n, i) { Lme(e, t, n, i), Fme(e, t, n, i), Nme(e, t, n, i), Vme(e, t, n, i) } function ent(e, t, n, i) { let o = e, r = o._textureSliceWidth, s = o._noiseTextureRows, a = t.context; o._vaNoise = Xtt(a), o._spNoise = qt.fromCache({ context: a, vertexShaderSource: n, fragmentShaderSource: i, attributeLocations: { position: 0 } }); let c = o.noiseDetail, u = o.noiseOffset; o._noiseTexture = new Rt({ context: a, width: r * r / s, height: r * s, pixelDatatype: Ye.UNSIGNED_BYTE, pixelFormat: ht.RGBA, sampler: new dn({ wrapS: In.REPEAT, wrapT: In.REPEAT, minificationFilter: ln.NEAREST, magnificationFilter: Xi.NEAREST }) }); let f = new pf({ vertexArray: o._vaNoise, shaderProgram: o._spNoise, outputTexture: o._noiseTexture, uniformMap: { u_noiseTextureDimensions: Rme(o), u_noiseDetail: function () { return c }, u_noiseOffset: function () { return u } }, persists: !1, owner: e, postExecute: function (d) { o._ready = !0, o._loading = !1 } }); t.commandList.push(f), o._loading = !0 } function tnt(e, t) { let n = e, i = t.context; n._createVertexArray = !1, n._vaf = n._vaf && n._vaf.destroy(); let o = e._clouds, r = o.length; if (r > 0) { n._vaf = Qtt(i, r, n._instanced); let s = n._vaf.writers, a; for (a = 0; a < r; ++a) { let c = o[a]; $tt(e, t, s, c) } n._vaf.commit(W7(i)) } } var nnt = []; function int(e, t) { let n = t.context, i = e, r = i._clouds.length, s = i._cloudsToUpdate, a = i._cloudsToUpdateIndex, c = i._propertiesChanged, u = nnt; u.length = 0, (c[ktt] || c[Utt]) && u.push(Lme), (c[Vtt] || c[Gtt]) && u.push(Fme), (c[ztt] || c[Htt]) && u.push(Nme), c[jtt] && u.push(Vme); let f = u.length, d = i._vaf.writers, p, g, m; if (a / r > .1) { for (p = 0; p < a; ++p)for (g = s[p], g._dirty = !1, m = 0; m < f; ++m)u[m](e, t, d, g); i._vaf.commit(W7(n)) } else { for (p = 0; p < a; ++p) { for (g = s[p], g._dirty = !1, m = 0; m < f; ++m)u[m](e, t, d, g); i._instanced ? i._vaf.subCommit(g._index, 1) : i._vaf.subCommit(g._index * 4, 4) } i._vaf.endSubCommits() } i._cloudsToUpdateIndex = 0 } function ont(e, t, n, i) { let o = t.context, r = e, s = new Ue({ defines: [], sources: [n] }); r._instanced && s.defines.push("INSTANCED"); let a = new Ue({ defines: [], sources: [i] }); r.debugBillboards && a.defines.push("DEBUG_BILLBOARDS"), r.debugEllipsoids && a.defines.push("DEBUG_ELLIPSOIDS"), r._sp = qt.replaceCache({ context: o, shaderProgram: r._sp, vertexShaderSource: s, fragmentShaderSource: a, attributeLocations: zl }), r._rs = Ve.fromCache({ depthTest: { enabled: !0, func: te.LESS }, depthMask: !1, blending: an.ALPHA_BLEND }), r._spCreated = !0, r._compiledDebugBillboards = r.debugBillboards, r._compiledDebugEllipsoids = r.debugEllipsoids } function rnt(e, t) { let n = e, i = t.passes, o = n._uniforms, r = t.commandList; if (i.render) { let s = n._colorCommands, a = n._vaf.va, c = a.length; s.length = c; for (let u = 0; u < c; u++) { let f = s[u]; l(f) || (f = s[u] = new $e), f.pass = xe.TRANSLUCENT, f.owner = e, f.uniformMap = o, f.count = a[u].indicesCount, f.vertexArray = a[u].va, f.shaderProgram = n._sp, f.renderState = n._rs, n._instanced && (f.count = 6, f.instanceCount = n._clouds.length), r.push(f) } } } ld.prototype.update = function (e) { if (G7(this), !this.show) return; let t = this.debugBillboards || this.debugEllipsoids; this._ready = t ? !0 : l(this._noiseTexture), !this._ready && !this._loading && !t && ent(this, e, OV, IV), this._instanced = e.context.instancedArrays, zl = this._instanced ? Ntt : Ftt, W7 = this._instanced ? Jtt : Ktt; let i = this._clouds.length, o = this._cloudsToUpdate, r = this._cloudsToUpdateIndex; this._createVertexArray ? tnt(this, e) : r > 0 && int(this, e), r > i * 1.5 && (o.length = i), !(!l(this._vaf) || !l(this._vaf.va) || !this._ready & !t) && ((!this._spCreated || this.debugBillboards !== this._compiledDebugBillboards || this.debugEllipsoids !== this._compiledDebugEllipsoids) && ont(this, e, PV, vV), rnt(this, e)) }; ld.prototype.isDestroyed = function () { return !1 }; ld.prototype.destroy = function () { return this._noiseTexture = this._noiseTexture && this._noiseTexture.destroy(), this._sp = this._sp && this._sp.destroy(), this._vaf = this._vaf && this._vaf.destroy(), Mme(this._clouds), le(this) }; var kme = ld; function j7(e, t) { let n = t.terrainProvider, i = t.mapProjection, o = i.ellipsoid, r, s = t.camera.getRectangleCameraCoordinates(e); return t.mode === ee.SCENE3D ? r = o.cartesianToCartographic(s) : r = i.unproject(s), l(n) ? n.readyPromise.then(function () { let a = n.availability; if (!l(a) || t.mode === ee.SCENE2D) return r; let c = [ce.center(e), ce.southeast(e), ce.southwest(e), ce.northeast(e), ce.northwest(e)]; return j7._sampleTerrainMostDetailed(n, c).then(function (u) { let f = u.reduce(function (p, g) { return Math.max(g.height, p) }, -Number.MAX_VALUE), d = r; return d.height += f, d }) }) : Promise.resolve(r) } j7._sampleTerrainMostDetailed = rg; var TE = j7; var snt = I.toRadians(30); function q7(e) { this._angle = y(e, snt) } Object.defineProperties(q7.prototype, { angle: { get: function () { return this._angle }, set: function (e) { this._angle = e } } }); q7.prototype.emit = function (e) { let t = Math.tan(this._angle), n = I.randomBetween(0, I.TWO_PI), i = I.randomBetween(0, t), o = i * Math.cos(n), r = i * Math.sin(n), s = 1; e.velocity = h.fromElements(o, r, s, e.velocity), h.normalize(e.velocity, e.velocity), e.position = h.clone(h.ZERO, e.position) }; var Ume = q7; var ant = new U, cnt = new U, lnt = new U, unt = new U, zme = new se, YD = new Uint8Array(4); function Hme(e, t, n, i) { let o = t.height === n.height ? 0 : (e - t.height) / (n.height - t.height); return U.lerp(t.color, n.color, o, i) } function RV(e, t) { return { height: e, color: U.clone(t) } } function Gme(e) { return e = e.filter(function (t, n, i) { let o = n > 0, r = n < i.length - 1, s = o ? t.height === i[n - 1].height : !0, a = r ? t.height === i[n + 1].height : !0; return !s || !a }), e = e.filter(function (t, n, i) { let o = n > 0, r = n < i.length - 1, s = o ? U.equals(t.color, i[n - 1].color) : !1, a = r ? U.equals(t.color, i[n + 1].color) : !1; return !s || !a }), e = e.filter(function (t, n, i) { let o = n > 0, r = o ? U.equals(t.color, i[n - 1].color) : !1, s = o ? t.height === i[n - 1].height : !0; return !r || !s }), e } function fnt(e) { let t, n, i = [], o = e.length; for (t = 0; t < o; t++) { let r = e[t], s = r.entries, a = s.length, c = []; for (n = 0; n < a; n++) { let g = s[n], m = I.clamp(g.height, nl._minimumHeight, nl._maximumHeight), A = U.clone(g.color, ant); A.red *= A.alpha, A.green *= A.alpha, A.blue *= A.alpha, c.push(RV(m, A)) } let u = !0, f = !0; for (n = 0; n < a - 1; n++) { let g = c[n + 0], m = c[n + 1]; u = u && g.height <= m.height, f = f && g.height >= m.height } f ? c = c.reverse() : u || Xy(c, function (g, m) { return I.sign(g.height - m.height) }); let d = y(r.extendDownwards, !1), p = y(r.extendUpwards, !1); c.length === 1 && !d && !p && (d = !0, p = !0), d && c.splice(0, 0, RV(nl._minimumHeight, c[0].color)), p && c.splice(c.length, 0, RV(nl._maximumHeight, c[c.length - 1].color)), c = Gme(c), i.push(c) } return i } function dnt(e) { let t = fnt(e), n = [], i = [], o; function r(u, f) { n.push(RV(u, f)) } function s(u, f, d) { let p = U.multiplyByScalar(d, 1 - f.alpha, unt); p = U.add(p, f, p), r(u, p) } let a = t.length; for (o = 0; o < a; o++) { let u = t[o], f = 0, d = 0; i = n, n = []; let p = u.length, g = i.length; for (; f < p || d < g;) { let m = f < p ? u[f] : void 0, A = f > 0 ? u[f - 1] : void 0, C = f < p - 1 ? u[f + 1] : void 0, x = d < g ? i[d] : void 0, T = d > 0 ? i[d - 1] : void 0, b = d < g - 1 ? i[d + 1] : void 0; if (l(m) && l(x) && m.height === x.height) { let S = l(b) && x.height === b.height, D = !l(T), P = !l(b), B = l(C) && m.height === C.height, R = !l(A), M = !l(C); S ? B ? (s(m.height, m.color, x.color), s(m.height, C.color, b.color)) : R ? (r(m.height, x.color), s(m.height, m.color, b.color)) : M ? (s(m.height, m.color, x.color), r(m.height, b.color)) : (s(m.height, m.color, x.color), s(m.height, m.color, b.color)) : D ? B ? (r(m.height, m.color), s(m.height, C.color, x.color)) : M ? (r(m.height, m.color), r(m.height, x.color)) : (R || r(m.height, m.color), s(m.height, m.color, x.color)) : P ? B ? (s(m.height, m.color, x.color), r(m.height, C.color)) : R ? (r(m.height, x.color), r(m.height, m.color)) : M ? s(m.height, m.color, x.color) : (s(m.height, m.color, x.color), r(m.height, m.color)) : B ? (s(m.height, m.color, x.color), s(m.height, C.color, x.color)) : R ? (r(m.height, x.color), s(m.height, m.color, x.color)) : M ? (s(m.height, m.color, x.color), r(m.height, x.color)) : s(m.height, m.color, x.color), f += B ? 2 : 1, d += S ? 2 : 1 } else if (l(m) && l(x) && l(T) && m.height < x.height) { let S = Hme(m.height, T, x, lnt); l(A) ? l(C) ? s(m.height, m.color, S) : (s(m.height, m.color, S), r(m.height, S)) : (r(m.height, S), s(m.height, m.color, S)), f++ } else if (l(x) && l(m) && l(A) && x.height < m.height) { let S = Hme(x.height, A, m, cnt); l(T) ? l(b) ? s(x.height, S, x.color) : (s(x.height, S, x.color), r(x.height, S)) : (r(x.height, S), s(x.height, S, x.color)), d++ } else l(m) && (!l(x) || m.height < x.height) ? (l(x) && !l(T) && !l(C) ? (r(m.height, m.color), r(m.height, nl._emptyColor), r(x.height, nl._emptyColor)) : (!l(x) && l(T) && !l(A) && (r(T.height, nl._emptyColor), r(m.height, nl._emptyColor)), r(m.height, m.color)), f++) : l(x) && (!l(m) || x.height < m.height) && (r(x.height, x.color), d++) } } return Gme(n) } function nl(e) { e = y(e, y.EMPTY_OBJECT); let t = e.scene, n = e.layers, i = dnt(n), o = i.length, r, s, a, c; if (!nl._useFloatTexture(t.context)) for (a = Ye.UNSIGNED_BYTE, c = ht.RGBA, s = new Uint8Array(o * 4), r = 0; r < o; r++)se.packFloat(i[r].height, zme), se.pack(zme, s, r * 4); else for (a = Ye.FLOAT, c = ht.LUMINANCE, s = new Float32Array(o), r = 0; r < o; r++)s[r] = i[r].height; let f = Rt.create({ context: t.context, pixelFormat: c, pixelDatatype: a, source: { arrayBufferView: s, width: o, height: 1 }, sampler: new dn({ wrapS: In.CLAMP_TO_EDGE, wrapT: In.CLAMP_TO_EDGE, minificationFilter: ln.NEAREST, magnificationFilter: Xi.NEAREST }) }), d = new Uint8Array(o * 4); for (r = 0; r < o; r++)i[r].color.toBytes(YD), d[r * 4 + 0] = YD[0], d[r * 4 + 1] = YD[1], d[r * 4 + 2] = YD[2], d[r * 4 + 3] = YD[3]; let p = Rt.create({ context: t.context, pixelFormat: ht.RGBA, pixelDatatype: Ye.UNSIGNED_BYTE, source: { arrayBufferView: d, width: o, height: 1 }, sampler: new dn({ wrapS: In.CLAMP_TO_EDGE, wrapT: In.CLAMP_TO_EDGE, minificationFilter: ln.LINEAR, magnificationFilter: Xi.LINEAR }) }); return Ki.fromType("ElevationBand", { heights: f, colors: p }) } nl._useFloatTexture = function (e) { return e.floatingPointTexture }; nl._maximumHeight = 5906376425472; nl._minimumHeight = -5906376425472; nl._emptyColor = new U(0, 0, 0, 0); var Wme = nl; function hnt(e) { e = yt(e, { url: wh.fromAssetId(96188) }); let t = new Su(e), n = e.style; if (!l(n)) { let i = y(e.defaultColor, U.WHITE).toCssColorString(); n = new xE({ color: `Boolean(\${feature['cesium#color']}) ? color(\${feature['cesium#color']}) : ${i}` }) } return t.style = n, t } var jme = hnt; function mnt(e) { e = y(e, y.EMPTY_OBJECT); let t = [], n = e.geometry; (!l(n.attributes) || !l(n.primitiveType)) && (n = n.constructor.createGeometry(n)); let i = n.attributes, o = F.clone(y(e.modelMatrix, F.IDENTITY)), r = y(e.length, 1e4); if (l(i.normal) && t.push(new At({ geometry: Bn.createLineSegmentsForVectors(n, "normal", r), attributes: { color: new Bt(1, 0, 0, 1) }, modelMatrix: o })), l(i.tangent) && t.push(new At({ geometry: Bn.createLineSegmentsForVectors(n, "tangent", r), attributes: { color: new Bt(0, 1, 0, 1) }, modelMatrix: o })), l(i.bitangent) && t.push(new At({ geometry: Bn.createLineSegmentsForVectors(n, "bitangent", r), attributes: { color: new Bt(0, 0, 1, 1) }, modelMatrix: o })), t.length > 0) return new xn({ asynchronous: !1, geometryInstances: t, appearance: new $t({ flat: !0, translucent: !1 }) }) } var qme = mnt; var Yme = /{[^}]+}/g, Xme = { x: ynt, y: Cnt, z: Ent, s: bnt, reverseX: Ant, reverseY: xnt, reverseZ: Tnt, westDegrees: Snt, southDegrees: wnt, eastDegrees: Dnt, northDegrees: vnt, westProjected: Pnt, southProjected: Int, eastProjected: Ont, northProjected: Bnt, width: Rnt, height: Mnt }, pnt = yt(Xme, { i: Lnt, j: Fnt, reverseI: Nnt, reverseJ: Vnt, longitudeDegrees: Unt, latitudeDegrees: znt, longitudeProjected: Hnt, latitudeProjected: Gnt, format: jnt }); function SE(e) { this._errorEvent = new _e, this._resource = void 0, this._urlSchemeZeroPadding = void 0, this._pickFeaturesResource = void 0, this._tileWidth = void 0, this._tileHeight = void 0, this._maximumLevel = void 0, this._minimumLevel = void 0, this._tilingScheme = void 0, this._rectangle = void 0, this._tileDiscardPolicy = void 0, this._credit = void 0, this._hasAlphaChannel = void 0, this._readyPromise = void 0, this._tags = void 0, this._pickFeaturesTags = void 0, this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0, this.enablePickFeatures = !0, this.reinitialize(e) } Object.defineProperties(SE.prototype, { url: { get: function () { return this._resource.url } }, urlSchemeZeroPadding: { get: function () { return this._urlSchemeZeroPadding } }, pickFeaturesUrl: { get: function () { return this._pickFeaturesResource.url } }, proxy: { get: function () { return this._resource.proxy } }, tileWidth: { get: function () { return this._tileWidth } }, tileHeight: { get: function () { return this._tileHeight } }, maximumLevel: { get: function () { return this._maximumLevel } }, minimumLevel: { get: function () { return this._minimumLevel } }, tilingScheme: { get: function () { return this._tilingScheme } }, rectangle: { get: function () { return this._rectangle } }, tileDiscardPolicy: { get: function () { return this._tileDiscardPolicy } }, errorEvent: { get: function () { return this._errorEvent } }, ready: { get: function () { return l(this._resource) } }, readyPromise: { get: function () { return this._readyPromise } }, credit: { get: function () { return this._credit } }, hasAlphaChannel: { get: function () { return this._hasAlphaChannel } } }); SE.prototype.reinitialize = function (e) { let t = this; t._readyPromise = Promise.resolve(e).then(function (n) { let i = n.customTags, o = yt(Xme, i), r = yt(pnt, i), s = Pe.createIfNeeded(n.url), a = Pe.createIfNeeded(n.pickFeaturesUrl); t.enablePickFeatures = y(n.enablePickFeatures, t.enablePickFeatures), t._urlSchemeZeroPadding = y(n.urlSchemeZeroPadding, t.urlSchemeZeroPadding), t._tileDiscardPolicy = n.tileDiscardPolicy, t._getFeatureInfoFormats = n.getFeatureInfoFormats, t._subdomains = n.subdomains, Array.isArray(t._subdomains) ? t._subdomains = t._subdomains.slice() : l(t._subdomains) && t._subdomains.length > 0 ? t._subdomains = t._subdomains.split("") : t._subdomains = ["a", "b", "c"], t._tileWidth = y(n.tileWidth, 256), t._tileHeight = y(n.tileHeight, 256), t._minimumLevel = y(n.minimumLevel, 0), t._maximumLevel = n.maximumLevel, t._tilingScheme = y(n.tilingScheme, new Gr({ ellipsoid: n.ellipsoid })), t._rectangle = y(n.rectangle, t._tilingScheme.rectangle), t._rectangle = ce.intersection(t._rectangle, t._tilingScheme.rectangle), t._hasAlphaChannel = y(n.hasAlphaChannel, !0); let c = n.credit; return typeof c == "string" && (c = new Xt(c)), t._credit = c, t._resource = s, t._tags = o, t._pickFeaturesResource = a, t._pickFeaturesTags = r, !0 }) }; SE.prototype.getTileCredits = function (e, t, n) { }; SE.prototype.requestImage = function (e, t, n, i) { return tl.loadImage(this, _nt(this, e, t, n, i)) }; SE.prototype.pickFeatures = function (e, t, n, i, o) { if (!this.enablePickFeatures || !l(this._pickFeaturesResource) || this._getFeatureInfoFormats.length === 0) return; let r = 0, s = this; function a(u, f) { return u.callback(f) } function c() { if (r >= s._getFeatureInfoFormats.length) return Promise.resolve([]); let u = s._getFeatureInfoFormats[r], f = gnt(s, e, t, n, i, o, u.format); return ++r, u.type === "json" ? f.fetchJson().then(u.callback).catch(c) : u.type === "xml" ? f.fetchXML().then(u.callback).catch(c) : u.type === "text" || u.type === "html" ? f.fetchText().then(u.callback).catch(c) : f.fetch({ responseType: u.format }).then(a.bind(void 0, u)).catch(c) } return c() }; var MV = !1, Hl = new ce, LV = !1, XD = new ce; function _nt(e, t, n, i, o) { MV = !1, LV = !1; let r = e._resource, s = r.getUrlComponent(!0), a = e._tags, c = {}, u = s.match(Yme); return l(u) && u.forEach(function (f) { let d = f.substring(1, f.length - 1); l(a[d]) && (c[d] = a[d](e, t, n, i)) }), r.getDerivedResource({ request: o, templateValues: c }) } var Y7 = !1, bE = new H, X7 = !1; function gnt(e, t, n, i, o, r, s) { MV = !1, LV = !1, Y7 = !1, X7 = !1; let a = e._pickFeaturesResource, c = a.getUrlComponent(!0), u = e._pickFeaturesTags, f = {}, d = c.match(Yme); return l(d) && d.forEach(function (p) { let g = p.substring(1, p.length - 1); l(u[g]) && (f[g] = u[g](e, t, n, i, o, r, s)) }), a.getDerivedResource({ templateValues: f }) } function wE(e, t, n) { if (e && e.urlSchemeZeroPadding && e.urlSchemeZeroPadding.hasOwnProperty(t)) { let i = e.urlSchemeZeroPadding[t]; if (typeof i == "string") { let o = i.length; o > 1 && (n = n.length >= o ? n : new Array(o - n.toString().length + 1).join("0") + n) } } return n } function ynt(e, t, n, i) { return wE(e, "{x}", t) } function Ant(e, t, n, i) { let o = e.tilingScheme.getNumberOfXTilesAtLevel(i) - t - 1; return wE(e, "{reverseX}", o) } function Cnt(e, t, n, i) { return wE(e, "{y}", n) } function xnt(e, t, n, i) { let o = e.tilingScheme.getNumberOfYTilesAtLevel(i) - n - 1; return wE(e, "{reverseY}", o) } function Tnt(e, t, n, i) { let o = e.maximumLevel, r = l(o) && i < o ? o - i - 1 : i; return wE(e, "{reverseZ}", r) } function Ent(e, t, n, i) { return wE(e, "{z}", i) } function bnt(e, t, n, i) { let o = (t + n + i) % e._subdomains.length; return e._subdomains[o] } function FV(e, t, n, i) { MV || (e.tilingScheme.tileXYToRectangle(t, n, i, Hl), Hl.west = I.toDegrees(Hl.west), Hl.south = I.toDegrees(Hl.south), Hl.east = I.toDegrees(Hl.east), Hl.north = I.toDegrees(Hl.north), MV = !0) } function Snt(e, t, n, i) { return FV(e, t, n, i), Hl.west } function wnt(e, t, n, i) { return FV(e, t, n, i), Hl.south } function Dnt(e, t, n, i) { return FV(e, t, n, i), Hl.east } function vnt(e, t, n, i) { return FV(e, t, n, i), Hl.north } function NV(e, t, n, i) { LV || (e.tilingScheme.tileXYToNativeRectangle(t, n, i, XD), LV = !0) } function Pnt(e, t, n, i) { return NV(e, t, n, i), XD.west } function Int(e, t, n, i) { return NV(e, t, n, i), XD.south } function Ont(e, t, n, i) { return NV(e, t, n, i), XD.east } function Bnt(e, t, n, i) { return NV(e, t, n, i), XD.north } function Rnt(e, t, n, i) { return e.tileWidth } function Mnt(e, t, n, i) { return e.tileHeight } function Lnt(e, t, n, i, o, r, s) { return VV(e, t, n, i, o, r), bE.x } function Fnt(e, t, n, i, o, r, s) { return VV(e, t, n, i, o, r), bE.y } function Nnt(e, t, n, i, o, r, s) { return VV(e, t, n, i, o, r), e.tileWidth - bE.x - 1 } function Vnt(e, t, n, i, o, r, s) { return VV(e, t, n, i, o, r), e.tileHeight - bE.y - 1 } var knt = new ce, EE = new h; function VV(e, t, n, i, o, r, s) { if (Y7) return; K7(e, t, n, i, o, r); let a = EE, c = e.tilingScheme.tileXYToNativeRectangle(t, n, i, knt); bE.x = e.tileWidth * (a.x - c.west) / c.width | 0, bE.y = e.tileHeight * (c.north - a.y) / c.height | 0, Y7 = !0 } function Unt(e, t, n, i, o, r, s) { return I.toDegrees(o) } function znt(e, t, n, i, o, r, s) { return I.toDegrees(r) } function Hnt(e, t, n, i, o, r, s) { return K7(e, t, n, i, o, r), EE.x } function Gnt(e, t, n, i, o, r, s) { return K7(e, t, n, i, o, r), EE.y } var Wnt = new he; function K7(e, t, n, i, o, r, s) { if (!X7) { if (e.tilingScheme.projection instanceof _i) EE.x = I.toDegrees(o), EE.y = I.toDegrees(r); else { let a = Wnt; a.longitude = o, a.latitude = r, e.tilingScheme.projection.project(a, EE) } X7 = !0 } } function jnt(e, t, n, i, o, r, s) { return s } var Ua = SE; function eA(e) { e = y(e, y.EMPTY_OBJECT), this._tmsResource = void 0, this._xmlResource = void 0, this._options = e, this._metadataError = void 0, this._metadataSuccess = this._metadataSuccess.bind(this), this._metadataFailure = this._metadataFailure.bind(this), this._requestMetadata = this._requestMetadata.bind(this); let t, n = this, i = Promise.resolve(e.url).then(function (o) { return t = Pe.createIfNeeded(o), t.appendForwardSlash(), n._tmsResource = t, n._xmlResource = t.getDerivedResource({ url: "tilemapresource.xml" }), n._requestMetadata() }).catch(o => Promise.reject(o)); Ua.call(this, i), this._promise = i } l(Object.create) && (eA.prototype = Object.create(Ua.prototype), eA.prototype.constructor = eA); eA.prototype._requestMetadata = function () { return this._xmlResource.fetchXML().then(this._metadataSuccess).catch(e => e instanceof Kh ? this._metadataFailure() : Promise.reject(e)) }; function Kme(e, t) { return e.west < t.rectangle.west && (e.west = t.rectangle.west), e.east > t.rectangle.east && (e.east = t.rectangle.east), e.south < t.rectangle.south && (e.south = t.rectangle.south), e.north > t.rectangle.north && (e.north = t.rectangle.north), e } function Jme(e, t, n) { let i = e.positionToTileXY(ce.southwest(t), n), o = e.positionToTileXY(ce.northeast(t), n); return (Math.abs(o.x - i.x) + 1) * (Math.abs(o.y - i.y) + 1) > 4 ? 0 : n } eA.prototype._metadataSuccess = function (e) { let t = /tileformat/i, n = /tileset/i, i = /tilesets/i, o = /boundingbox/i, r, s, a, c = [], u = this._xmlResource, f = this._metadataError, d = this._requestMetadata, p = e.childNodes[0].childNodes; for (let R = 0; R < p.length; R++)if (t.test(p.item(R).nodeName)) r = p.item(R); else if (i.test(p.item(R).nodeName)) { a = p.item(R); let M = p.item(R).childNodes; for (let L = 0; L < M.length; L++)n.test(M.item(L).nodeName) && c.push(M.item(L)) } else o.test(p.item(R).nodeName) && (s = p.item(R)); let g; if (!l(a) || !l(s)) return g = `Unable to find expected tilesets or bbox attributes in ${u.url}.`, f = Gn.reportError(f, this, this.errorEvent, g), f.retry ? (this._metadataError = f, d()) : Promise.reject(new fe(g)); let m = this._options, A = y(m.fileExtension, r.getAttribute("extension")), C = y(m.tileWidth, parseInt(r.getAttribute("width"), 10)), x = y(m.tileHeight, parseInt(r.getAttribute("height"), 10)), T = y(m.minimumLevel, parseInt(c[0].getAttribute("order"), 10)), b = y(m.maximumLevel, parseInt(c[c.length - 1].getAttribute("order"), 10)), S = a.getAttribute("profile"), D = m.tilingScheme; if (!l(D)) if (S === "geodetic" || S === "global-geodetic") D = new Hi({ ellipsoid: m.ellipsoid }); else if (S === "mercator" || S === "global-mercator") D = new Gr({ ellipsoid: m.ellipsoid }); else return g = `${u.url}specifies an unsupported profile attribute, ${S}.`, f = Gn.reportError(f, this, this.errorEvent, g), f.retry ? (this._metadataError = f, d()) : Promise.reject(new fe(g)); let P = ce.clone(m.rectangle); if (!l(P)) { let R, M, L, _; y(m.flipXY, !1) ? (L = new H(parseFloat(s.getAttribute("miny")), parseFloat(s.getAttribute("minx"))), _ = new H(parseFloat(s.getAttribute("maxy")), parseFloat(s.getAttribute("maxx")))) : (L = new H(parseFloat(s.getAttribute("minx")), parseFloat(s.getAttribute("miny"))), _ = new H(parseFloat(s.getAttribute("maxx")), parseFloat(s.getAttribute("maxy")))); let w = S === "geodetic" || S === "mercator"; if (D.projection instanceof _i || w) R = he.fromDegrees(L.x, L.y), M = he.fromDegrees(_.x, _.y); else { let v = D.projection; R = v.unproject(L), M = v.unproject(_) } P = new ce(R.longitude, R.latitude, M.longitude, M.latitude) } P = Kme(P, D), T = Jme(D, P, T); let B = this._tmsResource.getDerivedResource({ url: `{z}/{x}/{reverseY}.${A}` }); return Promise.resolve({ url: B, tilingScheme: D, rectangle: P, tileWidth: C, tileHeight: x, minimumLevel: T, maximumLevel: b, tileDiscardPolicy: m.tileDiscardPolicy, credit: m.credit }) }; eA.prototype._metadataFailure = function () { let e = this._options, t = y(e.fileExtension, "png"), n = y(e.tileWidth, 256), i = y(e.tileHeight, 256), o = e.maximumLevel, r = l(e.tilingScheme) ? e.tilingScheme : new Gr({ ellipsoid: e.ellipsoid }), s = y(e.rectangle, r.rectangle); s = Kme(s, r); let a = Jme(r, s, e.minimumLevel), c = this._tmsResource.getDerivedResource({ url: `{z}/{x}/{reverseY}.${t}` }); return Promise.resolve({ url: c, tilingScheme: r, rectangle: s, tileWidth: n, tileHeight: i, minimumLevel: a, maximumLevel: o, tileDiscardPolicy: e.tileDiscardPolicy, credit: e.credit }) }; var tA = eA; function Zu(e) { e = y(e, {}), this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = 1.9, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0; let t = e.url, n = y(e.path, "/default_map"), i = Pe.createIfNeeded(t).getDerivedResource({ url: n[0] === "/" ? n.substring(1) : n }); i.appendForwardSlash(), this._resource = i, this._url = t, this._path = n, this._tileDiscardPolicy = e.tileDiscardPolicy, this._channel = e.channel, this._requestType = "ImageryMaps", this._credit = new Xt(`<a href="http://www.google.com/enterprise/mapsearth/products/earthenterprise.html"><img src="${Zu.logoUrl}" title="Google Imagery"/></a>`), this._tilingScheme = void 0, this._version = void 0, this._tileWidth = 256, this._tileHeight = 256, this._maximumLevel = e.maximumLevel, this._errorEvent = new _e, this._ready = !1; let o = i.getDerivedResource({ url: "query", queryParameters: { request: "Json", vars: "geeServerDefs", is2d: "t" } }), r = this, s; function a(f) { let d; try { d = JSON.parse(f) } catch { d = JSON.parse(f.replace(/([\[\{,])[\n\r ]*([A-Za-z0-9]+)[\n\r ]*:/g, '$1"$2":')) } let p; for (let m = 0; m < d.layers.length; m++)if (d.layers[m].id === r._channel) { p = d.layers[m]; break } let g; if (!l(p)) return g = `Could not find layer with channel (id) of ${r._channel}.`, s = Gn.reportError(s, r, r._errorEvent, g), s.retry ? u() : Promise.reject(new fe(g)); if (!l(p.version)) return g = `Could not find a version in channel (id) ${r._channel}.`, s = Gn.reportError(s, r, r._errorEvent, g), s.retry ? u() : Promise.reject(new fe(g)); if (r._version = p.version, l(d.projection) && d.projection === "flat") r._tilingScheme = new Hi({ numberOfLevelZeroTilesX: 2, numberOfLevelZeroTilesY: 2, rectangle: new ce(-Math.PI, -Math.PI, Math.PI, Math.PI), ellipsoid: e.ellipsoid }); else if (!l(d.projection) || d.projection === "mercator") r._tilingScheme = new Gr({ numberOfLevelZeroTilesX: 2, numberOfLevelZeroTilesY: 2, ellipsoid: e.ellipsoid }); else return g = `Unsupported projection ${d.projection}.`, s = Gn.reportError(s, r, r._errorEvent, g), s.retry ? u() : Promise.reject(new fe(g)); return r._ready = !0, Gn.reportSuccess(s), Promise.resolve(!0) } function c(f) { let d = y(f.message, `An error occurred while accessing ${o.url}.`); return s = Gn.reportError(s, r, r._errorEvent, d), Promise.reject(new fe(d)) } function u() { return o.fetchText().then(a).catch(c) } this._readyPromise = u() } Object.defineProperties(Zu.prototype, { url: { get: function () { return this._url } }, path: { get: function () { return this._path } }, proxy: { get: function () { return this._resource.proxy } }, channel: { get: function () { return this._channel } }, tileWidth: { get: function () { return this._tileWidth } }, tileHeight: { get: function () { return this._tileHeight } }, maximumLevel: { get: function () { return this._maximumLevel } }, minimumLevel: { get: function () { return 0 } }, tilingScheme: { get: function () { return this._tilingScheme } }, version: { get: function () { return this._version } }, requestType: { get: function () { return this._requestType } }, rectangle: { get: function () { return this._tilingScheme.rectangle } }, tileDiscardPolicy: { get: function () { return this._tileDiscardPolicy } }, errorEvent: { get: function () { return this._errorEvent } }, ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } }, credit: { get: function () { return this._credit } }, hasAlphaChannel: { get: function () { return !0 } } }); Zu.prototype.getTileCredits = function (e, t, n) { }; Zu.prototype.requestImage = function (e, t, n, i) { let o = this._resource.getDerivedResource({ url: "query", request: i, queryParameters: { request: this._requestType, channel: this._channel, version: this._version, x: e, y: t, z: n + 1 } }); return tl.loadImage(this, o) }; Zu.prototype.pickFeatures = function (e, t, n, i, o) { }; Zu._logoUrl = void 0; Object.defineProperties(Zu, { logoUrl: { get: function () { return l(Zu._logoUrl) || (Zu._logoUrl = Jt("Assets/Images/google_earth_credit.png")), Zu._logoUrl }, set: function (e) { Zu._logoUrl = e } } }); var kV = Zu; var qnt = /\/$/, Zme = new Xt('&copy; <a href="https://www.mapbox.com/about/maps/">Mapbox</a> &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> <strong><a href="https://www.mapbox.com/map-feedback/">Improve this map</a></strong>'); function DE(e) { e = y(e, y.EMPTY_OBJECT); let t = e.mapId, n = e.accessToken; this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0; let i = Pe.createIfNeeded(y(e.url, "https://{s}.tiles.mapbox.com/v4/")); this._mapId = t, this._accessToken = n; let o = y(e.format, "png"); /\./.test(o) || (o = `.${o}`), this._format = o; let r = i.getUrlComponent(); qnt.test(r) || (r += "/"), r += `${t}/{z}/{x}/{y}${this._format}`, i.url = r, i.setQueryParameters({ access_token: n }); let s; l(e.credit) ? (s = e.credit, typeof s == "string" && (s = new Xt(s))) : s = Zme, this._resource = i, this._imageryProvider = new Ua({ url: i, credit: s, ellipsoid: e.ellipsoid, minimumLevel: e.minimumLevel, maximumLevel: e.maximumLevel, rectangle: e.rectangle }) } Object.defineProperties(DE.prototype, { url: { get: function () { return this._imageryProvider.url } }, ready: { get: function () { return this._imageryProvider.ready } }, readyPromise: { get: function () { return this._imageryProvider.readyPromise } }, rectangle: { get: function () { return this._imageryProvider.rectangle } }, tileWidth: { get: function () { return this._imageryProvider.tileWidth } }, tileHeight: { get: function () { return this._imageryProvider.tileHeight } }, maximumLevel: { get: function () { return this._imageryProvider.maximumLevel } }, minimumLevel: { get: function () { return this._imageryProvider.minimumLevel } }, tilingScheme: { get: function () { return this._imageryProvider.tilingScheme } }, tileDiscardPolicy: { get: function () { return this._imageryProvider.tileDiscardPolicy } }, errorEvent: { get: function () { return this._imageryProvider.errorEvent } }, credit: { get: function () { return this._imageryProvider.credit } }, proxy: { get: function () { return this._imageryProvider.proxy } }, hasAlphaChannel: { get: function () { return this._imageryProvider.hasAlphaChannel } } }); DE.prototype.getTileCredits = function (e, t, n) { }; DE.prototype.requestImage = function (e, t, n, i) { return this._imageryProvider.requestImage(e, t, n, i) }; DE.prototype.pickFeatures = function (e, t, n, i, o) { return this._imageryProvider.pickFeatures(e, t, n, i, o) }; DE._defaultCredit = Zme; var UV = DE; function KD(e) { e = y(e, y.EMPTY_OBJECT), this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0; let t = Pe.createIfNeeded(e.url), n = y(e.rectangle, ce.MAX_VALUE), i = new Hi({ rectangle: n, numberOfLevelZeroTilesX: 1, numberOfLevelZeroTilesY: 1, ellipsoid: e.ellipsoid }); this._tilingScheme = i, this._resource = t, this._image = void 0, this._texture = void 0, this._tileWidth = 0, this._tileHeight = 0, this._errorEvent = new _e, this._ready = !1; let o = e.credit; typeof o == "string" && (o = new Xt(o)), this._credit = o; let r = this, s; function a(f) { return r._image = f, r._tileWidth = f.width, r._tileHeight = f.height, r._ready = !0, Gn.reportSuccess(r._errorEvent), Promise.resolve(!0) } function c(f) { let d = `Failed to load image ${t.url}.`; return s = Gn.reportError(s, r, r._errorEvent, d, 0, 0, 0), s.retry ? u() : Promise.reject(new fe(d)) } function u() { return tl.loadImage(null, t).then(a).catch(c) } this._readyPromise = u() } Object.defineProperties(KD.prototype, { url: { get: function () { return this._resource.url } }, proxy: { get: function () { return this._resource.proxy } }, tileWidth: { get: function () { return this._tileWidth } }, tileHeight: { get: function () { return this._tileHeight } }, maximumLevel: { get: function () { return 0 } }, minimumLevel: { get: function () { return 0 } }, tilingScheme: { get: function () { return this._tilingScheme } }, rectangle: { get: function () { return this._tilingScheme.rectangle } }, tileDiscardPolicy: { get: function () { } }, errorEvent: { get: function () { return this._errorEvent } }, ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } }, credit: { get: function () { return this._credit } }, hasAlphaChannel: { get: function () { return !0 } } }); KD.prototype.getTileCredits = function (e, t, n) { }; KD.prototype.requestImage = function (e, t, n, i) { if (!!l(this._image)) return Promise.resolve(this._image) }; KD.prototype.pickFeatures = function (e, t, n, i, o) { }; var zV = KD; function Ynt(e, t, n) { this.type = e, l(t) || (e === "json" ? t = "application/json" : e === "xml" ? t = "text/xml" : e === "html" ? t = "text/html" : e === "text" && (t = "text/plain")), this.format = t, l(n) || (e === "json" ? n = Xnt : e === "xml" ? n = Qnt : (e === "html" || e === "text") && (n = Qme)), this.callback = n } function Xnt(e) { let t = [], n = e.features; for (let i = 0; i < n.length; ++i) { let o = n[i], r = new Oh; if (r.data = o, r.properties = o.properties, r.configureNameFromProperties(o.properties), r.configureDescriptionFromProperties(o.properties), l(o.geometry) && o.geometry.type === "Point") { let s = o.geometry.coordinates[0], a = o.geometry.coordinates[1]; r.position = he.fromDegrees(s, a) } t.push(r) } return t } var J7 = "http://www.mapinfo.com/mxp", Knt = "http://www.esri.com/wms", Jnt = "http://www.opengis.net/wfs", Znt = "http://www.opengis.net/gml"; function Qnt(e) { let t = e.documentElement; if (t.localName === "MultiFeatureCollection" && t.namespaceURI === J7) return $nt(e); if (t.localName === "FeatureInfoResponse" && t.namespaceURI === Knt) return eit(e); if (t.localName === "FeatureCollection" && t.namespaceURI === Jnt) return tit(e); if (t.localName === "ServiceExceptionReport") throw new fe(new XMLSerializer().serializeToString(t)); return t.localName === "msGMLOutput" ? nit(e) : iit(e) } function $nt(e) { let t = [], i = e.documentElement.getElementsByTagNameNS(J7, "Feature"); for (let o = 0; o < i.length; ++o) { let r = i[o], s = {}, a = r.getElementsByTagNameNS(J7, "Val"); for (let u = 0; u < a.length; ++u) { let f = a[u]; if (f.hasAttribute("ref")) { let d = f.getAttribute("ref"), p = f.textContent.trim(); s[d] = p } } let c = new Oh; c.data = r, c.properties = s, c.configureNameFromProperties(s), c.configureDescriptionFromProperties(s), t.push(c) } return t } function eit(e) { let t = e.documentElement, n = [], i, o = t.getElementsByTagNameNS("*", "FIELDS"); if (o.length > 0) for (let r = 0; r < o.length; ++r) { let s = o[r]; i = {}; let a = s.attributes; for (let c = 0; c < a.length; ++c) { let u = a[c]; i[u.name] = u.value } n.push(HV(s, i)) } else { let r = t.getElementsByTagNameNS("*", "FeatureInfo"); for (let s = 0; s < r.length; ++s) { let a = r[s]; i = {}; let c = a.childNodes; for (let u = 0; u < c.length; ++u) { let f = c[u]; f.nodeType === Node.ELEMENT_NODE && (i[f.localName] = f.textContent) } n.push(HV(a, i)) } } return n } function tit(e) { let t = [], i = e.documentElement.getElementsByTagNameNS(Znt, "featureMember"); for (let o = 0; o < i.length; ++o) { let r = i[o], s = {}; Z7(r, s), t.push(HV(r, s)) } return t } function nit(e) { let t = [], n, i = e.documentElement.childNodes; for (let r = 0; r < i.length; r++)if (i[r].nodeType === Node.ELEMENT_NODE) { n = i[r]; break } if (!l(n)) throw new fe("Unable to find first child of the feature info xml document"); let o = n.childNodes; for (let r = 0; r < o.length; ++r) { let s = o[r]; if (s.nodeType === Node.ELEMENT_NODE) { let a = {}; Z7(s, a), t.push(HV(s, a)) } } return t } function Z7(e, t) { let n = !0; for (let i = 0; i < e.childNodes.length; ++i) { let o = e.childNodes[i]; o.nodeType === Node.ELEMENT_NODE && (n = !1), !(o.localName === "Point" || o.localName === "LineString" || o.localName === "Polygon" || o.localName === "boundedBy") && o.hasChildNodes() && Z7(o, t) && (t[o.localName] = o.textContent) } return n } function HV(e, t) { let n = new Oh; return n.data = e, n.properties = t, n.configureNameFromProperties(t), n.configureDescriptionFromProperties(t), n } function iit(e) { let t = new XMLSerializer().serializeToString(e), n = document.createElement("div"), i = document.createElement("pre"); i.textContent = t, n.appendChild(i); let o = new Oh; return o.data = e, o.description = n.innerHTML, [o] } var oit = /<body>\s*<\/body>/im, rit = /<ServiceExceptionReport([\s\S]*)<\/ServiceExceptionReport>/im, sit = /<title>([\s\S]*)<\/title>/im; function Qme(e) { if (oit.test(e) || rit.test(e)) return; let t, n = sit.exec(e); n && n.length > 1 && (t = n[1]); let i = new Oh; return i.name = t, i.description = e, i.data = e, [i] } var vE = Ynt; function JD(e) { e = y(e, y.EMPTY_OBJECT), this._tileCache = {}, this._tilesRequestedForInterval = []; let t = this._clock = e.clock; this._times = e.times, this._requestImageFunction = e.requestImageFunction, this._reloadFunction = e.reloadFunction, this._currentIntervalIndex = -1, t.onTick.addEventListener(this._clockOnTick, this), this._clockOnTick(t) } Object.defineProperties(JD.prototype, { clock: { get: function () { return this._clock }, set: function (e) { this._clock !== e && (this._clock = e, this._clockOnTick(e), this._reloadFunction()) } }, times: { get: function () { return this._times }, set: function (e) { this._times !== e && (this._times = e, this._clockOnTick(this._clock), this._reloadFunction()) } }, currentInterval: { get: function () { return this._times.get(this._currentIntervalIndex) } } }); JD.prototype.getFromCache = function (e, t, n, i) { let o = $me(e, t, n), r, s = this._tileCache[this._currentIntervalIndex]; if (l(s) && l(s[o])) { let a = s[o]; r = a.promise.catch(function (c) { throw i.state = a.request.state, c }), delete s[o] } return r }; JD.prototype.checkApproachingInterval = function (e, t, n, i) { let o = $me(e, t, n), r = this._tilesRequestedForInterval, s = epe(this), a = { key: o, priorityFunction: i.priorityFunction }; (!l(s) || !tpe(this, a, s)) && r.push(a), r.length >= 512 && r.splice(0, 256) }; JD.prototype._clockOnTick = function (e) { let t = e.currentTime, i = this._times.indexOf(t), o = this._currentIntervalIndex; if (i !== o) { let s = this._tileCache[o]; for (let a in s) s.hasOwnProperty(a) && s[a].request.cancel(); delete this._tileCache[o], this._tilesRequestedForInterval = [], this._currentIntervalIndex = i, this._reloadFunction(); return } let r = epe(this); if (l(r)) { let s = this._tilesRequestedForInterval, a = !0; for (; a && s.length !== 0;) { let c = s.pop(); a = tpe(this, c, r), a || s.push(c) } } }; function $me(e, t, n) { return `${e}-${t}-${n}` } function ait(e) { let t = e.split("-"); if (t.length === 3) return { x: Number(t[0]), y: Number(t[1]), level: Number(t[2]) } } function epe(e) { let t = e._times; if (!l(t)) return; let n = e._clock, i = n.currentTime, o = n.canAnimate && n.shouldAnimate, r = n.multiplier; if (!o && r !== 0) return; let s, a = t.indexOf(i); if (a < 0) return; let c = t.get(a); return r > 0 ? (s = $.secondsDifference(c.stop, i), ++a) : (s = $.secondsDifference(c.start, i), --a), s /= r, a >= 0 && s <= 5 ? t.get(a) : void 0 } function tpe(e, t, n) { let i = e._times.indexOf(n.start), o = e._tileCache, r = o[i]; l(r) || (r = o[i] = {}); let s = t.key; if (l(r[s])) return !0; let a = ait(s), c = new jo({ throttle: !1, throttleByServer: !0, type: Xr.IMAGERY, priorityFunction: t.priorityFunction }), u = e._requestImageFunction(a.x, a.y, a.level, c, n); return l(u) ? (r[s] = { promise: u, request: c }, !0) : !1 } var PE = JD; var cit = [3034, 3035, 3042, 3043, 3044], lit = [4471, 4559]; function ud(e) { if (e = y(e, y.EMPTY_OBJECT), l(e.times) && !l(e.clock)) throw new ye("options.times was specified, so options.clock is required."); this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0, this._getFeatureInfoUrl = y(e.getFeatureInfoUrl, e.url); let t = Pe.createIfNeeded(e.url), n = Pe.createIfNeeded(this._getFeatureInfoUrl); t.setQueryParameters(ud.DefaultParameters, !0), n.setQueryParameters(ud.GetFeatureInfoDefaultParameters, !0), l(e.parameters) && t.setQueryParameters(npe(e.parameters)), l(e.getFeatureInfoParameters) && n.setQueryParameters(npe(e.getFeatureInfoParameters)); let i = this; this._reload = void 0, l(e.times) && (this._timeDynamicImagery = new PE({ clock: e.clock, times: e.times, requestImageFunction: function (s, a, c, u, f) { return ipe(i, s, a, c, u, f) }, reloadFunction: function () { l(i._reload) && i._reload() } })); let o = {}; if (o.layers = e.layers, o.bbox = "{westProjected},{southProjected},{eastProjected},{northProjected}", o.width = "{width}", o.height = "{height}", parseFloat(t.queryParameters.version) >= 1.3) { o.crs = y(e.crs, e.tilingScheme && e.tilingScheme.projection instanceof Ri ? "EPSG:3857" : "CRS:84"); let s = o.crs.split(":"); if (s[0] === "EPSG" && s.length === 2) { let a = Number(s[1]); (a >= 4e3 && a < 5e3 && !lit.includes(a) || cit.includes(a)) && (o.bbox = "{southProjected},{westProjected},{northProjected},{eastProjected}") } } else o.srs = y(e.srs, e.tilingScheme && e.tilingScheme.projection instanceof Ri ? "EPSG:3857" : "EPSG:4326"); t.setQueryParameters(o, !0), n.setQueryParameters(o, !0); let r = { query_layers: e.layers, info_format: "{format}" }; parseFloat(n.queryParameters.version) >= 1.3 ? (r.i = "{i}", r.j = "{j}") : (r.x = "{i}", r.y = "{j}"), n.setQueryParameters(r, !0), this._resource = t, this._pickFeaturesResource = n, this._layers = e.layers, this._tileProvider = new Ua({ url: t, pickFeaturesUrl: n, tilingScheme: y(e.tilingScheme, new Hi({ ellipsoid: e.ellipsoid })), rectangle: e.rectangle, tileWidth: e.tileWidth, tileHeight: e.tileHeight, minimumLevel: e.minimumLevel, maximumLevel: e.maximumLevel, subdomains: e.subdomains, tileDiscardPolicy: e.tileDiscardPolicy, credit: e.credit, getFeatureInfoFormats: y(e.getFeatureInfoFormats, ud.DefaultGetFeatureInfoFormats), enablePickFeatures: e.enablePickFeatures }) } function ipe(e, t, n, i, o, r) { let s = l(r) ? r.data : void 0, a = e._tileProvider; return l(s) && a._resource.setQueryParameters(s), a.requestImage(t, n, i, o) } function uit(e, t, n, i, o, r, s) { let a = l(s) ? s.data : void 0, c = e._tileProvider; return l(a) && c._pickFeaturesResource.setQueryParameters(a), c.pickFeatures(t, n, i, o, r) } Object.defineProperties(ud.prototype, { url: { get: function () { return this._resource._url } }, proxy: { get: function () { return this._resource.proxy } }, layers: { get: function () { return this._layers } }, tileWidth: { get: function () { return this._tileProvider.tileWidth } }, tileHeight: { get: function () { return this._tileProvider.tileHeight } }, maximumLevel: { get: function () { return this._tileProvider.maximumLevel } }, minimumLevel: { get: function () { return this._tileProvider.minimumLevel } }, tilingScheme: { get: function () { return this._tileProvider.tilingScheme } }, rectangle: { get: function () { return this._tileProvider.rectangle } }, tileDiscardPolicy: { get: function () { return this._tileProvider.tileDiscardPolicy } }, errorEvent: { get: function () { return this._tileProvider.errorEvent } }, ready: { get: function () { return this._tileProvider.ready } }, readyPromise: { get: function () { return this._tileProvider.readyPromise } }, credit: { get: function () { return this._tileProvider.credit } }, hasAlphaChannel: { get: function () { return this._tileProvider.hasAlphaChannel } }, enablePickFeatures: { get: function () { return this._tileProvider.enablePickFeatures }, set: function (e) { this._tileProvider.enablePickFeatures = e } }, clock: { get: function () { return this._timeDynamicImagery.clock }, set: function (e) { this._timeDynamicImagery.clock = e } }, times: { get: function () { return this._timeDynamicImagery.times }, set: function (e) { this._timeDynamicImagery.times = e } }, getFeatureInfoUrl: { get: function () { return this._getFeatureInfoUrl } } }); ud.prototype.getTileCredits = function (e, t, n) { return this._tileProvider.getTileCredits(e, t, n) }; ud.prototype.requestImage = function (e, t, n, i) { let o, r = this._timeDynamicImagery, s; return l(r) && (s = r.currentInterval, o = r.getFromCache(e, t, n, i)), l(o) || (o = ipe(this, e, t, n, i, s)), l(o) && l(r) && r.checkApproachingInterval(e, t, n, i), o }; ud.prototype.pickFeatures = function (e, t, n, i, o) { let r = this._timeDynamicImagery, s = l(r) ? r.currentInterval : void 0; return uit(this, e, t, n, i, o, s) }; ud.DefaultParameters = Object.freeze({ service: "WMS", version: "1.1.1", request: "GetMap", styles: "", format: "image/jpeg" }); ud.GetFeatureInfoDefaultParameters = Object.freeze({ service: "WMS", version: "1.1.1", request: "GetFeatureInfo" }); ud.DefaultGetFeatureInfoFormats = Object.freeze([Object.freeze(new vE("json", "application/json")), Object.freeze(new vE("xml", "text/xml")), Object.freeze(new vE("text", "text/html"))]); function npe(e) { let t = {}; for (let n in e) e.hasOwnProperty(n) && (t[n.toLowerCase()] = e[n]); return t } var GV = ud; var fit = Object.freeze({ service: "WMTS", version: "1.0.0", request: "GetTile" }); function ZD(e) { e = y(e, y.EMPTY_OBJECT), this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0; let t = Pe.createIfNeeded(e.url), n = e.style, i = e.tileMatrixSetID, o = t.url, r = o.match(/{/g); if (!l(r) || r.length === 1 && /{s}/.test(o)) t.setQueryParameters(fit), this._useKvp = !0; else { let d = { style: n, Style: n, TileMatrixSet: i }; t.setTemplateValues(d), this._useKvp = !1 } this._resource = t, this._layer = e.layer, this._style = n, this._tileMatrixSetID = i, this._tileMatrixLabels = e.tileMatrixLabels, this._format = y(e.format, "image/jpeg"), this._tileDiscardPolicy = e.tileDiscardPolicy, this._tilingScheme = l(e.tilingScheme) ? e.tilingScheme : new Gr({ ellipsoid: e.ellipsoid }), this._tileWidth = y(e.tileWidth, 256), this._tileHeight = y(e.tileHeight, 256), this._minimumLevel = y(e.minimumLevel, 0), this._maximumLevel = e.maximumLevel, this._rectangle = y(e.rectangle, this._tilingScheme.rectangle), this._dimensions = e.dimensions; let s = this; this._reload = void 0, l(e.times) && (this._timeDynamicImagery = new PE({ clock: e.clock, times: e.times, requestImageFunction: function (d, p, g, m, A) { return ope(s, d, p, g, m, A) }, reloadFunction: function () { l(s._reload) && s._reload() } })), this._readyPromise = Promise.resolve(!0); let a = this._tilingScheme.positionToTileXY(ce.southwest(this._rectangle), this._minimumLevel), c = this._tilingScheme.positionToTileXY(ce.northeast(this._rectangle), this._minimumLevel), u = (Math.abs(c.x - a.x) + 1) * (Math.abs(c.y - a.y) + 1); this._errorEvent = new _e; let f = e.credit; this._credit = typeof f == "string" ? new Xt(f) : f, this._subdomains = e.subdomains, Array.isArray(this._subdomains) ? this._subdomains = this._subdomains.slice() : l(this._subdomains) && this._subdomains.length > 0 ? this._subdomains = this._subdomains.split("") : this._subdomains = ["a", "b", "c"] } function ope(e, t, n, i, o, r) { let s = e._tileMatrixLabels, a = l(s) ? s[i] : i.toString(), c = e._subdomains, u = e._dimensions, f = l(r) ? r.data : void 0, d, p; if (!e._useKvp) p = { TileMatrix: a, TileRow: n.toString(), TileCol: t.toString(), s: c[(t + n + i) % c.length] }, d = e._resource.getDerivedResource({ request: o }), d.setTemplateValues(p), l(u) && d.setTemplateValues(u), l(f) && d.setTemplateValues(f); else { let g = {}; g.tilematrix = a, g.layer = e._layer, g.style = e._style, g.tilerow = n, g.tilecol = t, g.tilematrixset = e._tileMatrixSetID, g.format = e._format, l(u) && (g = yt(g, u)), l(f) && (g = yt(g, f)), p = { s: c[(t + n + i) % c.length] }, d = e._resource.getDerivedResource({ queryParameters: g, request: o }), d.setTemplateValues(p) } return tl.loadImage(e, d) } Object.defineProperties(ZD.prototype, { url: { get: function () { return this._resource.url } }, proxy: { get: function () { return this._resource.proxy } }, tileWidth: { get: function () { return this._tileWidth } }, tileHeight: { get: function () { return this._tileHeight } }, maximumLevel: { get: function () { return this._maximumLevel } }, minimumLevel: { get: function () { return this._minimumLevel } }, tilingScheme: { get: function () { return this._tilingScheme } }, rectangle: { get: function () { return this._rectangle } }, tileDiscardPolicy: { get: function () { return this._tileDiscardPolicy } }, errorEvent: { get: function () { return this._errorEvent } }, format: { get: function () { return this._format } }, ready: { value: !0 }, readyPromise: { get: function () { return this._readyPromise } }, credit: { get: function () { return this._credit } }, hasAlphaChannel: { get: function () { return !0 } }, clock: { get: function () { return this._timeDynamicImagery.clock }, set: function (e) { this._timeDynamicImagery.clock = e } }, times: { get: function () { return this._timeDynamicImagery.times }, set: function (e) { this._timeDynamicImagery.times = e } }, dimensions: { get: function () { return this._dimensions }, set: function (e) { this._dimensions !== e && (this._dimensions = e, l(this._reload) && this._reload()) } } }); ZD.prototype.getTileCredits = function (e, t, n) { }; ZD.prototype.requestImage = function (e, t, n, i) { let o, r = this._timeDynamicImagery, s; return l(r) && (s = r.currentInterval, o = r.getFromCache(e, t, n, i)), l(o) || (o = ope(this, e, t, n, i, s)), l(o) && l(r) && r.checkApproachingInterval(e, t, n, i), o }; ZD.prototype.pickFeatures = function (e, t, n, i, o) { }; var WV = ZD; function fp(e) { return function (t) { return new e(t) } } var dit = { ARCGIS_MAPSERVER: fp(Mg), BING: fp(mV), GOOGLE_EARTH: fp(kV), MAPBOX: fp(UV), SINGLE_TILE: fp(zV), TMS: fp(tA), URL_TEMPLATE: fp(Ua), WMS: fp(GV), WMTS: fp(WV) }; function Ng(e) { e = y(e, y.EMPTY_OBJECT); let t = e.assetId; this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0, this._ready = !1, this._tileCredits = void 0, this._errorEvent = new _e; let n = this, i = wh._createEndpointResource(t, e), o = e.assetId.toString() + e.accessToken + e.server, r = Ng._endpointCache[o]; l(r) || (r = i.fetchJson(), Ng._endpointCache[o] = r), this._readyPromise = r.then(function (s) { if (s.type !== "IMAGERY") return Promise.reject(new fe(`Cesium ion asset ${t} is not an imagery asset.`)); let a, c = s.externalType; if (!l(c)) a = new tA({ url: new wh(s, i) }); else { let u = dit[c]; if (!l(u)) return Promise.reject(new fe(`Unrecognized Cesium ion imagery type: ${c}`)); a = u(s.options) } return n._tileCredits = wh.getCreditsFromEndpoint(s, i), a.errorEvent.addEventListener(function (u) { u.provider = n, n._errorEvent.raiseEvent(u) }), n._imageryProvider = a, a.readyPromise.then(function () { return n._ready = !0, !0 }) }) } Object.defineProperties(Ng.prototype, { ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } }, rectangle: { get: function () { return this._imageryProvider.rectangle } }, tileWidth: { get: function () { return this._imageryProvider.tileWidth } }, tileHeight: { get: function () { return this._imageryProvider.tileHeight } }, maximumLevel: { get: function () { return this._imageryProvider.maximumLevel } }, minimumLevel: { get: function () { return this._imageryProvider.minimumLevel } }, tilingScheme: { get: function () { return this._imageryProvider.tilingScheme } }, tileDiscardPolicy: { get: function () { return this._imageryProvider.tileDiscardPolicy } }, errorEvent: { get: function () { return this._errorEvent } }, credit: { get: function () { return this._imageryProvider.credit } }, hasAlphaChannel: { get: function () { return this._imageryProvider.hasAlphaChannel }, proxy: { get: function () { } } } }); Ng.prototype.getTileCredits = function (e, t, n) { let i = this._imageryProvider.getTileCredits(e, t, n); return l(i) ? this._tileCredits.concat(i) : this._tileCredits }; Ng.prototype.requestImage = function (e, t, n, i) { return this._imageryProvider.requestImage(e, t, n, i) }; Ng.prototype.pickFeatures = function (e, t, n, i, o) { return this._imageryProvider.pickFeatures(e, t, n, i, o) }; Ng._endpointCache = {}; var Vg = Ng; var hit = { AERIAL: 2, AERIAL_WITH_LABELS: 3, ROAD: 4 }, kg = Object.freeze(hit); function mit(e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.style, kg.AERIAL); return new Vg({ assetId: t }) } var Ug = mit; var lpe = po(al(), 1), rpe = 576, pit = 100, QD = "#ffffff", Q7 = "#48b"; function upe(e, t) { this.credit = e, this.count = y(t, 1) } function _it(e, t) { let n = e.length; for (let i = 0; i < n; i++) { let o = e[i]; if (Xt.equals(o, t)) return !0 } return !1 } function git(e) { let t = e._previousCesiumCredit, n = e._currentCesiumCredit; Xt.equals(n, t) || (l(t) && e._cesiumCreditContainer.removeChild(t.element), l(n) && e._cesiumCreditContainer.appendChild(n.element), e._previousCesiumCredit = n) } var fpe = "cesium-credit-delimiter"; function spe(e) { let t = document.createElement("span"); return t.textContent = e, t.className = fpe, t } function ape(e, t) { if (l(t)) { let n = document.createElement(t); n._creditId = e._creditId, n.appendChild(e), e = n } return e } function cpe(e, t, n, i) { let o = e.childNodes, r = -1; t.sort(function (s, a) { return a.count - s.count }); for (let s = 0; s < t.length; ++s) { let a = t[s].credit; if (l(a)) { if (r = s, l(n) && (r *= 2, s > 0)) { let u = r - 1; if (o.length <= u) e.appendChild(spe(n)); else { let f = o[u]; f.className !== fpe && e.replaceChild(spe(n), f) } } let c = a.element; if (o.length <= r) e.appendChild(ape(c, i)); else { let u = o[r]; u._creditId !== a._id && e.replaceChild(ape(c, i), u) } } } for (++r; r < o.length;)e.removeChild(o[r]) } function yit(e) { let t = e._lightboxCredits, n = e.viewport.clientWidth, i = e.viewport.clientHeight; n !== e._lastViewportWidth && (n < rpe ? (t.className = "cesium-credit-lightbox cesium-credit-lightbox-mobile", t.style.marginTop = "0") : (t.className = "cesium-credit-lightbox cesium-credit-lightbox-expanded", t.style.marginTop = `${Math.floor((i - t.clientHeight) * .5)}px`), e._lastViewportWidth = n), n >= rpe && i !== e._lastViewportHeight && (t.style.marginTop = `${Math.floor((i - t.clientHeight) * .5)}px`, e._lastViewportHeight = i) } function za(e, t) {
        let n = `${e} {`; for (let i in t) t.hasOwnProperty(i) && (n += `${i}: ${t[i]}; `); return n += ` }
`, n
    } function Ait() { let e = ""; e += za(".cesium-credit-lightbox-overlay", { display: "none", "z-index": "1", position: "absolute", top: "0", left: "0", width: "100%", height: "100%", "background-color": "rgba(80, 80, 80, 0.8)" }), e += za(".cesium-credit-lightbox", { "background-color": "#303336", color: QD, position: "relative", "min-height": `${pit}px`, margin: "auto" }), e += za(".cesium-credit-lightbox > ul > li a, .cesium-credit-lightbox > ul > li a:visited", { color: QD }), e += za(".cesium-credit-lightbox > ul > li a:hover", { color: Q7 }), e += za(".cesium-credit-lightbox.cesium-credit-lightbox-expanded", { border: "1px solid #444", "border-radius": "5px", "max-width": "370px" }), e += za(".cesium-credit-lightbox.cesium-credit-lightbox-mobile", { height: "100%", width: "100%" }), e += za(".cesium-credit-lightbox-title", { padding: "20px 20px 0 20px" }), e += za(".cesium-credit-lightbox-close", { "font-size": "18pt", cursor: "pointer", position: "absolute", top: "0", right: "6px", color: QD }), e += za(".cesium-credit-lightbox-close:hover", { color: Q7 }), e += za(".cesium-credit-lightbox > ul", { margin: "0", padding: "12px 20px 12px 40px", "font-size": "13px" }), e += za(".cesium-credit-lightbox > ul > li", { "padding-bottom": "6px" }), e += za(".cesium-credit-lightbox > ul > li *", { padding: "0", margin: "0" }), e += za(".cesium-credit-expand-link", { "padding-left": "5px", cursor: "pointer", "text-decoration": "underline", color: QD }), e += za(".cesium-credit-expand-link:hover", { color: Q7 }), e += za(".cesium-credit-text", { color: QD }), e += za(".cesium-credit-textContainer *, .cesium-credit-logoContainer *", { display: "inline" }); let t = document.head, n = document.createElement("style"); n.innerHTML = e, t.insertBefore(n, t.firstChild) } function ur(e, t, n) { let i = this; n = y(n, document.body); let o = document.createElement("div"); o.className = "cesium-credit-lightbox-overlay", n.appendChild(o); let r = document.createElement("div"); r.className = "cesium-credit-lightbox", o.appendChild(r); function s(m) { r.contains(m.target) || i.hideLightbox() } o.addEventListener("click", s, !1); let a = document.createElement("div"); a.className = "cesium-credit-lightbox-title", a.textContent = "Data provided by:", r.appendChild(a); let c = document.createElement("a"); c.onclick = this.hideLightbox.bind(this), c.innerHTML = "&times;", c.className = "cesium-credit-lightbox-close", r.appendChild(c); let u = document.createElement("ul"); r.appendChild(u); let f = document.createElement("div"); f.className = "cesium-credit-logoContainer", f.style.display = "inline", e.appendChild(f); let d = document.createElement("div"); d.className = "cesium-credit-textContainer", d.style.display = "inline", e.appendChild(d); let p = document.createElement("a"); p.className = "cesium-credit-expand-link", p.onclick = this.showLightbox.bind(this), p.textContent = "Data attribution", e.appendChild(p), Ait(); let g = Xt.clone(ur.cesiumCredit); this._delimiter = y(t, " \u2022 "), this._screenContainer = d, this._cesiumCreditContainer = f, this._lastViewportHeight = void 0, this._lastViewportWidth = void 0, this._lightboxCredits = r, this._creditList = u, this._lightbox = o, this._hideLightbox = s, this._expandLink = p, this._expanded = !1, this._defaultCredits = [], this._cesiumCredit = g, this._previousCesiumCredit = void 0, this._currentCesiumCredit = g, this._creditDisplayElementPool = [], this._creditDisplayElementIndex = 0, this._currentFrameCredits = { screenCredits: new Ct, lightboxCredits: new Ct }, this._defaultCredit = void 0, this.viewport = n, this.container = e } function dpe(e, t, n, i) { i = y(i, 1); let o = t.get(n.id); if (l(o)) o.count < Number.MAX_VALUE && (o.count += i); else { let r = e._creditDisplayElementPool, s = e._creditDisplayElementPoolIndex; s < r.length ? (o = r[s], o.credit = n, o.count = i) : (o = new upe(n, i), r.push(o)), ++e._creditDisplayElementPoolIndex, t.set(n.id, o) } } ur.prototype.addCredit = function (e) { if (e._isIon) { l(this._defaultCredit) || (this._defaultCredit = Xt.clone(hpe())), this._currentCesiumCredit = this._defaultCredit; return } let t; e.showOnScreen ? t = this._currentFrameCredits.screenCredits : t = this._currentFrameCredits.lightboxCredits, dpe(this, t, e) }; ur.prototype.addDefaultCredit = function (e) { let t = this._defaultCredits; _it(t, e) || t.push(e) }; ur.prototype.removeDefaultCredit = function (e) { let t = this._defaultCredits, n = t.indexOf(e); n !== -1 && t.splice(n, 1) }; ur.prototype.showLightbox = function () { this._lightbox.style.display = "block", this._expanded = !0 }; ur.prototype.hideLightbox = function () { this._lightbox.style.display = "none", this._expanded = !1 }; ur.prototype.update = function () { this._expanded && yit(this) }; ur.prototype.beginFrame = function () { let e = this._currentFrameCredits; this._creditDisplayElementPoolIndex = 0; let t = e.screenCredits; t.removeAll(); let n = this._defaultCredits; for (let i = 0; i < n.length; ++i) { let o = n[i]; dpe(this, t, o, Number.MAX_VALUE) } e.lightboxCredits.removeAll(), Xt.equals(ur.cesiumCredit, this._cesiumCredit) || (this._cesiumCredit = Xt.clone(ur.cesiumCredit)), this._currentCesiumCredit = this._cesiumCredit }; ur.prototype.endFrame = function () { let e = this._currentFrameCredits.screenCredits.values; cpe(this._screenContainer, e, this._delimiter, void 0); let t = this._currentFrameCredits.lightboxCredits.values; this._expandLink.style.display = t.length > 0 ? "inline" : "none", cpe(this._creditList, t, void 0, "li"), git(this) }; ur.prototype.destroy = function () { return this._lightbox.removeEventListener("click", this._hideLightbox, !1), this.container.removeChild(this._cesiumCreditContainer), this.container.removeChild(this._screenContainer), this.container.removeChild(this._expandLink), this.viewport.removeChild(this._lightbox), le(this) }; ur.prototype.isDestroyed = function () { return !1 }; ur._cesiumCredit = void 0; ur._cesiumCreditInitialized = !1; var jV; function hpe() { if (!l(jV)) { let e = Jt("Assets/Images/ion-credit.png"); e.indexOf("http://") !== 0 && e.indexOf("https://") !== 0 && e.indexOf("data:") !== 0 && (e = new lpe.default(e).path()), jV = new Xt(`<a href="https://cesium.com/" target="_blank"><img src="${e}" title="Cesium ion"/></a>`, !0) } return ur._cesiumCreditInitialized || (ur._cesiumCredit = jV, ur._cesiumCreditInitialized = !0), jV } Object.defineProperties(ur, { cesiumCredit: { get: function () { return hpe(), ur._cesiumCredit }, set: function (e) { ur._cesiumCredit = e, ur._cesiumCreditInitialized = !0 } } }); ur.CreditDisplayElement = upe; var qV = ur; function $D(e) {
        e = y(e, y.EMPTY_OBJECT); let t = e.attributeName, n = e.perInstanceAttribute; l(n) || (n = !1); let i = y(e.glslDatatype, "vec3"), o = `v_${t}`, r; if (t === "normal" || t === "tangent" || t === "bitangent") r = `vec4 getColor() { return vec4((${o} + vec3(1.0)) * 0.5, 1.0); }
`; else switch (t === "st" && (i = "vec2"), i) {
            case "float": r = `vec4 getColor() { return vec4(vec3(${o}), 1.0); }
`; break; case "vec2": r = `vec4 getColor() { return vec4(${o}, 0.0, 1.0); }
`; break; case "vec3": r = `vec4 getColor() { return vec4(${o}, 1.0); }
`; break; case "vec4": r = `vec4 getColor() { return ${o}; }
`; break
        }let s = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;
attribute float batchId;
${n ? "" : `attribute ${i} ${t};
`}varying ${i} ${o};
void main()
{
vec4 p = czm_translateRelativeToEye(position3DHigh, position3DLow);
${n ? `${o} = czm_batchTable_${t}(batchId);
`: `${o} = ${t};
`}gl_Position = czm_modelViewProjectionRelativeToEye * p;
}`, a = `varying ${i} ${o};
${r}
void main()
{
gl_FragColor = getColor();
}`; this.material = void 0, this.translucent = y(e.translucent, !1), this._vertexShaderSource = y(e.vertexShaderSource, s), this._fragmentShaderSource = y(e.fragmentShaderSource, a), this._renderState = Yi.getDefaultRenderState(!1, !1, e.renderState), this._closed = y(e.closed, !1), this._attributeName = t, this._glslDatatype = i
    } Object.defineProperties($D.prototype, { vertexShaderSource: { get: function () { return this._vertexShaderSource } }, fragmentShaderSource: { get: function () { return this._fragmentShaderSource } }, renderState: { get: function () { return this._renderState } }, closed: { get: function () { return this._closed } }, attributeName: { get: function () { return this._attributeName } }, glslDatatype: { get: function () { return this._glslDatatype } } }); $D.prototype.getFragmentShaderSource = Yi.prototype.getFragmentShaderSource; $D.prototype.isTranslucent = Yi.prototype.isTranslucent; $D.prototype.getRenderState = Yi.prototype.getRenderState; var mpe = $D; function YV(e) { e = y(e, y.EMPTY_OBJECT), this._camera = e.camera, this._frustumSplits = e.frustumSplits, this._color = y(e.color, U.CYAN), this._updateOnChange = y(e.updateOnChange, !0), this.show = y(e.show, !0), this.id = e.id, this._id = void 0, this._outlinePrimitives = [], this._planesPrimitives = [] } var Cit = new h, xit = new Q, Tit = new Be, Eit = new mi, bit = new $c, Sit = new Zt, wit = new wr, Dit = new U, vit = [1, 1e5]; YV.prototype.update = function (e) { if (!this.show) return; let t = this._planesPrimitives, n = this._outlinePrimitives, i, o; if (this._updateOnChange) { for (o = t.length, i = 0; i < o; ++i)n[i] = n[i] && n[i].destroy(), t[i] = t[i] && t[i].destroy(); t.length = 0, n.length = 0 } if (t.length === 0) { let r = this._camera, s = r.frustum, a; s instanceof mi ? a = Eit : s instanceof $c ? a = bit : s instanceof Zt ? a = Sit : a = wit, a = s.clone(a); let c, u = this._frustumSplits; !l(u) || u.length <= 1 ? (u = vit, u[0] = this._camera.frustum.near, u[1] = this._camera.frustum.far, c = 1) : c = u.length - 1; let f = r.positionWC, d = r.directionWC, p = r.upWC, g = r.rightWC; g = h.negate(g, Cit); let m = xit; Q.setColumn(m, 0, g, m), Q.setColumn(m, 1, p, m), Q.setColumn(m, 2, d, m); let A = Be.fromRotationMatrix(m, Tit); for (t.length = n.length = c, i = 0; i < c; ++i)a.near = u[i], a.far = u[i + 1], t[i] = new xn({ geometryInstances: new At({ geometry: new fE({ origin: f, orientation: A, frustum: a, _drawNearPlane: i === 0 }), attributes: { color: Bt.fromColor(U.fromAlpha(this._color, .1, Dit)) }, id: this.id, pickPrimitive: this }), appearance: new $t({ translucent: !0, flat: !0 }), asynchronous: !1 }), n[i] = new xn({ geometryInstances: new At({ geometry: new H3({ origin: f, orientation: A, frustum: a, _drawNearPlane: i === 0 }), attributes: { color: Bt.fromColor(this._color) }, id: this.id, pickPrimitive: this }), appearance: new $t({ translucent: !1, flat: !0 }), asynchronous: !1 }) } for (o = t.length, i = 0; i < o; ++i)n[i].update(e), t[i].update(e) }; YV.prototype.isDestroyed = function () { return !1 }; YV.prototype.destroy = function () { let e = this._planesPrimitives.length; for (let t = 0; t < e; ++t)this._outlinePrimitives[t] = this._outlinePrimitives[t] && this._outlinePrimitives[t].destroy(), this._planesPrimitives[t] = this._planesPrimitives[t] && this._planesPrimitives[t].destroy(); return le(this) }; var dp = YV; function ppe() { this._cachedShowFrustumsShaders = {} } function Pit(e) { let t = {}, n = e.vertexAttributes; for (let i in n) n.hasOwnProperty(i) && (t[i] = n[i].index); return t } function Iit(e, t) {
        let n = e.context, i = t, o = i.fragmentShaderSource.clone(), r = []; o.sources = o.sources.map(function (f) { f = Ue.replaceMain(f, "czm_Debug_main"); let d = /gl_FragData\[(\d+)\]/g, p; for (; (p = d.exec(f)) !== null;)r.indexOf(p[1]) === -1 && r.push(p[1]); return f }); let s = r.length, a = ""; a += `uniform vec3 debugShowCommandsColor;
`, a += `uniform vec3 debugShowFrustumsColor;
`, a += `void main() 
{ 
    czm_Debug_main(); 
`; let c; if (s > 0) for (c = 0; c < s; ++c)a += `    gl_FragData[${r[c]}].rgb *= debugShowCommandsColor;
`, a += `    gl_FragData[${r[c]}].rgb *= debugShowFrustumsColor;
`; else a += `    gl_FragColor.rgb *= debugShowCommandsColor;
`, a += `    gl_FragColor.rgb *= debugShowFrustumsColor;
`; a += "}", o.sources.push(a); let u = Pit(i); return qt.fromCache({ context: n, vertexShaderSource: i.vertexShaderSource, fragmentShaderSource: o, attributeLocations: u })
    } var ev = new U; function Oit(e, t) { let n; return l(t.uniformMap) ? n = t.uniformMap : n = {}, l(n.debugShowCommandsColor) || l(n.debugShowFrustumsColor) || (n.debugShowCommandsColor = function () { return e.debugShowCommands ? (l(t._debugColor) || (t._debugColor = U.fromRandom()), t._debugColor) : U.WHITE }, n.debugShowFrustumsColor = function () { return e.debugShowFrustums ? (ev.red = t.debugOverlappingFrustums & 1 << 0 ? 1 : 0, ev.green = t.debugOverlappingFrustums & 1 << 1 ? 1 : 0, ev.blue = t.debugOverlappingFrustums & 1 << 2 ? 1 : 0, ev.alpha = 1, ev) : U.WHITE }), n } var Bit = new $e; ppe.prototype.executeDebugShowFrustumsCommand = function (e, t, n) { let i = t.shaderProgram.id, o = this._cachedShowFrustumsShaders[i]; l(o) || (o = Iit(e, t.shaderProgram), this._cachedShowFrustumsShaders[i] = o); let r = $e.shallowClone(t, Bit); r.shaderProgram = o, r.uniformMap = Oit(e, t), r.execute(e.context, n) }; var XV = ppe; function KV(e) { e = y(e, y.EMPTY_OBJECT), this.length = y(e.length, 1e7), this._length = void 0, this.width = y(e.width, 2), this._width = void 0, this.show = y(e.show, !0), this.modelMatrix = F.clone(y(e.modelMatrix, F.IDENTITY)), this._modelMatrix = new F, this.id = e.id, this._id = void 0, this._primitive = void 0 } KV.prototype.update = function (e) { if (!!this.show) { if (!l(this._primitive) || !F.equals(this._modelMatrix, this.modelMatrix) || this._length !== this.length || this._width !== this.width || this._id !== this.id) { this._modelMatrix = F.clone(this.modelMatrix, this._modelMatrix), this._length = this.length, this._width = this.width, this._id = this.id, l(this._primitive) && this._primitive.destroy(), this.modelMatrix[12] === 0 && this.modelMatrix[13] === 0 && this.modelMatrix[14] === 0 && (this.modelMatrix[14] = .01); let t = new At({ geometry: new lg({ positions: [h.ZERO, h.UNIT_X], width: this.width, vertexFormat: Vr.VERTEX_FORMAT, colors: [U.RED, U.RED], arcType: Yt.NONE }), modelMatrix: F.multiplyByUniformScale(this.modelMatrix, this.length, new F), id: this.id, pickPrimitive: this }), n = new At({ geometry: new lg({ positions: [h.ZERO, h.UNIT_Y], width: this.width, vertexFormat: Vr.VERTEX_FORMAT, colors: [U.GREEN, U.GREEN], arcType: Yt.NONE }), modelMatrix: F.multiplyByUniformScale(this.modelMatrix, this.length, new F), id: this.id, pickPrimitive: this }), i = new At({ geometry: new lg({ positions: [h.ZERO, h.UNIT_Z], width: this.width, vertexFormat: Vr.VERTEX_FORMAT, colors: [U.BLUE, U.BLUE], arcType: Yt.NONE }), modelMatrix: F.multiplyByUniformScale(this.modelMatrix, this.length, new F), id: this.id, pickPrimitive: this }); this._primitive = new xn({ geometryInstances: [t, n, i], appearance: new Vr, asynchronous: !1 }) } this._primitive.update(e) } }; KV.prototype.isDestroyed = function () { return !1 }; KV.prototype.destroy = function () { return this._primitive = this._primitive && this._primitive.destroy(), le(this) }; var JV = KV; var ZV = `varying vec4 positionEC;
void main()
{
vec3 position;
vec3 direction;
if (czm_orthographicIn3D == 1.0)
{
vec2 uv = (gl_FragCoord.xy -  czm_viewport.xy) / czm_viewport.zw;
vec2 minPlane = vec2(czm_frustumPlanes.z, czm_frustumPlanes.y);
vec2 maxPlane = vec2(czm_frustumPlanes.w, czm_frustumPlanes.x);
position = vec3(mix(minPlane, maxPlane, uv), 0.0);
direction = vec3(0.0, 0.0, -1.0);
}
else
{
position = vec3(0.0);
direction = normalize(positionEC.xyz);
}
czm_ray ray = czm_ray(position, direction);
vec3 ellipsoid_center = czm_view[3].xyz;
czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid_center, czm_ellipsoidInverseRadii);
if (!czm_isEmpty(intersection))
{
gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
}
else
{
discard;
}
czm_writeLogDepth();
}
`; var QV = `attribute vec4 position;
varying vec4 positionEC;
void main()
{
positionEC = czm_modelView * position;
gl_Position = czm_projection * positionEC;
czm_vertexLogDepth();
}
`; function nv(e) { this._rs = void 0, this._sp = void 0, this._va = void 0, this._command = void 0, this._mode = void 0, this._useLogDepth = !1, this._ellipsoidOffset = y(e, 0) } var tv = Nt.supportsTypedArrays() ? new Float32Array(12) : [], _pe = new h, gpe = new h, $7 = new h, ype = new h, $V = new h; function Rit(e, t) { let n = e.radii, i = t.camera, o, r, s; if (i.frustum instanceof Zt) o = h.ZERO, r = i.rightWC, s = i.upWC; else { let d = i.positionWC, p = h.multiplyComponents(e.oneOverRadii, d, _pe), g = h.normalize(p, gpe), m = h.normalize(h.cross(h.UNIT_Z, p, $7), $7), A = h.normalize(h.cross(g, m, ype), ype), C = h.magnitude(p), x = Math.sqrt(C * C - 1); o = h.multiplyByScalar(g, 1 / C, _pe); let T = x / C; r = h.multiplyByScalar(m, T, gpe), s = h.multiplyByScalar(A, T, $7) } let a = h.add(o, s, $V); h.subtract(a, r, a), h.multiplyComponents(n, a, a), h.pack(a, tv, 0); let c = h.subtract(o, s, $V); h.subtract(c, r, c), h.multiplyComponents(n, c, c), h.pack(c, tv, 3); let u = h.add(o, s, $V); h.add(u, r, u), h.multiplyComponents(n, u, u), h.pack(u, tv, 6); let f = h.subtract(o, s, $V); return h.add(f, r, f), h.multiplyComponents(n, f, f), h.pack(f, tv, 9), tv } nv.prototype.update = function (e) {
        if (this._mode = e.mode, e.mode !== ee.SCENE3D) return; let t = e.context, n = e.mapProjection.ellipsoid.radii, i = new ie(n.x + this._ellipsoidOffset, n.y + this._ellipsoidOffset, n.z + this._ellipsoidOffset), o = e.useLogDepth; if (l(this._command) || (this._rs = Ve.fromCache({ cull: { enabled: !0 }, depthTest: { enabled: !0 }, colorMask: { red: !1, green: !1, blue: !1, alpha: !1 } }), this._command = new $e({ renderState: this._rs, boundingVolume: new re(h.ZERO, i.maximumRadius), pass: xe.OPAQUE, owner: this })), !l(this._sp) || this._useLogDepth !== o) {
            this._useLogDepth = o; let s = new Ue({ sources: [QV] }), a = new Ue({ sources: [ZV] }); if (o) {
                let c = `#ifdef GL_EXT_frag_depth 
#extension GL_EXT_frag_depth : enable 
#endif 

`; a.sources.push(c), a.defines.push("LOG_DEPTH"), s.defines.push("LOG_DEPTH")
            } this._sp = qt.replaceCache({ shaderProgram: this._sp, context: t, vertexShaderSource: s, fragmentShaderSource: a, attributeLocations: { position: 0 } }), this._command.shaderProgram = this._sp
        } let r = Rit(i, e); if (l(this._va)) this._va.getAttribute(0).vertexBuffer.copyFromArrayView(r); else { let s = new st({ attributes: { position: new be({ componentDatatype: Y.FLOAT, componentsPerAttribute: 3, values: r }) }, indices: [0, 1, 2, 2, 1, 3], primitiveType: Oe.TRIANGLES }); this._va = Qn.fromGeometry({ context: t, geometry: s, attributeLocations: { position: 0 }, bufferUsage: Re.DYNAMIC_DRAW }), this._command.vertexArray = this._va }
    }; nv.prototype.execute = function (e, t) { this._mode === ee.SCENE3D && this._command.execute(e, t) }; nv.prototype.isDestroyed = function () { return !1 }; nv.prototype.destroy = function () { this._sp = this._sp && this._sp.destroy(), this._va = this._va && this._va.destroy() }; var ek = nv; function iv() { } var Mit = /\bgl_FragDepthEXT\b/, Lit = /\bdiscard\b/; function Fit(e, t) {
        let n = e.shaderCache.getDerivedShaderProgram(t, "depthOnly"); if (!l(n)) {
            let i = t._attributeLocations, o = t.fragmentShaderSource, r, s = !1, a = o.sources, c = a.length; for (r = 0; r < c; ++r)if (Mit.test(a[r]) || Lit.test(a[r])) { s = !0; break } let u = !1, f = o.defines; for (c = f.length, r = 0; r < c; ++r)if (f[r] === "LOG_DEPTH") { u = !0; break } let d; !s && !u ? (d = `void main() 
{ 
    gl_FragColor = vec4(1.0); 
} 
`, o = new Ue({ sources: [d] })) : !s && u && (d = `#ifdef GL_EXT_frag_depth 
#extension GL_EXT_frag_depth : enable 
#endif 

void main() 
{ 
    gl_FragColor = vec4(1.0); 
    czm_writeLogDepth(); 
} 
`, o = new Ue({ defines: ["LOG_DEPTH"], sources: [d] })), n = e.shaderCache.createDerivedShaderProgram(t, "depthOnly", { vertexShaderSource: t.vertexShaderSource, fragmentShaderSource: o, attributeLocations: i })
        } return n
    } function Nit(e, t) { let n = e._depthOnlyRenderStateCache, i = n[t.id]; if (!l(i)) { let o = Ve.getState(t); o.depthMask = !0, o.colorMask = { red: !1, green: !1, blue: !1, alpha: !1 }, i = Ve.fromCache(o), n[t.id] = i } return i } iv.createDepthOnlyDerivedCommand = function (e, t, n, i) { l(i) || (i = {}); let o, r; return l(i.depthOnlyCommand) && (o = i.depthOnlyCommand.shaderProgram, r = i.depthOnlyCommand.renderState), i.depthOnlyCommand = $e.shallowClone(t, i.depthOnlyCommand), !l(o) || i.shaderProgramId !== t.shaderProgram.id ? (i.depthOnlyCommand.shaderProgram = Fit(n, t.shaderProgram), i.depthOnlyCommand.renderState = Nit(e, t.renderState), i.shaderProgramId = t.shaderProgram.id) : (i.depthOnlyCommand.shaderProgram = o, i.depthOnlyCommand.renderState = r), i }; var Vit = /\s+czm_writeLogDepth\(/, kit = /\s+czm_vertexLogDepth\(/, Uit = /\s*#extension\s+GL_EXT_frag_depth\s*:\s*enable/; function zit(e, t) {
        let n = e.shaderCache.getDerivedShaderProgram(t, "logDepth"); if (!l(n)) {
            let i = t._attributeLocations, o = t.vertexShaderSource.clone(), r = t.fragmentShaderSource.clone(); o.defines = l(o.defines) ? o.defines.slice(0) : [], o.defines.push("LOG_DEPTH"), r.defines = l(r.defines) ? r.defines.slice(0) : [], r.defines.push("LOG_DEPTH"); let s, a, c = !1, u = o.sources, f = u.length; for (s = 0; s < f; ++s)if (kit.test(u[s])) { c = !0; break } if (!c) {
                for (s = 0; s < f; ++s)u[s] = Ue.replaceMain(u[s], "czm_log_depth_main"); a = `

void main() 
{ 
    czm_log_depth_main(); 
    czm_vertexLogDepth(); 
} 
`, u.push(a)
            } for (u = r.sources, f = u.length, c = !1, s = 0; s < f; ++s)Vit.test(u[s]) && (c = !0); r.defines.indexOf("LOG_DEPTH_WRITE") !== -1 && (c = !0); let d = !0; for (s = 0; s < f; ++s)Uit.test(u[s]) && (d = !1); let p = ""; if (d && (p += `#ifdef GL_EXT_frag_depth 
#extension GL_EXT_frag_depth : enable 
#endif 

`), !c) {
                for (s = 0; s < f; s++)u[s] = Ue.replaceMain(u[s], "czm_log_depth_main"); p += `
void main() 
{ 
    czm_log_depth_main(); 
    czm_writeLogDepth(); 
} 
`} u.push(p), n = e.shaderCache.createDerivedShaderProgram(t, "logDepth", { vertexShaderSource: o, fragmentShaderSource: r, attributeLocations: i })
        } return n
    } iv.createLogDepthCommand = function (e, t, n) { l(n) || (n = {}); let i; return l(n.command) && (i = n.command.shaderProgram), n.command = $e.shallowClone(e, n.command), !l(i) || n.shaderProgramId !== e.shaderProgram.id ? (n.command.shaderProgram = zit(t, e.shaderProgram), n.shaderProgramId = e.shaderProgram.id) : n.command.shaderProgram = i, n }; function Hit(e, t, n) {
        let i = e.shaderCache.getDerivedShaderProgram(t, "pick"); if (!l(i)) {
            let o = t._attributeLocations, r = t.fragmentShaderSource, s = r.sources, a = s.length, c = `void main() 
{ 
    czm_non_pick_main(); 
    if (gl_FragColor.a == 0.0) { 
        discard; 
    } 
    gl_FragColor = ${n}; 
} 
`, u = new Array(a + 1); for (let f = 0; f < a; ++f)u[f] = Ue.replaceMain(s[f], "czm_non_pick_main"); u[a] = c, r = new Ue({ sources: u, defines: r.defines }), i = e.shaderCache.createDerivedShaderProgram(t, "pick", { vertexShaderSource: t.vertexShaderSource, fragmentShaderSource: r, attributeLocations: o })
        } return i
    } function Git(e, t) { let n = e.picking.pickRenderStateCache, i = n[t.id]; if (!l(i)) { let o = Ve.getState(t); o.blending.enabled = !1, o.depthMask = !0, i = Ve.fromCache(o), n[t.id] = i } return i } iv.createPickDerivedCommand = function (e, t, n, i) { l(i) || (i = {}); let o, r; return l(i.pickCommand) && (o = i.pickCommand.shaderProgram, r = i.pickCommand.renderState), i.pickCommand = $e.shallowClone(t, i.pickCommand), !l(o) || i.shaderProgramId !== t.shaderProgram.id ? (i.pickCommand.shaderProgram = Hit(n, t.shaderProgram, t.pickId), i.pickCommand.renderState = Git(e, t.renderState), i.shaderProgramId = t.shaderProgram.id) : (i.pickCommand.shaderProgram = o, i.pickCommand.renderState = r), i }; function Wit(e, t) { let n = e.shaderCache.getDerivedShaderProgram(t, "HDR"); if (!l(n)) { let i = t._attributeLocations, o = t.vertexShaderSource.clone(), r = t.fragmentShaderSource.clone(); o.defines = l(o.defines) ? o.defines.slice(0) : [], o.defines.push("HDR"), r.defines = l(r.defines) ? r.defines.slice(0) : [], r.defines.push("HDR"), n = e.shaderCache.createDerivedShaderProgram(t, "HDR", { vertexShaderSource: o, fragmentShaderSource: r, attributeLocations: i }) } return n } iv.createHdrCommand = function (e, t, n) { l(n) || (n = {}); let i; return l(n.command) && (i = n.command.shaderProgram), n.command = $e.shallowClone(e, n.command), !l(i) || n.shaderProgramId !== e.shaderProgram.id ? (n.command.shaderProgram = Wit(t, e.shaderProgram), n.shaderProgramId = e.shaderProgram.id) : n.command.shaderProgram = i, n }; var zg = iv; function tk(e) { this._scene = e, this._lastAlpha = void 0, this._lastBeta = void 0, this._lastGamma = void 0, this._alpha = void 0, this._beta = void 0, this._gamma = void 0; let t = this; function n(i) { let o = i.alpha; if (!l(o)) { t._alpha = void 0, t._beta = void 0, t._gamma = void 0; return } t._alpha = I.toRadians(o), t._beta = I.toRadians(i.beta), t._gamma = I.toRadians(i.gamma) } window.addEventListener("deviceorientation", n, !1), this._removeListener = function () { window.removeEventListener("deviceorientation", n, !1) } } var jit = new Be, Ape = new Be, qit = new Q; function Yit(e, t, n, i) { let o = e.direction, r = e.right, s = e.up, a = Be.fromAxisAngle(o, n, Ape), c = Be.fromAxisAngle(r, i, jit), u = Be.multiply(c, a, c), f = Be.fromAxisAngle(s, t, Ape); Be.multiply(f, u, u); let d = Q.fromQuaternion(u, qit); Q.multiplyByVector(d, r, r), Q.multiplyByVector(d, s, s), Q.multiplyByVector(d, o, o) } tk.prototype.update = function () { if (!l(this._alpha)) return; l(this._lastAlpha) || (this._lastAlpha = this._alpha, this._lastBeta = this._beta, this._lastGamma = this._gamma); let e = this._lastAlpha - this._alpha, t = this._lastBeta - this._beta, n = this._lastGamma - this._gamma; Yit(this._scene.camera, -e, t, n), this._lastAlpha = this._alpha, this._lastBeta = this._beta, this._lastGamma = this._gamma }; tk.prototype.isDestroyed = function () { return !1 }; tk.prototype.destroy = function () { return this._removeListener(), le(this) }; var nk = tk; function Xit(e) { this.direction = h.clone(e.direction), this.color = U.clone(y(e.color, U.WHITE)), this.intensity = y(e.intensity, 1) } var Cpe = Xit; var ov = `#ifdef WRITE_DEPTH
#ifdef GL_EXT_frag_depth
#extension GL_EXT_frag_depth : enable
#endif
#endif
uniform vec3 u_radii;
uniform vec3 u_oneOverEllipsoidRadiiSquared;
varying vec3 v_positionEC;
vec4 computeEllipsoidColor(czm_ray ray, float intersection, float side)
{
vec3 positionEC = czm_pointAlongRay(ray, intersection);
vec3 positionMC = (czm_inverseModelView * vec4(positionEC, 1.0)).xyz;
vec3 geodeticNormal = normalize(czm_geodeticSurfaceNormal(positionMC, vec3(0.0), u_oneOverEllipsoidRadiiSquared));
vec3 sphericalNormal = normalize(positionMC / u_radii);
vec3 normalMC = geodeticNormal * side;
vec3 normalEC = normalize(czm_normal * normalMC);
vec2 st = czm_ellipsoidWgs84TextureCoordinates(sphericalNormal);
vec3 positionToEyeEC = -positionEC;
czm_materialInput materialInput;
materialInput.s = st.s;
materialInput.st = st;
materialInput.str = (positionMC + u_radii) / u_radii;
materialInput.normalEC = normalEC;
materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);
materialInput.positionToEyeEC = positionToEyeEC;
czm_material material = czm_getMaterial(materialInput);
#ifdef ONLY_SUN_LIGHTING
return czm_private_phong(normalize(positionToEyeEC), material, czm_sunDirectionEC);
#else
return czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);
#endif
}
void main()
{
float maxRadius = max(u_radii.x, max(u_radii.y, u_radii.z)) * 1.5;
vec3 direction = normalize(v_positionEC);
vec3 ellipsoidCenter = czm_modelView[3].xyz;
float t1 = -1.0;
float t2 = -1.0;
float b = -2.0 * dot(direction, ellipsoidCenter);
float c = dot(ellipsoidCenter, ellipsoidCenter) - maxRadius * maxRadius;
float discriminant = b * b - 4.0 * c;
if (discriminant >= 0.0) {
t1 = (-b - sqrt(discriminant)) * 0.5;
t2 = (-b + sqrt(discriminant)) * 0.5;
}
if (t1 < 0.0 && t2 < 0.0) {
discard;
}
float t = min(t1, t2);
if (t < 0.0) {
t = 0.0;
}
czm_ray ray = czm_ray(t * direction, direction);
vec3 ellipsoid_inverseRadii = vec3(1.0 / u_radii.x, 1.0 / u_radii.y, 1.0 / u_radii.z);
czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoidCenter, ellipsoid_inverseRadii);
if (czm_isEmpty(intersection))
{
discard;
}
vec4 outsideFaceColor = (intersection.start != 0.0) ? computeEllipsoidColor(ray, intersection.start, 1.0) : vec4(0.0);
vec4 insideFaceColor = (outsideFaceColor.a < 1.0) ? computeEllipsoidColor(ray, intersection.stop, -1.0) : vec4(0.0);
gl_FragColor = mix(insideFaceColor, outsideFaceColor, outsideFaceColor.a);
gl_FragColor.a = 1.0 - (1.0 - insideFaceColor.a) * (1.0 - outsideFaceColor.a);
#ifdef WRITE_DEPTH
#ifdef GL_EXT_frag_depth
t = (intersection.start != 0.0) ? intersection.start : intersection.stop;
vec3 positionEC = czm_pointAlongRay(ray, t);
vec4 positionCC = czm_projection * vec4(positionEC, 1.0);
#ifdef LOG_DEPTH
czm_writeLogDepth(1.0 + positionCC.w);
#else
float z = positionCC.z / positionCC.w;
float n = czm_depthRange.near;
float f = czm_depthRange.far;
gl_FragDepthEXT = (z * (f - n) + f + n) * 0.5;
#endif
#endif
#endif
}
`; var rv = `attribute vec3 position;
uniform vec3 u_radii;
varying vec3 v_positionEC;
void main()
{
vec4 p = vec4(u_radii * position, 1.0);
v_positionEC = (czm_modelView * p).xyz;
gl_Position = czm_modelViewProjection * p;
gl_Position.z = clamp(gl_Position.z, czm_depthRange.near, czm_depthRange.far);
czm_vertexLogDepth();
}
`; var ej = { position: 0 }; function ik(e) { e = y(e, y.EMPTY_OBJECT), this.center = h.clone(y(e.center, h.ZERO)), this._center = new h, this.radii = h.clone(e.radii), this._radii = new h, this._oneOverEllipsoidRadiiSquared = new h, this._boundingSphere = new re, this.modelMatrix = F.clone(y(e.modelMatrix, F.IDENTITY)), this._modelMatrix = new F, this._computedModelMatrix = new F, this.show = y(e.show, !0), this.material = y(e.material, Ki.fromType(Ki.ColorType)), this._material = void 0, this._translucent = void 0, this.id = e.id, this._id = void 0, this.debugShowBoundingVolume = y(e.debugShowBoundingVolume, !1), this.onlySunLighting = y(e.onlySunLighting, !1), this._onlySunLighting = !1, this._depthTestEnabled = y(e.depthTestEnabled, !0), this._useLogDepth = !1, this._sp = void 0, this._rs = void 0, this._va = void 0, this._pickSP = void 0, this._pickId = void 0, this._colorCommand = new $e({ owner: y(e._owner, this) }), this._pickCommand = new $e({ owner: y(e._owner, this), pickOnly: !0 }); let t = this; this._uniforms = { u_radii: function () { return t.radii }, u_oneOverEllipsoidRadiiSquared: function () { return t._oneOverEllipsoidRadiiSquared } }, this._pickUniforms = { czm_pickColor: function () { return t._pickId.color } } } function Kit(e) { let t = e.cache.ellipsoidPrimitive_vertexArray; if (l(t)) return t; let n = ll.createGeometry(ll.fromDimensions({ dimensions: new h(2, 2, 2), vertexFormat: we.POSITION_ONLY })); return t = Qn.fromGeometry({ context: e, geometry: n, attributeLocations: ej, bufferUsage: Re.STATIC_DRAW, interleave: !0 }), e.cache.ellipsoidPrimitive_vertexArray = t, t } var xpe = `#ifdef GL_EXT_frag_depth 
#extension GL_EXT_frag_depth : enable 
#endif 

`; ik.prototype.update = function (e) { if (!this.show || e.mode !== ee.SCENE3D || !l(this.center) || !l(this.radii)) return; let t = e.context, n = this.material.isTranslucent(), i = this._translucent !== n; (!l(this._rs) || i) && (this._translucent = n, this._rs = Ve.fromCache({ cull: { enabled: !0, face: gi.FRONT }, depthTest: { enabled: this._depthTestEnabled }, depthMask: !n && t.fragmentDepth, blending: n ? an.ALPHA_BLEND : void 0 })), l(this._va) || (this._va = Kit(t)); let o = !1, r = this.radii; if (!h.equals(this._radii, r)) { h.clone(r, this._radii); let A = this._oneOverEllipsoidRadiiSquared; A.x = 1 / (r.x * r.x), A.y = 1 / (r.y * r.y), A.z = 1 / (r.z * r.z), o = !0 } (!F.equals(this.modelMatrix, this._modelMatrix) || !h.equals(this.center, this._center)) && (F.clone(this.modelMatrix, this._modelMatrix), h.clone(this.center, this._center), F.multiplyByTranslation(this.modelMatrix, this.center, this._computedModelMatrix), o = !0), o && (h.clone(h.ZERO, this._boundingSphere.center), this._boundingSphere.radius = h.maximumComponent(r), re.transform(this._boundingSphere, this._computedModelMatrix, this._boundingSphere)); let s = this._material !== this.material; this._material = this.material, this._material.update(t); let a = this.onlySunLighting !== this._onlySunLighting; this._onlySunLighting = this.onlySunLighting; let c = e.useLogDepth, u = this._useLogDepth !== c; this._useLogDepth = c; let f = this._colorCommand, d, p; (s || a || i || u) && (d = new Ue({ sources: [rv] }), p = new Ue({ sources: [this.material.shaderSource, ov] }), this.onlySunLighting && p.defines.push("ONLY_SUN_LIGHTING"), !n && t.fragmentDepth && p.defines.push("WRITE_DEPTH"), this._useLogDepth && (d.defines.push("LOG_DEPTH"), p.defines.push("LOG_DEPTH"), p.sources.push(xpe)), this._sp = qt.replaceCache({ context: t, shaderProgram: this._sp, vertexShaderSource: d, fragmentShaderSource: p, attributeLocations: ej }), f.vertexArray = this._va, f.renderState = this._rs, f.shaderProgram = this._sp, f.uniformMap = yt(this._uniforms, this.material._uniforms), f.executeInClosestFrustum = n); let g = e.commandList, m = e.passes; if (m.render && (f.boundingVolume = this._boundingSphere, f.debugShowBoundingVolume = this.debugShowBoundingVolume, f.modelMatrix = this._computedModelMatrix, f.pass = n ? xe.TRANSLUCENT : xe.OPAQUE, g.push(f)), m.pick) { let A = this._pickCommand; (!l(this._pickId) || this._id !== this.id) && (this._id = this.id, this._pickId = this._pickId && this._pickId.destroy(), this._pickId = t.createPickId({ primitive: this, id: this.id })), (s || a || !l(this._pickSP) || u) && (d = new Ue({ sources: [rv] }), p = new Ue({ sources: [this.material.shaderSource, ov], pickColorQualifier: "uniform" }), this.onlySunLighting && p.defines.push("ONLY_SUN_LIGHTING"), !n && t.fragmentDepth && p.defines.push("WRITE_DEPTH"), this._useLogDepth && (d.defines.push("LOG_DEPTH"), p.defines.push("LOG_DEPTH"), p.sources.push(xpe)), this._pickSP = qt.replaceCache({ context: t, shaderProgram: this._pickSP, vertexShaderSource: d, fragmentShaderSource: p, attributeLocations: ej }), A.vertexArray = this._va, A.renderState = this._rs, A.shaderProgram = this._pickSP, A.uniformMap = yt(yt(this._uniforms, this._pickUniforms), this.material._uniforms), A.executeInClosestFrustum = n), A.boundingVolume = this._boundingSphere, A.modelMatrix = this._computedModelMatrix, A.pass = n ? xe.TRANSLUCENT : xe.OPAQUE, g.push(A) } }; ik.prototype.isDestroyed = function () { return !1 }; ik.prototype.destroy = function () { return this._sp = this._sp && this._sp.destroy(), this._pickSP = this._pickSP && this._pickSP.destroy(), this._pickId = this._pickId && this._pickId.destroy(), le(this) }; var ok = ik; var rk = `varying vec3 v_positionMC;
varying vec3 v_positionEC;
varying vec2 v_st;
void main()
{
czm_materialInput materialInput;
vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));
#ifdef FACE_FORWARD
normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);
#endif
materialInput.s = v_st.s;
materialInput.st = v_st;
materialInput.str = vec3(v_st, 0.0);
materialInput.normalEC = normalEC;
materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);
vec3 positionToEyeEC = -v_positionEC;
materialInput.positionToEyeEC = positionToEyeEC;
czm_material material = czm_getMaterial(materialInput);
#ifdef FLAT
gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);
#else
gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);
#endif
}
`; var sk = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;
attribute vec2 st;
attribute float batchId;
varying vec3 v_positionMC;
varying vec3 v_positionEC;
varying vec2 v_st;
void main()
{
vec4 p = czm_computePosition();
v_positionMC = position3DHigh + position3DLow;
v_positionEC = (czm_modelViewRelativeToEye * p).xyz;
v_st = st;
gl_Position = czm_modelViewProjectionRelativeToEye * p;
}
`; function nA(e) { e = y(e, y.EMPTY_OBJECT); let t = y(e.translucent, !0), n = y(e.aboveGround, !1); this.material = l(e.material) ? e.material : Ki.fromType(Ki.ColorType), this.translucent = y(e.translucent, !0), this._vertexShaderSource = y(e.vertexShaderSource, sk), this._fragmentShaderSource = y(e.fragmentShaderSource, rk), this._renderState = Yi.getDefaultRenderState(t, !n, e.renderState), this._closed = !1, this._flat = y(e.flat, !1), this._faceForward = y(e.faceForward, n), this._aboveGround = n } Object.defineProperties(nA.prototype, { vertexShaderSource: { get: function () { return this._vertexShaderSource } }, fragmentShaderSource: { get: function () { return this._fragmentShaderSource } }, renderState: { get: function () { return this._renderState } }, closed: { get: function () { return this._closed } }, vertexFormat: { get: function () { return nA.VERTEX_FORMAT } }, flat: { get: function () { return this._flat } }, faceForward: { get: function () { return this._faceForward } }, aboveGround: { get: function () { return this._aboveGround } } }); nA.VERTEX_FORMAT = we.POSITION_AND_ST; nA.prototype.getFragmentShaderSource = Yi.prototype.getFragmentShaderSource; nA.prototype.isTranslucent = Yi.prototype.isTranslucent; nA.prototype.getRenderState = Yi.prototype.getRenderState; var Tpe = nA; function Epe() { this.enabled = !0, this.renderable = !0, this.density = 2e-4, this.screenSpaceErrorFactor = 2, this.minimumBrightness = .03 } var ak = [359.393, 800.749, 1275.6501, 2151.1192, 3141.7763, 4777.5198, 6281.2493, 12364.307, 15900.765, 49889.0549, 78026.8259, 99260.7344, 120036.3873, 151011.0158, 156091.1953, 203849.3112, 274866.9803, 319916.3149, 493552.0528, 628733.5874], Bh = [2e-5, 2e-4, 1e-4, 7e-5, 5e-5, 4e-5, 3e-5, 19e-6, 1e-5, 85e-7, 62e-7, 58e-7, 53e-7, 52e-7, 51e-7, 42e-7, 4e-6, 34e-7, 26e-7, 22e-7]; for (let e = 0; e < Bh.length; ++e)Bh[e] *= 1e6; var bpe = Bh[1], tj = Bh[Bh.length - 1]; for (let e = 0; e < Bh.length; ++e)Bh[e] = (Bh[e] - tj) / (bpe - tj); var Vs = 0; function Jit(e) { let t = ak, n = t.length; if (e < t[0]) return Vs = 0, Vs; if (e > t[n - 1]) return Vs = n - 2, Vs; if (e >= t[Vs]) { if (Vs + 1 < n && e < t[Vs + 1]) return Vs; if (Vs + 2 < n && e < t[Vs + 2]) return ++Vs, Vs } else if (Vs - 1 >= 0 && e >= t[Vs - 1]) return --Vs, Vs; let i; for (i = 0; i < n - 2 && !(e >= t[i] && e < t[i + 1]); ++i); return Vs = i, Vs } var Zit = new h; Epe.prototype.update = function (e) { if (!(e.fog.enabled = this.enabled)) return; e.fog.renderable = this.renderable; let n = e.camera, i = n.positionCartographic; if (!l(i) || i.height > 8e5 || e.mode !== ee.SCENE3D) { e.fog.enabled = !1; return } let o = i.height, r = Jit(o), s = I.clamp((o - ak[r]) / (ak[r + 1] - ak[r]), 0, 1), a = I.lerp(Bh[r], Bh[r + 1], s), c = this.density * 1e6, u = c / bpe * tj; a = a * (c - u) * 1e-6; let f = h.normalize(n.positionWC, Zit), d = Math.abs(h.dot(n.directionWC, f)); a *= 1 - d, e.fog.density = a, e.fog.sse = this.screenSpaceErrorFactor, e.fog.minimumBrightness = this.minimumBrightness }; var ck = Epe; function il(e) { this._scene = e.scene, this.samplingWindow = y(e.samplingWindow, il.defaultSettings.samplingWindow), this.quietPeriod = y(e.quietPeriod, il.defaultSettings.quietPeriod), this.warmupPeriod = y(e.warmupPeriod, il.defaultSettings.warmupPeriod), this.minimumFrameRateDuringWarmup = y(e.minimumFrameRateDuringWarmup, il.defaultSettings.minimumFrameRateDuringWarmup), this.minimumFrameRateAfterWarmup = y(e.minimumFrameRateAfterWarmup, il.defaultSettings.minimumFrameRateAfterWarmup), this._lowFrameRate = new _e, this._nominalFrameRate = new _e, this._frameTimes = [], this._needsQuietPeriod = !0, this._quietPeriodEndTime = 0, this._warmupPeriodEndTime = 0, this._frameRateIsLow = !1, this._lastFramesPerSecond = void 0, this._pauseCount = 0; let t = this; this._preUpdateRemoveListener = this._scene.preUpdate.addEventListener(function (o, r) { Qit(t, r) }), this._hiddenPropertyName = document.hidden !== void 0 ? "hidden" : document.mozHidden !== void 0 ? "mozHidden" : document.msHidden !== void 0 ? "msHidden" : document.webkitHidden !== void 0 ? "webkitHidden" : void 0; let n = document.hidden !== void 0 ? "visibilitychange" : document.mozHidden !== void 0 ? "mozvisibilitychange" : document.msHidden !== void 0 ? "msvisibilitychange" : document.webkitHidden !== void 0 ? "webkitvisibilitychange" : void 0; function i() { $it(t) } this._visibilityChangeRemoveListener = void 0, l(n) && (document.addEventListener(n, i, !1), this._visibilityChangeRemoveListener = function () { document.removeEventListener(n, i, !1) }) } il.defaultSettings = { samplingWindow: 5, quietPeriod: 2, warmupPeriod: 5, minimumFrameRateDuringWarmup: 4, minimumFrameRateAfterWarmup: 8 }; il.fromScene = function (e) { return (!l(e._frameRateMonitor) || e._frameRateMonitor.isDestroyed()) && (e._frameRateMonitor = new il({ scene: e })), e._frameRateMonitor }; Object.defineProperties(il.prototype, { scene: { get: function () { return this._scene } }, lowFrameRate: { get: function () { return this._lowFrameRate } }, nominalFrameRate: { get: function () { return this._nominalFrameRate } }, lastFramesPerSecond: { get: function () { return this._lastFramesPerSecond } } }); il.prototype.pause = function () { ++this._pauseCount, this._pauseCount === 1 && (this._frameTimes.length = 0, this._lastFramesPerSecond = void 0) }; il.prototype.unpause = function () { --this._pauseCount, this._pauseCount <= 0 && (this._pauseCount = 0, this._needsQuietPeriod = !0) }; il.prototype.isDestroyed = function () { return !1 }; il.prototype.destroy = function () { return this._preUpdateRemoveListener(), l(this._visibilityChangeRemoveListener) && this._visibilityChangeRemoveListener(), le(this) }; function Qit(e, t) { if (e._pauseCount > 0) return; let n = Ei(); if (e._needsQuietPeriod) e._needsQuietPeriod = !1, e._frameTimes.length = 0, e._quietPeriodEndTime = n + e.quietPeriod / jn.SECONDS_PER_MILLISECOND, e._warmupPeriodEndTime = e._quietPeriodEndTime + (e.warmupPeriod + e.samplingWindow) / jn.SECONDS_PER_MILLISECOND; else if (n >= e._quietPeriodEndTime) { e._frameTimes.push(n); let i = n - e.samplingWindow / jn.SECONDS_PER_MILLISECOND; if (e._frameTimes.length >= 2 && e._frameTimes[0] <= i) { for (; e._frameTimes.length >= 2 && e._frameTimes[1] < i;)e._frameTimes.shift(); let o = (n - e._frameTimes[0]) / (e._frameTimes.length - 1); e._lastFramesPerSecond = 1e3 / o; let r = 1e3 / (n > e._warmupPeriodEndTime ? e.minimumFrameRateAfterWarmup : e.minimumFrameRateDuringWarmup); o > r ? e._frameRateIsLow || (e._frameRateIsLow = !0, e._needsQuietPeriod = !0, e.lowFrameRate.raiseEvent(e.scene, e._lastFramesPerSecond)) : e._frameRateIsLow && (e._frameRateIsLow = !1, e._needsQuietPeriod = !0, e.nominalFrameRate.raiseEvent(e.scene, e._lastFramesPerSecond)) } } } function $it(e) { document[e._hiddenPropertyName] ? e.pause() : e.unpause() } var lk = il; function eot(e, t, n) { this.context = e, this.commandList = [], this.shadowMaps = [], this.brdfLutGenerator = void 0, this.environmentMap = void 0, this.sphericalHarmonicCoefficients = void 0, this.specularEnvironmentMaps = void 0, this.specularEnvironmentMapsMaximumLOD = void 0, this.mode = ee.SCENE3D, this.morphTime = ee.getMorphTime(ee.SCENE3D), this.frameNumber = 0, this.newFrame = !1, this.time = void 0, this.jobScheduler = n, this.mapProjection = void 0, this.camera = void 0, this.cameraUnderground = !1, this.globeTranslucencyState = void 0, this.cullingVolume = void 0, this.occluder = void 0, this.maximumScreenSpaceError = void 0, this.pixelRatio = 1, this.passes = { render: !1, pick: !1, depth: !1, postProcess: !1, offscreen: !1 }, this.creditDisplay = t, this.afterRender = [], this.scene3DOnly = !1, this.fog = { enabled: !1, density: void 0, sse: void 0, minimumBrightness: void 0 }, this.terrainExaggeration = 1, this.terrainExaggerationRelativeHeight = 0, this.shadowState = { shadowsEnabled: !0, shadowMaps: [], lightShadowMaps: [], nearPlane: 1, farPlane: 5e3, closestObjectSize: 1e3, lastDirtyTime: 0, outOfView: !0 }, this.splitPosition = 0, this.frustumSplits = [], this.backgroundColor = void 0, this.light = void 0, this.minimumDisableDepthTestDistance = void 0, this.invertClassification = !1, this.invertClassificationColor = void 0, this.useLogDepth = !1, this.tilesetPassState = void 0, this.minimumTerrainHeight = 0 } var uk = eot; function tot(e, t) { this.near = y(e, 0), this.far = y(t, 0); let n = xe.NUMBER_OF_PASSES, i = new Array(n), o = new Array(n); for (let r = 0; r < n; ++r)i[r] = [], o[r] = 0; this.commands = i, this.indices = o } var fk = tot; function not(e, t, n) {
        return `    float clipDistance = clip(gl_FragCoord, ${e}, ${t}); 
    vec4 clippingPlanesEdgeColor = vec4(1.0); 
    clippingPlanesEdgeColor.rgb = ${n}.rgb; 
    float clippingPlanesEdgeWidth = ${n}.a; 
    if (clipDistance > 0.0 && clipDistance < clippingPlanesEdgeWidth) 
    { 
        gl_FragColor = clippingPlanesEdgeColor;
    } 
`} var dk = not; var iot = new H; function oot(e, t) {
        let n = e.unionClippingRegions, i = e.length, o = Ks.useFloatTexture(t), r = Ks.getTextureResolution(e, t, iot), s = r.x, a = r.y, c = o ? aot(s, a) : cot(s, a); return c += `
`, c += n ? rot(i) : sot(i), c
    } function rot(e) {
        return `float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)
{
    vec4 position = czm_windowToEyeCoordinates(fragCoord);
    vec3 clipNormal = vec3(0.0);
    vec3 clipPosition = vec3(0.0);
    float clipAmount;
    float pixelWidth = czm_metersPerPixel(position);
    bool breakAndDiscard = false;
    for (int i = 0; i < ${e}; ++i)
    {
        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);
        clipNormal = clippingPlane.xyz;
        clipPosition = -clippingPlane.w * clipNormal;
        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;
        clipAmount = czm_branchFreeTernary(i == 0, amount, min(amount, clipAmount));
        if (amount <= 0.0)
        {
           breakAndDiscard = true;
           break;
        }
    }
    if (breakAndDiscard) {
        discard;
    }
    return clipAmount;
}
`} function sot(e) {
        return `float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)
{
    bool clipped = true;
    vec4 position = czm_windowToEyeCoordinates(fragCoord);
    vec3 clipNormal = vec3(0.0);
    vec3 clipPosition = vec3(0.0);
    float clipAmount = 0.0;
    float pixelWidth = czm_metersPerPixel(position);
    for (int i = 0; i < ${e}; ++i)
    {
        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);
        clipNormal = clippingPlane.xyz;
        clipPosition = -clippingPlane.w * clipNormal;
        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;
        clipAmount = max(amount, clipAmount);
        clipped = clipped && (amount <= 0.0);
    }
    if (clipped)
    {
        discard;
    }
    return clipAmount;
}
`} function aot(e, t) {
        let n = 1 / e, i = 1 / t, o = `${n}`; o.indexOf(".") === -1 && (o += ".0"); let r = `${i}`; return r.indexOf(".") === -1 && (r += ".0"), `vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)
{
    int pixY = clippingPlaneNumber / ${e};
    int pixX = clippingPlaneNumber - (pixY * ${e});
    float u = (float(pixX) + 0.5) * ${o};
    float v = (float(pixY) + 0.5) * ${r};
    vec4 plane = texture2D(packedClippingPlanes, vec2(u, v));
    return czm_transformPlane(plane, transform);
}
`} function cot(e, t) {
        let n = 1 / e, i = 1 / t, o = `${n}`; o.indexOf(".") === -1 && (o += ".0"); let r = `${i}`; return r.indexOf(".") === -1 && (r += ".0"), `vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)
{
    int clippingPlaneStartIndex = clippingPlaneNumber * 2;
    int pixY = clippingPlaneStartIndex / ${e};
    int pixX = clippingPlaneStartIndex - (pixY * ${e});
    float u = (float(pixX) + 0.5) * ${o};
    float v = (float(pixY) + 0.5) * ${r};
    vec4 oct32 = texture2D(packedClippingPlanes, vec2(u, v)) * 255.0;
    vec2 oct = vec2(oct32.x * 256.0 + oct32.y, oct32.z * 256.0 + oct32.w);
    vec4 plane;
    plane.xyz = czm_octDecode(oct, 65535.0);
    plane.w = czm_unpackFloat(texture2D(packedClippingPlanes, vec2(u + ${o}, v)));
    return czm_transformPlane(plane, transform);
}
`} var IE = oot; var hk = `uniform vec4 u_initialColor;
#if TEXTURE_UNITS > 0
uniform sampler2D u_dayTextures[TEXTURE_UNITS];
uniform vec4 u_dayTextureTranslationAndScale[TEXTURE_UNITS];
uniform bool u_dayTextureUseWebMercatorT[TEXTURE_UNITS];
#ifdef APPLY_ALPHA
uniform float u_dayTextureAlpha[TEXTURE_UNITS];
#endif
#ifdef APPLY_DAY_NIGHT_ALPHA
uniform float u_dayTextureNightAlpha[TEXTURE_UNITS];
uniform float u_dayTextureDayAlpha[TEXTURE_UNITS];
#endif
#ifdef APPLY_SPLIT
uniform float u_dayTextureSplit[TEXTURE_UNITS];
#endif
#ifdef APPLY_BRIGHTNESS
uniform float u_dayTextureBrightness[TEXTURE_UNITS];
#endif
#ifdef APPLY_CONTRAST
uniform float u_dayTextureContrast[TEXTURE_UNITS];
#endif
#ifdef APPLY_HUE
uniform float u_dayTextureHue[TEXTURE_UNITS];
#endif
#ifdef APPLY_SATURATION
uniform float u_dayTextureSaturation[TEXTURE_UNITS];
#endif
#ifdef APPLY_GAMMA
uniform float u_dayTextureOneOverGamma[TEXTURE_UNITS];
#endif
#ifdef APPLY_IMAGERY_CUTOUT
uniform vec4 u_dayTextureCutoutRectangles[TEXTURE_UNITS];
#endif
#ifdef APPLY_COLOR_TO_ALPHA
uniform vec4 u_colorsToAlpha[TEXTURE_UNITS];
#endif
uniform vec4 u_dayTextureTexCoordsRectangle[TEXTURE_UNITS];
#endif
#ifdef SHOW_REFLECTIVE_OCEAN
uniform sampler2D u_waterMask;
uniform vec4 u_waterMaskTranslationAndScale;
uniform float u_zoomedOutOceanSpecularIntensity;
#endif
#ifdef SHOW_OCEAN_WAVES
uniform sampler2D u_oceanNormalMap;
#endif
#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)
uniform vec2 u_lightingFadeDistance;
#endif
#ifdef TILE_LIMIT_RECTANGLE
uniform vec4 u_cartographicLimitRectangle;
#endif
#ifdef GROUND_ATMOSPHERE
uniform vec2 u_nightFadeDistance;
#endif
#ifdef ENABLE_CLIPPING_PLANES
uniform highp sampler2D u_clippingPlanes;
uniform mat4 u_clippingPlanesMatrix;
uniform vec4 u_clippingPlanesEdgeStyle;
#endif
#if defined(GROUND_ATMOSPHERE) || defined(FOG) && defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))
uniform float u_minimumBrightness;
#endif
#ifdef COLOR_CORRECT
uniform vec3 u_hsbShift;
#endif
#ifdef HIGHLIGHT_FILL_TILE
uniform vec4 u_fillHighlightColor;
#endif
#ifdef TRANSLUCENT
uniform vec4 u_frontFaceAlphaByDistance;
uniform vec4 u_backFaceAlphaByDistance;
uniform vec4 u_translucencyRectangle;
#endif
#ifdef UNDERGROUND_COLOR
uniform vec4 u_undergroundColor;
uniform vec4 u_undergroundColorAlphaByDistance;
#endif
#ifdef ENABLE_VERTEX_LIGHTING
uniform float u_lambertDiffuseMultiplier;
#endif
varying vec3 v_positionMC;
varying vec3 v_positionEC;
varying vec3 v_textureCoordinates;
varying vec3 v_normalMC;
varying vec3 v_normalEC;
#ifdef APPLY_MATERIAL
varying float v_height;
varying float v_slope;
varying float v_aspect;
#endif
#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)
varying float v_distance;
#endif
#if defined(GROUND_ATMOSPHERE) || defined(FOG)
varying vec3 v_atmosphereRayleighColor;
varying vec3 v_atmosphereMieColor;
varying float v_atmosphereOpacity;
#endif
#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)
float interpolateByDistance(vec4 nearFarScalar, float distance)
{
float startDistance = nearFarScalar.x;
float startValue = nearFarScalar.y;
float endDistance = nearFarScalar.z;
float endValue = nearFarScalar.w;
float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0);
return mix(startValue, endValue, t);
}
#endif
#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT) || defined(APPLY_MATERIAL)
vec4 alphaBlend(vec4 sourceColor, vec4 destinationColor)
{
return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a);
}
#endif
#ifdef TRANSLUCENT
bool inTranslucencyRectangle()
{
return
v_textureCoordinates.x > u_translucencyRectangle.x &&
v_textureCoordinates.x < u_translucencyRectangle.z &&
v_textureCoordinates.y > u_translucencyRectangle.y &&
v_textureCoordinates.y < u_translucencyRectangle.w;
}
#endif
vec4 sampleAndBlend(
vec4 previousColor,
sampler2D textureToSample,
vec2 tileTextureCoordinates,
vec4 textureCoordinateRectangle,
vec4 textureCoordinateTranslationAndScale,
float textureAlpha,
float textureNightAlpha,
float textureDayAlpha,
float textureBrightness,
float textureContrast,
float textureHue,
float textureSaturation,
float textureOneOverGamma,
float split,
vec4 colorToAlpha,
float nightBlend)
{
vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);
textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;
alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);
textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;
#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)
textureAlpha *= mix(textureDayAlpha, textureNightAlpha, nightBlend);
#endif
vec2 translation = textureCoordinateTranslationAndScale.xy;
vec2 scale = textureCoordinateTranslationAndScale.zw;
vec2 textureCoordinates = tileTextureCoordinates * scale + translation;
vec4 value = texture2D(textureToSample, textureCoordinates);
vec3 color = value.rgb;
float alpha = value.a;
#ifdef APPLY_COLOR_TO_ALPHA
vec3 colorDiff = abs(color.rgb - colorToAlpha.rgb);
colorDiff.r = max(max(colorDiff.r, colorDiff.g), colorDiff.b);
alpha = czm_branchFreeTernary(colorDiff.r < colorToAlpha.a, 0.0, alpha);
#endif
#if !defined(APPLY_GAMMA)
vec4 tempColor = czm_gammaCorrect(vec4(color, alpha));
color = tempColor.rgb;
alpha = tempColor.a;
#else
color = pow(color, vec3(textureOneOverGamma));
#endif
#ifdef APPLY_SPLIT
float splitPosition = czm_splitPosition;
if (split < 0.0 && gl_FragCoord.x > splitPosition) {
alpha = 0.0;
}
else if (split > 0.0 && gl_FragCoord.x < splitPosition) {
alpha = 0.0;
}
#endif
#ifdef APPLY_BRIGHTNESS
color = mix(vec3(0.0), color, textureBrightness);
#endif
#ifdef APPLY_CONTRAST
color = mix(vec3(0.5), color, textureContrast);
#endif
#ifdef APPLY_HUE
color = czm_hue(color, textureHue);
#endif
#ifdef APPLY_SATURATION
color = czm_saturation(color, textureSaturation);
#endif
float sourceAlpha = alpha * textureAlpha;
float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);
outAlpha += sign(outAlpha) - 1.0;
vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;
return vec4(outColor, max(outAlpha, 0.0));
}
vec3 colorCorrect(vec3 rgb) {
#ifdef COLOR_CORRECT
vec3 hsb = czm_RGBToHSB(rgb);
hsb.x += u_hsbShift.x;
hsb.y = clamp(hsb.y + u_hsbShift.y, 0.0, 1.0);
hsb.z = hsb.z > czm_epsilon7 ? hsb.z + u_hsbShift.z : 0.0;
rgb = czm_HSBToRGB(hsb);
#endif
return rgb;
}
vec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend);
vec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float specularMapValue, float fade);
const float fExposure = 2.0;
vec3 computeEllipsoidPosition()
{
float mpp = czm_metersPerPixel(vec4(0.0, 0.0, -czm_currentFrustum.x, 1.0), 1.0);
vec2 xy = gl_FragCoord.xy / czm_viewport.zw * 2.0 - vec2(1.0);
xy *= czm_viewport.zw * mpp * 0.5;
vec3 direction = normalize(vec3(xy, -czm_currentFrustum.x));
czm_ray ray = czm_ray(vec3(0.0), direction);
vec3 ellipsoid_center = czm_view[3].xyz;
czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid_center, czm_ellipsoidInverseRadii);
vec3 ellipsoidPosition = czm_pointAlongRay(ray, intersection.start);
return (czm_inverseView * vec4(ellipsoidPosition, 1.0)).xyz;
}
void main()
{
#ifdef TILE_LIMIT_RECTANGLE
if (v_textureCoordinates.x < u_cartographicLimitRectangle.x || u_cartographicLimitRectangle.z < v_textureCoordinates.x ||
v_textureCoordinates.y < u_cartographicLimitRectangle.y || u_cartographicLimitRectangle.w < v_textureCoordinates.y)
{
discard;
}
#endif
#ifdef ENABLE_CLIPPING_PLANES
float clipDistance = clip(gl_FragCoord, u_clippingPlanes, u_clippingPlanesMatrix);
#endif
#if defined(SHOW_REFLECTIVE_OCEAN) || defined(ENABLE_DAYNIGHT_SHADING) || defined(HDR)
vec3 normalMC = czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0));
vec3 normalEC = czm_normal3D * normalMC;
#endif
#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)
float nightBlend = 1.0 - clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0, 0.0, 1.0);
#else
float nightBlend = 0.0;
#endif
vec4 color = computeDayColor(u_initialColor, clamp(v_textureCoordinates, 0.0, 1.0), nightBlend);
#ifdef SHOW_TILE_BOUNDARIES
if (v_textureCoordinates.x < (1.0/256.0) || v_textureCoordinates.x > (255.0/256.0) ||
v_textureCoordinates.y < (1.0/256.0) || v_textureCoordinates.y > (255.0/256.0))
{
color = vec4(1.0, 0.0, 0.0, 1.0);
}
#endif
#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)
float cameraDist;
if (czm_sceneMode == czm_sceneMode2D)
{
cameraDist = max(czm_frustumPlanes.x - czm_frustumPlanes.y, czm_frustumPlanes.w - czm_frustumPlanes.z) * 0.5;
}
else if (czm_sceneMode == czm_sceneModeColumbusView)
{
cameraDist = -czm_view[3].z;
}
else
{
cameraDist = length(czm_view[3]);
}
float fadeOutDist = u_lightingFadeDistance.x;
float fadeInDist = u_lightingFadeDistance.y;
if (czm_sceneMode != czm_sceneMode3D) {
vec3 radii = czm_ellipsoidRadii;
float maxRadii = max(radii.x, max(radii.y, radii.z));
fadeOutDist -= maxRadii;
fadeInDist -= maxRadii;
}
float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);
#else
float fade = 0.0;
#endif
#ifdef SHOW_REFLECTIVE_OCEAN
vec2 waterMaskTranslation = u_waterMaskTranslationAndScale.xy;
vec2 waterMaskScale = u_waterMaskTranslationAndScale.zw;
vec2 waterMaskTextureCoordinates = v_textureCoordinates.xy * waterMaskScale + waterMaskTranslation;
waterMaskTextureCoordinates.y = 1.0 - waterMaskTextureCoordinates.y;
float mask = texture2D(u_waterMask, waterMaskTextureCoordinates).r;
if (mask > 0.0)
{
mat3 enuToEye = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalEC);
vec2 ellipsoidTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC);
vec2 ellipsoidFlippedTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC.zyx);
vec2 textureCoordinates = mix(ellipsoidTextureCoordinates, ellipsoidFlippedTextureCoordinates, czm_morphTime * smoothstep(0.9, 0.95, normalMC.z));
color = computeWaterColor(v_positionEC, textureCoordinates, enuToEye, color, mask, fade);
}
#endif
#ifdef APPLY_MATERIAL
czm_materialInput materialInput;
materialInput.st = v_textureCoordinates.st;
materialInput.normalEC = normalize(v_normalEC);
materialInput.positionToEyeEC = -v_positionEC;
materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalize(v_normalEC));
materialInput.slope = v_slope;
materialInput.height = v_height;
materialInput.aspect = v_aspect;
czm_material material = czm_getMaterial(materialInput);
vec4 materialColor = vec4(material.diffuse, material.alpha);
color = alphaBlend(materialColor, color);
#endif
#ifdef ENABLE_VERTEX_LIGHTING
float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalize(v_normalEC)) * u_lambertDiffuseMultiplier + 0.3, 0.0, 1.0);
vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);
#elif defined(ENABLE_DAYNIGHT_SHADING)
float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);
diffuseIntensity = mix(1.0, diffuseIntensity, fade);
vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);
#else
vec4 finalColor = color;
#endif
#ifdef ENABLE_CLIPPING_PLANES
vec4 clippingPlanesEdgeColor = vec4(1.0);
clippingPlanesEdgeColor.rgb = u_clippingPlanesEdgeStyle.rgb;
float clippingPlanesEdgeWidth = u_clippingPlanesEdgeStyle.a;
if (clipDistance < clippingPlanesEdgeWidth)
{
finalColor = clippingPlanesEdgeColor;
}
#endif
#ifdef HIGHLIGHT_FILL_TILE
finalColor = vec4(mix(finalColor.rgb, u_fillHighlightColor.rgb, u_fillHighlightColor.a), finalColor.a);
#endif
#if defined(DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN)
vec3 atmosphereLightDirection = czm_sunDirectionWC;
#else
vec3 atmosphereLightDirection = czm_lightDirectionWC;
#endif
#if defined(GROUND_ATMOSPHERE) || defined(FOG)
if (!czm_backFacing())
{
bool dynamicLighting = false;
#if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_DAYNIGHT_SHADING) || defined(ENABLE_VERTEX_LIGHTING))
dynamicLighting = true;
#endif
vec3 rayleighColor;
vec3 mieColor;
float opacity;
vec3 positionWC;
vec3 lightDirection;
#ifdef PER_FRAGMENT_GROUND_ATMOSPHERE
positionWC = computeEllipsoidPosition();
lightDirection = czm_branchFreeTernary(dynamicLighting, atmosphereLightDirection, normalize(positionWC));
computeAtmosphereScattering(
positionWC,
lightDirection,
rayleighColor,
mieColor,
opacity
);
#else
positionWC = v_positionMC;
lightDirection = czm_branchFreeTernary(dynamicLighting, atmosphereLightDirection, normalize(positionWC));
rayleighColor = v_atmosphereRayleighColor;
mieColor = v_atmosphereMieColor;
opacity = v_atmosphereOpacity;
#endif
rayleighColor = colorCorrect(rayleighColor);
mieColor = colorCorrect(mieColor);
vec4 groundAtmosphereColor = computeAtmosphereColor(positionWC, lightDirection, rayleighColor, mieColor, opacity);
#ifdef FOG
vec3 fogColor = groundAtmosphereColor.rgb;
#if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))
float darken = clamp(dot(normalize(czm_viewerPositionWC), atmosphereLightDirection), u_minimumBrightness, 1.0);
fogColor *= darken;
#endif
#ifndef HDR
fogColor.rgb = czm_acesTonemapping(fogColor.rgb);
fogColor.rgb = czm_inverseGamma(fogColor.rgb);
#endif
const float modifier = 0.15;
finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor.rgb, modifier), finalColor.a);
#else
const float transmittanceModifier = 0.5;
float transmittance = transmittanceModifier + clamp(1.0 - groundAtmosphereColor.a, 0.0, 1.0);
vec3 finalAtmosphereColor = finalColor.rgb + groundAtmosphereColor.rgb * transmittance;
#if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))
float fadeInDist = u_nightFadeDistance.x;
float fadeOutDist = u_nightFadeDistance.y;
float sunlitAtmosphereIntensity = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.05, 1.0);
float darken = clamp(dot(normalize(positionWC), atmosphereLightDirection), 0.0, 1.0);
vec3 darkenendGroundAtmosphereColor = mix(groundAtmosphereColor.rgb, finalAtmosphereColor.rgb, darken);
finalAtmosphereColor = mix(darkenendGroundAtmosphereColor, finalAtmosphereColor, sunlitAtmosphereIntensity);
#endif
#ifndef HDR
finalAtmosphereColor.rgb = vec3(1.0) - exp(-fExposure * finalAtmosphereColor.rgb);
#else
finalAtmosphereColor.rgb = czm_saturation(finalAtmosphereColor.rgb, 1.6);
#endif
finalColor.rgb = mix(finalColor.rgb, finalAtmosphereColor.rgb, fade);
#endif
}
#endif
#ifdef UNDERGROUND_COLOR
if (czm_backFacing())
{
float distanceFromEllipsoid = max(czm_eyeHeight, 0.0);
float distance = max(v_distance - distanceFromEllipsoid, 0.0);
float blendAmount = interpolateByDistance(u_undergroundColorAlphaByDistance, distance);
vec4 undergroundColor = vec4(u_undergroundColor.rgb, u_undergroundColor.a * blendAmount);
finalColor = alphaBlend(undergroundColor, finalColor);
}
#endif
#ifdef TRANSLUCENT
if (inTranslucencyRectangle())
{
vec4 alphaByDistance = gl_FrontFacing ? u_frontFaceAlphaByDistance : u_backFaceAlphaByDistance;
finalColor.a *= interpolateByDistance(alphaByDistance, v_distance);
}
#endif
gl_FragColor =  finalColor;
}
#ifdef SHOW_REFLECTIVE_OCEAN
float waveFade(float edge0, float edge1, float x)
{
float y = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
return pow(1.0 - y, 5.0);
}
float linearFade(float edge0, float edge1, float x)
{
return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
}
const float oceanFrequencyLowAltitude = 825000.0;
const float oceanAnimationSpeedLowAltitude = 0.004;
const float oceanOneOverAmplitudeLowAltitude = 1.0 / 2.0;
const float oceanSpecularIntensity = 0.5;
const float oceanFrequencyHighAltitude = 125000.0;
const float oceanAnimationSpeedHighAltitude = 0.008;
const float oceanOneOverAmplitudeHighAltitude = 1.0 / 2.0;
vec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float maskValue, float fade)
{
vec3 positionToEyeEC = -positionEyeCoordinates;
float positionToEyeECLength = length(positionToEyeEC);
vec3 normalizedPositionToEyeEC = normalize(normalize(positionToEyeEC));
float waveIntensity = waveFade(70000.0, 1000000.0, positionToEyeECLength);
#ifdef SHOW_OCEAN_WAVES
float time = czm_frameNumber * oceanAnimationSpeedHighAltitude;
vec4 noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyHighAltitude, time, 0.0);
vec3 normalTangentSpaceHighAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeHighAltitude);
time = czm_frameNumber * oceanAnimationSpeedLowAltitude;
noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyLowAltitude, time, 0.0);
vec3 normalTangentSpaceLowAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeLowAltitude);
float highAltitudeFade = linearFade(0.0, 60000.0, positionToEyeECLength);
float lowAltitudeFade = 1.0 - linearFade(20000.0, 60000.0, positionToEyeECLength);
vec3 normalTangentSpace =
(highAltitudeFade * normalTangentSpaceHighAltitude) +
(lowAltitudeFade * normalTangentSpaceLowAltitude);
normalTangentSpace = normalize(normalTangentSpace);
normalTangentSpace.xy *= waveIntensity;
normalTangentSpace = normalize(normalTangentSpace);
#else
vec3 normalTangentSpace = vec3(0.0, 0.0, 1.0);
#endif
vec3 normalEC = enuToEye * normalTangentSpace;
const vec3 waveHighlightColor = vec3(0.3, 0.45, 0.6);
float diffuseIntensity = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * maskValue;
vec3 diffuseHighlight = waveHighlightColor * diffuseIntensity * (1.0 - fade);
#ifdef SHOW_OCEAN_WAVES
float tsPerturbationRatio = normalTangentSpace.z;
vec3 nonDiffuseHighlight = mix(waveHighlightColor * 5.0 * (1.0 - tsPerturbationRatio), vec3(0.0), diffuseIntensity);
#else
vec3 nonDiffuseHighlight = vec3(0.0);
#endif
float specularIntensity = czm_getSpecular(czm_lightDirectionEC, normalizedPositionToEyeEC, normalEC, 10.0);
float surfaceReflectance = mix(0.0, mix(u_zoomedOutOceanSpecularIntensity, oceanSpecularIntensity, waveIntensity), maskValue);
float specular = specularIntensity * surfaceReflectance;
#ifdef HDR
specular *= 1.4;
float e = 0.2;
float d = 3.3;
float c = 1.7;
vec3 color = imageryColor.rgb + (c * (vec3(e) + imageryColor.rgb * d) * (diffuseHighlight + nonDiffuseHighlight + specular));
#else
vec3 color = imageryColor.rgb + diffuseHighlight + nonDiffuseHighlight + specular;
#endif
return vec4(color, imageryColor.a);
}
#endif // #ifdef SHOW_REFLECTIVE_OCEAN
`; var mk = `#ifdef QUANTIZATION_BITS12
attribute vec4 compressed0;
attribute float compressed1;
#else
attribute vec4 position3DAndHeight;
attribute vec4 textureCoordAndEncodedNormals;
#endif
#ifdef GEODETIC_SURFACE_NORMALS
attribute vec3 geodeticSurfaceNormal;
#endif
#ifdef EXAGGERATION
uniform vec2 u_terrainExaggerationAndRelativeHeight;
#endif
uniform vec3 u_center3D;
uniform mat4 u_modifiedModelView;
uniform mat4 u_modifiedModelViewProjection;
uniform vec4 u_tileRectangle;
uniform vec2 u_southAndNorthLatitude;
uniform vec2 u_southMercatorYAndOneOverHeight;
varying vec3 v_positionMC;
varying vec3 v_positionEC;
varying vec3 v_textureCoordinates;
varying vec3 v_normalMC;
varying vec3 v_normalEC;
#ifdef APPLY_MATERIAL
varying float v_slope;
varying float v_aspect;
varying float v_height;
#endif
#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)
varying float v_distance;
#endif
#if defined(FOG) || defined(GROUND_ATMOSPHERE)
varying vec3 v_atmosphereRayleighColor;
varying vec3 v_atmosphereMieColor;
varying float v_atmosphereOpacity;
#endif
vec4 getPosition(vec3 position, float height, vec2 textureCoordinates);
float get2DYPositionFraction(vec2 textureCoordinates);
vec4 getPosition3DMode(vec3 position, float height, vec2 textureCoordinates)
{
return u_modifiedModelViewProjection * vec4(position, 1.0);
}
float get2DMercatorYPositionFraction(vec2 textureCoordinates)
{
const float maxTileWidth = 0.003068;
float positionFraction = textureCoordinates.y;
float southLatitude = u_southAndNorthLatitude.x;
float northLatitude = u_southAndNorthLatitude.y;
if (northLatitude - southLatitude > maxTileWidth)
{
float southMercatorY = u_southMercatorYAndOneOverHeight.x;
float oneOverMercatorHeight = u_southMercatorYAndOneOverHeight.y;
float currentLatitude = mix(southLatitude, northLatitude, textureCoordinates.y);
currentLatitude = clamp(currentLatitude, -czm_webMercatorMaxLatitude, czm_webMercatorMaxLatitude);
positionFraction = czm_latitudeToWebMercatorFraction(currentLatitude, southMercatorY, oneOverMercatorHeight);
}
return positionFraction;
}
float get2DGeographicYPositionFraction(vec2 textureCoordinates)
{
return textureCoordinates.y;
}
vec4 getPositionPlanarEarth(vec3 position, float height, vec2 textureCoordinates)
{
float yPositionFraction = get2DYPositionFraction(textureCoordinates);
vec4 rtcPosition2D = vec4(height, mix(u_tileRectangle.st, u_tileRectangle.pq, vec2(textureCoordinates.x, yPositionFraction)), 1.0);
return u_modifiedModelViewProjection * rtcPosition2D;
}
vec4 getPosition2DMode(vec3 position, float height, vec2 textureCoordinates)
{
return getPositionPlanarEarth(position, 0.0, textureCoordinates);
}
vec4 getPositionColumbusViewMode(vec3 position, float height, vec2 textureCoordinates)
{
return getPositionPlanarEarth(position, height, textureCoordinates);
}
vec4 getPositionMorphingMode(vec3 position, float height, vec2 textureCoordinates)
{
vec3 position3DWC = position + u_center3D;
float yPositionFraction = get2DYPositionFraction(textureCoordinates);
vec4 position2DWC = vec4(height, mix(u_tileRectangle.st, u_tileRectangle.pq, vec2(textureCoordinates.x, yPositionFraction)), 1.0);
vec4 morphPosition = czm_columbusViewMorph(position2DWC, vec4(position3DWC, 1.0), czm_morphTime);
return czm_modelViewProjection * morphPosition;
}
#ifdef QUANTIZATION_BITS12
uniform vec2 u_minMaxHeight;
uniform mat4 u_scaleAndBias;
#endif
void main()
{
#ifdef QUANTIZATION_BITS12
vec2 xy = czm_decompressTextureCoordinates(compressed0.x);
vec2 zh = czm_decompressTextureCoordinates(compressed0.y);
vec3 position = vec3(xy, zh.x);
float height = zh.y;
vec2 textureCoordinates = czm_decompressTextureCoordinates(compressed0.z);
height = height * (u_minMaxHeight.y - u_minMaxHeight.x) + u_minMaxHeight.x;
position = (u_scaleAndBias * vec4(position, 1.0)).xyz;
#if (defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL)) && defined(INCLUDE_WEB_MERCATOR_Y)
float webMercatorT = czm_decompressTextureCoordinates(compressed0.w).x;
float encodedNormal = compressed1;
#elif defined(INCLUDE_WEB_MERCATOR_Y)
float webMercatorT = czm_decompressTextureCoordinates(compressed0.w).x;
float encodedNormal = 0.0;
#elif defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL)
float webMercatorT = textureCoordinates.y;
float encodedNormal = compressed0.w;
#else
float webMercatorT = textureCoordinates.y;
float encodedNormal = 0.0;
#endif
#else
vec3 position = position3DAndHeight.xyz;
float height = position3DAndHeight.w;
vec2 textureCoordinates = textureCoordAndEncodedNormals.xy;
#if (defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL) || defined(APPLY_MATERIAL)) && defined(INCLUDE_WEB_MERCATOR_Y)
float webMercatorT = textureCoordAndEncodedNormals.z;
float encodedNormal = textureCoordAndEncodedNormals.w;
#elif defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL) || defined(APPLY_MATERIAL)
float webMercatorT = textureCoordinates.y;
float encodedNormal = textureCoordAndEncodedNormals.z;
#elif defined(INCLUDE_WEB_MERCATOR_Y)
float webMercatorT = textureCoordAndEncodedNormals.z;
float encodedNormal = 0.0;
#else
float webMercatorT = textureCoordinates.y;
float encodedNormal = 0.0;
#endif
#endif
vec3 position3DWC = position + u_center3D;
#ifdef GEODETIC_SURFACE_NORMALS
vec3 ellipsoidNormal = geodeticSurfaceNormal;
#else
vec3 ellipsoidNormal = normalize(position3DWC);
#endif
#if defined(EXAGGERATION) && defined(GEODETIC_SURFACE_NORMALS)
float exaggeration = u_terrainExaggerationAndRelativeHeight.x;
float relativeHeight = u_terrainExaggerationAndRelativeHeight.y;
float newHeight = (height - relativeHeight) * exaggeration + relativeHeight;
float minRadius = min(min(czm_ellipsoidRadii.x, czm_ellipsoidRadii.y), czm_ellipsoidRadii.z);
newHeight = max(newHeight, -minRadius);
vec3 offset = ellipsoidNormal * (newHeight - height);
position += offset;
position3DWC += offset;
height = newHeight;
#endif
gl_Position = getPosition(position, height, textureCoordinates);
v_positionEC = (u_modifiedModelView * vec4(position, 1.0)).xyz;
v_positionMC = position3DWC;
v_textureCoordinates = vec3(textureCoordinates, webMercatorT);
#if defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL) || defined(APPLY_MATERIAL)
vec3 normalMC = czm_octDecode(encodedNormal);
#if defined(EXAGGERATION) && defined(GEODETIC_SURFACE_NORMALS)
vec3 projection = dot(normalMC, ellipsoidNormal) * ellipsoidNormal;
vec3 rejection = normalMC - projection;
normalMC = normalize(projection + rejection * exaggeration);
#endif
v_normalMC = normalMC;
v_normalEC = czm_normal3D * v_normalMC;
#endif
#if defined(FOG) || (defined(GROUND_ATMOSPHERE) && !defined(PER_FRAGMENT_GROUND_ATMOSPHERE))
bool dynamicLighting = false;
#if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_DAYNIGHT_SHADING) || defined(ENABLE_VERTEX_LIGHTING))
dynamicLighting = true;
#endif
#if defined(DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN)
vec3 atmosphereLightDirection = czm_sunDirectionWC;
#else
vec3 atmosphereLightDirection = czm_lightDirectionWC;
#endif
vec3 lightDirection = czm_branchFreeTernary(dynamicLighting, atmosphereLightDirection, normalize(position3DWC));
computeAtmosphereScattering(
position3DWC,
lightDirection,
v_atmosphereRayleighColor,
v_atmosphereMieColor,
v_atmosphereOpacity
);
#endif
#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)
v_distance = length((czm_modelView3D * vec4(position3DWC, 1.0)).xyz);
#endif
#ifdef APPLY_MATERIAL
float northPoleZ = czm_ellipsoidRadii.z;
vec3 northPolePositionMC = vec3(0.0, 0.0, northPoleZ);
vec3 vectorEastMC = normalize(cross(northPolePositionMC - v_positionMC, ellipsoidNormal));
float dotProd = abs(dot(ellipsoidNormal, v_normalMC));
v_slope = acos(dotProd);
vec3 normalRejected = ellipsoidNormal * dotProd;
vec3 normalProjected = v_normalMC - normalRejected;
vec3 aspectVector = normalize(normalProjected);
v_aspect = acos(dot(aspectVector, vectorEastMC));
float determ = dot(cross(vectorEastMC, aspectVector), ellipsoidNormal);
v_aspect = czm_branchFreeTernary(determ < 0.0, 2.0 * czm_pi - v_aspect, v_aspect);
v_height = height;
#endif
}
`; var Hg = `uniform vec3 u_radiiAndDynamicAtmosphereColor;
uniform float u_atmosphereLightIntensity;
uniform float u_atmosphereRayleighScaleHeight;
uniform float u_atmosphereMieScaleHeight;
uniform float u_atmosphereMieAnisotropy;
uniform vec3 u_atmosphereRayleighCoefficient;
uniform vec3 u_atmosphereMieCoefficient;
const float ATMOSPHERE_THICKNESS = 111e3;
const int PRIMARY_STEPS = 16;
const int LIGHT_STEPS = 4;
void computeScattering(
czm_ray primaryRay,
float primaryRayLength,
vec3 lightDirection,
float atmosphereInnerRadius,
out vec3 rayleighColor,
out vec3 mieColor,
out float opacity
) {
rayleighColor = vec3(0.0);
mieColor = vec3(0.0);
opacity = 0.0;
float atmosphereOuterRadius = atmosphereInnerRadius + ATMOSPHERE_THICKNESS;
vec3 origin = vec3(0.0);
czm_raySegment primaryRayAtmosphereIntersect = czm_raySphereIntersectionInterval(primaryRay, origin, atmosphereOuterRadius);
if (primaryRayAtmosphereIntersect == czm_emptyRaySegment) {
return;
}
primaryRayAtmosphereIntersect.start = max(primaryRayAtmosphereIntersect.start, 0.0);
primaryRayAtmosphereIntersect.stop = min(primaryRayAtmosphereIntersect.stop, length(primaryRayLength));
float rayStepLength = (primaryRayAtmosphereIntersect.stop - primaryRayAtmosphereIntersect.start) / float(PRIMARY_STEPS);
float rayPositionLength = primaryRayAtmosphereIntersect.start;
vec3 rayleighAccumulation = vec3(0.0);
vec3 mieAccumulation = vec3(0.0);
vec2 opticalDepth = vec2(0.0);
vec2 heightScale = vec2(u_atmosphereRayleighScaleHeight, u_atmosphereMieScaleHeight);
for (int i = 0; i < PRIMARY_STEPS; i++) {
vec3 samplePosition = primaryRay.origin + primaryRay.direction * (rayPositionLength + rayStepLength);
float sampleHeight = length(samplePosition) - atmosphereInnerRadius;
vec2 sampleDensity = exp(-sampleHeight / heightScale) * rayStepLength;
opticalDepth += sampleDensity;
czm_ray lightRay = czm_ray(samplePosition, lightDirection);
czm_raySegment lightRayAtmosphereIntersect = czm_raySphereIntersectionInterval(lightRay, origin, atmosphereOuterRadius);
float lightStepLength = lightRayAtmosphereIntersect.stop / float(LIGHT_STEPS);
float lightPositionLength = 0.0;
vec2 lightOpticalDepth = vec2(0.0);
for (int j = 0; j < LIGHT_STEPS; j++) {
vec3 lightPosition = samplePosition + lightDirection * (lightPositionLength + lightStepLength * 0.5);
float lightHeight = length(lightPosition) - atmosphereInnerRadius;
lightOpticalDepth += exp(-lightHeight / heightScale) * lightStepLength;
lightPositionLength += lightStepLength;
}
vec3 attenuation = exp(-((u_atmosphereMieCoefficient * (opticalDepth.y + lightOpticalDepth.y)) + (u_atmosphereRayleighCoefficient * (opticalDepth.x + lightOpticalDepth.x))));
rayleighAccumulation += sampleDensity.x * attenuation;
mieAccumulation += sampleDensity.y * attenuation;
rayPositionLength += rayStepLength;
}
rayleighColor = u_atmosphereRayleighCoefficient * rayleighAccumulation;
mieColor = u_atmosphereMieCoefficient * mieAccumulation;
opacity = length(exp(-((u_atmosphereMieCoefficient * opticalDepth.y) + (u_atmosphereRayleighCoefficient * opticalDepth.x))));
}
vec4 computeAtmosphereColor(
vec3 positionWC,
vec3 lightDirection,
vec3 rayleighColor,
vec3 mieColor,
float opacity
) {
vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC;
vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC);
float cosAngle = dot(cameraToPositionWCDirection, lightDirection);
float cosAngleSq = cosAngle * cosAngle;
float G = u_atmosphereMieAnisotropy;
float GSq = G * G;
float rayleighPhase = 3.0 / (50.2654824574) * (1.0 + cosAngleSq);
float miePhase = 3.0 / (25.1327412287) * ((1.0 - GSq) * (cosAngleSq + 1.0)) / (pow(1.0 + GSq - 2.0 * cosAngle * G, 1.5) * (2.0 + GSq));
vec3 rayleigh = rayleighPhase * rayleighColor;
vec3 mie = miePhase * mieColor;
vec3 color = (rayleigh + mie) * u_atmosphereLightIntensity;
return vec4(color, opacity);
}
`; var sv = `void computeAtmosphereScattering(vec3 positionWC, vec3 lightDirection, out vec3 rayleighColor, out vec3 mieColor, out float opacity) {
vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC;
vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC);
czm_ray primaryRay = czm_ray(czm_viewerPositionWC, cameraToPositionWCDirection);
float atmosphereInnerRadius = length(positionWC);
computeScattering(
primaryRay,
length(cameraToPositionWC),
lightDirection,
atmosphereInnerRadius,
rayleighColor,
mieColor,
opacity
);
}
`; function lot(e, t, n, i, o) { this.numberOfDayTextures = e, this.flags = t, this.material = n, this.shaderProgram = i, this.clippingShaderState = o } function nj() { this.baseVertexShaderSource = void 0, this.baseFragmentShaderSource = void 0, this._shadersByTexturesFlags = [], this.material = void 0 } function uot(e) { let t = "vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPosition3DMode(position, height, textureCoordinates); }", n = "vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionColumbusViewMode(position, height, textureCoordinates); }", i = "vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionMorphingMode(position, height, textureCoordinates); }", o; switch (e) { case ee.SCENE3D: o = t; break; case ee.SCENE2D: case ee.COLUMBUS_VIEW: o = n; break; case ee.MORPHING: o = i; break }return o } function fot(e) { return e ? "float get2DYPositionFraction(vec2 textureCoordinates) { return get2DMercatorYPositionFraction(textureCoordinates); }" : "float get2DYPositionFraction(vec2 textureCoordinates) { return get2DGeographicYPositionFraction(textureCoordinates); }" } nj.prototype.getShaderProgram = function (e) {
        let t = e.frameState, n = e.surfaceTile, i = e.numberOfDayTextures, o = e.applyBrightness, r = e.applyContrast, s = e.applyHue, a = e.applySaturation, c = e.applyGamma, u = e.applyAlpha, f = e.applyDayNightAlpha, d = e.applySplit, p = e.showReflectiveOcean, g = e.showOceanWaves, m = e.enableLighting, A = e.dynamicAtmosphereLighting, C = e.dynamicAtmosphereLightingFromSun, x = e.showGroundAtmosphere, T = e.perFragmentGroundAtmosphere, b = e.hasVertexNormals, S = e.useWebMercatorProjection, D = e.enableFog, P = e.enableClippingPlanes, B = e.clippingPlanes, R = e.clippedByBoundaries, M = e.hasImageryLayerCutout, L = e.colorCorrect, _ = e.highlightFillTile, E = e.colorToAlpha, w = e.hasGeodeticSurfaceNormals, v = e.hasExaggeration, O = e.showUndergroundColor, V = e.translucent, z = 0, k = "", N = n.renderedMesh.encoding; N.quantization === Fs.BITS12 && (z = 1, k = "QUANTIZATION_BITS12"); let q = 0, J = ""; R && (q = 1, J = "TILE_LIMIT_RECTANGLE"); let W = 0, K = ""; M && (W = 1, K = "APPLY_IMAGERY_CUTOUT"); let Z = t.mode, de = Z | o << 2 | r << 3 | s << 4 | a << 5 | c << 6 | u << 7 | p << 8 | g << 9 | m << 10 | A << 11 | C << 12 | x << 13 | T << 14 | b << 15 | S << 16 | D << 17 | z << 18 | d << 19 | P << 20 | q << 21 | W << 22 | L << 23 | _ << 24 | E << 25 | w << 26 | v << 27 | O << 28 | V << 29 | f << 30, pe = 0; l(B) && B.length > 0 && (pe = P ? B.clippingPlanesState : 0); let oe = n.surfaceShader; if (l(oe) && oe.numberOfDayTextures === i && oe.flags === de && oe.material === this.material && oe.clippingShaderState === pe) return oe.shaderProgram; let ue = this._shadersByTexturesFlags[i]; if (l(ue) || (ue = this._shadersByTexturesFlags[i] = []), oe = ue[de], !l(oe) || oe.material !== this.material || oe.clippingShaderState !== pe) {
            let ge = this.baseVertexShaderSource.clone(), Ee = this.baseFragmentShaderSource.clone(); pe !== 0 && Ee.sources.unshift(IE(B, t.context)), ge.defines.push(k), Ee.defines.push(`TEXTURE_UNITS ${i}`, J, K), o && Ee.defines.push("APPLY_BRIGHTNESS"), r && Ee.defines.push("APPLY_CONTRAST"), s && Ee.defines.push("APPLY_HUE"), a && Ee.defines.push("APPLY_SATURATION"), c && Ee.defines.push("APPLY_GAMMA"), u && Ee.defines.push("APPLY_ALPHA"), f && Ee.defines.push("APPLY_DAY_NIGHT_ALPHA"), p && (Ee.defines.push("SHOW_REFLECTIVE_OCEAN"), ge.defines.push("SHOW_REFLECTIVE_OCEAN")), g && Ee.defines.push("SHOW_OCEAN_WAVES"), E && Ee.defines.push("APPLY_COLOR_TO_ALPHA"), O && (ge.defines.push("UNDERGROUND_COLOR"), Ee.defines.push("UNDERGROUND_COLOR")), V && (ge.defines.push("TRANSLUCENT"), Ee.defines.push("TRANSLUCENT")), m && (b ? (ge.defines.push("ENABLE_VERTEX_LIGHTING"), Ee.defines.push("ENABLE_VERTEX_LIGHTING")) : (ge.defines.push("ENABLE_DAYNIGHT_SHADING"), Ee.defines.push("ENABLE_DAYNIGHT_SHADING"))), A && (ge.defines.push("DYNAMIC_ATMOSPHERE_LIGHTING"), Ee.defines.push("DYNAMIC_ATMOSPHERE_LIGHTING"), C && (ge.defines.push("DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN"), Ee.defines.push("DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN"))), x && (ge.defines.push("GROUND_ATMOSPHERE"), Ee.defines.push("GROUND_ATMOSPHERE"), T && (ge.defines.push("PER_FRAGMENT_GROUND_ATMOSPHERE"), Ee.defines.push("PER_FRAGMENT_GROUND_ATMOSPHERE"))), ge.defines.push("INCLUDE_WEB_MERCATOR_Y"), Ee.defines.push("INCLUDE_WEB_MERCATOR_Y"), D && (ge.defines.push("FOG"), Ee.defines.push("FOG")), d && Ee.defines.push("APPLY_SPLIT"), P && Ee.defines.push("ENABLE_CLIPPING_PLANES"), L && Ee.defines.push("COLOR_CORRECT"), _ && Ee.defines.push("HIGHLIGHT_FILL_TILE"), w && ge.defines.push("GEODETIC_SURFACE_NORMALS"), v && ge.defines.push("EXAGGERATION"); let Ie = `    vec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend)
    {
        vec4 color = initialColor;
`; M && (Ie += `        vec4 cutoutAndColorResult;
        bool texelUnclipped;
`); for (let We = 0; We < i; ++We)M ? Ie += `        cutoutAndColorResult = u_dayTextureCutoutRectangles[${We}];
        texelUnclipped = v_textureCoordinates.x < cutoutAndColorResult.x || cutoutAndColorResult.z < v_textureCoordinates.x || v_textureCoordinates.y < cutoutAndColorResult.y || cutoutAndColorResult.w < v_textureCoordinates.y;
        cutoutAndColorResult = sampleAndBlend(
`: Ie += `        color = sampleAndBlend(
`, Ie += `            color,
            u_dayTextures[${We}],
            u_dayTextureUseWebMercatorT[${We}] ? textureCoordinates.xz : textureCoordinates.xy,
            u_dayTextureTexCoordsRectangle[${We}],
            u_dayTextureTranslationAndScale[${We}],
            ${u ? `u_dayTextureAlpha[${We}]` : "1.0"},
            ${f ? `u_dayTextureNightAlpha[${We}]` : "1.0"},
${f ? `u_dayTextureDayAlpha[${We}]` : "1.0"},
${o ? `u_dayTextureBrightness[${We}]` : "0.0"},
            ${r ? `u_dayTextureContrast[${We}]` : "0.0"},
            ${s ? `u_dayTextureHue[${We}]` : "0.0"},
            ${a ? `u_dayTextureSaturation[${We}]` : "0.0"},
            ${c ? `u_dayTextureOneOverGamma[${We}]` : "0.0"},
            ${d ? `u_dayTextureSplit[${We}]` : "0.0"},
            ${E ? `u_colorsToAlpha[${We}]` : "vec4(0.0)"},
        nightBlend        );
`, M && (Ie += `        color = czm_branchFreeTernary(texelUnclipped, cutoutAndColorResult, color);
`); Ie += `        return color;
    }`, Ee.sources.push(Ie), ge.sources.push(uot(Z)), ge.sources.push(fot(S)); let Fe = qt.fromCache({ context: t.context, vertexShaderSource: ge, fragmentShaderSource: Ee, attributeLocations: N.getAttributeLocations() }); oe = ue[de] = new lot(i, de, this.material, Fe, pe)
        } return n.surfaceShader = oe, oe.shaderProgram
    }; nj.prototype.destroy = function () { let e, t, n = this._shadersByTexturesFlags; for (let i in n) if (n.hasOwnProperty(i)) { let o = n[i]; if (!l(o)) continue; for (e in o) o.hasOwnProperty(e) && (t = o[e], l(t) && t.shaderProgram.destroy()) } return le(this) }; var pk = nj; var dot = { UNLOADED: 0, TRANSITIONING: 1, RECEIVED: 2, TEXTURE_LOADED: 3, READY: 4, FAILED: 5, INVALID: 6, PLACEHOLDER: 7 }, ii = Object.freeze(dot); var hot = { START: 0, LOADING: 1, DONE: 2, FAILED: 3 }, ks = Object.freeze(hot); var mot = { FAILED: 0, UNLOADED: 1, RECEIVING: 2, RECEIVED: 3, TRANSFORMING: 4, TRANSFORMED: 5, READY: 6 }, fo = Object.freeze(mot); function Ho() { this.imagery = [], this.waterMaskTexture = void 0, this.waterMaskTranslationAndScale = new se(0, 0, 1, 1), this.terrainData = void 0, this.vertexArray = void 0, this.tileBoundingRegion = void 0, this.occludeePointInScaledSpace = new h, this.boundingVolumeSourceTile = void 0, this.boundingVolumeIsFromMesh = !1, this.terrainState = fo.UNLOADED, this.mesh = void 0, this.fill = void 0, this.pickBoundingSphere = new re, this.surfaceShader = void 0, this.isClipped = !0, this.clippedByBoundaries = !1 } Object.defineProperties(Ho.prototype, { eligibleForUnloading: { get: function () { let e = this.terrainState, n = !(e === fo.RECEIVING || e === fo.TRANSFORMING), i = this.imagery; for (let o = 0, r = i.length; n && o < r; ++o) { let s = i[o]; n = !l(s.loadingImagery) || s.loadingImagery.state !== ii.TRANSITIONING } return n } }, renderedMesh: { get: function () { if (l(this.vertexArray)) return this.mesh; if (l(this.fill)) return this.fill.mesh } } }); var pot = new he; function ij(e, t, n, i, o, r) { let s = e.getExaggeratedPosition(i, o, r); if (l(t) && t !== ee.SCENE3D) { let c = n.ellipsoid.cartesianToCartographic(s, pot); s = n.project(c, r), s = h.fromElements(s.z, s.x, s.y, r) } return s } var _ot = new h, got = new h, yot = new h; Ho.prototype.pick = function (e, t, n, i, o) { let r = this.renderedMesh; if (!l(r)) return; let s = r.vertices, a = r.indices, c = r.encoding, u = a.length, f = Number.MAX_VALUE; for (let d = 0; d < u; d += 3) { let p = a[d], g = a[d + 1], m = a[d + 2], A = ij(c, t, n, s, p, _ot), C = ij(c, t, n, s, g, got), x = ij(c, t, n, s, m, yot), T = Gi.rayTriangleParametric(e, A, C, x, i); l(T) && T < f && T >= 0 && (f = T) } return f !== Number.MAX_VALUE ? En.getPoint(e, f, o) : void 0 }; Ho.prototype.freeResources = function () { l(this.waterMaskTexture) && (--this.waterMaskTexture.referenceCount, this.waterMaskTexture.referenceCount === 0 && this.waterMaskTexture.destroy(), this.waterMaskTexture = void 0), this.terrainData = void 0, this.terrainState = fo.UNLOADED, this.mesh = void 0, this.fill = this.fill && this.fill.destroy(); let e = this.imagery; for (let t = 0, n = e.length; t < n; ++t)e[t].freeResources(); this.imagery.length = 0, this.freeVertexArray() }; Ho.prototype.freeVertexArray = function () { Ho._freeVertexArray(this.vertexArray), this.vertexArray = void 0, Ho._freeVertexArray(this.wireframeVertexArray), this.wireframeVertexArray = void 0 }; Ho.initialize = function (e, t, n) { let i = e.data; l(i) || (i = e.data = new Ho), e.state === ks.START && (Aot(e, t, n), e.state = ks.LOADING) }; Ho.processStateMachine = function (e, t, n, i, o, r, s) { Ho.initialize(e, n, i); let a = e.data; if (e.state === ks.LOADING && Cot(e, t, n, i, o, r), s) return; let c = e.renderable; e.renderable = l(a.vertexArray); let u = a.terrainState === fo.READY; e.upsampledFromParent = l(a.terrainData) && a.terrainData.wasCreatedByUpsampling(); let f = a.processImagery(e, n, t); if (u && f) { let d = e._loadedCallbacks, p = {}; for (let g in d) d.hasOwnProperty(g) && (d[g](e) || (p[g] = d[g])); e._loadedCallbacks = p, e.state = ks.DONE } c && (e.renderable = !0) }; Ho.prototype.processImagery = function (e, t, n, i) { let o = e.data, r = e.upsampledFromParent, s = !1, a = !0, c = o.imagery, u, f; for (u = 0, f = c.length; u < f; ++u) { let d = c[u]; if (!l(d.loadingImagery)) { r = !1; continue } if (d.loadingImagery.state === ii.PLACEHOLDER) { let g = d.loadingImagery.imageryLayer; if (g.imageryProvider.ready) { d.freeResources(), c.splice(u, 1), g._createTileImagerySkeletons(e, t, u), --u, f = c.length; continue } else r = !1 } let p = d.processStateMachine(e, n, i); a = a && p, s = s || p || l(d.readyImagery), r = r && l(d.loadingImagery) && (d.loadingImagery.state === ii.FAILED || d.loadingImagery.state === ii.INVALID) } return e.upsampledFromParent = r, e.renderable = e.renderable && (s || a), a }; function Spe(e, t, n, i) { let o = e.renderedMesh, r = o.vertices, s = o.encoding, a = r.length / s.stride, c = _c.clone(s); c.hasGeodeticSurfaceNormals = t, c = _c.clone(c); let u = c.stride, f = new Float32Array(a * u); t ? s.addGeodeticSurfaceNormals(r, f, n) : s.removeGeodeticSurfaceNormals(r, f), o.vertices = f, o.stride = u, o !== e.mesh ? (Ho._freeVertexArray(e.fill.vertexArray), e.fill.vertexArray = Ho._createVertexArrayForMesh(i.context, o)) : (Ho._freeVertexArray(e.vertexArray), e.vertexArray = Ho._createVertexArrayForMesh(i.context, o)), Ho._freeVertexArray(e.wireframeVertexArray), e.wireframeVertexArray = void 0 } Ho.prototype.addGeodeticSurfaceNormals = function (e, t) { Spe(this, !0, e, t) }; Ho.prototype.removeGeodeticSurfaceNormals = function (e) { Spe(this, !1, void 0, e) }; Ho.prototype.updateExaggeration = function (e, t, n) { let i = this, o = i.renderedMesh; if (o === void 0) return; let r = t.terrainExaggeration, s = t.terrainExaggerationRelativeHeight, a = r !== 1, c = o.encoding, u = c.exaggeration !== r, f = c.exaggerationRelativeHeight !== s; if (u || f) { if (u) if (a && !c.hasGeodeticSurfaceNormals) { let d = e.tilingScheme.ellipsoid; i.addGeodeticSurfaceNormals(d, t) } else !a && c.hasGeodeticSurfaceNormals && i.removeGeodeticSurfaceNormals(t); if (c.exaggeration = r, c.exaggerationRelativeHeight = s, n !== void 0) { n._tileToUpdateHeights.push(e); let d = e.customData, p = d.length; for (let g = 0; g < p; g++) { let m = d[g]; m.level = -1 } } } }; function Aot(e, t, n) { let i = t.getTileDataAvailable(e.x, e.y, e.level); if (!l(i) && l(e.parent)) { let o = e.parent, r = o.data; l(r) && l(r.terrainData) && (i = r.terrainData.isChildAvailable(o.x, o.y, e.x, e.y)) } i === !1 && (e.data.terrainState = fo.FAILED); for (let o = 0, r = n.length; o < r; ++o) { let s = n.get(o); s.show && s._createTileImagerySkeletons(e, t) } } function Cot(e, t, n, i, o, r) { let s = e.data, a = e.parent; if (s.terrainState === fo.FAILED && a !== void 0 && (a.data !== void 0 && a.data.terrainData !== void 0 && a.data.terrainData.canUpsample !== !1 || Ho.processStateMachine(a, t, n, i, o, r, !0)), s.terrainState === fo.FAILED && xot(s, e, t, n, e.x, e.y, e.level), s.terrainState === fo.UNLOADED && Tot(s, n, e.x, e.y, e.level), s.terrainState === fo.RECEIVED && bot(s, t, n, e.x, e.y, e.level), s.terrainState === fo.TRANSFORMED && (Sot(s, t.context, n, e.x, e.y, e.level, r), s.updateExaggeration(e, t, o)), s.terrainState >= fo.RECEIVED && s.waterMaskTexture === void 0 && n.hasWaterMask) if (s.terrainData.waterMask !== void 0) Dot(t.context, s); else { let u = s._findAncestorTileWithTerrainData(e); l(u) && l(u.data.waterMaskTexture) && (s.waterMaskTexture = u.data.waterMaskTexture, ++s.waterMaskTexture.referenceCount, s._computeWaterMaskTranslationAndScale(e, u, s.waterMaskTranslationAndScale)) } } function xot(e, t, n, i, o, r, s) { let a = t.parent; if (!a) { t.state = ks.FAILED; return } let c = a.data.terrainData, u = a.x, f = a.y, d = a.level; if (!l(c)) return; let p = c.upsample(i.tilingScheme, u, f, d, o, r, s); !l(p) || (e.terrainState = fo.RECEIVING, Promise.resolve(p).then(function (g) { e.terrainData = g, e.terrainState = fo.RECEIVED }).catch(function () { e.terrainState = fo.FAILED })) } function Tot(e, t, n, i, o) { function r(c) { e.terrainData = c, e.terrainState = fo.RECEIVED, e.request = void 0 } function s(c) { if (e.request.state === ri.CANCELLED) { e.terrainData = void 0, e.terrainState = fo.UNLOADED, e.request = void 0; return } e.terrainState = fo.FAILED, e.request = void 0; let u = `Failed to obtain terrain tile X: ${n} Y: ${i} Level: ${o}. Error message: "${c}"`; t._requestError = Gn.reportError(t._requestError, t, t.errorEvent, u, n, i, o), t._requestError.retry && a() } function a() { let c = new jo({ throttle: !1, throttleByServer: !0, type: Xr.TERRAIN }); e.request = c; let u = t.requestTileGeometry(n, i, o, c); l(u) ? (e.terrainState = fo.RECEIVING, Promise.resolve(u).then(function (f) { r(f) }).catch(function (f) { s(f) })) : (e.terrainState = fo.UNLOADED, e.request = void 0) } a() } var Eot = { tilingScheme: void 0, x: 0, y: 0, level: 0, exaggeration: 1, exaggerationRelativeHeight: 0, throttle: !0 }; function bot(e, t, n, i, o, r) { let s = n.tilingScheme, a = Eot; a.tilingScheme = s, a.x = i, a.y = o, a.level = r, a.exaggeration = t.terrainExaggeration, a.exaggerationRelativeHeight = t.terrainExaggerationRelativeHeight, a.throttle = !0; let u = e.terrainData.createMesh(a); !l(u) || (e.terrainState = fo.TRANSFORMING, Promise.resolve(u).then(function (f) { e.mesh = f, e.terrainState = fo.TRANSFORMED }).catch(function () { e.terrainState = fo.FAILED })) } Ho._createVertexArrayForMesh = function (e, t) { let n = t.vertices, i = ct.createVertexBuffer({ context: e, typedArray: n, usage: Re.STATIC_DRAW }), o = t.encoding.getAttributes(i), r = t.indices.indexBuffers || {}, s = r[e.id]; if (!l(s) || s.isDestroyed()) { let a = t.indices; s = ct.createIndexBuffer({ context: e, typedArray: a, usage: Re.STATIC_DRAW, indexDatatype: Me.fromSizeInBytes(a.BYTES_PER_ELEMENT) }), s.vertexArrayDestroyable = !1, s.referenceCount = 1, r[e.id] = s, t.indices.indexBuffers = r } else ++s.referenceCount; return new Qn({ context: e, attributes: o, indexBuffer: s }) }; Ho._freeVertexArray = function (e) { if (l(e)) { let t = e.indexBuffer; e.isDestroyed() || e.destroy(), l(t) && !t.isDestroyed() && l(t.referenceCount) && (--t.referenceCount, t.referenceCount === 0 && t.destroy()) } }; function Sot(e, t, n, i, o, r, s) { e.vertexArray = Ho._createVertexArrayForMesh(t, e.mesh), e.terrainState = fo.READY, e.fill = e.fill && e.fill.destroy(s) } function wot(e) { let t = e.cache.tile_waterMaskData; if (!l(t)) { let n = Rt.create({ context: e, pixelFormat: ht.LUMINANCE, pixelDatatype: Ye.UNSIGNED_BYTE, source: { arrayBufferView: new Uint8Array([255]), width: 1, height: 1 } }); n.referenceCount = 1; let i = new dn({ wrapS: In.CLAMP_TO_EDGE, wrapT: In.CLAMP_TO_EDGE, minificationFilter: ln.LINEAR, magnificationFilter: Xi.LINEAR }); t = { allWaterTexture: n, sampler: i, destroy: function () { this.allWaterTexture.destroy() } }, e.cache.tile_waterMaskData = t } return t } function Dot(e, t) { let n = t.terrainData.waterMask, i = wot(e), o, r = n.length; if (r === 1) if (n[0] !== 0) o = i.allWaterTexture; else return; else { let s = Math.sqrt(r); o = Rt.create({ context: e, pixelFormat: ht.LUMINANCE, pixelDatatype: Ye.UNSIGNED_BYTE, source: { width: s, height: s, arrayBufferView: n }, sampler: i.sampler, flipY: !1 }), o.referenceCount = 0 } ++o.referenceCount, t.waterMaskTexture = o, se.fromElements(0, 0, 1, 1, t.waterMaskTranslationAndScale) } Ho.prototype._findAncestorTileWithTerrainData = function (e) { let t = e.parent; for (; l(t) && (!l(t.data) || !l(t.data.terrainData) || t.data.terrainData.wasCreatedByUpsampling());)t = t.parent; return t }; Ho.prototype._computeWaterMaskTranslationAndScale = function (e, t, n) { let i = t.rectangle, o = e.rectangle, r = o.width, s = o.height, a = r / i.width, c = s / i.height; return n.x = a * (o.west - i.west) / r, n.y = c * (o.south - i.south) / s, n.z = a, n.w = c, n }; var fd = Ho; var _k = `uniform sampler2D u_texture;
varying vec2 v_textureCoordinates;
void main()
{
gl_FragColor = texture2D(u_texture, v_textureCoordinates);
}
`; var gk = `attribute vec4 position;
attribute float webMercatorT;
uniform vec2 u_textureDimensions;
varying vec2 v_textureCoordinates;
void main()
{
v_textureCoordinates = vec2(position.x, webMercatorT);
gl_Position = czm_viewportOrthographic * (position * vec4(u_textureDimensions, 1.0, 1.0));
}
`; function OE(e, t, n, i, o) { if (this.imageryLayer = e, this.x = t, this.y = n, this.level = i, this.request = void 0, i !== 0) { let r = t / 2 | 0, s = n / 2 | 0, a = i - 1; this.parent = e.getImageryFromCache(r, s, a) } this.state = ii.UNLOADED, this.imageUrl = void 0, this.image = void 0, this.texture = void 0, this.textureWebMercator = void 0, this.credits = void 0, this.referenceCount = 0, !l(o) && e.imageryProvider.ready && (o = e.imageryProvider.tilingScheme.tileXYToRectangle(t, n, i)), this.rectangle = o } OE.createPlaceholder = function (e) { let t = new OE(e, 0, 0, 0); return t.addReference(), t.state = ii.PLACEHOLDER, t }; OE.prototype.addReference = function () { ++this.referenceCount }; OE.prototype.releaseReference = function () { return --this.referenceCount, this.referenceCount === 0 ? (this.imageryLayer.removeImageryFromCache(this), l(this.parent) && this.parent.releaseReference(), l(this.image) && l(this.image.destroy) && this.image.destroy(), l(this.texture) && this.texture.destroy(), l(this.textureWebMercator) && this.texture !== this.textureWebMercator && this.textureWebMercator.destroy(), le(this), 0) : this.referenceCount }; OE.prototype.processStateMachine = function (e, t, n) { this.state === ii.UNLOADED && !n && (this.state = ii.TRANSITIONING, this.imageryLayer._requestImagery(this)), this.state === ii.RECEIVED && (this.state = ii.TRANSITIONING, this.imageryLayer._createTexture(e.context, this)); let i = this.state === ii.READY && t && !this.texture; (this.state === ii.TEXTURE_LOADED || i) && (this.state = ii.TRANSITIONING, this.imageryLayer._reprojectTexture(e, this, t)) }; var av = OE; function oj(e, t, n) { this.readyImagery = void 0, this.loadingImagery = e, this.textureCoordinateRectangle = t, this.textureTranslationAndScale = void 0, this.useWebMercatorT = n } oj.prototype.freeResources = function () { l(this.readyImagery) && this.readyImagery.releaseReference(), l(this.loadingImagery) && this.loadingImagery.releaseReference() }; oj.prototype.processStateMachine = function (e, t, n) { let i = this.loadingImagery, o = i.imageryLayer; if (i.processStateMachine(t, !this.useWebMercatorT, n), i.state === ii.READY) return l(this.readyImagery) && this.readyImagery.releaseReference(), this.readyImagery = this.loadingImagery, this.loadingImagery = void 0, this.textureTranslationAndScale = o._calculateTextureTranslationAndScale(e, this), !0; let r = i.parent, s; for (; l(r) && (r.state !== ii.READY || !this.useWebMercatorT && !l(r.texture));)r.state !== ii.FAILED && r.state !== ii.INVALID && (s = s || r), r = r.parent; return this.readyImagery !== r && (l(this.readyImagery) && this.readyImagery.releaseReference(), this.readyImagery = r, l(r) && (r.addReference(), this.textureTranslationAndScale = o._calculateTextureTranslationAndScale(e, this))), i.state === ii.FAILED || i.state === ii.INVALID ? l(s) ? (s.processStateMachine(t, !this.useWebMercatorT, n), !1) : !0 : !1 }; var cv = oj; function Pi(e, t) { this._imageryProvider = e, t = y(t, y.EMPTY_OBJECT), this.alpha = y(t.alpha, y(e.defaultAlpha, 1)), this.nightAlpha = y(t.nightAlpha, y(e.defaultNightAlpha, 1)), this.dayAlpha = y(t.dayAlpha, y(e.defaultDayAlpha, 1)), this.brightness = y(t.brightness, y(e.defaultBrightness, Pi.DEFAULT_BRIGHTNESS)), this.contrast = y(t.contrast, y(e.defaultContrast, Pi.DEFAULT_CONTRAST)), this.hue = y(t.hue, y(e.defaultHue, Pi.DEFAULT_HUE)), this.saturation = y(t.saturation, y(e.defaultSaturation, Pi.DEFAULT_SATURATION)), this.gamma = y(t.gamma, y(e.defaultGamma, Pi.DEFAULT_GAMMA)), this.splitDirection = y(t.splitDirection, y(e.defaultSplit, Pi.DEFAULT_SPLIT)), this.minificationFilter = y(t.minificationFilter, y(e.defaultMinificationFilter, Pi.DEFAULT_MINIFICATION_FILTER)), this.magnificationFilter = y(t.magnificationFilter, y(e.defaultMagnificationFilter, Pi.DEFAULT_MAGNIFICATION_FILTER)), this.show = y(t.show, !0), this._minimumTerrainLevel = t.minimumTerrainLevel, this._maximumTerrainLevel = t.maximumTerrainLevel, this._rectangle = y(t.rectangle, ce.MAX_VALUE), this._maximumAnisotropy = t.maximumAnisotropy, this._imageryCache = {}, this._skeletonPlaceholder = new cv(av.createPlaceholder(this)), this._show = !0, this._layerIndex = -1, this._isBaseLayer = !1, this._requestImageError = void 0, this._reprojectComputeCommands = [], this.cutoutRectangle = t.cutoutRectangle, this.colorToAlpha = t.colorToAlpha, this.colorToAlphaThreshold = y(t.colorToAlphaThreshold, Pi.DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD) } Object.defineProperties(Pi.prototype, { imageryProvider: { get: function () { return this._imageryProvider } }, rectangle: { get: function () { return this._rectangle } } }); Pi.DEFAULT_BRIGHTNESS = 1; Pi.DEFAULT_CONTRAST = 1; Pi.DEFAULT_HUE = 0; Pi.DEFAULT_SATURATION = 1; Pi.DEFAULT_GAMMA = 1; Pi.DEFAULT_SPLIT = zc.NONE; Pi.DEFAULT_MINIFICATION_FILTER = ln.LINEAR; Pi.DEFAULT_MAGNIFICATION_FILTER = Xi.LINEAR; Pi.DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD = .004; Pi.prototype.isBaseLayer = function () { return this._isBaseLayer }; Pi.prototype.isDestroyed = function () { return !1 }; Pi.prototype.destroy = function () { return le(this) }; var vpe = new ce, wpe = new ce, rj = new ce, Ppe = new ce; Pi.prototype.getViewableRectangle = function () { let e = this._imageryProvider, t = this._rectangle; return e.readyPromise.then(function () { return ce.intersection(e.rectangle, t) }) }; Pi.prototype._createTileImagerySkeletons = function (e, t, n) { let i = e.data; if (l(this._minimumTerrainLevel) && e.level < this._minimumTerrainLevel || l(this._maximumTerrainLevel) && e.level > this._maximumTerrainLevel) return !1; let o = this._imageryProvider; if (l(n) || (n = i.imagery.length), !o.ready) return this._skeletonPlaceholder.loadingImagery.addReference(), i.imagery.splice(n, 0, this._skeletonPlaceholder), !0; let r = o.tilingScheme.projection instanceof Ri && e.rectangle.north < Ri.MaximumLatitude && e.rectangle.south > -Ri.MaximumLatitude, s = ce.intersection(o.rectangle, this._rectangle, vpe), a = ce.intersection(e.rectangle, s, wpe); if (!l(a)) { if (!this.isBaseLayer()) return !1; let w = s, v = e.rectangle; a = wpe, v.south >= w.north ? a.north = a.south = w.north : v.north <= w.south ? a.north = a.south = w.south : (a.south = Math.max(v.south, w.south), a.north = Math.min(v.north, w.north)), v.west >= w.east ? a.west = a.east = w.east : v.east <= w.west ? a.west = a.east = w.west : (a.west = Math.max(v.west, w.west), a.east = Math.min(v.east, w.east)) } let c = 0; a.south > 0 ? c = a.south : a.north < 0 && (c = a.north); let f = 1 * t.getLevelMaximumGeometricError(e.level), d = Iot(this, f, c); d = Math.max(0, d); let p = o.maximumLevel; if (d > p && (d = p), l(o.minimumLevel)) { let w = o.minimumLevel; d < w && (d = w) } let g = o.tilingScheme, m = g.positionToTileXY(ce.northwest(a), d), A = g.positionToTileXY(ce.southeast(a), d), C = e.rectangle.width / 512, x = e.rectangle.height / 512, T = g.tileXYToRectangle(m.x, m.y, d); Math.abs(T.south - e.rectangle.north) < x && m.y < A.y && ++m.y, Math.abs(T.east - e.rectangle.west) < C && m.x < A.x && ++m.x; let b = g.tileXYToRectangle(A.x, A.y, d); Math.abs(b.north - e.rectangle.south) < x && A.y > m.y && --A.y, Math.abs(b.west - e.rectangle.east) < C && A.x > m.x && --A.x; let S = ce.clone(e.rectangle, Ppe), D = g.tileXYToRectangle(m.x, m.y, d), P = ce.intersection(D, s, rj), B; r ? (g.rectangleToNativeRectangle(S, S), g.rectangleToNativeRectangle(D, D), g.rectangleToNativeRectangle(P, P), g.rectangleToNativeRectangle(s, s), B = g.tileXYToNativeRectangle.bind(g), C = S.width / 512, x = S.height / 512) : B = g.tileXYToRectangle.bind(g); let R, M = 0, L = 1, _; !this.isBaseLayer() && Math.abs(P.west - S.west) >= C && (M = Math.min(1, (P.west - S.west) / S.width)), !this.isBaseLayer() && Math.abs(P.north - S.north) >= x && (L = Math.max(0, (P.north - S.south) / S.height)); let E = L; for (let w = m.x; w <= A.x; w++)if (R = M, D = B(w, m.y, d), P = ce.simpleIntersection(D, s, rj), !!l(P)) { M = Math.min(1, (P.east - S.west) / S.width), w === A.x && (this.isBaseLayer() || Math.abs(P.east - S.east) < C) && (M = 1), L = E; for (let v = m.y; v <= A.y; v++) { if (_ = L, D = B(w, v, d), P = ce.simpleIntersection(D, s, rj), !l(P)) continue; L = Math.max(0, (P.south - S.south) / S.height), v === A.y && (this.isBaseLayer() || Math.abs(P.south - S.south) < x) && (L = 0); let O = new se(R, L, M, _), V = this.getImageryFromCache(w, v, d); i.imagery.splice(n, 0, new cv(V, O, r)), ++n } } return !0 }; Pi.prototype._calculateTextureTranslationAndScale = function (e, t) { let n = t.readyImagery.rectangle, i = e.rectangle; if (t.useWebMercatorT) { let c = t.readyImagery.imageryLayer.imageryProvider.tilingScheme; n = c.rectangleToNativeRectangle(n, vpe), i = c.rectangleToNativeRectangle(i, Ppe) } let o = i.width, r = i.height, s = o / n.width, a = r / n.height; return new se(s * (i.west - n.west) / o, a * (i.south - n.south) / r, s, a) }; Pi.prototype._requestImagery = function (e) { let t = this._imageryProvider, n = this; function i(s) { if (!l(s)) return o(); e.image = s, e.state = ii.RECEIVED, e.request = void 0, Gn.reportSuccess(n._requestImageError) } function o(s) { if (e.request.state === ri.CANCELLED) { e.state = ii.UNLOADED, e.request = void 0; return } e.state = ii.FAILED, e.request = void 0; let a = `Failed to obtain image tile X: ${e.x} Y: ${e.y} Level: ${e.level}.`; n._requestImageError = Gn.reportError(n._requestImageError, t, t.errorEvent, a, e.x, e.y, e.level, s), n._requestImageError.retry && r() } function r() { let s = new jo({ throttle: !1, throttleByServer: !0, type: Xr.IMAGERY }); e.request = s, e.state = ii.TRANSITIONING; let a = t.requestImage(e.x, e.y, e.level, s); if (!l(a)) { e.state = ii.UNLOADED, e.request = void 0; return } l(t.getTileCredits) && (e.credits = t.getTileCredits(e.x, e.y, e.level)), a.then(function (c) { i(c) }).catch(function (c) { o(c) }) } r() }; Pi.prototype._createTextureWebGL = function (e, t) { let n = new dn({ minificationFilter: this.minificationFilter, magnificationFilter: this.magnificationFilter }), i = t.image; return l(i.internalFormat) ? new Rt({ context: e, pixelFormat: i.internalFormat, width: i.width, height: i.height, source: { arrayBufferView: i.bufferView }, sampler: n }) : new Rt({ context: e, source: i, pixelFormat: this._imageryProvider.hasAlphaChannel ? ht.RGBA : ht.RGB, sampler: n }) }; Pi.prototype._createTexture = function (e, t) { let n = this._imageryProvider, i = t.image; if (l(n.tileDiscardPolicy)) { let r = n.tileDiscardPolicy; if (l(r)) { if (!r.isReady()) { t.state = ii.RECEIVED; return } if (r.shouldDiscardImage(i)) { t.state = ii.INVALID; return } } } let o = this._createTextureWebGL(e, t); n.tilingScheme.projection instanceof Ri ? t.textureWebMercator = o : t.texture = o, t.image = void 0, t.state = ii.TEXTURE_LOADED }; function Dpe(e, t, n) { return `${e}:${t}:${n}` } Pi.prototype._finalizeReprojectTexture = function (e, t) { let n = this.minificationFilter, i = this.magnificationFilter; if (n === ln.LINEAR && i === Xi.LINEAR && !ht.isCompressedFormat(t.pixelFormat) && I.isPowerOfTwo(t.width) && I.isPowerOfTwo(t.height)) { n = ln.LINEAR_MIPMAP_LINEAR; let r = Ut.maximumTextureFilterAnisotropy, s = Math.min(r, y(this._maximumAnisotropy, r)), a = Dpe(n, i, s), c = e.cache.imageryLayerMipmapSamplers; l(c) || (c = {}, e.cache.imageryLayerMipmapSamplers = c); let u = c[a]; l(u) || (u = c[a] = new dn({ wrapS: In.CLAMP_TO_EDGE, wrapT: In.CLAMP_TO_EDGE, minificationFilter: n, magnificationFilter: i, maximumAnisotropy: s })), t.generateMipmap($h.NICEST), t.sampler = u } else { let r = Dpe(n, i, 0), s = e.cache.imageryLayerNonMipmapSamplers; l(s) || (s = {}, e.cache.imageryLayerNonMipmapSamplers = s); let a = s[r]; l(a) || (a = s[r] = new dn({ wrapS: In.CLAMP_TO_EDGE, wrapT: In.CLAMP_TO_EDGE, minificationFilter: n, magnificationFilter: i })), t.sampler = a } }; Pi.prototype._reprojectTexture = function (e, t, n) { let i = t.textureWebMercator || t.texture, o = t.rectangle, r = e.context; if (n = y(n, !0), n && !(this._imageryProvider.tilingScheme.projection instanceof _i) && o.width / i.width > 1e-5) { let s = this; t.addReference(); let a = new pf({ persists: !0, owner: this, preExecute: function (c) { Pot(c, r, i, t.rectangle) }, postExecute: function (c) { t.texture = c, s._finalizeReprojectTexture(r, c), t.state = ii.READY, t.releaseReference() }, canceled: function () { t.state = ii.TEXTURE_LOADED, t.releaseReference() } }); this._reprojectComputeCommands.push(a) } else n && (t.texture = i), this._finalizeReprojectTexture(r, i), t.state = ii.READY }; Pi.prototype.queueReprojectionCommands = function (e) { let t = this._reprojectComputeCommands, n = t.length; for (let i = 0; i < n; ++i)e.commandList.push(t[i]); t.length = 0 }; Pi.prototype.cancelReprojections = function () { this._reprojectComputeCommands.forEach(function (e) { l(e.canceled) && e.canceled() }), this._reprojectComputeCommands.length = 0 }; Pi.prototype.getImageryFromCache = function (e, t, n, i) { let o = Ipe(e, t, n), r = this._imageryCache[o]; return l(r) || (r = new av(this, e, t, n, i), this._imageryCache[o] = r), r.addReference(), r }; Pi.prototype.removeImageryFromCache = function (e) { let t = Ipe(e.x, e.y, e.level); delete this._imageryCache[t] }; function Ipe(e, t, n) { return JSON.stringify([e, t, n]) } var yk = { u_textureDimensions: function () { return this.textureDimensions }, u_texture: function () { return this.texture }, textureDimensions: new H, texture: void 0 }, vot = Nt.supportsTypedArrays() ? new Float32Array(2 * 64) : void 0; function Pot(e, t, n, i) { let o = t.cache.imageryLayer_reproject; if (!l(o)) { o = t.cache.imageryLayer_reproject = { vertexArray: void 0, shaderProgram: void 0, sampler: void 0, destroy: function () { l(this.framebuffer) && this.framebuffer.destroy(), l(this.vertexArray) && this.vertexArray.destroy(), l(this.shaderProgram) && this.shaderProgram.destroy() } }; let C = new Float32Array(2 * 64 * 2), x = 0; for (let P = 0; P < 64; ++P) { let B = P / 63; C[x++] = 0, C[x++] = B, C[x++] = 1, C[x++] = B } let T = { position: 0, webMercatorT: 1 }, b = Hr.getRegularGridIndices(2, 64), S = ct.createIndexBuffer({ context: t, typedArray: b, usage: Re.STATIC_DRAW, indexDatatype: Me.UNSIGNED_SHORT }); o.vertexArray = new Qn({ context: t, attributes: [{ index: T.position, vertexBuffer: ct.createVertexBuffer({ context: t, typedArray: C, usage: Re.STATIC_DRAW }), componentsPerAttribute: 2 }, { index: T.webMercatorT, vertexBuffer: ct.createVertexBuffer({ context: t, sizeInBytes: 64 * 2 * 4, usage: Re.STREAM_DRAW }), componentsPerAttribute: 1 }], indexBuffer: S }); let D = new Ue({ sources: [gk] }); o.shaderProgram = qt.fromCache({ context: t, vertexShaderSource: D, fragmentShaderSource: _k, attributeLocations: T }), o.sampler = new dn({ wrapS: In.CLAMP_TO_EDGE, wrapT: In.CLAMP_TO_EDGE, minificationFilter: ln.LINEAR, magnificationFilter: Xi.LINEAR }) } n.sampler = o.sampler; let r = n.width, s = n.height; yk.textureDimensions.x = r, yk.textureDimensions.y = s, yk.texture = n; let a = Math.sin(i.south), c = .5 * Math.log((1 + a) / (1 - a)); a = Math.sin(i.north); let u = .5 * Math.log((1 + a) / (1 - a)), f = 1 / (u - c), d = new Rt({ context: t, width: r, height: s, pixelFormat: n.pixelFormat, pixelDatatype: n.pixelDatatype, preMultiplyAlpha: n.preMultiplyAlpha }); I.isPowerOfTwo(r) && I.isPowerOfTwo(s) && d.generateMipmap($h.NICEST); let p = i.south, g = i.north, m = vot, A = 0; for (let C = 0; C < 64; ++C) { let x = C / 63, T = I.lerp(p, g, x); a = Math.sin(T); let S = (.5 * Math.log((1 + a) / (1 - a)) - c) * f; m[A++] = S, m[A++] = S } o.vertexArray.getAttribute(1).vertexBuffer.copyFromArrayView(m), e.shaderProgram = o.shaderProgram, e.outputTexture = d, e.uniformMap = yk, e.vertexArray = o.vertexArray } function Iot(e, t, n) { let i = e._imageryProvider, o = i.tilingScheme, r = o.ellipsoid, s = e._imageryProvider.tilingScheme.projection instanceof _i ? 1 : Math.cos(n), a = o.rectangle, u = r.maximumRadius * a.width * s / (i.tileWidth * o.getNumberOfXTilesAtLevel(0)) / t, f = Math.log(u) / Math.log(2); return Math.round(f) | 0 } var Qu = Pi; var Ope = { NONE: 0, CULLED: 1, RENDERED: 2, REFINED: 3, RENDERED_AND_KICKED: 6, REFINED_AND_KICKED: 7, CULLED_BUT_NEEDED: 9, wasKicked: function (e) { return e >= Ope.RENDERED_AND_KICKED }, originalResult: function (e) { return e & 3 }, kick: function (e) { return e | 4 } }, qn = Ope; function RE(e) { this.tile = e, this.frameLastUpdated = void 0, this.westMeshes = [], this.westTiles = [], this.southMeshes = [], this.southTiles = [], this.eastMeshes = [], this.eastTiles = [], this.northMeshes = [], this.northTiles = [], this.southwestMesh = void 0, this.southwestTile = void 0, this.southeastMesh = void 0, this.southeastTile = void 0, this.northwestMesh = void 0, this.northwestTile = void 0, this.northeastMesh = void 0, this.northeastTile = void 0, this.changedThisFrame = !0, this.visitedFrame = void 0, this.enqueuedFrame = void 0, this.mesh = void 0, this.vertexArray = void 0, this.waterMaskTexture = void 0, this.waterMaskTranslationAndScale = new se } RE.prototype.update = function (e, t, n) { this.changedThisFrame && (Vpe(e, t, this.tile, n), this.changedThisFrame = !1) }; RE.prototype.destroy = function (e) { this._destroyVertexArray(e), l(this.waterMaskTexture) && (--this.waterMaskTexture.referenceCount, this.waterMaskTexture.referenceCount === 0 && this.waterMaskTexture.destroy(), this.waterMaskTexture = void 0) }; RE.prototype._destroyVertexArray = function (e) { l(this.vertexArray) && (l(e) ? e.push(this.vertexArray) : fd._freeVertexArray(this.vertexArray), this.vertexArray = void 0) }; var Oot = new ry; RE.updateFillTiles = function (e, t, n, i) { let o = e._quadtree, r = o._levelZeroTiles, s = o._lastSelectionFrameNumber, a = Oot; a.clear(); for (let u = 0; u < t.length; ++u) { let f = t[u]; l(f.data.vertexArray) && a.enqueue(t[u]) } let c = a.dequeue(); for (; c !== void 0;) { let u = c.findTileToWest(r), f = c.findTileToSouth(r), d = c.findTileToEast(r), p = c.findTileToNorth(r); is(e, n, c, u, s, un.EAST, !1, a, i), is(e, n, c, f, s, un.NORTH, !1, a, i), is(e, n, c, d, s, un.WEST, !1, a, i), is(e, n, c, p, s, un.SOUTH, !1, a, i); let g = u.findTileToNorth(r), m = u.findTileToSouth(r), A = d.findTileToNorth(r), C = d.findTileToSouth(r); is(e, n, c, g, s, un.SOUTHEAST, !1, a, i), is(e, n, c, A, s, un.SOUTHWEST, !1, a, i), is(e, n, c, m, s, un.NORTHEAST, !1, a, i), is(e, n, c, C, s, un.NORTHWEST, !1, a, i), c = a.dequeue() } }; function is(e, t, n, i, o, r, s, a, c) { if (i === void 0) return; let u = i; for (; u && (u._lastSelectionResultFrame !== o || qn.wasKicked(u._lastSelectionResult) || qn.originalResult(u._lastSelectionResult) === qn.CULLED);) { if (s) return; let f = u.parent; if (r >= un.NORTHWEST && f !== void 0) switch (r) { case un.NORTHWEST: u = u === f.northwestChild ? f : void 0; break; case un.NORTHEAST: u = u === f.northeastChild ? f : void 0; break; case un.SOUTHWEST: u = u === f.southwestChild ? f : void 0; break; case un.SOUTHEAST: u = u === f.southeastChild ? f : void 0; break } else u = f } if (u !== void 0) { if (u._lastSelectionResult === qn.RENDERED) { if (l(u.data.vertexArray)) return; Bot(e, t, n, u, r, o, a, c); return } if (qn.originalResult(i._lastSelectionResult) !== qn.CULLED) switch (r) { case un.WEST: is(e, t, n, i.northwestChild, o, r, !0, a, c), is(e, t, n, i.southwestChild, o, r, !0, a, c); break; case un.EAST: is(e, t, n, i.southeastChild, o, r, !0, a, c), is(e, t, n, i.northeastChild, o, r, !0, a, c); break; case un.SOUTH: is(e, t, n, i.southwestChild, o, r, !0, a, c), is(e, t, n, i.southeastChild, o, r, !0, a, c); break; case un.NORTH: is(e, t, n, i.northeastChild, o, r, !0, a, c), is(e, t, n, i.northwestChild, o, r, !0, a, c); break; case un.NORTHWEST: is(e, t, n, i.northwestChild, o, r, !0, a, c); break; case un.NORTHEAST: is(e, t, n, i.northeastChild, o, r, !0, a, c); break; case un.SOUTHWEST: is(e, t, n, i.southwestChild, o, r, !0, a, c); break; case un.SOUTHEAST: is(e, t, n, i.southeastChild, o, r, !0, a, c); break; default: throw new ye("Invalid edge") } } } function Bot(e, t, n, i, o, r, s, a) { let c = i.data; if (c.fill === void 0) c.fill = new RE(i); else if (c.fill.visitedFrame === r) return; c.fill.enqueuedFrame !== r && (c.fill.enqueuedFrame = r, c.fill.changedThisFrame = !1, s.enqueue(i)), Rot(e, t, n, i, o, a) } function Rot(e, t, n, i, o, r) { let s = i.data.fill, a, c = n.data.fill; l(c) ? (c.visitedFrame = t.frameNumber, c.changedThisFrame && (Vpe(e, t, n, r), c.changedThisFrame = !1), a = n.data.fill.mesh) : a = n.data.mesh; let u, f; switch (o) { case un.WEST: u = s.westMeshes, f = s.westTiles; break; case un.SOUTH: u = s.southMeshes, f = s.southTiles; break; case un.EAST: u = s.eastMeshes, f = s.eastTiles; break; case un.NORTH: u = s.northMeshes, f = s.northTiles; break; case un.NORTHWEST: s.changedThisFrame = s.changedThisFrame || s.northwestMesh !== a, s.northwestMesh = a, s.northwestTile = n; return; case un.NORTHEAST: s.changedThisFrame = s.changedThisFrame || s.northeastMesh !== a, s.northeastMesh = a, s.northeastTile = n; return; case un.SOUTHWEST: s.changedThisFrame = s.changedThisFrame || s.southwestMesh !== a, s.southwestMesh = a, s.southwestTile = n; return; case un.SOUTHEAST: s.changedThisFrame = s.changedThisFrame || s.southeastMesh !== a, s.southeastMesh = a, s.southeastTile = n; return }if (n.level <= i.level) { s.changedThisFrame = s.changedThisFrame || u[0] !== a || u.length !== 1, u[0] = a, f[0] = n, u.length = 1, f.length = 1; return } let d, p, g, m, A = n.rectangle, C, x = i.rectangle; switch (o) { case un.WEST: for (C = (x.north - x.south) * I.EPSILON5, d = 0; d < f.length && (g = f[d], m = g.rectangle, !I.greaterThan(A.north, m.south, C)); ++d); for (p = d; p < f.length && (g = f[p], m = g.rectangle, !I.greaterThanOrEquals(A.south, m.north, C)); ++p); break; case un.SOUTH: for (C = (x.east - x.west) * I.EPSILON5, d = 0; d < f.length && (g = f[d], m = g.rectangle, !I.lessThan(A.west, m.east, C)); ++d); for (p = d; p < f.length && (g = f[p], m = g.rectangle, !I.lessThanOrEquals(A.east, m.west, C)); ++p); break; case un.EAST: for (C = (x.north - x.south) * I.EPSILON5, d = 0; d < f.length && (g = f[d], m = g.rectangle, !I.lessThan(A.south, m.north, C)); ++d); for (p = d; p < f.length && (g = f[p], m = g.rectangle, !I.lessThanOrEquals(A.north, m.south, C)); ++p); break; case un.NORTH: for (C = (x.east - x.west) * I.EPSILON5, d = 0; d < f.length && (g = f[d], m = g.rectangle, !I.greaterThan(A.east, m.west, C)); ++d); for (p = d; p < f.length && (g = f[p], m = g.rectangle, !I.greaterThanOrEquals(A.west, m.east, C)); ++p); break }p - d === 1 ? (s.changedThisFrame = s.changedThisFrame || u[d] !== a, u[d] = a, f[d] = n) : (s.changedThisFrame = !0, u.splice(d, p - d, a), f.splice(d, p - d, n)) } var iA = new he, Mot = new he, BE = new h, lj = new h, sj = new H, aj = new H, Gl = new H; function Sk() { this.height = 0, this.encodedNormal = new H } function Ak(e, t, n, i, o, r, s, a, c) { if (l(o)) return o; let u; if (l(r) && l(s)) u = (r.height + s.height) * .5; else if (l(r)) u = r.height; else if (l(s)) u = s.height; else if (l(a)) u = a.height; else { let d = e.tile.data.tileBoundingRegion, p = 0, g = 0; l(d) && (p = d.minimumHeight, g = d.maximumHeight), u = (p + g) * .5 } return kpe(e, t, n, i, u, c), c } var Lot = { minimumHeight: 0, maximumHeight: 0 }, Fot = new h, Bpe = new Sk, Rpe = new Sk, Mpe = new Sk, Lpe = new Sk, Not = typeof Uint8Array < "u" ? new Uint8Array(9 * 9) : void 0, Vot = { tilingScheme: void 0, x: 0, y: 0, level: 0, exaggeration: 1, exaggerationRelativeHeight: 0 }; function Vpe(e, t, n, i) { fd.initialize(n, e.terrainProvider, e._imageryLayers); let o = n.data, r = o.fill, s = n.rectangle, a = t.terrainExaggeration, c = t.terrainExaggerationRelativeHeight, u = a !== 1, f = n.tilingScheme.ellipsoid, d = xk(r, f, 0, 1, r.northwestTile, r.northwestMesh, r.northTiles, r.northMeshes, r.westTiles, r.westMeshes, Mpe), p = xk(r, f, 0, 0, r.southwestTile, r.southwestMesh, r.westTiles, r.westMeshes, r.southTiles, r.southMeshes, Bpe), g = xk(r, f, 1, 0, r.southeastTile, r.southeastMesh, r.southTiles, r.southMeshes, r.eastTiles, r.eastMeshes, Rpe), m = xk(r, f, 1, 1, r.northeastTile, r.northeastMesh, r.eastTiles, r.eastMeshes, r.northTiles, r.northMeshes, Lpe); d = Ak(r, f, 0, 1, d, p, m, g, Mpe), p = Ak(r, f, 0, 0, p, d, g, m, Bpe), g = Ak(r, f, 1, 1, g, p, m, d, Rpe), m = Ak(r, f, 1, 1, m, g, d, p, Lpe); let A = p.height, C = g.height, x = d.height, T = m.height, b = Math.min(A, C, x, T), S = Math.max(A, C, x, T), D = (b + S) * .5, P, B, R = e.getLevelMaximumGeometricError(n.level), M = f.maximumRadius - R, L = Math.acos(M / f.maximumRadius) * 4; if (L *= 1.5, s.width > L && S - b <= R) { let w = new Ma({ width: 9, height: 9, buffer: Not, structure: { heightOffset: S } }), v = Vot; v.tilingScheme = n.tilingScheme, v.x = n.x, v.y = n.y, v.level = n.level, v.exaggeration = a, v.exaggerationRelativeHeight = c, r.mesh = w._createMeshSync(v) } else { let w = u, v = ce.center(s, Mot); v.height = D; let O = f.cartographicToCartesian(v, Fot), V = new _c(O, void 0, void 0, void 0, void 0, !0, !0, w, a, c), z = 5, k; for (k = r.westMeshes, P = 0, B = k.length; P < B; ++P)z += k[P].eastIndicesNorthToSouth.length; for (k = r.southMeshes, P = 0, B = k.length; P < B; ++P)z += k[P].northIndicesWestToEast.length; for (k = r.eastMeshes, P = 0, B = k.length; P < B; ++P)z += k[P].westIndicesSouthToNorth.length; for (k = r.northMeshes, P = 0, B = k.length; P < B; ++P)z += k[P].southIndicesEastToWest.length; let G = Lot; G.minimumHeight = b, G.maximumHeight = S; let N = V.stride, X = new Float32Array(z * N), q = 0, J = q; q = Ck(f, s, V, X, q, 0, 1, d.height, d.encodedNormal, 1, G), q = Ek(r, f, V, X, q, r.westTiles, r.westMeshes, un.EAST, G); let W = q; q = Ck(f, s, V, X, q, 0, 0, p.height, p.encodedNormal, 0, G), q = Ek(r, f, V, X, q, r.southTiles, r.southMeshes, un.NORTH, G); let K = q; q = Ck(f, s, V, X, q, 1, 0, g.height, g.encodedNormal, 0, G), q = Ek(r, f, V, X, q, r.eastTiles, r.eastMeshes, un.WEST, G); let Z = q; q = Ck(f, s, V, X, q, 1, 1, m.height, m.encodedNormal, 1, G), q = Ek(r, f, V, X, q, r.northTiles, r.northMeshes, un.SOUTH, G), b = G.minimumHeight, S = G.maximumHeight; let de = di.fromRectangle(s, b, S, n.tilingScheme.ellipsoid), pe = Ri.geodeticLatitudeToMercatorAngle(s.south), oe = 1 / (Ri.geodeticLatitudeToMercatorAngle(s.north) - pe), ue = (Ri.geodeticLatitudeToMercatorAngle(v.latitude) - pe) * oe, ge = f.geodeticSurfaceNormalCartographic(iA, lj), Ee = kn.octEncode(ge, sj), Ie = q; V.encode(X, q * N, de.center, H.fromElements(.5, .5, Gl), D, Ee, ue, ge), ++q; let Fe = q, We = Fe < 256 ? 1 : 2, Lt = (Fe - 1) * 3, Gt = Lt * We, cn = (X.length - Fe * N) * Float32Array.BYTES_PER_ELEMENT, _t; if (cn >= Gt) { let Ce = Fe * N * Float32Array.BYTES_PER_ELEMENT; _t = Fe < 256 ? new Uint8Array(X.buffer, Ce, Lt) : new Uint16Array(X.buffer, Ce, Lt) } else _t = Fe < 256 ? new Uint8Array(Lt) : new Uint16Array(Lt); X = new Float32Array(X.buffer, 0, Fe * N); let Pn = 0; for (P = 0; P < Fe - 2; ++P)_t[Pn++] = Ie, _t[Pn++] = P, _t[Pn++] = P + 1; _t[Pn++] = Ie, _t[Pn++] = P, _t[Pn++] = 0; let Jn = []; for (P = W; P >= J; --P)Jn.push(P); let at = []; for (P = K; P >= W; --P)at.push(P); let Ne = []; for (P = Z; P >= K; --P)Ne.push(P); let nt = []; for (nt.push(0), P = Ie - 1; P >= Z; --P)nt.push(P); r.mesh = new id(V.center, X, _t, Lt, Fe, b, S, re.fromOrientedBoundingBox(de), jot(e, de.center, s, b, S), V.stride, de, V, Jn, at, Ne, nt) } let _ = t.context; r._destroyVertexArray(i), r.vertexArray = fd._createVertexArrayForMesh(_, r.mesh), o.processImagery(n, e.terrainProvider, t, !0); let E = r.waterMaskTexture; if (r.waterMaskTexture = void 0, e.terrainProvider.hasWaterMask) { let w = o._findAncestorTileWithTerrainData(n); l(w) && l(w.data.waterMaskTexture) && (r.waterMaskTexture = w.data.waterMaskTexture, ++r.waterMaskTexture.referenceCount, o._computeWaterMaskTranslationAndScale(n, w, r.waterMaskTranslationAndScale)) } l(E) && (--E.referenceCount, E.referenceCount === 0 && E.destroy()) } function Ck(e, t, n, i, o, r, s, a, c, u, f) { let d = iA; d.longitude = I.lerp(t.west, t.east, r), d.latitude = I.lerp(t.south, t.north, s), d.height = a; let p = e.cartographicToCartesian(d, BE), g; n.hasGeodeticSurfaceNormals && (g = e.geodeticSurfaceNormal(p, lj)); let m = aj; return m.x = r, m.y = s, n.encode(i, o * n.stride, p, m, a, c, u, g), f.minimumHeight = Math.min(f.minimumHeight, a), f.maximumHeight = Math.max(f.maximumHeight, a), o + 1 } var bk = new ce; function lv(e, t, n, i) { let o = e.rectangle, r = t.rectangle; t.x === 0 && n.x === 1 && e.x === e.tilingScheme.getNumberOfXTilesAtLevel(e.level) - 1 ? (o = ce.clone(e.rectangle, bk), o.west -= I.TWO_PI, o.east -= I.TWO_PI) : e.x === 0 && n.x === 0 && t.x === t.tilingScheme.getNumberOfXTilesAtLevel(t.level) - 1 && (o = ce.clone(e.rectangle, bk), o.west += I.TWO_PI, o.east += I.TWO_PI); let s = o.east - o.west, a = (r.west - o.west) / s, c = (r.east - o.west) / s, u = o.north - o.south, f = (r.south - o.south) / u, d = (r.north - o.south) / u, p = (n.x - a) / (c - a), g = (n.y - f) / (d - f); return Math.abs(p) < Math.EPSILON5 ? p = 0 : Math.abs(p - 1) < Math.EPSILON5 && (p = 1), Math.abs(g) < Math.EPSILON5 ? g = 0 : Math.abs(g - 1) < Math.EPSILON5 && (g = 1), i.x = p, i.y = g, i } var kot = new H; function cj(e, t, n, i, o) { let r = e.encoding, s = e.vertices; if (o.height = r.decodeHeight(s, t), r.hasVertexNormals) r.getOctEncodedNormal(s, t, o.encodedNormal); else { let a = o.encodedNormal; a.x = 0, a.y = 0 } } var Uot = new H, zot = new h; function Hot(e, t, n, i, o, r, s, a, c, u) { let f = i.encoding, d = i.vertices, p = lv(t, n, f.decodeTextureCoordinates(d, o, Gl), Gl), g = lv(t, n, f.decodeTextureCoordinates(d, r, aj), aj), m; c ? m = (s - p.x) / (g.x - p.x) : m = (a - p.y) / (g.y - p.y); let A = f.decodeHeight(d, o), C = f.decodeHeight(d, r), x = n.rectangle; iA.longitude = I.lerp(x.west, x.east, s), iA.latitude = I.lerp(x.south, x.north, a), u.height = iA.height = I.lerp(A, C, m); let T; if (f.hasVertexNormals) { let b = f.getOctEncodedNormal(d, o, kot), S = f.getOctEncodedNormal(d, r, Uot), D = kn.octDecode(b.x, b.y, BE), P = kn.octDecode(S.x, S.y, zot); T = h.lerp(D, P, m, BE), h.normalize(T, T), kn.octEncode(T, u.encodedNormal) } else T = e.geodeticSurfaceNormalCartographic(iA, BE), kn.octEncode(T, u.encodedNormal) } function kpe(e, t, n, i, o, r) { r.height = o; let s = t.geodeticSurfaceNormalCartographic(iA, BE); kn.octEncode(s, r.encodedNormal) } function xk(e, t, n, i, o, r, s, a, c, u, f) { if (Npe(e, t, a, s, !1, n, i, f) || Npe(e, t, u, c, !0, n, i, f)) return f; let p; if (uj(o, r)) return n === 0 ? i === 0 ? p = r.eastIndicesNorthToSouth[0] : p = r.southIndicesEastToWest[0] : i === 0 ? p = r.northIndicesWestToEast[0] : p = r.westIndicesSouthToNorth[0], cj(r, p, n, i, f), f; let g; if (n === 0 ? i === 0 ? g = Tk(e.westMeshes, e.westTiles, un.EAST, e.southMeshes, e.southTiles, un.NORTH, n, i) : g = Tk(e.northMeshes, e.northTiles, un.SOUTH, e.westMeshes, e.westTiles, un.EAST, n, i) : i === 0 ? g = Tk(e.southMeshes, e.southTiles, un.NORTH, e.eastMeshes, e.eastTiles, un.WEST, n, i) : g = Tk(e.eastMeshes, e.eastTiles, un.WEST, e.northMeshes, e.northTiles, un.SOUTH, n, i), l(g)) return kpe(e, t, n, i, g, f), f } function Tk(e, t, n, i, o, r, s, a) { let c = Fpe(e, t, !1, n, s, a), u = Fpe(i, o, !0, r, s, a); return l(c) && l(u) ? (c + u) * .5 : l(c) ? c : u } function Ek(e, t, n, i, o, r, s, a, c) { for (let u = 0; u < r.length; ++u)o = Got(e, t, n, i, o, r[u], s[u], a, c); return o } function Got(e, t, n, i, o, r, s, a, c) { let u = r.rectangle; a === un.EAST && e.tile.x === 0 ? (u = ce.clone(r.rectangle, bk), u.west -= I.TWO_PI, u.east -= I.TWO_PI) : a === un.WEST && r.x === 0 && (u = ce.clone(r.rectangle, bk), u.west += I.TWO_PI, u.east += I.TWO_PI); let f = e.tile.rectangle, d, p; o > 0 && (n.decodeTextureCoordinates(i, o - 1, Gl), d = Gl.x, p = Gl.y); let g, m; switch (a) { case un.WEST: g = s.westIndicesSouthToNorth, m = !1; break; case un.NORTH: g = s.northIndicesWestToEast, m = !0; break; case un.EAST: g = s.eastIndicesNorthToSouth, m = !1; break; case un.SOUTH: g = s.southIndicesEastToWest, m = !0; break }let A = r, C = e.tile, x = s.encoding, T = s.vertices, b = n.stride, S, D; x.hasWebMercatorT && (S = Ri.geodeticLatitudeToMercatorAngle(f.south), D = 1 / (Ri.geodeticLatitudeToMercatorAngle(f.north) - S)); for (let P = 0; P < g.length; ++P) { let B = g[P], R = x.decodeTextureCoordinates(T, B, Gl); lv(A, C, R, R); let M = R.x, L = R.y, _ = m ? M : L; if (_ < 0 || _ > 1 || Math.abs(M - d) < I.EPSILON5 && Math.abs(L - p) < I.EPSILON5) continue; let E = Math.abs(M) < I.EPSILON5 || Math.abs(M - 1) < I.EPSILON5, w = Math.abs(L) < I.EPSILON5 || Math.abs(L - 1) < I.EPSILON5; if (E && w) continue; let v = x.decodePosition(T, B, BE), O = x.decodeHeight(T, B), V; x.hasVertexNormals ? V = x.getOctEncodedNormal(T, B, sj) : (V = sj, V.x = 0, V.y = 0); let z = L; if (x.hasWebMercatorT) { let G = I.lerp(f.south, f.north, L); z = (Ri.geodeticLatitudeToMercatorAngle(G) - S) * D } let k; n.hasGeodeticSurfaceNormals && (k = t.geodeticSurfaceNormal(v, lj)), n.encode(i, o * b, v, R, O, V, z, k), c.minimumHeight = Math.min(c.minimumHeight, O), c.maximumHeight = Math.max(c.maximumHeight, O), ++o } return o } function Fpe(e, t, n, i, o, r) { let s, a, c; n ? (s = 0, a = e.length, c = 1) : (s = e.length - 1, a = -1, c = -1); for (let u = s; u !== a; u += c) { let f = e[u], d = t[u]; if (!uj(d, f)) continue; let p; switch (i) { case un.WEST: p = f.westIndicesSouthToNorth; break; case un.SOUTH: p = f.southIndicesEastToWest; break; case un.EAST: p = f.eastIndicesNorthToSouth; break; case un.NORTH: p = f.northIndicesWestToEast; break }let g = p[n ? 0 : p.length - 1]; if (l(g)) return f.encoding.decodeHeight(f.vertices, g) } } function uj(e, t) { return l(t) && (!l(e.data.fill) || !e.data.fill.changedThisFrame) } function Npe(e, t, n, i, o, r, s, a) { let c, u, f, d, p, g = i[o ? 0 : n.length - 1], m = n[o ? 0 : n.length - 1]; if (uj(g, m) && (r === 0 ? s === 0 ? (c = o ? m.northIndicesWestToEast : m.eastIndicesNorthToSouth, u = o, f = o) : (c = o ? m.eastIndicesNorthToSouth : m.southIndicesEastToWest, u = !o, f = !1) : s === 0 ? (c = o ? m.westIndicesSouthToNorth : m.northIndicesWestToEast, u = !o, f = !0) : (c = o ? m.southIndicesEastToWest : m.westIndicesSouthToNorth, u = o, f = !o), c.length > 0)) { d = o ? 0 : c.length - 1, p = c[d], m.encoding.decodeTextureCoordinates(m.vertices, p, Gl); let A = lv(g, e.tile, Gl, Gl); if (A.x === r && A.y === s) return cj(m, p, r, s, a), !0; if (d = Wo(c, u ? r : s, function (C, x) { m.encoding.decodeTextureCoordinates(m.vertices, C, Gl); let T = lv(g, e.tile, Gl, Gl); return f ? u ? T.x - r : T.y - s : u ? r - T.x : s - T.y }), d < 0) { if (d = ~d, d > 0 && d < c.length) return Hot(t, g, e.tile, m, c[d - 1], c[d], r, s, u, a), !0 } else return cj(m, c[d], r, s, a), !0 } return !1 } var Wot = [new h, new h, new h, new h]; function jot(e, t, n, i, o, r) { let s = e.quadtree._occluders.ellipsoid, a = s.ellipsoid, c = Wot; return h.fromRadians(n.west, n.south, o, a, c[0]), h.fromRadians(n.east, n.south, o, a, c[1]), h.fromRadians(n.west, n.north, o, a, c[2]), h.fromRadians(n.east, n.north, o, a, c[3]), s.computeHorizonCullingPointPossiblyUnderEllipsoid(t, c, i, r) } var uv = RE; function Go(e) { this.lightingFadeOutDistance = 65e5, this.lightingFadeInDistance = 9e6, this.hasWaterMask = !1, this.oceanNormalMap = void 0, this.zoomedOutOceanSpecularIntensity = .5, this.enableLighting = !1, this.dynamicAtmosphereLighting = !1, this.dynamicAtmosphereLightingFromSun = !1, this.showGroundAtmosphere = !1, this.shadows = hn.RECEIVE_ONLY, this.fillHighlightColor = void 0, this.hueShift = 0, this.saturationShift = 0, this.brightnessShift = 0, this.showSkirts = !0, this.backFaceCulling = !0, this.undergroundColor = void 0, this.undergroundColorAlphaByDistance = void 0, this.lambertDiffuseMultiplier = 0, this.materialUniformMap = void 0, this._materialUniformMap = void 0, this._quadtree = void 0, this._terrainProvider = e.terrainProvider, this._imageryLayers = e.imageryLayers, this._surfaceShaderSet = e.surfaceShaderSet, this._renderState = void 0, this._blendRenderState = void 0, this._disableCullingRenderState = void 0, this._disableCullingBlendRenderState = void 0, this._errorEvent = new _e, this._imageryLayers.layerAdded.addEventListener(Go.prototype._onLayerAdded, this), this._imageryLayers.layerRemoved.addEventListener(Go.prototype._onLayerRemoved, this), this._imageryLayers.layerMoved.addEventListener(Go.prototype._onLayerMoved, this), this._imageryLayers.layerShownOrHidden.addEventListener(Go.prototype._onLayerShownOrHidden, this), this._imageryLayersUpdatedEvent = new _e, this._layerOrderChanged = !1, this._tilesToRenderByTextureCount = [], this._drawCommands = [], this._uniformMaps = [], this._usedDrawCommands = 0, this._vertexArraysToDestroy = [], this._debug = { wireframe: !1, boundingSphereTile: void 0 }, this._baseColor = void 0, this._firstPassInitialColor = void 0, this.baseColor = new U(0, 0, .5, 1), this._clippingPlanes = void 0, this.cartographicLimitRectangle = ce.clone(ce.MAX_VALUE), this._hasLoadedTilesThisFrame = !1, this._hasFillTilesThisFrame = !1, this._oldTerrainExaggeration = void 0, this._oldTerrainExaggerationRelativeHeight = void 0 } Object.defineProperties(Go.prototype, { baseColor: { get: function () { return this._baseColor }, set: function (e) { this._baseColor = e, this._firstPassInitialColor = se.fromColor(e, this._firstPassInitialColor) } }, quadtree: { get: function () { return this._quadtree }, set: function (e) { this._quadtree = e } }, ready: { get: function () { return this._terrainProvider.ready && (this._imageryLayers.length === 0 || this._imageryLayers.get(0).imageryProvider.ready) } }, tilingScheme: { get: function () { return this._terrainProvider.tilingScheme } }, errorEvent: { get: function () { return this._errorEvent } }, imageryLayersUpdatedEvent: { get: function () { return this._imageryLayersUpdatedEvent } }, terrainProvider: { get: function () { return this._terrainProvider }, set: function (e) { this._terrainProvider !== e && (this._terrainProvider = e, l(this._quadtree) && this._quadtree.invalidateAllTiles()) } }, clippingPlanes: { get: function () { return this._clippingPlanes }, set: function (e) { Ks.setOwner(e, this, "_clippingPlanes") } } }); function qot(e, t) { let n = e.loadingImagery; l(n) || (n = e.readyImagery); let i = t.loadingImagery; return l(i) || (i = t.readyImagery), n.imageryLayer._layerIndex - i.imageryLayer._layerIndex } Go.prototype.update = function (e) { this._imageryLayers._update() }; function Yot(e, t) { let n = t.creditDisplay; e._terrainProvider.ready && l(e._terrainProvider.credit) && n.addCredit(e._terrainProvider.credit); let i = e._imageryLayers; for (let o = 0, r = i.length; o < r; ++o) { let s = i.get(o).imageryProvider; s.ready && l(s.credit) && n.addCredit(s.credit) } } Go.prototype.initialize = function (e) { this._imageryLayers.queueReprojectionCommands(e), this._layerOrderChanged && (this._layerOrderChanged = !1, this._quadtree.forEachLoadedTile(function (i) { i.data.imagery.sort(qot) })), Yot(this, e); let t = this._vertexArraysToDestroy, n = t.length; for (let i = 0; i < n; ++i)fd._freeVertexArray(t[i]); t.length = 0 }; Go.prototype.beginUpdate = function (e) { let t = this._tilesToRenderByTextureCount; for (let i = 0, o = t.length; i < o; ++i) { let r = t[i]; l(r) && (r.length = 0) } let n = this._clippingPlanes; l(n) && n.enabled && n.update(e), this._usedDrawCommands = 0, this._hasLoadedTilesThisFrame = !1, this._hasFillTilesThisFrame = !1 }; Go.prototype.endUpdate = function (e) { if (!l(this._renderState)) { this._renderState = Ve.fromCache({ cull: { enabled: !0 }, depthTest: { enabled: !0, func: Ja.LESS } }), this._blendRenderState = Ve.fromCache({ cull: { enabled: !0 }, depthTest: { enabled: !0, func: Ja.LESS_OR_EQUAL }, blending: an.ALPHA_BLEND }); let s = tt(this._renderState, !0); s.cull.enabled = !1, this._disableCullingRenderState = Ve.fromCache(s), s = tt(this._blendRenderState, !0), s.cull.enabled = !1, this._disableCullingBlendRenderState = Ve.fromCache(s) } this._hasFillTilesThisFrame && this._hasLoadedTilesThisFrame && uv.updateFillTiles(this, this._quadtree._tilesToRender, e, this._vertexArraysToDestroy); let t = this.quadtree, n = e.terrainExaggeration, i = e.terrainExaggerationRelativeHeight, o = this._oldTerrainExaggeration !== n || this._oldTerrainExaggerationRelativeHeight !== i; this._oldTerrainExaggeration = n, this._oldTerrainExaggerationRelativeHeight = i, o && t.forEachLoadedTile(function (s) { s.data.updateExaggeration(s, e, t) }); let r = this._tilesToRenderByTextureCount; for (let s = 0, a = r.length; s < a; ++s) { let c = r[s]; if (!!l(c)) for (let u = 0, f = c.length; u < f; ++u) { let d = c[u], p = d.data.tileBoundingRegion; grt(this, d, e), e.minimumTerrainHeight = Math.min(e.minimumTerrainHeight, p.minimumHeight) } } }; function Wpe(e, t) { let n = t.globeTranslucencyState; if (n.translucent) { let i = e.renderState.blending.enabled; n.pushDerivedCommands(e, i, t) } else t.commandList.push(e) } Go.prototype.updateForPick = function (e) { let t = this._drawCommands; for (let n = 0, i = this._usedDrawCommands; n < i; ++n)Wpe(t[n], e) }; Go.prototype.cancelReprojections = function () { this._imageryLayers.cancelReprojections() }; Go.prototype.getLevelMaximumGeometricError = function (e) { return this._terrainProvider.getLevelMaximumGeometricError(e) }; Go.prototype.loadTile = function (e, t) { let n = t.data, i = !0, o; l(n) && (i = n.boundingVolumeSourceTile !== t || t._lastSelectionResult === qn.CULLED_BUT_NEEDED, o = n.terrainState), fd.processStateMachine(t, e, this.terrainProvider, this._imageryLayers, this.quadtree, this._vertexArraysToDestroy, i), n = t.data, i && o !== t.data.terrainState && this.computeTileVisibility(t, e, this.quadtree.occluders) !== lr.NONE && n.boundingVolumeSourceTile === t && (i = !1, fd.processStateMachine(t, e, this.terrainProvider, this._imageryLayers, this.quadtree, this._vertexArraysToDestroy, i)) }; var Xot = new re, jpe = new ce, Kot = new ce, Jot = new he; function Dk(e, t) { if (t.west < t.east) return t; let n = ce.clone(t, Kot); return ce.center(e, Jot).longitude > 0 ? n.east = I.PI : n.west = -I.PI, n } function qpe(e, t) { if (t.cameraUnderground || t.globeTranslucencyState.translucent) return !0; if (e.backFaceCulling) return !1; let n = e._clippingPlanes; return !!(l(n) && n.enabled || !ce.equals(e.cartographicLimitRectangle, ce.MAX_VALUE)) } Go.prototype.computeTileVisibility = function (e, t, n) { let i = this.computeDistanceToTile(e, t); e._distance = i; let o = qpe(this, t); if (t.fog.enabled && !o && I.fog(i, t.fog.density) >= 1) return lr.NONE; let r = e.data, s = r.tileBoundingRegion; if (r.boundingVolumeSourceTile === void 0) return lr.PARTIAL; let a = t.cullingVolume, c = s.boundingVolume; l(c) || (c = s.boundingSphere), r.clippedByBoundaries = !1; let u = Dk(e.rectangle, this.cartographicLimitRectangle), f = ce.simpleIntersection(u, e.rectangle, jpe); if (!l(f)) return lr.NONE; if (ce.equals(f, e.rectangle) || (r.clippedByBoundaries = !0), t.mode !== ee.SCENE3D && (c = Xot, re.fromRectangleWithHeights2D(e.rectangle, t.mapProjection, s.minimumHeight, s.maximumHeight, c), h.fromElements(c.center.z, c.center.x, c.center.y, c.center), t.mode === ee.MORPHING && l(r.renderedMesh) && (c = re.union(s.boundingSphere, c, c))), !l(c)) return lr.PARTIAL; let d = this._clippingPlanes; if (l(d) && d.enabled) { let A = d.computeIntersectionWithBoundingVolume(c); if (e.isClipped = A !== Kt.INSIDE, A === Kt.OUTSIDE) return lr.NONE } let p, g = a.computeVisibility(c); if (g === Kt.OUTSIDE ? p = lr.NONE : g === Kt.INTERSECTING ? p = lr.PARTIAL : g === Kt.INSIDE && (p = lr.FULL), p === lr.NONE) return p; let m = t.mode === ee.SCENE3D && t.camera.frustum instanceof Zt; if (t.mode === ee.SCENE3D && !m && l(n) && !o) { let A = r.occludeePointInScaledSpace; return !l(A) || n.ellipsoid.isScaledSpacePointVisiblePossiblyUnderEllipsoid(A, s.minimumHeight) ? p : lr.NONE } return p }; Go.prototype.canRefine = function (e) { return l(e.data.terrainData) ? !0 : this.terrainProvider.getTileDataAvailable(e.x * 2, e.y * 2, e.level + 1) !== void 0 }; var Zot = [], Qot = []; Go.prototype.canRenderWithoutLosingDetail = function (e, t) { let n = e.data, i = Zot; i.length = this._imageryLayers.length; let o = !1, r = !1, s; l(n) && (o = n.terrainState === fo.READY, r = !0, s = n.imagery); let a, c; for (a = 0, c = i.length; a < c; ++a)i[a] = r; if (l(s)) for (a = 0, c = s.length; a < c; ++a) { let d = s[a], p = d.loadingImagery, g = !l(p) || p.state === ii.FAILED || p.state === ii.INVALID, m = (d.loadingImagery || d.readyImagery).imageryLayer._layerIndex; i[m] = g && i[m] } let u = this.quadtree._lastSelectionFrameNumber, f = Qot; for (f.length = 0, f.push(e.southwestChild, e.southeastChild, e.northwestChild, e.northeastChild); f.length > 0;) { let d = f.pop(), p = d._lastSelectionResultFrame === u ? d._lastSelectionResult : qn.NONE; if (p === qn.RENDERED) { let g = d.data; if (!l(g)) continue; if (!o && d.data.terrainState === fo.READY) return !1; let m = d.data.imagery; for (a = 0, c = m.length; a < c; ++a) { let A = m[a], C = A.loadingImagery, x = !l(C) || C.state === ii.FAILED || C.state === ii.INVALID, T = (A.loadingImagery || A.readyImagery).imageryLayer._layerIndex; if (x && !i[T]) return !1 } } else p === qn.REFINED && f.push(d.southwestChild, d.southeastChild, d.northwestChild, d.northeastChild) } return !0 }; var $ot = new h; Go.prototype.computeTileLoadPriority = function (e, t) { let n = e.data; if (n === void 0) return 0; let i = n.tileBoundingRegion.boundingVolume; if (i === void 0) return 0; let o = t.camera.positionWC, r = t.camera.directionWC, s = h.subtract(i.center, o, $ot), a = h.magnitude(s); return a < I.EPSILON5 ? 0 : (h.divideByScalar(s, a, s), (1 - h.dot(s, r)) * e._distance) }; var Upe = new F, wk = new F, ert = new se, trt = new se, nrt = new se, irt = new h, zpe = new h, ort = new h, rrt = new h; Go.prototype.showTileThisFrame = function (e, t) { let n = 0, i = e.data.imagery; for (let a = 0, c = i.length; a < c; ++a) { let u = i[a]; l(u.readyImagery) && u.readyImagery.imageryLayer.alpha !== 0 && ++n } let o = this._tilesToRenderByTextureCount[n]; l(o) || (o = [], this._tilesToRenderByTextureCount[n] = o), o.push(e); let r = e.data; l(r.vertexArray) ? this._hasLoadedTilesThisFrame = !0 : this._hasFillTilesThisFrame = !0; let s = this._debug; ++s.tilesRendered, s.texturesRendered += n }; var srt = [new h, new h, new h, new h]; function Hpe(e, t, n, i, o, r) { let s = e.quadtree._occluders.ellipsoid, a = s.ellipsoid, c = srt; return h.fromRadians(n.west, n.south, o, a, c[0]), h.fromRadians(n.east, n.south, o, a, c[1]), h.fromRadians(n.west, n.north, o, a, c[2]), h.fromRadians(n.east, n.north, o, a, c[3]), s.computeHorizonCullingPointPossiblyUnderEllipsoid(t, c, i, r) } Go.prototype.computeDistanceToTile = function (e, t) { art(e, this, t); let n = e.data; if (n.boundingVolumeSourceTile === void 0) return 9999999999; let o = n.tileBoundingRegion, r = o.minimumHeight, s = o.maximumHeight; if (n.boundingVolumeSourceTile !== e) { let c = t.camera.positionCartographic.height, u = Math.abs(c - r), f = Math.abs(c - s); u > f ? (o.minimumHeight = r, o.maximumHeight = r) : (o.minimumHeight = s, o.maximumHeight = s) } let a = o.distanceToCamera(t); return o.minimumHeight = r, o.maximumHeight = s, a }; function art(e, t, n) { let i = e.data; i === void 0 && (i = e.data = new fd); let o = e.tilingScheme.ellipsoid; i.tileBoundingRegion === void 0 && (i.tileBoundingRegion = new Bf({ computeBoundingVolumes: !1, rectangle: e.rectangle, ellipsoid: o, minimumHeight: 0, maximumHeight: 0 })); let r = i.tileBoundingRegion, s = r.minimumHeight, a = r.maximumHeight, c = !1, u = e, f = i.mesh, d = i.terrainData; if (f !== void 0 && f.minimumHeight !== void 0 && f.maximumHeight !== void 0) r.minimumHeight = f.minimumHeight, r.maximumHeight = f.maximumHeight, c = !0; else if (d !== void 0 && d._minimumHeight !== void 0 && d._maximumHeight !== void 0) r.minimumHeight = d._minimumHeight, r.maximumHeight = d._maximumHeight; else { r.minimumHeight = Number.NaN, r.maximumHeight = Number.NaN; let p = e.parent; for (; p !== void 0;) { let g = p.data; if (g !== void 0) { let m = g.mesh, A = g.terrainData; if (m !== void 0 && m.minimumHeight !== void 0 && m.maximumHeight !== void 0) { r.minimumHeight = m.minimumHeight, r.maximumHeight = m.maximumHeight; break } else if (A !== void 0 && A._minimumHeight !== void 0 && A._maximumHeight !== void 0) { r.minimumHeight = A._minimumHeight, r.maximumHeight = A._maximumHeight; break } } p = p.parent } u = p } if (u !== void 0) { let p = n.terrainExaggeration, g = n.terrainExaggerationRelativeHeight; if (p !== 1 && (c = !1, r.minimumHeight = Ic.getHeight(r.minimumHeight, p, g), r.maximumHeight = Ic.getHeight(r.maximumHeight, p, g)), c) i.boundingVolumeIsFromMesh || (r._orientedBoundingBox = di.clone(f.orientedBoundingBox, r._orientedBoundingBox), r._boundingSphere = re.clone(f.boundingSphere3D, r._boundingSphere), i.occludeePointInScaledSpace = h.clone(f.occludeePointInScaledSpace, i.occludeePointInScaledSpace), l(i.occludeePointInScaledSpace) || (i.occludeePointInScaledSpace = Hpe(t, r._orientedBoundingBox.center, e.rectangle, r.minimumHeight, r.maximumHeight, i.occludeePointInScaledSpace))); else { let A = r._orientedBoundingBox === void 0 || r._boundingSphere === void 0; (r.minimumHeight !== s || r.maximumHeight !== a || A) && (r.computeBoundingVolumes(o), i.occludeePointInScaledSpace = Hpe(t, r._orientedBoundingBox.center, e.rectangle, r.minimumHeight, r.maximumHeight, i.occludeePointInScaledSpace)) } i.boundingVolumeSourceTile = u, i.boundingVolumeIsFromMesh = c } else i.boundingVolumeSourceTile = void 0, i.boundingVolumeIsFromMesh = !1 } Go.prototype.isDestroyed = function () { return !1 }; Go.prototype.destroy = function () { return this._tileProvider = this._tileProvider && this._tileProvider.destroy(), this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy(), le(this) }; function crt(e, t, n) { return function (i) { let o, r, s = -1, a = i.data.imagery, c = a.length, u; for (u = 0; u < c; ++u)if (o = a[u], r = y(o.readyImagery, o.loadingImagery), r.imageryLayer === t) { s = u; break } if (s !== -1) { let f = s + e; if (o = a[f], r = l(o) ? y(o.readyImagery, o.loadingImagery) : void 0, !l(r) || r.imageryLayer !== t) return !t._createTileImagerySkeletons(i, n, f); for (u = s; u < f; ++u)a[u].freeResources(); a.splice(s, e) } return !0 } } Go.prototype._onLayerAdded = function (e, t) { if (e.show) { let n = this._terrainProvider, i = this, o = e.imageryProvider, r = this._imageryLayersUpdatedEvent; o._reload = function () { e._imageryCache = {}, i._quadtree.forEachLoadedTile(function (s) { if (l(s._loadedCallbacks[e._layerIndex])) return; let a, c = s.data.imagery, u = c.length, f = -1, d = 0; for (a = 0; a < u; ++a) { let g = c[a]; if (y(g.readyImagery, g.loadingImagery).imageryLayer === e) f === -1 && (f = a), ++d; else if (f !== -1) break } if (f === -1) return; let p = f + d; e._createTileImagerySkeletons(s, n, p) && (s._loadedCallbacks[e._layerIndex] = crt(d, e, n), s.state = ks.LOADING) }) }, this._quadtree.forEachLoadedTile(function (s) { e._createTileImagerySkeletons(s, n) && (s.state = ks.LOADING, s.level !== 0 && (s._lastSelectionResultFrame !== i.quadtree._lastSelectionFrameNumber || s._lastSelectionResult !== qn.RENDERED) && (s.renderable = !1)) }), this._layerOrderChanged = !0, r.raiseEvent() } }; Go.prototype._onLayerRemoved = function (e, t) { this._quadtree.forEachLoadedTile(function (n) { let i = n.data.imagery, o = -1, r = 0; for (let s = 0, a = i.length; s < a; ++s) { let c = i[s], u = c.loadingImagery; if (l(u) || (u = c.readyImagery), u.imageryLayer === e) o === -1 && (o = s), c.freeResources(), ++r; else if (o !== -1) break } o !== -1 && i.splice(o, r) }), l(e.imageryProvider) && (e.imageryProvider._reload = void 0), this._imageryLayersUpdatedEvent.raiseEvent() }; Go.prototype._onLayerMoved = function (e, t, n) { this._layerOrderChanged = !0, this._imageryLayersUpdatedEvent.raiseEvent() }; Go.prototype._onLayerShownOrHidden = function (e, t, n) { n ? this._onLayerAdded(e, t) : this._onLayerRemoved(e, t) }; var lrt = new F, urt = new F; function Gpe(e, t) { let n = { u_initialColor: function () { return this.properties.initialColor }, u_fillHighlightColor: function () { return this.properties.fillHighlightColor }, u_zoomedOutOceanSpecularIntensity: function () { return this.properties.zoomedOutOceanSpecularIntensity }, u_oceanNormalMap: function () { return this.properties.oceanNormalMap }, u_atmosphereLightIntensity: function () { return this.properties.atmosphereLightIntensity }, u_atmosphereRayleighCoefficient: function () { return this.properties.atmosphereRayleighCoefficient }, u_atmosphereMieCoefficient: function () { return this.properties.atmosphereMieCoefficient }, u_atmosphereRayleighScaleHeight: function () { return this.properties.atmosphereRayleighScaleHeight }, u_atmosphereMieScaleHeight: function () { return this.properties.atmosphereMieScaleHeight }, u_atmosphereMieAnisotropy: function () { return this.properties.atmosphereMieAnisotropy }, u_lightingFadeDistance: function () { return this.properties.lightingFadeDistance }, u_nightFadeDistance: function () { return this.properties.nightFadeDistance }, u_center3D: function () { return this.properties.center3D }, u_terrainExaggerationAndRelativeHeight: function () { return this.properties.terrainExaggerationAndRelativeHeight }, u_tileRectangle: function () { return this.properties.tileRectangle }, u_modifiedModelView: function () { let i = e.context.uniformState.view, o = F.multiplyByPoint(i, this.properties.rtc, zpe); return F.setTranslation(i, o, Upe), Upe }, u_modifiedModelViewProjection: function () { let i = e.context.uniformState.view, o = e.context.uniformState.projection, r = F.multiplyByPoint(i, this.properties.rtc, zpe); return F.setTranslation(i, r, wk), F.multiply(o, wk, wk), wk }, u_dayTextures: function () { return this.properties.dayTextures }, u_dayTextureTranslationAndScale: function () { return this.properties.dayTextureTranslationAndScale }, u_dayTextureTexCoordsRectangle: function () { return this.properties.dayTextureTexCoordsRectangle }, u_dayTextureUseWebMercatorT: function () { return this.properties.dayTextureUseWebMercatorT }, u_dayTextureAlpha: function () { return this.properties.dayTextureAlpha }, u_dayTextureNightAlpha: function () { return this.properties.dayTextureNightAlpha }, u_dayTextureDayAlpha: function () { return this.properties.dayTextureDayAlpha }, u_dayTextureBrightness: function () { return this.properties.dayTextureBrightness }, u_dayTextureContrast: function () { return this.properties.dayTextureContrast }, u_dayTextureHue: function () { return this.properties.dayTextureHue }, u_dayTextureSaturation: function () { return this.properties.dayTextureSaturation }, u_dayTextureOneOverGamma: function () { return this.properties.dayTextureOneOverGamma }, u_dayIntensity: function () { return this.properties.dayIntensity }, u_southAndNorthLatitude: function () { return this.properties.southAndNorthLatitude }, u_southMercatorYAndOneOverHeight: function () { return this.properties.southMercatorYAndOneOverHeight }, u_waterMask: function () { return this.properties.waterMask }, u_waterMaskTranslationAndScale: function () { return this.properties.waterMaskTranslationAndScale }, u_minMaxHeight: function () { return this.properties.minMaxHeight }, u_scaleAndBias: function () { return this.properties.scaleAndBias }, u_dayTextureSplit: function () { return this.properties.dayTextureSplit }, u_dayTextureCutoutRectangles: function () { return this.properties.dayTextureCutoutRectangles }, u_clippingPlanes: function () { let i = t._clippingPlanes; return l(i) && l(i.texture) ? i.texture : e.context.defaultTexture }, u_cartographicLimitRectangle: function () { return this.properties.localizedCartographicLimitRectangle }, u_clippingPlanesMatrix: function () { let i = t._clippingPlanes, o = l(i) ? F.multiply(e.context.uniformState.view, i.modelMatrix, lrt) : F.IDENTITY; return F.inverseTranspose(o, urt) }, u_clippingPlanesEdgeStyle: function () { let i = this.properties.clippingPlanesEdgeColor; return i.alpha = this.properties.clippingPlanesEdgeWidth, i }, u_minimumBrightness: function () { return e.fog.minimumBrightness }, u_hsbShift: function () { return this.properties.hsbShift }, u_colorsToAlpha: function () { return this.properties.colorsToAlpha }, u_frontFaceAlphaByDistance: function () { return this.properties.frontFaceAlphaByDistance }, u_backFaceAlphaByDistance: function () { return this.properties.backFaceAlphaByDistance }, u_translucencyRectangle: function () { return this.properties.localizedTranslucencyRectangle }, u_undergroundColor: function () { return this.properties.undergroundColor }, u_undergroundColorAlphaByDistance: function () { return this.properties.undergroundColorAlphaByDistance }, u_lambertDiffuseMultiplier: function () { return this.properties.lambertDiffuseMultiplier }, properties: { initialColor: new se(0, 0, .5, 1), fillHighlightColor: new U(0, 0, 0, 0), zoomedOutOceanSpecularIntensity: .5, oceanNormalMap: void 0, lightingFadeDistance: new H(65e5, 9e6), nightFadeDistance: new H(1e7, 4e7), atmosphereLightIntensity: 10, atmosphereRayleighCoefficient: new h(55e-7, 13e-6, 284e-7), atmosphereMieCoefficient: new h(21e-6, 21e-6, 21e-6), atmosphereRayleighScaleHeight: 1e4, atmosphereMieScaleHeight: 3200, atmosphereMieAnisotropy: .9, hsbShift: new h, center3D: void 0, rtc: new h, modifiedModelView: new F, tileRectangle: new se, terrainExaggerationAndRelativeHeight: new H(1, 0), dayTextures: [], dayTextureTranslationAndScale: [], dayTextureTexCoordsRectangle: [], dayTextureUseWebMercatorT: [], dayTextureAlpha: [], dayTextureNightAlpha: [], dayTextureDayAlpha: [], dayTextureBrightness: [], dayTextureContrast: [], dayTextureHue: [], dayTextureSaturation: [], dayTextureOneOverGamma: [], dayTextureSplit: [], dayTextureCutoutRectangles: [], dayIntensity: 0, colorsToAlpha: [], southAndNorthLatitude: new H, southMercatorYAndOneOverHeight: new H, waterMask: void 0, waterMaskTranslationAndScale: new se, minMaxHeight: new H, scaleAndBias: new F, clippingPlanesEdgeColor: U.clone(U.WHITE), clippingPlanesEdgeWidth: 0, localizedCartographicLimitRectangle: new se, frontFaceAlphaByDistance: new se, backFaceAlphaByDistance: new se, localizedTranslucencyRectangle: new se, undergroundColor: U.clone(U.TRANSPARENT), undergroundColorAlphaByDistance: new se, lambertDiffuseMultiplier: 0 } }; return l(t.materialUniformMap) ? yt(n, t.materialUniformMap) : n } function frt(e, t, n) { let i = n.data, o, r; if (l(i.vertexArray) ? (o = i.mesh, r = i.vertexArray) : l(i.fill) && l(i.fill.vertexArray) && (o = i.fill.mesh, r = i.fill.vertexArray), !(!l(o) || !l(r))) { if (l(i.wireframeVertexArray)) { if (i.wireframeVertexArray.mesh === o) return; i.wireframeVertexArray.destroy(), i.wireframeVertexArray = void 0 } i.wireframeVertexArray = drt(e, r, o), i.wireframeVertexArray.mesh = o } } function drt(e, t, n) { let o = { indices: n.indices, primitiveType: Oe.TRIANGLES }; Bn.toWireframe(o); let r = o.indices, s = ct.createIndexBuffer({ context: e, typedArray: r, usage: Re.STATIC_DRAW, indexDatatype: Me.fromSizeInBytes(r.BYTES_PER_ELEMENT) }); return new Qn({ context: e, attributes: t._attributes, indexBuffer: s }) } var Ype, Xpe, vk; (function () { let e = new At({ geometry: bd.fromDimensions({ dimensions: new h(2, 2, 2) }) }), t = new At({ geometry: new L_({ radius: 1 }) }), n = new F, i, o; function r(s) { return new xn({ geometryInstances: s, appearance: new $t({ translucent: !1, flat: !0 }), asynchronous: !1 }) } Ype = function (s, a) { return s === i || (vk(), i = s, n = F.fromRotationTranslation(s.halfAxes, s.center, n), e.modelMatrix = n, e.attributes.color = Bt.fromColor(a), o = r(e)), o }, Xpe = function (s, a) { return s === i || (vk(), i = s, n = F.fromTranslation(s.center, n), n = F.multiplyByUniformScale(n, s.radius, n), t.modelMatrix = n, t.attributes.color = Bt.fromColor(a), o = r(t)), o }, vk = function () { l(o) && (o.destroy(), o = void 0, i = void 0) } })(); var hrt = new se(0, 0, 0, 0), mrt = { frameState: void 0, surfaceTile: void 0, numberOfDayTextures: void 0, applyBrightness: void 0, applyContrast: void 0, applyHue: void 0, applySaturation: void 0, applyGamma: void 0, applyAlpha: void 0, applyDayNightAlpha: void 0, applySplit: void 0, showReflectiveOcean: void 0, showOceanWaves: void 0, enableLighting: void 0, dynamicAtmosphereLighting: void 0, dynamicAtmosphereLightingFromSun: void 0, showGroundAtmosphere: void 0, perFragmentGroundAtmosphere: void 0, hasVertexNormals: void 0, useWebMercatorProjection: void 0, enableFog: void 0, enableClippingPlanes: void 0, clippingPlanes: void 0, clippedByBoundaries: void 0, hasImageryLayerCutout: void 0, colorCorrect: void 0, colorToAlpha: void 0, hasGeodeticSurfaceNormals: void 0, hasExaggeration: void 0 }, prt = U.TRANSPARENT, _rt = new wt; function grt(e, t, n) { let i = t.data; l(i.vertexArray) || (i.fill === void 0 && (i.fill = new uv(t)), i.fill.update(e, n)); let o = n.creditDisplay, r = i.terrainData; if (l(r) && l(r.credits)) { let at = r.credits; for (let Ne = 0, nt = at.length; Ne < nt; ++Ne)o.addCredit(at[Ne]) } let s = Ut.maximumTextureImageUnits, a = i.waterMaskTexture, c = i.waterMaskTranslationAndScale; !l(a) && l(i.fill) && (a = i.fill.waterMaskTexture, c = i.fill.waterMaskTranslationAndScale); let u = n.cameraUnderground, f = n.globeTranslucencyState, d = f.translucent, p = f.frontFaceAlphaByDistance, g = f.backFaceAlphaByDistance, m = f.rectangle, A = y(e.undergroundColor, prt), C = y(e.undergroundColorAlphaByDistance, _rt), x = qpe(e, n) && n.mode === ee.SCENE3D && A.alpha > 0 && (C.nearValue > 0 || C.farValue > 0), T = e.lambertDiffuseMultiplier, b = e.hasWaterMask && l(a), S = e.oceanNormalMap, D = b && l(S), P = e.terrainProvider.ready && e.terrainProvider.hasVertexNormals, B = n.fog.enabled && n.fog.renderable && !u, R = e.showGroundAtmosphere && n.mode === ee.SCENE3D, M = hn.castShadows(e.shadows) && !d, L = hn.receiveShadows(e.shadows) && !d, _ = e.hueShift, E = e.saturationShift, w = e.brightnessShift, v = !(I.equalsEpsilon(_, 0, I.EPSILON7) && I.equalsEpsilon(E, 0, I.EPSILON7) && I.equalsEpsilon(w, 0, I.EPSILON7)), O = !1; if (R) { let at = h.magnitude(n.camera.positionWC), Ne = e.nightFadeOutDistance; O = at > Ne } b && --s, D && --s, l(n.shadowState) && n.shadowState.shadowsEnabled && --s, l(e.clippingPlanes) && e.clippingPlanes.enabled && --s, s -= f.numberOfTextureUniforms; let V = i.renderedMesh, z = V.center, k = V.encoding, G = i.tileBoundingRegion, N = n.terrainExaggeration, X = n.terrainExaggerationRelativeHeight, q = N !== 1, J = k.hasGeodeticSurfaceNormals, W = ert, K = 0, Z = 0, de = 0, pe = 0, oe = !1; if (n.mode !== ee.SCENE3D) { let at = n.mapProjection, Ne = at.project(ce.southwest(t.rectangle), ort), nt = at.project(ce.northeast(t.rectangle), rrt); if (W.x = Ne.x, W.y = Ne.y, W.z = nt.x, W.w = nt.y, n.mode !== ee.MORPHING && (z = irt, z.x = 0, z.y = (W.z + W.x) * .5, z.z = (W.w + W.y) * .5, W.x -= z.y, W.y -= z.z, W.z -= z.y, W.w -= z.z), n.mode === ee.SCENE2D && k.quantization === Fs.BITS12) { let Ce = 1 / (Math.pow(2, 12) - 1) * .5, je = (W.z - W.x) * Ce, ut = (W.w - W.y) * Ce; W.x -= je, W.y -= ut, W.z += je, W.w += ut } at instanceof Ri && (K = t.rectangle.south, Z = t.rectangle.north, de = Ri.geodeticLatitudeToMercatorAngle(K), pe = 1 / (Ri.geodeticLatitudeToMercatorAngle(Z) - de), oe = !0) } let ue = mrt; ue.frameState = n, ue.surfaceTile = i, ue.showReflectiveOcean = b, ue.showOceanWaves = D, ue.enableLighting = e.enableLighting, ue.dynamicAtmosphereLighting = e.dynamicAtmosphereLighting, ue.dynamicAtmosphereLightingFromSun = e.dynamicAtmosphereLightingFromSun, ue.showGroundAtmosphere = R, ue.atmosphereLightIntensity = e.atmosphereLightIntensity, ue.atmosphereRayleighCoefficient = e.atmosphereRayleighCoefficient, ue.atmosphereMieCoefficient = e.atmosphereMieCoefficient, ue.atmosphereRayleighScaleHeight = e.atmosphereRayleighScaleHeight, ue.atmosphereMieScaleHeight = e.atmosphereMieScaleHeight, ue.atmosphereMieAnisotropy = e.atmosphereMieAnisotropy, ue.perFragmentGroundAtmosphere = O, ue.hasVertexNormals = P, ue.useWebMercatorProjection = oe, ue.clippedByBoundaries = i.clippedByBoundaries, ue.hasGeodeticSurfaceNormals = J, ue.hasExaggeration = q; let ge = i.imagery, Ee = 0, Ie = ge.length, Fe = e.showSkirts && !u && !d, We = e.backFaceCulling && !u && !d, Lt = We ? e._renderState : e._disableCullingRenderState, Gt = We ? e._blendRenderState : e._disableCullingBlendRenderState, cn = Lt, _t = e._firstPassInitialColor, Pn = n.context; if (l(e._debug.boundingSphereTile) || vk(), e._materialUniformMap !== e.materialUniformMap) { e._materialUniformMap = e.materialUniformMap; let at = e._drawCommands.length; for (let Ne = 0; Ne < at; ++Ne)e._uniformMaps[Ne] = Gpe(n, e) } do { let at = 0, Ne, nt; if (e._drawCommands.length <= e._usedDrawCommands ? (Ne = new $e, Ne.owner = t, Ne.cull = !1, Ne.boundingVolume = new re, Ne.orientedBoundingBox = void 0, nt = Gpe(n, e), e._drawCommands.push(Ne), e._uniformMaps.push(nt)) : (Ne = e._drawCommands[e._usedDrawCommands], nt = e._uniformMaps[e._usedDrawCommands]), Ne.owner = t, ++e._usedDrawCommands, t === e._debug.boundingSphereTile) { let Oo = G.boundingVolume, ir = G.boundingSphere; l(Oo) ? Ype(Oo, U.RED).update(n) : l(ir) && Xpe(ir, U.RED).update(n) } let Ce = nt.properties; se.clone(_t, Ce.initialColor), Ce.oceanNormalMap = S, Ce.lightingFadeDistance.x = e.lightingFadeOutDistance, Ce.lightingFadeDistance.y = e.lightingFadeInDistance, Ce.nightFadeDistance.x = e.nightFadeOutDistance, Ce.nightFadeDistance.y = e.nightFadeInDistance, Ce.atmosphereLightIntensity = e.atmosphereLightIntensity, Ce.atmosphereRayleighCoefficient = e.atmosphereRayleighCoefficient, Ce.atmosphereMieCoefficient = e.atmosphereMieCoefficient, Ce.atmosphereRayleighScaleHeight = e.atmosphereRayleighScaleHeight, Ce.atmosphereMieScaleHeight = e.atmosphereMieScaleHeight, Ce.atmosphereMieAnisotropy = e.atmosphereMieAnisotropy, Ce.zoomedOutOceanSpecularIntensity = e.zoomedOutOceanSpecularIntensity; let je = u ? g : p, ut = u ? p : g; l(je) && (se.fromElements(je.near, je.nearValue, je.far, je.farValue, Ce.frontFaceAlphaByDistance), se.fromElements(ut.near, ut.nearValue, ut.far, ut.farValue, Ce.backFaceAlphaByDistance)), se.fromElements(C.near, C.nearValue, C.far, C.farValue, Ce.undergroundColorAlphaByDistance), U.clone(A, Ce.undergroundColor), Ce.lambertDiffuseMultiplier = T; let Wn = !l(i.vertexArray) && l(e.fillHighlightColor) && e.fillHighlightColor.alpha > 0; Wn && U.clone(e.fillHighlightColor, Ce.fillHighlightColor), Ce.terrainExaggerationAndRelativeHeight.x = N, Ce.terrainExaggerationAndRelativeHeight.y = X, Ce.center3D = V.center, h.clone(z, Ce.rtc), se.clone(W, Ce.tileRectangle), Ce.southAndNorthLatitude.x = K, Ce.southAndNorthLatitude.y = Z, Ce.southMercatorYAndOneOverHeight.x = de, Ce.southMercatorYAndOneOverHeight.y = pe; let Zn = trt, Fi = Dk(t.rectangle, e.cartographicLimitRectangle), mo = nrt, bo = Dk(t.rectangle, m); h.fromElements(_, E, w, Ce.hsbShift); let Ii = t.rectangle, Le = 1 / Ii.width, et = 1 / Ii.height; Zn.x = (Fi.west - Ii.west) * Le, Zn.y = (Fi.south - Ii.south) * et, Zn.z = (Fi.east - Ii.west) * Le, Zn.w = (Fi.north - Ii.south) * et, se.clone(Zn, Ce.localizedCartographicLimitRectangle), mo.x = (bo.west - Ii.west) * Le, mo.y = (bo.south - Ii.south) * et, mo.z = (bo.east - Ii.west) * Le, mo.w = (bo.north - Ii.south) * et, se.clone(mo, Ce.localizedTranslucencyRectangle); let Ke = B && I.fog(t._distance, n.fog.density) > I.EPSILON3; v = v && (Ke || R); let qe = !1, mt = !1, Ft = !1, Cn = !1, ro = !1, So = !1, Ao = !1, Hs = !1, nr = !1, Oi = !1; for (; at < s && Ee < Ie;) { let Oo = ge[Ee], ir = Oo.readyImagery; if (++Ee, !l(ir) || ir.imageryLayer.alpha === 0) continue; let Uh = Oo.useWebMercatorT ? ir.textureWebMercator : ir.texture, br = ir.imageryLayer; l(Oo.textureTranslationAndScale) || (Oo.textureTranslationAndScale = br._calculateTextureTranslationAndScale(t, Oo)), Ce.dayTextures[at] = Uh, Ce.dayTextureTranslationAndScale[at] = Oo.textureTranslationAndScale, Ce.dayTextureTexCoordsRectangle[at] = Oo.textureCoordinateRectangle, Ce.dayTextureUseWebMercatorT[at] = Oo.useWebMercatorT, Ce.dayTextureAlpha[at] = br.alpha, So = So || Ce.dayTextureAlpha[at] !== 1, Ce.dayTextureNightAlpha[at] = br.nightAlpha, Ao = Ao || Ce.dayTextureNightAlpha[at] !== 1, Ce.dayTextureDayAlpha[at] = br.dayAlpha, Ao = Ao || Ce.dayTextureDayAlpha[at] !== 1, Ce.dayTextureBrightness[at] = br.brightness, qe = qe || Ce.dayTextureBrightness[at] !== Qu.DEFAULT_BRIGHTNESS, Ce.dayTextureContrast[at] = br.contrast, mt = mt || Ce.dayTextureContrast[at] !== Qu.DEFAULT_CONTRAST, Ce.dayTextureHue[at] = br.hue, Ft = Ft || Ce.dayTextureHue[at] !== Qu.DEFAULT_HUE, Ce.dayTextureSaturation[at] = br.saturation, Cn = Cn || Ce.dayTextureSaturation[at] !== Qu.DEFAULT_SATURATION, Ce.dayTextureOneOverGamma[at] = 1 / br.gamma, ro = ro || Ce.dayTextureOneOverGamma[at] !== 1 / Qu.DEFAULT_GAMMA, Ce.dayTextureSplit[at] = br.splitDirection, Hs = Hs || Ce.dayTextureSplit[at] !== 0; let Kl = Ce.dayTextureCutoutRectangles[at]; if (l(Kl) || (Kl = Ce.dayTextureCutoutRectangles[at] = new se), se.clone(se.ZERO, Kl), l(br.cutoutRectangle)) { let qr = Dk(Ii, br.cutoutRectangle), Bo = ce.simpleIntersection(qr, Ii, jpe); nr = l(Bo) || nr, Kl.x = (qr.west - Ii.west) * Le, Kl.y = (qr.south - Ii.south) * et, Kl.z = (qr.east - Ii.west) * Le, Kl.w = (qr.north - Ii.south) * et } let Jl = Ce.colorsToAlpha[at]; l(Jl) || (Jl = Ce.colorsToAlpha[at] = new se); let n0 = l(br.colorToAlpha) && br.colorToAlphaThreshold > 0; if (Oi = Oi || n0, n0) { let qr = br.colorToAlpha; Jl.x = qr.red, Jl.y = qr.green, Jl.z = qr.blue, Jl.w = br.colorToAlphaThreshold } else Jl.w = -1; if (l(ir.credits)) { let qr = ir.credits; for (let Bo = 0, vA = qr.length; Bo < vA; ++Bo)o.addCredit(qr[Bo]) } ++at } Ce.dayTextures.length = at, Ce.waterMask = a, se.clone(c, Ce.waterMaskTranslationAndScale), Ce.minMaxHeight.x = k.minimumHeight, Ce.minMaxHeight.y = k.maximumHeight, F.clone(k.matrix, Ce.scaleAndBias); let Wr = e._clippingPlanes, jr = l(Wr) && Wr.enabled && t.isClipped; jr && (Ce.clippingPlanesEdgeColor = U.clone(Wr.edgeColor, Ce.clippingPlanesEdgeColor), Ce.clippingPlanesEdgeWidth = Wr.edgeWidth), ue.numberOfDayTextures = at, ue.applyBrightness = qe, ue.applyContrast = mt, ue.applyHue = Ft, ue.applySaturation = Cn, ue.applyGamma = ro, ue.applyAlpha = So, ue.applyDayNightAlpha = Ao, ue.applySplit = Hs, ue.enableFog = Ke, ue.enableClippingPlanes = jr, ue.clippingPlanes = Wr, ue.hasImageryLayerCutout = nr, ue.colorCorrect = v, ue.highlightFillTile = Wn, ue.colorToAlpha = Oi, ue.showUndergroundColor = x, ue.translucent = d; let Xl = i.renderedMesh.indices.length; Fe || (Xl = i.renderedMesh.indexCountWithoutSkirts), Ne.shaderProgram = e._surfaceShaderSet.getShaderProgram(ue), Ne.castShadows = M, Ne.receiveShadows = L, Ne.renderState = cn, Ne.primitiveType = Oe.TRIANGLES, Ne.vertexArray = i.vertexArray || i.fill.vertexArray, Ne.count = Xl, Ne.uniformMap = nt, Ne.pass = xe.GLOBE, e._debug.wireframe && (frt(Pn, e, t), l(i.wireframeVertexArray) && (Ne.vertexArray = i.wireframeVertexArray, Ne.primitiveType = Oe.LINES, Ne.count = Xl * 2)); let Ni = Ne.boundingVolume, Er = Ne.orientedBoundingBox; n.mode !== ee.SCENE3D ? (re.fromRectangleWithHeights2D(t.rectangle, n.mapProjection, G.minimumHeight, G.maximumHeight, Ni), h.fromElements(Ni.center.z, Ni.center.x, Ni.center.y, Ni.center), n.mode === ee.MORPHING && (Ni = re.union(G.boundingSphere, Ni, Ni))) : (Ne.boundingVolume = re.clone(G.boundingSphere, Ni), Ne.orientedBoundingBox = di.clone(G.boundingVolume, Er)), Ne.dirty = !0, d && f.updateDerivedCommands(Ne, n), Wpe(Ne, n), cn = Gt, _t = hrt } while (Ee < Ie) } var Pk = Go; function Kpe() { this._enabled = !1, this._frontFaceAlpha = 1, this._frontFaceAlphaByDistance = void 0, this._backFaceAlpha = 1, this._backFaceAlphaByDistance = void 0, this._rectangle = ce.clone(ce.MAX_VALUE) } Object.defineProperties(Kpe.prototype, { enabled: { get: function () { return this._enabled }, set: function (e) { this._enabled = e } }, frontFaceAlpha: { get: function () { return this._frontFaceAlpha }, set: function (e) { this._frontFaceAlpha = e } }, frontFaceAlphaByDistance: { get: function () { return this._frontFaceAlphaByDistance }, set: function (e) { this._frontFaceAlphaByDistance = wt.clone(e, this._frontFaceAlphaByDistance) } }, backFaceAlpha: { get: function () { return this._backFaceAlpha }, set: function (e) { this._backFaceAlpha = e } }, backFaceAlphaByDistance: { get: function () { return this._backFaceAlphaByDistance }, set: function (e) { this._backFaceAlphaByDistance = wt.clone(e, this._backFaceAlphaByDistance) } }, rectangle: { get: function () { return this._rectangle }, set: function (e) { l(e) || (e = ce.clone(ce.MAX_VALUE)), ce.clone(e, this._rectangle) } } }); var Ik = Kpe; function os() { this._layers = [], this.layerAdded = new _e, this.layerRemoved = new _e, this.layerMoved = new _e, this.layerShownOrHidden = new _e } Object.defineProperties(os.prototype, { length: { get: function () { return this._layers.length } } }); os.prototype.add = function (e, t) { l(t) ? this._layers.splice(t, 0, e) : (t = this._layers.length, this._layers.push(e)), this._update(), this.layerAdded.raiseEvent(e, t) }; os.prototype.addImageryProvider = function (e, t) { let n = new Qu(e); return this.add(n, t), n }; os.prototype.remove = function (e, t) { t = y(t, !0); let n = this._layers.indexOf(e); return n !== -1 ? (this._layers.splice(n, 1), this._update(), this.layerRemoved.raiseEvent(e, n), t && e.destroy(), !0) : !1 }; os.prototype.removeAll = function (e) { e = y(e, !0); let t = this._layers; for (let n = 0, i = t.length; n < i; n++) { let o = t[n]; this.layerRemoved.raiseEvent(o, n), e && o.destroy() } this._layers = [] }; os.prototype.contains = function (e) { return this.indexOf(e) !== -1 }; os.prototype.indexOf = function (e) { return this._layers.indexOf(e) }; os.prototype.get = function (e) { return this._layers[e] }; function Ok(e, t) { return e.indexOf(t) } function Jpe(e, t, n) { let i = e._layers; if (t = I.clamp(t, 0, i.length - 1), n = I.clamp(n, 0, i.length - 1), t === n) return; let o = i[t]; i[t] = i[n], i[n] = o, e._update(), e.layerMoved.raiseEvent(o, n, t) } os.prototype.raise = function (e) { let t = Ok(this._layers, e); Jpe(this, t, t + 1) }; os.prototype.lower = function (e) { let t = Ok(this._layers, e); Jpe(this, t, t - 1) }; os.prototype.raiseToTop = function (e) { let t = Ok(this._layers, e); t !== this._layers.length - 1 && (this._layers.splice(t, 1), this._layers.push(e), this._update(), this.layerMoved.raiseEvent(e, this._layers.length - 1, t)) }; os.prototype.lowerToBottom = function (e) { let t = Ok(this._layers, e); t !== 0 && (this._layers.splice(t, 1), this._layers.splice(0, 0, e), this._update(), this.layerMoved.raiseEvent(e, 0, t)) }; var yrt = new ce; function Zpe(e, t, n, i) { let o = e.globe._surface._tilesToRender, r; for (let a = 0; !l(r) && a < o.length; ++a) { let c = o[a]; ce.contains(c.rectangle, t) && (r = c) } if (!l(r)) return; let s = r.data.imagery; for (let a = s.length - 1; a >= 0; --a) { let c = s[a], u = c.readyImagery; if (!l(u)) continue; let f = u.imageryLayer.imageryProvider; if (n && !l(f.pickFeatures) || !ce.contains(u.rectangle, t)) continue; let d = yrt, p = 1 / 1024; d.west = I.lerp(r.rectangle.west, r.rectangle.east, c.textureCoordinateRectangle.x - p), d.east = I.lerp(r.rectangle.west, r.rectangle.east, c.textureCoordinateRectangle.z + p), d.south = I.lerp(r.rectangle.south, r.rectangle.north, c.textureCoordinateRectangle.y - p), d.north = I.lerp(r.rectangle.south, r.rectangle.north, c.textureCoordinateRectangle.w + p), ce.contains(d, t) && i(u) } } os.prototype.pickImageryLayers = function (e, t) { let n = t.globe.pick(e, t); if (!l(n)) return; let i = t.globe.ellipsoid.cartesianToCartographic(n), o = []; if (Zpe(t, i, !1, function (r) { o.push(r.imageryLayer) }), o.length !== 0) return o }; os.prototype.pickImageryLayerFeatures = function (e, t) { let n = t.globe.pick(e, t); if (!l(n)) return; let i = t.globe.ellipsoid.cartesianToCartographic(n), o = [], r = []; if (Zpe(t, i, !0, function (s) { let c = s.imageryLayer.imageryProvider.pickFeatures(s.x, s.y, s.level, i.longitude, i.latitude); l(c) && (o.push(c), r.push(s.imageryLayer)) }), o.length !== 0) return Promise.all(o).then(function (s) { let a = []; for (let c = 0; c < s.length; ++c) { let u = s[c], f = r[c]; if (l(u) && u.length > 0) for (let d = 0; d < u.length; ++d) { let p = u[d]; p.imageryLayer = f, l(p.position) || (p.position = i), a.push(p) } } return a }) }; os.prototype.queueReprojectionCommands = function (e) { let t = this._layers; for (let n = 0, i = t.length; n < i; ++n)t[n].queueReprojectionCommands(e) }; os.prototype.cancelReprojections = function () { let e = this._layers; for (let t = 0, n = e.length; t < n; ++t)e[t].cancelReprojections() }; os.prototype.isDestroyed = function () { return !1 }; os.prototype.destroy = function () { return this.removeAll(!0), le(this) }; os.prototype._update = function () { let e = !0, t = this._layers, n, i, o, r; for (o = 0, r = t.length; o < r; ++o)i = t[o], i._layerIndex = o, i.show ? (i._isBaseLayer = e, e = !1) : i._isBaseLayer = !1, i.show !== i._show && (l(i._show) && (l(n) || (n = []), n.push(i)), i._show = i.show); if (l(n)) for (o = 0, r = n.length; o < r; ++o)i = n[o], this.layerShownOrHidden.raiseEvent(i, i._layerIndex, i.show) }; var Bk = os; function Qpe(e) { this._ellipsoid = new j_(e.ellipsoid, h.ZERO) } Object.defineProperties(Qpe.prototype, { ellipsoid: { get: function () { return this._ellipsoid } } }); var Rk = Qpe; function Cc(e) { this._tilingScheme = e.tilingScheme, this._x = e.x, this._y = e.y, this._level = e.level, this._parent = e.parent, this._rectangle = this._tilingScheme.tileXYToRectangle(this._x, this._y, this._level), this._southwestChild = void 0, this._southeastChild = void 0, this._northwestChild = void 0, this._northeastChild = void 0, this.replacementPrevious = void 0, this.replacementNext = void 0, this._distance = 0, this._loadPriority = 0, this._customData = [], this._frameUpdated = void 0, this._lastSelectionResult = qn.NONE, this._lastSelectionResultFrame = void 0, this._loadedCallbacks = {}, this.state = ks.START, this.renderable = !1, this.upsampledFromParent = !1, this.data = void 0 } Cc.createLevelZeroTiles = function (e) { let t = e.getNumberOfXTilesAtLevel(0), n = e.getNumberOfYTilesAtLevel(0), i = new Array(t * n), o = 0; for (let r = 0; r < n; ++r)for (let s = 0; s < t; ++s)i[o++] = new Cc({ tilingScheme: e, x: s, y: r, level: 0 }); return i }; Cc.prototype._updateCustomData = function (e, t, n) { let i = this.customData, o, r, s; if (l(t) && l(n)) { for (i = i.filter(function (a) { return n.indexOf(a) === -1 }), this._customData = i, s = this._rectangle, o = 0; o < t.length; ++o)r = t[o], ce.contains(s, r.positionCartographic) && i.push(r); this._frameUpdated = e } else { let a = this._parent; if (l(a) && this._frameUpdated !== a._frameUpdated) { i.length = 0, s = this._rectangle; let c = a.customData; for (o = 0; o < c.length; ++o)r = c[o], ce.contains(s, r.positionCartographic) && i.push(r); this._frameUpdated = a._frameUpdated } } }; Object.defineProperties(Cc.prototype, { tilingScheme: { get: function () { return this._tilingScheme } }, x: { get: function () { return this._x } }, y: { get: function () { return this._y } }, level: { get: function () { return this._level } }, parent: { get: function () { return this._parent } }, rectangle: { get: function () { return this._rectangle } }, children: { get: function () { return [this.northwestChild, this.northeastChild, this.southwestChild, this.southeastChild] } }, southwestChild: { get: function () { return l(this._southwestChild) || (this._southwestChild = new Cc({ tilingScheme: this.tilingScheme, x: this.x * 2, y: this.y * 2 + 1, level: this.level + 1, parent: this })), this._southwestChild } }, southeastChild: { get: function () { return l(this._southeastChild) || (this._southeastChild = new Cc({ tilingScheme: this.tilingScheme, x: this.x * 2 + 1, y: this.y * 2 + 1, level: this.level + 1, parent: this })), this._southeastChild } }, northwestChild: { get: function () { return l(this._northwestChild) || (this._northwestChild = new Cc({ tilingScheme: this.tilingScheme, x: this.x * 2, y: this.y * 2, level: this.level + 1, parent: this })), this._northwestChild } }, northeastChild: { get: function () { return l(this._northeastChild) || (this._northeastChild = new Cc({ tilingScheme: this.tilingScheme, x: this.x * 2 + 1, y: this.y * 2, level: this.level + 1, parent: this })), this._northeastChild } }, customData: { get: function () { return this._customData } }, needsLoading: { get: function () { return this.state < ks.DONE } }, eligibleForUnloading: { get: function () { let e = !0; return l(this.data) && (e = this.data.eligibleForUnloading, l(e) || (e = !0)), e } } }); Cc.prototype.findLevelZeroTile = function (e, t, n) { let i = this.tilingScheme.getNumberOfXTilesAtLevel(0); if (t < 0 ? t += i : t >= i && (t -= i), !(n < 0 || n >= this.tilingScheme.getNumberOfYTilesAtLevel(0))) return e.filter(function (o) { return o.x === t && o.y === n })[0] }; Cc.prototype.findTileToWest = function (e) { let t = this.parent; if (t === void 0) return this.findLevelZeroTile(e, this.x - 1, this.y); if (t.southeastChild === this) return t.southwestChild; if (t.northeastChild === this) return t.northwestChild; let n = t.findTileToWest(e); if (n !== void 0) return t.southwestChild === this ? n.southeastChild : n.northeastChild }; Cc.prototype.findTileToEast = function (e) { let t = this.parent; if (t === void 0) return this.findLevelZeroTile(e, this.x + 1, this.y); if (t.southwestChild === this) return t.southeastChild; if (t.northwestChild === this) return t.northeastChild; let n = t.findTileToEast(e); if (n !== void 0) return t.southeastChild === this ? n.southwestChild : n.northwestChild }; Cc.prototype.findTileToSouth = function (e) { let t = this.parent; if (t === void 0) return this.findLevelZeroTile(e, this.x, this.y + 1); if (t.northwestChild === this) return t.southwestChild; if (t.northeastChild === this) return t.southeastChild; let n = t.findTileToSouth(e); if (n !== void 0) return t.southwestChild === this ? n.northwestChild : n.northeastChild }; Cc.prototype.findTileToNorth = function (e) { let t = this.parent; if (t === void 0) return this.findLevelZeroTile(e, this.x, this.y - 1); if (t.southwestChild === this) return t.northwestChild; if (t.southeastChild === this) return t.northeastChild; let n = t.findTileToNorth(e); if (n !== void 0) return t.northwestChild === this ? n.southwestChild : n.southeastChild }; Cc.prototype.freeResources = function () { this.state = ks.START, this.renderable = !1, this.upsampledFromParent = !1, l(this.data) && l(this.data.freeResources) && this.data.freeResources(), Mk(this._southwestChild), this._southwestChild = void 0, Mk(this._southeastChild), this._southeastChild = void 0, Mk(this._northwestChild), this._northwestChild = void 0, Mk(this._northeastChild), this._northeastChild = void 0 }; function Mk(e) { l(e) && e.freeResources() } var Lk = Cc; function Fk() { this.head = void 0, this.tail = void 0, this.count = 0, this._lastBeforeStartOfFrame = void 0 } Fk.prototype.markStartOfRenderFrame = function () { this._lastBeforeStartOfFrame = this.head }; Fk.prototype.trimTiles = function (e) { let t = this.tail, n = !0; for (; n && l(this._lastBeforeStartOfFrame) && this.count > e && l(t);) { n = t !== this._lastBeforeStartOfFrame; let i = t.replacementPrevious; t.eligibleForUnloading && (t.freeResources(), $pe(this, t)), t = i } }; function $pe(e, t) { let n = t.replacementPrevious, i = t.replacementNext; t === e._lastBeforeStartOfFrame && (e._lastBeforeStartOfFrame = i), t === e.head ? e.head = i : n.replacementNext = i, t === e.tail ? e.tail = n : i.replacementPrevious = n, t.replacementPrevious = void 0, t.replacementNext = void 0, --e.count } Fk.prototype.markTileRendered = function (e) { let t = this.head; if (t === e) { e === this._lastBeforeStartOfFrame && (this._lastBeforeStartOfFrame = e.replacementNext); return } if (++this.count, !l(t)) { e.replacementPrevious = void 0, e.replacementNext = void 0, this.head = e, this.tail = e; return } (l(e.replacementPrevious) || l(e.replacementNext)) && $pe(this, e), e.replacementPrevious = void 0, e.replacementNext = t, t.replacementPrevious = e, this.head = e }; var Nk = Fk; function $u(e) { this._tileProvider = e.tileProvider, this._tileProvider.quadtree = this, this._debug = { enableDebugOutput: !1, maxDepth: 0, maxDepthVisited: 0, tilesVisited: 0, tilesCulled: 0, tilesRendered: 0, tilesWaitingForChildren: 0, lastMaxDepth: -1, lastMaxDepthVisited: -1, lastTilesVisited: -1, lastTilesCulled: -1, lastTilesRendered: -1, lastTilesWaitingForChildren: -1, suspendLodUpdate: !1 }; let n = this._tileProvider.tilingScheme.ellipsoid; this._tilesToRender = [], this._tileLoadQueueHigh = [], this._tileLoadQueueMedium = [], this._tileLoadQueueLow = [], this._tileReplacementQueue = new Nk, this._levelZeroTiles = void 0, this._loadQueueTimeSlice = 5, this._tilesInvalidated = !1, this._addHeightCallbacks = [], this._removeHeightCallbacks = [], this._tileToUpdateHeights = [], this._lastTileIndex = 0, this._updateHeightsTimeSlice = 2, this._cameraPositionCartographic = void 0, this._cameraReferenceFrameOriginCartographic = void 0, this.maximumScreenSpaceError = y(e.maximumScreenSpaceError, 2), this.tileCacheSize = y(e.tileCacheSize, 100), this.loadingDescendantLimit = 20, this.preloadAncestors = !0, this.preloadSiblings = !1, this._occluders = new Rk({ ellipsoid: n }), this._tileLoadProgressEvent = new _e, this._lastTileLoadQueueLength = 0, this._lastSelectionFrameNumber = void 0 } Object.defineProperties($u.prototype, { tileProvider: { get: function () { return this._tileProvider } }, tileLoadProgressEvent: { get: function () { return this._tileLoadProgressEvent } }, occluders: { get: function () { return this._occluders } } }); $u.prototype.invalidateAllTiles = function () { this._tilesInvalidated = !0 }; function Art(e) { let t = e._tileReplacementQueue; t.head = void 0, t.tail = void 0, t.count = 0, t_e(e); let n = e._levelZeroTiles; if (l(n)) for (let i = 0; i < n.length; ++i) { let r = n[i].customData, s = r.length; for (let a = 0; a < s; ++a) { let c = r[a]; c.level = 0, e._addHeightCallbacks.push(c) } n[i].freeResources() } e._levelZeroTiles = void 0, e._tileProvider.cancelReprojections() } $u.prototype.forEachLoadedTile = function (e) { let t = this._tileReplacementQueue.head; for (; l(t);)t.state !== ks.START && e(t), t = t.replacementNext }; $u.prototype.forEachRenderedTile = function (e) { let t = this._tilesToRender; for (let n = 0, i = t.length; n < i; ++n)e(t[n]) }; $u.prototype.updateHeight = function (e, t) { let n = this, i = { positionOnEllipsoidSurface: void 0, positionCartographic: e, level: -1, callback: t }; return i.removeFunc = function () { let o = n._addHeightCallbacks, r = o.length; for (let s = 0; s < r; ++s)if (o[s] === i) { o.splice(s, 1); break } n._removeHeightCallbacks.push(i), i.callback && (i.callback = void 0) }, n._addHeightCallbacks.push(i), i.removeFunc }; $u.prototype.update = function (e) { l(this._tileProvider.update) && this._tileProvider.update(e) }; function t_e(e) { let t = e._debug; t.maxDepth = 0, t.maxDepthVisited = 0, t.tilesVisited = 0, t.tilesCulled = 0, t.tilesRendered = 0, t.tilesWaitingForChildren = 0, e._tileLoadQueueHigh.length = 0, e._tileLoadQueueMedium.length = 0, e._tileLoadQueueLow.length = 0 } $u.prototype.beginFrame = function (e) { !e.passes.render || (this._tilesInvalidated && (Art(this), this._tilesInvalidated = !1), this._tileProvider.initialize(e), t_e(this), !this._debug.suspendLodUpdate && this._tileReplacementQueue.markStartOfRenderFrame()) }; $u.prototype.render = function (e) { let t = e.passes, n = this._tileProvider; t.render && (n.beginUpdate(e), Ert(this, e), Rrt(this, e), n.endUpdate(e)), t.pick && this._tilesToRender.length > 0 && n.updateForPick(e) }; function Crt(e, t) { let n = e._tileLoadQueueHigh.length + e._tileLoadQueueMedium.length + e._tileLoadQueueLow.length; (n !== e._lastTileLoadQueueLength || e._tilesInvalidated) && (t.afterRender.push(_e.prototype.raiseEvent.bind(e._tileLoadProgressEvent, n)), e._lastTileLoadQueueLength = n); let i = e._debug; i.enableDebugOutput && !i.suspendLodUpdate && (i.maxDepth = e._tilesToRender.reduce(function (o, r) { return Math.max(o, r.level) }, -1), i.tilesRendered = e._tilesToRender.length, (i.tilesVisited !== i.lastTilesVisited || i.tilesRendered !== i.lastTilesRendered || i.tilesCulled !== i.lastTilesCulled || i.maxDepth !== i.lastMaxDepth || i.tilesWaitingForChildren !== i.lastTilesWaitingForChildren || i.maxDepthVisited !== i.lastMaxDepthVisited) && (console.log(`Visited ${i.tilesVisited}, Rendered: ${i.tilesRendered}, Culled: ${i.tilesCulled}, Max Depth Rendered: ${i.maxDepth}, Max Depth Visited: ${i.maxDepthVisited}, Waiting for children: ${i.tilesWaitingForChildren}`), i.lastTilesVisited = i.tilesVisited, i.lastTilesRendered = i.tilesRendered, i.lastTilesCulled = i.tilesCulled, i.lastMaxDepth = i.maxDepth, i.lastTilesWaitingForChildren = i.tilesWaitingForChildren, i.lastMaxDepthVisited = i.maxDepthVisited)) } $u.prototype.endFrame = function (e) { !e.passes.render || e.mode === ee.MORPHING || (Prt(this, e), Brt(this, e), Crt(this, e)) }; $u.prototype.isDestroyed = function () { return !1 }; $u.prototype.destroy = function () { this._tileProvider = this._tileProvider && this._tileProvider.destroy() }; var dv, e_e = new he; function xrt(e, t) { let n = ce.center(e.rectangle, e_e), i = n.longitude - dv.longitude, o = n.latitude - dv.latitude; n = ce.center(t.rectangle, e_e); let r = n.longitude - dv.longitude, s = n.latitude - dv.latitude; return i * i + o * o - (r * r + s * s) } var Trt = new h, fv = []; function Ert(e, t) { let n = e._debug; if (n.suspendLodUpdate) return; let i = e._tilesToRender; i.length = 0; let o, r = e._tileProvider; if (!l(e._levelZeroTiles)) if (r.ready) { let A = r.tilingScheme; e._levelZeroTiles = Lk.createLevelZeroTiles(A); let C = e._levelZeroTiles.length; if (fv.length < C) for (fv = new Array(C), o = 0; o < C; ++o)fv[o] === void 0 && (fv[o] = new hv) } else return; e._occluders.ellipsoid.cameraPosition = t.camera.positionWC; let s, a = e._levelZeroTiles, c = a.length > 1 ? e._occluders : void 0; dv = t.camera.positionCartographic, a.sort(xrt); let u = e._addHeightCallbacks, f = e._removeHeightCallbacks, d = t.frameNumber, p; if (u.length > 0 || f.length > 0) { for (o = 0, p = a.length; o < p; ++o)s = a[o], s._updateCustomData(d, u, f); u.length = 0, f.length = 0 } let g = t.camera; e._cameraPositionCartographic = g.positionCartographic; let m = F.getTranslation(g.transform, Trt); for (e._cameraReferenceFrameOriginCartographic = e.tileProvider.tilingScheme.ellipsoid.cartesianToCartographic(m, e._cameraReferenceFrameOriginCartographic), o = 0, p = a.length; o < p; ++o)s = a[o], e._tileReplacementQueue.markTileRendered(s), s.renderable ? ra(e, s, r, t, c, !1, fv[o]) : (hp(e, e._tileLoadQueueHigh, s, t), ++n.tilesWaitingForChildren); e._lastSelectionFrameNumber = d } function hp(e, t, n, i) { !n.needsLoading || (e.tileProvider.computeTileLoadPriority !== void 0 && (n._loadPriority = e.tileProvider.computeTileLoadPriority(n, i)), t.push(n)) } function hv() { this.allAreRenderable = !0, this.anyWereRenderedLastFrame = !1, this.notYetRenderableCount = 0 } function n_e() { this.southwest = new hv, this.southeast = new hv, this.northwest = new hv, this.northeast = new hv } n_e.prototype.combine = function (e) { let t = this.southwest, n = this.southeast, i = this.northwest, o = this.northeast; e.allAreRenderable = t.allAreRenderable && n.allAreRenderable && i.allAreRenderable && o.allAreRenderable, e.anyWereRenderedLastFrame = t.anyWereRenderedLastFrame || n.anyWereRenderedLastFrame || i.anyWereRenderedLastFrame || o.anyWereRenderedLastFrame, e.notYetRenderableCount = t.notYetRenderableCount + n.notYetRenderableCount + i.notYetRenderableCount + o.notYetRenderableCount }; var hj = new Array(31); for (let e = 0; e < hj.length; ++e)hj[e] = new n_e; function brt(e, t, n, i, o) { let r = e._debug; ++r.tilesVisited, e._tileReplacementQueue.markTileRendered(n), n._updateCustomData(t.frameNumber), n.level > r.maxDepthVisited && (r.maxDepthVisited = n.level); let s = Drt(e, t, n) < e.maximumScreenSpaceError, a = n.southwestChild, c = n.southeastChild, u = n.northwestChild, f = n.northeastChild, d = e._lastSelectionFrameNumber, p = n._lastSelectionResultFrame === d ? n._lastSelectionResult : qn.NONE, g = e.tileProvider; if (s || i) { let m = qn.originalResult(p) === qn.RENDERED, A = qn.originalResult(p) === qn.CULLED || p === qn.NONE, C = n.state === ks.DONE, x = m || A || C; if (x || l(g.canRenderWithoutLosingDetail) && (x = g.canRenderWithoutLosingDetail(n)), x) { s && hp(e, e._tileLoadQueueMedium, n, t), Vk(e, n), o.allAreRenderable = n.renderable, o.anyWereRenderedLastFrame = p === qn.RENDERED, o.notYetRenderableCount = n.renderable ? 0 : 1, n._lastSelectionResultFrame = t.frameNumber, n._lastSelectionResult = qn.RENDERED, o.anyWereRenderedLastFrame || e._tileToUpdateHeights.push(n); return } i = !0, s && hp(e, e._tileLoadQueueHigh, n, t) } if (g.canRefine(n)) { if (a.upsampledFromParent && c.upsampledFromParent && u.upsampledFromParent && f.upsampledFromParent) { Vk(e, n), hp(e, e._tileLoadQueueMedium, n, t), e._tileReplacementQueue.markTileRendered(a), e._tileReplacementQueue.markTileRendered(c), e._tileReplacementQueue.markTileRendered(u), e._tileReplacementQueue.markTileRendered(f), o.allAreRenderable = n.renderable, o.anyWereRenderedLastFrame = p === qn.RENDERED, o.notYetRenderableCount = n.renderable ? 0 : 1, n._lastSelectionResultFrame = t.frameNumber, n._lastSelectionResult = qn.RENDERED, o.anyWereRenderedLastFrame || e._tileToUpdateHeights.push(n); return } n._lastSelectionResultFrame = t.frameNumber, n._lastSelectionResult = qn.REFINED; let A = e._tilesToRender.length, C = e._tileLoadQueueLow.length, x = e._tileLoadQueueMedium.length, T = e._tileLoadQueueHigh.length, b = e._tileToUpdateHeights.length; if (Srt(e, a, c, u, f, t, i, o), A !== e._tilesToRender.length) { let S = o.allAreRenderable, D = o.anyWereRenderedLastFrame, P = o.notYetRenderableCount, B = !1; if (!S && !D) { let R = e._tilesToRender; for (let L = A; L < R.length; ++L) { let _ = R[L]; for (; _ !== void 0 && _._lastSelectionResult !== qn.KICKED && _ !== n;)_._lastSelectionResult = qn.kick(_._lastSelectionResult), _ = _.parent } e._tilesToRender.length = A, e._tileToUpdateHeights.length = b, Vk(e, n), n._lastSelectionResult = qn.RENDERED; let M = p === qn.RENDERED; !M && P > e.loadingDescendantLimit && (e._tileLoadQueueLow.length = C, e._tileLoadQueueMedium.length = x, e._tileLoadQueueHigh.length = T, hp(e, e._tileLoadQueueMedium, n, t), o.notYetRenderableCount = n.renderable ? 0 : 1, B = !0), o.allAreRenderable = n.renderable, o.anyWereRenderedLastFrame = M, M || e._tileToUpdateHeights.push(n), ++r.tilesWaitingForChildren } e.preloadAncestors && !B && hp(e, e._tileLoadQueueLow, n, t) } return } n._lastSelectionResultFrame = t.frameNumber, n._lastSelectionResult = qn.RENDERED, Vk(e, n), hp(e, e._tileLoadQueueHigh, n, t), o.allAreRenderable = n.renderable, o.anyWereRenderedLastFrame = p === qn.RENDERED, o.notYetRenderableCount = n.renderable ? 0 : 1 } function Srt(e, t, n, i, o, r, s, a) { let c = r.camera.positionCartographic, u = e._tileProvider, f = e._occluders, d = hj[t.level], p = d.southwest, g = d.southeast, m = d.northwest, A = d.northeast; c.longitude < t.rectangle.east ? c.latitude < t.rectangle.north ? (ra(e, t, u, r, f, s, p), ra(e, n, u, r, f, s, g), ra(e, i, u, r, f, s, m), ra(e, o, u, r, f, s, A)) : (ra(e, i, u, r, f, s, m), ra(e, t, u, r, f, s, p), ra(e, o, u, r, f, s, A), ra(e, n, u, r, f, s, g)) : c.latitude < t.rectangle.north ? (ra(e, n, u, r, f, s, g), ra(e, t, u, r, f, s, p), ra(e, o, u, r, f, s, A), ra(e, i, u, r, f, s, m)) : (ra(e, o, u, r, f, s, A), ra(e, i, u, r, f, s, m), ra(e, n, u, r, f, s, g), ra(e, t, u, r, f, s, p)), d.combine(a) } function wrt(e, t) { let n = t.rectangle; return l(e._cameraPositionCartographic) && ce.contains(n, e._cameraPositionCartographic) || l(e._cameraReferenceFrameOriginCartographic) && ce.contains(n, e._cameraReferenceFrameOriginCartographic) } function ra(e, t, n, i, o, r, s) { if (n.computeTileVisibility(t, i, o) !== lr.NONE) return brt(e, i, t, r, s); if (++e._debug.tilesCulled, e._tileReplacementQueue.markTileRendered(t), s.allAreRenderable = !0, s.anyWereRenderedLastFrame = !1, s.notYetRenderableCount = 0, wrt(e, t)) { (!l(t.data) || !l(t.data.vertexArray)) && hp(e, e._tileLoadQueueMedium, t, i); let a = e._lastSelectionFrameNumber, c = t._lastSelectionResultFrame === a ? t._lastSelectionResult : qn.NONE; c !== qn.CULLED_BUT_NEEDED && c !== qn.RENDERED && e._tileToUpdateHeights.push(t), t._lastSelectionResult = qn.CULLED_BUT_NEEDED } else e.preloadSiblings || t.level === 0 ? (hp(e, e._tileLoadQueueLow, t, i), t._lastSelectionResult = qn.CULLED) : t._lastSelectionResult = qn.CULLED; t._lastSelectionResultFrame = i.frameNumber } function Drt(e, t, n) { if (t.mode === ee.SCENE2D || t.camera.frustum instanceof Zt || t.camera.frustum instanceof wr) return vrt(e, t, n); let i = e._tileProvider.getLevelMaximumGeometricError(n.level), o = n._distance, r = t.context.drawingBufferHeight, s = t.camera.frustum.sseDenominator, a = i * r / (o * s); return t.fog.enabled && (a -= I.fog(o, t.fog.density) * t.fog.sse), a /= t.pixelRatio, a } function vrt(e, t, n) { let o = t.camera.frustum; l(o._offCenterFrustum) && (o = o._offCenterFrustum); let r = t.context, s = r.drawingBufferWidth, a = r.drawingBufferHeight, c = e._tileProvider.getLevelMaximumGeometricError(n.level), u = Math.max(o.top - o.bottom, o.right - o.left) / Math.max(s, a), f = c / u; return t.fog.enabled && t.mode !== ee.SCENE2D && (f -= I.fog(n._distance, t.fog.density) * t.fog.sse), f /= t.pixelRatio, f } function Vk(e, t) { e._tilesToRender.push(t) } function Prt(e, t) { let n = e._tileLoadQueueHigh, i = e._tileLoadQueueMedium, o = e._tileLoadQueueLow; if (n.length === 0 && i.length === 0 && o.length === 0) return; e._tileReplacementQueue.trimTiles(e.tileCacheSize); let r = Ei() + e._loadQueueTimeSlice, s = e._tileProvider, a = fj(e, t, s, r, n, !1); a = fj(e, t, s, r, i, a), fj(e, t, s, r, o, a) } function Irt(e, t) { return e._loadPriority - t._loadPriority } function fj(e, t, n, i, o, r) { n.computeTileLoadPriority !== void 0 && o.sort(Irt); for (let s = 0, a = o.length; s < a && (Ei() < i || !r); ++s) { let c = o[s]; e._tileReplacementQueue.markTileRendered(c), n.loadTile(t, c), r = !0 } return r } var ME = new En, dj = new he, Gg = new h, Ort = []; function Brt(e, t) { if (!e.tileProvider.ready) return; let n = Ort; n.length = 0; let i = e._tileToUpdateHeights, o = Ei(), r = e._updateHeightsTimeSlice, s = o + r, a = t.mode, c = t.mapProjection, u = e.tileProvider.tilingScheme.ellipsoid, f; for (; i.length > 0;) { let d = i[0]; if (!l(d.data) || !l(d.data.mesh)) { let A = d._lastSelectionResultFrame === e._lastSelectionFrameNumber ? d._lastSelectionResult : qn.NONE; (A === qn.RENDERED || A === qn.CULLED_BUT_NEEDED) && n.push(d), i.shift(), e._lastTileIndex = 0; continue } let p = d.customData, g = p.length, m = !1; for (f = e._lastTileIndex; f < g; ++f) { let A = p[f], C = d.data.terrainData, x = l(C) && C.wasCreatedByUpsampling(); if (d.level > A.level && !x) { if (l(A.positionOnEllipsoidSurface) || (A.positionOnEllipsoidSurface = h.fromRadians(A.positionCartographic.longitude, A.positionCartographic.latitude, 0, u)), a === ee.SCENE3D) { let b = u.geodeticSurfaceNormal(A.positionOnEllipsoidSurface, ME.direction), S = u.getSurfaceNormalIntersectionWithZAxis(A.positionOnEllipsoidSurface, 11500, ME.origin); if (!l(S)) { let D = 0; l(d.data.tileBoundingRegion) && (D = d.data.tileBoundingRegion.minimumHeight); let P = Math.min(D, -11500), B = h.multiplyByScalar(b, Math.abs(P) + 1, Gg); h.subtract(A.positionOnEllipsoidSurface, B, ME.origin) } } else he.clone(A.positionCartographic, dj), dj.height = -11500, c.project(dj, Gg), h.fromElements(Gg.z, Gg.x, Gg.y, Gg), h.clone(Gg, ME.origin), h.clone(h.UNIT_X, ME.direction); let T = d.data.pick(ME, a, c, !1, Gg); l(T) && (l(A.callback) && A.callback(T), A.level = d.level) } if (Ei() >= s) { m = !0; break } } if (m) { e._lastTileIndex = f; break } else e._lastTileIndex = 0, i.shift() } for (f = 0; f < n.length; f++)i.push(n[f]) } function Rrt(e, t) { let n = e._tileProvider, i = e._tilesToRender; for (let o = 0, r = i.length; o < r; ++o) { let s = i[o]; n.showTileThisFrame(s, t) } } var kk = $u; function dd(e) { e = y(e, ie.WGS84); let t = new Pg({ ellipsoid: e }), n = new Bk; this._ellipsoid = e, this._imageryLayerCollection = n, this._surfaceShaderSet = new pk, this._material = void 0, this._surface = new kk({ tileProvider: new Pk({ terrainProvider: t, imageryLayers: n, surfaceShaderSet: this._surfaceShaderSet }) }), this._terrainProvider = t, this._terrainProviderChanged = new _e, this._undergroundColor = U.clone(U.BLACK), this._undergroundColorAlphaByDistance = new wt(e.maximumRadius / 1e3, 0, e.maximumRadius / 5, 1), this._translucency = new Ik, pj(this), this.show = !0, this._oceanNormalMapResourceDirty = !0, this._oceanNormalMapResource = new Pe({ url: Jt("Assets/Textures/waterNormalsSmall.jpg") }), this.maximumScreenSpaceError = 2, this.tileCacheSize = 100, this.loadingDescendantLimit = 20, this.preloadAncestors = !0, this.preloadSiblings = !1, this.fillHighlightColor = void 0, this.enableLighting = !1, this.lambertDiffuseMultiplier = .9, this.dynamicAtmosphereLighting = !0, this.dynamicAtmosphereLightingFromSun = !1, this.showGroundAtmosphere = !0, this.atmosphereLightIntensity = 10, this.atmosphereRayleighCoefficient = new h(55e-7, 13e-6, 284e-7), this.atmosphereMieCoefficient = new h(21e-6, 21e-6, 21e-6), this.atmosphereRayleighScaleHeight = 1e4, this.atmosphereMieScaleHeight = 3200, this.atmosphereMieAnisotropy = .9, this.lightingFadeOutDistance = 1e7, this.lightingFadeInDistance = 2e7, this.nightFadeOutDistance = 1e7, this.nightFadeInDistance = 5e7, this.showWaterEffect = !0, this.depthTestAgainstTerrain = !1, this.shadows = hn.RECEIVE_ONLY, this.atmosphereHueShift = 0, this.atmosphereSaturationShift = 0, this.atmosphereBrightnessShift = 0, this.terrainExaggeration = 1, this.terrainExaggerationRelativeHeight = 0, this.showSkirts = !0, this.backFaceCulling = !0, this._oceanNormalMap = void 0, this._zoomedOutOceanSpecularIntensity = void 0 } Object.defineProperties(dd.prototype, { ellipsoid: { get: function () { return this._ellipsoid } }, imageryLayers: { get: function () { return this._imageryLayerCollection } }, imageryLayersUpdatedEvent: { get: function () { return this._surface.tileProvider.imageryLayersUpdatedEvent } }, tilesLoaded: { get: function () { return l(this._surface) ? this._surface.tileProvider.ready && this._surface._tileLoadQueueHigh.length === 0 && this._surface._tileLoadQueueMedium.length === 0 && this._surface._tileLoadQueueLow.length === 0 : !0 } }, baseColor: { get: function () { return this._surface.tileProvider.baseColor }, set: function (e) { this._surface.tileProvider.baseColor = e } }, clippingPlanes: { get: function () { return this._surface.tileProvider.clippingPlanes }, set: function (e) { this._surface.tileProvider.clippingPlanes = e } }, cartographicLimitRectangle: { get: function () { return this._surface.tileProvider.cartographicLimitRectangle }, set: function (e) { l(e) || (e = ce.clone(ce.MAX_VALUE)), this._surface.tileProvider.cartographicLimitRectangle = e } }, oceanNormalMapUrl: { get: function () { return this._oceanNormalMapResource.url }, set: function (e) { this._oceanNormalMapResource.url = e, this._oceanNormalMapResourceDirty = !0 } }, terrainProvider: { get: function () { return this._terrainProvider }, set: function (e) { e !== this._terrainProvider && (this._terrainProvider = e, this._terrainProviderChanged.raiseEvent(e), l(this._material) && pj(this)) } }, terrainProviderChanged: { get: function () { return this._terrainProviderChanged } }, tileLoadProgressEvent: { get: function () { return this._surface.tileLoadProgressEvent } }, material: { get: function () { return this._material }, set: function (e) { this._material !== e && (this._material = e, pj(this)) } }, undergroundColor: { get: function () { return this._undergroundColor }, set: function (e) { this._undergroundColor = U.clone(e, this._undergroundColor) } }, undergroundColorAlphaByDistance: { get: function () { return this._undergroundColorAlphaByDistance }, set: function (e) { this._undergroundColorAlphaByDistance = wt.clone(e, this._undergroundColorAlphaByDistance) } }, translucency: { get: function () { return this._translucency } } }); function pj(e) { let t = [], n = l(e._material) && (e._material.shaderSource.match(/slope/) || e._material.shaderSource.match("normalEC")), i = [Hg, sv]; l(e._material) && (!n || e._terrainProvider.requestVertexNormals) ? (i.push(e._material.shaderSource), t.push("APPLY_MATERIAL"), e._surface._tileProvider.materialUniformMap = e._material._uniforms) : e._surface._tileProvider.materialUniformMap = void 0, i.push(hk), e._surfaceShaderSet.baseVertexShaderSource = new Ue({ sources: [Hg, sv, mk], defines: t }), e._surfaceShaderSet.baseFragmentShaderSource = new Ue({ sources: i, defines: t }), e._surfaceShaderSet.material = e._material } function Mrt(e) { return function (t, n) { let i = re.distanceSquaredTo(t.pickBoundingSphere, e), o = re.distanceSquaredTo(n.pickBoundingSphere, e); return i - o } } var Lrt = [], Frt = { start: 0, stop: 0 }; dd.prototype.pickWorldCoordinates = function (e, t, n, i) { n = y(n, !0); let o = t.mode, r = t.mapProjection, s = Lrt; s.length = 0; let a = this._surface._tilesToRender, c = a.length, u, f; for (f = 0; f < c; ++f) { u = a[f]; let p = u.data; if (!l(p)) continue; let g = p.pickBoundingSphere; if (o !== ee.SCENE3D) p.pickBoundingSphere = g = re.fromRectangleWithHeights2D(u.rectangle, r, p.tileBoundingRegion.minimumHeight, p.tileBoundingRegion.maximumHeight, g), h.fromElements(g.center.z, g.center.x, g.center.y, g.center); else if (l(p.renderedMesh)) re.clone(p.tileBoundingRegion.boundingSphere, g); else continue; let m = Gi.raySphere(e, g, Frt); l(m) && s.push(p) } s.sort(Mrt(e.origin)); let d; for (c = s.length, f = 0; f < c && (d = s[f].pick(e, t.mode, t.mapProjection, n, i), !l(d)); ++f); return d }; var Nrt = new he; dd.prototype.pick = function (e, t, n) { if (n = this.pickWorldCoordinates(e, t, !0, n), l(n) && t.mode !== ee.SCENE3D) { n = h.fromElements(n.y, n.z, n.x, n); let i = t.mapProjection.unproject(n, Nrt); n = t.globe.ellipsoid.cartographicToCartesian(i, n) } return n }; var Vrt = new h, i_e = new h, krt = new he, Urt = new En; function mj(e, t) { return l(e) && ce.contains(e.rectangle, t) ? e : void 0 } dd.prototype.getHeight = function (e) { let t = this._surface._levelZeroTiles; if (!l(t)) return; let n, i, o = t.length; for (i = 0; i < o && (n = t[i], !ce.contains(n.rectangle, e)); ++i); if (i >= o) return; let r = n; for (; l(n);)n = mj(n._southwestChild, e) || mj(n._southeastChild, e) || mj(n._northwestChild, e) || n._northeastChild, l(n) && l(n.data) && l(n.data.renderedMesh) && (r = n); if (n = r, !l(n) || !l(n.data) || !l(n.data.renderedMesh)) return; let s = this._surface._tileProvider.tilingScheme.projection, a = this._surface._tileProvider.tilingScheme.ellipsoid, c = h.fromRadians(e.longitude, e.latitude, 0, a, Vrt), u = Urt, f = a.geodeticSurfaceNormal(c, u.direction), d = a.getSurfaceNormalIntersectionWithZAxis(c, 11500, u.origin); if (!l(d)) { let g; l(n.data.tileBoundingRegion) && (g = n.data.tileBoundingRegion.minimumHeight); let m = Math.min(y(g, 0), -11500), A = h.multiplyByScalar(f, Math.abs(m) + 1, i_e); h.subtract(c, A, u.origin) } let p = n.data.pick(u, void 0, s, !1, i_e); if (!!l(p)) return a.cartesianToCartographic(p, krt).height }; dd.prototype.update = function (e) { !this.show || e.passes.render && this._surface.update(e) }; dd.prototype.beginFrame = function (e) { let t = this._surface, n = t.tileProvider, i = this.terrainProvider, o = this.showWaterEffect && i.ready && i.hasWaterMask; if (o && this._oceanNormalMapResourceDirty) { this._oceanNormalMapResourceDirty = !1; let a = this._oceanNormalMapResource, c = a.url; if (l(c)) { let u = this; a.fetchImage().then(function (f) { c === u._oceanNormalMapResource.url && (u._oceanNormalMap = u._oceanNormalMap && u._oceanNormalMap.destroy(), u._oceanNormalMap = new Rt({ context: e.context, source: f })) }) } else this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy() } let r = e.passes, s = e.mode; r.render && (this.showGroundAtmosphere ? this._zoomedOutOceanSpecularIntensity = .4 : this._zoomedOutOceanSpecularIntensity = .5, t.maximumScreenSpaceError = this.maximumScreenSpaceError, t.tileCacheSize = this.tileCacheSize, t.loadingDescendantLimit = this.loadingDescendantLimit, t.preloadAncestors = this.preloadAncestors, t.preloadSiblings = this.preloadSiblings, n.terrainProvider = this.terrainProvider, n.lightingFadeOutDistance = this.lightingFadeOutDistance, n.lightingFadeInDistance = this.lightingFadeInDistance, n.nightFadeOutDistance = this.nightFadeOutDistance, n.nightFadeInDistance = this.nightFadeInDistance, n.zoomedOutOceanSpecularIntensity = s === ee.SCENE3D ? this._zoomedOutOceanSpecularIntensity : 0, n.hasWaterMask = o, n.oceanNormalMap = this._oceanNormalMap, n.enableLighting = this.enableLighting, n.dynamicAtmosphereLighting = this.dynamicAtmosphereLighting, n.dynamicAtmosphereLightingFromSun = this.dynamicAtmosphereLightingFromSun, n.showGroundAtmosphere = this.showGroundAtmosphere, n.atmosphereLightIntensity = this.atmosphereLightIntensity, n.atmosphereRayleighCoefficient = this.atmosphereRayleighCoefficient, n.atmosphereMieCoefficient = this.atmosphereMieCoefficient, n.atmosphereRayleighScaleHeight = this.atmosphereRayleighScaleHeight, n.atmosphereMieScaleHeight = this.atmosphereMieScaleHeight, n.atmosphereMieAnisotropy = this.atmosphereMieAnisotropy, n.shadows = this.shadows, n.hueShift = this.atmosphereHueShift, n.saturationShift = this.atmosphereSaturationShift, n.brightnessShift = this.atmosphereBrightnessShift, n.fillHighlightColor = this.fillHighlightColor, n.showSkirts = this.showSkirts, n.backFaceCulling = this.backFaceCulling, n.undergroundColor = this._undergroundColor, n.undergroundColorAlphaByDistance = this._undergroundColorAlphaByDistance, n.lambertDiffuseMultiplier = this.lambertDiffuseMultiplier, t.beginFrame(e)) }; dd.prototype.render = function (e) { !this.show || (l(this._material) && this._material.update(e.context), this._surface.render(e)) }; dd.prototype.endFrame = function (e) { !this.show || e.passes.render && this._surface.endFrame(e) }; dd.prototype.isDestroyed = function () { return !1 }; dd.prototype.destroy = function () { return this._surfaceShaderSet = this._surfaceShaderSet && this._surfaceShaderSet.destroy(), this._surface = this._surface && this._surface.destroy(), this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy(), le(this) }; var Uk = dd; var Wl = `uniform sampler2D colorTexture;
varying vec2 v_textureCoordinates;
void main()
{
gl_FragColor = texture2D(colorTexture, v_textureCoordinates);
}
`; var oA = `uniform highp sampler2D u_depthTexture;
varying vec2 v_textureCoordinates;
void main()
{
gl_FragColor = czm_packDepth(texture2D(u_depthTexture, v_textureCoordinates).r);
}
`; function Rh() { this._picking = !1, this._numSamples = 1, this._tempCopyDepthTexture = void 0, this._pickColorFramebuffer = new si({ depthStencil: !0, supportsDepthTexture: !0 }), this._outputFramebuffer = new si({ depthStencil: !0, supportsDepthTexture: !0 }), this._copyDepthFramebuffer = new si, this._tempCopyDepthFramebuffer = new si, this._updateDepthFramebuffer = new si({ createColorAttachments: !1, createDepthAttachments: !1, depthStencil: !0 }), this._clearGlobeColorCommand = void 0, this._copyColorCommand = void 0, this._copyDepthCommand = void 0, this._tempCopyDepthCommand = void 0, this._updateDepthCommand = void 0, this._viewport = new Ge, this._rs = void 0, this._rsBlend = void 0, this._rsUpdate = void 0, this._useScissorTest = !1, this._scissorRectangle = void 0, this._useHdr = void 0, this._clearGlobeDepth = void 0 } Object.defineProperties(Rh.prototype, { colorFramebufferManager: { get: function () { return this._picking ? this._pickColorFramebuffer : this._outputFramebuffer } }, framebuffer: { get: function () { return this.colorFramebufferManager.framebuffer } }, depthStencilTexture: { get: function () { return this.colorFramebufferManager.getDepthStencilTexture() } }, picking: { get: function () { return this._picking }, set: function (e) { this._picking = e } } }); function zrt(e) { e._pickColorFramebuffer.destroy(), e._outputFramebuffer.destroy(), e._copyDepthFramebuffer.destroy(), e._tempCopyDepthFramebuffer.destroy(), e._updateDepthFramebuffer.destroy() } function o_e(e, t, n, i, o) { e._viewport.width = n, e._viewport.height = i; let r = !Ge.equals(e._viewport, o.viewport), s = r !== e._useScissorTest; e._useScissorTest = r, Ge.equals(e._scissorRectangle, o.viewport) || (e._scissorRectangle = Ge.clone(o.viewport, e._scissorRectangle), s = !0), (!l(e._rs) || !Ge.equals(e._viewport, e._rs.viewport) || s) && (e._rs = Ve.fromCache({ viewport: e._viewport, scissorTest: { enabled: e._useScissorTest, rectangle: e._scissorRectangle } }), e._rsBlend = Ve.fromCache({ viewport: e._viewport, scissorTest: { enabled: e._useScissorTest, rectangle: e._scissorRectangle }, blending: an.ALPHA_BLEND }), e._rsUpdate = Ve.fromCache({ viewport: e._viewport, scissorTest: { enabled: e._useScissorTest, rectangle: e._scissorRectangle }, stencilTest: { enabled: !0, frontFunction: Fn.EQUAL, frontOperation: { fail: lt.KEEP, zFail: lt.KEEP, zPass: lt.KEEP }, backFunction: Fn.NEVER, reference: vt.CESIUM_3D_TILE_MASK, mask: vt.CESIUM_3D_TILE_MASK } })), l(e._copyDepthCommand) || (e._copyDepthCommand = t.createViewportQuadCommand(oA, { uniformMap: { u_depthTexture: function () { return e.colorFramebufferManager.getDepthStencilTexture() } }, owner: e })), e._copyDepthCommand.framebuffer = e._copyDepthFramebuffer.framebuffer, e._copyDepthCommand.renderState = e._rs, l(e._copyColorCommand) || (e._copyColorCommand = t.createViewportQuadCommand(Wl, { uniformMap: { colorTexture: function () { return e.colorFramebufferManager.getColorTexture() } }, owner: e })), e._copyColorCommand.renderState = e._rs, l(e._tempCopyDepthCommand) || (e._tempCopyDepthCommand = t.createViewportQuadCommand(oA, { uniformMap: { u_depthTexture: function () { return e._tempCopyDepthTexture } }, owner: e })), e._tempCopyDepthCommand.framebuffer = e._tempCopyDepthFramebuffer.framebuffer, e._tempCopyDepthCommand.renderState = e._rs, l(e._updateDepthCommand) || (e._updateDepthCommand = t.createViewportQuadCommand(Wl, { uniformMap: { colorTexture: function () { return e._tempCopyDepthFramebuffer.getColorTexture() } }, owner: e })), e._updateDepthCommand.framebuffer = e._updateDepthFramebuffer.framebuffer, e._updateDepthCommand.renderState = e._rsUpdate, l(e._clearGlobeColorCommand) || (e._clearGlobeColorCommand = new ti({ color: new U(0, 0, 0, 0), stencil: 0, owner: e })), e._clearGlobeColorCommand.framebuffer = e.framebuffer } Rh.prototype.update = function (e, t, n, i, o, r) { let s = n.width, a = n.height, c = o ? e.halfFloatingPointTexture ? Ye.HALF_FLOAT : Ye.FLOAT : Ye.UNSIGNED_BYTE; this._numSamples = i, this.picking ? this._pickColorFramebuffer.update(e, s, a) : this._outputFramebuffer.update(e, s, a, i, c), this._copyDepthFramebuffer.update(e, s, a), o_e(this, e, s, a, t), e.uniformState.globeDepthTexture = void 0, this._useHdr = o, this._clearGlobeDepth = r }; Rh.prototype.prepareColorTextures = function (e, t) { !this.picking && this._numSamples > 1 && this._outputFramebuffer.prepareTextures(e, t) }; Rh.prototype.executeCopyDepth = function (e, t) { l(this._copyDepthCommand) && (this.prepareColorTextures(e), this._copyDepthCommand.execute(e, t), e.uniformState.globeDepthTexture = this._copyDepthFramebuffer.getColorTexture()) }; Rh.prototype.executeUpdateDepth = function (e, t, n, i) { let o = l(i) ? i : t.framebuffer.depthStencilTexture; if (n || o !== this.colorFramebufferManager.getDepthStencilTexture()) { if (l(this._updateDepthCommand)) { if (!l(this._updateDepthFramebuffer.framebuffer) || this._updateDepthFramebuffer.getDepthStencilTexture() !== o || this._updateDepthFramebuffer.getColorTexture() !== this._copyDepthFramebuffer.getColorTexture()) { let r = this._copyDepthFramebuffer.getColorTexture().width, s = this._copyDepthFramebuffer.getColorTexture().height; this._tempCopyDepthFramebuffer.destroy(), this._tempCopyDepthFramebuffer.update(e, r, s); let a = this._copyDepthFramebuffer.getColorTexture(); this._updateDepthFramebuffer.setColorTexture(a, 0), this._updateDepthFramebuffer.setDepthStencilTexture(o), this._updateDepthFramebuffer.update(e, r, s), o_e(this, e, r, s, t) } this._tempCopyDepthTexture = o, this._tempCopyDepthCommand.execute(e, t), this._updateDepthCommand.execute(e, t) } return } l(this._copyDepthCommand) && this._copyDepthCommand.execute(e, t) }; Rh.prototype.executeCopyColor = function (e, t) { l(this._copyColorCommand) && this._copyColorCommand.execute(e, t) }; Rh.prototype.clear = function (e, t, n) { let i = this._clearGlobeColorCommand; l(i) && (U.clone(n, i.color), this.colorFramebufferManager.clear(e, i, t)) }; Rh.prototype.isDestroyed = function () { return !1 }; Rh.prototype.destroy = function () { return zrt(this), l(this._copyColorCommand) && (this._copyColorCommand.shaderProgram = this._copyColorCommand.shaderProgram.destroy()), l(this._copyDepthCommand) && (this._copyDepthCommand.shaderProgram = this._copyDepthCommand.shaderProgram.destroy()), l(this._tempCopyDepthCommand) && (this._tempCopyDepthCommand.shaderProgram = this._tempCopyDepthCommand.shaderProgram.destroy()), l(this._updateDepthCommand) && (this._updateDepthCommand.shaderProgram = this._updateDepthCommand.shaderProgram.destroy()), le(this) }; var zk = Rh; function rA() { this._framebuffer = new si({ depthStencil: !0, supportsDepthTexture: !0 }), this._packedDepthFramebuffer = new si, this._renderState = void 0, this._packedDepthCommand = void 0, this._clearCommand = void 0, this._viewport = new Ge, this._useScissorTest = !1, this._scissorRectangle = void 0, this._useHdr = void 0 } Object.defineProperties(rA.prototype, { classificationTexture: { get: function () { return this._framebuffer.getColorTexture() } }, classificationFramebuffer: { get: function () { return this._framebuffer.framebuffer } }, packedDepthFramebuffer: { get: function () { return this._packedDepthFramebuffer.framebuffer } }, depthStencilTexture: { get: function () { return this._framebuffer.getDepthStencilTexture() } }, depthStencilRenderbuffer: { get: function () { return this._framebuffer.getDepthStencilRenderbuffer() } }, packedDepthTexture: { get: function () { return this._packedDepthFramebuffer.getColorTexture() } } }); function Hrt(e) { e._framebuffer.destroy(), e._packedDepthFramebuffer.destroy() } function Grt(e, t, n, i, o) { let r = o ? t.halfFloatingPointTexture ? Ye.HALF_FLOAT : Ye.FLOAT : Ye.UNSIGNED_BYTE; e._framebuffer.update(t, n, i, 1, r), e._packedDepthFramebuffer.update(t, n, i) } function Wrt(e, t, n, i, o) { e._viewport.width = n, e._viewport.height = i; let r = !Ge.equals(e._viewport, o.viewport), s = r !== e._useScissorTest; e._useScissorTest = r, Ge.equals(e._scissorRectangle, o.viewport) || (e._scissorRectangle = Ge.clone(o.viewport, e._scissorRectangle), s = !0), (!l(e._renderState) || !Ge.equals(e._viewport, e._renderState.viewport) || s) && (e._renderState = Ve.fromCache({ viewport: e._viewport, scissorTest: { enabled: e._useScissorTest, rectangle: e._scissorRectangle } })), l(e._packedDepthCommand) || (e._packedDepthCommand = t.createViewportQuadCommand(oA, { uniformMap: { u_depthTexture: function () { return e.depthStencilTexture } }, owner: e })), l(e._clearCommand) || (e._clearCommand = new ti({ color: new U(0, 0, 0, 0), depth: 1, stencil: 0, owner: e })), e._packedDepthCommand.framebuffer = e._packedDepthFramebuffer.framebuffer, e._packedDepthCommand.renderState = e._renderState, e._clearCommand.framebuffer = e.classificationFramebuffer, e._clearCommand.renderState = e._renderState } rA.prototype.updateAndClear = function (e, t, n, i) { let o = t.width, r = t.height; Grt(this, n, o, r, e), Wrt(this, n, o, r, i), this._useHdr = e }; rA.prototype.clearClassification = function (e, t) { this._clearCommand.execute(e, t) }; rA.prototype.packDepth = function (e, t) { return this._packedDepthCommand.execute(e, t), this.packedDepthTexture }; rA.prototype.isDestroyed = function () { return !1 }; rA.prototype.destroy = function () { return Hrt(this), le(this) }; var Hk = rA; var Us = { OPAQUE_FRONT_FACE: 0, OPAQUE_BACK_FACE: 1, DEPTH_ONLY_FRONT_FACE: 2, DEPTH_ONLY_BACK_FACE: 3, DEPTH_ONLY_FRONT_AND_BACK_FACE: 4, TRANSLUCENT_FRONT_FACE: 5, TRANSLUCENT_BACK_FACE: 6, TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST: 7, TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST: 8, PICK_FRONT_FACE: 9, PICK_BACK_FACE: 10, DERIVED_COMMANDS_MAXIMUM_LENGTH: 11 }, sA = Us.DERIVED_COMMANDS_MAXIMUM_LENGTH, m_e = ["opaqueFrontFaceCommand", "opaqueBackFaceCommand", "depthOnlyFrontFaceCommand", "depthOnlyBackFaceCommand", "depthOnlyFrontAndBackFaceCommand", "translucentFrontFaceCommand", "translucentBackFaceCommand", "translucentFrontFaceManualDepthTestCommand", "translucentBackFaceManualDepthTestCommand", "pickFrontFaceCommand", "pickBackFaceCommand"]; function aA() { this._frontFaceAlphaByDistance = new wt(0, 1, 0, 1), this._backFaceAlphaByDistance = new wt(0, 1, 0, 1), this._frontFaceTranslucent = !1, this._backFaceTranslucent = !1, this._requiresManualDepthTest = !1, this._sunVisibleThroughGlobe = !1, this._environmentVisible = !1, this._useDepthPlane = !1, this._numberOfTextureUniforms = 0, this._globeTranslucencyFramebuffer = void 0, this._rectangle = ce.clone(ce.MAX_VALUE), this._derivedCommandKey = 0, this._derivedCommandsDirty = !1, this._derivedCommandPacks = void 0, this._derivedCommandTypes = new Array(sA), this._derivedBlendCommandTypes = new Array(sA), this._derivedPickCommandTypes = new Array(sA), this._derivedCommandTypesToUpdate = new Array(sA), this._derivedCommandsLength = 0, this._derivedBlendCommandsLength = 0, this._derivedPickCommandsLength = 0, this._derivedCommandsToUpdateLength = 0 } Object.defineProperties(aA.prototype, { frontFaceAlphaByDistance: { get: function () { return this._frontFaceAlphaByDistance } }, backFaceAlphaByDistance: { get: function () { return this._backFaceAlphaByDistance } }, translucent: { get: function () { return this._frontFaceTranslucent } }, sunVisibleThroughGlobe: { get: function () { return this._sunVisibleThroughGlobe } }, environmentVisible: { get: function () { return this._environmentVisible } }, useDepthPlane: { get: function () { return this._useDepthPlane } }, numberOfTextureUniforms: { get: function () { return this._numberOfTextureUniforms } }, rectangle: { get: function () { return this._rectangle } } }); aA.prototype.update = function (e) { let t = e.globe; if (!l(t) || !t.show) { this._frontFaceTranslucent = !1, this._backFaceTranslucent = !1, this._sunVisibleThroughGlobe = !0, this._environmentVisible = !0, this._useDepthPlane = !1; return } this._frontFaceAlphaByDistance = r_e(t.translucency.enabled, t.translucency.frontFaceAlpha, t.translucency.frontFaceAlphaByDistance, this._frontFaceAlphaByDistance), this._backFaceAlphaByDistance = r_e(t.translucency.enabled, t.translucency.backFaceAlpha, t.translucency.backFaceAlphaByDistance, this._backFaceAlphaByDistance), this._frontFaceTranslucent = s_e(t.translucency.enabled, this._frontFaceAlphaByDistance, t), this._backFaceTranslucent = s_e(t.translucency.enabled, this._backFaceAlphaByDistance, t), this._requiresManualDepthTest = Xrt(this, e, t), this._sunVisibleThroughGlobe = jrt(this, e), this._environmentVisible = qrt(this, e), this._useDepthPlane = Yrt(this, e), this._numberOfTextureUniforms = Krt(this), this._rectangle = ce.clone(t.translucency.rectangle, this._rectangle), Jrt(this, e) }; function r_e(e, t, n, i) { return e ? l(n) ? (wt.clone(n, i), i.nearValue *= t, i.farValue *= t, i) : (i.nearValue = t, i.farValue = t, i) : (i.nearValue = 1, i.farValue = 1, i) } function s_e(e, t, n) { return e && (n.baseColor.alpha < 1 || t.nearValue < 1 || t.farValue < 1) } function jrt(e, t) { let n = e._frontFaceTranslucent, i = e._backFaceTranslucent; return n && (t.cameraUnderground || i) } function qrt(e, t) { return !t.cameraUnderground || e._frontFaceTranslucent } function Yrt(e, t) { return !t.cameraUnderground && !e._frontFaceTranslucent } function Xrt(e, t, n) { return e._frontFaceTranslucent && !e._backFaceTranslucent && !n.depthTestAgainstTerrain && t.mode !== ee.SCENE2D && t.context.depthTexture } function Krt(e) { let t = 0; return e._frontFaceTranslucent && ++t, e._requiresManualDepthTest && ++t, t } function Jrt(e, t) { e._derivedCommandsLength = _j(e, t, !1, !1, e._derivedCommandTypes), e._derivedBlendCommandsLength = _j(e, t, !0, !1, e._derivedBlendCommandTypes), e._derivedPickCommandsLength = _j(e, t, !1, !0, e._derivedPickCommandTypes); let n, i = 0; for (n = 0; n < e._derivedCommandsLength; ++n)i |= 1 << e._derivedCommandTypes[n]; for (n = 0; n < e._derivedBlendCommandsLength; ++n)i |= 1 << e._derivedBlendCommandTypes[n]; for (n = 0; n < e._derivedPickCommandsLength; ++n)i |= 1 << e._derivedPickCommandTypes[n]; let o = 0; for (n = 0; n < sA; ++n)(i & 1 << n) > 0 && (e._derivedCommandTypesToUpdate[o++] = n); e._derivedCommandsToUpdateLength = o; let r = i !== e._derivedCommandKey; e._derivedCommandKey = i, e._derivedCommandsDirty = r, !l(e._derivedCommandPacks) && e._frontFaceTranslucent && (e._derivedCommandPacks = fst()) } function _j(e, t, n, i, o) { let r = 0, s = e._frontFaceTranslucent, a = e._backFaceTranslucent; if (!s) return r; let c = t.cameraUnderground, u = e._requiresManualDepthTest, f = i ? Us.PICK_FRONT_FACE : u ? Us.TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST : Us.TRANSLUCENT_FRONT_FACE, d = i ? Us.PICK_BACK_FACE : u ? Us.TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST : Us.TRANSLUCENT_BACK_FACE; return t.mode === ee.SCENE2D ? (o[r++] = Us.DEPTH_ONLY_FRONT_FACE, o[r++] = f, r) : (a ? (n || (o[r++] = Us.DEPTH_ONLY_FRONT_AND_BACK_FACE), c ? (o[r++] = f, o[r++] = d) : (o[r++] = d, o[r++] = f)) : c ? (n || (o[r++] = Us.DEPTH_ONLY_BACK_FACE), o[r++] = Us.OPAQUE_FRONT_FACE, o[r++] = d) : (n || (o[r++] = Us.DEPTH_ONLY_FRONT_FACE), o[r++] = Us.OPAQUE_BACK_FACE, o[r++] = f), r) } function ef(e, t) { let n = e.indexOf(t); n > -1 && e.splice(n, 1) } function a_e(e, t) { return e.indexOf(t) > -1 } function Zrt(e, t) { ef(e.defines, "TRANSLUCENT"), ef(t.defines, "TRANSLUCENT") } function Qrt(e, t) { ef(e.defines, "GROUND_ATMOSPHERE"), ef(t.defines, "GROUND_ATMOSPHERE"), ef(e.defines, "FOG"), ef(t.defines, "FOG"), ef(e.defines, "TRANSLUCENT"), ef(t.defines, "TRANSLUCENT") } function gj(e, t) {
        if (a_e(t.defines, "TILE_LIMIT_RECTANGLE") || a_e(t.defines, "ENABLE_CLIPPING_PLANES")) return; let n = `void main() 
{ 
    gl_FragColor = vec4(1.0); 
} 
`; t.sources = [n]
    } function yj(e, t) {
        let n = t.sources, i = n.length; for (let r = 0; r < i; ++r)n[r] = Ue.replaceMain(n[r], "czm_globe_translucency_main"); let o = `

uniform sampler2D u_classificationTexture; 
void main() 
{ 
    vec2 st = gl_FragCoord.xy / czm_viewport.zw; 
#ifdef MANUAL_DEPTH_TEST 
    float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, st)); 
    if (logDepthOrDepth != 0.0) 
    { 
        vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth); 
        float depthEC = eyeCoordinate.z / eyeCoordinate.w; 
        if (v_positionEC.z < depthEC) 
        { 
            discard; 
        } 
    } 
#endif 
    czm_globe_translucency_main(); 
    vec4 classificationColor = texture2D(u_classificationTexture, st); 
    if (classificationColor.a > 0.0) 
    { 
        // Reverse premultiplication process to get the correct composited result of the classification primitives 
        classificationColor.rgb /= classificationColor.a; 
    } 
    gl_FragColor = classificationColor * vec4(classificationColor.aaa, 1.0) + gl_FragColor * (1.0 - classificationColor.a); 
} 
`; n.push(o)
    } function p_e(e, t) { yj(e, t), ef(e.defines, "GROUND_ATMOSPHERE"), ef(t.defines, "GROUND_ATMOSPHERE"), ef(e.defines, "FOG"), ef(t.defines, "FOG") } function $rt(e, t) { yj(e, t), e.defines.push("GENERATE_POSITION"), t.defines.push("MANUAL_DEPTH_TEST") } function est(e, t) { p_e(e, t), e.defines.push("GENERATE_POSITION"), t.defines.push("MANUAL_DEPTH_TEST") } function c_e(e, t) {
        let n = `uniform sampler2D u_classificationTexture; 
void main() 
{ 
    vec2 st = gl_FragCoord.xy / czm_viewport.zw; 
    vec4 pickColor = texture2D(u_classificationTexture, st); 
    if (pickColor == vec4(0.0)) 
    { 
        discard; 
    } 
    gl_FragColor = pickColor; 
} 
`; t.sources = [n]
    } function tst(e, t, n, i, o, r) { if (!l(o)) return t; if (!i && l(n)) return n; let s = e.shaderCache.getDerivedShaderProgram(t, r); if (!l(s)) { let a = t._attributeLocations, c = t.vertexShaderSource.clone(), u = t.fragmentShaderSource.clone(); c.defines = l(c.defines) ? c.defines.slice(0) : [], u.defines = l(u.defines) ? u.defines.slice(0) : [], o(c, u), s = e.shaderCache.createDerivedShaderProgram(t, r, { vertexShaderSource: c, fragmentShaderSource: u, attributeLocations: a }) } return s } function nst(e) { e.cull.face = gi.BACK, e.cull.enabled = !0 } function ist(e) { e.cull.face = gi.FRONT, e.cull.enabled = !0 } function ost(e) { e.cull.face = gi.BACK, e.cull.enabled = !0, e.colorMask = { red: !1, green: !1, blue: !1, alpha: !1 } } function rst(e) { e.cull.face = gi.FRONT, e.cull.enabled = !0, e.colorMask = { red: !1, green: !1, blue: !1, alpha: !1 } } function sst(e) { e.cull.enabled = !1, e.colorMask = { red: !1, green: !1, blue: !1, alpha: !1 } } function l_e(e) { e.cull.face = gi.BACK, e.cull.enabled = !0, e.depthMask = !1, e.blending = an.ALPHA_BLEND } function u_e(e) { e.cull.face = gi.FRONT, e.cull.enabled = !0, e.depthMask = !1, e.blending = an.ALPHA_BLEND } function ast(e) { e.cull.face = gi.BACK, e.cull.enabled = !0, e.blending.enabled = !1 } function cst(e) { e.cull.face = gi.FRONT, e.cull.enabled = !0, e.blending.enabled = !1 } function lst(e, t, n, i, o) { if (!l(i)) return e; if (!n && l(t)) return t; let r = o[e.id]; if (!l(r)) { let s = Ve.getState(e); i(s), r = Ve.fromCache(s), o[e.id] = r } return r } function LE(e) { return { u_classificationTexture: function () { return e._globeTranslucencyFramebuffer.classificationTexture } } } function ust(e, t, n, i, o) { return l(o) ? !i && l(n) ? n : yt(t, o(e), !1) : t } function hd(e) { this.pass = e.pass, this.pickOnly = e.pickOnly, this.getShaderProgramFunction = e.getShaderProgramFunction, this.getRenderStateFunction = e.getRenderStateFunction, this.getUniformMapFunction = e.getUniformMapFunction, this.renderStateCache = {} } function fst() { return [new hd({ pass: xe.GLOBE, pickOnly: !1, getShaderProgramFunction: Zrt, getRenderStateFunction: nst, getUniformMapFunction: void 0 }), new hd({ pass: xe.GLOBE, pickOnly: !1, getShaderProgramFunction: Qrt, getRenderStateFunction: ist, getUniformMapFunction: void 0 }), new hd({ pass: xe.GLOBE, pickOnly: !1, getShaderProgramFunction: gj, getRenderStateFunction: ost, getUniformMapFunction: void 0 }), new hd({ pass: xe.GLOBE, pickOnly: !1, getShaderProgramFunction: gj, getRenderStateFunction: rst, getUniformMapFunction: void 0 }), new hd({ pass: xe.GLOBE, pickOnly: !1, getShaderProgramFunction: gj, getRenderStateFunction: sst, getUniformMapFunction: void 0 }), new hd({ pass: xe.TRANSLUCENT, pickOnly: !1, getShaderProgramFunction: yj, getRenderStateFunction: l_e, getUniformMapFunction: LE }), new hd({ pass: xe.TRANSLUCENT, pickOnly: !1, getShaderProgramFunction: p_e, getRenderStateFunction: u_e, getUniformMapFunction: LE }), new hd({ pass: xe.TRANSLUCENT, pickOnly: !1, getShaderProgramFunction: $rt, getRenderStateFunction: l_e, getUniformMapFunction: LE }), new hd({ pass: xe.TRANSLUCENT, pickOnly: !1, getShaderProgramFunction: est, getRenderStateFunction: u_e, getUniformMapFunction: LE }), new hd({ pass: xe.TRANSLUCENT, pickOnly: !0, getShaderProgramFunction: c_e, getRenderStateFunction: ast, getUniformMapFunction: LE }), new hd({ pass: xe.TRANSLUCENT, pickOnly: !0, getShaderProgramFunction: c_e, getRenderStateFunction: cst, getUniformMapFunction: LE })] } var f_e = new Array(sA), d_e = new Array(sA); aA.prototype.updateDerivedCommands = function (e, t) { let n = this._derivedCommandTypesToUpdate, i = this._derivedCommandsToUpdateLength; if (i !== 0) { for (let o = 0; o < i; ++o)d_e[o] = this._derivedCommandPacks[n[o]], f_e[o] = m_e[n[o]]; dst(this, e, i, n, f_e, d_e, t) } }; function dst(e, t, n, i, o, r, s) { let a = t.derivedCommands.globeTranslucency, c = e._derivedCommandsDirty; if (t.dirty || !l(a) || c) { t.dirty = !1, l(a) || (a = {}, t.derivedCommands.globeTranslucency = a); let u = s.frameNumber, f = y(a.uniformMapDirtyFrame, 0), d = y(a.shaderProgramDirtyFrame, 0), p = y(a.renderStateDirtyFrame, 0), g = a.uniformMap !== t.uniformMap, m = a.shaderProgramId !== t.shaderProgram.id, A = a.renderStateId !== t.renderState.id; g && (a.uniformMapDirtyFrame = u), m && (a.shaderProgramDirtyFrame = u), A && (a.renderStateDirtyFrame = u), a.uniformMap = t.uniformMap, a.shaderProgramId = t.shaderProgram.id, a.renderStateId = t.renderState.id; for (let C = 0; C < n; ++C) { let x = r[C], T = i[C], b = o[C], S = a[b], D, P, B; l(S) ? (D = S.uniformMap, P = S.shaderProgram, B = S.renderState) : (D = void 0, P = void 0, B = void 0), S = $e.shallowClone(t, S), a[b] = S; let R = y(S.derivedCommands.uniformMapDirtyFrame, 0), M = y(S.derivedCommands.shaderProgramDirtyFrame, 0), L = y(S.derivedCommands.renderStateDirtyFrame, 0), _ = g || R < f, E = m || M < d, w = A || L < p; _ && (S.derivedCommands.uniformMapDirtyFrame = u), E && (S.derivedCommands.shaderProgramDirtyFrame = u), w && (S.derivedCommands.renderStateDirtyFrame = u), S.derivedCommands.type = T, S.pass = x.pass, S.pickOnly = x.pickOnly, S.uniformMap = ust(e, t.uniformMap, D, _, x.getUniformMapFunction), S.shaderProgram = tst(s.context, t.shaderProgram, P, E, x.getShaderProgramFunction, b), S.renderState = lst(t.renderState, B, w, x.getRenderStateFunction, x.renderStateCache) } } } aA.prototype.pushDerivedCommands = function (e, t, n) { let i = n.passes.pick; if (i && t) return; let o = this._derivedCommandTypes, r = this._derivedCommandsLength; if (i ? (o = this._derivedPickCommandTypes, r = this._derivedPickCommandsLength) : t && (o = this._derivedBlendCommandTypes, r = this._derivedBlendCommandsLength), r === 0) { n.commandList.push(e); return } let s = e.derivedCommands.globeTranslucency; for (let a = 0; a < r; ++a) { let c = m_e[o[a]]; n.commandList.push(s[c]) } }; function __e(e, t, n, i, o, r, s) { for (let a = 0; a < t; ++a) { let c = e[a], u = c.derivedCommands.type; (!l(s) || s.indexOf(u) > -1) && n(c, i, o, r) } } function h_e(e, t, n, i, o, r) { for (let s = 0; s < t; ++s)n(e[s], i, o, r) } var hst = [Us.OPAQUE_FRONT_FACE, Us.OPAQUE_BACK_FACE], mst = [Us.DEPTH_ONLY_FRONT_FACE, Us.DEPTH_ONLY_BACK_FACE, Us.DEPTH_ONLY_FRONT_AND_BACK_FACE]; aA.prototype.executeGlobeCommands = function (e, t, n, i, o) { let r = i.context, s = e.commands[xe.GLOBE], a = e.indices[xe.GLOBE]; a !== 0 && (this._globeTranslucencyFramebuffer = n, n.clearClassification(r, o), __e(s, a, t, i, r, o, hst)) }; aA.prototype.executeGlobeClassificationCommands = function (e, t, n, i, o) { let r = i.context, s = e.commands[xe.GLOBE], a = e.indices[xe.GLOBE], c = e.commands[xe.TERRAIN_CLASSIFICATION], u = e.indices[xe.TERRAIN_CLASSIFICATION]; if (a === 0 || u === 0) return; let f = this._frontFaceTranslucent, d = this._backFaceTranslucent; if ((!f || !d) && h_e(c, u, t, i, r, o), !f && !d) return; this._globeTranslucencyFramebuffer = n; let p = r.uniformState.globeDepthTexture, g = o.framebuffer; if (o.framebuffer = n.classificationFramebuffer, __e(s, a, t, i, r, o, mst), r.depthTexture) { let m = n.packDepth(r, o); r.uniformState.globeDepthTexture = m } h_e(c, u, t, i, r, o), r.uniformState.globeDepthTexture = p, o.framebuffer = g }; var Gk = aA; var g_e = po(i7(), 1); function Aj() { this._image = new Image } Aj.prototype.isReady = function () { return !0 }; Aj.prototype.shouldDiscardImage = function (e) { return e === this._image }; function mv(e) { e = y(e, y.EMPTY_OBJECT), this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0; let t; if (l(e.metadata)) t = e.metadata; else { let r = Pe.createIfNeeded(e.url); t = new Ih(r) } this._metadata = t, this._tileDiscardPolicy = e.tileDiscardPolicy, this._tilingScheme = new Hi({ numberOfLevelZeroTilesX: 2, numberOfLevelZeroTilesY: 2, rectangle: new ce(-I.PI, -I.PI, I.PI, I.PI), ellipsoid: e.ellipsoid }); let n = e.credit; typeof n == "string" && (n = new Xt(n)), this._credit = n, this._tileWidth = 256, this._tileHeight = 256, this._maximumLevel = 23, l(this._tileDiscardPolicy) || (this._tileDiscardPolicy = new Aj), this._errorEvent = new _e, this._ready = !1; let i = this, o; this._readyPromise = t.readyPromise.then(function (r) { if (!t.imageryPresent) { let s = new fe(`The server ${t.url} doesn't have imagery`); return o = Gn.reportError(o, i, i._errorEvent, s.message, void 0, void 0, void 0, s), Promise.reject(s) } return Gn.reportSuccess(o), i._ready = r, r }).catch(function (r) { return o = Gn.reportError(o, i, i._errorEvent, r.message, void 0, void 0, void 0, r), Promise.reject(r) }) } Object.defineProperties(mv.prototype, { url: { get: function () { return this._metadata.url } }, proxy: { get: function () { return this._metadata.proxy } }, tileWidth: { get: function () { return this._tileWidth } }, tileHeight: { get: function () { return this._tileHeight } }, maximumLevel: { get: function () { return this._maximumLevel } }, minimumLevel: { get: function () { return 0 } }, tilingScheme: { get: function () { return this._tilingScheme } }, rectangle: { get: function () { return this._tilingScheme.rectangle } }, tileDiscardPolicy: { get: function () { return this._tileDiscardPolicy } }, errorEvent: { get: function () { return this._errorEvent } }, ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } }, credit: { get: function () { return this._credit } }, hasAlphaChannel: { get: function () { return !1 } } }); mv.prototype.getTileCredits = function (e, t, n) { let i = this._metadata, o = i.getTileInformation(e, t, n); if (l(o)) { let r = i.providers[o.imageryProvider]; if (l(r)) return [r] } }; mv.prototype.requestImage = function (e, t, n, i) { let o = this._tileDiscardPolicy._image, r = this._metadata, s = Ih.tileXYToQuadKey(e, t, n), a = r.getTileInformation(e, t, n); if (!l(a)) { if (r.isValid(s)) { let u = new jo({ throttle: i.throttle, throttleByServer: i.throttleByServer, type: i.type, priorityFunction: i.priorityFunction }); r.populateSubtree(e, t, n, u); return } return Promise.resolve(o) } if (!a.hasImagery()) return Promise.resolve(o); let c = pst(this, a, e, t, n, i).fetchArrayBuffer(); if (!!l(c)) return c.then(function (u) { k3(r.key, u); let f = new Uint8Array(u), d, p = r.protoImagery; if ((!l(p) || !p) && (d = _st(f)), !l(d) && (!l(p) || p)) { let g = gst(f); d = g.imageType, f = g.imageData } return !l(d) || !l(f) ? o : WC({ uint8Array: f, format: d, flipY: !0 }) }) }; mv.prototype.pickFeatures = function (e, t, n, i, o) { }; function pst(e, t, n, i, o, r) { let s = Ih.tileXYToQuadKey(n, i, o), a = t.imageryVersion; return a = l(a) && a > 0 ? a : 1, e._metadata.resource.getDerivedResource({ url: `flatfile?f1-0${s}-i.${a.toString()}`, request: r }) } function _st(e) { let t = "JFIF"; if (e[6] === t.charCodeAt(0) && e[7] === t.charCodeAt(1) && e[8] === t.charCodeAt(2) && e[9] === t.charCodeAt(3)) return "image/jpeg"; let n = "PNG"; if (e[1] === n.charCodeAt(0) && e[2] === n.charCodeAt(1) && e[3] === n.charCodeAt(2)) return "image/png" } function gst(e) { let t = g_e.Reader.create(e), n = t.len, i = {}; for (; t.pos < n;) { let s = t.uint32(), a; switch (s >>> 3) { case 1: i.imageType = t.uint32(); break; case 2: i.imageData = t.bytes(); break; case 3: i.alphaType = t.uint32(); break; case 4: i.imageAlpha = t.bytes(); break; case 5: if (a = i.copyrightIds, l(a) || (a = i.copyrightIds = []), (s & 7) === 2) { let c = t.uint32() + t.pos; for (; t.pos < c;)a.push(t.uint32()) } else a.push(t.uint32()); break; default: t.skipType(s & 7); break } } let o = i.imageType; if (l(o)) switch (o) { case 0: i.imageType = "image/jpeg"; break; case 4: i.imageType = "image/png"; break; default: throw new fe("GoogleEarthEnterpriseImageryProvider: Unsupported image type.") }let r = i.alphaType; return l(r) && r !== 0 && (console.log("GoogleEarthEnterpriseImageryProvider: External alpha not supported."), delete i.alphaType, delete i.imageAlpha), i } var y_e = mv; var yst = new U(1, 1, 1, .4), Ast = new U(0, 1, 0, .05), Cst = new U(0, .5, 0, .2); function cA(e) { e = y(e, y.EMPTY_OBJECT), this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0, this._tilingScheme = l(e.tilingScheme) ? e.tilingScheme : new Hi({ ellipsoid: e.ellipsoid }), this._cells = y(e.cells, 8), this._color = y(e.color, yst), this._glowColor = y(e.glowColor, Ast), this._glowWidth = y(e.glowWidth, 6), this._backgroundColor = y(e.backgroundColor, Cst), this._errorEvent = new _e, this._tileWidth = y(e.tileWidth, 256), this._tileHeight = y(e.tileHeight, 256), this._canvasSize = y(e.canvasSize, 256), this._canvas = this._createGridCanvas(), this._readyPromise = Promise.resolve(!0) } Object.defineProperties(cA.prototype, { proxy: { get: function () { } }, tileWidth: { get: function () { return this._tileWidth } }, tileHeight: { get: function () { return this._tileHeight } }, maximumLevel: { get: function () { } }, minimumLevel: { get: function () { } }, tilingScheme: { get: function () { return this._tilingScheme } }, rectangle: { get: function () { return this._tilingScheme.rectangle } }, tileDiscardPolicy: { get: function () { } }, errorEvent: { get: function () { return this._errorEvent } }, ready: { get: function () { return !0 } }, readyPromise: { get: function () { return this._readyPromise } }, credit: { get: function () { } }, hasAlphaChannel: { get: function () { return !0 } } }); cA.prototype._drawGrid = function (e) { let n = this._canvasSize; for (let i = 0; i <= this._cells; ++i) { let o = i / this._cells, r = 1 + o * (n - 1); e.moveTo(r, 0), e.lineTo(r, n), e.moveTo(0, r), e.lineTo(n, r) } e.stroke() }; cA.prototype._createGridCanvas = function () { let e = document.createElement("canvas"); e.width = this._canvasSize, e.height = this._canvasSize; let t = 0, n = this._canvasSize, i = e.getContext("2d"), o = this._backgroundColor.toCssColorString(); i.fillStyle = o, i.fillRect(t, t, n, n); let r = this._glowColor.toCssColorString(); i.strokeStyle = r, i.lineWidth = this._glowWidth, i.strokeRect(t, t, n, n), this._drawGrid(i), i.lineWidth = this._glowWidth * .5, i.strokeRect(t, t, n, n), this._drawGrid(i); let s = this._color.toCssColorString(); return i.strokeStyle = s, i.lineWidth = 2, i.strokeRect(t, t, n, n), i.lineWidth = 1, this._drawGrid(i), e }; cA.prototype.getTileCredits = function (e, t, n) { }; cA.prototype.requestImage = function (e, t, n, i) { return Promise.resolve(this._canvas) }; cA.prototype.pickFeatures = function (e, t, n, i, o) { }; var A_e = cA; function Mh() { this._numSamples = 1, this.previousFramebuffer = void 0, this._previousFramebuffer = void 0, this._depthStencilTexture = void 0, this._depthStencilRenderbuffer = void 0, this._fbo = new si({ depthStencil: !0, createDepthAttachments: !1 }), this._fboClassified = new si({ depthStencil: !0, createDepthAttachments: !1 }), this._rsUnclassified = void 0, this._rsClassified = void 0, this._unclassifiedCommand = void 0, this._classifiedCommand = void 0, this._translucentCommand = void 0, this._clearColorCommand = new ti({ color: new U(0, 0, 0, 0), owner: this }), this._clearCommand = new ti({ color: new U(0, 0, 0, 0), depth: 1, stencil: 0 }); let e = this; this._uniformMap = { colorTexture: function () { return e._fbo.getColorTexture() }, depthTexture: function () { return e._depthStencilTexture }, classifiedTexture: function () { return e._fboClassified.getColorTexture() } } } Object.defineProperties(Mh.prototype, { unclassifiedCommand: { get: function () { return this._unclassifiedCommand } } }); Mh.isTranslucencySupported = function (e) { return e.depthTexture && e.fragmentDepth }; var xst = { depthMask: !1, stencilTest: { enabled: !0, frontFunction: Fn.EQUAL, frontOperation: { fail: lt.KEEP, zFail: lt.KEEP, zPass: lt.KEEP }, backFunction: Fn.NEVER, reference: 0, mask: vt.CLASSIFICATION_MASK }, blending: an.ALPHA_BLEND }, Tst = { depthMask: !1, stencilTest: { enabled: !0, frontFunction: Fn.NOT_EQUAL, frontOperation: { fail: lt.KEEP, zFail: lt.KEEP, zPass: lt.KEEP }, backFunction: Fn.NEVER, reference: 0, mask: vt.CLASSIFICATION_MASK }, blending: an.ALPHA_BLEND }, Est = { depthMask: !0, depthTest: { enabled: !0 }, stencilTest: vt.setCesium3DTileBit(), stencilMask: vt.CESIUM_3D_TILE_MASK, blending: an.ALPHA_BLEND }, bst = `#extension GL_EXT_frag_depth : enable
uniform sampler2D colorTexture;
uniform sampler2D depthTexture;
uniform sampler2D classifiedTexture;
varying vec2 v_textureCoordinates;
void main()
{
    vec4 color = texture2D(colorTexture, v_textureCoordinates);
    if (color.a == 0.0)
    {
        discard;
    }
    bool isClassified = all(equal(texture2D(classifiedTexture, v_textureCoordinates), vec4(0.0)));
#ifdef UNCLASSIFIED
    vec4 highlightColor = czm_invertClassificationColor;
    if (isClassified)
    {
        discard;
    }
#else
    vec4 highlightColor = vec4(1.0);
    if (!isClassified)
    {
        discard;
    }
#endif
    gl_FragColor = color * highlightColor;
    gl_FragDepthEXT = texture2D(depthTexture, v_textureCoordinates).r;
}
`, Sst = `uniform sampler2D colorTexture;
varying vec2 v_textureCoordinates;
void main()
{
    vec4 color = texture2D(colorTexture, v_textureCoordinates);
    if (color.a == 0.0)
    {
        discard;
    }
#ifdef UNCLASSIFIED
    gl_FragColor = color * czm_invertClassificationColor;
#else
    gl_FragColor = color;
#endif
}
`; Mh.prototype.update = function (e, t, n) { let i = this._fbo.getColorTexture(), o = this.previousFramebuffer !== this._previousFramebuffer; this._previousFramebuffer = this.previousFramebuffer; let r = this._numSamples !== t, s = e.drawingBufferWidth, a = e.drawingBufferHeight, c = !l(i) || i.width !== s || i.height !== a; if ((c || o || r) && (this._numSamples = t, this._depthStencilTexture = this._depthStencilTexture && this._depthStencilTexture.destroy(), this._depthStencilRenderbuffer = this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy(), l(this._previousFramebuffer) || (this._depthStencilTexture = new Rt({ context: e, width: s, height: a, pixelFormat: ht.DEPTH_STENCIL, pixelDatatype: Ye.UNSIGNED_INT_24_8 }), t > 1 && (this._depthStencilRenderbuffer = new hu({ context: e, width: s, height: a, format: Uc.DEPTH24_STENCIL8, numSamples: t })))), !l(this._fbo.framebuffer) || c || o || r) { this._fbo.destroy(), this._fboClassified.destroy(); let u, f; l(this._previousFramebuffer) ? (u = n.getDepthStencilTexture(), f = n.getDepthStencilRenderbuffer()) : (u = this._depthStencilTexture, f = this._depthStencilRenderbuffer), this._fbo.setDepthStencilTexture(u), l(f) && this._fbo.setDepthStencilRenderbuffer(f), this._fbo.update(e, s, a, t), l(this._previousFramebuffer) || (this._fboClassified.setDepthStencilTexture(u), this._fboClassified.update(e, s, a)) } if (l(this._rsUnclassified) || (this._rsUnclassified = Ve.fromCache(xst), this._rsClassified = Ve.fromCache(Tst), this._rsDefault = Ve.fromCache(Est)), !l(this._unclassifiedCommand) || o || r) { l(this._unclassifiedCommand) && (this._unclassifiedCommand.shaderProgram = this._unclassifiedCommand.shaderProgram && this._unclassifiedCommand.shaderProgram.destroy(), this._classifiedCommand.shaderProgram = this._classifiedCommand.shaderProgram && this._classifiedCommand.shaderProgram.destroy()); let u = l(this._previousFramebuffer) ? Sst : bst, f = new Ue({ defines: ["UNCLASSIFIED"], sources: [u] }), d = new Ue({ sources: [u] }); this._unclassifiedCommand = e.createViewportQuadCommand(f, { renderState: l(this._previousFramebuffer) ? this._rsUnclassified : this._rsDefault, uniformMap: this._uniformMap, owner: this }), this._classifiedCommand = e.createViewportQuadCommand(d, { renderState: l(this._previousFramebuffer) ? this._rsClassified : this._rsDefault, uniformMap: this._uniformMap, owner: this }), l(this._translucentCommand) && (this._translucentCommand.shaderProgram = this._translucentCommand.shaderProgram && this._translucentCommand.shaderProgram.destroy()), l(this._previousFramebuffer) || (this._translucentCommand = e.createViewportQuadCommand(Wl, { renderState: this._rsUnclassified, uniformMap: this._uniformMap, owner: this })) } }; Mh.prototype.prepareTextures = function (e, t) { this._fbo._numSamples > 1 && this._fbo.prepareTextures(e, t) }; Mh.prototype.clear = function (e, t) { l(this._previousFramebuffer) ? this._fbo.clear(e, this._clearColorCommand, t) : (this._fbo.clear(e, this._clearCommand, t), this._fboClassified.clear(e, this._clearCommand, t)) }; Mh.prototype.executeClassified = function (e, t) { if (!l(this._previousFramebuffer)) { let n = t.framebuffer; this.prepareTextures(e, !0), t.framebuffer = this._fboClassified.framebuffer, this._translucentCommand.execute(e, t), t.framebuffer = n } this._classifiedCommand.execute(e, t) }; Mh.prototype.executeUnclassified = function (e, t) { this._unclassifiedCommand.execute(e, t) }; Mh.prototype.isDestroyed = function () { return !1 }; Mh.prototype.destroy = function () { return this._fbo.destroy(), this._fboClassified.destroy(), this._depthStencilTexture = this._depthStencilTexture && this._depthStencilTexture.destroy(), this._depthStencilRenderbuffer = this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy(), l(this._unclassifiedCommand) && (this._unclassifiedCommand.shaderProgram = this._unclassifiedCommand.shaderProgram && this._unclassifiedCommand.shaderProgram.destroy(), this._classifiedCommand.shaderProgram = this._classifiedCommand.shaderProgram && this._classifiedCommand.shaderProgram.destroy()), le(this) }; var pv = Mh; function Wk(e) { this._total = e, this.usedThisFrame = 0, this.stolenFromMeThisFrame = 0, this.starvedThisFrame = !1, this.starvedLastFrame = !1 } Object.defineProperties(Wk.prototype, { total: { get: function () { return this._total } } }); function Wg(e) { let t = new Array(Ca.NUMBER_OF_JOB_TYPES); t[Ca.TEXTURE] = new Wk(l(e) ? e[Ca.TEXTURE] : 10), t[Ca.PROGRAM] = new Wk(l(e) ? e[Ca.PROGRAM] : 10), t[Ca.BUFFER] = new Wk(l(e) ? e[Ca.BUFFER] : 30); let n = t.length, i, o = 0; for (i = 0; i < n; ++i)o += t[i].total; let r = new Array(n); for (i = 0; i < n; ++i)r[i] = !1; this._totalBudget = o, this._totalUsedThisFrame = 0, this._budgets = t, this._executedThisFrame = r } Wg.getTimestamp = Ei; Object.defineProperties(Wg.prototype, { totalBudget: { get: function () { return this._totalBudget } } }); Wg.prototype.disableThisFrame = function () { this._totalUsedThisFrame = this._totalBudget }; Wg.prototype.resetBudgets = function () { let e = this._budgets, t = e.length; for (let n = 0; n < t; ++n) { let i = e[n]; i.starvedLastFrame = i.starvedThisFrame, i.starvedThisFrame = !1, i.usedThisFrame = 0, i.stolenFromMeThisFrame = 0 } this._totalUsedThisFrame = 0 }; Wg.prototype.execute = function (e, t) { let n = this._budgets, i = n[t], o = this._executedThisFrame[t]; if (this._totalUsedThisFrame >= this._totalBudget && o) return i.starvedThisFrame = !0, !1; let r; if (i.usedThisFrame + i.stolenFromMeThisFrame >= i.total) { let c = n.length, u; for (u = 0; u < c && (r = n[u], !(r.usedThisFrame + r.stolenFromMeThisFrame < r.total && !r.starvedLastFrame)); ++u); if (u === c && o) return !1; o && (i.starvedThisFrame = !0) } let s = Wg.getTimestamp(); e.execute(); let a = Wg.getTimestamp() - s; return this._totalUsedThisFrame += a, r ? r.stolenFromMeThisFrame += a : i.usedThisFrame += a, this._executedThisFrame[t] = !0, !0 }; var jk = Wg; function C_e() { } Object.defineProperties(C_e.prototype, { color: { get: ye.throwInstantiationError }, intensity: { get: ye.throwInstantiationError } }); var x_e = C_e; var wst = /\/$/, T_e = new Xt('&copy; <a href="https://www.mapbox.com/about/maps/">Mapbox</a> &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> <strong><a href="https://www.mapbox.com/map-feedback/">Improve this map</a></strong>'); function FE(e) { e = y(e, y.EMPTY_OBJECT); let t = e.styleId, n = e.accessToken; this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0; let i = Pe.createIfNeeded(y(e.url, "https://api.mapbox.com/styles/v1/")); this._styleId = t, this._accessToken = n; let o = y(e.tilesize, 512); this._tilesize = o; let r = y(e.username, "mapbox"); this._username = r; let s = l(e.scaleFactor) ? "@2x" : "", a = i.getUrlComponent(); wst.test(a) || (a += "/"), a += `${this._username}/${t}/tiles/${this._tilesize}/{z}/{x}/{y}${s}`, i.url = a, i.setQueryParameters({ access_token: n }); let c; l(e.credit) ? (c = e.credit, typeof c == "string" && (c = new Xt(c))) : c = T_e, this._resource = i, this._imageryProvider = new Ua({ url: i, credit: c, ellipsoid: e.ellipsoid, minimumLevel: e.minimumLevel, maximumLevel: e.maximumLevel, rectangle: e.rectangle }) } Object.defineProperties(FE.prototype, { url: { get: function () { return this._imageryProvider.url } }, ready: { get: function () { return this._imageryProvider.ready } }, readyPromise: { get: function () { return this._imageryProvider.readyPromise } }, rectangle: { get: function () { return this._imageryProvider.rectangle } }, tileWidth: { get: function () { return this._imageryProvider.tileWidth } }, tileHeight: { get: function () { return this._imageryProvider.tileHeight } }, maximumLevel: { get: function () { return this._imageryProvider.maximumLevel } }, minimumLevel: { get: function () { return this._imageryProvider.minimumLevel } }, tilingScheme: { get: function () { return this._imageryProvider.tilingScheme } }, tileDiscardPolicy: { get: function () { return this._imageryProvider.tileDiscardPolicy } }, errorEvent: { get: function () { return this._imageryProvider.errorEvent } }, credit: { get: function () { return this._imageryProvider.credit } }, proxy: { get: function () { return this._imageryProvider.proxy } }, hasAlphaChannel: { get: function () { return this._imageryProvider.hasAlphaChannel } } }); FE.prototype.getTileCredits = function (e, t, n) { }; FE.prototype.requestImage = function (e, t, n, i) { return this._imageryProvider.requestImage(e, t, n, i) }; FE.prototype.pickFeatures = function (e, t, n, i, o) { return this._imageryProvider.pickFeatures(e, t, n, i, o) }; FE._defaultCredit = T_e; var E_e = FE; function _v(e) { e = y(e, y.EMPTY_OBJECT); let t = e.textureUrl; l(t) || (t = Jt("Assets/Textures/moonSmall.jpg")), this.show = y(e.show, !0), this.textureUrl = t, this._ellipsoid = y(e.ellipsoid, ie.MOON), this.onlySunLighting = y(e.onlySunLighting, !0), this._ellipsoidPrimitive = new ok({ radii: this.ellipsoid.radii, material: Ki.fromType(Ki.ImageType), depthTestEnabled: !1, _owner: this }), this._ellipsoidPrimitive.material.translucent = !1, this._axes = new K3 } Object.defineProperties(_v.prototype, { ellipsoid: { get: function () { return this._ellipsoid } } }); var qk = new Q, Dst = new Q, vst = new h, Yk = []; _v.prototype.update = function (e) { if (!this.show) return; let t = this._ellipsoidPrimitive; t.material.uniforms.image = this.textureUrl, t.onlySunLighting = this.onlySunLighting; let n = e.time; l(It.computeIcrfToFixedMatrix(n, qk)) || It.computeTemeToPseudoFixedMatrix(n, qk); let i = this._axes.evaluate(n, Dst); Q.transpose(i, i), Q.multiply(qk, i, i); let o = zy.computeMoonPositionInEarthInertialFrame(n, vst); Q.multiplyByVector(qk, o, o), F.fromRotationTranslation(i, o, t.modelMatrix); let r = e.commandList; return e.commandList = Yk, Yk.length = 0, t.update(e), e.commandList = r, Yk.length === 1 ? Yk[0] : void 0 }; _v.prototype.isDestroyed = function () { return !1 }; _v.prototype.destroy = function () { return this._ellipsoidPrimitive = this._ellipsoidPrimitive && this._ellipsoidPrimitive.destroy(), le(this) }; var Xk = _v; function Cj(e) { } Cj.prototype.isReady = function () { return !0 }; Cj.prototype.shouldDiscardImage = function (e) { return !1 }; var b_e = Cj; var gv = `#ifdef MRT
#extension GL_EXT_draw_buffers : enable
#endif
uniform vec4 u_bgColor;
uniform sampler2D u_depthTexture;
varying vec2 v_textureCoordinates;
void main()
{
if (texture2D(u_depthTexture, v_textureCoordinates).r < 1.0)
{
#ifdef MRT
gl_FragData[0] = u_bgColor;
gl_FragData[1] = vec4(u_bgColor.a);
#else
gl_FragColor = u_bgColor;
#endif
return;
}
discard;
}
`; var Kk = `uniform sampler2D u_opaque;
uniform sampler2D u_accumulation;
uniform sampler2D u_revealage;
varying vec2 v_textureCoordinates;
void main()
{
vec4 opaque = texture2D(u_opaque, v_textureCoordinates);
vec4 accum = texture2D(u_accumulation, v_textureCoordinates);
float r = texture2D(u_revealage, v_textureCoordinates).r;
#ifdef MRT
vec4 transparent = vec4(accum.rgb / clamp(r, 1e-4, 5e4), accum.a);
#else
vec4 transparent = vec4(accum.rgb / clamp(accum.a, 1e-4, 5e4), r);
#endif
gl_FragColor = (1.0 - transparent.a) * transparent + transparent.a * opaque;
if (opaque != czm_backgroundColor)
{
gl_FragColor.a = 1.0;
}
}
`; function mp(e) { this._numSamples = 1, this._translucentMultipassSupport = !1, this._translucentMRTSupport = !1; let t = e.colorBufferFloat && e.depthTexture && e.floatBlend; this._translucentMRTSupport = e.drawBuffers && t, this._translucentMultipassSupport = !this._translucentMRTSupport && t, this._opaqueFBO = void 0, this._opaqueTexture = void 0, this._depthStencilTexture = void 0, this._accumulationTexture = void 0, this._translucentFBO = new si({ colorAttachmentsLength: this._translucentMRTSupport ? 2 : 1, createColorAttachments: !1, createDepthAttachments: !1, depth: !0 }), this._alphaFBO = new si({ createColorAttachments: !1, createDepthAttachments: !1, depth: !0 }), this._adjustTranslucentFBO = new si({ colorAttachmentsLength: this._translucentMRTSupport ? 2 : 1, createColorAttachments: !1 }), this._adjustAlphaFBO = new si({ createColorAttachments: !1 }), this._opaqueClearCommand = new ti({ color: new U(0, 0, 0, 0), owner: this }), this._translucentMRTClearCommand = new ti({ color: new U(0, 0, 0, 1), owner: this }), this._translucentMultipassClearCommand = new ti({ color: new U(0, 0, 0, 0), owner: this }), this._alphaClearCommand = new ti({ color: new U(1, 1, 1, 1), owner: this }), this._translucentRenderStateCache = {}, this._alphaRenderStateCache = {}, this._compositeCommand = void 0, this._adjustTranslucentCommand = void 0, this._adjustAlphaCommand = void 0, this._viewport = new Ge, this._rs = void 0, this._useScissorTest = !1, this._scissorRectangle = void 0, this._useHDR = !1 } function S_e(e) { e._accumulationTexture = e._accumulationTexture && !e._accumulationTexture.isDestroyed() && e._accumulationTexture.destroy(), e._revealageTexture = e._revealageTexture && !e._revealageTexture.isDestroyed() && e._revealageTexture.destroy() } function xj(e) { e._translucentFBO.destroy(), e._alphaFBO.destroy(), e._adjustTranslucentFBO.destroy(), e._adjustAlphaFBO.destroy() } function w_e(e) { S_e(e), xj(e) } function Pst(e, t, n, i) { S_e(e), e._accumulationTexture = new Rt({ context: t, width: n, height: i, pixelFormat: ht.RGBA, pixelDatatype: Ye.FLOAT }); let o = new Float32Array(n * i * 4); e._revealageTexture = new Rt({ context: t, pixelFormat: ht.RGBA, pixelDatatype: Ye.FLOAT, source: { arrayBufferView: o, width: n, height: i }, flipY: !1 }) } function Ist(e, t) { xj(e); let n = te.FRAMEBUFFER_COMPLETE, i = !0, o = e._accumulationTexture.width, r = e._accumulationTexture.height; if (e._translucentMRTSupport && (e._translucentFBO.setColorTexture(e._accumulationTexture, 0), e._translucentFBO.setColorTexture(e._revealageTexture, 1), e._translucentFBO.setDepthStencilTexture(e._depthStencilTexture), e._translucentFBO.update(t, o, r), e._adjustTranslucentFBO.setColorTexture(e._accumulationTexture, 0), e._adjustTranslucentFBO.setColorTexture(e._revealageTexture, 1), e._adjustTranslucentFBO.update(t, o, r), (e._translucentFBO.status !== n || e._adjustTranslucentFBO.status !== n) && (xj(e), e._translucentMRTSupport = !1)), !e._translucentMRTSupport) { e._translucentFBO.setColorTexture(e._accumulationTexture), e._translucentFBO.setDepthStencilTexture(e._depthStencilTexture), e._translucentFBO.update(t, o, r), e._alphaFBO.setColorTexture(e._revealageTexture), e._alphaFBO.setDepthStencilTexture(e._depthStencilTexture), e._alphaFBO.update(t, o, r), e._adjustTranslucentFBO.setColorTexture(e._accumulationTexture), e._adjustTranslucentFBO.update(t, o, r), e._adjustAlphaFBO.setColorTexture(e._revealageTexture), e._adjustAlphaFBO.update(t, o, r); let s = e._translucentFBO.status === n, a = e._alphaFBO.status === n, c = e._adjustTranslucentFBO.status === n, u = e._adjustAlphaFBO.status === n; (!s || !a || !c || !u) && (w_e(e), e._translucentMultipassSupport = !1, i = !1) } return i } mp.prototype.update = function (e, t, n, i, o) { if (!this.isSupported()) return; this._opaqueFBO = n, this._opaqueTexture = n.getColorTexture(0), this._depthStencilTexture = n.getDepthStencilTexture(); let r = this._opaqueTexture.width, s = this._opaqueTexture.height, a = this._accumulationTexture, c = !l(a) || a.width !== r || a.height !== s || i !== this._useHDR, u = this._numSamples !== o; if ((c || u) && (this._numSamples = o, Pst(this, e, r, s)), (!l(this._translucentFBO.framebuffer) || c || u) && !Ist(this, e)) return; this._useHDR = i; let f = this, d, p; l(this._compositeCommand) || (d = new Ue({ sources: [Kk] }), this._translucentMRTSupport && d.defines.push("MRT"), p = { u_opaque: function () { return f._opaqueTexture }, u_accumulation: function () { return f._accumulationTexture }, u_revealage: function () { return f._revealageTexture } }, this._compositeCommand = e.createViewportQuadCommand(d, { uniformMap: p, owner: this })), l(this._adjustTranslucentCommand) || (this._translucentMRTSupport ? (d = new Ue({ defines: ["MRT"], sources: [gv] }), p = { u_bgColor: function () { return f._translucentMRTClearCommand.color }, u_depthTexture: function () { return f._depthStencilTexture } }, this._adjustTranslucentCommand = e.createViewportQuadCommand(d, { uniformMap: p, owner: this })) : this._translucentMultipassSupport && (d = new Ue({ sources: [gv] }), p = { u_bgColor: function () { return f._translucentMultipassClearCommand.color }, u_depthTexture: function () { return f._depthStencilTexture } }, this._adjustTranslucentCommand = e.createViewportQuadCommand(d, { uniformMap: p, owner: this }), p = { u_bgColor: function () { return f._alphaClearCommand.color }, u_depthTexture: function () { return f._depthStencilTexture } }, this._adjustAlphaCommand = e.createViewportQuadCommand(d, { uniformMap: p, owner: this }))), this._viewport.width = r, this._viewport.height = s; let g = !Ge.equals(this._viewport, t.viewport), m = g !== this._useScissorTest; this._useScissorTest = g, Ge.equals(this._scissorRectangle, t.viewport) || (this._scissorRectangle = Ge.clone(t.viewport, this._scissorRectangle), m = !0), (!l(this._rs) || !Ge.equals(this._viewport, this._rs.viewport) || m) && (this._rs = Ve.fromCache({ viewport: this._viewport, scissorTest: { enabled: this._useScissorTest, rectangle: this._scissorRectangle } })), l(this._compositeCommand) && (this._compositeCommand.renderState = this._rs), this._adjustTranslucentCommand && (this._adjustTranslucentCommand.renderState = this._rs), l(this._adjustAlphaCommand) && (this._adjustAlphaCommand.renderState = this._rs) }; var Ost = { enabled: !0, color: new U(0, 0, 0, 0), equationRgb: ma.ADD, equationAlpha: ma.ADD, functionSourceRgb: Co.ONE, functionDestinationRgb: Co.ONE, functionSourceAlpha: Co.ZERO, functionDestinationAlpha: Co.ONE_MINUS_SOURCE_ALPHA }, Bst = { enabled: !0, color: new U(0, 0, 0, 0), equationRgb: ma.ADD, equationAlpha: ma.ADD, functionSourceRgb: Co.ONE, functionDestinationRgb: Co.ONE, functionSourceAlpha: Co.ONE, functionDestinationAlpha: Co.ONE }, Rst = { enabled: !0, color: new U(0, 0, 0, 0), equationRgb: ma.ADD, equationAlpha: ma.ADD, functionSourceRgb: Co.ZERO, functionDestinationRgb: Co.ONE_MINUS_SOURCE_ALPHA, functionSourceAlpha: Co.ZERO, functionDestinationAlpha: Co.ONE_MINUS_SOURCE_ALPHA }; function Tj(e, t, n, i) { let o = n[i.id]; if (!l(o)) { let r = Ve.getState(i); r.depthMask = !1, r.blending = t, o = Ve.fromCache(r), n[i.id] = o } return o } function Mst(e, t, n) { return Tj(t, Ost, e._translucentRenderStateCache, n) } function Lst(e, t, n) { return Tj(t, Bst, e._translucentRenderStateCache, n) } function Fst(e, t, n) { return Tj(t, Rst, e._alphaRenderStateCache, n) } var Nst = `    vec3 Ci = czm_gl_FragColor.rgb * czm_gl_FragColor.a;
    float ai = czm_gl_FragColor.a;
    float wzi = czm_alphaWeight(ai);
    gl_FragData[0] = vec4(Ci * wzi, ai);
    gl_FragData[1] = vec4(ai * wzi);
`, Vst = `    vec3 Ci = czm_gl_FragColor.rgb * czm_gl_FragColor.a;
    float ai = czm_gl_FragColor.a;
    float wzi = czm_alphaWeight(ai);
    gl_FragColor = vec4(Ci, ai) * wzi;
`, kst = `    float ai = czm_gl_FragColor.a;
    gl_FragColor = vec4(ai);
`; function Ej(e, t, n, i) {
        let o = e.shaderCache.getDerivedShaderProgram(t, n); if (!l(o)) {
            let r = t._attributeLocations, s = t.fragmentShaderSource.clone(); s.sources = s.sources.map(function (a) { return a = Ue.replaceMain(a, "czm_translucent_main"), a = a.replace(/gl_FragColor/g, "czm_gl_FragColor"), a = a.replace(/\bdiscard\b/g, "czm_discard = true"), a = a.replace(/czm_phong/g, "czm_translucentPhong"), a }), s.sources.splice(0, 0, `${i.indexOf("gl_FragData") !== -1 ? `#extension GL_EXT_draw_buffers : enable 
`: ""}vec4 czm_gl_FragColor;
bool czm_discard = false;
`), s.sources.push(`void main()
{
    czm_translucent_main();
    if (czm_discard)
    {
        discard;
    }
${i}}
`), o = e.shaderCache.createDerivedShaderProgram(t, n, { vertexShaderSource: t.vertexShaderSource, fragmentShaderSource: s, attributeLocations: r })
        } return o
    } function Ust(e, t) { return Ej(e, t, "translucentMRT", Nst) } function zst(e, t) { return Ej(e, t, "translucentMultipass", Vst) } function Hst(e, t) { return Ej(e, t, "alphaMultipass", kst) } mp.prototype.createDerivedCommands = function (e, t, n) { if (l(n) || (n = {}), this._translucentMRTSupport) { let i, o; l(n.translucentCommand) && (i = n.translucentCommand.shaderProgram, o = n.translucentCommand.renderState), n.translucentCommand = $e.shallowClone(e, n.translucentCommand), !l(i) || n.shaderProgramId !== e.shaderProgram.id ? (n.translucentCommand.shaderProgram = Ust(t, e.shaderProgram), n.translucentCommand.renderState = Mst(this, t, e.renderState), n.shaderProgramId = e.shaderProgram.id) : (n.translucentCommand.shaderProgram = i, n.translucentCommand.renderState = o) } else { let i, o, r, s; l(n.translucentCommand) && (i = n.translucentCommand.shaderProgram, o = n.translucentCommand.renderState, r = n.alphaCommand.shaderProgram, s = n.alphaCommand.renderState), n.translucentCommand = $e.shallowClone(e, n.translucentCommand), n.alphaCommand = $e.shallowClone(e, n.alphaCommand), !l(i) || n.shaderProgramId !== e.shaderProgram.id ? (n.translucentCommand.shaderProgram = zst(t, e.shaderProgram), n.translucentCommand.renderState = Lst(this, t, e.renderState), n.alphaCommand.shaderProgram = Hst(t, e.shaderProgram), n.alphaCommand.renderState = Fst(this, t, e.renderState), n.shaderProgramId = e.shaderProgram.id) : (n.translucentCommand.shaderProgram = i, n.translucentCommand.renderState = o, n.alphaCommand.shaderProgram = r, n.alphaCommand.renderState = s) } return n }; function Gst(e, t, n, i, o, r) { let s, a, c, u = t.context, f = t.frameState.useLogDepth, d = t._hdr, p = i.framebuffer, g = o.length, m = t.frameState.shadowState.lightShadowsEnabled; i.framebuffer = e._adjustTranslucentFBO.framebuffer, e._adjustTranslucentCommand.execute(u, i), i.framebuffer = e._adjustAlphaFBO.framebuffer, e._adjustAlphaCommand.execute(u, i); let A = e._opaqueFBO.framebuffer; for (i.framebuffer = e._translucentFBO.framebuffer, c = 0; c < g; ++c)s = o[c], s = f ? s.derivedCommands.logDepth.command : s, s = d ? s.derivedCommands.hdr.command : s, a = m && s.receiveShadows ? s.derivedCommands.oit.shadows.translucentCommand : s.derivedCommands.oit.translucentCommand, n(a, t, u, i, A); for (l(r) && (s = r.unclassifiedCommand, a = m && s.receiveShadows ? s.derivedCommands.oit.shadows.translucentCommand : s.derivedCommands.oit.translucentCommand, n(a, t, u, i, A)), i.framebuffer = e._alphaFBO.framebuffer, c = 0; c < g; ++c)s = o[c], s = f ? s.derivedCommands.logDepth.command : s, s = d ? s.derivedCommands.hdr.command : s, a = m && s.receiveShadows ? s.derivedCommands.oit.shadows.alphaCommand : s.derivedCommands.oit.alphaCommand, n(a, t, u, i, A); l(r) && (s = r.unclassifiedCommand, a = m && s.receiveShadows ? s.derivedCommands.oit.shadows.alphaCommand : s.derivedCommands.oit.alphaCommand, n(a, t, u, i, A)), i.framebuffer = p } function Wst(e, t, n, i, o, r) { let s = t.context, a = t.frameState.useLogDepth, c = t._hdr, u = i.framebuffer, f = o.length, d = t.frameState.shadowState.lightShadowsEnabled; i.framebuffer = e._adjustTranslucentFBO.framebuffer, e._adjustTranslucentCommand.execute(s, i); let p = e._opaqueFBO.framebuffer; i.framebuffer = e._translucentFBO.framebuffer; let g, m; for (let A = 0; A < f; ++A)g = o[A], g = a ? g.derivedCommands.logDepth.command : g, g = c ? g.derivedCommands.hdr.command : g, m = d && g.receiveShadows ? g.derivedCommands.oit.shadows.translucentCommand : g.derivedCommands.oit.translucentCommand, n(m, t, s, i, p); l(r) && (g = r.unclassifiedCommand, m = d && g.receiveShadows ? g.derivedCommands.oit.shadows.translucentCommand : g.derivedCommands.oit.translucentCommand, n(m, t, s, i, p)), i.framebuffer = u } mp.prototype.executeCommands = function (e, t, n, i, o) { if (this._translucentMRTSupport) { Wst(this, e, t, n, i, o); return } Gst(this, e, t, n, i, o) }; mp.prototype.execute = function (e, t) { this._compositeCommand.execute(e, t) }; mp.prototype.clear = function (e, t, n) { let i = t.framebuffer; t.framebuffer = this._opaqueFBO.framebuffer, U.clone(n, this._opaqueClearCommand.color), this._opaqueClearCommand.execute(e, t), t.framebuffer = this._translucentFBO.framebuffer, (this._translucentMRTSupport ? this._translucentMRTClearCommand : this._translucentMultipassClearCommand).execute(e, t), this._translucentMultipassSupport && (t.framebuffer = this._alphaFBO.framebuffer, this._alphaClearCommand.execute(e, t)), t.framebuffer = i }; mp.prototype.isSupported = function () { return this._translucentMRTSupport || this._translucentMultipassSupport }; mp.prototype.isDestroyed = function () { return !1 }; mp.prototype.destroy = function () { return w_e(this), l(this._compositeCommand) && (this._compositeCommand.shaderProgram = this._compositeCommand.shaderProgram && this._compositeCommand.shaderProgram.destroy()), l(this._adjustTranslucentCommand) && (this._adjustTranslucentCommand.shaderProgram = this._adjustTranslucentCommand.shaderProgram && this._adjustTranslucentCommand.shaderProgram.destroy()), l(this._adjustAlphaCommand) && (this._adjustAlphaCommand.shaderProgram = this._adjustAlphaCommand.shaderProgram && this._adjustAlphaCommand.shaderProgram.destroy()), le(this) }; var Jk = mp; var jst = new Xt("MapQuest, Open Street Map and contributors, CC-BY-SA"); function Zk(e) { e = y(e, y.EMPTY_OBJECT); let t = Pe.createIfNeeded(y(e.url, "https://a.tile.openstreetmap.org/")); t.appendForwardSlash(), t.url += `{z}/{x}/{y}.${y(e.fileExtension, "png")}`; let n = new Gr({ ellipsoid: e.ellipsoid }), i = 256, o = 256, r = y(e.minimumLevel, 0), s = e.maximumLevel, a = y(e.rectangle, n.rectangle), c = n.positionToTileXY(ce.southwest(a), r), u = n.positionToTileXY(ce.northeast(a), r), f = (Math.abs(u.x - c.x) + 1) * (Math.abs(u.y - c.y) + 1), d = y(e.credit, jst); typeof d == "string" && (d = new Xt(d)), Ua.call(this, { url: t, credit: d, tilingScheme: n, tileWidth: i, tileHeight: o, minimumLevel: r, maximumLevel: s, rectangle: a }) } l(Object.create) && (Zk.prototype = Object.create(Ua.prototype), Zk.prototype.constructor = Zk); var NE = Zk; var qst = new H(1, 1); function bj(e) { e = y(e, y.EMPTY_OBJECT), this.mass = y(e.mass, 1), this.position = h.clone(y(e.position, h.ZERO)), this.velocity = h.clone(y(e.velocity, h.ZERO)), this.life = y(e.life, Number.MAX_VALUE), this.image = e.image, this.startColor = U.clone(y(e.startColor, U.WHITE)), this.endColor = U.clone(y(e.endColor, U.WHITE)), this.startScale = y(e.startScale, 1), this.endScale = y(e.endScale, 1), this.imageSize = H.clone(y(e.imageSize, qst)), this._age = 0, this._normalizedAge = 0, this._billboard = void 0 } Object.defineProperties(bj.prototype, { age: { get: function () { return this._age } }, normalizedAge: { get: function () { return this._normalizedAge } } }); var D_e = new h; bj.prototype.update = function (e, t) { return h.multiplyByScalar(this.velocity, e, D_e), h.add(this.position, D_e, this.position), l(t) && t(this, e), this._age += e, this.life === Number.MAX_VALUE ? this._normalizedAge = 0 : this._normalizedAge = this._age / this.life, this._age <= this.life }; var yv = bj; function v_e(e) { e = y(e, y.EMPTY_OBJECT), this.time = y(e.time, 0), this.minimum = y(e.minimum, 0), this.maximum = y(e.maximum, 50), this._complete = !1 } Object.defineProperties(v_e.prototype, { complete: { get: function () { return this._complete } } }); var P_e = v_e; function I_e(e) { } I_e.prototype.emit = function (e) { ye.throwInstantiationError() }; var O_e = I_e; var B_e = new H(1, 1); function Av(e) { e = y(e, y.EMPTY_OBJECT), this.show = y(e.show, !0), this.updateCallback = e.updateCallback, this.loop = y(e.loop, !0), this.image = y(e.image, void 0); let t = e.emitter; l(t) || (t = new DV(.5)), this._emitter = t, this._bursts = e.bursts, this._modelMatrix = F.clone(y(e.modelMatrix, F.IDENTITY)), this._emitterModelMatrix = F.clone(y(e.emitterModelMatrix, F.IDENTITY)), this._matrixDirty = !0, this._combinedMatrix = new F, this._startColor = U.clone(y(e.color, y(e.startColor, U.WHITE))), this._endColor = U.clone(y(e.color, y(e.endColor, U.WHITE))), this._startScale = y(e.scale, y(e.startScale, 1)), this._endScale = y(e.scale, y(e.endScale, 1)), this._emissionRate = y(e.emissionRate, 5), this._minimumSpeed = y(e.speed, y(e.minimumSpeed, 1)), this._maximumSpeed = y(e.speed, y(e.maximumSpeed, 1)), this._minimumParticleLife = y(e.particleLife, y(e.minimumParticleLife, 5)), this._maximumParticleLife = y(e.particleLife, y(e.maximumParticleLife, 5)), this._minimumMass = y(e.mass, y(e.minimumMass, 1)), this._maximumMass = y(e.mass, y(e.maximumMass, 1)), this._minimumImageSize = H.clone(y(e.imageSize, y(e.minimumImageSize, B_e))), this._maximumImageSize = H.clone(y(e.imageSize, y(e.maximumImageSize, B_e))), this._sizeInMeters = y(e.sizeInMeters, !1), this._lifetime = y(e.lifetime, Number.MAX_VALUE), this._billboardCollection = void 0, this._particles = [], this._particlePool = [], this._previousTime = void 0, this._currentTime = 0, this._carryOver = 0, this._complete = new _e, this._isComplete = !1, this._updateParticlePool = !0, this._particleEstimate = 0 } Object.defineProperties(Av.prototype, { emitter: { get: function () { return this._emitter }, set: function (e) { this._emitter = e } }, bursts: { get: function () { return this._bursts }, set: function (e) { this._bursts = e, this._updateParticlePool = !0 } }, modelMatrix: { get: function () { return this._modelMatrix }, set: function (e) { this._matrixDirty = this._matrixDirty || !F.equals(this._modelMatrix, e), F.clone(e, this._modelMatrix) } }, emitterModelMatrix: { get: function () { return this._emitterModelMatrix }, set: function (e) { this._matrixDirty = this._matrixDirty || !F.equals(this._emitterModelMatrix, e), F.clone(e, this._emitterModelMatrix) } }, startColor: { get: function () { return this._startColor }, set: function (e) { U.clone(e, this._startColor) } }, endColor: { get: function () { return this._endColor }, set: function (e) { U.clone(e, this._endColor) } }, startScale: { get: function () { return this._startScale }, set: function (e) { this._startScale = e } }, endScale: { get: function () { return this._endScale }, set: function (e) { this._endScale = e } }, emissionRate: { get: function () { return this._emissionRate }, set: function (e) { this._emissionRate = e, this._updateParticlePool = !0 } }, minimumSpeed: { get: function () { return this._minimumSpeed }, set: function (e) { this._minimumSpeed = e } }, maximumSpeed: { get: function () { return this._maximumSpeed }, set: function (e) { this._maximumSpeed = e } }, minimumParticleLife: { get: function () { return this._minimumParticleLife }, set: function (e) { this._minimumParticleLife = e } }, maximumParticleLife: { get: function () { return this._maximumParticleLife }, set: function (e) { this._maximumParticleLife = e, this._updateParticlePool = !0 } }, minimumMass: { get: function () { return this._minimumMass }, set: function (e) { this._minimumMass = e } }, maximumMass: { get: function () { return this._maximumMass }, set: function (e) { this._maximumMass = e } }, minimumImageSize: { get: function () { return this._minimumImageSize }, set: function (e) { this._minimumImageSize = e } }, maximumImageSize: { get: function () { return this._maximumImageSize }, set: function (e) { this._maximumImageSize = e } }, sizeInMeters: { get: function () { return this._sizeInMeters }, set: function (e) { this._sizeInMeters = e } }, lifetime: { get: function () { return this._lifetime }, set: function (e) { this._lifetime = e } }, complete: { get: function () { return this._complete } }, isComplete: { get: function () { return this._isComplete } } }); function Yst(e) { let t = e._emissionRate, n = e._maximumParticleLife, i = 0, o = e._bursts; if (l(o)) { let d = o.length; for (let p = 0; p < d; ++p)i += o[p].maximum } let r = e._billboardCollection, s = e.image, a = Math.ceil(t * n + i), c = e._particles, u = e._particlePool, f = Math.max(a - c.length - u.length, 0); for (let d = 0; d < f; ++d) { let p = new yv; p._billboard = r.add({ image: s }), u.push(p) } e._particleEstimate = a } function Xst(e) { let t = e._particlePool.pop(); return l(t) || (t = new yv), t } function Kst(e, t) { e._particlePool.push(t) } function Jst(e) { let t = e._particles, n = e._particlePool, i = e._billboardCollection, o = t.length, r = n.length, s = e._particleEstimate, a = r - Math.max(s - o - r, 0); for (let c = a; c < r; ++c) { let u = n[c]; i.remove(u._billboard) } n.length = a } function Zst(e) { l(e._billboard) && (e._billboard.show = !1) } function R_e(e, t) { let n = t._billboard; l(n) || (n = t._billboard = e._billboardCollection.add({ image: t.image })), n.width = t.imageSize.x, n.height = t.imageSize.y, n.position = t.position, n.sizeInMeters = e.sizeInMeters, n.show = !0; let i = I.lerp(t.startColor.red, t.endColor.red, t.normalizedAge), o = I.lerp(t.startColor.green, t.endColor.green, t.normalizedAge), r = I.lerp(t.startColor.blue, t.endColor.blue, t.normalizedAge), s = I.lerp(t.startColor.alpha, t.endColor.alpha, t.normalizedAge); n.color = new U(i, o, r, s), n.scale = I.lerp(t.startScale, t.endScale, t.normalizedAge) } function Qst(e, t) { t.startColor = U.clone(e._startColor, t.startColor), t.endColor = U.clone(e._endColor, t.endColor), t.startScale = e._startScale, t.endScale = e._endScale, t.image = e.image, t.life = I.randomBetween(e._minimumParticleLife, e._maximumParticleLife), t.mass = I.randomBetween(e._minimumMass, e._maximumMass), t.imageSize.x = I.randomBetween(e._minimumImageSize.x, e._maximumImageSize.x), t.imageSize.y = I.randomBetween(e._minimumImageSize.y, e._maximumImageSize.y), t._normalizedAge = 0, t._age = 0; let n = I.randomBetween(e._minimumSpeed, e._maximumSpeed); h.multiplyByScalar(t.velocity, n, t.velocity), e._particles.push(t) } function $st(e, t) { if (e._isComplete) return 0; t = I.mod(t, e._lifetime); let n = t * e._emissionRate, i = Math.floor(n); if (e._carryOver += n - i, e._carryOver > 1 && (i++, e._carryOver -= 1), l(e.bursts)) { let o = e.bursts.length; for (let r = 0; r < o; r++) { let s = e.bursts[r], a = e._currentTime; l(s) && !s._complete && a > s.time && (i += I.randomBetween(s.minimum, s.maximum), s._complete = !0) } } return i } var Qk = new h; Av.prototype.update = function (e) { if (!this.show) return; l(this._billboardCollection) || (this._billboardCollection = new yu), this._updateParticlePool && (Yst(this), this._updateParticlePool = !1); let t = 0; this._previousTime && (t = $.secondsDifference(e.time, this._previousTime)), t < 0 && (t = 0); let n = this._particles, i = this._emitter, o = this.updateCallback, r, s, a = n.length; for (r = 0; r < a; ++r)s = n[r], s.update(t, o) ? R_e(this, s) : (Zst(s), Kst(this, s), n[r] = n[a - 1], --r, --a); n.length = a; let c = $st(this, t); if (c > 0 && l(i)) { this._matrixDirty && (this._combinedMatrix = F.multiply(this.modelMatrix, this.emitterModelMatrix, this._combinedMatrix), this._matrixDirty = !1); let u = this._combinedMatrix; for (r = 0; r < c; r++)s = Xst(this), this._emitter.emit(s), h.add(s.position, s.velocity, Qk), F.multiplyByPoint(u, Qk, Qk), s.position = F.multiplyByPoint(u, s.position, s.position), h.subtract(Qk, s.position, s.velocity), h.normalize(s.velocity, s.velocity), Qst(this, s), R_e(this, s) } if (this._billboardCollection.update(e), this._previousTime = $.clone(e.time, this._previousTime), this._currentTime += t, this._lifetime !== Number.MAX_VALUE && this._currentTime > this._lifetime) if (this.loop) { if (this._currentTime = I.mod(this._currentTime, this._lifetime), this.bursts) { let u = this.bursts.length; for (r = 0; r < u; r++)this.bursts[r]._complete = !1 } } else this._isComplete = !0, this._complete.raiseEvent(this); e.frameNumber % 120 === 0 && Jst(this) }; Av.prototype.isDestroyed = function () { return !1 }; Av.prototype.destroy = function () { return this._billboardCollection = this._billboardCollection && this._billboardCollection.destroy(), le(this) }; var M_e = Av; function $k(e) { e = y(e, y.EMPTY_OBJECT); let t = vn(e.container); this._container = t; let n = document.createElement("div"); n.className = "cesium-performanceDisplay"; let i = document.createElement("div"); i.className = "cesium-performanceDisplay-fps", this._fpsText = document.createTextNode(""), i.appendChild(this._fpsText); let o = document.createElement("div"); o.className = "cesium-performanceDisplay-ms", this._msText = document.createTextNode(""), o.appendChild(this._msText), n.appendChild(o), n.appendChild(i), this._container.appendChild(n), this._lastFpsSampleTime = Ei(), this._lastMsSampleTime = Ei(), this._fpsFrameCount = 0, this._msFrameCount = 0, this._throttled = !1; let r = document.createElement("div"); r.className = "cesium-performanceDisplay-throttled", this._throttledText = document.createTextNode(""), r.appendChild(this._throttledText), n.appendChild(r) } Object.defineProperties($k.prototype, { throttled: { get: function () { return this._throttled }, set: function (e) { this._throttled !== e && (e ? this._throttledText.nodeValue = "(throttled)" : this._throttledText.nodeValue = "", this._throttled = e) } } }); $k.prototype.update = function (e) { let t = Ei(), n = y(e, !0); this._fpsFrameCount++; let i = t - this._lastFpsSampleTime; if (i > 1e3) { let r = "N/A"; n && (r = this._fpsFrameCount * 1e3 / i | 0), this._fpsText.nodeValue = `${r} FPS`, this._lastFpsSampleTime = t, this._fpsFrameCount = 0 } this._msFrameCount++; let o = t - this._lastMsSampleTime; if (o > 200) { let r = "N/A"; n && (r = (o / this._msFrameCount).toFixed(2)), this._msText.nodeValue = `${r} MS`, this._lastMsSampleTime = t, this._msFrameCount = 0 } }; $k.prototype.destroy = function () { return le(this) }; var jg = $k; function lA() { this._framebuffer = new si, this._textureToCopy = void 0, this._copyDepthCommand = void 0 } Object.defineProperties(lA.prototype, { framebuffer: { get: function () { return this._framebuffer.framebuffer } } }); function eat(e, t, n) { let i = n.width, o = n.height; e._framebuffer.update(t, i, o) } function tat(e, t, n) {
        if (!l(e._copyDepthCommand)) {
            let i = `uniform highp sampler2D u_texture;
varying vec2 v_textureCoordinates;
void main()
{
    gl_FragColor = czm_packDepth(texture2D(u_texture, v_textureCoordinates).r);
}
`; e._copyDepthCommand = t.createViewportQuadCommand(i, { renderState: Ve.fromCache(), uniformMap: { u_texture: function () { return e._textureToCopy } }, owner: e })
        } e._textureToCopy = n, e._copyDepthCommand.framebuffer = e.framebuffer
    } lA.prototype.update = function (e, t) { eat(this, e, t), tat(this, e, t) }; var nat = new se, iat = new se(1, 1 / 255, 1 / 65025, 1 / 16581375); lA.prototype.getDepth = function (e, t, n) { if (!l(this.framebuffer)) return; let i = e.readPixels({ x: t, y: n, width: 1, height: 1, framebuffer: this.framebuffer }), o = se.unpack(i, 0, nat); return se.divideByScalar(o, 255, o), se.dot(o, iat) }; lA.prototype.executeCopyDepth = function (e, t) { this._copyDepthCommand.execute(e, t) }; lA.prototype.isDestroyed = function () { return !1 }; lA.prototype.destroy = function () { return this._framebuffer.destroy(), l(this._copyDepthCommand) && (this._copyDepthCommand.shaderProgram = l(this._copyDepthCommand.shaderProgram) && this._copyDepthCommand.shaderProgram.destroy()), le(this) }; var eU = lA; function Cv() { this._framebuffer = new si({ color: !1, depthStencil: !0, supportsDepthTexture: !0 }), this._passState = void 0 } Object.defineProperties(Cv.prototype, { framebuffer: { get: function () { return this._framebuffer.framebuffer } } }); function oat(e) { e._framebuffer.destroy() } function rat(e, t) { let n = t.drawingBufferWidth, i = t.drawingBufferHeight; e._framebuffer.update(t, n, i); let o = new pc(t); o.blendingEnabled = !1, o.scissorTest = { enabled: !0, rectangle: new Ge }, o.viewport = new Ge, e._passState = o } Cv.prototype.update = function (e, t, n) { let i = n.width, o = n.height; this._framebuffer.isDirty(i, o) && rat(this, e); let r = this.framebuffer, s = this._passState; return s.framebuffer = r, s.viewport.width = i, s.viewport.height = o, s.scissorTest.rectangle.x = t.x, s.scissorTest.rectangle.y = o - t.y, s.scissorTest.rectangle.width = 1, s.scissorTest.rectangle.height = 1, s }; Cv.prototype.isDestroyed = function () { return !1 }; Cv.prototype.destroy = function () { return oat(this), le(this) }; var tU = Cv; function Tv(e) { let t = new pc(e); t.blendingEnabled = !1, t.scissorTest = { enabled: !0, rectangle: new Ge }, t.viewport = new Ge, this._context = e, this._fb = new si({ depthStencil: !0 }), this._passState = t, this._width = 0, this._height = 0 } Tv.prototype.begin = function (e, t) { let n = this._context, i = t.width, o = t.height; return Ge.clone(e, this._passState.scissorTest.rectangle), this._width = i, this._height = o, this._fb.update(n, i, o), this._passState.framebuffer = this._fb.framebuffer, this._passState.viewport.width = i, this._passState.viewport.height = o, this._passState }; var xv = new U; Tv.prototype.end = function (e) { let t = y(e.width, 1), n = y(e.height, 1), i = this._context, o = i.readPixels({ x: e.x, y: e.y, width: t, height: n, framebuffer: this._fb.framebuffer }), r = Math.max(t, n), s = r * r, a = Math.floor(t * .5), c = Math.floor(n * .5), u = 0, f = 0, d = 0, p = -1; for (let g = 0; g < s; ++g) { if (-a <= u && u <= a && -c <= f && f <= c) { let m = 4 * ((c - f) * t + u + a); xv.red = U.byteToFloat(o[m]), xv.green = U.byteToFloat(o[m + 1]), xv.blue = U.byteToFloat(o[m + 2]), xv.alpha = U.byteToFloat(o[m + 3]); let A = i.getObjectByPickColor(xv); if (l(A)) return A } if (u === f || u < 0 && -u === f || u > 0 && u === 1 - f) { let m = d; d = -p, p = m } u += d, f += p } }; Tv.prototype.isDestroyed = function () { return !1 }; Tv.prototype.destroy = function () { return this._fb.destroy(), le(this) }; var nU = Tv; function pp() { this._numSamples = 1, this._colorFramebuffer = new si({ depthStencil: !0, supportsDepthTexture: !0 }), this._idFramebuffer = new si({ depthStencil: !0, supportsDepthTexture: !0 }), this._idClearColor = new U(0, 0, 0, 0), this._clearCommand = new ti({ color: new U(0, 0, 0, 0), depth: 1, owner: this }) } function sat(e) { e._colorFramebuffer.destroy(), e._idFramebuffer.destroy() } Object.defineProperties(pp.prototype, { framebuffer: { get: function () { return this._colorFramebuffer.framebuffer } }, idFramebuffer: { get: function () { return this._idFramebuffer.framebuffer } }, depthStencilTexture: { get: function () { return this._colorFramebuffer.getDepthStencilTexture() } } }); pp.prototype.update = function (e, t, n, i) { let o = t.width, r = t.height, s = n ? e.halfFloatingPointTexture ? Ye.HALF_FLOAT : Ye.FLOAT : Ye.UNSIGNED_BYTE; this._numSamples = i, this._colorFramebuffer.update(e, o, r, i, s), this._idFramebuffer.update(e, o, r) }; pp.prototype.clear = function (e, t, n) { U.clone(n, this._clearCommand.color), U.clone(this._idClearColor, this._clearCommand.color), this._colorFramebuffer.clear(e, this._clearCommand, t), this._idFramebuffer.clear(e, this._clearCommand, t) }; pp.prototype.getFramebuffer = function () { return this._colorFramebuffer.framebuffer }; pp.prototype.getIdFramebuffer = function () { return this._idFramebuffer.framebuffer }; pp.prototype.prepareColorTextures = function (e) { this._numSamples > 1 && this._colorFramebuffer.prepareTextures(e) }; pp.prototype.isDestroyed = function () { return !1 }; pp.prototype.destroy = function () { return sat(this), le(this) }; var VE = pp; function uA() { } uA.getShadowCastShaderKeyword = function (e, t, n, i) { return `castShadow ${e} ${t} ${n} ${i}` }; uA.createShadowCastVertexShader = function (e, t, n) {
        let i = e.defines.slice(0), o = e.sources.slice(0); i.push("SHADOW_MAP"), n && i.push("GENERATE_POSITION"); let r = Ue.findPositionVarying(e), s = l(r); if (t && !s) {
            let a = o.length; for (let u = 0; u < a; ++u)o[u] = Ue.replaceMain(o[u], "czm_shadow_cast_main"); let c = `varying vec3 v_positionEC; 
void main() 
{ 
    czm_shadow_cast_main(); 
    v_positionEC = (czm_inverseProjection * gl_Position).xyz; 
}`; o.push(c)
        } return new Ue({ defines: i, sources: o })
    }; uA.createShadowCastFragmentShader = function (e, t, n, i) {
        let o = e.defines.slice(0), r = e.sources.slice(0); o.push("SHADOW_MAP"); let s = Ue.findPositionVarying(e), a = l(s); a || (s = "v_positionEC"); let c = r.length; for (let f = 0; f < c; ++f)r[f] = Ue.replaceMain(r[f], "czm_shadow_cast_main"); let u = ""; return t && (a || (u += `varying vec3 v_positionEC; 
`), u += `uniform vec4 shadowMap_lightPositionEC; 
`), i ? u += `void main() 
{ 
`: u += `void main() 
{ 
    czm_shadow_cast_main(); 
    if (gl_FragColor.a == 0.0) 
    { 
       discard; 
    } 
`, t ? u += `    float distance = length(${s}); 
    if (distance >= shadowMap_lightPositionEC.w) 
    { 
        discard; 
    } 
    distance /= shadowMap_lightPositionEC.w; // radius 
    gl_FragColor = czm_packDepth(distance); 
`: n ? u += `    gl_FragColor = vec4(1.0); 
`: u += `    gl_FragColor = czm_packDepth(gl_FragCoord.z); 
`, u += `} 
`, r.push(u), new Ue({ defines: o, sources: r })
    }; uA.getShadowReceiveShaderKeyword = function (e, t, n, i) { let o = e._usesDepthTexture, r = e._polygonOffsetSupported, s = e._isPointLight, a = e._isSpotLight, c = e._numberOfCascades > 1, u = e.debugCascadeColors, f = e.softShadows; return `receiveShadow ${o}${r}${s}${a}${c}${u}${f}${t}${n}${i}` }; uA.createShadowReceiveVertexShader = function (e, t, n) { let i = e.defines.slice(0), o = e.sources.slice(0); return i.push("SHADOW_MAP"), t && (n ? i.push("GENERATE_POSITION_AND_NORMAL") : i.push("GENERATE_POSITION")), new Ue({ defines: i, sources: o }) }; uA.createShadowReceiveFragmentShader = function (e, t, n, i, o) {
        let r = Ue.findNormalVarying(e), s = !i && l(r) || i && o, a = Ue.findPositionVarying(e), c = l(a), u = t._usesDepthTexture, f = t._polygonOffsetSupported, d = t._isPointLight, p = t._isSpotLight, g = t._numberOfCascades > 1, m = t.debugCascadeColors, A = t.softShadows, C = d ? t._pointBias : i ? t._terrainBias : t._primitiveBias, x = e.defines.slice(0), T = e.sources.slice(0), b = T.length; for (let P = 0; P < b; ++P)T[P] = Ue.replaceMain(T[P], "czm_shadow_receive_main"); d ? x.push("USE_CUBE_MAP_SHADOW") : u && x.push("USE_SHADOW_DEPTH_TEXTURE"), A && !d && x.push("USE_SOFT_SHADOWS"), g && n && i && (s ? x.push("ENABLE_VERTEX_LIGHTING") : x.push("ENABLE_DAYNIGHT_SHADING")), n && C.normalShading && s && (x.push("USE_NORMAL_SHADING"), C.normalShadingSmooth > 0 && x.push("USE_NORMAL_SHADING_SMOOTH")); let S = ""; d ? S += `uniform samplerCube shadowMap_textureCube; 
`: S += `uniform sampler2D shadowMap_texture; 
`; let D; return c ? D = `    return vec4(${a}, 1.0); 
`: D = `#ifndef LOG_DEPTH 
    return czm_windowToEyeCoordinates(gl_FragCoord); 
#else 
    return vec4(v_logPositionEC, 1.0); 
#endif 
`, S += `uniform mat4 shadowMap_matrix; 
uniform vec3 shadowMap_lightDirectionEC; 
uniform vec4 shadowMap_lightPositionEC; 
uniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; 
uniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; 
#ifdef LOG_DEPTH 
varying vec3 v_logPositionEC; 
#endif 
vec4 getPositionEC() 
{ 
${D}} 
vec3 getNormalEC() 
{ 
${s ? `    return normalize(${r}); 
`: `    return vec3(1.0); 
`}} 
void applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) 
{ 
${C.normalOffset && s ? `    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; 
    float normalOffsetScale = 1.0 - nDotL; 
    vec3 offset = normalOffset * normalOffsetScale * normalEC; 
    positionEC.xyz += offset; 
`: ""}} 
`, S += `void main() 
{ 
    czm_shadow_receive_main(); 
    vec4 positionEC = getPositionEC(); 
    vec3 normalEC = getNormalEC(); 
    float depth = -positionEC.z; 
`, S += `    czm_shadowParameters shadowParameters; 
    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; 
    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; 
    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; 
    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; 
`, i ? S += `    shadowParameters.depthBias *= max(depth * 0.01, 1.0); 
`: f || (S += `    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); 
`), d ? S += `    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; 
    float distance = length(directionEC); 
    directionEC = normalize(directionEC); 
    float radius = shadowMap_lightPositionEC.w; 
    // Stop early if the fragment is beyond the point light radius 
    if (distance > radius) 
    { 
        return; 
    } 
    vec3 directionWC  = czm_inverseViewRotation * directionEC; 
    shadowParameters.depth = distance / radius; 
    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); 
    shadowParameters.texCoords = directionWC; 
    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); 
`: p ? S += `    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); 
    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); 
    applyNormalOffset(positionEC, normalEC, nDotL); 
    vec4 shadowPosition = shadowMap_matrix * positionEC; 
    // Spot light uses a perspective projection, so perform the perspective divide 
    shadowPosition /= shadowPosition.w; 
    // Stop early if the fragment is not in the shadow bounds 
    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) 
    { 
        return; 
    } 
    shadowParameters.texCoords = shadowPosition.xy; 
    shadowParameters.depth = shadowPosition.z; 
    shadowParameters.nDotL = nDotL; 
    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); 
`: g ? S += `    float maxDepth = shadowMap_cascadeSplits[1].w; 
    // Stop early if the eye depth exceeds the last cascade 
    if (depth > maxDepth) 
    { 
        return; 
    } 
    // Get the cascade based on the eye-space depth 
    vec4 weights = czm_cascadeWeights(depth); 
    // Apply normal offset 
    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); 
    applyNormalOffset(positionEC, normalEC, nDotL); 
    // Transform position into the cascade 
    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; 
    // Get visibility 
    shadowParameters.texCoords = shadowPosition.xy; 
    shadowParameters.depth = shadowPosition.z; 
    shadowParameters.nDotL = nDotL; 
    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); 
    // Fade out shadows that are far away 
    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; 
    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); 
    visibility = mix(visibility, 1.0, fade); 
${m ? `    // Draw cascade colors for debugging 
    gl_FragColor *= czm_cascadeColor(weights); 
`: ""}` : S += `    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); 
    applyNormalOffset(positionEC, normalEC, nDotL); 
    vec4 shadowPosition = shadowMap_matrix * positionEC; 
    // Stop early if the fragment is not in the shadow bounds 
    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) 
    { 
        return; 
    } 
    shadowParameters.texCoords = shadowPosition.xy; 
    shadowParameters.depth = shadowPosition.z; 
    shadowParameters.nDotL = nDotL; 
    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); 
`, S += `    gl_FragColor.rgb *= visibility; 
} 
`, T.push(S), new Ue({ defines: x, sources: T })
    }; var _p = uA; function Lh(e) { e = y(e, y.EMPTY_OBJECT); let t = e.context; this._enabled = y(e.enabled, !0), this._softShadows = y(e.softShadows, !1), this._normalOffset = y(e.normalOffset, !0), this.dirty = !0, this.fromLightSource = y(e.fromLightSource, !0), this.darkness = y(e.darkness, .3), this._darkness = this.darkness, this.fadingEnabled = y(e.fadingEnabled, !0), this.maximumDistance = y(e.maximumDistance, 5e3), this._outOfView = !1, this._outOfViewPrevious = !1, this._needsUpdate = !0; let n = !0; (Nt.isInternetExplorer() || Nt.isEdge() || (Nt.isChrome() || Nt.isFirefox()) && Nt.isWindows() && !t.depthTexture) && (n = !1), this._polygonOffsetSupported = n, this._terrainBias = { polygonOffset: n, polygonOffsetFactor: 1.1, polygonOffsetUnits: 4, normalOffset: this._normalOffset, normalOffsetScale: .5, normalShading: !0, normalShadingSmooth: .3, depthBias: 1e-4 }, this._primitiveBias = { polygonOffset: n, polygonOffsetFactor: 1.1, polygonOffsetUnits: 4, normalOffset: this._normalOffset, normalOffsetScale: .1, normalShading: !0, normalShadingSmooth: .05, depthBias: 2e-5 }, this._pointBias = { polygonOffset: !1, polygonOffsetFactor: 1.1, polygonOffsetUnits: 4, normalOffset: this._normalOffset, normalOffsetScale: 0, normalShading: !0, normalShadingSmooth: .1, depthBias: 5e-4 }, this._depthAttachment = void 0, this._colorAttachment = void 0, this._shadowMapMatrix = new F, this._shadowMapTexture = void 0, this._lightDirectionEC = new h, this._lightPositionEC = new se, this._distance = 0, this._lightCamera = e.lightCamera, this._shadowMapCamera = new iU, this._shadowMapCullingVolume = void 0, this._sceneCamera = void 0, this._boundingSphere = new re, this._isPointLight = y(e.isPointLight, !1), this._pointLightRadius = y(e.pointLightRadius, 100), this._cascadesEnabled = this._isPointLight ? !1 : y(e.cascadesEnabled, !0), this._numberOfCascades = this._cascadesEnabled ? y(e.numberOfCascades, 4) : 0, this._fitNearFar = !0, this._maximumCascadeDistances = [25, 150, 700, Number.MAX_VALUE], this._textureSize = new H, this._isSpotLight = !1, this._cascadesEnabled ? this._shadowMapCamera.frustum = new wr : l(this._lightCamera.frustum.fov) && (this._isSpotLight = !0), this._cascadeSplits = [new se, new se], this._cascadeMatrices = [new F, new F, new F, new F], this._cascadeDistances = new se; let i; this._isPointLight ? i = 6 : this._cascadesEnabled ? i = this._numberOfCascades : i = 1, this._passes = new Array(i); for (let o = 0; o < i; ++o)this._passes[o] = new aat(t); this.debugShow = !1, this.debugFreezeFrame = !1, this._debugFreezeFrame = !1, this._debugCascadeColors = !1, this._debugLightFrustum = void 0, this._debugCameraFrustum = void 0, this._debugCascadeFrustums = new Array(this._numberOfCascades), this._debugShadowViewCommand = void 0, this._usesDepthTexture = t.depthTexture, this._isPointLight && (this._usesDepthTexture = !1), this._primitiveRenderState = void 0, this._terrainRenderState = void 0, this._pointRenderState = void 0, wj(this), this._clearCommand = new ti({ depth: 1, color: new U }), this._clearPassState = new pc(t), this._size = y(e.size, 2048), this.size = this._size } Lh.MAXIMUM_DISTANCE = 2e4; function aat(e) { this.camera = new iU, this.passState = new pc(e), this.framebuffer = void 0, this.textureOffsets = void 0, this.commandList = [], this.cullingVolume = void 0 } function Sj(e, t) { return Ve.fromCache({ cull: { enabled: !0, face: gi.BACK }, depthTest: { enabled: !0 }, colorMask: { red: e, green: e, blue: e, alpha: e }, depthMask: !0, polygonOffset: { enabled: t.polygonOffset, factor: t.polygonOffsetFactor, units: t.polygonOffsetUnits } }) } function wj(e) { let t = !e._usesDepthTexture; e._primitiveRenderState = Sj(t, e._primitiveBias), e._terrainRenderState = Sj(t, e._terrainBias), e._pointRenderState = Sj(t, e._pointBias) } Lh.prototype.debugCreateRenderStates = function () { wj(this) }; Object.defineProperties(Lh.prototype, { enabled: { get: function () { return this._enabled }, set: function (e) { this.dirty = this._enabled !== e, this._enabled = e } }, normalOffset: { get: function () { return this._normalOffset }, set: function (e) { this.dirty = this._normalOffset !== e, this._normalOffset = e, this._terrainBias.normalOffset = e, this._primitiveBias.normalOffset = e, this._pointBias.normalOffset = e } }, softShadows: { get: function () { return this._softShadows }, set: function (e) { this.dirty = this._softShadows !== e, this._softShadows = e } }, size: { get: function () { return this._size }, set: function (e) { hat(this, e) } }, outOfView: { get: function () { return this._outOfView } }, shadowMapCullingVolume: { get: function () { return this._shadowMapCullingVolume } }, passes: { get: function () { return this._passes } }, isPointLight: { get: function () { return this._isPointLight } }, debugCascadeColors: { get: function () { return this._debugCascadeColors }, set: function (e) { this.dirty = this._debugCascadeColors !== e, this._debugCascadeColors = e } } }); function Dj(e) { let t = e._passes.length; for (let n = 0; n < t; ++n) { let i = e._passes[n], o = i.framebuffer; l(o) && !o.isDestroyed() && o.destroy(), i.framebuffer = void 0 } e._depthAttachment = e._depthAttachment && e._depthAttachment.destroy(), e._colorAttachment = e._colorAttachment && e._colorAttachment.destroy() } function cat(e, t) { let n = new hu({ context: t, width: e._textureSize.x, height: e._textureSize.y, format: Uc.DEPTH_COMPONENT16 }), i = new Rt({ context: t, width: e._textureSize.x, height: e._textureSize.y, pixelFormat: ht.RGBA, pixelDatatype: Ye.UNSIGNED_BYTE, sampler: dn.NEAREST }), o = new Js({ context: t, depthRenderbuffer: n, colorTextures: [i], destroyAttachments: !1 }), r = e._passes.length; for (let s = 0; s < r; ++s) { let a = e._passes[s]; a.framebuffer = o, a.passState.framebuffer = o } e._shadowMapTexture = i, e._depthAttachment = n, e._colorAttachment = i } function lat(e, t) { let n = new Rt({ context: t, width: e._textureSize.x, height: e._textureSize.y, pixelFormat: ht.DEPTH_STENCIL, pixelDatatype: Ye.UNSIGNED_INT_24_8, sampler: dn.NEAREST }), i = new Js({ context: t, depthStencilTexture: n, destroyAttachments: !1 }), o = e._passes.length; for (let r = 0; r < o; ++r) { let s = e._passes[r]; s.framebuffer = i, s.passState.framebuffer = i } e._shadowMapTexture = n, e._depthAttachment = n } function uat(e, t) { let n = new hu({ context: t, width: e._textureSize.x, height: e._textureSize.y, format: Uc.DEPTH_COMPONENT16 }), i = new Xa({ context: t, width: e._textureSize.x, height: e._textureSize.y, pixelFormat: ht.RGBA, pixelDatatype: Ye.UNSIGNED_BYTE, sampler: dn.NEAREST }), o = [i.negativeX, i.negativeY, i.negativeZ, i.positiveX, i.positiveY, i.positiveZ]; for (let r = 0; r < 6; ++r) { let s = new Js({ context: t, depthRenderbuffer: n, colorTextures: [o[r]], destroyAttachments: !1 }), a = e._passes[r]; a.framebuffer = s, a.passState.framebuffer = s } e._shadowMapTexture = i, e._depthAttachment = n, e._colorAttachment = i } function N_e(e, t) { e._isPointLight ? uat(e, t) : e._usesDepthTexture ? lat(e, t) : cat(e, t) } function fat(e, t) { e._usesDepthTexture && e._passes[0].framebuffer.status !== te.FRAMEBUFFER_COMPLETE && (e._usesDepthTexture = !1, wj(e), Dj(e), N_e(e, t)) } function dat(e, t) { (!l(e._passes[0].framebuffer) || e._shadowMapTexture.width !== e._textureSize.x) && (Dj(e), N_e(e, t), fat(e, t), V_e(e, t)) } function V_e(e, t, n) { n = y(n, 0), (e._isPointLight || n === 0) && (e._clearCommand.framebuffer = e._passes[n].framebuffer, e._clearCommand.execute(t, e._clearPassState)) } function hat(e, t) { e._size = t; let n = e._passes, i = n.length, o = e._textureSize; if (e._isPointLight) { t = Ut.maximumCubeMapSize >= t ? t : Ut.maximumCubeMapSize, o.x = t, o.y = t; let r = new Ge(0, 0, t, t); n[0].passState.viewport = r, n[1].passState.viewport = r, n[2].passState.viewport = r, n[3].passState.viewport = r, n[4].passState.viewport = r, n[5].passState.viewport = r } else i === 1 ? (t = Ut.maximumTextureSize >= t ? t : Ut.maximumTextureSize, o.x = t, o.y = t, n[0].passState.viewport = new Ge(0, 0, t, t)) : i === 4 && (t = Ut.maximumTextureSize >= t * 2 ? t : Ut.maximumTextureSize / 2, o.x = t * 2, o.y = t * 2, n[0].passState.viewport = new Ge(0, 0, t, t), n[1].passState.viewport = new Ge(t, 0, t, t), n[2].passState.viewport = new Ge(0, t, t, t), n[3].passState.viewport = new Ge(t, t, t, t)); e._clearPassState.viewport = new Ge(0, 0, o.x, o.y); for (let r = 0; r < i; ++r) { let s = n[r], a = s.passState.viewport, c = a.x / o.x, u = a.y / o.y, f = a.width / o.x, d = a.height / o.y; s.textureOffsets = new F(f, 0, 0, c, 0, d, 0, u, 0, 0, 1, 0, 0, 0, 0, 1) } } var mat = new Ge; function pat(e, t) {
        let n; e._isPointLight ? n = `uniform samplerCube shadowMap_textureCube; 
varying vec2 v_textureCoordinates; 
void main() 
{ 
    vec2 uv = v_textureCoordinates; 
    vec3 dir; 
 
    if (uv.y < 0.5) 
    { 
        if (uv.x < 0.333) 
        { 
            dir.x = -1.0; 
            dir.y = uv.x * 6.0 - 1.0; 
            dir.z = uv.y * 4.0 - 1.0; 
        } 
        else if (uv.x < 0.666) 
        { 
            dir.y = -1.0; 
            dir.x = uv.x * 6.0 - 3.0; 
            dir.z = uv.y * 4.0 - 1.0; 
        } 
        else 
        { 
            dir.z = -1.0; 
            dir.x = uv.x * 6.0 - 5.0; 
            dir.y = uv.y * 4.0 - 1.0; 
        } 
    } 
    else 
    { 
        if (uv.x < 0.333) 
        { 
            dir.x = 1.0; 
            dir.y = uv.x * 6.0 - 1.0; 
            dir.z = uv.y * 4.0 - 3.0; 
        } 
        else if (uv.x < 0.666) 
        { 
            dir.y = 1.0; 
            dir.x = uv.x * 6.0 - 3.0; 
            dir.z = uv.y * 4.0 - 3.0; 
        } 
        else 
        { 
            dir.z = 1.0; 
            dir.x = uv.x * 6.0 - 5.0; 
            dir.y = uv.y * 4.0 - 3.0; 
        } 
    } 
 
    float shadow = czm_unpackDepth(textureCube(shadowMap_textureCube, dir)); 
    gl_FragColor = vec4(vec3(shadow), 1.0); 
} 
`: n = `uniform sampler2D shadowMap_texture; 
varying vec2 v_textureCoordinates; 
void main() 
{ 
${e._usesDepthTexture ? `    float shadow = texture2D(shadowMap_texture, v_textureCoordinates).r; 
`: `    float shadow = czm_unpackDepth(texture2D(shadowMap_texture, v_textureCoordinates)); 
`}    gl_FragColor = vec4(vec3(shadow), 1.0); 
} 
`; let i = t.createViewportQuadCommand(n, { uniformMap: { shadowMap_texture: function () { return e._shadowMapTexture }, shadowMap_textureCube: function () { return e._shadowMapTexture } } }); return i.pass = xe.OVERLAY, i
    } function _at(e, t) { let n = t.context, i = t.context.drawingBufferWidth, o = t.context.drawingBufferHeight, r = Math.min(i, o) * .3, s = mat; s.x = i - r, s.y = 0, s.width = r, s.height = r; let a = e._debugShadowViewCommand; l(a) || (a = pat(e, n), e._debugShadowViewCommand = a), (!l(a.renderState) || !Ge.equals(a.renderState.viewport, s)) && (a.renderState = Ve.fromCache({ viewport: Ge.clone(s) })), t.commandList.push(e._debugShadowViewCommand) } var Fh = new Array(8); Fh[0] = new se(-1, -1, -1, 1); Fh[1] = new se(1, -1, -1, 1); Fh[2] = new se(1, 1, -1, 1); Fh[3] = new se(-1, 1, -1, 1); Fh[4] = new se(-1, -1, 1, 1); Fh[5] = new se(1, -1, 1, 1); Fh[6] = new se(1, 1, 1, 1); Fh[7] = new se(-1, 1, 1, 1); var qg = new F, vj = new Array(8); for (let e = 0; e < 8; ++e)vj[e] = new se; function gat(e, t) { let n = new At({ geometry: new bd({ minimum: new h(-.5, -.5, -.5), maximum: new h(.5, .5, .5) }), attributes: { color: Bt.fromColor(t) } }), i = new At({ geometry: new L_({ radius: .5 }), attributes: { color: Bt.fromColor(t) } }); return new xn({ geometryInstances: [n, i], appearance: new $t({ translucent: !1, flat: !0 }), asynchronous: !1, modelMatrix: e }) } var yat = [U.RED, U.GREEN, U.BLUE, U.MAGENTA], Aat = new h; function Cat(e, t) { _at(e, t); let n = e.debugFreezeFrame && !e._debugFreezeFrame; if (e._debugFreezeFrame = e.debugFreezeFrame, e.debugFreezeFrame && (n && (e._debugCameraFrustum = e._debugCameraFrustum && e._debugCameraFrustum.destroy(), e._debugCameraFrustum = new dp({ camera: e._sceneCamera, color: U.CYAN, updateOnChange: !1 })), e._debugCameraFrustum.update(t)), e._cascadesEnabled) { if (e.debugFreezeFrame) { n && (e._debugLightFrustum = e._debugLightFrustum && e._debugLightFrustum.destroy(), e._debugLightFrustum = new dp({ camera: e._shadowMapCamera, color: U.YELLOW, updateOnChange: !1 })), e._debugLightFrustum.update(t); for (let i = 0; i < e._numberOfCascades; ++i)n && (e._debugCascadeFrustums[i] = e._debugCascadeFrustums[i] && e._debugCascadeFrustums[i].destroy(), e._debugCascadeFrustums[i] = new dp({ camera: e._passes[i].camera, color: yat[i], updateOnChange: !1 })), e._debugCascadeFrustums[i].update(t) } } else if (e._isPointLight) { if (!l(e._debugLightFrustum) || e._needsUpdate) { let i = e._shadowMapCamera.positionWC, o = Be.IDENTITY, r = e._pointLightRadius * 2, s = h.fromElements(r, r, r, Aat), a = F.fromTranslationQuaternionRotationScale(i, o, s, qg); e._debugLightFrustum = e._debugLightFrustum && e._debugLightFrustum.destroy(), e._debugLightFrustum = gat(a, U.YELLOW) } e._debugLightFrustum.update(t) } else (!l(e._debugLightFrustum) || e._needsUpdate) && (e._debugLightFrustum = new dp({ camera: e._shadowMapCamera, color: U.YELLOW, updateOnChange: !1 })), e._debugLightFrustum.update(t) } function iU() { this.viewMatrix = new F, this.inverseViewMatrix = new F, this.frustum = void 0, this.positionCartographic = new he, this.positionWC = new h, this.directionWC = h.clone(h.UNIT_Z), this.upWC = h.clone(h.UNIT_Y), this.rightWC = h.clone(h.UNIT_X), this.viewProjectionMatrix = new F } iU.prototype.clone = function (e) { F.clone(e.viewMatrix, this.viewMatrix), F.clone(e.inverseViewMatrix, this.inverseViewMatrix), this.frustum = e.frustum.clone(this.frustum), he.clone(e.positionCartographic, this.positionCartographic), h.clone(e.positionWC, this.positionWC), h.clone(e.directionWC, this.directionWC), h.clone(e.upWC, this.upWC), h.clone(e.rightWC, this.rightWC) }; var xat = new F(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1); iU.prototype.getViewProjection = function () { let e = this.viewMatrix, t = this.frustum.projectionMatrix; return F.multiply(t, e, this.viewProjectionMatrix), F.multiply(xat, this.viewProjectionMatrix, this.viewProjectionMatrix), this.viewProjectionMatrix }; var Tat = new Array(5), Eat = new mi, bat = new Array(4), k_e = new h, U_e = new h; function Sat(e, t) { let n = e._shadowMapCamera, i = e._sceneCamera, o = i.frustum.near, r = i.frustum.far, s = e._numberOfCascades, a, c = r - o, u = r / o, f = .9, d = !1; t.shadowState.closestObjectSize < 200 && (d = !0, f = .9); let p = bat, g = Tat; for (g[0] = o, g[s] = r, a = 0; a < s; ++a) { let L = (a + 1) / s, _ = o * Math.pow(u, L), E = o + c * L, w = I.lerp(E, _, f); g[a + 1] = w, p[a] = w - g[a] } if (d) { for (a = 0; a < s; ++a)p[a] = Math.min(p[a], e._maximumCascadeDistances[a]); let L = g[0]; for (a = 0; a < s - 1; ++a)L += p[a], g[a + 1] = L } se.unpack(g, 0, e._cascadeSplits[0]), se.unpack(g, 1, e._cascadeSplits[1]), se.unpack(p, 0, e._cascadeDistances); let m = n.frustum, A = m.left, C = m.right, x = m.bottom, T = m.top, b = m.near, S = m.far, D = n.positionWC, P = n.directionWC, B = n.upWC, R = i.frustum.clone(Eat), M = n.getViewProjection(); for (a = 0; a < s; ++a) { R.near = g[a], R.far = g[a + 1]; let L = F.multiply(R.projectionMatrix, i.viewMatrix, qg), _ = F.inverse(L, qg), E = F.multiply(M, _, qg), w = h.fromElements(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, k_e), v = h.fromElements(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, U_e); for (let G = 0; G < 8; ++G) { let N = se.clone(Fh[G], vj[G]); F.multiplyByVector(E, N, N), h.divideByScalar(N, N.w, N), h.minimumByComponent(N, w, w), h.maximumByComponent(N, v, v) } w.x = Math.max(w.x, 0), w.y = Math.max(w.y, 0), w.z = 0, v.x = Math.min(v.x, 1), v.y = Math.min(v.y, 1), v.z = Math.min(v.z, 1); let O = e._passes[a], V = O.camera; V.clone(n); let z = V.frustum; z.left = A + w.x * (C - A), z.right = A + v.x * (C - A), z.bottom = x + w.y * (T - x), z.top = x + v.y * (T - x), z.near = b + w.z * (S - b), z.far = b + v.z * (S - b), O.cullingVolume = V.frustum.computeCullingVolume(D, P, B); let k = e._cascadeMatrices[a]; F.multiply(V.getViewProjection(), i.inverseViewMatrix, k), F.multiply(O.textureOffsets, k, k) } } var wat = new F, Dat = new h, vat = new h, L_e = new h; function Pat(e, t) { let n = e._shadowMapCamera, i = e._sceneCamera, o = F.multiply(i.frustum.projectionMatrix, i.viewMatrix, qg), r = F.inverse(o, qg), s = n.directionWC, a = i.directionWC; h.equalsEpsilon(s, a, I.EPSILON10) && (a = i.upWC); let c = h.cross(s, a, Dat); a = h.cross(c, s, vat), h.normalize(a, a), h.normalize(c, c); let u = h.fromElements(0, 0, 0, L_e), f = F.computeView(u, s, a, c, wat), d = F.multiply(f, r, qg), p = h.fromElements(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, k_e), g = h.fromElements(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, U_e); for (let S = 0; S < 8; ++S) { let D = se.clone(Fh[S], vj[S]); F.multiplyByVector(d, D, D), h.divideByScalar(D, D.w, D), h.minimumByComponent(D, p, p), h.maximumByComponent(D, g, g) } g.z += 1e3, p.z -= 10; let m = L_e; m.x = -(.5 * (p.x + g.x)), m.y = -(.5 * (p.y + g.y)), m.z = -g.z; let A = F.fromTranslation(m, qg); f = F.multiply(A, f, f); let C = .5 * (g.x - p.x), x = .5 * (g.y - p.y), T = g.z - p.z, b = n.frustum; b.left = -C, b.right = C, b.bottom = -x, b.top = x, b.near = .01, b.far = T, F.clone(f, n.viewMatrix), F.inverse(f, n.inverseViewMatrix), F.getTranslation(n.inverseViewMatrix, n.positionWC), t.mapProjection.ellipsoid.cartesianToCartographic(n.positionWC, n.positionCartographic), h.clone(s, n.directionWC), h.clone(a, n.upWC), h.clone(c, n.rightWC) } var Iat = [new h(-1, 0, 0), new h(0, -1, 0), new h(0, 0, -1), new h(1, 0, 0), new h(0, 1, 0), new h(0, 0, 1)], Oat = [new h(0, -1, 0), new h(0, 0, -1), new h(0, -1, 0), new h(0, -1, 0), new h(0, 0, 1), new h(0, -1, 0)], Bat = [new h(0, 0, 1), new h(1, 0, 0), new h(-1, 0, 0), new h(0, 0, -1), new h(1, 0, 0), new h(1, 0, 0)]; function Rat(e, t) { let n = new mi; n.fov = I.PI_OVER_TWO, n.near = 1, n.far = e._pointLightRadius, n.aspectRatio = 1; for (let i = 0; i < 6; ++i) { let o = e._passes[i].camera; o.positionWC = e._shadowMapCamera.positionWC, o.positionCartographic = t.mapProjection.ellipsoid.cartesianToCartographic(o.positionWC, o.positionCartographic), o.directionWC = Iat[i], o.upWC = Oat[i], o.rightWC = Bat[i], F.computeView(o.positionWC, o.directionWC, o.upWC, o.rightWC, o.viewMatrix), F.inverse(o.viewMatrix, o.inverseViewMatrix), o.frustum = n } } var Mat = new h, Lat = new h, z_e = new re, F_e = z_e.center; function Fat(e, t) { let n = e._sceneCamera, i = e._shadowMapCamera, o = z_e; if (e._cascadesEnabled) { if (n.frustum.near >= e.maximumDistance) { e._outOfView = !0, e._needsUpdate = !1; return } let r = t.mapProjection.ellipsoid.geodeticSurfaceNormal(n.positionWC, Mat), s = h.negate(i.directionWC, Lat), a = h.dot(r, s); if (e.fadingEnabled) { let c = I.clamp(a / .1, 0, 1); e._darkness = I.lerp(1, e.darkness, c) } else e._darkness = e.darkness; if (a < 0) { e._outOfView = !0, e._needsUpdate = !1; return } e._needsUpdate = !0, e._outOfView = !1 } else if (e._isPointLight) o.center = i.positionWC, o.radius = e._pointLightRadius, e._outOfView = t.cullingVolume.computeVisibility(o) === Kt.OUTSIDE, e._needsUpdate = !e._outOfView && !e._boundingSphere.equals(o), re.clone(o, e._boundingSphere); else { let r = i.frustum.far / 2, s = h.add(i.positionWC, h.multiplyByScalar(i.directionWC, r, F_e), F_e); o.center = s, o.radius = r, e._outOfView = t.cullingVolume.computeVisibility(o) === Kt.OUTSIDE, e._needsUpdate = !e._outOfView && !e._boundingSphere.equals(o), re.clone(o, e._boundingSphere) } } function Nat(e, t) { let n = t.camera, i = e._lightCamera, o = e._sceneCamera, r = e._shadowMapCamera; e._cascadesEnabled ? h.clone(i.directionWC, r.directionWC) : e._isPointLight ? h.clone(i.positionWC, r.positionWC) : r.clone(i); let s = e._lightDirectionEC; F.multiplyByPointAsVector(n.viewMatrix, r.directionWC, s), h.normalize(s, s), h.negate(s, s), F.multiplyByPoint(n.viewMatrix, r.positionWC, e._lightPositionEC), e._lightPositionEC.w = e._pointLightRadius; let a, c; e._fitNearFar ? (a = Math.min(t.shadowState.nearPlane, e.maximumDistance), c = Math.min(t.shadowState.farPlane, e.maximumDistance), c = Math.max(c, a + 1)) : (a = n.frustum.near, c = e.maximumDistance), e._sceneCamera = oo.clone(n, o), n.frustum.clone(e._sceneCamera.frustum), e._sceneCamera.frustum.near = a, e._sceneCamera.frustum.far = c, e._distance = c - a, Fat(e, t), !e._outOfViewPrevious && e._outOfView && (e._needsUpdate = !0), e._outOfViewPrevious = e._outOfView } Lh.prototype.update = function (e) { if (Nat(this, e), this._needsUpdate) if (dat(this, e.context), this._isPointLight && Rat(this, e), this._cascadesEnabled && (Pat(this, e), this._numberOfCascades > 1 && Sat(this, e)), this._isPointLight) this._shadowMapCullingVolume = Xs.fromBoundingSphere(this._boundingSphere); else { let t = this._shadowMapCamera, n = t.positionWC, i = t.directionWC, o = t.upWC; this._shadowMapCullingVolume = t.frustum.computeCullingVolume(n, i, o), this._passes.length === 1 && this._passes[0].camera.clone(t) } if (this._passes.length === 1) { let t = this._sceneCamera.inverseViewMatrix; F.multiply(this._shadowMapCamera.getViewProjection(), t, this._shadowMapMatrix) } this.debugShow && Cat(this, e) }; Lh.prototype.updatePass = function (e, t) { V_e(this, e, t) }; var Vat = new H; function H_e(e, t, n) { let i = e._isPointLight ? e._pointBias : n ? e._terrainBias : e._primitiveBias, o = { shadowMap_texture: function () { return e._shadowMapTexture }, shadowMap_textureCube: function () { return e._shadowMapTexture }, shadowMap_matrix: function () { return e._shadowMapMatrix }, shadowMap_cascadeSplits: function () { return e._cascadeSplits }, shadowMap_cascadeMatrices: function () { return e._cascadeMatrices }, shadowMap_lightDirectionEC: function () { return e._lightDirectionEC }, shadowMap_lightPositionEC: function () { return e._lightPositionEC }, shadowMap_cascadeDistances: function () { return e._cascadeDistances }, shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function () { let r = Vat; return r.x = 1 / e._textureSize.x, r.y = 1 / e._textureSize.y, se.fromElements(r.x, r.y, i.depthBias, i.normalShadingSmooth, this.combinedUniforms1) }, shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function () { return se.fromElements(i.normalOffsetScale, e._distance, e.maximumDistance, e._darkness, this.combinedUniforms2) }, combinedUniforms1: new se, combinedUniforms2: new se }; return yt(t, o, !1) } function kat(e, t, n, i, o, r) { let s, a, c; if (l(r) && (s = r.shaderProgram, a = r.renderState, c = r.uniformMap), r = $e.shallowClone(n, r), r.castShadows = !0, r.receiveShadows = !1, !l(s) || o !== n.shaderProgram.id || t) { let u = n.shaderProgram, f = n.pass === xe.GLOBE, d = n.pass !== xe.TRANSLUCENT, p = e._isPointLight, g = e._usesDepthTexture, m = _p.getShadowCastShaderKeyword(p, f, g, d); if (s = i.shaderCache.getDerivedShaderProgram(u, m), !l(s)) { let C = u.vertexShaderSource, x = u.fragmentShaderSource, T = _p.createShadowCastVertexShader(C, p, f), b = _p.createShadowCastFragmentShader(x, p, g, d); s = i.shaderCache.createDerivedShaderProgram(u, m, { vertexShaderSource: T, fragmentShaderSource: b, attributeLocations: u._attributeLocations }) } a = e._primitiveRenderState, p ? a = e._pointRenderState : f && (a = e._terrainRenderState), n.renderState.cull.enabled || (a = tt(a, !1), a.cull = tt(a.cull, !1), a.cull.enabled = !1, a = Ve.fromCache(a)), c = H_e(e, n.uniformMap, f) } return r.shaderProgram = s, r.renderState = a, r.uniformMap = c, r } Lh.createReceiveDerivedCommand = function (e, t, n, i, o) { l(o) || (o = {}); let r = e.length > 0, s = t.shaderProgram, a = s.vertexShaderSource, c = s.fragmentShaderSource, u = t.pass === xe.GLOBE, f = !1; if (u && (f = t.owner.data.renderedMesh.encoding.hasVertexNormals), t.receiveShadows && r) { let d, p; l(o.receiveCommand) && (d = o.receiveCommand.shaderProgram, p = o.receiveCommand.uniformMap), o.receiveCommand = $e.shallowClone(t, o.receiveCommand), o.castShadows = !1, o.receiveShadows = !0; let g = o.receiveShaderCastShadows !== t.castShadows, m = o.receiveShaderProgramId !== t.shaderProgram.id; if (!l(d) || m || n || g) { let A = _p.getShadowReceiveShaderKeyword(e[0], t.castShadows, u, f); if (d = i.shaderCache.getDerivedShaderProgram(s, A), !l(d)) { let C = _p.createShadowReceiveVertexShader(a, u, f), x = _p.createShadowReceiveFragmentShader(c, e[0], t.castShadows, u, f); d = i.shaderCache.createDerivedShaderProgram(s, A, { vertexShaderSource: C, fragmentShaderSource: x, attributeLocations: s._attributeLocations }) } p = H_e(e[0], t.uniformMap, u) } o.receiveCommand.shaderProgram = d, o.receiveCommand.uniformMap = p, o.receiveShaderProgramId = t.shaderProgram.id, o.receiveShaderCastShadows = t.castShadows } return o }; Lh.createCastDerivedCommand = function (e, t, n, i, o) { if (l(o) || (o = {}), t.castShadows) { let r = o.castCommands; l(r) || (r = o.castCommands = []); let s = o.castShaderProgramId, a = e.length; r.length = a; for (let c = 0; c < a; ++c)r[c] = kat(e[c], n, t, i, s, r[c]); o.castShaderProgramId = t.shaderProgram.id } return o }; Lh.prototype.isDestroyed = function () { return !1 }; Lh.prototype.destroy = function () { Dj(this), this._debugLightFrustum = this._debugLightFrustum && this._debugLightFrustum.destroy(), this._debugCameraFrustum = this._debugCameraFrustum && this._debugCameraFrustum.destroy(), this._debugShadowViewCommand = this._debugShadowViewCommand && this._debugShadowViewCommand.shaderProgram && this._debugShadowViewCommand.shaderProgram.destroy(); for (let e = 0; e < this._numberOfCascades; ++e)this._debugCascadeFrustums[e] = this._debugCascadeFrustums[e] && this._debugCascadeFrustums[e].destroy(); return le(this) }; var Yg = Lh; var oU = `uniform sampler2D u_opaqueDepthTexture;
uniform sampler2D u_translucentDepthTexture;
varying vec2 v_textureCoordinates;
void main()
{
float opaqueDepth = texture2D(u_opaqueDepthTexture, v_textureCoordinates).r;
float translucentDepth = texture2D(u_translucentDepthTexture, v_textureCoordinates).r;
translucentDepth = czm_branchFreeTernary(translucentDepth > opaqueDepth, 1.0, translucentDepth);
gl_FragColor = czm_packDepth(translucentDepth);
}
`; var kE = `uniform sampler2D colorTexture;
#ifdef DEBUG_SHOW_DEPTH
uniform sampler2D u_packedTranslucentDepth;
#endif
varying vec2 v_textureCoordinates;
void main()
{
#ifdef DEBUG_SHOW_DEPTH
if (v_textureCoordinates.x < 0.5)
{
gl_FragColor.rgb = vec3(czm_unpackDepth(texture2D(u_packedTranslucentDepth, v_textureCoordinates)));
gl_FragColor.a = 1.0;
}
#else
vec4 color = texture2D(colorTexture, v_textureCoordinates);
#ifdef PICK
if (color == vec4(0.0))
{
discard;
}
#else
color.rgb /= color.a;
#endif
gl_FragColor = color;
#endif
}
`; var Uat = !1; function Xg(e) { this._drawClassificationFBO = new si({ createDepthAttachments: !1 }), this._accumulationFBO = new si({ createDepthAttachments: !1 }), this._packFBO = new si, this._opaqueDepthStencilTexture = void 0, this._textureToComposite = void 0, this._translucentDepthStencilTexture = void 0, this._packDepthCommand = void 0, this._accumulateCommand = void 0, this._compositeCommand = void 0, this._copyCommand = void 0, this._clearColorCommand = new ti({ color: new U(0, 0, 0, 0), owner: this }), this._clearDepthStencilCommand = new ti({ depth: 1, stencil: 0, owner: this }), this._supported = e.depthTexture, this._viewport = new Ge, this._rsDepth = void 0, this._rsAccumulate = void 0, this._rsComp = void 0, this._useScissorTest = void 0, this._scissorRectangle = void 0, this._hasTranslucentDepth = !1, this._frustumsDrawn = 0 } Object.defineProperties(Xg.prototype, { hasTranslucentDepth: { get: function () { return this._hasTranslucentDepth } } }); function G_e(e) { e._textureToComposite = void 0, e._translucentDepthStencilTexture = e._translucentDepthStencilTexture && !e._translucentDepthStencilTexture.isDestroyed() && e._translucentDepthStencilTexture.destroy() } function W_e(e) { e._drawClassificationFBO.destroy(), e._accumulationFBO.destroy(), e._packFBO.destroy() } function zat(e, t, n, i) { G_e(e), e._translucentDepthStencilTexture = new Rt({ context: t, width: n, height: i, pixelFormat: ht.DEPTH_STENCIL, pixelDatatype: Ye.UNSIGNED_INT_24_8, sampler: dn.NEAREST }) } function Hat(e, t, n, i) { W_e(e), e._drawClassificationFBO.setDepthStencilTexture(e._translucentDepthStencilTexture), e._drawClassificationFBO.update(t, n, i), e._accumulationFBO.setDepthStencilTexture(e._translucentDepthStencilTexture), e._accumulationFBO.update(t, n, i), e._packFBO.update(t, n, i) } function Gat(e, t, n, i) { if (!e.isSupported()) return; e._opaqueDepthStencilTexture = i; let o = e._opaqueDepthStencilTexture.width, r = e._opaqueDepthStencilTexture.height; e._drawClassificationFBO.isDirty(o, r) && (zat(e, t, o, r), Hat(e, t, o, r)); let s, a; if (l(e._packDepthCommand) || (s = new Ue({ sources: [oU] }), a = { u_opaqueDepthTexture: function () { return e._opaqueDepthStencilTexture }, u_translucentDepthTexture: function () { return e._translucentDepthStencilTexture } }, e._packDepthCommand = t.createViewportQuadCommand(s, { uniformMap: a, owner: e })), !l(e._compositeCommand)) { s = new Ue({ sources: [kE] }), a = { colorTexture: function () { return e._textureToComposite } }, Uat && (s.defines = ["DEBUG_SHOW_DEPTH"], a.u_packedTranslucentDepth = function () { return e._packFBO.getColorTexture() }), e._compositeCommand = t.createViewportQuadCommand(s, { uniformMap: a, owner: e }); let f = e._compositeCommand, d = f.shaderProgram, p = t.shaderCache.createDerivedShaderProgram(d, "pick", { vertexShaderSource: d.vertexShaderSource, fragmentShaderSource: new Ue({ sources: s.sources, defines: ["PICK"] }), attributeLocations: d._attributeLocations }), g = $e.shallowClone(f); g.shaderProgram = p, f.derivedCommands.pick = g } l(e._copyCommand) || (s = new Ue({ sources: [kE] }), a = { colorTexture: function () { return e._drawClassificationFBO.getColorTexture() } }, e._copyCommand = t.createViewportQuadCommand(s, { uniformMap: a, owner: e })), l(e._accumulateCommand) || (s = new Ue({ sources: [kE] }), a = { colorTexture: function () { return e._drawClassificationFBO.getColorTexture() } }, e._accumulateCommand = t.createViewportQuadCommand(s, { uniformMap: a, owner: e })), e._viewport.width = o, e._viewport.height = r; let c = !Ge.equals(e._viewport, n.viewport), u = c !== e._useScissorTest; e._useScissorTest = c, Ge.equals(e._scissorRectangle, n.viewport) || (e._scissorRectangle = Ge.clone(n.viewport, e._scissorRectangle), u = !0), (!l(e._rsDepth) || !Ge.equals(e._viewport, e._rsDepth.viewport) || u) && (e._rsDepth = Ve.fromCache({ viewport: e._viewport, scissorTest: { enabled: e._useScissorTest, rectangle: e._scissorRectangle } })), l(e._packDepthCommand) && (e._packDepthCommand.renderState = e._rsDepth), (!l(e._rsAccumulate) || !Ge.equals(e._viewport, e._rsAccumulate.viewport) || u) && (e._rsAccumulate = Ve.fromCache({ viewport: e._viewport, scissorTest: { enabled: e._useScissorTest, rectangle: e._scissorRectangle }, stencilTest: { enabled: !0, frontFunction: Fn.EQUAL, reference: vt.CESIUM_3D_TILE_MASK } })), l(e._accumulateCommand) && (e._accumulateCommand.renderState = e._rsAccumulate), (!l(e._rsComp) || !Ge.equals(e._viewport, e._rsComp.viewport) || u) && (e._rsComp = Ve.fromCache({ viewport: e._viewport, scissorTest: { enabled: e._useScissorTest, rectangle: e._scissorRectangle }, blending: an.ALPHA_BLEND })), l(e._compositeCommand) && (e._compositeCommand.renderState = e._rsComp, e._compositeCommand.derivedCommands.pick.renderState = e._rsComp) } Xg.prototype.executeTranslucentCommands = function (e, t, n, i, o) { let r = i.length, s, a, c = e.frameState.useLogDepth, u = e.context, f = n.framebuffer; for (a = 0; a < r; ++a)if (s = i[a], s = c ? s.derivedCommands.logDepth.command : s, s.depthForTranslucentClassification) { this._hasTranslucentDepth = !0; break } if (!!this._hasTranslucentDepth) { for (Gat(this, u, n, o), n.framebuffer = this._drawClassificationFBO.framebuffer, this._clearDepthStencilCommand.execute(u, n), a = 0; a < r; ++a) { if (s = i[a], s = c ? s.derivedCommands.logDepth.command : s, !s.depthForTranslucentClassification) continue; let d = s.derivedCommands.depth.depthOnlyCommand; t(d, e, u, n) } this._frustumsDrawn += this._hasTranslucentDepth ? 1 : 0, this._hasTranslucentDepth && (n.framebuffer = this._packFBO.framebuffer, this._packDepthCommand.execute(u, n)), n.framebuffer = f } }; Xg.prototype.executeClassificationCommands = function (e, t, n, i) { if (!this._hasTranslucentDepth) return; let o = e.context, r = o.uniformState, s = n.framebuffer; this._frustumsDrawn === 2 && (n.framebuffer = this._accumulationFBO.framebuffer, this._copyCommand.execute(o, n)), n.framebuffer = this._drawClassificationFBO.framebuffer, this._frustumsDrawn > 1 && this._clearColorCommand.execute(o, n), r.updatePass(xe.CESIUM_3D_TILE_CLASSIFICATION); let a = r.globeDepthTexture; r.globeDepthTexture = this._packFBO.getColorTexture(); let c = i.commands[xe.CESIUM_3D_TILE_CLASSIFICATION], u = i.indices[xe.CESIUM_3D_TILE_CLASSIFICATION]; for (let f = 0; f < u; ++f)t(c[f], e, o, n); r.globeDepthTexture = a, n.framebuffer = s, this._frustumsDrawn !== 1 && (n.framebuffer = this._accumulationFBO.framebuffer, this._accumulateCommand.execute(o, n), n.framebuffer = s) }; Xg.prototype.execute = function (e, t) { if (!this._hasTranslucentDepth) return; this._frustumsDrawn === 1 ? this._textureToComposite = this._drawClassificationFBO.getColorTexture() : this._textureToComposite = this._accumulationFBO.getColorTexture(), (e.frameState.passes.pick ? this._compositeCommand.derivedCommands.pick : this._compositeCommand).execute(e.context, t), Wat(this, e, t) }; function Wat(e, t, n) { if (!e._hasTranslucentDepth) return; let i = n.framebuffer; n.framebuffer = e._drawClassificationFBO.framebuffer, e._clearColorCommand.execute(t._context, n), n.framebuffer = i, e._frustumsDrawn > 1 && (n.framebuffer = e._accumulationFBO.framebuffer, e._clearColorCommand.execute(t._context, n)), e._hasTranslucentDepth = !1, e._frustumsDrawn = 0 } Xg.prototype.isSupported = function () { return this._supported }; Xg.prototype.isDestroyed = function () { return !1 }; Xg.prototype.destroy = function () { return G_e(this), W_e(this), l(this._compositeCommand) && (this._compositeCommand.shaderProgram = this._compositeCommand.shaderProgram && this._compositeCommand.shaderProgram.destroy()), l(this._packDepthCommand) && (this._packDepthCommand.shaderProgram = this._packDepthCommand.shaderProgram && this._packDepthCommand.shaderProgram.destroy()), le(this) }; var rU = Xg; function jat() { this.command = void 0, this.near = void 0, this.far = void 0 } function sU(e, t, n) { let i = e.context, o; i.depthTexture && (o = new zk); let r; e._useOIT && i.depthTexture && (r = new Jk(i)); let s = new pc(i); s.viewport = Ge.clone(n), this.camera = t, this._cameraClone = oo.clone(t), this._cameraStartFired = !1, this._cameraMovedTime = void 0, this.viewport = n, this.passState = s, this.pickFramebuffer = new nU(i), this.pickDepthFramebuffer = new tU, this.sceneFramebuffer = new VE, this.globeDepth = o, this.globeTranslucencyFramebuffer = new Hk, this.oit = r, this.translucentTileClassification = new rU(i), this.pickDepths = [], this.frustumCommandsList = [], this.debugFrustumStatistics = void 0, this._commandExtents = [] } var j_e = new h, q_e = new h; function qat(e, t) { let n = Math.max(Math.abs(e.x), Math.abs(t.x)), i = Math.max(Math.abs(e.y), Math.abs(t.y)), o = Math.max(Math.abs(e.z), Math.abs(t.z)); return Math.max(Math.max(n, i), o) } function Yat(e, t, n) { let i = 1 / Math.max(1, qat(e.position, t.position)); return h.multiplyByScalar(e.position, i, j_e), h.multiplyByScalar(t.position, i, q_e), h.equalsEpsilon(j_e, q_e, n) && h.equalsEpsilon(e.direction, t.direction, n) && h.equalsEpsilon(e.up, t.up, n) && h.equalsEpsilon(e.right, t.right, n) && F.equalsEpsilon(e.transform, t.transform, n) && e.frustum.equalsEpsilon(t.frustum, n) } sU.prototype.checkForCameraUpdates = function (e) { let t = this.camera, n = this._cameraClone; return Yat(t, n, I.EPSILON15) ? (this._cameraStartFired && Ei() - this._cameraMovedTime > e.cameraEventWaitTime && (t.moveEnd.raiseEvent(), this._cameraStartFired = !1), !1) : (this._cameraStartFired || (t.moveStart.raiseEvent(), this._cameraStartFired = !0), this._cameraMovedTime = Ei(), oo.clone(t, n), !0) }; function Xat(e, t, n, i) { let o = t.frameState, r = o.camera, s = o.useLogDepth ? t.logarithmicDepthFarToNearRatio : t.farToNearRatio, a = t.mode === ee.SCENE2D, c = t.nearToFarDistance2D; i *= 1 + I.EPSILON2, n = Math.min(Math.max(n, r.frustum.near), r.frustum.far), i = Math.max(Math.min(i, r.frustum.far), n); let u; a ? (i = Math.min(i, r.position.z + t.nearToFarDistance2D), n = Math.min(n, i), u = Math.ceil(Math.max(1, i - n) / t.nearToFarDistance2D)) : u = Math.ceil(Math.log(i / n) / Math.log(s)); let f = e.frustumCommandsList; f.length = u; for (let d = 0; d < u; ++d) { let p, g; a ? (p = Math.min(i - c, n + d * c), g = Math.min(i, p + c)) : (p = Math.max(n, Math.pow(s, d) * n), g = Math.min(i, s * p)); let m = f[d]; l(m) ? (m.near = p, m.far = g) : m = f[d] = new fk(p, g) } } function Kat(e, t, n, i, o) { t.debugShowFrustums && (n.debugOverlappingFrustums = 0); let r = e.frustumCommandsList, s = r.length; for (let a = 0; a < s; ++a) { let c = r[a], u = c.near, f = c.far; if (i > f) continue; if (o < u) break; let d = n.pass, p = c.indices[d]++; if (c.commands[d][p] = n, t.debugShowFrustums && (n.debugOverlappingFrustums |= 1 << a), n.executeInClosestFrustum) break } if (t.debugShowFrustums) { let a = e.debugFrustumStatistics.commandsInFrustums; a[n.debugOverlappingFrustums] = l(a[n.debugOverlappingFrustums]) ? a[n.debugOverlappingFrustums] + 1 : 1, ++e.debugFrustumStatistics.totalCommands } t.updateDerivedCommands(n) } var Y_e = new Xs, Jat = new Dc; sU.prototype.createPotentiallyVisibleSet = function (e) { let t = e.frameState, n = t.camera, i = n.directionWC, o = n.positionWC, r = e._computeCommandList, s = e._overlayCommandList, a = t.commandList; e.debugShowFrustums && (this.debugFrustumStatistics = { totalCommands: 0, commandsInFrustums: {} }); let c = this.frustumCommandsList, u = c.length, f = xe.NUMBER_OF_PASSES; for (let E = 0; E < u; ++E)for (let w = 0; w < f; ++w)c[E].indices[w] = 0; r.length = 0, s.length = 0; let d = this._commandExtents, p = d.length, g = 0, m = +Number.MAX_VALUE, A = -Number.MAX_VALUE, C = t.shadowState.shadowsEnabled, x = +Number.MAX_VALUE, T = -Number.MAX_VALUE, b = Number.MAX_VALUE, S = t.mode === ee.SCENE3D ? t.occluder : void 0, D = t.cullingVolume, P = Y_e.planes; for (let E = 0; E < 5; ++E)P[E] = D.planes[E]; D = Y_e; let B = a.length; for (let E = 0; E < B; ++E) { let w = a[E], v = w.pass; if (v === xe.COMPUTE) r.push(w); else if (v === xe.OVERLAY) s.push(w); else { let O, V, z = w.boundingVolume; if (l(z)) { if (!e.isVisible(w, D, S)) continue; let G = z.computePlaneDistances(o, i, Jat); if (O = G.start, V = G.stop, m = Math.min(m, O), A = Math.max(A, V), C && w.receiveShadows && O < Yg.MAXIMUM_DISTANCE && !(v === xe.GLOBE && O < -100 && V > 100)) { let N = V - O; v !== xe.GLOBE && O < 100 && (b = Math.min(b, N)), x = Math.min(x, O), T = Math.max(T, V) } } else w instanceof ti ? (O = n.frustum.near, V = n.frustum.far) : (O = n.frustum.near, V = n.frustum.far, m = Math.min(m, O), A = Math.max(A, V)); let k = d[g]; l(k) || (k = d[g] = new jat), k.command = w, k.near = O, k.far = V, g++ } } C && (x = Math.min(Math.max(x, n.frustum.near), n.frustum.far), T = Math.max(Math.min(T, n.frustum.far), x)), C && (t.shadowState.nearPlane = x, t.shadowState.farPlane = T, t.shadowState.closestObjectSize = b), Xat(this, e, m, A); let R, M; for (R = 0; R < g; R++)M = d[R], Kat(this, e, M.command, M.near, M.far); if (g < p) for (R = g; R < p && (M = d[R], !!l(M.command)); R++)M.command = void 0; let L = c.length, _ = t.frustumSplits; _.length = L + 1; for (let E = 0; E < L; ++E)_[E] = c[E].near, E === L - 1 && (_[E + 1] = c[E].far) }; sU.prototype.destroy = function () { this.pickFramebuffer = this.pickFramebuffer && this.pickFramebuffer.destroy(), this.pickDepthFramebuffer = this.pickDepthFramebuffer && this.pickDepthFramebuffer.destroy(), this.sceneFramebuffer = this.sceneFramebuffer && this.sceneFramebuffer.destroy(), this.globeDepth = this.globeDepth && this.globeDepth.destroy(), this.oit = this.oit && this.oit.destroy(), this.translucentTileClassification = this.translucentTileClassification && this.translucentTileClassification.destroy(), this.globeTranslucencyFramebuffer = this.globeTranslucencyFramebuffer && this.globeTranslucencyFramebuffer.destroy(); let e, t = this.pickDepths, n = t.length; for (e = 0; e < n; ++e)t[e].destroy() }; var UE = sU; var K_e = .1, Zat = new ad({ pass: Qo.MOST_DETAILED_PRELOAD }), Qat = new ad({ pass: Qo.MOST_DETAILED_PICK }), Pj = new ad({ pass: Qo.PICK }); function sa(e) { this._mostDetailedRayPicks = [], this.pickRenderStateCache = {}, this._pickPositionCache = {}, this._pickPositionCacheDirty = !1; let t = new Ge(0, 0, 1, 1), n = new oo(e); n.frustum = new Zt({ width: K_e, aspectRatio: 1, near: .1 }), this._pickOffscreenView = new UE(e, n, t) } sa.prototype.update = function () { this._pickPositionCacheDirty = !0 }; sa.prototype.getPickDepth = function (e, t) { let n = e.view.pickDepths, i = n[t]; return l(i) || (i = new eU, n[t] = i), i }; var $at = new wr, ect = new h, aU = new h, tct = new H, nct = new F; function ict(e, t, n, i, o) { let r = e.camera, s = r.frustum; l(s._offCenterFrustum) && (s = s._offCenterFrustum); let a = 2 * (t.x - o.x) / o.width - 1; a *= (s.right - s.left) * .5; let c = 2 * (o.height - t.y - o.y) / o.height - 1; c *= (s.top - s.bottom) * .5; let u = F.clone(r.transform, nct); r._setTransform(F.IDENTITY); let f = h.clone(r.position, ect); h.multiplyByScalar(r.right, a, aU), h.add(aU, f, f), h.multiplyByScalar(r.up, c, aU), h.add(aU, f, f), r._setTransform(u), e.mode === ee.SCENE2D && h.fromElements(f.z, f.x, f.y, f); let d = s.getPixelDimensions(o.width, o.height, 1, 1, tct), p = $at; return p.right = d.x * .5, p.left = -p.right, p.top = d.y * .5, p.bottom = -p.top, p.near = s.near, p.far = s.far, p.computeCullingVolume(f, r.directionWC, r.upWC) } var oct = new $c, rct = new H; function sct(e, t, n, i, o) { let r = e.camera, s = r.frustum, a = s.near, c = Math.tan(s.fovy * .5), u = s.aspectRatio * c, f = 2 * (t.x - o.x) / o.width - 1, d = 2 * (o.height - t.y - o.y) / o.height - 1, p = f * a * u, g = d * a * c, m = s.getPixelDimensions(o.width, o.height, 1, 1, rct), A = m.x * n * .5, C = m.y * i * .5, x = oct; return x.top = g + C, x.bottom = g - C, x.right = p + A, x.left = p - A, x.near = a, x.far = s.far, x.computeCullingVolume(r.positionWC, r.directionWC, r.upWC) } function J_e(e, t, n, i, o) { let r = e.camera.frustum; return r instanceof Zt || r instanceof wr ? ict(e, t, n, i, o) : sct(e, t, n, i, o) } var zE = 3, Ev = 3, Nh = new Ge(0, 0, zE, Ev), Z_e = new H, Ij = new U(0, 0, 0, 0); sa.prototype.pick = function (e, t, n, i) { zE = y(n, 3), Ev = y(i, zE); let o = e.context, r = o.uniformState, s = e.frameState, a = e.defaultView; e.view = a; let c = a.viewport; c.x = 0, c.y = 0, c.width = o.drawingBufferWidth, c.height = o.drawingBufferHeight; let u = a.passState; u.viewport = Ge.clone(c, u.viewport); let f = ji.transformWindowToDrawingBuffer(e, t, Z_e); e.jobScheduler.disableThisFrame(), e.updateFrameState(), s.cullingVolume = J_e(e, f, zE, Ev, c), s.invertClassification = !1, s.passes.pick = !0, s.tilesetPassState = Pj, r.update(s), e.updateEnvironment(), Nh.x = f.x - (zE - 1) * .5, Nh.y = e.drawingBufferHeight - f.y - (Ev - 1) * .5, Nh.width = zE, Nh.height = Ev, u = a.pickFramebuffer.begin(Nh, a.viewport), e.updateAndExecuteCommands(u, Ij), e.resolveFramebuffers(u); let d = a.pickFramebuffer.end(Nh); return o.endFrame(), d }; function act(e, t) { let n = e.context, i = e.frameState, o = e.environmentState, r = e.defaultView; e.view = r; let s = r.viewport; s.x = 0, s.y = 0, s.width = n.drawingBufferWidth, s.height = n.drawingBufferHeight; let a = r.passState; a.viewport = Ge.clone(s, a.viewport), e.clearPasses(i.passes), i.passes.pick = !0, i.passes.depth = !0, i.cullingVolume = J_e(e, t, 1, 1, s), i.tilesetPassState = Pj, e.updateEnvironment(), o.renderTranslucentDepthForPick = !0, a = r.pickDepthFramebuffer.update(n, t, s), e.updateAndExecuteCommands(a, Ij), e.resolveFramebuffers(a), n.endFrame() } var cct = new mi, lct = new $c, uct = new Zt, fct = new wr; sa.prototype.pickPositionWorldCoordinates = function (e, t, n) { if (!e.useDepthPicking) return; let i = t.toString(); if (this._pickPositionCacheDirty) this._pickPositionCache = {}, this._pickPositionCacheDirty = !1; else if (this._pickPositionCache.hasOwnProperty(i)) return h.clone(this._pickPositionCache[i], n); let o = e.frameState, r = e.context, s = r.uniformState, a = e.defaultView; e.view = a; let c = ji.transformWindowToDrawingBuffer(e, t, Z_e); e.pickTranslucentDepth ? act(e, c) : (e.updateFrameState(), s.update(o), e.updateEnvironment()), c.y = e.drawingBufferHeight - c.y; let u = e.camera, f; l(u.frustum.fov) ? f = u.frustum.clone(cct) : l(u.frustum.infiniteProjectionMatrix) ? f = u.frustum.clone(lct) : l(u.frustum.width) ? f = u.frustum.clone(uct) : f = u.frustum.clone(fct); let d = a.frustumCommandsList, p = d.length; for (let g = 0; g < p; ++g) { let A = this.getPickDepth(e, g).getDepth(r, c.x, c.y); if (!!l(A) && A > 0 && A < 1) { let C = d[g], x; return e.mode === ee.SCENE2D ? (x = u.position.z, u.position.z = x - C.near + 1, f.far = Math.max(1, C.far - C.near), f.near = 1, s.update(o), s.updateFrustum(f)) : (f.near = C.near * (g !== 0 ? e.opaqueFrustumNearOffset : 1), f.far = C.far, s.updateFrustum(f)), n = ji.drawingBufferToWgs84Coordinates(e, c, A, n), e.mode === ee.SCENE2D && (u.position.z = x, s.update(o)), this._pickPositionCache[i] = h.clone(n), n } } this._pickPositionCache[i] = void 0 }; var dct = new he; sa.prototype.pickPosition = function (e, t, n) { if (n = this.pickPositionWorldCoordinates(e, t, n), l(n) && e.mode !== ee.SCENE3D) { h.fromElements(n.y, n.z, n.x, n); let i = e.mapProjection, o = i.ellipsoid, r = i.unproject(n, dct); o.cartographicToCartesian(r, n) } return n }; function Q_e(e, t) { let n, i, o = [], r = [], s = [], a = []; l(e) || (e = Number.MAX_VALUE); let c = t(); for (; l(c);) { let u = c.object, f = c.position, d = c.exclude; if (l(f) && !l(u)) { o.push(c); break } if (!l(u) || !l(u.primitive) || !d && (o.push(c), 0 >= --e)) break; let p = u.primitive, g = !1; typeof p.getGeometryInstanceAttributes == "function" && l(u.id) && (i = p.getGeometryInstanceAttributes(u.id), l(i) && l(i.show) && (g = !0, i.show = fn.toValue(!1, i.show), s.push(i))), u instanceof xs && (g = !0, u.show = !1, a.push(u)), g || (p.show = !1, r.push(p)), c = t() } for (n = 0; n < r.length; ++n)r[n].show = !0; for (n = 0; n < s.length; ++n)i = s[n], i.show = fn.toValue(!0, i.show); for (n = 0; n < a.length; ++n)a[n].show = !0; return o } sa.prototype.drillPick = function (e, t, n, i, o) { let r = this; return Q_e(n, function () { let c = r.pick(e, t, i, o); if (l(c)) return { object: c, position: void 0, exclude: !1 } }).map(function (c) { return c.object }) }; var X_e = new h, hct = new h; function mct(e, t, n) { this.ray = e, this.width = t, this.tilesets = n, this.ready = !1; let i = this; this.promise = new Promise(o => { i._completePick = () => { o() } }) } function $_e(e, t, n, i) { let o = t.direction, r = h.mostOrthogonalAxis(o, X_e), s = h.cross(o, r, X_e), a = h.cross(o, s, hct); return i.position = t.origin, i.direction = o, i.up = a, i.right = s, i.frustum.width = y(n, K_e), i.frustum.computeCullingVolume(i.positionWC, i.directionWC, i.upWC) } function pct(e, t, n) { let i = t.frameState, o = n.ray, r = n.width, s = n.tilesets, a = e._pickOffscreenView.camera, c = $_e(e, o, r, a), u = Zat; u.camera = a, u.cullingVolume = c; let f = !0, d = s.length; for (let p = 0; p < d; ++p) { let g = s[p]; g.show && t.primitives.contains(g) && (g.updateForPass(i, u), f = f && u.ready) } return f && n._completePick(), f } sa.prototype.updateMostDetailedRayPicks = function (e) { let t = this._mostDetailedRayPicks; for (let n = 0; n < t.length; ++n)pct(this, e, t[n]) && t.splice(n--, 1) }; function ege(e, t, n) { let i = e.length; for (let o = 0; o < i; ++o) { let r = e.get(o); r.show && (l(r.isCesium3DTileset) ? (!l(t) || t.indexOf(r) === -1) && n.push(r) : r instanceof wl && ege(r, t, n)) } } function cU(e, t, n, i, o, r) { let s = []; if (ege(t.primitives, i, s), s.length === 0) return Promise.resolve(r()); let a = new mct(n, o, s); return e._mostDetailedRayPicks.push(a), a.promise.then(function () { return r() }) } function _ct(e, t) { return !l(e) || !l(t) || t.length === 0 ? !1 : t.indexOf(e) > -1 || t.indexOf(e.primitive) > -1 || t.indexOf(e.id) > -1 } function gct(e, t, n, i, o, r, s) { let a = t.context, c = a.uniformState, u = t.frameState, f = e._pickOffscreenView; t.view = f, $_e(e, n, o, f.camera), Nh = Ge.clone(f.viewport, Nh); let d = f.pickFramebuffer.begin(Nh, f.viewport); t.jobScheduler.disableThisFrame(), t.updateFrameState(), u.invertClassification = !1, u.passes.pick = !0, u.passes.offscreen = !0, s ? u.tilesetPassState = Qat : u.tilesetPassState = Pj, c.update(u), t.updateEnvironment(), t.updateAndExecuteCommands(d, Ij), t.resolveFramebuffers(d); let p, g = f.pickFramebuffer.end(Nh); if (t.context.depthTexture) { let m = f.frustumCommandsList.length; for (let A = 0; A < m; ++A) { let x = e.getPickDepth(t, A).getDepth(a, 0, 0); if (!!l(x) && x > 0 && x < 1) { let T = f.frustumCommandsList[A], b = T.near * (A !== 0 ? t.opaqueFrustumNearOffset : 1), S = T.far, D = b + x * (S - b); p = En.getPoint(n, D); break } } } if (t.view = t.defaultView, a.endFrame(), l(g) || l(p)) return { object: g, position: p, exclude: !l(p) && r || _ct(g, i) } } function tge(e, t, n, i, o, r, s, a) { return Q_e(i, function () { return gct(e, t, n, o, r, s, a) }) } function HE(e, t, n, i, o, r, s) { let a = tge(e, t, n, 1, i, o, r, s); if (a.length > 0) return a[0] } function nge(e, t, n, i, o, r, s, a) { return tge(e, t, n, i, o, r, s, a) } function lU(e, t) { return new Promise((n, i) => { t.then(function (o) { let r = e.postRender.addEventListener(function () { r(), n(o) }); e.requestRender() }).catch(function (o) { i(o) }) }) } sa.prototype.pickFromRay = function (e, t, n, i) { return HE(this, e, t, n, i, !1, !1) }; sa.prototype.drillPickFromRay = function (e, t, n, i, o) { return nge(this, e, t, n, i, o, !1, !1) }; sa.prototype.pickFromRayMostDetailed = function (e, t, n, i) { let o = this; return t = En.clone(t), n = l(n) ? n.slice() : n, lU(e, cU(o, e, t, n, i, function () { return HE(o, e, t, n, i, !1, !0) })) }; sa.prototype.drillPickFromRayMostDetailed = function (e, t, n, i, o) { let r = this; return t = En.clone(t), i = l(i) ? i.slice() : i, lU(e, cU(r, e, t, i, o, function () { return nge(r, e, t, n, i, o, !1, !0) })) }; var yct = new h, Act = new h, Cct = new En, ige = new he; function Oj(e, t) { let n = e.globe, i = l(n) ? n.ellipsoid : e.mapProjection.ellipsoid, o = oi._defaultMaxTerrainHeight, r = i.geodeticSurfaceNormalCartographic(t, Act), s = he.toCartesian(t, i, yct), a = Cct; a.origin = s, a.direction = r; let c = new En; return En.getPoint(a, o, c.origin), h.negate(r, c.direction), c } function oge(e, t) { let n = e.globe, i = l(n) ? n.ellipsoid : e.mapProjection.ellipsoid, o = he.fromCartesian(t, i, ige); return Oj(e, o) } function rge(e, t) { let n = e.globe, i = l(n) ? n.ellipsoid : e.mapProjection.ellipsoid; return he.fromCartesian(t, i, ige).height } function xct(e, t, n, i, o) { let r = Oj(t, n); return cU(e, t, r, i, o, function () { let s = HE(e, t, r, i, o, !0, !0); if (l(s)) return rge(t, s.position) }) } function Tct(e, t, n, i, o, r) { let s = oge(t, n); return cU(e, t, s, i, o, function () { let a = HE(e, t, s, i, o, !0, !0); if (l(a)) return h.clone(a.position, r) }) } sa.prototype.sampleHeight = function (e, t, n, i) { let o = Oj(e, t), r = HE(this, e, o, n, i, !0, !1); if (l(r)) return rge(e, r.position) }; sa.prototype.clampToHeight = function (e, t, n, i, o) { let r = oge(e, t), s = HE(this, e, r, n, i, !0, !1); if (l(s)) return h.clone(s.position, o) }; sa.prototype.sampleHeightMostDetailed = function (e, t, n, i) { n = l(n) ? n.slice() : n; let o = t.length, r = new Array(o); for (let s = 0; s < o; ++s)r[s] = xct(this, e, t[s], n, i); return lU(e, Promise.all(r).then(function (s) { let a = s.length; for (let c = 0; c < a; ++c)t[c].height = s[c]; return t })) }; sa.prototype.clampToHeightMostDetailed = function (e, t, n, i) { n = l(n) ? n.slice() : n; let o = t.length, r = new Array(o); for (let s = 0; s < o; ++s)r[s] = Tct(this, e, t[s], n, i, t[s]); return lU(e, Promise.all(r).then(function (s) { let a = s.length; for (let c = 0; c < a; ++c)t[c] = s[c]; return t })) }; sa.prototype.destroy = function () { this._pickOffscreenView = this._pickOffscreenView && this._pickOffscreenView.destroy() }; var uU = sa; var cge = po(eP(), 1); var Ect = {
        modifyFragmentShader: function (t) {
            return t = Ue.replaceMain(t, "czm_splitter_main"), t += `uniform float czm_splitDirection; 
void main() 
{ 
#ifndef SHADOW_MAP
    if (czm_splitDirection < 0.0 && gl_FragCoord.x > czm_splitPosition) discard; 
    if (czm_splitDirection > 0.0 && gl_FragCoord.x < czm_splitPosition) discard; 
#endif
    czm_splitter_main(); 
} 
`, t
        }, addUniforms: function (t, n) { n.czm_splitDirection = function () { return t.splitDirection } }
    }, bv = Ect; var fA = { NEEDS_DECODE: 0, DECODING: 1, READY: 2, FAILED: 3 }; function Sv(e) { this._parsedContent = void 0, this._drawCommand = void 0, this._isTranslucent = !1, this._styleTranslucent = !1, this._constantColor = U.clone(U.DARKGRAY), this._highlightColor = U.clone(U.WHITE), this._pointSize = 1, this._rtcCenter = void 0, this._quantizedVolumeScale = void 0, this._quantizedVolumeOffset = void 0, this._styleableShaderAttributes = void 0, this._isQuantized = !1, this._isOctEncoded16P = !1, this._isRGB565 = !1, this._hasColors = !1, this._hasNormals = !1, this._hasBatchIds = !1, this._decodingState = fA.READY, this._dequantizeInShader = !0, this._isQuantizedDraco = !1, this._isOctEncodedDraco = !1, this._quantizedRange = 0, this._octEncodedRange = 0, this.backFaceCulling = !1, this._backFaceCulling = !1, this.normalShading = !0, this._normalShading = !0, this._opaqueRenderState = void 0, this._translucentRenderState = void 0, this._mode = void 0, this._ready = !1, this._pointsLength = 0, this._geometryByteLength = 0, this._vertexShaderLoaded = e.vertexShaderLoaded, this._fragmentShaderLoaded = e.fragmentShaderLoaded, this._uniformMapLoaded = e.uniformMapLoaded, this._batchTableLoaded = e.batchTableLoaded, this._pickIdLoaded = e.pickIdLoaded, this._opaquePass = y(e.opaquePass, xe.OPAQUE), this._cull = y(e.cull, !0), this.style = void 0, this._style = void 0, this.styleDirty = !1, this.modelMatrix = F.clone(F.IDENTITY), this._modelMatrix = F.clone(F.IDENTITY), this.time = 0, this.shadows = hn.ENABLED, this._boundingSphere = void 0, this.clippingPlanes = void 0, this.isClipped = !1, this.clippingPlanesDirty = !1, this.clippingPlanesOriginMatrix = void 0, this.attenuation = !1, this._attenuation = !1, this.geometricError = 0, this.geometricErrorScale = 1, this.maximumAttenuation = this._pointSize, this.splitDirection = y(e.splitDirection, zc.NONE), this._splittingEnabled = !1, this._resolveReadyPromise = void 0, this._rejectReadyPromise = void 0, this._readyPromise = bct(this, e) } Object.defineProperties(Sv.prototype, { pointsLength: { get: function () { return this._pointsLength } }, geometryByteLength: { get: function () { return this._geometryByteLength } }, ready: { get: function () { return this._ready } }, readyPromise: { get: function () { return this._readyPromise } }, color: { get: function () { return U.clone(this._highlightColor) }, set: function (e) { this._highlightColor = U.clone(e, this._highlightColor) } }, boundingSphere: { get: function () { if (l(this._drawCommand)) return this._drawCommand.boundingVolume }, set: function (e) { this._boundingSphere = re.clone(e, this._boundingSphere) } } }); function bct(e, t) { let n = px.parse(t.arrayBuffer, t.byteOffset); if (e._parsedContent = n, e._rtcCenter = n.rtcCenter, e._hasNormals = n.hasNormals, e._hasColors = n.hasColors, e._hasBatchIds = n.hasBatchIds, e._isTranslucent = n.isTranslucent, !n.hasBatchIds && l(n.batchTableBinary) && (n.styleableProperties = Xp.getBinaryProperties(n.pointsLength, n.batchTableJson, n.batchTableBinary)), l(n.draco)) { let a = n.draco; e._decodingState = fA.NEEDS_DECODE, a.dequantizeInShader = e._dequantizeInShader } let i = n.positions; l(i) && (e._isQuantized = i.isQuantized, e._quantizedVolumeScale = i.quantizedVolumeScale, e._quantizedVolumeOffset = i.quantizedVolumeOffset, e._quantizedRange = i.quantizedRange); let o = n.normals; l(o) && (e._isOctEncoded16P = o.octEncoded); let r = n.colors; l(r) && (l(r.constantColor) && (e._constantColor = U.clone(r.constantColor, e._constantColor), e._hasColors = !1), e._isRGB565 = r.isRGB565); let s = n.batchIds; return l(n.batchIds) && (s.name = "BATCH_ID", s.semantic = "BATCH_ID", s.setIndex = void 0), n.hasBatchIds && e._batchTableLoaded(n.batchLength, n.batchTableJson, n.batchTableBinary), e._pointsLength = n.pointsLength, new Promise(function (a, c) { e._resolveReadyPromise = function () { e._ready = !0, a(e) }, e._rejectReadyPromise = c }) } var Sct = new h, wct = new h, Dct = new h, sge, fU; function vct(e) { if (!l(fU)) { sge = new cge.default(0), fU = new Array(e); for (let t = 0; t < e; ++t)fU[t] = sge.random() } return fU } function Pct(e) { let n = e.length / 3, i = Math.min(n, 20), o = vct(20), r = Number.MAX_VALUE, s = -Number.MAX_VALUE, a = h.fromElements(r, r, r, Sct), c = h.fromElements(s, s, s, wct); for (let f = 0; f < i; ++f) { let d = Math.floor(o[f] * n), p = h.unpack(e, d * 3, Dct); h.minimumByComponent(a, p, a), h.maximumByComponent(c, p, c) } let u = re.fromCornerPoints(a, c); return u.radius += I.EPSILON2, u } function age(e, t) { let n = Y.fromTypedArray(e); return n === Y.INT || n === Y.UNSIGNED_INT || n === Y.DOUBLE ? (Pt("Cast pnts property to floats", `Point cloud property "${t}" will be casted to a float array because INT, UNSIGNED_INT, and DOUBLE are not valid WebGL vertex attribute types. Some precision may be lost.`), new Float32Array(e)) : e } var Ict = new se, Oct = new se, Bct = new U, lge = 0, dU = 1, Fj = 2, uge = 3, Rct = 4, Bj = new F, Mct = new F; function Lct(e, t) { let n = t.context, i = e._parsedContent, o = e._pointsLength, r = i.positions, s = i.colors, a = i.normals, c = i.batchIds, u = i.styleableProperties, f = l(u), d = e._isQuantized, p = e._isQuantizedDraco, g = e._isOctEncoded16P, m = e._isOctEncodedDraco, A = e._quantizedRange, C = e._octEncodedRange, x = e._isRGB565, T = e._isTranslucent, b = e._hasColors, S = e._hasNormals, D = e._hasBatchIds, P, B, R = [], M = {}; if (e._styleableShaderAttributes = M, f) { let k = Rct; for (let G in u) if (u.hasOwnProperty(G)) { let N = u[G], X = age(N.typedArray, G); P = N.componentCount, B = Y.fromTypedArray(X); let q = ct.createVertexBuffer({ context: n, typedArray: X, usage: Re.STATIC_DRAW }); e._geometryByteLength += q.sizeInBytes; let J = { index: k, vertexBuffer: q, componentsPerAttribute: P, componentDatatype: B, normalize: !1, offsetInBytes: 0, strideInBytes: 0 }; R.push(J), M[G] = { location: k, componentCount: P }, ++k } } let L = ct.createVertexBuffer({ context: n, typedArray: r.typedArray, usage: Re.STATIC_DRAW }); e._geometryByteLength += L.sizeInBytes; let _; b && (_ = ct.createVertexBuffer({ context: n, typedArray: s.typedArray, usage: Re.STATIC_DRAW }), e._geometryByteLength += _.sizeInBytes); let E; S && (E = ct.createVertexBuffer({ context: n, typedArray: a.typedArray, usage: Re.STATIC_DRAW }), e._geometryByteLength += E.sizeInBytes); let w; D && (c.typedArray = age(c.typedArray, "batchIds"), w = ct.createVertexBuffer({ context: n, typedArray: c.typedArray, usage: Re.STATIC_DRAW }), e._geometryByteLength += w.sizeInBytes); let v = []; if (d ? B = Y.UNSIGNED_SHORT : p ? B = A <= 255 ? Y.UNSIGNED_BYTE : Y.UNSIGNED_SHORT : B = Y.FLOAT, v.push({ index: lge, vertexBuffer: L, componentsPerAttribute: 3, componentDatatype: B, normalize: !1, offsetInBytes: 0, strideInBytes: 0 }), e._cull && (d || p ? e._boundingSphere = re.fromCornerPoints(h.ZERO, e._quantizedVolumeScale) : e._boundingSphere = Pct(r.typedArray)), b) if (x) v.push({ index: dU, vertexBuffer: _, componentsPerAttribute: 1, componentDatatype: Y.UNSIGNED_SHORT, normalize: !1, offsetInBytes: 0, strideInBytes: 0 }); else { let k = T ? 4 : 3; v.push({ index: dU, vertexBuffer: _, componentsPerAttribute: k, componentDatatype: Y.UNSIGNED_BYTE, normalize: !0, offsetInBytes: 0, strideInBytes: 0 }) } S && (g ? (P = 2, B = Y.UNSIGNED_BYTE) : m ? (P = 2, B = C <= 255 ? Y.UNSIGNED_BYTE : Y.UNSIGNED_SHORT) : (P = 3, B = Y.FLOAT), v.push({ index: Fj, vertexBuffer: E, componentsPerAttribute: P, componentDatatype: B, normalize: !1, offsetInBytes: 0, strideInBytes: 0 })), D && v.push({ index: uge, vertexBuffer: w, componentsPerAttribute: 1, componentDatatype: Y.fromTypedArray(c.typedArray), normalize: !1, offsetInBytes: 0, strideInBytes: 0 }), f && (v = v.concat(R)); let O = new Qn({ context: n, attributes: v }), V = { depthTest: { enabled: !0 } }, z = { depthTest: { enabled: !0 }, depthMask: !1, blending: an.ALPHA_BLEND }; e._opaquePass === xe.CESIUM_3D_TILE && (V.stencilTest = vt.setCesium3DTileBit(), V.stencilMask = vt.CESIUM_3D_TILE_MASK, z.stencilTest = vt.setCesium3DTileBit(), z.stencilMask = vt.CESIUM_3D_TILE_MASK), e._opaqueRenderState = Ve.fromCache(V), e._translucentRenderState = Ve.fromCache(z), e._drawCommand = new $e({ boundingVolume: new re, cull: e._cull, modelMatrix: new F, primitiveType: Oe.POINTS, vertexArray: O, count: o, shaderProgram: void 0, uniformMap: void 0, renderState: T ? e._translucentRenderState : e._opaqueRenderState, pass: T ? xe.TRANSLUCENT : e._opaquePass, owner: e, castShadows: !1, receiveShadows: !1, pickId: e._pickIdLoaded() }) } function Fct(e, t) { let n = t.context, i = e._isQuantized, o = e._isQuantizedDraco, r = e._isOctEncodedDraco, s = { u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier: function () { let a = Ict; if (a.x = e._attenuation ? e.maximumAttenuation : e._pointSize, a.x *= t.pixelRatio, a.y = e.time, e._attenuation) { let c = t.camera.frustum, u; t.mode === ee.SCENE2D || c instanceof Zt ? u = Number.POSITIVE_INFINITY : u = n.drawingBufferHeight / t.camera.frustum.sseDenominator, a.z = e.geometricError * e.geometricErrorScale, a.w = u } return a }, u_highlightColor: function () { return e._highlightColor }, u_constantColor: function () { return e._constantColor }, u_clippingPlanes: function () { let a = e.clippingPlanes; return e.isClipped ? a.texture : n.defaultTexture }, u_clippingPlanesEdgeStyle: function () { let a = e.clippingPlanes; if (!l(a)) return U.TRANSPARENT; let c = U.clone(a.edgeColor, Bct); return c.alpha = a.edgeWidth, c }, u_clippingPlanesMatrix: function () { let a = e.clippingPlanes; if (!l(a)) return F.IDENTITY; let c = y(e.clippingPlanesOriginMatrix, e._modelMatrix); F.multiply(n.uniformState.view3D, c, Bj); let u = F.multiply(Bj, a.modelMatrix, Bj); return F.inverseTranspose(u, Mct) } }; bv.addUniforms(e, s), (i || o || r) && (s = yt(s, { u_quantizedVolumeScaleAndOctEncodedRange: function () { let a = Oct; if (l(e._quantizedVolumeScale)) { let c = h.clone(e._quantizedVolumeScale, a); h.divideByScalar(c, e._quantizedRange, a) } return a.w = e._octEncodedRange, a } })), l(e._uniformMapLoaded) && (s = e._uniformMapLoaded(s)), e._drawCommand.uniformMap = s } function Rj(e, t) { let n = /czm_3dtiles_property_(\d+)/g, i = n.exec(e); for (; i !== null;) { let o = parseInt(i[1]); t.indexOf(o) === -1 && t.push(o), i = n.exec(e) } } function Mj(e, t) {
        e = e.slice(e.indexOf(`
`)); let n = /czm_3dtiles_builtin_property_(\w+)/g, i = n.exec(e); for (; i !== null;) { let o = i[1]; t.indexOf(o) === -1 && t.push(o), i = n.exec(e) }
    } function Lj(e, t) { let n = e.numberOfAttributes; for (let i = 0; i < n; ++i) { let o = e.getAttribute(i); if (o.index === t) return o } } var Nct = { POSITION: "czm_3dtiles_builtin_property_POSITION", POSITION_ABSOLUTE: "czm_3dtiles_builtin_property_POSITION_ABSOLUTE", COLOR: "czm_3dtiles_builtin_property_COLOR", NORMAL: "czm_3dtiles_builtin_property_NORMAL" }; function Vct(e, t, n) {
        let i, o, r, s = t.context, a = l(n), c = e._isQuantized, u = e._isQuantizedDraco, f = e._isOctEncoded16P, d = e._isOctEncodedDraco, p = e._isRGB565, g = e._isTranslucent, m = e._hasColors, A = e._hasNormals, C = e._hasBatchIds, x = e._backFaceCulling, T = e._normalShading, b = e._drawCommand.vertexArray, S = e.clippingPlanes, D = e._attenuation, P, B, R, M = g, L = tt(Nct), _ = {}, E = e._styleableShaderAttributes; for (o in E) E.hasOwnProperty(o) && (r = E[o], L[o] = `czm_3dtiles_property_${r.location}`, _[r.location] = r); if (a) { let oe = { translucent: !1 }, ue = "(vec3 czm_3dtiles_builtin_property_POSITION, vec3 czm_3dtiles_builtin_property_POSITION_ABSOLUTE, vec4 czm_3dtiles_builtin_property_COLOR, vec3 czm_3dtiles_builtin_property_NORMAL)"; P = n.getColorShaderFunction(`getColorFromStyle${ue}`, L, oe), B = n.getShowShaderFunction(`getShowFromStyle${ue}`, L, oe), R = n.getPointSizeShaderFunction(`getPointSizeFromStyle${ue}`, L, oe), l(P) && oe.translucent && (M = !0) } e._styleTranslucent = M; let w = l(P), v = l(B), O = l(R), V = e.isClipped, z = [], k = []; w && (Rj(P, z), Mj(P, k)), v && (Rj(B, z), Mj(B, k)), O && (Rj(R, z), Mj(R, k)); let G = k.indexOf("COLOR") >= 0, N = k.indexOf("NORMAL") >= 0; if (N && !A) throw new fe("Style references the NORMAL semantic but the point cloud does not have normals"); for (o in E) if (E.hasOwnProperty(o)) { r = E[o]; let oe = z.indexOf(r.location) >= 0, ue = Lj(b, r.location); ue.enabled = oe } let X = m && (!w || G); if (m) { let oe = Lj(b, dU); oe.enabled = X } let q = A && (T || x || N); if (A) { let oe = Lj(b, Fj); oe.enabled = q } let J = { a_position: lge }; X && (J.a_color = dU), q && (J.a_normal = Fj), C && (J.a_batchId = uge); let W = "", K = z.length; for (i = 0; i < K; ++i) {
            let oe = z[i]; r = _[oe]; let ue = r.componentCount, ge = `czm_3dtiles_property_${oe}`, Ee; ue === 1 ? Ee = "float" : Ee = `vec${ue}`, W += `attribute ${Ee} ${ge}; 
`, J[ge] = r.location
        } Fct(e, t); let Z = `attribute vec3 a_position; 
varying vec4 v_color; 
uniform vec4 u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier; 
uniform vec4 u_constantColor; 
uniform vec4 u_highlightColor; 
`; Z += `float u_pointSize; 
float tiles3d_tileset_time; 
`, D && (Z += `float u_geometricError; 
float u_depthMultiplier; 
`), Z += W, X && (g ? Z += `attribute vec4 a_color; 
`: p ? Z += `attribute float a_color; 
const float SHIFT_RIGHT_11 = 1.0 / 2048.0; 
const float SHIFT_RIGHT_5 = 1.0 / 32.0; 
const float SHIFT_LEFT_11 = 2048.0; 
const float SHIFT_LEFT_5 = 32.0; 
const float NORMALIZE_6 = 1.0 / 64.0; 
const float NORMALIZE_5 = 1.0 / 32.0; 
`: Z += `attribute vec3 a_color; 
`), q && (f || d ? Z += `attribute vec2 a_normal; 
`: Z += `attribute vec3 a_normal; 
`), C && (Z += `attribute float a_batchId; 
`), (c || u || d) && (Z += `uniform vec4 u_quantizedVolumeScaleAndOctEncodedRange; 
`), w && (Z += P), v && (Z += B), O && (Z += R), Z += `void main() 
{ 
    u_pointSize = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.x; 
    tiles3d_tileset_time = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.y; 
`, D && (Z += `    u_geometricError = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.z; 
    u_depthMultiplier = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.w; 
`), X ? g ? Z += `    vec4 color = a_color; 
`: p ? Z += `    float compressed = a_color; 
    float r = floor(compressed * SHIFT_RIGHT_11); 
    compressed -= r * SHIFT_LEFT_11; 
    float g = floor(compressed * SHIFT_RIGHT_5); 
    compressed -= g * SHIFT_LEFT_5; 
    float b = compressed; 
    vec3 rgb = vec3(r * NORMALIZE_5, g * NORMALIZE_6, b * NORMALIZE_5); 
    vec4 color = vec4(rgb, 1.0); 
`: Z += `    vec4 color = vec4(a_color, 1.0); 
`: Z += `    vec4 color = u_constantColor; 
`, c || u ? Z += `    vec3 position = a_position * u_quantizedVolumeScaleAndOctEncodedRange.xyz; 
`: Z += `    vec3 position = a_position; 
`, Z += `    vec3 position_absolute = vec3(czm_model * vec4(position, 1.0)); 
`, q ? (f ? Z += `    vec3 normal = czm_octDecode(a_normal); 
`: d ? Z += `    vec3 normal = czm_octDecode(a_normal, u_quantizedVolumeScaleAndOctEncodedRange.w).zxy; 
`: Z += `    vec3 normal = a_normal; 
`, Z += `    vec3 normalEC = czm_normal * normal; 
`) : Z += `    vec3 normal = vec3(1.0); 
`, w && (Z += `    color = getColorFromStyle(position, position_absolute, color, normal); 
`), v && (Z += `    float show = float(getShowFromStyle(position, position_absolute, color, normal)); 
`), O ? Z += `    gl_PointSize = getPointSizeFromStyle(position, position_absolute, color, normal) * czm_pixelRatio; 
`: D ? Z += `    vec4 positionEC = czm_modelView * vec4(position, 1.0); 
    float depth = -positionEC.z; 
    gl_PointSize = min((u_geometricError / depth) * u_depthMultiplier, u_pointSize); 
`: Z += `    gl_PointSize = u_pointSize; 
`, Z += `    color = color * u_highlightColor; 
`, q && T && (Z += `    float diffuseStrength = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC); 
    diffuseStrength = max(diffuseStrength, 0.4); 
    color.xyz *= diffuseStrength * czm_lightColor; 
`), Z += `    v_color = color; 
    gl_Position = czm_modelViewProjection * vec4(position, 1.0); 
`, q && x && (Z += `    float visible = step(-normalEC.z, 0.0); 
    gl_Position *= visible; 
    gl_PointSize *= visible; 
`), v && (Z += `    gl_Position.w *= float(show); 
    gl_PointSize *= float(show); 
`), Z += `} 
`; let de = `varying vec4 v_color; 
`; V && (de += `uniform highp sampler2D u_clippingPlanes; 
uniform mat4 u_clippingPlanesMatrix; 
uniform vec4 u_clippingPlanesEdgeStyle; 
`, de += `
`, de += IE(S, s), de += `
`), de += `void main() 
{ 
    gl_FragColor = czm_gammaCorrect(v_color); 
`, V && (de += dk("u_clippingPlanes", "u_clippingPlanesMatrix", "u_clippingPlanesEdgeStyle")), de += `} 
`, e.splitDirection !== zc.NONE && (de = bv.modifyFragmentShader(de)), l(e._vertexShaderLoaded) && (Z = e._vertexShaderLoaded(Z)), l(e._fragmentShaderLoaded) && (de = e._fragmentShaderLoaded(de)); let pe = e._drawCommand; l(pe.shaderProgram) && pe.shaderProgram.destroy(), pe.shaderProgram = qt.fromCache({ context: s, vertexShaderSource: Z, fragmentShaderSource: de, attributeLocations: J }); try { pe.shaderProgram._bind() } catch { throw new fe("Error generating style shader: this may be caused by a type mismatch, index out-of-bounds, or other syntax error.") }
    } function kct(e, t) { if (e._decodingState === fA.READY) return !1; if (e._decodingState === fA.NEEDS_DECODE) { let n = e._parsedContent, i = n.draco, o = i_.decodePointCloud(i, t); l(o) && (e._decodingState = fA.DECODING, o.then(function (r) { e._decodingState = fA.READY; let s = l(r.POSITION) ? r.POSITION.array : void 0, a = l(r.RGB) ? r.RGB.array : void 0, c = l(r.RGBA) ? r.RGBA.array : void 0, u = l(r.NORMAL) ? r.NORMAL.array : void 0, f = l(r.BATCH_ID) ? r.BATCH_ID.array : void 0, d = l(s) && l(r.POSITION.data.quantization), p = l(u) && l(r.NORMAL.data.quantization); if (d) { let C = r.POSITION.data.quantization, x = C.range; e._quantizedVolumeScale = h.fromElements(x, x, x), e._quantizedVolumeOffset = h.unpack(C.minValues), e._quantizedRange = (1 << C.quantizationBits) - 1, e._isQuantizedDraco = !0 } p && (e._octEncodedRange = (1 << r.NORMAL.data.quantization.quantizationBits) - 1, e._isOctEncodedDraco = !0); let g = n.styleableProperties, m = i.batchTableProperties; for (let C in m) if (m.hasOwnProperty(C)) { let x = r[C]; l(g) || (g = {}), g[C] = { typedArray: x.array, componentCount: x.data.componentsPerAttribute } } l(s) && (n.positions = { typedArray: s }); let A = y(c, a); l(A) && (n.colors = { typedArray: A }), l(u) && (n.normals = { typedArray: u }), l(f) && (n.batchIds = { typedArray: f }), n.styleableProperties = g }).catch(function (r) { e._decodingState = fA.FAILED, e._rejectReadyPromise(r) })) } return !0 } var Uct = new se, zct = new h; Sv.prototype.update = function (e) { let t = e.context; if (kct(this, t)) return; let i = !1, o = !F.equals(this._modelMatrix, this.modelMatrix); if (this._mode !== e.mode && (this._mode = e.mode, o = !0), l(this._drawCommand) || (Lct(this, e), o = !0, i = !0, this._resolveReadyPromise(), this._parsedContent = void 0), o) { F.clone(this.modelMatrix, this._modelMatrix); let u = this._drawCommand.modelMatrix; if (F.clone(this._modelMatrix, u), l(this._rtcCenter) && F.multiplyByTranslation(u, this._rtcCenter, u), l(this._quantizedVolumeOffset) && F.multiplyByTranslation(u, this._quantizedVolumeOffset, u), e.mode !== ee.SCENE3D) { let d = e.mapProjection, p = F.getColumn(u, 3, Uct); se.equals(p, se.UNIT_W) || It.basisTo2D(d, u, u) } let f = this._drawCommand.boundingVolume; if (re.clone(this._boundingSphere, f), this._cull) { let d = f.center; F.multiplyByPoint(u, d, d); let p = F.getScale(u, zct); f.radius *= h.maximumComponent(p) } } this.clippingPlanesDirty && (this.clippingPlanesDirty = !1, i = !0), this._attenuation !== this.attenuation && (this._attenuation = this.attenuation, i = !0), this.backFaceCulling !== this._backFaceCulling && (this._backFaceCulling = this.backFaceCulling, i = !0), this.normalShading !== this._normalShading && (this._normalShading = this.normalShading, i = !0), (this._style !== this.style || this.styleDirty) && (this._style = this.style, this.styleDirty = !1, i = !0); let r = this.splitDirection !== zc.NONE; this._splittingEnabled !== r && (this._splittingEnabled = r, i = !0), i && Vct(this, e, this._style), this._drawCommand.castShadows = hn.castShadows(this.shadows), this._drawCommand.receiveShadows = hn.receiveShadows(this.shadows); let s = this._highlightColor.alpha < 1 || this._constantColor.alpha < 1 || this._styleTranslucent; this._drawCommand.renderState = s ? this._translucentRenderState : this._opaqueRenderState, this._drawCommand.pass = s ? xe.TRANSLUCENT : this._opaquePass; let a = e.commandList, c = e.passes; (c.render || c.pick) && a.push(this._drawCommand) }; Sv.prototype.isDestroyed = function () { return !1 }; Sv.prototype.destroy = function () { let e = this._drawCommand; return l(e) && (e.vertexArray = e.vertexArray && e.vertexArray.destroy(), e.shaderProgram = e.shaderProgram && e.shaderProgram.destroy()), le(this) }; var hU = Sv; var Hct = { NEAREST: 0, LINEAR: 1 }, tf = Hct; function dA(e) { e = y(e, y.EMPTY_OBJECT); let t = e.fragmentShader, n = y(e.textureScale, 1), i = y(e.pixelFormat, ht.RGBA); this._fragmentShader = t, this._uniforms = e.uniforms, this._textureScale = n, this._forcePowerOfTwo = y(e.forcePowerOfTwo, !1), this._sampleMode = y(e.sampleMode, tf.NEAREST), this._pixelFormat = i, this._pixelDatatype = y(e.pixelDatatype, Ye.UNSIGNED_BYTE), this._clearColor = y(e.clearColor, U.BLACK), this._uniformMap = void 0, this._command = void 0, this._colorTexture = void 0, this._depthTexture = void 0, this._idTexture = void 0, this._actualUniforms = {}, this._dirtyUniforms = [], this._texturesToRelease = [], this._texturesToCreate = [], this._texturePromise = void 0; let o = new pc; o.scissorTest = { enabled: !0, rectangle: l(e.scissorRectangle) ? Ge.clone(e.scissorRectangle) : new Ge }, this._passState = o, this._ready = !1; let r = e.name; l(r) || (r = Nn()), this._name = r, this._logDepthChanged = void 0, this._useLogDepth = void 0, this._selectedIdTexture = void 0, this._selected = void 0, this._selectedShadow = void 0, this._parentSelected = void 0, this._parentSelectedShadow = void 0, this._combinedSelected = void 0, this._combinedSelectedShadow = void 0, this._selectedLength = 0, this._parentSelectedLength = 0, this._selectedDirty = !0, this._textureCache = void 0, this._index = void 0, this.enabled = !0, this._enabled = !0 } Object.defineProperties(dA.prototype, { ready: { get: function () { return this._ready } }, name: { get: function () { return this._name } }, fragmentShader: { get: function () { return this._fragmentShader } }, uniforms: { get: function () { return this._uniforms } }, textureScale: { get: function () { return this._textureScale } }, forcePowerOfTwo: { get: function () { return this._forcePowerOfTwo } }, sampleMode: { get: function () { return this._sampleMode } }, pixelFormat: { get: function () { return this._pixelFormat } }, pixelDatatype: { get: function () { return this._pixelDatatype } }, clearColor: { get: function () { return this._clearColor } }, scissorRectangle: { get: function () { return this._passState.scissorTest.rectangle } }, outputTexture: { get: function () { if (l(this._textureCache)) { let e = this._textureCache.getFramebuffer(this._name); if (l(e)) return e.getColorTexture(0) } } }, selected: { get: function () { return this._selected }, set: function (e) { this._selected = e } }, parentSelected: { get: function () { return this._parentSelected }, set: function (e) { this._parentSelected = e } } }); var Gct = /uniform\s+sampler2D\s+depthTexture/g; dA.prototype._isSupported = function (e) { return !Gct.test(this._fragmentShader) || e.depthTexture }; function Wct(e, t, n) { let i = t[n]; return (typeof i == "string" || i instanceof HTMLCanvasElement || i instanceof HTMLImageElement || i instanceof HTMLVideoElement || i instanceof ImageData) && e._dirtyUniforms.push(n), { get: function () { return t[n] }, set: function (o) { let r = t[n]; t[n] = o; let s = e._actualUniforms, a = s[n]; l(a) && a !== r && a instanceof Rt && !l(e._textureCache.getStageByName(n)) && (e._texturesToRelease.push(a), delete s[n], delete s[`${n}Dimensions`]), r instanceof Rt && e._texturesToRelease.push(r), typeof o == "string" || o instanceof HTMLCanvasElement || o instanceof HTMLImageElement || o instanceof HTMLVideoElement || o instanceof ImageData ? e._dirtyUniforms.push(n) : s[n] = o } } } function jct(e, t) { return function () { let n = e._actualUniforms[t]; return typeof n == "function" ? n() : n } } function qct(e, t) { return function () { let n = e[t](); if (l(n)) return n.dimensions } } function Yct(e) { if (l(e._uniformMap)) return; let t = {}, n = {}, i = e._uniforms, o = e._actualUniforms; for (let r in i) if (i.hasOwnProperty(r)) { typeof i[r] != "function" ? (t[r] = jct(e, r), n[r] = Wct(e, i, r)) : (t[r] = i[r], n[r] = i[r]), o[r] = i[r]; let s = t[r](); (typeof s == "string" || s instanceof Rt || s instanceof HTMLImageElement || s instanceof HTMLCanvasElement || s instanceof HTMLVideoElement) && (t[`${r}Dimensions`] = qct(t, r)) } e._uniforms = {}, Object.defineProperties(e._uniforms, n), e._uniformMap = yt(t, { colorTexture: function () { return e._colorTexture }, colorTextureDimensions: function () { return e._colorTexture.dimensions }, depthTexture: function () { return e._depthTexture }, depthTextureDimensions: function () { return e._depthTexture.dimensions }, czm_idTexture: function () { return e._idTexture }, czm_selectedIdTexture: function () { return e._selectedIdTexture }, czm_selectedIdTextureStep: function () { return 1 / e._selectedIdTexture.width } }) } function Xct(e, t) {
        if (l(e._command) && !e._logDepthChanged && !e._selectedDirty) return; let n = e._fragmentShader; if (l(e._selectedIdTexture)) {
            let o = e._selectedIdTexture.width; n = n.replace(/varying\s+vec2\s+v_textureCoordinates;/g, ""), n = `#define CZM_SELECTED_FEATURE 
uniform sampler2D czm_idTexture; 
uniform sampler2D czm_selectedIdTexture; 
uniform float czm_selectedIdTextureStep; 
varying vec2 v_textureCoordinates; 
bool czm_selected(vec2 offset) 
{ 
    bool selected = false;
    vec4 id = texture2D(czm_idTexture, v_textureCoordinates + offset); 
    for (int i = 0; i < ${o}; ++i) 
    { 
        vec4 selectedId = texture2D(czm_selectedIdTexture, vec2((float(i) + 0.5) * czm_selectedIdTextureStep, 0.5)); 
        if (all(equal(id, selectedId))) 
        { 
            return true; 
        } 
    } 
    return false; 
} 

bool czm_selected() 
{ 
    return czm_selected(vec2(0.0)); 
} 

${n}`
        } let i = new Ue({ defines: [e._useLogDepth ? "LOG_DEPTH" : ""], sources: [n] }); e._command = t.createViewportQuadCommand(i, { uniformMap: e._uniformMap, owner: e })
    } function Kct(e) { let t = e._sampleMode, n, i; t === tf.LINEAR ? (n = ln.LINEAR, i = Xi.LINEAR) : (n = ln.NEAREST, i = Xi.NEAREST); let o = e._sampler; (!l(o) || o.minificationFilter !== n || o.magnificationFilter !== i) && (e._sampler = new dn({ wrapS: In.CLAMP_TO_EDGE, wrapT: In.CLAMP_TO_EDGE, minificationFilter: n, magnificationFilter: i })) } function Jct(e, t) { return function (n) { e._texturesToCreate.push({ name: t, source: n }) } } function Zct(e, t) { return function () { return e._textureCache.getOutputTexture(t) } } function Qct(e, t) { let n, i, o, r = e._texturesToRelease, s = r.length; for (n = 0; n < s; ++n)i = r[n], i = i && i.destroy(); r.length = 0; let a = e._texturesToCreate; for (s = a.length, n = 0; n < s; ++n) { let d = a[n]; o = d.name; let p = d.source; e._actualUniforms[o] = new Rt({ context: t, source: p }) } a.length = 0; let c = e._dirtyUniforms; if (c.length === 0 && !l(e._texturePromise)) { e._ready = !0; return } if (c.length === 0 || l(e._texturePromise)) return; s = c.length; let u = e._uniforms, f = []; for (n = 0; n < s; ++n) { o = c[n]; let d = u[o], p = e._textureCache.getStageByName(d); if (l(p)) e._actualUniforms[o] = Zct(e, d); else if (typeof d == "string") { let g = new Pe({ url: d }); f.push(g.fetchImage().then(Jct(e, o))) } else e._texturesToCreate.push({ name: o, source: d }) } c.length = 0, f.length > 0 ? (e._ready = !1, e._texturePromise = Promise.all(f).then(function () { e._ready = !0, e._texturePromise = void 0 })) : e._ready = !0 } function fge(e) { l(e._command) && (e._command.shaderProgram = e._command.shaderProgram && e._command.shaderProgram.destroy(), e._command = void 0), e._selectedIdTexture = e._selectedIdTexture && e._selectedIdTexture.destroy(); let t = e._textureCache; if (!l(t)) return; let n = e._uniforms, i = e._actualUniforms; for (let o in i) i.hasOwnProperty(o) && i[o] instanceof Rt && (l(t.getStageByName(n[o])) || i[o].destroy(), e._dirtyUniforms.push(o)) } function $ct(e) { let t = l(e._selected) ? e._selected.length : 0, n = l(e._parentSelected) ? e._parentSelected : 0, i = e._selected !== e._selectedShadow || t !== e._selectedLength; if (i = i || e._parentSelected !== e._parentSelectedShadow || n !== e._parentSelectedLength, l(e._selected) && l(e._parentSelected) ? e._combinedSelected = e._selected.concat(e._parentSelected) : l(e._parentSelected) ? e._combinedSelected = e._parentSelected : e._combinedSelected = e._selected, !i && l(e._combinedSelected)) { if (!l(e._combinedSelectedShadow)) return !0; t = e._combinedSelected.length; for (let o = 0; o < t; ++o)if (e._combinedSelected[o] !== e._combinedSelectedShadow[o]) return !0 } return i } function elt(e, t) { if (!e._selectedDirty) return; e._selectedIdTexture = e._selectedIdTexture && e._selectedIdTexture.destroy(), e._selectedIdTexture = void 0; let n = e._combinedSelected; if (!l(n)) return; let i, o, r = 0, s = n.length; for (i = 0; i < s; ++i)o = n[i], l(o.pickIds) ? r += o.pickIds.length : l(o.pickId) && ++r; if (s === 0 || r === 0) { let f = new Uint8Array(4); f[0] = 255, f[1] = 255, f[2] = 255, f[3] = 255, e._selectedIdTexture = new Rt({ context: t, pixelFormat: ht.RGBA, pixelDatatype: Ye.UNSIGNED_BYTE, source: { arrayBufferView: f, width: 1, height: 1 }, sampler: dn.NEAREST }); return } let a, c = 0, u = new Uint8Array(r * 4); for (i = 0; i < s; ++i)if (o = n[i], l(o.pickIds)) { let f = o.pickIds, d = f.length; for (let p = 0; p < d; ++p)a = f[p].color, u[c] = U.floatToByte(a.red), u[c + 1] = U.floatToByte(a.green), u[c + 2] = U.floatToByte(a.blue), u[c + 3] = U.floatToByte(a.alpha), c += 4 } else l(o.pickId) && (a = o.pickId.color, u[c] = U.floatToByte(a.red), u[c + 1] = U.floatToByte(a.green), u[c + 2] = U.floatToByte(a.blue), u[c + 3] = U.floatToByte(a.alpha), c += 4); e._selectedIdTexture = new Rt({ context: t, pixelFormat: ht.RGBA, pixelDatatype: Ye.UNSIGNED_BYTE, source: { arrayBufferView: u, width: r, height: 1 }, sampler: dn.NEAREST }) } dA.prototype.update = function (e, t) { if (this.enabled !== this._enabled && !this.enabled && fge(this), this._enabled = this.enabled, !this._enabled || (this._logDepthChanged = t !== this._useLogDepth, this._useLogDepth = t, this._selectedDirty = $ct(this), this._selectedShadow = this._selected, this._parentSelectedShadow = this._parentSelected, this._combinedSelectedShadow = this._combinedSelected, this._selectedLength = l(this._selected) ? this._selected.length : 0, this._parentSelectedLength = l(this._parentSelected) ? this._parentSelected.length : 0, elt(this, e), Yct(this), Qct(this, e), Xct(this, e), Kct(this), this._selectedDirty = !1, !this._ready)) return; let n = this._textureCache.getFramebuffer(this._name); if (this._command.framebuffer = n, !l(n)) return; let i = n.getColorTexture(0), o; (i.width !== e.drawingBufferWidth || i.height !== e.drawingBufferHeight) && (o = this._renderState, (!l(o) || i.width !== o.viewport.width || i.height !== o.viewport.height) && (this._renderState = Ve.fromCache({ viewport: new Ge(0, 0, i.width, i.height) }))), this._command.renderState = o }; dA.prototype.execute = function (e, t, n, i) { if (!l(this._command) || !l(this._command.framebuffer) || !this._ready || !this._enabled) return; this._colorTexture = t, this._depthTexture = n, this._idTexture = i, dn.equals(this._colorTexture.sampler, this._sampler) || (this._colorTexture.sampler = this._sampler); let o = this.scissorRectangle.width > 0 && this.scissorRectangle.height > 0 ? this._passState : void 0; l(o) && (o.context = e), this._command.execute(e, o) }; dA.prototype.isDestroyed = function () { return !1 }; dA.prototype.destroy = function () { return fge(this), le(this) }; var ho = dA; var mU = `uniform sampler2D colorTexture;
varying vec2 v_textureCoordinates;
#ifdef AUTO_EXPOSURE
uniform sampler2D autoExposure;
#endif
void main()
{
vec4 fragmentColor = texture2D(colorTexture, v_textureCoordinates);
vec3 color = fragmentColor.rgb;
#ifdef AUTO_EXPOSURE
color /= texture2D(autoExposure, vec2(0.5)).r;
#endif
color = czm_acesTonemapping(color);
color = czm_inverseGamma(color);
gl_FragColor = vec4(color, fragmentColor.a);
}
`; var pU = `uniform sampler2D randomTexture;
uniform sampler2D depthTexture;
uniform float intensity;
uniform float bias;
uniform float lengthCap;
uniform float stepSize;
uniform float frustumLength;
varying vec2 v_textureCoordinates;
vec4 clipToEye(vec2 uv, float depth)
{
vec2 xy = vec2((uv.x * 2.0 - 1.0), ((1.0 - uv.y) * 2.0 - 1.0));
vec4 posEC = czm_inverseProjection * vec4(xy, depth, 1.0);
posEC = posEC / posEC.w;
return posEC;
}
vec3 getNormalXEdge(vec3 posInCamera, float depthU, float depthD, float depthL, float depthR, vec2 pixelSize)
{
vec4 posInCameraUp = clipToEye(v_textureCoordinates - vec2(0.0, pixelSize.y), depthU);
vec4 posInCameraDown = clipToEye(v_textureCoordinates + vec2(0.0, pixelSize.y), depthD);
vec4 posInCameraLeft = clipToEye(v_textureCoordinates - vec2(pixelSize.x, 0.0), depthL);
vec4 posInCameraRight = clipToEye(v_textureCoordinates + vec2(pixelSize.x, 0.0), depthR);
vec3 up = posInCamera.xyz - posInCameraUp.xyz;
vec3 down = posInCameraDown.xyz - posInCamera.xyz;
vec3 left = posInCamera.xyz - posInCameraLeft.xyz;
vec3 right = posInCameraRight.xyz - posInCamera.xyz;
vec3 DX = length(left) < length(right) ? left : right;
vec3 DY = length(up) < length(down) ? up : down;
return normalize(cross(DY, DX));
}
void main(void)
{
float depth = czm_readDepth(depthTexture, v_textureCoordinates);
vec4 posInCamera = clipToEye(v_textureCoordinates, depth);
if (posInCamera.z > frustumLength)
{
gl_FragColor = vec4(1.0);
return;
}
vec2 pixelSize = czm_pixelRatio / czm_viewport.zw;
float depthU = czm_readDepth(depthTexture, v_textureCoordinates - vec2(0.0, pixelSize.y));
float depthD = czm_readDepth(depthTexture, v_textureCoordinates + vec2(0.0, pixelSize.y));
float depthL = czm_readDepth(depthTexture, v_textureCoordinates - vec2(pixelSize.x, 0.0));
float depthR = czm_readDepth(depthTexture, v_textureCoordinates + vec2(pixelSize.x, 0.0));
vec3 normalInCamera = getNormalXEdge(posInCamera.xyz, depthU, depthD, depthL, depthR, pixelSize);
float ao = 0.0;
vec2 sampleDirection = vec2(1.0, 0.0);
float gapAngle = 90.0 * czm_radiansPerDegree;
float randomVal = texture2D(randomTexture, v_textureCoordinates).x;
for (int i = 0; i < 4; i++)
{
float newGapAngle = gapAngle * (float(i) + randomVal);
float cosVal = cos(newGapAngle);
float sinVal = sin(newGapAngle);
vec2 rotatedSampleDirection = vec2(cosVal * sampleDirection.x - sinVal * sampleDirection.y, sinVal * sampleDirection.x + cosVal * sampleDirection.y);
float localAO = 0.0;
float localStepSize = stepSize;
for (int j = 0; j < 6; j++)
{
vec2 newCoords = v_textureCoordinates + rotatedSampleDirection * localStepSize * pixelSize;
if(newCoords.x > 1.0 || newCoords.y > 1.0 || newCoords.x < 0.0 || newCoords.y < 0.0)
{
break;
}
float stepDepthInfo = czm_readDepth(depthTexture, newCoords);
vec4 stepPosInCamera = clipToEye(newCoords, stepDepthInfo);
vec3 diffVec = stepPosInCamera.xyz - posInCamera.xyz;
float len = length(diffVec);
if (len > lengthCap)
{
break;
}
float dotVal = clamp(dot(normalInCamera, normalize(diffVec)), 0.0, 1.0 );
float weight = len / lengthCap;
weight = 1.0 - weight * weight;
if (dotVal < bias)
{
dotVal = 0.0;
}
localAO = max(localAO, dotVal * weight);
localStepSize += stepSize;
}
ao += localAO;
}
ao /= 4.0;
ao = 1.0 - clamp(ao, 0.0, 1.0);
ao = pow(ao, intensity);
gl_FragColor = vec4(vec3(ao), 1.0);
}
`; var _U = `uniform sampler2D colorTexture;
uniform sampler2D ambientOcclusionTexture;
uniform bool ambientOcclusionOnly;
varying vec2 v_textureCoordinates;
void main(void)
{
vec3 color = texture2D(colorTexture, v_textureCoordinates).rgb;
vec3 ao = texture2D(ambientOcclusionTexture, v_textureCoordinates).rgb;
gl_FragColor.rgb = ambientOcclusionOnly ? ao : ao * color;
}
`; var gU = `uniform sampler2D colorTexture;
uniform float gradations;
varying vec2 v_textureCoordinates;
void main(void)
{
vec3 rgb = texture2D(colorTexture, v_textureCoordinates).rgb;
#ifdef CZM_SELECTED_FEATURE
if (czm_selected()) {
gl_FragColor = vec4(rgb, 1.0);
return;
}
#endif
float luminance = czm_luminance(rgb);
float darkness = luminance * gradations;
darkness = (darkness - fract(darkness)) / gradations;
gl_FragColor = vec4(vec3(darkness), 1.0);
}
`; var yU = `uniform sampler2D colorTexture;
uniform sampler2D bloomTexture;
uniform bool glowOnly;
varying vec2 v_textureCoordinates;
void main(void)
{
vec4 color = texture2D(colorTexture, v_textureCoordinates);
#ifdef CZM_SELECTED_FEATURE
if (czm_selected()) {
gl_FragColor = color;
return;
}
#endif
vec4 bloom = texture2D(bloomTexture, v_textureCoordinates);
gl_FragColor = glowOnly ? bloom : bloom + color;
}
`; var AU = `uniform sampler2D colorTexture;
uniform float brightness;
varying vec2 v_textureCoordinates;
void main(void)
{
vec3 rgb = texture2D(colorTexture, v_textureCoordinates).rgb;
vec3 target = vec3(0.0);
gl_FragColor = vec4(mix(target, rgb, brightness), 1.0);
}
`; var CU = `uniform sampler2D colorTexture;
uniform float contrast;
uniform float brightness;
varying vec2 v_textureCoordinates;
void main(void)
{
vec3 sceneColor = texture2D(colorTexture, v_textureCoordinates).xyz;
sceneColor = czm_RGBToHSB(sceneColor);
sceneColor.z += brightness;
sceneColor = czm_HSBToRGB(sceneColor);
float factor = (259.0 * (contrast + 255.0)) / (255.0 * (259.0 - contrast));
sceneColor = factor * (sceneColor - vec3(0.5)) + vec3(0.5);
gl_FragColor = vec4(sceneColor, 1.0);
}
`; var xU = `uniform sampler2D colorTexture;
uniform sampler2D blurTexture;
uniform sampler2D depthTexture;
uniform float focalDistance;
varying vec2 v_textureCoordinates;
vec4 toEye(vec2 uv, float depth)
{
vec2 xy = vec2((uv.x * 2.0 - 1.0), ((1.0 - uv.y) * 2.0 - 1.0));
vec4 posInCamera = czm_inverseProjection * vec4(xy, depth, 1.0);
posInCamera = posInCamera / posInCamera.w;
return posInCamera;
}
float computeDepthBlur(float depth)
{
float f;
if (depth < focalDistance)
{
f = (focalDistance - depth) / (focalDistance - czm_currentFrustum.x);
}
else
{
f = (depth - focalDistance) / (czm_currentFrustum.y - focalDistance);
f = pow(f, 0.1);
}
f *= f;
f = clamp(f, 0.0, 1.0);
return pow(f, 0.5);
}
void main(void)
{
float depth = czm_readDepth(depthTexture, v_textureCoordinates);
vec4 posInCamera = toEye(v_textureCoordinates, depth);
float d = computeDepthBlur(-posInCamera.z);
gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), texture2D(blurTexture, v_textureCoordinates), d);
}
`; var TU = `uniform sampler2D depthTexture;
varying vec2 v_textureCoordinates;
void main(void)
{
float depth = czm_readDepth(depthTexture, v_textureCoordinates);
gl_FragColor = vec4(vec3(depth), 1.0);
}
`; var EU = `uniform sampler2D depthTexture;
uniform float length;
uniform vec4 color;
varying vec2 v_textureCoordinates;
void main(void)
{
float directions[3];
directions[0] = -1.0;
directions[1] = 0.0;
directions[2] = 1.0;
float scalars[3];
scalars[0] = 3.0;
scalars[1] = 10.0;
scalars[2] = 3.0;
float padx = czm_pixelRatio / czm_viewport.z;
float pady = czm_pixelRatio / czm_viewport.w;
#ifdef CZM_SELECTED_FEATURE
bool selected = false;
for (int i = 0; i < 3; ++i)
{
float dir = directions[i];
selected = selected || czm_selected(vec2(-padx, dir * pady));
selected = selected || czm_selected(vec2(padx, dir * pady));
selected = selected || czm_selected(vec2(dir * padx, -pady));
selected = selected || czm_selected(vec2(dir * padx, pady));
if (selected)
{
break;
}
}
if (!selected)
{
gl_FragColor = vec4(color.rgb, 0.0);
return;
}
#endif
float horizEdge = 0.0;
float vertEdge = 0.0;
for (int i = 0; i < 3; ++i)
{
float dir = directions[i];
float scale = scalars[i];
horizEdge -= texture2D(depthTexture, v_textureCoordinates + vec2(-padx, dir * pady)).x * scale;
horizEdge += texture2D(depthTexture, v_textureCoordinates + vec2(padx, dir * pady)).x * scale;
vertEdge -= texture2D(depthTexture, v_textureCoordinates + vec2(dir * padx, -pady)).x * scale;
vertEdge += texture2D(depthTexture, v_textureCoordinates + vec2(dir * padx, pady)).x * scale;
}
float len = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);
gl_FragColor = vec4(color.rgb, len > length ? color.a : 0.0);
}
`; var bU = `uniform sampler2D colorTexture;
varying vec2 v_textureCoordinates;
#ifdef AUTO_EXPOSURE
uniform sampler2D autoExposure;
#endif
void main()
{
vec4 fragmentColor = texture2D(colorTexture, v_textureCoordinates);
vec3 color = fragmentColor.rgb;
#ifdef AUTO_EXPOSURE
float exposure = texture2D(autoExposure, vec2(0.5)).r;
color /= exposure;
#endif
const float A = 0.22;
const float B = 0.30;
const float C = 0.10;
const float D = 0.20;
const float E = 0.01;
const float F = 0.30;
const float white = 11.2;
vec3 c = ((color * (A * color + C * B) + D * E) / (color * ( A * color + B) + D * F)) - E / F;
float w = ((white * (A * white + C * B) + D * E) / (white * ( A * white + B) + D * F)) - E / F;
c = czm_inverseGamma(c / w);
gl_FragColor = vec4(c, fragmentColor.a);
}
`; var SU = `varying vec2 v_textureCoordinates;
uniform sampler2D colorTexture;
const float fxaaQualitySubpix = 0.5;
const float fxaaQualityEdgeThreshold = 0.125;
const float fxaaQualityEdgeThresholdMin = 0.0833;
void main()
{
vec2 fxaaQualityRcpFrame = vec2(1.0) / czm_viewport.zw;
vec4 color = FxaaPixelShader(
v_textureCoordinates,
colorTexture,
fxaaQualityRcpFrame,
fxaaQualitySubpix,
fxaaQualityEdgeThreshold,
fxaaQualityEdgeThresholdMin);
float alpha = texture2D(colorTexture, v_textureCoordinates).a;
gl_FragColor = vec4(color.rgb, alpha);
}
`; var hA = `#define SAMPLES 8
uniform float delta;
uniform float sigma;
uniform float direction;
uniform sampler2D colorTexture;
#ifdef USE_STEP_SIZE
uniform float stepSize;
#else
uniform vec2 step;
#endif
varying vec2 v_textureCoordinates;
void main()
{
vec2 st = v_textureCoordinates;
vec2 dir = vec2(1.0 - direction, direction);
#ifdef USE_STEP_SIZE
vec2 step = vec2(stepSize * (czm_pixelRatio / czm_viewport.zw));
#else
vec2 step = step;
#endif
vec3 g;
g.x = 1.0 / (sqrt(czm_twoPi) * sigma);
g.y = exp((-0.5 * delta * delta) / (sigma * sigma));
g.z = g.y * g.y;
vec4 result = texture2D(colorTexture, st) * g.x;
for (int i = 1; i < SAMPLES; ++i)
{
g.xy *= g.yz;
vec2 offset = float(i) * dir * step;
result += texture2D(colorTexture, st - offset) * g.x;
result += texture2D(colorTexture, st + offset) * g.x;
}
gl_FragColor = result;
}
`; var wU = `uniform sampler2D colorTexture;
uniform sampler2D dirtTexture;
uniform sampler2D starTexture;
uniform vec2 dirtTextureDimensions;
uniform float distortion;
uniform float ghostDispersal;
uniform float haloWidth;
uniform float dirtAmount;
uniform float earthRadius;
uniform float intensity;
varying vec2 v_textureCoordinates;
#define DISTANCE_TO_SPACE 6500000.0
vec4 getNDCFromWC(vec3 WC, float earthRadius)
{
vec4 positionEC = czm_view * vec4(WC, 1.0);
positionEC = vec4(positionEC.x + earthRadius, positionEC.y, positionEC.z, 1.0);
vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);
return czm_viewportOrthographic * vec4(positionWC.xy, -positionWC.z, 1.0);
}
float isInEarth(vec2 texcoord, vec2 sceneSize)
{
vec2 NDC = texcoord * 2.0 - 1.0;
vec4 earthPosSC = getNDCFromWC(vec3(0.0), 0.0);
vec4 earthPosSCEdge = getNDCFromWC(vec3(0.0), earthRadius * 1.5);
NDC.xy -= earthPosSC.xy;
float X = abs(NDC.x) * sceneSize.x;
float Y = abs(NDC.y) * sceneSize.y;
return clamp(0.0, 1.0, max(sqrt(X * X + Y * Y) / max(abs(earthPosSCEdge.x * sceneSize.x), 1.0) - 0.8 , 0.0));
}
vec4 textureDistorted(sampler2D tex, vec2 texcoord, vec2 direction, vec3 distortion, bool isSpace)
{
vec2 sceneSize = czm_viewport.zw;
vec3 color;
if(isSpace)
{
color.r = isInEarth(texcoord + direction * distortion.r, sceneSize) * texture2D(tex, texcoord + direction * distortion.r).r;
color.g = isInEarth(texcoord + direction * distortion.g, sceneSize) * texture2D(tex, texcoord + direction * distortion.g).g;
color.b = isInEarth(texcoord + direction * distortion.b, sceneSize) * texture2D(tex, texcoord + direction * distortion.b).b;
}
else
{
color.r = texture2D(tex, texcoord + direction * distortion.r).r;
color.g = texture2D(tex, texcoord + direction * distortion.g).g;
color.b = texture2D(tex, texcoord + direction * distortion.b).b;
}
return vec4(clamp(color, 0.0, 1.0), 0.0);
}
void main(void)
{
vec4 originalColor = texture2D(colorTexture, v_textureCoordinates);
vec3 rgb = originalColor.rgb;
bool isSpace = length(czm_viewerPositionWC.xyz) > DISTANCE_TO_SPACE;
vec4 sunPos = czm_morphTime == 1.0 ? vec4(czm_sunPositionWC, 1.0) : vec4(czm_sunPositionColumbusView.zxy, 1.0);
vec4 sunPositionEC = czm_view * sunPos;
vec4 sunPositionWC = czm_eyeToWindowCoordinates(sunPositionEC);
sunPos = czm_viewportOrthographic * vec4(sunPositionWC.xy, -sunPositionWC.z, 1.0);
if(!isSpace || !((sunPos.x >= -1.1 && sunPos.x <= 1.1) && (sunPos.y >= -1.1 && sunPos.y <= 1.1)))
{
gl_FragColor = originalColor;
return;
}
vec2 texcoord = vec2(1.0) - v_textureCoordinates;
vec2 pixelSize = czm_pixelRatio / czm_viewport.zw;
vec2 invPixelSize = 1.0 / pixelSize;
vec3 distortionVec = pixelSize.x * vec3(-distortion, 0.0, distortion);
vec2 ghostVec = (vec2(0.5) - texcoord) * ghostDispersal;
vec3 direction = normalize(vec3(ghostVec, 0.0));
vec4 result = vec4(0.0);
vec4 ghost = vec4(0.0);
for (int i = 0; i < 4; ++i)
{
vec2 offset = fract(texcoord + ghostVec * float(i));
ghost += textureDistorted(colorTexture, offset, direction.xy, distortionVec, isSpace);
}
result += ghost;
vec2 haloVec = normalize(ghostVec) * haloWidth;
float weightForHalo = length(vec2(0.5) - fract(texcoord + haloVec)) / length(vec2(0.5));
weightForHalo = pow(1.0 - weightForHalo, 5.0);
result += textureDistorted(colorTexture, texcoord + haloVec, direction.xy, distortionVec, isSpace) * weightForHalo * 1.5;
vec2 dirtTexCoords = (v_textureCoordinates * invPixelSize) / dirtTextureDimensions;
if (dirtTexCoords.x > 1.0)
{
dirtTexCoords.x = mod(floor(dirtTexCoords.x), 2.0) == 1.0 ? 1.0 - fract(dirtTexCoords.x) :  fract(dirtTexCoords.x);
}
if (dirtTexCoords.y > 1.0)
{
dirtTexCoords.y = mod(floor(dirtTexCoords.y), 2.0) == 1.0 ? 1.0 - fract(dirtTexCoords.y) :  fract(dirtTexCoords.y);
}
result += dirtAmount * texture2D(dirtTexture, dirtTexCoords);
float camrot = czm_view[0].z + czm_view[1].y;
float cosValue = cos(camrot);
float sinValue = sin(camrot);
mat3 rotation = mat3(
cosValue, -sinValue, 0.0,
sinValue, cosValue, 0.0,
0.0, 0.0, 1.0
);
vec3 st1 = vec3(v_textureCoordinates * 2.0 - vec2(1.0), 1.0);
vec3 st2 = vec3((rotation * st1).xy, 1.0);
vec3 st3 = st2 * 0.5 + vec3(0.5);
vec2 lensStarTexcoord = st3.xy;
float weightForLensFlare = length(vec3(sunPos.xy, 0.0));
float oneMinusWeightForLensFlare = max(1.0 - weightForLensFlare, 0.0);
if (!isSpace)
{
result *= oneMinusWeightForLensFlare * intensity * 0.2;
}
else
{
result *= oneMinusWeightForLensFlare * intensity;
result *= texture2D(starTexture, lensStarTexcoord) * pow(weightForLensFlare, 1.0) * max((1.0 - length(vec3(st1.xy, 0.0))), 0.0) * 2.0;
}
result += texture2D(colorTexture, v_textureCoordinates);
gl_FragColor = result;
}
`; var DU = `uniform sampler2D colorTexture;
uniform vec3 white;
varying vec2 v_textureCoordinates;
#ifdef AUTO_EXPOSURE
uniform sampler2D autoExposure;
#endif
void main()
{
vec4 fragmentColor = texture2D(colorTexture, v_textureCoordinates);
vec3 color = fragmentColor.rgb;
#ifdef AUTO_EXPOSURE
float exposure = texture2D(autoExposure, vec2(0.5)).r;
color /= exposure;
#endif
color = (color * (1.0 + color / white)) / (1.0 + color);
color = czm_inverseGamma(color);
gl_FragColor = vec4(color, fragmentColor.a);
}
`; var vU = `uniform sampler2D colorTexture;
varying vec2 v_textureCoordinates;
float rand(vec2 co)
{
return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);
}
void main(void)
{
float noiseValue = rand(v_textureCoordinates + sin(czm_frameNumber)) * 0.1;
vec3 rgb = texture2D(colorTexture, v_textureCoordinates).rgb;
vec3 green = vec3(0.0, 1.0, 0.0);
gl_FragColor = vec4((noiseValue + rgb) * green, 1.0);
}
`; var PU = `uniform sampler2D colorTexture;
varying vec2 v_textureCoordinates;
#ifdef AUTO_EXPOSURE
uniform sampler2D autoExposure;
#endif
void main()
{
vec4 fragmentColor = texture2D(colorTexture, v_textureCoordinates);
vec3 color = fragmentColor.rgb;
#ifdef AUTO_EXPOSURE
float exposure = texture2D(autoExposure, vec2(0.5)).r;
color /= exposure;
#endif
color = color / (1.0 + color);
color = czm_inverseGamma(color);
gl_FragColor = vec4(color, fragmentColor.a);
}
`; var IU = `uniform sampler2D colorTexture;
uniform sampler2D silhouetteTexture;
varying vec2 v_textureCoordinates;
void main(void)
{
vec4 silhouetteColor = texture2D(silhouetteTexture, v_textureCoordinates);
vec4 color = texture2D(colorTexture, v_textureCoordinates);
gl_FragColor = mix(color, silhouetteColor, silhouetteColor.a);
}
`;/**
 * @license
 * Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */var OU = `#if (FXAA_QUALITY_PRESET == 10)
#define FXAA_QUALITY_PS 3
#define FXAA_QUALITY_P0 1.5
#define FXAA_QUALITY_P1 3.0
#define FXAA_QUALITY_P2 12.0
#endif
#if (FXAA_QUALITY_PRESET == 11)
#define FXAA_QUALITY_PS 4
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 3.0
#define FXAA_QUALITY_P3 12.0
#endif
#if (FXAA_QUALITY_PRESET == 12)
#define FXAA_QUALITY_PS 5
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 4.0
#define FXAA_QUALITY_P4 12.0
#endif
#if (FXAA_QUALITY_PRESET == 13)
#define FXAA_QUALITY_PS 6
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 4.0
#define FXAA_QUALITY_P5 12.0
#endif
#if (FXAA_QUALITY_PRESET == 14)
#define FXAA_QUALITY_PS 7
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 4.0
#define FXAA_QUALITY_P6 12.0
#endif
#if (FXAA_QUALITY_PRESET == 15)
#define FXAA_QUALITY_PS 8
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 2.0
#define FXAA_QUALITY_P6 4.0
#define FXAA_QUALITY_P7 12.0
#endif
#if (FXAA_QUALITY_PRESET == 20)
#define FXAA_QUALITY_PS 3
#define FXAA_QUALITY_P0 1.5
#define FXAA_QUALITY_P1 2.0
#define FXAA_QUALITY_P2 8.0
#endif
#if (FXAA_QUALITY_PRESET == 21)
#define FXAA_QUALITY_PS 4
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 8.0
#endif
#if (FXAA_QUALITY_PRESET == 22)
#define FXAA_QUALITY_PS 5
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 8.0
#endif
#if (FXAA_QUALITY_PRESET == 23)
#define FXAA_QUALITY_PS 6
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 8.0
#endif
#if (FXAA_QUALITY_PRESET == 24)
#define FXAA_QUALITY_PS 7
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 3.0
#define FXAA_QUALITY_P6 8.0
#endif
#if (FXAA_QUALITY_PRESET == 25)
#define FXAA_QUALITY_PS 8
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 2.0
#define FXAA_QUALITY_P6 4.0
#define FXAA_QUALITY_P7 8.0
#endif
#if (FXAA_QUALITY_PRESET == 26)
#define FXAA_QUALITY_PS 9
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 2.0
#define FXAA_QUALITY_P6 2.0
#define FXAA_QUALITY_P7 4.0
#define FXAA_QUALITY_P8 8.0
#endif
#if (FXAA_QUALITY_PRESET == 27)
#define FXAA_QUALITY_PS 10
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 2.0
#define FXAA_QUALITY_P6 2.0
#define FXAA_QUALITY_P7 2.0
#define FXAA_QUALITY_P8 4.0
#define FXAA_QUALITY_P9 8.0
#endif
#if (FXAA_QUALITY_PRESET == 28)
#define FXAA_QUALITY_PS 11
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 2.0
#define FXAA_QUALITY_P6 2.0
#define FXAA_QUALITY_P7 2.0
#define FXAA_QUALITY_P8 2.0
#define FXAA_QUALITY_P9 4.0
#define FXAA_QUALITY_P10 8.0
#endif
#if (FXAA_QUALITY_PRESET == 29)
#define FXAA_QUALITY_PS 12
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.5
#define FXAA_QUALITY_P2 2.0
#define FXAA_QUALITY_P3 2.0
#define FXAA_QUALITY_P4 2.0
#define FXAA_QUALITY_P5 2.0
#define FXAA_QUALITY_P6 2.0
#define FXAA_QUALITY_P7 2.0
#define FXAA_QUALITY_P8 2.0
#define FXAA_QUALITY_P9 2.0
#define FXAA_QUALITY_P10 4.0
#define FXAA_QUALITY_P11 8.0
#endif
#if (FXAA_QUALITY_PRESET == 39)
#define FXAA_QUALITY_PS 12
#define FXAA_QUALITY_P0 1.0
#define FXAA_QUALITY_P1 1.0
#define FXAA_QUALITY_P2 1.0
#define FXAA_QUALITY_P3 1.0
#define FXAA_QUALITY_P4 1.0
#define FXAA_QUALITY_P5 1.5
#define FXAA_QUALITY_P6 2.0
#define FXAA_QUALITY_P7 2.0
#define FXAA_QUALITY_P8 2.0
#define FXAA_QUALITY_P9 2.0
#define FXAA_QUALITY_P10 4.0
#define FXAA_QUALITY_P11 8.0
#endif
#define FxaaBool bool
#define FxaaFloat float
#define FxaaFloat2 vec2
#define FxaaFloat3 vec3
#define FxaaFloat4 vec4
#define FxaaHalf float
#define FxaaHalf2 vec2
#define FxaaHalf3 vec3
#define FxaaHalf4 vec4
#define FxaaInt2 vec2
#define FxaaTex sampler2D
#define FxaaSat(x) clamp(x, 0.0, 1.0)
#define FxaaTexTop(t, p) texture2D(t, p)
#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r))
FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }
FxaaFloat4 FxaaPixelShader(
FxaaFloat2 pos,
FxaaTex tex,
FxaaFloat2 fxaaQualityRcpFrame,
FxaaFloat fxaaQualitySubpix,
FxaaFloat fxaaQualityEdgeThreshold,
FxaaFloat fxaaQualityEdgeThresholdMin
) {
FxaaFloat2 posM;
posM.x = pos.x;
posM.y = pos.y;
FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
#define lumaM rgbyM.y
FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));
FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));
FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));
FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));
FxaaFloat maxSM = max(lumaS, lumaM);
FxaaFloat minSM = min(lumaS, lumaM);
FxaaFloat maxESM = max(lumaE, maxSM);
FxaaFloat minESM = min(lumaE, minSM);
FxaaFloat maxWN = max(lumaN, lumaW);
FxaaFloat minWN = min(lumaN, lumaW);
FxaaFloat rangeMax = max(maxWN, maxESM);
FxaaFloat rangeMin = min(minWN, minESM);
FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
FxaaFloat range = rangeMax - rangeMin;
FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
FxaaBool earlyExit = range < rangeMaxClamped;
if(earlyExit)
return rgbyM;
FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));
FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));
FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));
FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
FxaaFloat lumaNS = lumaN + lumaS;
FxaaFloat lumaWE = lumaW + lumaE;
FxaaFloat subpixRcpRange = 1.0/range;
FxaaFloat subpixNSWE = lumaNS + lumaWE;
FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;
FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;
FxaaFloat lumaNESE = lumaNE + lumaSE;
FxaaFloat lumaNWNE = lumaNW + lumaNE;
FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;
FxaaFloat lumaNWSW = lumaNW + lumaSW;
FxaaFloat lumaSWSE = lumaSW + lumaSE;
FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;
FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;
FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;
FxaaFloat lengthSign = fxaaQualityRcpFrame.x;
FxaaBool horzSpan = edgeHorz >= edgeVert;
FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
if(!horzSpan) lumaN = lumaW;
if(!horzSpan) lumaS = lumaE;
if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;
FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;
FxaaFloat gradientN = lumaN - lumaM;
FxaaFloat gradientS = lumaS - lumaM;
FxaaFloat lumaNN = lumaN + lumaM;
FxaaFloat lumaSS = lumaS + lumaM;
FxaaBool pairN = abs(gradientN) >= abs(gradientS);
FxaaFloat gradient = max(abs(gradientN), abs(gradientS));
if(pairN) lengthSign = -lengthSign;
FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);
FxaaFloat2 posB;
posB.x = posM.x;
posB.y = posM.y;
FxaaFloat2 offNP;
offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;
if(!horzSpan) posB.x += lengthSign * 0.5;
if( horzSpan) posB.y += lengthSign * 0.5;
FxaaFloat2 posN;
posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;
posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;
FxaaFloat2 posP;
posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;
posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;
FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;
FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));
FxaaFloat subpixE = subpixC * subpixC;
FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));
if(!pairN) lumaNN = lumaSS;
FxaaFloat gradientScaled = gradient * 1.0/4.0;
FxaaFloat lumaMM = lumaM - lumaNN * 0.5;
FxaaFloat subpixF = subpixD * subpixE;
FxaaBool lumaMLTZero = lumaMM < 0.0;
lumaEndN -= lumaNN * 0.5;
lumaEndP -= lumaNN * 0.5;
FxaaBool doneN = abs(lumaEndN) >= gradientScaled;
FxaaBool doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;
FxaaBool doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;
#if (FXAA_QUALITY_PS > 3)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;
#if (FXAA_QUALITY_PS > 4)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;
#if (FXAA_QUALITY_PS > 5)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;
#if (FXAA_QUALITY_PS > 6)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;
#if (FXAA_QUALITY_PS > 7)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;
#if (FXAA_QUALITY_PS > 8)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;
#if (FXAA_QUALITY_PS > 9)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;
#if (FXAA_QUALITY_PS > 10)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;
#if (FXAA_QUALITY_PS > 11)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;
#if (FXAA_QUALITY_PS > 12)
if(doneNP) {
if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
doneN = abs(lumaEndN) >= gradientScaled;
doneP = abs(lumaEndP) >= gradientScaled;
if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;
if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;
doneNP = (!doneN) || (!doneP);
if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;
if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;
}
#endif
}
#endif
}
#endif
}
#endif
}
#endif
}
#endif
}
#endif
}
#endif
}
#endif
}
#endif
}
FxaaFloat dstN = posM.x - posN.x;
FxaaFloat dstP = posP.x - posM.x;
if(!horzSpan) dstN = posM.y - posN.y;
if(!horzSpan) dstP = posP.y - posM.y;
FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
FxaaFloat spanLength = (dstP + dstN);
FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
FxaaFloat spanLengthRcp = 1.0/spanLength;
FxaaBool directionN = dstN < dstP;
FxaaFloat dst = min(dstN, dstP);
FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;
FxaaFloat subpixG = subpixF * subpixF;
FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
FxaaFloat subpixH = subpixG * fxaaQualitySubpix;
FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;
if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;
return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);
}
`; function mA(e) { e = y(e, y.EMPTY_OBJECT), this._stages = e.stages, this._inputPreviousStageTexture = y(e.inputPreviousStageTexture, !0); let t = e.name; l(t) || (t = Nn()), this._name = t, this._uniforms = e.uniforms, this._textureCache = void 0, this._index = void 0, this._selected = void 0, this._selectedShadow = void 0, this._parentSelected = void 0, this._parentSelectedShadow = void 0, this._combinedSelected = void 0, this._combinedSelectedShadow = void 0, this._selectedLength = 0, this._parentSelectedLength = 0, this._selectedDirty = !0 } Object.defineProperties(mA.prototype, { ready: { get: function () { let e = this._stages, t = e.length; for (let n = 0; n < t; ++n)if (!e[n].ready) return !1; return !0 } }, name: { get: function () { return this._name } }, enabled: { get: function () { return this._stages[0].enabled }, set: function (e) { let t = this._stages, n = t.length; for (let i = 0; i < n; ++i)t[i].enabled = e } }, uniforms: { get: function () { return this._uniforms } }, inputPreviousStageTexture: { get: function () { return this._inputPreviousStageTexture } }, length: { get: function () { return this._stages.length } }, selected: { get: function () { return this._selected }, set: function (e) { this._selected = e } }, parentSelected: { get: function () { return this._parentSelected }, set: function (e) { this._parentSelected = e } } }); mA.prototype._isSupported = function (e) { let t = this._stages, n = t.length; for (let i = 0; i < n; ++i)if (!t[i]._isSupported(e)) return !1; return !0 }; mA.prototype.get = function (e) { return this._stages[e] }; function tlt(e) { let t = l(e._selected) ? e._selected.length : 0, n = l(e._parentSelected) ? e._parentSelected : 0, i = e._selected !== e._selectedShadow || t !== e._selectedLength; if (i = i || e._parentSelected !== e._parentSelectedShadow || n !== e._parentSelectedLength, l(e._selected) && l(e._parentSelected) ? e._combinedSelected = e._selected.concat(e._parentSelected) : l(e._parentSelected) ? e._combinedSelected = e._parentSelected : e._combinedSelected = e._selected, !i && l(e._combinedSelected)) { if (!l(e._combinedSelectedShadow)) return !0; t = e._combinedSelected.length; for (let o = 0; o < t; ++o)if (e._combinedSelected[o] !== e._combinedSelectedShadow[o]) return !0 } return i } mA.prototype.update = function (e, t) { this._selectedDirty = tlt(this), this._selectedShadow = this._selected, this._parentSelectedShadow = this._parentSelected, this._combinedSelectedShadow = this._combinedSelected, this._selectedLength = l(this._selected) ? this._selected.length : 0, this._parentSelectedLength = l(this._parentSelected) ? this._parentSelected.length : 0; let n = this._stages, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; this._selectedDirty && (r.parentSelected = this._combinedSelected), r.update(e, t) } }; mA.prototype.isDestroyed = function () { return !1 }; mA.prototype.destroy = function () { let e = this._stages, t = e.length; for (let n = 0; n < t; ++n)e[n].destroy(); return le(this) }; var ol = mA; var Tr = {}; function BU(e) {
        let o = `#define USE_STEP_SIZE
${hA}`, r = new ho({ name: `${e}_x_direction`, fragmentShader: o, uniforms: { delta: 1, sigma: 2, stepSize: 1, direction: 0 }, sampleMode: tf.LINEAR }), s = new ho({ name: `${e}_y_direction`, fragmentShader: o, uniforms: { delta: 1, sigma: 2, stepSize: 1, direction: 1 }, sampleMode: tf.LINEAR }), a = {}; return Object.defineProperties(a, { delta: { get: function () { return r.uniforms.delta }, set: function (c) { let u = r.uniforms, f = s.uniforms; u.delta = f.delta = c } }, sigma: { get: function () { return r.uniforms.sigma }, set: function (c) { let u = r.uniforms, f = s.uniforms; u.sigma = f.sigma = c } }, stepSize: { get: function () { return r.uniforms.stepSize }, set: function (c) { let u = r.uniforms, f = s.uniforms; u.stepSize = f.stepSize = c } } }), new ol({ name: e, stages: [r, s], uniforms: a })
    } Tr.createBlurStage = function () { return BU("czm_blur") }; Tr.createDepthOfFieldStage = function () { let e = BU("czm_depth_of_field_blur"), t = new ho({ name: "czm_depth_of_field_composite", fragmentShader: xU, uniforms: { focalDistance: 5, blurTexture: e.name } }), n = {}; return Object.defineProperties(n, { focalDistance: { get: function () { return t.uniforms.focalDistance }, set: function (i) { t.uniforms.focalDistance = i } }, delta: { get: function () { return e.uniforms.delta }, set: function (i) { e.uniforms.delta = i } }, sigma: { get: function () { return e.uniforms.sigma }, set: function (i) { e.uniforms.sigma = i } }, stepSize: { get: function () { return e.uniforms.stepSize }, set: function (i) { e.uniforms.stepSize = i } } }), new ol({ name: "czm_depth_of_field", stages: [e, t], inputPreviousStageTexture: !1, uniforms: n }) }; Tr.isDepthOfFieldSupported = function (e) { return e.context.depthTexture }; Tr.createEdgeDetectionStage = function () { let e = Nn(); return new ho({ name: `czm_edge_detection_${e}`, fragmentShader: EU, uniforms: { length: .25, color: U.clone(U.BLACK) } }) }; Tr.isEdgeDetectionSupported = function (e) { return e.context.depthTexture }; function nlt(e) {
        if (!l(e)) return Tr.createEdgeDetectionStage(); let t = new ol({ name: "czm_edge_detection_multiple", stages: e, inputPreviousStageTexture: !1 }), n = {}, i = "", o = ""; for (let a = 0; a < e.length; ++a)i += `uniform sampler2D edgeTexture${a}; 
`, o += `        vec4 edge${a} = texture2D(edgeTexture${a}, v_textureCoordinates); 
        if (edge${a}.a > 0.0) 
        { 
            color = edge${a}; 
            break; 
        } 
`, n[`edgeTexture${a}`] = e[a].name; let r = `${i}varying vec2 v_textureCoordinates; 
void main() { 
    vec4 color = vec4(0.0); 
    for (int i = 0; i < ${e.length}; i++) 
    { 
${o}    } 
    gl_FragColor = color; 
} 
`, s = new ho({ name: "czm_edge_detection_combine", fragmentShader: r, uniforms: n }); return new ol({ name: "czm_edge_detection_composite", stages: [t, s] })
    } Tr.createSilhouetteStage = function (e) { let t = nlt(e), n = new ho({ name: "czm_silhouette_color_edges", fragmentShader: IU, uniforms: { silhouetteTexture: t.name } }); return new ol({ name: "czm_silhouette", stages: [t, n], inputPreviousStageTexture: !1, uniforms: t.uniforms }) }; Tr.isSilhouetteSupported = function (e) { return e.context.depthTexture }; Tr.createBloomStage = function () { let e = new ho({ name: "czm_bloom_contrast_bias", fragmentShader: CU, uniforms: { contrast: 128, brightness: -.3 } }), t = BU("czm_bloom_blur"), n = new ol({ name: "czm_bloom_contrast_bias_blur", stages: [e, t] }), i = new ho({ name: "czm_bloom_generate_composite", fragmentShader: yU, uniforms: { glowOnly: !1, bloomTexture: n.name } }), o = {}; return Object.defineProperties(o, { glowOnly: { get: function () { return i.uniforms.glowOnly }, set: function (r) { i.uniforms.glowOnly = r } }, contrast: { get: function () { return e.uniforms.contrast }, set: function (r) { e.uniforms.contrast = r } }, brightness: { get: function () { return e.uniforms.brightness }, set: function (r) { e.uniforms.brightness = r } }, delta: { get: function () { return t.uniforms.delta }, set: function (r) { t.uniforms.delta = r } }, sigma: { get: function () { return t.uniforms.sigma }, set: function (r) { t.uniforms.sigma = r } }, stepSize: { get: function () { return t.uniforms.stepSize }, set: function (r) { t.uniforms.stepSize = r } } }), new ol({ name: "czm_bloom", stages: [n, i], inputPreviousStageTexture: !1, uniforms: o }) }; Tr.createAmbientOcclusionStage = function () { let e = new ho({ name: "czm_ambient_occlusion_generate", fragmentShader: pU, uniforms: { intensity: 3, bias: .1, lengthCap: .26, stepSize: 1.95, frustumLength: 1e3, randomTexture: void 0 } }), t = BU("czm_ambient_occlusion_blur"); t.uniforms.stepSize = .86; let n = new ol({ name: "czm_ambient_occlusion_generate_blur", stages: [e, t] }), i = new ho({ name: "czm_ambient_occlusion_composite", fragmentShader: _U, uniforms: { ambientOcclusionOnly: !1, ambientOcclusionTexture: n.name } }), o = {}; return Object.defineProperties(o, { intensity: { get: function () { return e.uniforms.intensity }, set: function (r) { e.uniforms.intensity = r } }, bias: { get: function () { return e.uniforms.bias }, set: function (r) { e.uniforms.bias = r } }, lengthCap: { get: function () { return e.uniforms.lengthCap }, set: function (r) { e.uniforms.lengthCap = r } }, stepSize: { get: function () { return e.uniforms.stepSize }, set: function (r) { e.uniforms.stepSize = r } }, frustumLength: { get: function () { return e.uniforms.frustumLength }, set: function (r) { e.uniforms.frustumLength = r } }, randomTexture: { get: function () { return e.uniforms.randomTexture }, set: function (r) { e.uniforms.randomTexture = r } }, delta: { get: function () { return t.uniforms.delta }, set: function (r) { t.uniforms.delta = r } }, sigma: { get: function () { return t.uniforms.sigma }, set: function (r) { t.uniforms.sigma = r } }, blurStepSize: { get: function () { return t.uniforms.stepSize }, set: function (r) { t.uniforms.stepSize = r } }, ambientOcclusionOnly: { get: function () { return i.uniforms.ambientOcclusionOnly }, set: function (r) { i.uniforms.ambientOcclusionOnly = r } } }), new ol({ name: "czm_ambient_occlusion", stages: [n, i], inputPreviousStageTexture: !1, uniforms: o }) }; Tr.isAmbientOcclusionSupported = function (e) { return e.context.depthTexture }; var ilt = `#define FXAA_QUALITY_PRESET 39 
${OU}
${SU}`; Tr.createFXAAStage = function () { return new ho({ name: "czm_FXAA", fragmentShader: ilt, sampleMode: tf.LINEAR }) }; Tr.createAcesTonemappingStage = function (e) {
        let t = e ? `#define AUTO_EXPOSURE
`: ""; return t += mU, new ho({ name: "czm_aces", fragmentShader: t, uniforms: { autoExposure: void 0 } })
    }; Tr.createFilmicTonemappingStage = function (e) {
        let t = e ? `#define AUTO_EXPOSURE
`: ""; return t += bU, new ho({ name: "czm_filmic", fragmentShader: t, uniforms: { autoExposure: void 0 } })
    }; Tr.createReinhardTonemappingStage = function (e) {
        let t = e ? `#define AUTO_EXPOSURE
`: ""; return t += PU, new ho({ name: "czm_reinhard", fragmentShader: t, uniforms: { autoExposure: void 0 } })
    }; Tr.createModifiedReinhardTonemappingStage = function (e) {
        let t = e ? `#define AUTO_EXPOSURE
`: ""; return t += DU, new ho({ name: "czm_modified_reinhard", fragmentShader: t, uniforms: { white: U.WHITE, autoExposure: void 0 } })
    }; Tr.createAutoExposureStage = function () { return new fV }; Tr.createBlackAndWhiteStage = function () { return new ho({ name: "czm_black_and_white", fragmentShader: gU, uniforms: { gradations: 5 } }) }; Tr.createBrightnessStage = function () { return new ho({ name: "czm_brightness", fragmentShader: AU, uniforms: { brightness: .5 } }) }; Tr.createNightVisionStage = function () { return new ho({ name: "czm_night_vision", fragmentShader: vU }) }; Tr.createDepthViewStage = function () { return new ho({ name: "czm_depth_view", fragmentShader: TU }) }; Tr.createLensFlareStage = function () { return new ho({ name: "czm_lens_flare", fragmentShader: wU, uniforms: { dirtTexture: Jt("Assets/Textures/LensFlare/DirtMask.jpg"), starTexture: Jt("Assets/Textures/LensFlare/StarBurst.jpg"), intensity: 2, distortion: 10, ghostDispersal: .4, haloWidth: .4, dirtAmount: .4, earthRadius: ie.WGS84.maximumRadius } }) }; var md = Tr; function gp(e) { this._collection = e, this._framebuffers = [], this._stageNameToFramebuffer = {}, this._width = void 0, this._height = void 0, this._updateDependencies = !1 } function Dv(e) { for (; l(e.length);)e = e.get(e.length - 1); return e.name } function Nj(e, t, n, i, o) { if (!i.enabled || !i._isSupported(t)) return o; let r = n[i.name] = {}; if (l(o)) { let a = e.getStageByName(o); r[Dv(a)] = !0 } let s = i.uniforms; if (l(s)) { let a = Object.getOwnPropertyNames(s), c = a.length; for (let u = 0; u < c; ++u) { let f = s[a[u]]; if (typeof f == "string") { let d = e.getStageByName(f); l(d) && (r[Dv(d)] = !0) } } } return i.name } function wv(e, t, n, i, o) { if (l(i.enabled) && !i.enabled || l(i._isSupported) && !i._isSupported(t)) return o; let r = o, s = !l(i.inputPreviousStageTexture) || i.inputPreviousStageTexture, a = o, c = i.length; for (let d = 0; d < c; ++d) { let p = i.get(d); l(p.length) ? a = wv(e, t, n, p, o) : a = Nj(e, t, n, p, o), s && (o = a) } let u, f; if (s) for (u = 1; u < c; ++u)f = Dv(i.get(u)), l(n[f]) || (n[f] = {}), n[f][r] = !0; else for (u = 1; u < c; ++u) { f = Dv(i.get(u)); let d = n[f]; for (let p = 0; p < u; ++p)d[Dv(i.get(p))] = !0 } return a } function olt(e, t) { let n = {}; if (l(e.ambientOcclusion)) { let i = e.ambientOcclusion, o = e.bloom, r = e._tonemapping, s = e.fxaa, a = wv(e, t, n, i, void 0); a = wv(e, t, n, o, a), a = Nj(e, t, n, r, a), a = wv(e, t, n, e, a), Nj(e, t, n, s, a) } else wv(e, t, n, e, void 0); return n } function rlt(e, t, n) { let o = e._collection.getStageByName(t), r = o._textureScale, s = o._forcePowerOfTwo, a = o._pixelFormat, c = o._pixelDatatype, u = o._clearColor, f, d, p = e._framebuffers, g = p.length; for (f = 0; f < g; ++f) { if (d = p[f], r !== d.textureScale || s !== d.forcePowerOfTwo || a !== d.pixelFormat || c !== d.pixelDatatype || !U.equals(u, d.clearColor)) continue; let m = d.stages, A = m.length, C = !1; for (let x = 0; x < A; ++x)if (n[m[x]]) { C = !0; break } if (!C) break } return l(d) && f < g ? (d.stages.push(t), d) : (d = { textureScale: r, forcePowerOfTwo: s, pixelFormat: a, pixelDatatype: c, clearColor: u, stages: [t], buffer: new si({ pixelFormat: a, pixelDatatype: c }), clear: void 0 }, p.push(d), d) } function slt(e, t) { let n = olt(e._collection, t); for (let i in n) n.hasOwnProperty(i) && (e._stageNameToFramebuffer[i] = rlt(e, i, n[i])) } function Vj(e) { let t = e._framebuffers, n = t.length; for (let i = 0; i < n; ++i)t[i].buffer.destroy() } function alt(e, t) { let n = e._width, i = e._height, o = e._framebuffers, r = o.length; for (let s = 0; s < r; ++s) { let a = o[s], c = a.textureScale, u = Math.ceil(n * c), f = Math.ceil(i * c), d = Math.min(u, f); a.forcePowerOfTwo && (I.isPowerOfTwo(d) || (d = I.nextPowerOfTwo(d)), u = d, f = d), a.buffer.update(t, u, f), a.clear = new ti({ color: a.clearColor, framebuffer: a.buffer.framebuffer }) } } gp.prototype.updateDependencies = function () { this._updateDependencies = !0 }; gp.prototype.update = function (e) { let t = this._collection, n = this._updateDependencies, i = l(t.ambientOcclusion) && t.ambientOcclusion.enabled && t.ambientOcclusion._isSupported(e), o = l(t.bloom) && t.bloom.enabled && t.bloom._isSupported(e), r = l(t._tonemapping) && t._tonemapping.enabled && t._tonemapping._isSupported(e), s = l(t.fxaa) && t.fxaa.enabled && t.fxaa._isSupported(e), a = !l(t._activeStages) || t._activeStages.length > 0 || i || o || r || s; if ((n || !a && this._framebuffers.length > 0) && (Vj(this), this._framebuffers.length = 0, this._stageNameToFramebuffer = {}, this._width = void 0, this._height = void 0), !n && !a) return; this._framebuffers.length === 0 && slt(this, e); let c = e.drawingBufferWidth, u = e.drawingBufferHeight, f = this._width !== c || this._height !== u; !n && !f || (this._width = c, this._height = u, this._updateDependencies = !1, Vj(this), alt(this, e)) }; gp.prototype.clear = function (e) { let t = this._framebuffers; for (let n = 0; n < t.length; ++n)t[n].clear.execute(e) }; gp.prototype.getStageByName = function (e) { return this._collection.getStageByName(e) }; gp.prototype.getOutputTexture = function (e) { return this._collection.getOutputTexture(e) }; gp.prototype.getFramebuffer = function (e) { let t = this._stageNameToFramebuffer[e]; if (!!l(t)) return t.buffer.framebuffer }; gp.prototype.isDestroyed = function () { return !1 }; gp.prototype.destroy = function () { return Vj(this), le(this) }; var GE = gp; var vv = { REINHARD: 0, MODIFIED_REINHARD: 1, FILMIC: 2, ACES: 3, validate: function (e) { return e === vv.REINHARD || e === vv.MODIFIED_REINHARD || e === vv.FILMIC || e === vv.ACES } }, pA = Object.freeze(vv); var kj = []; function xc() { let e = md.createFXAAStage(), t = md.createAmbientOcclusionStage(), n = md.createBloomStage(); this._autoExposureEnabled = !1, this._autoExposure = md.createAutoExposureStage(), this._tonemapping = void 0, this._tonemapper = void 0, this.tonemapper = pA.ACES; let i = this._tonemapping; e.enabled = !1, t.enabled = !1, n.enabled = !1, i.enabled = !1; let o = new GE(this), r = {}, s = kj; for (s.push(e, t, n, i); s.length > 0;) { let c = s.pop(); r[c.name] = c, c._textureCache = o; let u = c.length; if (l(u)) for (let f = 0; f < u; ++f)s.push(c.get(f)) } this._stages = [], this._activeStages = [], this._previousActiveStages = [], this._randomTexture = void 0; let a = this; t.uniforms.randomTexture = function () { return a._randomTexture }, this._ao = t, this._bloom = n, this._fxaa = e, this._aoEnabled = void 0, this._bloomEnabled = void 0, this._tonemappingEnabled = void 0, this._fxaaEnabled = void 0, this._activeStagesChanged = !1, this._stagesRemoved = !1, this._textureCacheDirty = !1, this._stageNames = r, this._textureCache = o } Object.defineProperties(xc.prototype, { ready: { get: function () { let e = !1, t = this._stages, n = t.length; for (let a = n - 1; a >= 0; --a) { let c = t[a]; e = e || c.ready && c.enabled } let i = this._fxaa, o = this._ao, r = this._bloom, s = this._tonemapping; return e = e || i.ready && i.enabled, e = e || o.ready && o.enabled, e = e || r.ready && r.enabled, e = e || s.ready && s.enabled, e } }, fxaa: { get: function () { return this._fxaa } }, ambientOcclusion: { get: function () { return this._ao } }, bloom: { get: function () { return this._bloom } }, length: { get: function () { return Uj(this), this._stages.length } }, outputTexture: { get: function () { let e = this._fxaa; if (e.enabled && e.ready) return this.getOutputTexture(e.name); let t = this._stages, n = t.length; for (let s = n - 1; s >= 0; --s) { let a = t[s]; if (l(a) && a.ready && a.enabled) return this.getOutputTexture(a.name) } let i = this._tonemapping; if (i.enabled && i.ready) return this.getOutputTexture(i.name); let o = this._bloom; if (o.enabled && o.ready) return this.getOutputTexture(o.name); let r = this._ao; if (r.enabled && r.ready) return this.getOutputTexture(r.name) } }, hasSelected: { get: function () { let e = this._stages.slice(); for (; e.length > 0;) { let t = e.pop(); if (!l(t)) continue; if (l(t.selected)) return !0; let n = t.length; if (l(n)) for (let i = 0; i < n; ++i)e.push(t.get(i)) } return !1 } }, tonemapper: { get: function () { return this._tonemapper }, set: function (e) { if (this._tonemapper === e) return; l(this._tonemapping) && (delete this._stageNames[this._tonemapping.name], this._tonemapping.destroy()); let t = this._autoExposureEnabled, n; switch (e) { case pA.REINHARD: n = md.createReinhardTonemappingStage(t); break; case pA.MODIFIED_REINHARD: n = md.createModifiedReinhardTonemappingStage(t); break; case pA.FILMIC: n = md.createFilmicTonemappingStage(t); break; default: n = md.createAcesTonemappingStage(t); break }if (t) { let i = this._autoExposure; n.uniforms.autoExposure = function () { return i.outputTexture } } this._tonemapper = e, this._tonemapping = n, l(this._stageNames) && (this._stageNames[n.name] = n, n._textureCache = this._textureCache), this._textureCacheDirty = !0 } } }); function Uj(e) { if (!e._stagesRemoved) return; e._stagesRemoved = !1; let t = [], n = e._stages, i = n.length; for (let o = 0, r = 0; o < i; ++o) { let s = n[o]; s && (s._index = r++, t.push(s)) } e._stages = t } xc.prototype.add = function (e) { let t = this._stageNames, n = kj; for (n.push(e); n.length > 0;) { let o = n.pop(); t[o.name] = o, o._textureCache = this._textureCache; let r = o.length; if (l(r)) for (let s = 0; s < r; ++s)n.push(o.get(s)) } let i = this._stages; return e._index = i.length, i.push(e), this._textureCacheDirty = !0, e }; xc.prototype.remove = function (e) { if (!this.contains(e)) return !1; let t = this._stageNames, n = kj; for (n.push(e); n.length > 0;) { let i = n.pop(); delete t[i.name]; let o = i.length; if (l(o)) for (let r = 0; r < o; ++r)n.push(i.get(r)) } return this._stages[e._index] = void 0, this._stagesRemoved = !0, this._textureCacheDirty = !0, e._index = void 0, e._textureCache = void 0, e.destroy(), !0 }; xc.prototype.contains = function (e) { return l(e) && l(e._index) && e._textureCache === this._textureCache }; xc.prototype.get = function (e) { return Uj(this), this._stages[e] }; xc.prototype.removeAll = function () { let e = this._stages, t = e.length; for (let n = 0; n < t; ++n)this.remove(e[n]); e.length = 0 }; xc.prototype.getStageByName = function (e) { return this._stageNames[e] }; xc.prototype.update = function (e, t, n) { Uj(this); let i = this._activeStages, o = this._activeStages = this._previousActiveStages; this._previousActiveStages = i; let r = this._stages, s = o.length = r.length, a, c, u = 0; for (a = 0; a < s; ++a)c = r[a], c.ready && c.enabled && c._isSupported(e) && (o[u++] = c); o.length = u; let f = u !== i.length; if (!f) { for (a = 0; a < u; ++a)if (o[a] !== i[a]) { f = !0; break } } let d = this._ao, p = this._bloom, g = this._autoExposure, m = this._tonemapping, A = this._fxaa; m.enabled = n; let C = d.enabled && d._isSupported(e), x = p.enabled && p._isSupported(e), T = m.enabled && m._isSupported(e), b = A.enabled && A._isSupported(e); if ((f || this._textureCacheDirty || C !== this._aoEnabled || x !== this._bloomEnabled || T !== this._tonemappingEnabled || b !== this._fxaaEnabled) && (this._textureCache.updateDependencies(), this._aoEnabled = C, this._bloomEnabled = x, this._tonemappingEnabled = T, this._fxaaEnabled = b, this._textureCacheDirty = !1), l(this._randomTexture) && !C && (this._randomTexture.destroy(), this._randomTexture = void 0), !l(this._randomTexture) && C) { s = 256 * 256 * 3; let S = new Uint8Array(s); for (a = 0; a < s; a += 3)S[a] = Math.floor(Math.random() * 255); this._randomTexture = new Rt({ context: e, pixelFormat: ht.RGB, pixelDatatype: Ye.UNSIGNED_BYTE, source: { arrayBufferView: S, width: 256, height: 256 }, sampler: new dn({ wrapS: In.REPEAT, wrapT: In.REPEAT, minificationFilter: ln.NEAREST, magnificationFilter: Xi.NEAREST }) }) } for (this._textureCache.update(e), A.update(e, t), d.update(e, t), p.update(e, t), m.update(e, t), this._autoExposureEnabled && g.update(e, t), s = r.length, a = 0; a < s; ++a)r[a].update(e, t); for (u = 0, a = 0; a < s; ++a)c = r[a], c.ready && c.enabled && c._isSupported(e) && u++; f = u !== o.length, f && this.update(e, t, n) }; xc.prototype.clear = function (e) { this._textureCache.clear(e), this._autoExposureEnabled && this._autoExposure.clear(e) }; function _A(e) { for (; l(e.length);)e = e.get(e.length - 1); return e.outputTexture } xc.prototype.getOutputTexture = function (e) { let t = this.getStageByName(e); if (!!l(t)) return _A(t) }; function Vh(e, t, n, i, o) { if (l(e.execute)) { e.execute(t, n, i, o); return } let r = e.length, s; if (e.inputPreviousStageTexture) for (Vh(e.get(0), t, n, i, o), s = 1; s < r; ++s)Vh(e.get(s), t, _A(e.get(s - 1)), i, o); else for (s = 0; s < r; ++s)Vh(e.get(s), t, n, i, o) } xc.prototype.execute = function (e, t, n, i) { let o = this._activeStages, r = o.length, s = this._fxaa, a = this._ao, c = this._bloom, u = this._autoExposure, f = this._tonemapping, d = a.enabled && a._isSupported(e), p = c.enabled && c._isSupported(e), g = this._autoExposureEnabled, m = f.enabled && f._isSupported(e), A = s.enabled && s._isSupported(e); if (!A && !d && !p && !m && r === 0) return; let C = t; d && a.ready && (Vh(a, e, C, n, i), C = _A(a)), p && c.ready && (Vh(c, e, C, n, i), C = _A(c)), g && u.ready && Vh(u, e, C, n, i), m && f.ready && (Vh(f, e, C, n, i), C = _A(f)); let x = C; if (r > 0) { Vh(o[0], e, C, n, i); for (let T = 1; T < r; ++T)Vh(o[T], e, _A(o[T - 1]), n, i); x = _A(o[r - 1]) } A && s.ready && Vh(s, e, x, n, i) }; xc.prototype.copy = function (e, t) { if (!l(this._copyColorCommand)) { let n = this; this._copyColorCommand = e.createViewportQuadCommand(Wl, { uniformMap: { colorTexture: function () { return n.outputTexture } }, owner: this }) } this._copyColorCommand.framebuffer = t, this._copyColorCommand.execute(e) }; xc.prototype.isDestroyed = function () { return !1 }; xc.prototype.destroy = function () { return this._fxaa.destroy(), this._ao.destroy(), this._bloom.destroy(), this._autoExposure.destroy(), this._tonemapping.destroy(), this.removeAll(), this._textureCache = this._textureCache && this._textureCache.destroy(), le(this) }; var RU = xc; function jl() { ye.throwInstantiationError() } jl.computeDefaultLevelZeroMaximumGeometricError = function (e) { return e.ellipsoid.maximumRadius * 2 * Math.PI * .25 / (65 * e.getNumberOfXTilesAtLevel(0)) }; Object.defineProperties(jl.prototype, { quadtree: { get: ye.throwInstantiationError, set: ye.throwInstantiationError }, ready: { get: ye.throwInstantiationError }, tilingScheme: { get: ye.throwInstantiationError }, errorEvent: { get: ye.throwInstantiationError } }); jl.prototype.update = ye.throwInstantiationError; jl.prototype.beginUpdate = ye.throwInstantiationError; jl.prototype.endUpdate = ye.throwInstantiationError; jl.prototype.getLevelMaximumGeometricError = ye.throwInstantiationError; jl.prototype.loadTile = ye.throwInstantiationError; jl.prototype.computeTileVisibility = ye.throwInstantiationError; jl.prototype.showTileThisFrame = ye.throwInstantiationError; jl.prototype.computeDistanceToTile = ye.throwInstantiationError; jl.prototype.isDestroyed = ye.throwInstantiationError; jl.prototype.destroy = ye.throwInstantiationError; var dge = jl; function gA(e) { this._scene = e, this._currentTweens = [], this._morphHandler = void 0, this._morphCancelled = !1, this._completeMorph = void 0, this._morphToOrthographic = !1 } gA.prototype.completeMorph = function () { l(this._completeMorph) && this._completeMorph() }; gA.prototype.morphTo2D = function (e, t) { l(this._completeMorph) && this._completeMorph(); let n = this._scene; this._previousMode = n.mode, this._morphToOrthographic = n.camera.frustum instanceof Zt, !(this._previousMode === ee.SCENE2D || this._previousMode === ee.MORPHING) && (this._scene.morphStart.raiseEvent(this, this._previousMode, ee.SCENE2D, !0), n._mode = ee.MORPHING, n.camera._setTransform(F.IDENTITY), this._previousMode === ee.COLUMBUS_VIEW ? Ult(this, e) : Ylt(this, e, t), e === 0 && l(this._completeMorph) && this._completeMorph()) }; var clt = new h, llt = new h, ult = new h, flt = new h, dlt = new h, hlt = new h, mlt = new h, plt = new he, _lt = new F, glt = new mi, ylt = new Zt, Alt = { position: void 0, direction: void 0, up: void 0, position2D: void 0, direction2D: void 0, up2D: void 0, frustum: void 0 }; gA.prototype.morphToColumbusView = function (e, t) { l(this._completeMorph) && this._completeMorph(); let n = this._scene; if (this._previousMode = n.mode, this._previousMode === ee.COLUMBUS_VIEW || this._previousMode === ee.MORPHING) return; this._scene.morphStart.raiseEvent(this, this._previousMode, ee.COLUMBUS_VIEW, !0), n.camera._setTransform(F.IDENTITY); let i = clt, o = llt, r = ult; if (e > 0) i.x = 0, i.y = -1, i.z = 1, i = h.multiplyByScalar(h.normalize(i, i), 5 * t.maximumRadius, i), h.negate(h.normalize(i, o), o), h.cross(h.UNIT_X, o, r); else { let u = n.camera; if (this._previousMode === ee.SCENE2D) h.clone(u.position, i), i.z = u.frustum.right - u.frustum.left, h.negate(h.UNIT_Z, o), h.clone(h.UNIT_Y, r); else { h.clone(u.positionWC, i), h.clone(u.directionWC, o), h.clone(u.upWC, r); let f = t.scaleToGeodeticSurface(i, mlt), d = It.eastNorthUpToFixedFrame(f, t, _lt); F.inverseTransformation(d, d), n.mapProjection.project(t.cartesianToCartographic(i, plt), i), F.multiplyByPointAsVector(d, o, o), F.multiplyByPointAsVector(d, r, r) } } let s; this._morphToOrthographic ? (s = ylt, s.width = n.camera.frustum.right - n.camera.frustum.left, s.aspectRatio = n.drawingBufferWidth / n.drawingBufferHeight) : (s = glt, s.aspectRatio = n.drawingBufferWidth / n.drawingBufferHeight, s.fov = I.toRadians(60)); let a = Alt; a.position = i, a.direction = o, a.up = r, a.frustum = s; let c = Klt(a); Pv(this, c), this._previousMode === ee.SCENE2D ? Xlt(this, e, a, c) : (a.position2D = F.multiplyByPoint(oo.TRANSFORM_2D, i, flt), a.direction2D = F.multiplyByPointAsVector(oo.TRANSFORM_2D, o, dlt), a.up2D = F.multiplyByPointAsVector(oo.TRANSFORM_2D, r, hlt), n._mode = ee.MORPHING, Ege(this, e, a, c)), e === 0 && l(this._completeMorph) && this._completeMorph() }; var Gj = { position: new h, direction: new h, up: new h, frustum: void 0 }, mge = new mi; gA.prototype.morphTo3D = function (e, t) { l(this._completeMorph) && this._completeMorph(); let n = this._scene; if (this._previousMode = n.mode, !(this._previousMode === ee.SCENE3D || this._previousMode === ee.MORPHING)) { if (this._scene.morphStart.raiseEvent(this, this._previousMode, ee.SCENE3D, !0), n._mode = ee.MORPHING, n.camera._setTransform(F.IDENTITY), this._previousMode === ee.SCENE2D) Ilt(this, e, t); else { let i; e > 0 ? (i = Gj, h.fromDegrees(0, 0, 5 * t.maximumRadius, t, i.position), h.negate(i.position, i.direction), h.normalize(i.direction, i.direction), h.clone(h.UNIT_Z, i.up)) : i = pge(this, t); let o, r = n.camera; r.frustum instanceof Zt ? o = r.frustum.clone() : (o = mge, o.aspectRatio = n.drawingBufferWidth / n.drawingBufferHeight, o.fov = I.toRadians(60)), i.frustum = o; let s = Sge(i); Pv(this, s), Hj(this, e, i, s) } e === 0 && l(this._completeMorph) && this._completeMorph() } }; gA.prototype.isDestroyed = function () { return !1 }; gA.prototype.destroy = function () { return MU(this), le(this) }; function Pv(e, t) { if (e._scene.completeMorphOnUserInput) { e._morphHandler = new Xu(e._scene.canvas); let n = function () { e._morphCancelled = !0, e._scene.camera.cancelFlight(), t(e) }; e._completeMorph = n, e._morphHandler.setInputAction(n, pn.LEFT_DOWN), e._morphHandler.setInputAction(n, pn.MIDDLE_DOWN), e._morphHandler.setInputAction(n, pn.RIGHT_DOWN), e._morphHandler.setInputAction(n, pn.WHEEL) } } function MU(e) { let t = e._currentTweens; for (let n = 0; n < t.length; ++n)t[n].cancelTween(); e._currentTweens.length = 0, e._morphHandler = e._morphHandler && e._morphHandler.destroy() } var Clt = new he, xlt = new h, Tlt = new F; function pge(e, t) { let n = e._scene, i = n.camera, o = Gj, r = o.position, s = o.direction, a = o.up, c = n.mapProjection.unproject(i.position, Clt); t.cartographicToCartesian(c, r); let u = t.scaleToGeodeticSurface(r, xlt), f = It.eastNorthUpToFixedFrame(u, t, Tlt); return F.multiplyByPointAsVector(f, i.direction, s), F.multiplyByPointAsVector(f, i.up, a), o } var Elt = new h, blt = new h, Slt = new h, wlt = new h, Dlt = new h, vlt = new h; function Hj(e, t, n, i) { t *= .5; let o = e._scene, r = o.camera, s = h.clone(r.position, Elt), a = h.clone(r.direction, blt), c = h.clone(r.up, Slt), u = F.multiplyByPoint(oo.TRANSFORM_2D_INVERSE, n.position, wlt), f = F.multiplyByPointAsVector(oo.TRANSFORM_2D_INVERSE, n.direction, Dlt), d = F.multiplyByPointAsVector(oo.TRANSFORM_2D_INVERSE, n.up, vlt); function p(m) { nf(s, u, m.time, r.position), nf(a, f, m.time, r.direction), nf(c, d, m.time, r.up), h.cross(r.direction, r.up, r.right), h.normalize(r.right, r.right) } let g = o.tweens.add({ duration: t, easingFunction: Mr.QUARTIC_OUT, startObject: { time: 0 }, stopObject: { time: 1 }, update: p, complete: function () { bge(e, o, 0, 1, t, i) } }); e._currentTweens.push(g) } var Plt = new Zt, _ge = new h, gge = new h, yge = new h, Wj = new h, Age = new h, Cge = new h; function Ilt(e, t, n) { t /= 3; let i = e._scene, o = i.camera, r; t > 0 ? (r = Gj, h.fromDegrees(0, 0, 5 * n.maximumRadius, n, r.position), h.negate(r.position, r.direction), h.normalize(r.direction, r.direction), h.clone(h.UNIT_Z, r.up)) : (o.position.z = o.frustum.right - o.frustum.left, r = pge(e, n)); let s; e._morphToOrthographic ? (s = Plt, s.aspectRatio = i.drawingBufferWidth / i.drawingBufferHeight, s.width = o.frustum.right - o.frustum.left) : (s = mge, s.aspectRatio = i.drawingBufferWidth / i.drawingBufferHeight, s.fov = I.toRadians(60)), r.frustum = s; let a = Sge(r); Pv(e, a); let c; e._morphToOrthographic ? c = function () { Hj(e, t, r, a) } : c = function () { Tge(e, t, r, function () { Hj(e, t, r, a) }) }, t > 0 ? (i._mode = ee.SCENE2D, o.flyTo({ duration: t, destination: h.fromDegrees(0, 0, 5 * n.maximumRadius, n, Wj), complete: function () { i._mode = ee.MORPHING, c() } })) : c() } function nf(e, t, n, i) { return h.lerp(e, t, n, i) } function xge(e, t, n, i, o) { let r = e._scene, s = r.camera; if (s.frustum instanceof Zt) return; let a = s.frustum.fov, c = I.RADIANS_PER_DEGREE * .5, u = n.position.z * Math.tan(a * .5); s.frustum.far = u / Math.tan(c * .5) + 1e7; function f(p) { s.frustum.fov = I.lerp(a, c, p.time); let g = u / Math.tan(s.frustum.fov * .5); i(s, g) } let d = r.tweens.add({ duration: t, easingFunction: Mr.QUARTIC_OUT, startObject: { time: 0 }, stopObject: { time: 1 }, update: f, complete: function () { s.frustum = n.frustum.clone(), o(e) } }); e._currentTweens.push(d) } var Olt = new h, Blt = new h, Rlt = new h, zj = new h, Mlt = new h, Llt = new h, Flt = new wr, Nlt = new En, Vlt = new h, klt = { position: void 0, direction: void 0, up: void 0, frustum: void 0 }; function Ult(e, t) { t *= .5; let n = e._scene, i = n.camera, o = h.clone(i.position, Olt), r = h.clone(i.direction, Blt), s = h.clone(i.up, Rlt), a = h.negate(h.UNIT_Z, Mlt), c = h.clone(h.UNIT_Y, Llt), u = zj; if (t > 0) h.clone(h.ZERO, zj), u.z = 5 * n.mapProjection.ellipsoid.maximumRadius; else { h.clone(o, zj); let C = Nlt; F.multiplyByPoint(oo.TRANSFORM_2D, o, C.origin), F.multiplyByPointAsVector(oo.TRANSFORM_2D, r, C.direction); let x = n.globe; if (l(x)) { let T = x.pickWorldCoordinates(C, n, !0, Vlt); l(T) && (F.multiplyByPoint(oo.TRANSFORM_2D_INVERSE, T, u), u.z += h.distance(o, u)) } } let f = Flt; f.right = u.z * .5, f.left = -f.right, f.top = f.right * (n.drawingBufferHeight / n.drawingBufferWidth), f.bottom = -f.top; let d = klt; d.position = u, d.direction = a, d.up = c, d.frustum = f; let p = wge(d); Pv(e, p); function g(C) { nf(o, u, C.time, i.position), nf(r, a, C.time, i.direction), nf(s, c, C.time, i.up), h.cross(i.direction, i.up, i.right), h.normalize(i.right, i.right), i._adjustOrthographicFrustum(!0) } function m(C, x) { C.position.z = x } let A = n.tweens.add({ duration: t, easingFunction: Mr.QUARTIC_OUT, startObject: { time: 0 }, stopObject: { time: 1 }, update: g, complete: function () { xge(e, t, d, m, p) } }); e._currentTweens.push(A) } var hge = new he, zlt = { position: new h, direction: new h, up: new h, position2D: new h, direction2D: new h, up2D: new h, frustum: new wr }, Hlt = { position: new h, direction: new h, up: new h, frustum: void 0 }, Glt = new h, Wlt = new En, jlt = new F, qlt = new h; function Ylt(e, t, n) { t *= .5; let i = e._scene, o = i.camera, r = zlt; if (t > 0) h.clone(h.ZERO, r.position), r.position.z = 5 * n.maximumRadius, h.negate(h.UNIT_Z, r.direction), h.clone(h.UNIT_Y, r.up); else { n.cartesianToCartographic(o.positionWC, hge), i.mapProjection.project(hge, r.position), h.negate(h.UNIT_Z, r.direction), h.clone(h.UNIT_Y, r.up); let d = Wlt; h.clone(r.position2D, d.origin); let p = h.clone(o.directionWC, d.direction), g = n.scaleToGeodeticSurface(o.positionWC, qlt), m = It.eastNorthUpToFixedFrame(g, n, jlt); F.inverseTransformation(m, m), F.multiplyByPointAsVector(m, p, p), F.multiplyByPointAsVector(oo.TRANSFORM_2D, p, p); let A = i.globe; if (l(A)) { let C = A.pickWorldCoordinates(d, i, !0, Glt); if (l(C)) { let x = h.distance(r.position2D, C); C.x += x, h.clone(C, r.position2D) } } } function s(d, p) { d.position.x = p } F.multiplyByPoint(oo.TRANSFORM_2D, r.position, r.position2D), F.multiplyByPointAsVector(oo.TRANSFORM_2D, r.direction, r.direction2D), F.multiplyByPointAsVector(oo.TRANSFORM_2D, r.up, r.up2D); let a = r.frustum; a.right = r.position.z * .5, a.left = -a.right, a.top = a.right * (i.drawingBufferHeight / i.drawingBufferWidth), a.bottom = -a.top; let c = Hlt; F.multiplyByPoint(oo.TRANSFORM_2D_INVERSE, r.position2D, c.position), h.clone(r.direction, c.direction), h.clone(r.up, c.up), c.frustum = a; let u = wge(c); Pv(e, u); function f() { xge(e, t, r, s, u) } Ege(e, t, r, f) } function Tge(e, t, n, i) { let o = e._scene, r = o.camera, s = r.frustum.right - r.frustum.left; r.frustum = n.frustum.clone(); let a = r.frustum.fov, c = I.RADIANS_PER_DEGREE * .5, u = s * Math.tan(a * .5); r.frustum.far = u / Math.tan(c * .5) + 1e7, r.frustum.fov = c; function f(p) { r.frustum.fov = I.lerp(c, a, p.time), r.position.z = u / Math.tan(r.frustum.fov * .5) } let d = o.tweens.add({ duration: t, easingFunction: Mr.QUARTIC_OUT, startObject: { time: 0 }, stopObject: { time: 1 }, update: f, complete: function () { i(e) } }); e._currentTweens.push(d) } function Xlt(e, t, n, i) { t *= .5; let o = e._scene, r = o.camera, s = h.clone(n.position, Wj), a = h.clone(n.direction, Age), c = h.clone(n.up, Cge); o._mode = ee.MORPHING; function u() { r.frustum = n.frustum.clone(); let f = h.clone(r.position, _ge), d = h.clone(r.direction, gge), p = h.clone(r.up, yge); f.z = s.z; function g(A) { nf(f, s, A.time, r.position), nf(d, a, A.time, r.direction), nf(p, c, A.time, r.up), h.cross(r.direction, r.up, r.right), h.normalize(r.right, r.right) } let m = o.tweens.add({ duration: t, easingFunction: Mr.QUARTIC_OUT, startObject: { time: 0 }, stopObject: { time: 1 }, update: g, complete: function () { i(e) } }); e._currentTweens.push(m) } e._morphToOrthographic ? u() : Tge(e, 0, n, u) } function Ege(e, t, n, i) { let o = e._scene, r = o.camera, s = h.clone(r.position, _ge), a = h.clone(r.direction, gge), c = h.clone(r.up, yge), u = h.clone(n.position2D, Wj), f = h.clone(n.direction2D, Age), d = h.clone(n.up2D, Cge); function p(m) { nf(s, u, m.time, r.position), nf(a, f, m.time, r.direction), nf(c, d, m.time, r.up), h.cross(r.direction, r.up, r.right), h.normalize(r.right, r.right), r._adjustOrthographicFrustum(!0) } let g = o.tweens.add({ duration: t, easingFunction: Mr.QUARTIC_OUT, startObject: { time: 0 }, stopObject: { time: 1 }, update: p, complete: function () { bge(e, o, 1, 0, t, i) } }); e._currentTweens.push(g) } function bge(e, t, n, i, o, r) { let s = { object: t, property: "morphTime", startValue: n, stopValue: i, duration: o, easingFunction: Mr.QUARTIC_OUT }; l(r) && (s.complete = function () { r(e) }); let a = t.tweens.addProperty(s); e._currentTweens.push(a) } function Sge(e) { return function (t) { let n = t._scene; n._mode = ee.SCENE3D, n.morphTime = ee.getMorphTime(ee.SCENE3D), MU(t); let i = n.camera; (t._previousMode !== ee.MORPHING || t._morphCancelled) && (t._morphCancelled = !1, h.clone(e.position, i.position), h.clone(e.direction, i.direction), h.clone(e.up, i.up), h.cross(i.direction, i.up, i.right), h.normalize(i.right, i.right), i.frustum = e.frustum.clone()); let o = i.frustum; n.frameState.useLogDepth && (o.near = .1, o.far = 1e10); let r = l(t._completeMorph); t._completeMorph = void 0, n.camera.update(n.mode), t._scene.morphComplete.raiseEvent(t, t._previousMode, ee.SCENE3D, r) } } function wge(e) { return function (t) { let n = t._scene; n._mode = ee.SCENE2D, n.morphTime = ee.getMorphTime(ee.SCENE2D), MU(t); let i = n.camera; h.clone(e.position, i.position), i.position.z = n.mapProjection.ellipsoid.maximumRadius * 2, h.clone(e.direction, i.direction), h.clone(e.up, i.up), h.cross(i.direction, i.up, i.right), h.normalize(i.right, i.right), i.frustum = e.frustum.clone(); let o = l(t._completeMorph); t._completeMorph = void 0, n.camera.update(n.mode), t._scene.morphComplete.raiseEvent(t, t._previousMode, ee.SCENE2D, o) } } function Klt(e) { return function (t) { let n = t._scene; n._mode = ee.COLUMBUS_VIEW, n.morphTime = ee.getMorphTime(ee.COLUMBUS_VIEW), MU(t); let i = n.camera; (t._previousModeMode !== ee.MORPHING || t._morphCancelled) && (t._morphCancelled = !1, h.clone(e.position, i.position), h.clone(e.direction, i.direction), h.clone(e.up, i.up), h.cross(i.direction, i.up, i.right), h.normalize(i.right, i.right)); let o = i.frustum; n.frameState.useLogDepth && (o.near = .1, o.far = 1e10); let r = l(t._completeMorph); t._completeMorph = void 0, n.camera.update(n.mode), t._scene.morphComplete.raiseEvent(t, t._previousMode, ee.COLUMBUS_VIEW, r) } } var LU = gA; function FU(e, t, n, i, o, r, s, a, c, u) { this._tweens = e, this._tweenjs = t, this._startObject = tt(n), this._stopObject = tt(i), this._duration = o, this._delay = r, this._easingFunction = s, this._update = a, this._complete = c, this.cancel = u, this.needsStart = !0 } Object.defineProperties(FU.prototype, { startObject: { get: function () { return this._startObject } }, stopObject: { get: function () { return this._stopObject } }, duration: { get: function () { return this._duration } }, delay: { get: function () { return this._delay } }, easingFunction: { get: function () { return this._easingFunction } }, update: { get: function () { return this._update } }, complete: { get: function () { return this._complete } }, tweenjs: { get: function () { return this._tweenjs } } }); FU.prototype.cancelTween = function () { this._tweens.remove(this) }; function pd() { this._tweens = [] } Object.defineProperties(pd.prototype, { length: { get: function () { return this._tweens.length } } }); pd.prototype.add = function (e) { if (e = y(e, y.EMPTY_OBJECT), e.duration === 0) return l(e.complete) && e.complete(), new FU(this); let t = e.duration / jn.SECONDS_PER_MILLISECOND, n = y(e.delay, 0), i = n / jn.SECONDS_PER_MILLISECOND, o = y(e.easingFunction, Mr.LINEAR_NONE), r = e.startObject, s = new tfe(r); s.to(tt(e.stopObject), t), s.delay(i), s.easing(o), l(e.update) && s.onUpdate(function () { e.update(r) }), s.onComplete(y(e.complete, null)), s.repeat(y(e._repeat, 0)); let a = new FU(this, s, e.startObject, e.stopObject, e.duration, n, o, e.update, e.complete, e.cancel); return this._tweens.push(a), a }; pd.prototype.addProperty = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.object, n = e.property, i = e.startValue, o = e.stopValue; function r(s) { t[n] = s.value } return this.add({ startObject: { value: i }, stopObject: { value: o }, duration: y(e.duration, 3), delay: e.delay, easingFunction: e.easingFunction, update: r, complete: e.complete, cancel: e.cancel, _repeat: e._repeat }) }; pd.prototype.addAlpha = function (e) { e = y(e, y.EMPTY_OBJECT); let t = e.material, n = []; for (let o in t.uniforms) t.uniforms.hasOwnProperty(o) && l(t.uniforms[o]) && l(t.uniforms[o].alpha) && n.push(o); function i(o) { let r = n.length; for (let s = 0; s < r; ++s)t.uniforms[n[s]].alpha = o.alpha } return this.add({ startObject: { alpha: y(e.startValue, 0) }, stopObject: { alpha: y(e.stopValue, 1) }, duration: y(e.duration, 3), delay: e.delay, easingFunction: e.easingFunction, update: i, complete: e.complete, cancel: e.cancel }) }; pd.prototype.addOffsetIncrement = function (e) { e = y(e, y.EMPTY_OBJECT); let n = e.material.uniforms; return this.addProperty({ object: n, property: "offset", startValue: n.offset, stopValue: n.offset + 1, duration: e.duration, delay: e.delay, easingFunction: e.easingFunction, update: e.update, cancel: e.cancel, _repeat: 1 / 0 }) }; pd.prototype.remove = function (e) { if (!l(e)) return !1; let t = this._tweens.indexOf(e); return t !== -1 ? (e.tweenjs.stop(), l(e.cancel) && e.cancel(), this._tweens.splice(t, 1), !0) : !1 }; pd.prototype.removeAll = function () { let e = this._tweens; for (let t = 0; t < e.length; ++t) { let n = e[t]; n.tweenjs.stop(), l(n.cancel) && n.cancel() } e.length = 0 }; pd.prototype.contains = function (e) { return l(e) && this._tweens.indexOf(e) !== -1 }; pd.prototype.get = function (e) { return this._tweens[e] }; pd.prototype.update = function (e) { let t = this._tweens, n = 0; for (e = l(e) ? e / jn.SECONDS_PER_MILLISECOND : Ei(); n < t.length;) { let i = t[n], o = i.tweenjs; i.needsStart ? (i.needsStart = !1, o.start(e)) : o.update(e) ? n++ : (o.stop(), t.splice(n, 1)) } }; var WE = pd; function Ov(e) { this.enableInputs = !0, this.enableTranslate = !0, this.enableZoom = !0, this.enableRotate = !0, this.enableTilt = !0, this.enableLook = !0, this.inertiaSpin = .9, this.inertiaTranslate = .9, this.inertiaZoom = .8, this.maximumMovementRatio = .1, this.bounceAnimationTime = 3, this.minimumZoomDistance = 1, this.maximumZoomDistance = Number.POSITIVE_INFINITY, this.translateEventTypes = wi.LEFT_DRAG, this.zoomEventTypes = [wi.RIGHT_DRAG, wi.WHEEL, wi.PINCH], this.rotateEventTypes = wi.LEFT_DRAG, this.tiltEventTypes = [wi.MIDDLE_DRAG, wi.PINCH, { eventType: wi.LEFT_DRAG, modifier: oa.CTRL }, { eventType: wi.RIGHT_DRAG, modifier: oa.CTRL }], this.lookEventTypes = { eventType: wi.LEFT_DRAG, modifier: oa.SHIFT }, this.minimumPickingTerrainHeight = 15e4, this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight, this.minimumCollisionTerrainHeight = 15e3, this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight, this.minimumTrackBallHeight = 75e5, this._minimumTrackBallHeight = this.minimumTrackBallHeight, this.enableCollisionDetection = !0, this._scene = e, this._globe = void 0, this._ellipsoid = void 0, this._aggregator = new SV(e.canvas), this._lastInertiaSpinMovement = void 0, this._lastInertiaZoomMovement = void 0, this._lastInertiaTranslateMovement = void 0, this._lastInertiaTiltMovement = void 0, this._inertiaDisablers = { _lastInertiaZoomMovement: ["_lastInertiaSpinMovement", "_lastInertiaTranslateMovement", "_lastInertiaTiltMovement"], _lastInertiaTiltMovement: ["_lastInertiaSpinMovement", "_lastInertiaTranslateMovement"] }, this._tweens = new WE, this._tween = void 0, this._horizontalRotationAxis = void 0, this._tiltCenterMousePosition = new H(-1, -1), this._tiltCenter = new h, this._rotateMousePosition = new H(-1, -1), this._rotateStartPosition = new h, this._strafeStartPosition = new h, this._strafeMousePosition = new H, this._strafeEndMousePosition = new H, this._zoomMouseStart = new H(-1, -1), this._zoomWorldPosition = new h, this._useZoomWorldPosition = !1, this._tiltCVOffMap = !1, this._looking = !1, this._rotating = !1, this._strafing = !1, this._zoomingOnVector = !1, this._zoomingUnderground = !1, this._rotatingZoom = !1, this._adjustedHeightForTerrain = !1, this._cameraUnderground = !1; let t = e.mapProjection; this._maxCoord = t.project(new he(Math.PI, I.PI_OVER_TWO)), this._zoomFactor = 5, this._rotateFactor = void 0, this._rotateRateRangeAdjustment = void 0, this._maximumRotateRate = 1.77, this._minimumRotateRate = 1 / 5e3, this._minimumZoomRate = 20, this._maximumZoomRate = 5906376272e3, this._minimumUndergroundPickDistance = 2e3, this._maximumUndergroundPickDistance = 1e4 } function Jlt(e, t) { if (e < 0) return 0; let n = (1 - t) * 25; return Math.exp(-n * e) } function Zlt(e) { return H.equalsEpsilon(e.startPosition, e.endPosition, I.EPSILON14) } var Qlt = .4; function $lt(e, t, n, i, o, r, s) { let a = r[s]; l(a) || (a = r[s] = { startPosition: new H, endPosition: new H, motion: new H, inertiaEnabled: !0 }); let c = e.getButtonPressTime(t, n), u = e.getButtonReleaseTime(t, n), f = c && u && (u.getTime() - c.getTime()) / 1e3, d = new Date, p = u && (d.getTime() - u.getTime()) / 1e3; if (c && u && f < Qlt) { let g = Jlt(p, i), m = e.getLastMovement(t, n); if (!l(m) || Zlt(m) || !a.inertiaEnabled || (a.motion.x = (m.endPosition.x - m.startPosition.x) * .5, a.motion.y = (m.endPosition.y - m.startPosition.y) * .5, a.startPosition = H.clone(m.startPosition, a.startPosition), a.endPosition = H.multiplyByScalar(a.motion, g, a.endPosition), a.endPosition = H.add(a.startPosition, a.endPosition, a.endPosition), isNaN(a.endPosition.x) || isNaN(a.endPosition.y) || H.distance(a.startPosition, a.endPosition) < .5)) return; if (!e.isButtonDown(t, n)) { let A = e.getStartMousePosition(t, n); o(r, A, a) } } } function eut(e, t) { if (l(t)) { let n = e[t]; l(n) && (n.inertiaEnabled = !0); let i = e._inertiaDisablers[t]; if (l(i)) { let o = i.length; for (let r = 0; r < o; ++r)n = e[i[r]], l(n) && (n.inertiaEnabled = !1) } } } var Dge = []; function Tc(e, t, n, i, o, r) { if (!l(n)) return; let s = e._aggregator; Array.isArray(n) || (Dge[0] = n, n = Dge); let a = n.length; for (let c = 0; c < a; ++c) { let u = n[c], f = l(u.eventType) ? u.eventType : u, d = u.modifier, p = s.isMoving(f, d) && s.getMovement(f, d), g = s.getStartMousePosition(f, d); e.enableInputs && t && (p ? (i(e, g, p), eut(e, r)) : o < 1 && $lt(s, f, d, o, i, e, r)) } } var NU = new En, tut = new h, nut = new H, iut = new h, out = new H, rut = new h, sut = new h, aut = new h, cut = new h, lut = new h, uut = new h, fut = new h, dut = new h, hut = new h, mut = new h, put = new h, _ut = new h, gut = new h, yut = new h, Aut = new h, yA = new h, vge = new h, Pge = new h, jj = { orientation: new lf }; function $j(e, t, n, i, o, r) { let s = 1; l(r) && (s = I.clamp(Math.abs(r), .25, 1)); let a = n.endPosition.y - n.startPosition.y, u = a > 0 ? e.minimumZoomDistance * s : 0, f = e.maximumZoomDistance, d = o - u, p = i * d; p = I.clamp(p, e._minimumZoomRate, e._maximumZoomRate); let g = a / e._scene.canvas.clientHeight; g = Math.min(g, e.maximumMovementRatio); let m = p * g; if (e.enableCollisionDetection || e.minimumZoomDistance === 0 || !l(e._globe)) { if (m > 0 && Math.abs(o - u) < 1 || m < 0 && Math.abs(o - f) < 1) return; o - m < u ? m = o - u - 1 : o - m > f && (m = o - f) } let A = e._scene, C = A.camera, x = A.mode, T = jj.orientation; if (T.heading = C.heading, T.pitch = C.pitch, T.roll = C.roll, C.frustum instanceof Zt) { Math.abs(m) > 0 && (C.zoomIn(m), C._adjustOrthographicFrustum()); return } let b = H.equals(t, e._zoomMouseStart), S = e._zoomingOnVector, D = e._rotatingZoom, P; if (b || (e._zoomMouseStart = H.clone(t, e._zoomMouseStart), l(e._globe) && (x === ee.SCENE2D ? (P = C.getPickRay(t, NU).origin, P = h.fromElements(P.y, P.z, P.x)) : P = Kg(e, t, tut)), l(P) ? (e._useZoomWorldPosition = !0, e._zoomWorldPosition = h.clone(P, e._zoomWorldPosition)) : e._useZoomWorldPosition = !1, S = e._zoomingOnVector = !1, D = e._rotatingZoom = !1, e._zoomingUnderground = e._cameraUnderground), !e._useZoomWorldPosition) { C.zoomIn(m); return } let B = x === ee.COLUMBUS_VIEW; if (C.positionCartographic.height < 2e6 && (D = !0), !b || D) { if (x === ee.SCENE2D) { let R = e._zoomWorldPosition, M = C.position; if (!h.equals(R, M) && C.positionCartographic.height < e._maxCoord.x * 2) { let L = C.position.x, _ = h.subtract(R, M, iut); h.normalize(_, _); let E = h.distance(R, M) * m / (C.getMagnitude() * .5); C.move(_, E * .5), (C.position.x < 0 && L > 0 || C.position.x > 0 && L < 0) && (P = C.getPickRay(t, NU).origin, P = h.fromElements(P.y, P.z, P.x), e._zoomWorldPosition = h.clone(P, e._zoomWorldPosition)) } } else if (x === ee.SCENE3D) { let R = h.normalize(C.position, lut); if (e._cameraUnderground || e._zoomingUnderground || C.positionCartographic.height < 3e3 && Math.abs(h.dot(C.direction, R)) < .6) B = !0; else { let M = A.canvas, L = out; L.x = M.clientWidth / 2, L.y = M.clientHeight / 2; let _ = Kg(e, L, rut); if (!l(_)) B = !0; else if (C.positionCartographic.height < 1e6) if (h.dot(C.direction, R) >= -.5) B = !0; else { let E = fut; h.clone(C.position, E); let w = e._zoomWorldPosition, v = uut; if (v = h.normalize(w, v), h.dot(v, R) < 0) return; let O = Aut, V = mut; h.clone(C.direction, V), h.add(E, h.multiplyByScalar(V, 1e3, yA), O); let z = put, k = _ut; h.subtract(w, E, z), h.normalize(z, k); let G = h.dot(R, k); if (G >= 0) { e._zoomMouseStart.x = -1; return } let N = Math.acos(-G), X = h.magnitude(E), q = h.magnitude(w), J = X - m, W = h.magnitude(z), K = Math.asin(I.clamp(W / q * Math.sin(N), -1, 1)), Z = Math.asin(I.clamp(J / q * Math.sin(N), -1, 1)), de = K - Z + N, pe = dut; h.normalize(E, pe); let oe = hut; oe = h.cross(k, pe, oe), oe = h.normalize(oe, oe), h.normalize(h.cross(pe, oe, yA), V), h.multiplyByScalar(h.normalize(O, yA), h.magnitude(O) - m, O), h.normalize(E, E), h.multiplyByScalar(E, J, E); let ue = gut; h.multiplyByScalar(h.add(h.multiplyByScalar(pe, Math.cos(de) - 1, vge), h.multiplyByScalar(V, Math.sin(de), Pge), yA), J, ue), h.add(E, ue, E), h.normalize(O, pe), h.normalize(h.cross(pe, oe, yA), V); let ge = yut; h.multiplyByScalar(h.add(h.multiplyByScalar(pe, Math.cos(de) - 1, vge), h.multiplyByScalar(V, Math.sin(de), Pge), yA), h.magnitude(O), ge), h.add(O, ge, O), h.clone(E, C.position), h.normalize(h.subtract(O, E, yA), C.direction), h.clone(C.direction, C.direction), h.cross(C.direction, C.up, C.right), h.cross(C.right, C.direction, C.up), C.setView(jj); return } else { let E = h.normalize(_, sut), w = h.normalize(e._zoomWorldPosition, aut), v = h.dot(w, E); if (v > 0 && v < 1) { let O = I.acosClamped(v), V = h.cross(w, E, cut), z = Math.abs(O) > I.toRadians(20) ? C.positionCartographic.height * .75 : C.positionCartographic.height - m, k = m / z; C.rotate(V, O * k) } } } } e._rotatingZoom = !B } if (!b && B || S) { let R, M = ji.wgs84ToWindowCoordinates(A, e._zoomWorldPosition, nut); x !== ee.COLUMBUS_VIEW && H.equals(t, e._zoomMouseStart) && l(M) ? R = C.getPickRay(M, NU) : R = C.getPickRay(t, NU); let L = R.direction; (x === ee.COLUMBUS_VIEW || x === ee.SCENE2D) && h.fromElements(L.y, L.z, L.x, L), C.move(L, m), e._zoomingOnVector = !0 } else C.zoomIn(m); e._cameraUnderground || C.setView(jj) } var Cut = new En, xut = new En, Tut = new h; function Eut(e, t, n) { let o = e._scene.camera, r = o.getPickRay(n.startPosition, Cut).origin, s = o.getPickRay(n.endPosition, xut).origin; r = h.fromElements(r.y, r.z, r.x, r), s = h.fromElements(s.y, s.z, s.x, s); let a = h.subtract(r, s, Tut), c = h.magnitude(a); c > 0 && (h.normalize(a, a), o.move(a, c)) } function Ige(e, t, n) { l(n.distance) && (n = n.distance); let o = e._scene.camera; $j(e, t, n, e._zoomFactor, o.getMagnitude()) } var but = new H, Sut = new H; function Oge(e, t, n) { if (l(n.angleAndHeight)) { wut(e, t, n.angleAndHeight); return } let i = e._scene, o = i.camera, r = i.canvas, s = r.clientWidth, a = r.clientHeight, c = but; c.x = 2 / s * n.startPosition.x - 1, c.y = 2 / a * (a - n.startPosition.y) - 1, c = H.normalize(c, c); let u = Sut; u.x = 2 / s * n.endPosition.x - 1, u.y = 2 / a * (a - n.endPosition.y) - 1, u = H.normalize(u, u); let f = I.acosClamped(c.x); c.y < 0 && (f = I.TWO_PI - f); let d = I.acosClamped(u.x); u.y < 0 && (d = I.TWO_PI - d); let p = d - f; o.twistRight(p) } function wut(e, t, n) { let i = e._rotateFactor * e._rotateRateRangeAdjustment; i > e._maximumRotateRate && (i = e._maximumRotateRate), i < e._minimumRotateRate && (i = e._minimumRotateRate); let o = e._scene, r = o.camera, s = o.canvas, a = (n.endPosition.x - n.startPosition.x) / s.clientWidth; a = Math.min(a, e.maximumMovementRatio); let c = i * a * Math.PI * 4; r.twistRight(c) } function Dut(e) { let t = e._scene.mapMode2D === Ul.ROTATE; F.equals(F.IDENTITY, e._scene.camera.transform) ? (Tc(e, e.enableTranslate, e.translateEventTypes, Eut, e.inertiaTranslate, "_lastInertiaTranslateMovement"), Tc(e, e.enableZoom, e.zoomEventTypes, Ige, e.inertiaZoom, "_lastInertiaZoomMovement"), t && Tc(e, e.enableRotate, e.tiltEventTypes, Oge, e.inertiaSpin, "_lastInertiaTiltMovement")) : (Tc(e, e.enableZoom, e.zoomEventTypes, Ige, e.inertiaZoom, "_lastInertiaZoomMovement"), t && Tc(e, e.enableRotate, e.translateEventTypes, Oge, e.inertiaSpin, "_lastInertiaSpinMovement")) } var Fge = new En, vut = new h, Put = new h; function Kg(e, t, n) { let i = e._scene, o = e._globe, r = i.camera; if (!l(o)) return; let s = !e._cameraUnderground, a; i.pickPositionSupported && (a = i.pickPositionWorldCoordinates(t, vut)); let c = r.getPickRay(t, Fge), u = o.pickWorldCoordinates(c, i, s, Put), f = l(a) ? h.distance(a, r.positionWC) : Number.POSITIVE_INFINITY, d = l(u) ? h.distance(u, r.positionWC) : Number.POSITIVE_INFINITY; return f < d ? h.clone(a, n) : h.clone(u, n) } var Iut = new he; function GU(e) { let t = e._ellipsoid, n = e._scene, i = n.camera, o = n.mode, r = 0; if (o === ee.SCENE3D) { let c = t.cartesianToCartographic(i.position, Iut); l(c) && (r = c.height) } else r = i.position.z; let s = y(e._scene.globeHeight, 0); return Math.abs(s - r) } var Out = new h; function Nge(e, t) { let n = t.origin, i = t.direction, o = GU(e), r = h.normalize(n, Out), s = Math.abs(h.dot(r, i)); return s = Math.max(s, .5) * 2, o * s } function Vge(e, t, n, i) { let o = h.distance(t.origin, n), r = GU(e), s = I.clamp(r * 5, e._minimumUndergroundPickDistance, e._maximumUndergroundPickDistance); return o > s && (o = Math.min(o, r / 5), o = Math.max(o, 100)), En.getPoint(t, o, i) } function kge(e, t, n, i) { let o; return l(n) ? (o = h.distance(t.origin, n), o > e._maximumUndergroundPickDistance && (o = GU(e))) : o = GU(e), En.getPoint(t, o, i) } var But = new H; function Uge(e, t) { let n = t.endPosition, i = H.subtract(t.endPosition, t.startPosition, But), o = e._strafeEndMousePosition; H.add(o, i, o), t.endPosition = o, eq(e, t, e._strafeStartPosition), t.endPosition = n } var Bge = new En, Rut = new En, qj = new h, Mut = new h, Lut = new h, Fut = new h, Nut = new nn(h.UNIT_X, 0), Vut = new H, kut = new H; function Uut(e, t, n) { if (h.equals(t, e._translateMousePosition) || (e._looking = !1), h.equals(t, e._strafeMousePosition) || (e._strafing = !1), e._looking) { Yl(e, t, n); return } if (e._strafing) { Uge(e, n); return } let o = e._scene.camera, r = e._cameraUnderground, s = H.clone(n.startPosition, Vut), a = H.clone(n.endPosition, kut), c = o.getPickRay(s, Bge), u = h.clone(h.ZERO, Fut), f = h.UNIT_X, d; if (o.position.z < e._minimumPickingTerrainHeight && (d = Kg(e, s, qj), l(d) && (u.x = d.x)), r || u.x > o.position.z && l(d)) { let b = d; r && (b = kge(e, c, d, qj)), H.clone(t, e._strafeMousePosition), H.clone(t, e._strafeEndMousePosition), h.clone(b, e._strafeStartPosition), e._strafing = !0, eq(e, n, e._strafeStartPosition); return } let p = nn.fromPointNormal(u, f, Nut); c = o.getPickRay(s, Bge); let g = Gi.rayPlane(c, p, qj), m = o.getPickRay(a, Rut), A = Gi.rayPlane(m, p, Mut); if (!l(g) || !l(A)) { e._looking = !0, Yl(e, t, n), H.clone(t, e._translateMousePosition); return } let C = h.subtract(g, A, Lut), x = C.x; C.x = C.y, C.y = C.z, C.z = x; let T = h.magnitude(C); T > I.EPSILON6 && (h.normalize(C, C), o.move(C, T)) } var zge = new H, kU = new En, UU = new h, zut = new h, Hge = new F, Hut = new F, Gut = new h, Wut = new nn(h.UNIT_X, 0), Yj = new h, Jj = new he, Gge = new F, jut = new Be, qut = new Q, zU = new h; function Yut(e, t, n) { if (l(n.angleAndHeight) && (n = n.angleAndHeight), H.equals(t, e._tiltCenterMousePosition) || (e._tiltCVOffMap = !1, e._looking = !1), e._looking) { Yl(e, t, n); return } let o = e._scene.camera; e._tiltCVOffMap || !e.onMap() || Math.abs(o.position.z) > e._minimumPickingTerrainHeight ? (e._tiltCVOffMap = !0, Xut(e, t, n)) : Kut(e, t, n) } function Xut(e, t, n) { let i = e._scene, o = i.camera, r = i.canvas, s = zge; s.x = r.clientWidth / 2, s.y = r.clientHeight / 2; let a = o.getPickRay(s, kU), c = h.UNIT_X, u = a.origin, f = a.direction, d, p = h.dot(c, f); if (Math.abs(p) > I.EPSILON6 && (d = -h.dot(c, u) / p), !l(d) || d <= 0) { e._looking = !0, Yl(e, t, n), H.clone(t, e._tiltCenterMousePosition); return } let g = h.multiplyByScalar(f, d, UU); h.add(u, g, g); let m = i.mapProjection, A = m.ellipsoid; h.fromElements(g.y, g.z, g.x, g); let C = m.unproject(g, Jj); A.cartographicToCartesian(C, g); let x = It.eastNorthUpToFixedFrame(g, A, Hge), T = e._globe, b = e._ellipsoid; e._globe = void 0, e._ellipsoid = ie.UNIT_SPHERE, e._rotateFactor = 1, e._rotateRateRangeAdjustment = 1; let S = F.clone(o.transform, Gge); o._setTransform(x), ql(e, t, n, h.UNIT_Z), o._setTransform(S), e._globe = T, e._ellipsoid = b; let D = b.maximumRadius; e._rotateFactor = 1 / D, e._rotateRateRangeAdjustment = D } function Kut(e, t, n) { let i = e._scene, o = i.camera, r = e._cameraUnderground, s, a, c = h.UNIT_X; if (H.equals(t, e._tiltCenterMousePosition)) s = h.clone(e._tiltCenter, UU); else { if (o.position.z < e._minimumPickingTerrainHeight && (s = Kg(e, t, UU)), !l(s)) { a = o.getPickRay(t, kU); let _ = a.origin, E = a.direction, w, v = h.dot(c, E); if (Math.abs(v) > I.EPSILON6 && (w = -h.dot(c, _) / v), !l(w) || w <= 0) { e._looking = !0, Yl(e, t, n), H.clone(t, e._tiltCenterMousePosition); return } s = h.multiplyByScalar(E, w, UU), h.add(_, s, s) } r && (l(a) || (a = o.getPickRay(t, kU)), Vge(e, a, s, s)), H.clone(t, e._tiltCenterMousePosition), h.clone(s, e._tiltCenter) } let u = i.canvas, f = zge; f.x = u.clientWidth / 2, f.y = e._tiltCenterMousePosition.y, a = o.getPickRay(f, kU); let d = h.clone(h.ZERO, Gut); d.x = s.x; let p = nn.fromPointNormal(d, c, Wut), g = Gi.rayPlane(a, p, zut), m = o._projection, A = m.ellipsoid; h.fromElements(s.y, s.z, s.x, s); let C = m.unproject(s, Jj); A.cartographicToCartesian(C, s); let x = It.eastNorthUpToFixedFrame(s, A, Hge), T; l(g) ? (h.fromElements(g.y, g.z, g.x, g), C = m.unproject(g, Jj), A.cartographicToCartesian(C, g), T = It.eastNorthUpToFixedFrame(g, A, Hut)) : T = x; let b = e._globe, S = e._ellipsoid; e._globe = void 0, e._ellipsoid = ie.UNIT_SPHERE, e._rotateFactor = 1, e._rotateRateRangeAdjustment = 1; let D = h.UNIT_Z, P = F.clone(o.transform, Gge); o._setTransform(x); let B = h.cross(h.UNIT_Z, h.normalize(o.position, Yj), Yj), R = h.dot(o.right, B); if (ql(e, t, n, D, !1, !0), o._setTransform(T), R < 0) { let _ = n.startPosition.y - n.endPosition.y; (r && _ < 0 || !r && _ > 0) && (D = void 0); let E = o.constrainedAxis; o.constrainedAxis = void 0, ql(e, t, n, D, !0, !1), o.constrainedAxis = E } else ql(e, t, n, D, !0, !1); if (l(o.constrainedAxis)) { let _ = h.cross(o.direction, o.constrainedAxis, zU); h.equalsEpsilon(_, h.ZERO, I.EPSILON6) || (h.dot(_, o.right) < 0 && h.negate(_, _), h.cross(_, o.direction, o.up), h.cross(o.direction, o.up, o.right), h.normalize(o.up, o.up), h.normalize(o.right, o.right)) } o._setTransform(P), e._globe = b, e._ellipsoid = S; let M = S.maximumRadius; e._rotateFactor = 1 / M, e._rotateRateRangeAdjustment = M; let L = h.clone(o.positionWC, Yj); if (e.enableCollisionDetection && iq(e), !h.equals(o.positionWC, L)) { o._setTransform(T), o.worldToCameraCoordinatesPoint(L, L); let _ = h.magnitudeSquared(L); h.magnitudeSquared(o.position) > _ && (h.normalize(o.position, o.position), h.multiplyByScalar(o.position, Math.sqrt(_), o.position)); let E = h.angleBetween(L, o.position), w = h.cross(L, o.position, L); h.normalize(w, w); let v = Be.fromAxisAngle(w, E, jut), O = Q.fromQuaternion(v, qut); Q.multiplyByVector(O, o.direction, o.direction), Q.multiplyByVector(O, o.up, o.up), h.cross(o.direction, o.up, o.right), h.cross(o.right, o.direction, o.up), o._setTransform(P) } } var Wge = new H, jge = new En, qge = new h; function Jut(e, t, n) { l(n.distance) && (n = n.distance); let i = e._scene, o = i.camera, r = i.canvas, s = e._cameraUnderground, a; s ? a = t : (a = Wge, a.x = r.clientWidth / 2, a.y = r.clientHeight / 2); let c = o.getPickRay(a, jge), u = c.origin, f = c.direction, d = o.position.z, p; d < e._minimumPickingTerrainHeight && (p = Kg(e, a, qge)); let g; if (l(p) && (g = h.distance(u, p)), s) { let m = Nge(e, c, d); l(g) ? g = Math.min(g, m) : g = m } if (!l(g)) { let m = h.UNIT_X; g = -h.dot(m, u) / h.dot(m, f) } $j(e, t, n, e._zoomFactor, g) } function Zut(e) { let n = e._scene.camera; if (!F.equals(F.IDENTITY, n.transform)) Tc(e, e.enableRotate, e.rotateEventTypes, ql, e.inertiaSpin, "_lastInertiaSpinMovement"), Tc(e, e.enableZoom, e.zoomEventTypes, Yge, e.inertiaZoom, "_lastInertiaZoomMovement"); else { let i = e._tweens; if (e._aggregator.anyButtonDown && i.removeAll(), Tc(e, e.enableTilt, e.tiltEventTypes, Yut, e.inertiaSpin, "_lastInertiaTiltMovement"), Tc(e, e.enableTranslate, e.translateEventTypes, Uut, e.inertiaTranslate, "_lastInertiaTranslateMovement"), Tc(e, e.enableZoom, e.zoomEventTypes, Jut, e.inertiaZoom, "_lastInertiaZoomMovement"), Tc(e, e.enableLook, e.lookEventTypes, Yl), !e._aggregator.anyButtonDown && !i.contains(e._tween)) { let o = n.createCorrectPositionTween(e.bounceAnimationTime); l(o) && (e._tween = i.add(o)) } i.update() } } var Qut = new En, $ut = new nn(h.UNIT_X, 0), eft = new h, tft = new h, nft = new h; function eq(e, t, n) { let i = e._scene, o = i.camera, r = o.getPickRay(t.endPosition, Qut), s = h.clone(o.direction, tft); i.mode === ee.COLUMBUS_VIEW && h.fromElements(s.z, s.x, s.y, s); let a = nn.fromPointNormal(n, s, $ut), c = Gi.rayPlane(r, a, eft); !l(c) || (s = h.subtract(n, c, s), i.mode === ee.COLUMBUS_VIEW && h.fromElements(s.y, s.z, s.x, s), h.add(o.position, s, o.position)) } var Rge = new h, ift = new he, Zj = new h, Qj = new ie, oft = new h, rft = new h; function sft(e, t, n) { let o = e._scene.camera, r = e._cameraUnderground, s = e._ellipsoid; if (!F.equals(o.transform, F.IDENTITY)) { ql(e, t, n); return } let a, c, u = s.geodeticSurfaceNormal(o.position, oft); if (H.equals(t, e._rotateMousePosition)) { if (e._looking) Yl(e, t, n, u); else if (e._rotating) ql(e, t, n); else if (e._strafing) Uge(e, n); else { if (h.magnitude(o.position) < h.magnitude(e._rotateStartPosition)) return; a = h.magnitude(e._rotateStartPosition), c = Zj, c.x = c.y = c.z = a, s = ie.fromCartesian3(c, Qj), Kj(e, t, n, s) } return } e._looking = !1, e._rotating = !1, e._strafing = !1; let f = s.cartesianToCartographic(o.positionWC, ift).height, d = e._globe; if (l(d) && f < e._minimumPickingTerrainHeight) { let p = Kg(e, n.startPosition, nft); if (l(p)) { let g = !1, m = o.getPickRay(n.startPosition, Fge); if (r) g = !0, kge(e, m, p, p); else { let A = s.geodeticSurfaceNormal(p, rft); Math.abs(h.dot(m.direction, A)) < .05 ? g = !0 : g = h.magnitude(o.position) < h.magnitude(p) } g ? (H.clone(t, e._strafeEndMousePosition), h.clone(p, e._strafeStartPosition), e._strafing = !0, eq(e, n, e._strafeStartPosition)) : (a = h.magnitude(p), c = Zj, c.x = c.y = c.z = a, s = ie.fromCartesian3(c, Qj), Kj(e, t, n, s), h.clone(p, e._rotateStartPosition)) } else e._looking = !0, Yl(e, t, n, u) } else l(o.pickEllipsoid(n.startPosition, e._ellipsoid, Rge)) ? (Kj(e, t, n, e._ellipsoid), h.clone(Rge, e._rotateStartPosition)) : f > e._minimumTrackBallHeight ? (e._rotating = !0, ql(e, t, n)) : (e._looking = !0, Yl(e, t, n, u)); H.clone(t, e._rotateMousePosition) } function ql(e, t, n, i, o, r) { o = y(o, !1), r = y(r, !1); let s = e._scene, a = s.camera, c = s.canvas, u = a.constrainedAxis; l(i) && (a.constrainedAxis = i); let f = h.magnitude(a.position), d = e._rotateFactor * (f - e._rotateRateRangeAdjustment); d > e._maximumRotateRate && (d = e._maximumRotateRate), d < e._minimumRotateRate && (d = e._minimumRotateRate); let p = (n.startPosition.x - n.endPosition.x) / c.clientWidth, g = (n.startPosition.y - n.endPosition.y) / c.clientHeight; p = Math.min(p, e.maximumMovementRatio), g = Math.min(g, e.maximumMovementRatio); let m = d * p * Math.PI * 2, A = d * g * Math.PI; o || a.rotateRight(m), r || a.rotateUp(A), a.constrainedAxis = u } var aft = se.clone(se.UNIT_W), cft = se.clone(se.UNIT_W), VU = new h, Xj = new h, lft = new h, uft = new h, fft = new H, dft = new H; function Kj(e, t, n, i) { let r = e._scene.camera, s = H.clone(n.startPosition, fft), a = H.clone(n.endPosition, dft), c = r.pickEllipsoid(s, i, aft), u = r.pickEllipsoid(a, i, cft); if (!l(c) || !l(u)) { e._rotating = !0, ql(e, t, n); return } if (c = r.worldToCameraCoordinates(c, c), u = r.worldToCameraCoordinates(u, u), l(r.constrainedAxis)) { let f = r.constrainedAxis, d = h.mostOrthogonalAxis(f, VU); h.cross(d, f, d), h.normalize(d, d); let p = h.cross(f, d, Xj), g = h.magnitude(c), m = h.dot(f, c), A = Math.acos(m / g), C = h.multiplyByScalar(f, m, lft); h.subtract(c, C, C), h.normalize(C, C); let x = h.magnitude(u), T = h.dot(f, u), b = Math.acos(T / x), S = h.multiplyByScalar(f, T, uft); h.subtract(u, S, S), h.normalize(S, S); let D = Math.acos(h.dot(C, d)); h.dot(C, p) < 0 && (D = I.TWO_PI - D); let P = Math.acos(h.dot(S, d)); h.dot(S, p) < 0 && (P = I.TWO_PI - P); let B = D - P, R; h.equalsEpsilon(f, r.position, I.EPSILON2) ? R = r.right : R = h.cross(f, r.position, VU); let M = h.cross(f, R, VU), L = h.dot(M, h.subtract(c, f, Xj)), _ = h.dot(M, h.subtract(u, f, Xj)), E; L > 0 && _ > 0 ? E = b - A : L > 0 && _ <= 0 ? h.dot(r.position, f) > 0 ? E = -A - b : E = A + b : E = A - b, r.rotateRight(B), r.rotateUp(E) } else { h.normalize(c, c), h.normalize(u, u); let f = h.dot(c, u), d = h.cross(c, u, VU); if (f < 1 && !h.equalsEpsilon(d, h.ZERO, I.EPSILON14)) { let p = Math.acos(f); r.rotate(d, p) } } } var hft = new h, mft = new he; function Yge(e, t, n) { l(n.distance) && (n = n.distance); let i = e._ellipsoid, o = e._scene, r = o.camera, s = o.canvas, a = e._cameraUnderground, c; a ? c = t : (c = Wge, c.x = s.clientWidth / 2, c.y = s.clientHeight / 2); let u = r.getPickRay(c, jge), f, d = i.cartesianToCartographic(r.position, mft).height; d < e._minimumPickingTerrainHeight && (f = Kg(e, c, qge)); let p; if (l(f) && (p = h.distance(u.origin, f)), a) { let m = Nge(e, u, d); l(p) ? p = Math.min(p, m) : p = m } l(p) || (p = d); let g = h.normalize(r.position, hft); $j(e, t, n, e._zoomFactor, p, h.dot(g, r.direction)) } var Xge = new H, HU = new En, Iv = new h, pft = new h, Kge = new F, _ft = new F, Jge = new F, gft = new Be, yft = new Q, tq = new he, nq = new h; function Aft(e, t, n) { let o = e._scene.camera; if (!F.equals(o.transform, F.IDENTITY)) return; if (l(n.angleAndHeight) && (n = n.angleAndHeight), H.equals(t, e._tiltCenterMousePosition) || (e._tiltOnEllipsoid = !1, e._looking = !1), e._looking) { let a = e._ellipsoid.geodeticSurfaceNormal(o.position, nq); Yl(e, t, n, a); return } let s = e._ellipsoid.cartesianToCartographic(o.position, tq); e._tiltOnEllipsoid || s.height > e._minimumCollisionTerrainHeight ? (e._tiltOnEllipsoid = !0, xft(e, t, n)) : Tft(e, t, n) } var Cft = new he; function xft(e, t, n) { let i = e._ellipsoid, o = e._scene, r = o.camera, s = e.minimumZoomDistance * .25, a = i.cartesianToCartographic(r.positionWC, Cft).height; if (a - s - 1 < I.EPSILON3 && n.endPosition.y - n.startPosition.y < 0) return; let c = o.canvas, u = Xge; u.x = c.clientWidth / 2, u.y = c.clientHeight / 2; let f = r.getPickRay(u, HU), d, p = Gi.rayEllipsoid(f, i); if (l(p)) d = En.getPoint(f, p.start, Iv); else if (a > e._minimumTrackBallHeight) { let T = Gi.grazingAltitudeLocation(f, i); if (!l(T)) return; let b = i.cartesianToCartographic(T, tq); b.height = 0, d = i.cartographicToCartesian(b, Iv) } else { e._looking = !0; let T = e._ellipsoid.geodeticSurfaceNormal(r.position, nq); Yl(e, t, n, T), H.clone(t, e._tiltCenterMousePosition); return } let g = It.eastNorthUpToFixedFrame(d, i, Kge), m = e._globe, A = e._ellipsoid; e._globe = void 0, e._ellipsoid = ie.UNIT_SPHERE, e._rotateFactor = 1, e._rotateRateRangeAdjustment = 1; let C = F.clone(r.transform, Jge); r._setTransform(g), ql(e, t, n, h.UNIT_Z), r._setTransform(C), e._globe = m, e._ellipsoid = A; let x = A.maximumRadius; e._rotateFactor = 1 / x, e._rotateRateRangeAdjustment = x } function Tft(e, t, n) { let i = e._ellipsoid, o = e._scene, r = o.camera, s = e._cameraUnderground, a, c, u; if (H.equals(t, e._tiltCenterMousePosition)) a = h.clone(e._tiltCenter, Iv); else { if (a = Kg(e, t, Iv), !l(a)) { if (c = r.getPickRay(t, HU), u = Gi.rayEllipsoid(c, i), !l(u)) { if (i.cartesianToCartographic(r.position, tq).height <= e._minimumTrackBallHeight) { e._looking = !0; let E = e._ellipsoid.geodeticSurfaceNormal(r.position, nq); Yl(e, t, n, E), H.clone(t, e._tiltCenterMousePosition) } return } a = En.getPoint(c, u.start, Iv) } s && (l(c) || (c = r.getPickRay(t, HU)), Vge(e, c, a, a)), H.clone(t, e._tiltCenterMousePosition), h.clone(a, e._tiltCenter) } let f = o.canvas, d = Xge; d.x = f.clientWidth / 2, d.y = e._tiltCenterMousePosition.y, c = r.getPickRay(d, HU); let p = h.magnitude(a), g = h.fromElements(p, p, p, Zj), m = ie.fromCartesian3(g, Qj); if (u = Gi.rayEllipsoid(c, m), !l(u)) return; let A = h.magnitude(c.origin) > p ? u.start : u.stop, C = En.getPoint(c, A, pft), x = It.eastNorthUpToFixedFrame(a, i, Kge), T = It.eastNorthUpToFixedFrame(C, m, _ft), b = e._globe, S = e._ellipsoid; e._globe = void 0, e._ellipsoid = ie.UNIT_SPHERE, e._rotateFactor = 1, e._rotateRateRangeAdjustment = 1; let D = h.UNIT_Z, P = F.clone(r.transform, Jge); r._setTransform(T); let B = h.cross(C, r.positionWC, zU); if (h.dot(r.rightWC, B) < 0) { let _ = n.startPosition.y - n.endPosition.y; (s && _ < 0 || !s && _ > 0) && (D = void 0); let E = r.constrainedAxis; r.constrainedAxis = void 0, ql(e, t, n, D, !0, !1), r.constrainedAxis = E } else ql(e, t, n, D, !0, !1); if (r._setTransform(x), ql(e, t, n, D, !1, !0), l(r.constrainedAxis)) { let _ = h.cross(r.direction, r.constrainedAxis, zU); h.equalsEpsilon(_, h.ZERO, I.EPSILON6) || (h.dot(_, r.right) < 0 && h.negate(_, _), h.cross(_, r.direction, r.up), h.cross(r.direction, r.up, r.right), h.normalize(r.up, r.up), h.normalize(r.right, r.right)) } r._setTransform(P), e._globe = b, e._ellipsoid = S; let M = S.maximumRadius; e._rotateFactor = 1 / M, e._rotateRateRangeAdjustment = M; let L = h.clone(r.positionWC, zU); if (e.enableCollisionDetection && iq(e), !h.equals(r.positionWC, L)) { r._setTransform(T), r.worldToCameraCoordinatesPoint(L, L); let _ = h.magnitudeSquared(L); h.magnitudeSquared(r.position) > _ && (h.normalize(r.position, r.position), h.multiplyByScalar(r.position, Math.sqrt(_), r.position)); let E = h.angleBetween(L, r.position), w = h.cross(L, r.position, L); h.normalize(w, w); let v = Be.fromAxisAngle(w, E, gft), O = Q.fromQuaternion(v, yft); Q.multiplyByVector(O, r.direction, r.direction), Q.multiplyByVector(O, r.up, r.up), h.cross(r.direction, r.up, r.right), h.cross(r.right, r.direction, r.up), r._setTransform(P) } } var Eft = new H, bft = new H, Mge = new En, Lge = new En, Sft = new h, wft = new h; function Yl(e, t, n, i) { let r = e._scene.camera, s = Eft; s.x = n.startPosition.x, s.y = 0; let a = bft; a.x = n.endPosition.x, a.y = 0; let c = r.getPickRay(s, Mge), u = r.getPickRay(a, Lge), f = 0, d, p; r.frustum instanceof Zt ? (d = c.origin, p = u.origin, h.add(r.direction, d, d), h.add(r.direction, p, p), h.subtract(d, r.position, d), h.subtract(p, r.position, p), h.normalize(d, d), h.normalize(p, p)) : (d = c.direction, p = u.direction); let g = h.dot(d, p); g < 1 && (f = Math.acos(g)), f = n.startPosition.x > n.endPosition.x ? -f : f; let m = e._horizontalRotationAxis; if (l(i) ? r.look(i, -f) : l(m) ? r.look(m, -f) : r.lookLeft(f), s.x = 0, s.y = n.startPosition.y, a.x = 0, a.y = n.endPosition.y, c = r.getPickRay(s, Mge), u = r.getPickRay(a, Lge), f = 0, r.frustum instanceof Zt ? (d = c.origin, p = u.origin, h.add(r.direction, d, d), h.add(r.direction, p, p), h.subtract(d, r.position, d), h.subtract(p, r.position, p), h.normalize(d, d), h.normalize(p, p)) : (d = c.direction, p = u.direction), g = h.dot(d, p), g < 1 && (f = Math.acos(g)), f = n.startPosition.y > n.endPosition.y ? -f : f, i = y(i, m), l(i)) { let A = r.direction, C = h.negate(i, Sft), x = h.equalsEpsilon(A, i, I.EPSILON2), T = h.equalsEpsilon(A, C, I.EPSILON2); if (!x && !T) { g = h.dot(A, i); let b = I.acosClamped(g); f > 0 && f > b && (f = b - I.EPSILON4), g = h.dot(A, C), b = I.acosClamped(g), f < 0 && -f > b && (f = -b + I.EPSILON4); let S = h.cross(i, A, wft); r.look(S, f) } else (x && f < 0 || T && f > 0) && r.look(r.right, -f) } else r.lookUp(f) } function Dft(e) { Tc(e, e.enableRotate, e.rotateEventTypes, sft, e.inertiaSpin, "_lastInertiaSpinMovement"), Tc(e, e.enableZoom, e.zoomEventTypes, Yge, e.inertiaZoom, "_lastInertiaZoomMovement"), Tc(e, e.enableTilt, e.tiltEventTypes, Aft, e.inertiaSpin, "_lastInertiaTiltMovement"), Tc(e, e.enableLook, e.lookEventTypes, Yl) } var vft = new F, Pft = new he; function iq(e) { e._adjustedHeightForTerrain = !0; let t = e._scene, n = t.mode, i = t.globe; if (!l(i) || n === ee.SCENE2D || n === ee.MORPHING) return; let o = t.camera, r = i.ellipsoid, s = t.mapProjection, a, c; F.equals(o.transform, F.IDENTITY) || (a = F.clone(o.transform, vft), c = h.magnitude(o.position), o._setTransform(F.IDENTITY)); let u = Pft; n === ee.SCENE3D ? r.cartesianToCartographic(o.position, u) : s.unproject(o.position, u); let f = !1; if (u.height < e._minimumCollisionTerrainHeight) { let d = e._scene.globeHeight; if (l(d)) { let p = d + e.minimumZoomDistance; u.height < p && (u.height = p, n === ee.SCENE3D ? r.cartographicToCartesian(u, o.position) : s.project(u, o.position), f = !0) } } l(a) && (o._setTransform(a), f && (h.normalize(o.position, o.position), h.negate(o.position, o.direction), h.multiplyByScalar(o.position, Math.max(c, e.minimumZoomDistance), o.position), h.normalize(o.direction, o.direction), h.cross(o.direction, o.up, o.right), h.cross(o.right, o.direction, o.up))) } Ov.prototype.onMap = function () { let e = this._scene, t = e.mode, n = e.camera; return t === ee.COLUMBUS_VIEW ? Math.abs(n.position.x) - this._maxCoord.x < 0 && Math.abs(n.position.y) - this._maxCoord.y < 0 : !0 }; var Ift = new h, Oft = new h; Ov.prototype.update = function () { let e = this._scene, t = e.camera, n = e.globe, i = e.mode; F.equals(t.transform, F.IDENTITY) ? (this._globe = n, this._ellipsoid = l(this._globe) ? this._globe.ellipsoid : e.mapProjection.ellipsoid) : (this._globe = void 0, this._ellipsoid = ie.UNIT_SPHERE); let o = l(this._globe) ? this._globe.terrainExaggeration : 1, r = l(this._globe) ? this._globe.terrainExaggerationRelativeHeight : 0; this._minimumCollisionTerrainHeight = Ic.getHeight(this.minimumCollisionTerrainHeight, o, r), this._minimumPickingTerrainHeight = Ic.getHeight(this.minimumPickingTerrainHeight, o, r), this._minimumTrackBallHeight = Ic.getHeight(this.minimumTrackBallHeight, o, r), this._cameraUnderground = e.cameraUnderground && l(this._globe); let s = this._ellipsoid.maximumRadius; this._rotateFactor = 1 / s, this._rotateRateRangeAdjustment = s, this._adjustedHeightForTerrain = !1; let a = h.clone(t.positionWC, Ift), c = h.clone(t.directionWC, Oft); i === ee.SCENE2D ? Dut(this) : i === ee.COLUMBUS_VIEW ? (this._horizontalRotationAxis = h.UNIT_Z, Zut(this)) : i === ee.SCENE3D && (this._horizontalRotationAxis = void 0, Dft(this)), this.enableCollisionDetection && !this._adjustedHeightForTerrain && (!h.equals(a, t.positionWC) || !h.equals(c, t.directionWC)) && iq(this), this._aggregator.reset() }; Ov.prototype.isDestroyed = function () { return !1 }; Ov.prototype.destroy = function () { return this._tweens.removeAll(), this._aggregator = this._aggregator && this._aggregator.destroy(), le(this) }; var WU = Ov; var jU = `uniform sampler2D colorTexture;
uniform sampler2D colorTexture2;
uniform vec2 center;
uniform float radius;
varying vec2 v_textureCoordinates;
void main()
{
vec4 color0 = texture2D(colorTexture, v_textureCoordinates);
vec4 color1 = texture2D(colorTexture2, v_textureCoordinates);
float x = length(gl_FragCoord.xy - center) / radius;
float t = smoothstep(0.5, 0.8, x);
gl_FragColor = mix(color0 + color1, color1, t);
}
`; var qU = `uniform sampler2D colorTexture;
uniform float avgLuminance;
uniform float threshold;
uniform float offset;
varying vec2 v_textureCoordinates;
float key(float avg)
{
float guess = 1.5 - (1.5 / (avg * 0.1 + 1.0));
return max(0.0, guess) + 0.1;
}
void main()
{
vec4 color = texture2D(colorTexture, v_textureCoordinates);
vec3 xyz = czm_RGBToXYZ(color.rgb);
float luminance = xyz.r;
float scaledLum = key(avgLuminance) * luminance / avgLuminance;
float brightLum = max(scaledLum - threshold, 0.0);
float brightness = brightLum / (offset + brightLum);
xyz.r = brightness;
gl_FragColor = vec4(czm_XYZToRGB(xyz), 1.0);
}
`; function yp() { this._sceneFramebuffer = new VE; let e = .125, t = new Array(6); t[0] = new ho({ fragmentShader: Wl, textureScale: e, forcePowerOfTwo: !0, sampleMode: tf.LINEAR }); let n = t[1] = new ho({ fragmentShader: qU, uniforms: { avgLuminance: .5, threshold: .25, offset: .1 }, textureScale: e, forcePowerOfTwo: !0 }), i = this; this._delta = 1, this._sigma = 2, this._blurStep = new H, t[2] = new ho({ fragmentShader: hA, uniforms: { step: function () { return i._blurStep.x = i._blurStep.y = 1 / n.outputTexture.width, i._blurStep }, delta: function () { return i._delta }, sigma: function () { return i._sigma }, direction: 0 }, textureScale: e, forcePowerOfTwo: !0 }), t[3] = new ho({ fragmentShader: hA, uniforms: { step: function () { return i._blurStep.x = i._blurStep.y = 1 / n.outputTexture.width, i._blurStep }, delta: function () { return i._delta }, sigma: function () { return i._sigma }, direction: 1 }, textureScale: e, forcePowerOfTwo: !0 }), t[4] = new ho({ fragmentShader: Wl, sampleMode: tf.LINEAR }), this._uCenter = new H, this._uRadius = void 0, t[5] = new ho({ fragmentShader: jU, uniforms: { center: function () { return i._uCenter }, radius: function () { return i._uRadius }, colorTexture2: function () { return i._sceneFramebuffer.framebuffer.getColorTexture(0) } } }), this._stages = new ol({ stages: t }); let o = new GE(this), r = t.length; for (let s = 0; s < r; ++s)t[s]._textureCache = o; this._textureCache = o, this.length = t.length } yp.prototype.get = function (e) { return this._stages.get(e) }; yp.prototype.getStageByName = function (e) { let t = this._stages.length; for (let n = 0; n < t; ++n) { let i = this._stages.get(n); if (i.name === e) return i } }; var Bft = new se, Zge = new H, Rft = new H, Qge = new F; function Mft(e, t, n) { let i = t.uniformState, o = i.sunPositionWC, r = i.view, s = i.viewProjection, a = i.projection, c = F.computeViewportTransformation(n, 0, 1, Qge), u = F.multiplyByPoint(r, o, Bft), f = It.pointToGLWindowCoordinates(s, c, o, Zge); u.x += I.SOLAR_RADIUS; let d = It.pointToGLWindowCoordinates(a, c, u, u), p = H.magnitude(H.subtract(d, f, d)) * 30 * 2, g = Rft; g.x = p, g.y = p, e._uCenter = H.clone(f, e._uCenter), e._uRadius = Math.max(g.x, g.y) * .15; let m = t.drawingBufferWidth, A = t.drawingBufferHeight, C = e._stages, x = C.get(0), T = x.outputTexture.width, b = x.outputTexture.height, S = new Ge; S.width = T, S.height = b, c = F.computeViewportTransformation(S, 0, 1, Qge), f = It.pointToGLWindowCoordinates(s, c, o, Zge), g.x *= T / m, g.y *= b / A; let D = x.scissorRectangle; D.x = Math.max(f.x - g.x * .5, 0), D.y = Math.max(f.y - g.y * .5, 0), D.width = Math.min(g.x, m), D.height = Math.min(g.y, A); for (let P = 1; P < 4; ++P)Ge.clone(D, C.get(P).scissorRectangle) } yp.prototype.clear = function (e, t, n) { this._sceneFramebuffer.clear(e, t, n), this._textureCache.clear(e) }; yp.prototype.update = function (e) { let t = e.context, n = e.viewport, i = this._sceneFramebuffer; i.update(t, n); let o = i.framebuffer; return this._textureCache.update(t), this._stages.update(t, !1), Mft(this, t, n), o }; yp.prototype.execute = function (e) { let t = this._sceneFramebuffer.framebuffer.getColorTexture(0), n = this._stages, i = n.length; n.get(0).execute(e, t); for (let o = 1; o < i; ++o)n.get(o).execute(e, n.get(o - 1).outputTexture) }; yp.prototype.copy = function (e, t) { if (!l(this._copyColorCommand)) { let n = this; this._copyColorCommand = e.createViewportQuadCommand(Wl, { uniformMap: { colorTexture: function () { return n._stages.get(n._stages.length - 1).outputTexture } }, owner: this }) } this._copyColorCommand.framebuffer = t, this._copyColorCommand.execute(e) }; yp.prototype.isDestroyed = function () { return !1 }; yp.prototype.destroy = function () { return this._textureCache.destroy(), this._stages.destroy(), le(this) }; var YU = yp; var KU = function (e) { return function () { e.frameState.afterRender.push(function () { e.requestRender() }) } }; function Li(e) { e = y(e, y.EMPTY_OBJECT); let t = e.canvas, n = e.creditContainer, i = e.creditViewport, o = tt(e.contextOptions); l(o) || (o = {}), l(o.webgl) || (o.webgl = {}), o.webgl.powerPreference = y(o.webgl.powerPreference, "high-performance"); let r = l(n), s = new E3(t, o); r || (n = document.createElement("div"), n.style.position = "absolute", n.style.bottom = "0", n.style["text-shadow"] = "0 0 2px #000000", n.style.color = "#ffffff", n.style["font-size"] = "10px", n.style["padding-right"] = "5px", t.parentNode.appendChild(n)), l(i) || (i = t.parentNode), this._id = Nn(), this._jobScheduler = new jk, this._frameState = new uk(s, new qV(n, " \u2022 ", i), this._jobScheduler), this._frameState.scene3DOnly = y(e.scene3DOnly, !1), this._removeCreditContainer = !r, this._creditContainer = n, this._canvas = t, this._context = s, this._computeEngine = new y3(s), this._globe = void 0, this._globeTranslucencyState = new Gk, this._primitives = new wl, this._groundPrimitives = new wl, this._globeHeight = void 0, this._cameraUnderground = !1, this._logDepthBuffer = s.fragmentDepth, this._logDepthBufferDirty = !0, this._tweens = new WE, this._shaderFrameCount = 0, this._sunPostProcess = void 0, this._computeCommandList = [], this._overlayCommandList = [], this._useOIT = y(e.orderIndependentTranslucency, !0), this._executeOITFunction = void 0, this._depthPlane = new ek(e.depthPlaneEllipsoidOffset), this._clearColorCommand = new ti({ color: new U, stencil: 0, owner: this }), this._depthClearCommand = new ti({ depth: 1, owner: this }), this._stencilClearCommand = new ti({ stencil: 0 }), this._classificationStencilClearCommand = new ti({ stencil: 0, renderState: Ve.fromCache({ stencilMask: vt.CLASSIFICATION_MASK }) }), this._depthOnlyRenderStateCache = {}, this._transitioner = new LU(this), this._preUpdate = new _e, this._postUpdate = new _e, this._renderError = new _e, this._preRender = new _e, this._postRender = new _e, this._minimumDisableDepthTestDistance = 0, this._debugInspector = new XV, this._msaaSamples = y(e.msaaSamples, 1), this.rethrowRenderErrors = !1, this.completeMorphOnUserInput = !0, this.morphStart = new _e, this.morphComplete = new _e, this.skyBox = void 0, this.skyAtmosphere = void 0, this.sun = void 0, this.sunBloom = !0, this._sunBloom = void 0, this.moon = void 0, this.backgroundColor = U.clone(U.BLACK), this._mode = ee.SCENE3D, this._mapProjection = l(e.mapProjection) ? e.mapProjection : new _i, this.morphTime = 1, this.farToNearRatio = 1e3, this.logarithmicDepthFarToNearRatio = 1e9, this.nearToFarDistance2D = 175e4, this.debugCommandFilter = void 0, this.debugShowCommands = !1, this.debugShowFrustums = !1, this.debugShowFramesPerSecond = !1, this.debugShowDepthFrustum = 1, this.debugShowFrustumPlanes = !1, this._debugShowFrustumPlanes = !1, this._debugFrustumPlanes = void 0, this.useDepthPicking = !0, this.pickTranslucentDepth = !1, this.cameraEventWaitTime = 500, this.fog = new ck, this._shadowMapCamera = new oo(this), this.shadowMap = new Yg({ context: s, lightCamera: this._shadowMapCamera, enabled: y(e.shadows, !1) }), this.invertClassification = !1, this.invertClassificationColor = U.clone(U.WHITE), this._actualInvertClassificationColor = U.clone(this._invertClassificationColor), this._invertClassification = new pv, this.focalLength = void 0, this.eyeSeparation = void 0, this.postProcessStages = new RU, this._brdfLutGenerator = new _V, this._performanceDisplay = void 0, this._debugVolume = void 0, this._screenSpaceCameraController = new WU(this), this._cameraUnderground = !1, this._mapMode2D = y(e.mapMode2D, Ul.INFINITE_SCROLL), this._environmentState = { skyBoxCommand: void 0, skyAtmosphereCommand: void 0, sunDrawCommand: void 0, sunComputeCommand: void 0, moonCommand: void 0, isSunVisible: !1, isMoonVisible: !1, isReadyForAtmosphere: !1, isSkyAtmosphereVisible: !1, clearGlobeDepth: !1, useDepthPlane: !1, renderTranslucentDepthForPick: !1, originalFramebuffer: void 0, useGlobeDepthFramebuffer: !1, useOIT: !1, useInvertClassification: !1, usePostProcess: !1, usePostProcessSelected: !1, useWebVR: !1 }, this._useWebVR = !1, this._cameraVR = void 0, this._aspectRatioVR = void 0, this.requestRenderMode = y(e.requestRenderMode, !1), this._renderRequested = !0, this.maximumRenderTimeChange = y(e.maximumRenderTimeChange, 0), this._lastRenderTime = void 0, this._frameRateMonitor = void 0, this._removeRequestListenerCallback = Ya.requestCompletedEvent.addEventListener(KU(this)), this._removeTaskProcessorListenerCallback = yi.taskCompletedEvent.addEventListener(KU(this)), this._removeGlobeCallbacks = []; let a = new Ge(0, 0, s.drawingBufferWidth, s.drawingBufferHeight), c = new oo(this); this._logDepthBuffer && (c.frustum.near = .1, c.frustum.far = 1e10), this.preloadFlightCamera = new oo(this), this.preloadFlightCullingVolume = void 0, this._picking = new uU(this), this._defaultView = new UE(this, c, a), this._view = this._defaultView, this._hdr = void 0, this._hdrDirty = void 0, this.highDynamicRange = !1, this.gamma = 2.2, this.sphericalHarmonicCoefficients = void 0, this.specularEnvironmentMaps = void 0, this._specularEnvironmentMapAtlas = void 0, this.light = new Eg, n0e(this, 0, $.now()), this.updateFrameState(), this.initializeFrame() } function Lft(e, t) { for (let i = 0; i < e._removeGlobeCallbacks.length; ++i)e._removeGlobeCallbacks[i](); e._removeGlobeCallbacks.length = 0; let n = []; l(t) && (n.push(t.imageryLayersUpdatedEvent.addEventListener(KU(e))), n.push(t.terrainProviderChanged.addEventListener(KU(e)))), e._removeGlobeCallbacks = n } Object.defineProperties(Li.prototype, { canvas: { get: function () { return this._canvas } }, drawingBufferHeight: { get: function () { return this._context.drawingBufferHeight } }, drawingBufferWidth: { get: function () { return this._context.drawingBufferWidth } }, maximumAliasedLineWidth: { get: function () { return Ut.maximumAliasedLineWidth } }, maximumCubeMapSize: { get: function () { return Ut.maximumCubeMapSize } }, pickPositionSupported: { get: function () { return this._context.depthTexture } }, sampleHeightSupported: { get: function () { return this._context.depthTexture } }, clampToHeightSupported: { get: function () { return this._context.depthTexture } }, invertClassificationSupported: { get: function () { return this._context.depthTexture } }, specularEnvironmentMapsSupported: { get: function () { return Vd.isSupported(this._context) } }, globe: { get: function () { return this._globe }, set: function (e) { this._globe = this._globe && this._globe.destroy(), this._globe = e, Lft(this, e) } }, primitives: { get: function () { return this._primitives } }, groundPrimitives: { get: function () { return this._groundPrimitives } }, camera: { get: function () { return this._view.camera }, set: function (e) { this._view.camera = e } }, view: { get: function () { return this._view }, set: function (e) { this._view = e } }, defaultView: { get: function () { return this._defaultView } }, picking: { get: function () { return this._picking } }, screenSpaceCameraController: { get: function () { return this._screenSpaceCameraController } }, mapProjection: { get: function () { return this._mapProjection } }, jobScheduler: { get: function () { return this._jobScheduler } }, frameState: { get: function () { return this._frameState } }, environmentState: { get: function () { return this._environmentState } }, tweens: { get: function () { return this._tweens } }, imageryLayers: { get: function () { if (!!l(this.globe)) return this.globe.imageryLayers } }, terrainProvider: { get: function () { if (!!l(this.globe)) return this.globe.terrainProvider }, set: function (e) { l(this.globe) && (this.globe.terrainProvider = e) } }, terrainProviderChanged: { get: function () { if (!!l(this.globe)) return this.globe.terrainProviderChanged } }, preUpdate: { get: function () { return this._preUpdate } }, postUpdate: { get: function () { return this._postUpdate } }, renderError: { get: function () { return this._renderError } }, preRender: { get: function () { return this._preRender } }, postRender: { get: function () { return this._postRender } }, lastRenderTime: { get: function () { return this._lastRenderTime } }, context: { get: function () { return this._context } }, debugFrustumStatistics: { get: function () { return this._view.debugFrustumStatistics } }, scene3DOnly: { get: function () { return this._frameState.scene3DOnly } }, orderIndependentTranslucency: { get: function () { return this._useOIT } }, id: { get: function () { return this._id } }, mode: { get: function () { return this._mode }, set: function (e) { e === ee.SCENE2D ? this.morphTo2D(0) : e === ee.SCENE3D ? this.morphTo3D(0) : e === ee.COLUMBUS_VIEW && this.morphToColumbusView(0), this._mode = e } }, frustumCommandsList: { get: function () { return this._view.frustumCommandsList } }, numberOfFrustums: { get: function () { return this._view.frustumCommandsList.length } }, useWebVR: { get: function () { return this._useWebVR }, set: function (e) { this._useWebVR = e, this._useWebVR ? (this._frameState.creditDisplay.container.style.visibility = "hidden", this._cameraVR = new oo(this), l(this._deviceOrientationCameraController) || (this._deviceOrientationCameraController = new nk(this)), this._aspectRatioVR = this.camera.frustum.aspectRatio) : (this._frameState.creditDisplay.container.style.visibility = "visible", this._cameraVR = void 0, this._deviceOrientationCameraController = this._deviceOrientationCameraController && !this._deviceOrientationCameraController.isDestroyed() && this._deviceOrientationCameraController.destroy(), this.camera.frustum.aspectRatio = this._aspectRatioVR, this.camera.frustum.xOffset = 0) } }, mapMode2D: { get: function () { return this._mapMode2D } }, splitPosition: { get: function () { return this._frameState.splitPosition }, set: function (e) { this._frameState.splitPosition = e } }, minimumDisableDepthTestDistance: { get: function () { return this._minimumDisableDepthTestDistance }, set: function (e) { this._minimumDisableDepthTestDistance = e } }, logarithmicDepthBuffer: { get: function () { return this._logDepthBuffer }, set: function (e) { e = this._context.fragmentDepth && e, this._logDepthBuffer !== e && (this._logDepthBuffer = e, this._logDepthBufferDirty = !0) } }, gamma: { get: function () { return this._context.uniformState.gamma }, set: function (e) { this._context.uniformState.gamma = e } }, highDynamicRange: { get: function () { return this._hdr }, set: function (e) { let t = this._context, n = e && t.depthTexture && (t.colorBufferFloat || t.colorBufferHalfFloat); this._hdrDirty = n !== this._hdr, this._hdr = n } }, highDynamicRangeSupported: { get: function () { let e = this._context; return e.depthTexture && (e.colorBufferFloat || e.colorBufferHalfFloat) } }, cameraUnderground: { get: function () { return this._cameraUnderground } }, msaaSamples: { get: function () { return this._msaaSamples }, set: function (e) { e = Math.min(e, Ut.maximumSamples), this._msaaSamples = e } }, msaaSupported: { get: function () { return this._context.msaa } }, pixelRatio: { get: function () { return this._frameState.pixelRatio }, set: function (e) { this._frameState.pixelRatio = e } }, opaqueFrustumNearOffset: { get: function () { return .9999 } }, globeHeight: { get: function () { return this._globeHeight } } }); Li.prototype.getCompressedTextureFormatSupported = function (e) { let t = this.context; return (e === "WEBGL_compressed_texture_s3tc" || e === "s3tc") && t.s3tc || (e === "WEBGL_compressed_texture_pvrtc" || e === "pvrtc") && t.pvrtc || (e === "WEBGL_compressed_texture_etc" || e === "etc") && t.etc || (e === "WEBGL_compressed_texture_etc1" || e === "etc1") && t.etc1 || (e === "WEBGL_compressed_texture_astc" || e === "astc") && t.astc || (e === "EXT_texture_compression_bptc" || e === "bc7") && t.bc7 }; function $ge(e, t, n) { let i = e._frameState, o = e._context, r = e._view.oit, s = i.shadowState.lightShadowMaps, a = i.shadowState.lightShadowsEnabled, c = t.derivedCommands; l(t.pickId) && (c.picking = zg.createPickDerivedCommand(e, t, o, c.picking)), t.pickOnly || (c.depth = zg.createDepthOnlyDerivedCommand(e, t, o, c.depth)), c.originalCommand = t, e._hdr && (c.hdr = zg.createHdrCommand(t, o, c.hdr), t = c.hdr.command, c = t.derivedCommands), a && t.receiveShadows && (c.shadows = Yg.createReceiveDerivedCommand(s, t, n, o, c.shadows)), t.pass === xe.TRANSLUCENT && l(r) && r.isSupported() && (a && t.receiveShadows ? (c.oit = l(c.oit) ? c.oit : {}, c.oit.shadows = r.createDerivedCommands(c.shadows.receiveCommand, o, c.oit.shadows)) : c.oit = r.createDerivedCommands(t, o, c.oit)) } Li.prototype.updateDerivedCommands = function (e) { if (!l(e.derivedCommands)) return; let t = this._frameState, n = this._context, i = !1, o = t.shadowState.lastDirtyTime; e.lastDirtyTime !== o && (e.lastDirtyTime = o, e.dirty = !0, i = !0); let r = t.useLogDepth, s = this._hdr, a = e.derivedCommands, c = l(a.logDepth), u = l(a.hdr), f = l(a.originalCommand), d = r && !c, p = s && !u, g = (!r || !s) && !f; if (e.dirty = e.dirty || d || p || g, e.dirty) { e.dirty = !1; let m = t.shadowState.shadowMaps; t.shadowState.shadowsEnabled && e.castShadows && (a.shadows = Yg.createCastDerivedCommand(m, e, i, n, a.shadows)), (c || d) && (a.logDepth = zg.createLogDepthCommand(e, n, a.logDepth), $ge(this, a.logDepth.command, i)), (f || g) && $ge(this, e, i) } }; var Fft = new ad({ pass: Qo.RENDER }), oq = new ad({ pass: Qo.PRELOAD }), rq = new ad({ pass: Qo.PRELOAD_FLIGHT }), Nft = new ad({ pass: Qo.REQUEST_RENDER_MODE_DEFER_CHECK }), e0e = new re, sq; function Vft(e) { let t = e.globe; if (e._mode === ee.SCENE3D && l(t) && t.show && !e._cameraUnderground && !e._globeTranslucencyState.translucent) { let n = t.ellipsoid, i = e.frameState.minimumTerrainHeight; return e0e.radius = n.minimumRadius + i, sq = nV.fromBoundingSphere(e0e, e.camera.positionWC, sq), sq } } Li.prototype.clearPasses = function (e) { e.render = !1, e.pick = !1, e.depth = !1, e.postProcess = !1, e.offscreen = !1 }; function n0e(e, t, n) { let i = e._frameState; i.frameNumber = t, i.time = $.clone(n, i.time) } Li.prototype.updateFrameState = function () { let e = this.camera, t = this._frameState; t.commandList.length = 0, t.shadowMaps.length = 0, t.brdfLutGenerator = this._brdfLutGenerator, t.environmentMap = this.skyBox && this.skyBox._cubeMap, t.mode = this._mode, t.morphTime = this.morphTime, t.mapProjection = this.mapProjection, t.camera = e, t.cullingVolume = e.frustum.computeCullingVolume(e.positionWC, e.directionWC, e.upWC), t.occluder = Vft(this), t.minimumTerrainHeight = 0, t.minimumDisableDepthTestDistance = this._minimumDisableDepthTestDistance, t.invertClassification = this.invertClassification, t.useLogDepth = this._logDepthBuffer && !(this.camera.frustum instanceof Zt || this.camera.frustum instanceof wr), t.light = this.light, t.cameraUnderground = this._cameraUnderground, t.globeTranslucencyState = this._globeTranslucencyState, l(this.globe) && (t.terrainExaggeration = this.globe.terrainExaggeration, t.terrainExaggerationRelativeHeight = this.globe.terrainExaggerationRelativeHeight), l(this._specularEnvironmentMapAtlas) && this._specularEnvironmentMapAtlas.ready ? (t.specularEnvironmentMaps = this._specularEnvironmentMapAtlas.texture, t.specularEnvironmentMapsMaximumLOD = this._specularEnvironmentMapAtlas.maximumMipmapLevel) : (t.specularEnvironmentMaps = void 0, t.specularEnvironmentMapsMaximumLOD = void 0), t.sphericalHarmonicCoefficients = this.sphericalHarmonicCoefficients, this._actualInvertClassificationColor = U.clone(this.invertClassificationColor, this._actualInvertClassificationColor), pv.isTranslucencySupported(this._context) || (this._actualInvertClassificationColor.alpha = 1), t.invertClassificationColor = this._actualInvertClassificationColor, l(this.globe) ? t.maximumScreenSpaceError = this.globe.maximumScreenSpaceError : t.maximumScreenSpaceError = 2, this.clearPasses(t.passes), t.tilesetPassState = void 0 }; Li.prototype.isVisible = function (e, t, n) { return l(e) && (!l(e.boundingVolume) || !e.cull || t.computeVisibility(e.boundingVolume) !== Kt.OUTSIDE && (!l(n) || !e.occlude || !e.boundingVolume.isOccluded(n))) }; var XU = new F(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1); XU = F.inverseTransformation(XU, XU); function kft(e, t, n, i) { let o = t._frameState, r = o.context, s = e.boundingVolume; l(t._debugVolume) && t._debugVolume.destroy(); let a, c = h.clone(s.center); if (o.mode !== ee.SCENE3D) { c = F.multiplyByPoint(XU, c, c); let p = o.mapProjection, g = p.unproject(c); c = p.ellipsoid.cartographicToCartesian(g) } if (l(s.radius)) { let p = s.radius; a = Bn.toWireframe(Bs.createGeometry(new Bs({ radii: new h(p, p, p), vertexFormat: $t.FLAT_VERTEX_FORMAT }))), t._debugVolume = new xn({ geometryInstances: new At({ geometry: a, modelMatrix: F.fromTranslation(c), attributes: { color: new Bt(1, 0, 0, 1) } }), appearance: new $t({ flat: !0, translucent: !1 }), asynchronous: !1 }) } else { let p = s.halfAxes; a = Bn.toWireframe(ll.createGeometry(ll.fromDimensions({ dimensions: new h(2, 2, 2), vertexFormat: $t.FLAT_VERTEX_FORMAT }))), t._debugVolume = new xn({ geometryInstances: new At({ geometry: a, modelMatrix: F.fromRotationTranslation(p, c, new F), attributes: { color: new Bt(1, 0, 0, 1) } }), appearance: new $t({ flat: !0, translucent: !1 }), asynchronous: !1 }) } let u = o.commandList, f = o.commandList = []; t._debugVolume.update(o), e = f[0], o.useLogDepth && (e = zg.createLogDepthCommand(e, r).command); let d; l(i) && (d = n.framebuffer, n.framebuffer = i), e.execute(r, n), l(d) && (n.framebuffer = d), o.commandList = u } function Ha(e, t, n, i, o) { let r = t._frameState; if (l(t.debugCommandFilter) && !t.debugCommandFilter(e)) return; if (e instanceof ti) { e.execute(n, i); return } e.debugShowBoundingVolume && l(e.boundingVolume) && kft(e, t, i, o), r.useLogDepth && l(e.derivedCommands.logDepth) && (e = e.derivedCommands.logDepth.command); let s = r.passes; if (!s.pick && !s.depth && t._hdr && l(e.derivedCommands) && l(e.derivedCommands.hdr) && (e = e.derivedCommands.hdr.command), s.pick || s.depth) { if (s.pick && !s.depth && l(e.derivedCommands.picking)) { e = e.derivedCommands.picking.pickCommand, e.execute(n, i); return } else if (l(e.derivedCommands.depth)) { e = e.derivedCommands.depth.depthOnlyCommand, e.execute(n, i); return } } if (t.debugShowCommands || t.debugShowFrustums) { t._debugInspector.executeDebugShowFrustumsCommand(t, e, i); return } r.shadowState.lightShadowsEnabled && e.receiveShadows && l(e.derivedCommands.shadows) ? e.derivedCommands.shadows.receiveCommand.execute(n, i) : e.execute(n, i) } function Bv(e, t, n, i) { let o = t._frameState, r = e.derivedCommands; !l(r) || (o.useLogDepth && l(r.logDepth) && (e = r.logDepth.command), r = e.derivedCommands, l(r.picking) ? (e = r.picking.pickCommand, e.execute(n, i)) : l(r.depth) && (e = r.depth.depthOnlyCommand, e.execute(n, i))) } function Uft(e, t, n) { return t.boundingVolume.distanceSquaredTo(n) - e.boundingVolume.distanceSquaredTo(n) } function zft(e, t, n) { return e.boundingVolume.distanceSquaredTo(n) - t.boundingVolume.distanceSquaredTo(n) + I.EPSILON12 } function Hft(e, t, n, i, o) { let r = e.context; Xy(i, Uft, e.camera.positionWC), l(o) && t(o.unclassifiedCommand, e, r, n); let s = i.length; for (let a = 0; a < s; ++a)t(i[a], e, r, n) } function Gft(e, t, n, i, o) { let r = e.context; Xy(i, zft, e.camera.positionWC), l(o) && t(o.unclassifiedCommand, e, r, n); let s = i.length; for (let a = 0; a < s; ++a)t(i[a], e, r, n) } var Wft = new mi, jft = new $c, qft = new Zt, Yft = new wr; function aq(e, t) { let n = e.camera, i = e.context, o = e.frameState, r = i.uniformState; r.updateCamera(n); let s; l(n.frustum.fov) ? s = n.frustum.clone(Wft) : l(n.frustum.infiniteProjectionMatrix) ? s = n.frustum.clone(jft) : l(n.frustum.width) ? s = n.frustum.clone(qft) : s = n.frustum.clone(Yft), s.near = n.frustum.near, s.far = n.frustum.far, r.updateFrustum(s), r.updatePass(xe.ENVIRONMENT); let a = o.passes, c = a.pick, u = e._environmentState, f = e._view, d = u.renderTranslucentDepthForPick, p = u.useWebVR; if (!c) { let E = u.skyBoxCommand; if (l(E) && Ha(E, e, i, t), u.isSkyAtmosphereVisible && Ha(u.skyAtmosphereCommand, e, i, t), u.isSunVisible && (u.sunDrawCommand.execute(i, t), e.sunBloom && !p)) { let w; u.useGlobeDepthFramebuffer ? w = f.globeDepth.framebuffer : u.usePostProcess ? w = f.sceneFramebuffer.framebuffer : w = u.originalFramebuffer, e._sunPostProcess.execute(i), e._sunPostProcess.copy(i, w), t.framebuffer = w } u.isMoonVisible && u.moonCommand.execute(i, t) } let g; u.useOIT ? (l(e._executeOITFunction) || (e._executeOITFunction = function (E, w, v, O, V) { f.globeDepth.prepareColorTextures(i), f.oit.executeCommands(E, w, v, O, V) }), g = e._executeOITFunction) : a.render ? g = Hft : g = Gft; let m = f.frustumCommandsList, A = m.length, C = u.clearGlobeDepth, x = u.useDepthPlane, T = e._globeTranslucencyState, b = T.translucent, S = e._view.globeTranslucencyFramebuffer, D = e._depthClearCommand, P = e._stencilClearCommand, B = e._classificationStencilClearCommand, R = e._depthPlane, M = u.usePostProcessSelected, L = n.position.z, _; for (let E = 0; E < A; ++E) { let w = A - E - 1, v = m[w]; e.mode === ee.SCENE2D ? (n.position.z = L - v.near + 1, s.far = Math.max(1, v.far - v.near), s.near = 1, r.update(o), r.updateFrustum(s)) : (s.near = w !== 0 ? v.near * e.opaqueFrustumNearOffset : v.near, s.far = v.far, r.updateFrustum(s)), D.execute(i, t), i.stencilBuffer && P.execute(i, t), r.updatePass(xe.GLOBE); let O = v.commands[xe.GLOBE], V = v.indices[xe.GLOBE]; if (b) T.executeGlobeCommands(v, Ha, S, e, t); else for (_ = 0; _ < V; ++_)Ha(O[_], e, i, t); let z = f.globeDepth; if (l(z) && u.useGlobeDepthFramebuffer && z.executeCopyDepth(i, t), !u.renderTranslucentDepthForPick) if (r.updatePass(xe.TERRAIN_CLASSIFICATION), O = v.commands[xe.TERRAIN_CLASSIFICATION], V = v.indices[xe.TERRAIN_CLASSIFICATION], b) T.executeGlobeClassificationCommands(v, Ha, S, e, t); else for (_ = 0; _ < V; ++_)Ha(O[_], e, i, t); if (C && (D.execute(i, t), x && R.execute(i, t)), !u.useInvertClassification || c || u.renderTranslucentDepthForPick) { for (r.updatePass(xe.CESIUM_3D_TILE), O = v.commands[xe.CESIUM_3D_TILE], V = v.indices[xe.CESIUM_3D_TILE], _ = 0; _ < V; ++_)Ha(O[_], e, i, t); if (V > 0 && (l(z) && u.useGlobeDepthFramebuffer && (z.prepareColorTextures(i, C), z.executeUpdateDepth(i, t, C, z.depthStencilTexture)), !u.renderTranslucentDepthForPick)) for (r.updatePass(xe.CESIUM_3D_TILE_CLASSIFICATION), O = v.commands[xe.CESIUM_3D_TILE_CLASSIFICATION], V = v.indices[xe.CESIUM_3D_TILE_CLASSIFICATION], _ = 0; _ < V; ++_)Ha(O[_], e, i, t) } else { e._invertClassification.clear(i, t); let X = t.framebuffer; for (t.framebuffer = e._invertClassification._fbo.framebuffer, r.updatePass(xe.CESIUM_3D_TILE), O = v.commands[xe.CESIUM_3D_TILE], V = v.indices[xe.CESIUM_3D_TILE], _ = 0; _ < V; ++_)Ha(O[_], e, i, t); for (l(z) && u.useGlobeDepthFramebuffer && (e._invertClassification.prepareTextures(i), z.executeUpdateDepth(i, t, C, e._invertClassification._fbo.getDepthStencilTexture())), r.updatePass(xe.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW), O = v.commands[xe.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW], V = v.indices[xe.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW], _ = 0; _ < V; ++_)Ha(O[_], e, i, t); for (t.framebuffer = X, e._invertClassification.executeClassified(i, t), o.invertClassificationColor.alpha === 1 && e._invertClassification.executeUnclassified(i, t), V > 0 && i.stencilBuffer && B.execute(i, t), r.updatePass(xe.CESIUM_3D_TILE_CLASSIFICATION), O = v.commands[xe.CESIUM_3D_TILE_CLASSIFICATION], V = v.indices[xe.CESIUM_3D_TILE_CLASSIFICATION], _ = 0; _ < V; ++_)Ha(O[_], e, i, t) } for (V > 0 && i.stencilBuffer && P.execute(i, t), r.updatePass(xe.OPAQUE), O = v.commands[xe.OPAQUE], V = v.indices[xe.OPAQUE], _ = 0; _ < V; ++_)Ha(O[_], e, i, t); w !== 0 && e.mode !== ee.SCENE2D && (s.near = v.near, r.updateFrustum(s)); let k; if (!c && u.useInvertClassification && o.invertClassificationColor.alpha < 1 && (k = e._invertClassification), r.updatePass(xe.TRANSLUCENT), O = v.commands[xe.TRANSLUCENT], O.length = v.indices[xe.TRANSLUCENT], g(e, Ha, t, O, k), v.indices[xe.CESIUM_3D_TILE_CLASSIFICATION] > 0 && f.translucentTileClassification.isSupported() && (f.translucentTileClassification.executeTranslucentCommands(e, Ha, t, O, z.depthStencilTexture), f.translucentTileClassification.executeClassificationCommands(e, Ha, t, v)), i.depthTexture && e.useDepthPicking && (u.useGlobeDepthFramebuffer || d)) { let X = z.depthStencilTexture, q = e._picking.getPickDepth(e, w); q.update(i, X), q.executeCopyDepth(i, t) } if (c || !M) continue; let N = t.framebuffer; if (t.framebuffer = f.sceneFramebuffer.getIdFramebuffer(), s.near = w !== 0 ? v.near * e.opaqueFrustumNearOffset : v.near, s.far = v.far, r.updateFrustum(s), r.updatePass(xe.GLOBE), O = v.commands[xe.GLOBE], V = v.indices[xe.GLOBE], b) T.executeGlobeCommands(v, Bv, S, e, t); else for (_ = 0; _ < V; ++_)Bv(O[_], e, i, t); for (C && (D.framebuffer = t.framebuffer, D.execute(i, t), D.framebuffer = void 0), C && x && R.execute(i, t), r.updatePass(xe.CESIUM_3D_TILE), O = v.commands[xe.CESIUM_3D_TILE], V = v.indices[xe.CESIUM_3D_TILE], _ = 0; _ < V; ++_)Bv(O[_], e, i, t); for (r.updatePass(xe.OPAQUE), O = v.commands[xe.OPAQUE], V = v.indices[xe.OPAQUE], _ = 0; _ < V; ++_)Bv(O[_], e, i, t); for (r.updatePass(xe.TRANSLUCENT), O = v.commands[xe.TRANSLUCENT], V = v.indices[xe.TRANSLUCENT], _ = 0; _ < V; ++_)Bv(O[_], e, i, t); t.framebuffer = N } } function i0e(e) { e.context.uniformState.updatePass(xe.COMPUTE); let n = e._environmentState.sunComputeCommand; l(n) && n.execute(e._computeEngine); let i = e._computeCommandList, o = i.length; for (let r = 0; r < o; ++r)i[r].execute(e._computeEngine) } function Xft(e, t) { e.context.uniformState.updatePass(xe.OVERLAY); let i = e.context, o = e._overlayCommandList, r = o.length; for (let s = 0; s < r; ++s)o[s].execute(i, t) } function Kft(e, t, n) { let i = n.shadowMapCullingVolume, o = n.isPointLight, r = n.passes, s = r.length, a = t.length; for (let c = 0; c < a; ++c) { let u = t[c]; if (e.updateDerivedCommands(u), u.castShadows && (u.pass === xe.GLOBE || u.pass === xe.CESIUM_3D_TILE || u.pass === xe.OPAQUE || u.pass === xe.TRANSLUCENT) && e.isVisible(u, i)) if (o) for (let f = 0; f < s; ++f)r[f].commandList.push(u); else if (s === 1) r[0].commandList.push(u); else { let f = !1; for (let d = s - 1; d >= 0; --d) { let p = r[d].cullingVolume; if (e.isVisible(u, p)) r[d].commandList.push(u), f = !0; else if (f) break } } } } function o0e(e) { let t = e.frameState, n = t.shadowState.shadowMaps, i = n.length; if (!t.shadowState.shadowsEnabled) return; let o = e.context, r = o.uniformState; for (let s = 0; s < i; ++s) { let a = n[s]; if (a.outOfView) continue; let c = a.passes, u = c.length; for (let d = 0; d < u; ++d)c[d].commandList.length = 0; let f = e.frameState.commandList; Kft(e, f, a); for (let d = 0; d < u; ++d) { let p = a.passes[d]; r.updateCamera(p.camera), a.updatePass(o, d); let g = p.commandList.length; for (let m = 0; m < g; ++m) { let A = p.commandList[m]; r.updatePass(A.pass), Ha(A.derivedCommands.shadows.castCommands[s], e, o, p.passState) } } } } var Jft = new h; Li.prototype.updateAndExecuteCommands = function (e, t) { let i = this._frameState.mode; this._environmentState.useWebVR ? Zft(this, e, t) : i !== ee.SCENE2D || this._mapMode2D === Ul.ROTATE ? Jg(!0, this, e, t) : (cq(this, e, t), sdt(this, e)) }; function Zft(e, t, n) { let i = e._view, o = i.camera, s = e._environmentState.renderTranslucentDepthForPick; cq(e, t, n), r0e(e), i.createPotentiallyVisibleSet(e), i0e(e), s || o0e(e); let a = t.viewport; a.x = 0, a.y = 0, a.width = a.width * .5; let c = oo.clone(o, e._cameraVR); c.frustum = o.frustum; let u = o.frustum.near, f = u * y(e.focalLength, 5), d = y(e.eyeSeparation, f / 30), p = h.multiplyByScalar(c.right, d * .5, Jft); o.frustum.aspectRatio = a.width / a.height; let g = .5 * d * u / f; h.add(c.position, p, o.position), o.frustum.xOffset = g, aq(e, t), a.x = a.width, h.subtract(c.position, p, o.position), o.frustum.xOffset = -g, aq(e, t), oo.clone(c, o) } var Qft = new he(Math.PI, I.PI_OVER_TWO), $ft = new h, edt = new h, tdt = new F, ndt = new F, idt = new h, odt = new h, rdt = new Ge; function sdt(e, t) { let n = e.context, i = e.frameState, o = e.camera, r = t.viewport, s = Ge.clone(r, rdt); t.viewport = s; let a = Qft, c = $ft; e.mapProjection.project(a, c); let f = h.clone(o.position, edt), d = F.clone(o.transform, ndt), p = o.frustum.clone(); o._setTransform(F.IDENTITY); let g = F.computeViewportTransformation(s, 0, 1, tdt), m = o.frustum.projectionMatrix, A = o.positionWC.y, C = h.fromElements(I.sign(A) * c.x - A, 0, -o.positionWC.x, idt), x = It.pointToGLWindowCoordinates(m, g, C, odt); x.x = Math.floor(x.x); let T = s.x, b = s.width; if (A === 0 || x.x <= T || x.x >= T + b) Jg(!0, e, t); else if (Math.abs(T + b * .5 - x.x) < 1) s.width = x.x - s.x, o.position.x *= I.sign(o.position.x), o.frustum.right = 0, i.cullingVolume = o.frustum.computeCullingVolume(o.positionWC, o.directionWC, o.upWC), n.uniformState.update(i), Jg(!0, e, t), s.x = x.x, o.position.x = -o.position.x, o.frustum.right = -o.frustum.left, o.frustum.left = 0, i.cullingVolume = o.frustum.computeCullingVolume(o.positionWC, o.directionWC, o.upWC), n.uniformState.update(i), Jg(!1, e, t); else if (x.x > T + b * .5) { s.width = x.x - T; let S = o.frustum.right; o.frustum.right = c.x - A, i.cullingVolume = o.frustum.computeCullingVolume(o.positionWC, o.directionWC, o.upWC), n.uniformState.update(i), Jg(!0, e, t), s.x = x.x, s.width = T + b - x.x, o.position.x = -o.position.x, o.frustum.left = -o.frustum.right, o.frustum.right = S - o.frustum.right * 2, i.cullingVolume = o.frustum.computeCullingVolume(o.positionWC, o.directionWC, o.upWC), n.uniformState.update(i), Jg(!1, e, t) } else { s.x = x.x, s.width = T + b - x.x; let S = o.frustum.left; o.frustum.left = -c.x - A, i.cullingVolume = o.frustum.computeCullingVolume(o.positionWC, o.directionWC, o.upWC), n.uniformState.update(i), Jg(!0, e, t), s.x = T, s.width = x.x - T, o.position.x = -o.position.x, o.frustum.right = -o.frustum.left, o.frustum.left = S - o.frustum.left * 2, i.cullingVolume = o.frustum.computeCullingVolume(o.positionWC, o.directionWC, o.upWC), n.uniformState.update(i), Jg(!1, e, t) } o._setTransform(d), h.clone(f, o.position), o.frustum = p.clone(), t.viewport = r } function Jg(e, t, n, i) { let o = t._environmentState, r = t._view, s = o.renderTranslucentDepthForPick; e || (t.frameState.commandList.length = 0), r0e(t), r.createPotentiallyVisibleSet(t), e && (l(i) && cq(t, n, i), i0e(t), s || o0e(t)), aq(t, n) } var t0e = new Xs; Li.prototype.updateEnvironment = function () { let e = this._frameState, t = this._view, n = this._environmentState, i = e.passes.render, o = e.passes.offscreen, r = this.skyAtmosphere, s = this.globe, a = this._globeTranslucencyState; if (!i || this._mode !== ee.SCENE2D && t.camera.frustum instanceof Zt || !a.environmentVisible) n.skyAtmosphereCommand = void 0, n.skyBoxCommand = void 0, n.sunDrawCommand = void 0, n.sunComputeCommand = void 0, n.moonCommand = void 0; else { l(r) ? (l(s) && (r.setDynamicAtmosphereColor(s.enableLighting && s.dynamicAtmosphereLighting, s.dynamicAtmosphereLightingFromSun), n.isReadyForAtmosphere = n.isReadyForAtmosphere || s._surface._tilesToRender.length > 0), n.skyAtmosphereCommand = r.update(e, s), l(n.skyAtmosphereCommand) && this.updateDerivedCommands(n.skyAtmosphereCommand)) : n.skyAtmosphereCommand = void 0, n.skyBoxCommand = l(this.skyBox) ? this.skyBox.update(e, this._hdr) : void 0; let A = l(this.sun) ? this.sun.update(e, t.passState, this._hdr) : void 0; n.sunDrawCommand = l(A) ? A.drawCommand : void 0, n.sunComputeCommand = l(A) ? A.computeCommand : void 0, n.moonCommand = l(this.moon) ? this.moon.update(e) : void 0 } let c = n.clearGlobeDepth = l(s) && s.show && (!s.depthTestAgainstTerrain || this.mode === ee.SCENE2D); (n.useDepthPlane = c && this.mode === ee.SCENE3D && a.useDepthPlane) && this._depthPlane.update(e), n.renderTranslucentDepthForPick = !1, n.useWebVR = this._useWebVR && this.mode !== ee.SCENE2D && !o; let f = e.mode === ee.SCENE3D && !a.sunVisibleThroughGlobe ? e.occluder : void 0, d = e.cullingVolume, p = t0e.planes; for (let A = 0; A < 5; ++A)p[A] = d.planes[A]; d = t0e, n.isSkyAtmosphereVisible = l(n.skyAtmosphereCommand) && n.isReadyForAtmosphere, n.isSunVisible = this.isVisible(n.sunDrawCommand, d, f), n.isMoonVisible = this.isVisible(n.moonCommand, d, f); let g = this.specularEnvironmentMaps, m = this._specularEnvironmentMapAtlas; l(g) && (!l(m) || m.url !== g) ? (m = m && m.destroy(), this._specularEnvironmentMapAtlas = new Vd(g)) : !l(g) && l(m) && (m.destroy(), this._specularEnvironmentMapAtlas = void 0), l(this._specularEnvironmentMapAtlas) && this._specularEnvironmentMapAtlas.update(e) }; function adt(e) { let t = e._frameState; e.debugShowFrustumPlanes !== e._debugShowFrustumPlanes && (e.debugShowFrustumPlanes ? e._debugFrustumPlanes = new dp({ camera: e.camera, updateOnChange: !1, frustumSplits: t.frustumSplits }) : e._debugFrustumPlanes = e._debugFrustumPlanes && e._debugFrustumPlanes.destroy(), e._debugShowFrustumPlanes = e.debugShowFrustumPlanes), l(e._debugFrustumPlanes) && e._debugFrustumPlanes.update(t) } function cdt(e) { let t = e._frameState, n = t.shadowMaps, i = n.length, o = i > 0 && !t.passes.pick && e.mode === ee.SCENE3D; if (o !== t.shadowState.shadowsEnabled && (++t.shadowState.lastDirtyTime, t.shadowState.shadowsEnabled = o), t.shadowState.lightShadowsEnabled = !1, !!o) { for (let r = 0; r < i; ++r)if (n[r] !== t.shadowState.shadowMaps[r]) { ++t.shadowState.lastDirtyTime; break } t.shadowState.shadowMaps.length = 0, t.shadowState.lightShadowMaps.length = 0; for (let r = 0; r < i; ++r) { let s = n[r]; s.update(t), t.shadowState.shadowMaps.push(s), s.fromLightSource && (t.shadowState.lightShadowMaps.push(s), t.shadowState.lightShadowsEnabled = !0), s.dirty && (++t.shadowState.lastDirtyTime, s.dirty = !1) } } } function r0e(e) { let t = e._frameState; e._groundPrimitives.update(t), e._primitives.update(t), adt(e), cdt(e), e._globe && e._globe.render(t) } function cq(e, t, n) { let i = e._context, o = e._frameState, r = e._environmentState, s = e._view, c = e._frameState.passes.pick; l(s.globeDepth) && (s.globeDepth.picking = c); let u = r.useWebVR; r.originalFramebuffer = t.framebuffer, l(e.sun) && e.sunBloom !== e._sunBloom ? (e.sunBloom && !u ? e._sunPostProcess = new YU : l(e._sunPostProcess) && (e._sunPostProcess = e._sunPostProcess.destroy()), e._sunBloom = e.sunBloom) : !l(e.sun) && l(e._sunPostProcess) && (e._sunPostProcess = e._sunPostProcess.destroy(), e._sunBloom = !1); let f = e._clearColorCommand; U.clone(n, f.color), f.execute(i, t); let d = r.useGlobeDepthFramebuffer = l(s.globeDepth); d && (s.globeDepth.update(i, t, s.viewport, e.msaaSamples, e._hdr, r.clearGlobeDepth), s.globeDepth.clear(i, t, n)); let p = s.oit, g = r.useOIT = !c && l(p) && p.isSupported(); g && (p.update(i, t, s.globeDepth.colorFramebufferManager, e._hdr, e.msaaSamples), p.clear(i, t, n), r.useOIT = p.isSupported()); let m = e.postProcessStages, A = r.usePostProcess = !c && (e._hdr || m.length > 0 || m.ambientOcclusion.enabled || m.fxaa.enabled || m.bloom.enabled); if (r.usePostProcessSelected = !1, A && (s.sceneFramebuffer.update(i, s.viewport, e._hdr, e.msaaSamples), s.sceneFramebuffer.clear(i, t, n), m.update(i, o.useLogDepth, e._hdr), m.clear(i), A = r.usePostProcess = m.ready, r.usePostProcessSelected = A && m.hasSelected), r.isSunVisible && e.sunBloom && !u ? (t.framebuffer = e._sunPostProcess.update(t), e._sunPostProcess.clear(i, t, n)) : d ? t.framebuffer = s.globeDepth.framebuffer : A && (t.framebuffer = s.sceneFramebuffer.framebuffer), l(t.framebuffer) && f.execute(i, t), r.useInvertClassification = !c && l(t.framebuffer) && e.invertClassification) { let x; if (e.frameState.invertClassificationColor.alpha === 1 && r.useGlobeDepthFramebuffer && (x = s.globeDepth.framebuffer), l(x) || i.depthTexture) { if (e._invertClassification.previousFramebuffer = x, e._invertClassification.update(i, e.msaaSamples, s.globeDepth.colorFramebufferManager), e._invertClassification.clear(i, t), e.frameState.invertClassificationColor.alpha < 1 && g) { let T = e._invertClassification.unclassifiedCommand, b = T.derivedCommands; b.oit = p.createDerivedCommands(T, i, b.oit) } } else r.useInvertClassification = !1 } e._globeTranslucencyState.translucent && s.globeTranslucencyFramebuffer.updateAndClear(e._hdr, s.viewport, i, t) } Li.prototype.resolveFramebuffers = function (e) { let t = this._context, n = this._environmentState, i = this._view, o = i.globeDepth; l(o) && o.prepareColorTextures(t); let r = n.useOIT, s = n.useGlobeDepthFramebuffer, a = n.usePostProcess, c = n.originalFramebuffer, u = s ? o.colorFramebufferManager : void 0, f = i.sceneFramebuffer._colorFramebuffer, d = i.sceneFramebuffer.idFramebuffer; r && (e.framebuffer = a ? f.framebuffer : c, i.oit.execute(t, e)); let p = i.translucentTileClassification; if (p.hasTranslucentDepth && p.isSupported() && p.execute(this, e), a) { i.sceneFramebuffer.prepareColorTextures(t); let g = f; s && !r && (g = u); let m = this.postProcessStages, A = g.getColorTexture(0), C = d.getColorTexture(0), x = y(u, f).getDepthStencilTexture(); m.execute(t, A, x, C), m.copy(t, c) } !r && !a && s && (e.framebuffer = c, o.executeCopyColor(t, e)) }; function ldt(e) { let t = e._frameState.afterRender; for (let n = 0, i = t.length; n < i; ++n)t[n](), e.requestRender(); t.length = 0 } function udt(e) { let t = e._globe, i = e.camera.positionCartographic; if (l(t) && t.show && l(i)) return t.getHeight(i) } function fdt(e) { let t = e.camera, n = e._mode, i = e.globe, o = e._screenSpaceCameraController, r = t.positionCartographic; if (!l(r)) return !1; if (!o.onMap() && r.height < 0) return !0; if (!l(i) || !i.show || n === ee.SCENE2D || n === ee.MORPHING) return !1; let s = e._globeHeight; return l(s) && r.height < s } Li.prototype.initializeFrame = function () { this._shaderFrameCount++ === 120 && (this._shaderFrameCount = 0, this._context.shaderCache.destroyReleasedShaderPrograms(), this._context.textureCache.destroyReleasedTextures()), this._tweens.update(), this._globeHeight = udt(this), this._cameraUnderground = fdt(this), this._globeTranslucencyState.update(this), this._screenSpaceCameraController.update(), l(this._deviceOrientationCameraController) && this._deviceOrientationCameraController.update(), this.camera.update(this._mode), this.camera._updateCameraChanged() }; function ddt(e, t) { if (e.debugShowFramesPerSecond) { if (!l(e._performanceDisplay)) { let n = document.createElement("div"); n.className = "cesium-performanceDisplay-defaultContainer", e._canvas.parentNode.appendChild(n); let o = new jg({ container: n }); e._performanceDisplay = o, e._performanceContainer = n } e._performanceDisplay.throttled = e.requestRenderMode, e._performanceDisplay.update(t) } else l(e._performanceDisplay) && (e._performanceDisplay = e._performanceDisplay && e._performanceDisplay.destroy(), e._performanceContainer.parentNode.removeChild(e._performanceContainer)) } function hdt(e) { e._jobScheduler.resetBudgets(); let t = e._frameState; e.primitives.prePassesUpdate(t), l(e.globe) && e.globe.update(t), e._picking.update(), t.creditDisplay.update() } function mdt(e) { let t = e._frameState; e.primitives.postPassesUpdate(t), Ya.update() } var pdt = new U; function _dt(e) { let t = e._frameState, n = e.context, i = n.uniformState, o = e._defaultView; e._view = o, e.updateFrameState(), t.passes.render = !0, t.passes.postProcess = e.postProcessStages.hasSelected, t.tilesetPassState = Fft; let r = y(e.backgroundColor, U.BLACK); e._hdr && (r = U.clone(r, pdt), r.red = Math.pow(r.red, e.gamma), r.green = Math.pow(r.green, e.gamma), r.blue = Math.pow(r.blue, e.gamma)), t.backgroundColor = r, e.fog.update(t), i.update(t); let s = e.shadowMap; l(s) && s.enabled && (!l(e.light) || e.light instanceof Eg ? h.negate(i.sunDirectionWC, e._shadowMapCamera.direction) : h.clone(e.light.direction, e._shadowMapCamera.direction), t.shadowMaps.push(s)), e._computeCommandList.length = 0, e._overlayCommandList.length = 0; let a = o.viewport; a.x = 0, a.y = 0, a.width = n.drawingBufferWidth, a.height = n.drawingBufferHeight; let c = o.passState; c.framebuffer = void 0, c.blendingEnabled = void 0, c.scissorTest = void 0, c.viewport = Ge.clone(a, c.viewport), l(e.globe) && e.globe.beginFrame(t), e.updateEnvironment(), e.updateAndExecuteCommands(c, r), e.resolveFramebuffers(c), c.framebuffer = void 0, Xft(e, c), l(e.globe) && (e.globe.endFrame(t), e.globe.tilesLoaded || (e._renderRequested = !0)), n.endFrame() } function AA(e, t) { try { t(e) } catch (n) { if (e._renderError.raiseEvent(e, n), e.rethrowRenderErrors) throw n } } function gdt(e) { return e._picking.updateMostDetailedRayPicks(e) } Li.prototype.render = function (e) { this._preUpdate.raiseEvent(this, e); let t = this._frameState; t.newFrame = !1, l(e) || (e = $.now()); let n = this._view.checkForCameraUpdates(this), i = !this.requestRenderMode || this._renderRequested || n || this._logDepthBufferDirty || this._hdrDirty || this.mode === ee.MORPHING; if (!i && l(this.maximumRenderTimeChange) && l(this._lastRenderTime)) { let o = Math.abs($.secondsDifference(this._lastRenderTime, e)); i = i || o > this.maximumRenderTimeChange } if (i) { this._lastRenderTime = $.clone(e, this._lastRenderTime), this._renderRequested = !1, this._logDepthBufferDirty = !1, this._hdrDirty = !1; let o = I.incrementWrap(t.frameNumber, 15e6, 1); n0e(this, o, e), t.newFrame = !0 } AA(this, hdt), this.primitives.show && (AA(this, gdt), AA(this, ydt), AA(this, Adt), i || AA(this, Cdt)), this._postUpdate.raiseEvent(this, e), i && (this._preRender.raiseEvent(this, e), t.creditDisplay.beginFrame(), AA(this, _dt)), ddt(this, i), AA(this, mdt), ldt(this), i && (this._postRender.raiseEvent(this, e), t.creditDisplay.endFrame()) }; Li.prototype.forceRender = function (e) { this._renderRequested = !0, this.render(e) }; Li.prototype.requestRender = function () { this._renderRequested = !0 }; Li.prototype.clampLineWidth = function (e) { return Math.max(Ut.minimumAliasedLineWidth, Math.min(e, Ut.maximumAliasedLineWidth)) }; Li.prototype.pick = function (e, t, n) { return this._picking.pick(this, e, t, n) }; Li.prototype.pickPositionWorldCoordinates = function (e, t) { return this._picking.pickPositionWorldCoordinates(this, e, t) }; Li.prototype.pickPosition = function (e, t) { return this._picking.pickPosition(this, e, t) }; Li.prototype.drillPick = function (e, t, n, i) { return this._picking.drillPick(this, e, t, n, i) }; function ydt(e) { let t = e._frameState; oq.camera = t.camera, oq.cullingVolume = t.cullingVolume, e.primitives.updateForPass(t, oq) } function Adt(e) { let t = e._frameState; if (!t.camera.canPreloadFlight()) return; rq.camera = e.preloadFlightCamera, rq.cullingVolume = e.preloadFlightCullingVolume, e.primitives.updateForPass(t, rq) } function Cdt(e) { e.primitives.updateForPass(e._frameState, Nft) } Li.prototype.pickFromRay = function (e, t, n) { return this._picking.pickFromRay(this, e, t, n) }; Li.prototype.drillPickFromRay = function (e, t, n, i) { return this._picking.drillPickFromRay(this, e, t, n, i) }; Li.prototype.pickFromRayMostDetailed = function (e, t, n) { return this._picking.pickFromRayMostDetailed(this, e, t, n) }; Li.prototype.drillPickFromRayMostDetailed = function (e, t, n, i) { return this._picking.drillPickFromRayMostDetailed(this, e, t, n, i) }; Li.prototype.sampleHeight = function (e, t, n) { return this._picking.sampleHeight(this, e, t, n) }; Li.prototype.clampToHeight = function (e, t, n, i) { return this._picking.clampToHeight(this, e, t, n, i) }; Li.prototype.sampleHeightMostDetailed = function (e, t, n) { return this._picking.sampleHeightMostDetailed(this, e, t, n) }; Li.prototype.clampToHeightMostDetailed = function (e, t, n) { return this._picking.clampToHeightMostDetailed(this, e, t, n) }; Li.prototype.cartesianToCanvasCoordinates = function (e, t) { return ji.wgs84ToWindowCoordinates(this, e, t) }; Li.prototype.completeMorph = function () { this._transitioner.completeMorph() }; Li.prototype.morphTo2D = function (e) { let t, n = this.globe; l(n) ? t = n.ellipsoid : t = this.mapProjection.ellipsoid, e = y(e, 2), this._transitioner.morphTo2D(e, t) }; Li.prototype.morphToColumbusView = function (e) { let t, n = this.globe; l(n) ? t = n.ellipsoid : t = this.mapProjection.ellipsoid, e = y(e, 2), this._transitioner.morphToColumbusView(e, t) }; Li.prototype.morphTo3D = function (e) { let t, n = this.globe; l(n) ? t = n.ellipsoid : t = this.mapProjection.ellipsoid, e = y(e, 2), this._transitioner.morphTo3D(e, t) }; Li.prototype.isDestroyed = function () { return !1 }; Li.prototype.destroy = function () { this._tweens.removeAll(), this._computeEngine = this._computeEngine && this._computeEngine.destroy(), this._screenSpaceCameraController = this._screenSpaceCameraController && this._screenSpaceCameraController.destroy(), this._deviceOrientationCameraController = this._deviceOrientationCameraController && !this._deviceOrientationCameraController.isDestroyed() && this._deviceOrientationCameraController.destroy(), this._primitives = this._primitives && this._primitives.destroy(), this._groundPrimitives = this._groundPrimitives && this._groundPrimitives.destroy(), this._globe = this._globe && this._globe.destroy(), this.skyBox = this.skyBox && this.skyBox.destroy(), this.skyAtmosphere = this.skyAtmosphere && this.skyAtmosphere.destroy(), this._debugSphere = this._debugSphere && this._debugSphere.destroy(), this.sun = this.sun && this.sun.destroy(), this._sunPostProcess = this._sunPostProcess && this._sunPostProcess.destroy(), this._depthPlane = this._depthPlane && this._depthPlane.destroy(), this._transitioner = this._transitioner && this._transitioner.destroy(), this._debugFrustumPlanes = this._debugFrustumPlanes && this._debugFrustumPlanes.destroy(), this._brdfLutGenerator = this._brdfLutGenerator && this._brdfLutGenerator.destroy(), this._picking = this._picking && this._picking.destroy(), this._defaultView = this._defaultView && this._defaultView.destroy(), this._view = void 0, this._removeCreditContainer && this._canvas.parentNode.removeChild(this._creditContainer), this.postProcessStages = this.postProcessStages && this.postProcessStages.destroy(), this._context = this._context && this._context.destroy(), this._frameState.creditDisplay = this._frameState.creditDisplay && this._frameState.creditDisplay.destroy(), l(this._performanceDisplay) && (this._performanceDisplay = this._performanceDisplay && this._performanceDisplay.destroy(), this._performanceContainer.parentNode.removeChild(this._performanceContainer)), this._removeRequestListenerCallback(), this._removeTaskProcessorListenerCallback(); for (let e = 0; e < this._removeGlobeCallbacks.length; ++e)this._removeGlobeCallbacks[e](); return this._removeGlobeCallbacks.length = 0, le(this) }; var JU = Li; var Rv = `float interpolateByDistance(vec4 nearFarScalar, float distance)
{
float startDistance = nearFarScalar.x;
float startValue = nearFarScalar.y;
float endDistance = nearFarScalar.z;
float endValue = nearFarScalar.w;
float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0);
return mix(startValue, endValue, t);
}
vec3 getLightDirection(vec3 positionWC)
{
float lightEnum = u_radiiAndDynamicAtmosphereColor.z;
vec3 lightDirection =
positionWC * float(lightEnum == 0.0) +
czm_lightDirectionWC * float(lightEnum == 1.0) +
czm_sunDirectionWC * float(lightEnum == 2.0);
return normalize(lightDirection);
}
void computeAtmosphereScattering(vec3 positionWC, vec3 lightDirection, out vec3 rayleighColor, out vec3 mieColor, out float opacity, out float underTranslucentGlobe)
{
float ellipsoidRadiiDifference = czm_ellipsoidRadii.x - czm_ellipsoidRadii.z;
float distanceAdjustMin = czm_ellipsoidRadii.x / 4.0;
float distanceAdjustMax = czm_ellipsoidRadii.x;
float distanceAdjustModifier = ellipsoidRadiiDifference / 2.0;
float distanceAdjust = distanceAdjustModifier * clamp((czm_eyeHeight - distanceAdjustMin) / (distanceAdjustMax - distanceAdjustMin), 0.0, 1.0);
float radiusAdjust = (ellipsoidRadiiDifference / 4.0) + distanceAdjust;
float atmosphereInnerRadius = (length(czm_viewerPositionWC) - czm_eyeHeight) - radiusAdjust;
vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC;
vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC);
czm_ray primaryRay = czm_ray(czm_viewerPositionWC, cameraToPositionWCDirection);
underTranslucentGlobe = 0.0;
#if defined(GLOBE_TRANSLUCENT)
czm_raySegment primaryRayEarthIntersect = czm_raySphereIntersectionInterval(primaryRay, vec3(0.0), atmosphereInnerRadius + radiusAdjust);
if (primaryRayEarthIntersect.start > 0.0 && primaryRayEarthIntersect.stop > 0.0) {
vec3 direction = normalize(positionWC);
czm_ray ellipsoidRay = czm_ray(positionWC, -direction);
czm_raySegment ellipsoidIntersection = czm_rayEllipsoidIntersectionInterval(ellipsoidRay, vec3(0.0), czm_ellipsoidInverseRadii);
vec3 onEarth = positionWC - (direction * ellipsoidIntersection.start);
float angle = dot(normalize(czm_viewerPositionWC), normalize(onEarth));
opacity = interpolateByDistance(vec4(0.0, 1.0, czm_ellipsoidRadii.x, 0.0), length(czm_viewerPositionWC - onEarth));
vec3 horizonColor = vec3(0.1, 0.2, 0.3);
vec3 nearColor = vec3(0.0);
rayleighColor = mix(nearColor, horizonColor, exp(-angle) * opacity);
underTranslucentGlobe = 1.0;
return;
}
#endif
computeScattering(
primaryRay,
length(cameraToPositionWC),
lightDirection,
atmosphereInnerRadius,
rayleighColor,
mieColor,
opacity
);
float cameraHeight = czm_eyeHeight + atmosphereInnerRadius;
float atmosphereOuterRadius = atmosphereInnerRadius + ATMOSPHERE_THICKNESS;
opacity = clamp((atmosphereOuterRadius - cameraHeight) / (atmosphereOuterRadius - atmosphereInnerRadius), 0.0, 1.0);
float nightAlpha = (u_radiiAndDynamicAtmosphereColor.z != 0.0) ? clamp(dot(normalize(positionWC), lightDirection), 0.0, 1.0) : 1.0;
opacity *= pow(nightAlpha, 0.5);
}
`; var ZU = `varying vec3 v_outerPositionWC;
uniform vec3 u_hsbShift;
#ifndef PER_FRAGMENT_ATMOSPHERE
varying vec3 v_mieColor;
varying vec3 v_rayleighColor;
varying float v_opacity;
varying float v_translucent;
#endif
void main (void)
{
vec3 lightDirection = getLightDirection(v_outerPositionWC);
vec3 mieColor;
vec3 rayleighColor;
float opacity;
float translucent;
#ifdef PER_FRAGMENT_ATMOSPHERE
computeAtmosphereScattering(
v_outerPositionWC,
lightDirection,
rayleighColor,
mieColor,
opacity,
translucent
);
#else
mieColor = v_mieColor;
rayleighColor = v_rayleighColor;
opacity = v_opacity;
translucent = v_translucent;
#endif
vec4 color = computeAtmosphereColor(v_outerPositionWC, lightDirection, rayleighColor, mieColor, opacity);
#ifndef HDR
color.rgb = czm_acesTonemapping(color.rgb);
color.rgb = czm_inverseGamma(color.rgb);
#endif
#ifdef COLOR_CORRECT
vec3 hsb = czm_RGBToHSB(color.rgb);
hsb.x += u_hsbShift.x;
hsb.y = clamp(hsb.y + u_hsbShift.y, 0.0, 1.0);
hsb.z = hsb.z > czm_epsilon7 ? hsb.z + u_hsbShift.z : 0.0;
color.rgb = czm_HSBToRGB(hsb);
#endif
if (translucent == 0.0) {
color.a = mix(color.b, 1.0, color.a) * smoothstep(0.0, 1.0, czm_morphTime);
}
gl_FragColor = color;
}
`; var QU = `attribute vec4 position;
varying vec3 v_outerPositionWC;
#ifndef PER_FRAGMENT_ATMOSPHERE
varying vec3 v_mieColor;
varying vec3 v_rayleighColor;
varying float v_opacity;
varying float v_translucent;
#endif
void main(void)
{
vec4 positionWC = czm_model * position;
vec3 lightDirection = getLightDirection(positionWC.xyz);
#ifndef PER_FRAGMENT_ATMOSPHERE
computeAtmosphereScattering(
positionWC.xyz,
lightDirection,
v_rayleighColor,
v_mieColor,
v_opacity,
v_translucent
);
#endif
v_outerPositionWC = positionWC.xyz;
gl_Position = czm_modelViewProjection * position;
}
`; function jE(e) { e = y(e, ie.WGS84), this.show = !0, this.perFragmentAtmosphere = !1, this._ellipsoid = e; let t = 1.025, n = h.multiplyByScalar(e.radii, t, new h); this._scaleMatrix = F.fromScale(n), this._modelMatrix = new F, this._command = new $e({ owner: this, modelMatrix: this._modelMatrix }), this._spSkyFromSpace = void 0, this._spSkyFromAtmosphere = void 0, this._flags = void 0, this.atmosphereLightIntensity = 50, this.atmosphereRayleighCoefficient = new h(55e-7, 13e-6, 284e-7), this.atmosphereMieCoefficient = new h(21e-6, 21e-6, 21e-6), this.atmosphereRayleighScaleHeight = 1e4, this.atmosphereMieScaleHeight = 3200, this.atmosphereMieAnisotropy = .9, this.hueShift = 0, this.saturationShift = 0, this.brightnessShift = 0, this._hueSaturationBrightness = new h; let i = new h; i.x = e.maximumRadius * t, i.y = e.maximumRadius, i.z = 0, this._radiiAndDynamicAtmosphereColor = i; let o = this; this._command.uniformMap = { u_radiiAndDynamicAtmosphereColor: function () { return o._radiiAndDynamicAtmosphereColor }, u_hsbShift: function () { return o._hueSaturationBrightness.x = o.hueShift, o._hueSaturationBrightness.y = o.saturationShift, o._hueSaturationBrightness.z = o.brightnessShift, o._hueSaturationBrightness }, u_atmosphereLightIntensity: function () { return o.atmosphereLightIntensity }, u_atmosphereRayleighCoefficient: function () { return o.atmosphereRayleighCoefficient }, u_atmosphereMieCoefficient: function () { return o.atmosphereMieCoefficient }, u_atmosphereRayleighScaleHeight: function () { return o.atmosphereRayleighScaleHeight }, u_atmosphereMieScaleHeight: function () { return o.atmosphereMieScaleHeight }, u_atmosphereMieAnisotropy: function () { return o.atmosphereMieAnisotropy } } } Object.defineProperties(jE.prototype, { ellipsoid: { get: function () { return this._ellipsoid } } }); jE.prototype.setDynamicAtmosphereColor = function (e, t) { let n = e ? t ? 2 : 1 : 0; this._radiiAndDynamicAtmosphereColor.z = n }; var lq = new F; jE.prototype.update = function (e, t) { if (!this.show) return; let n = e.mode; if (n !== ee.SCENE3D && n !== ee.MORPHING || !e.passes.render) return; let i = F.fromRotationTranslation(e.context.uniformState.inverseViewRotation, h.ZERO, lq), o = F.multiplyTransformation(i, Do.Y_UP_TO_Z_UP, lq), r = F.multiply(this._scaleMatrix, o, lq); F.clone(r, this._modelMatrix); let s = e.context, a = xdt(this), c = e.globeTranslucencyState.translucent, u = this.perFragmentAtmosphere || c || !l(t) || !t.show, f = this._command; if (!l(f.vertexArray)) { let p = Bs.createGeometry(new Bs({ radii: new h(1, 1, 1), slicePartitions: 256, stackPartitions: 256, vertexFormat: we.POSITION_ONLY })); f.vertexArray = Qn.fromGeometry({ context: s, geometry: p, attributeLocations: Bn.createAttributeLocations(p), bufferUsage: Re.STATIC_DRAW }), f.renderState = Ve.fromCache({ cull: { enabled: !0, face: gi.FRONT }, blending: an.ALPHA_BLEND, depthMask: !1 }) } let d = a | u << 2 | c << 3; if (d !== this._flags) { this._flags = d; let p = []; a && p.push("COLOR_CORRECT"), u && p.push("PER_FRAGMENT_ATMOSPHERE"), c && p.push("GLOBE_TRANSLUCENT"); let g = new Ue({ defines: p, sources: [Hg, Rv, QU] }), m = new Ue({ defines: p, sources: [Hg, Rv, ZU] }); this._spSkyAtmosphere = qt.fromCache({ context: s, vertexShaderSource: g, fragmentShaderSource: m }), f.shaderProgram = this._spSkyAtmosphere } return f }; function xdt(e) { return !(I.equalsEpsilon(e.hueShift, 0, I.EPSILON7) && I.equalsEpsilon(e.saturationShift, 0, I.EPSILON7) && I.equalsEpsilon(e.brightnessShift, 0, I.EPSILON7)) } jE.prototype.isDestroyed = function () { return !1 }; jE.prototype.destroy = function () { let e = this._command; return e.vertexArray = e.vertexArray && e.vertexArray.destroy(), this._spSkyAtmosphere = this._spSkyAtmosphere && this._spSkyAtmosphere.destroy(), le(this) }; var $U = jE; var e4 = `uniform samplerCube u_cubeMap;
varying vec3 v_texCoord;
void main()
{
vec4 color = textureCube(u_cubeMap, normalize(v_texCoord));
gl_FragColor = vec4(czm_gammaCorrect(color).rgb, czm_morphTime);
}
`; var t4 = `attribute vec3 position;
varying vec3 v_texCoord;
void main()
{
vec3 p = czm_viewRotation * (czm_temeToPseudoFixed * (czm_entireFrustum.y * position));
gl_Position = czm_projection * vec4(p, 1.0);
v_texCoord = position.xyz;
}
`; function n4(e) { this.sources = e.sources, this._sources = void 0, this.show = y(e.show, !0), this._command = new $e({ modelMatrix: F.clone(F.IDENTITY), owner: this }), this._cubeMap = void 0, this._attributeLocations = void 0, this._useHdr = void 0 } n4.prototype.update = function (e, t) { let n = this; if (!this.show || e.mode !== ee.SCENE3D && e.mode !== ee.MORPHING || !e.passes.render) return; let i = e.context; if (this._sources !== this.sources) { this._sources = this.sources; let r = this.sources; typeof r.positiveX == "string" ? b3(i, this._sources).then(function (s) { n._cubeMap = n._cubeMap && n._cubeMap.destroy(), n._cubeMap = s }) : (this._cubeMap = this._cubeMap && this._cubeMap.destroy(), this._cubeMap = new Xa({ context: i, source: r })) } let o = this._command; if (!l(o.vertexArray)) { o.uniformMap = { u_cubeMap: function () { return n._cubeMap } }; let r = ll.createGeometry(ll.fromDimensions({ dimensions: new h(2, 2, 2), vertexFormat: we.POSITION_ONLY })), s = this._attributeLocations = Bn.createAttributeLocations(r); o.vertexArray = Qn.fromGeometry({ context: i, geometry: r, attributeLocations: s, bufferUsage: Re.STATIC_DRAW }), o.renderState = Ve.fromCache({ blending: an.ALPHA_BLEND }) } if (!l(o.shaderProgram) || this._useHdr !== t) { let r = new Ue({ defines: [t ? "HDR" : ""], sources: [e4] }); o.shaderProgram = qt.fromCache({ context: i, vertexShaderSource: t4, fragmentShaderSource: r, attributeLocations: this._attributeLocations }), this._useHdr = t } if (!!l(this._cubeMap)) return o }; n4.prototype.isDestroyed = function () { return !1 }; n4.prototype.destroy = function () { let e = this._command; return e.vertexArray = e.vertexArray && e.vertexArray.destroy(), e.shaderProgram = e.shaderProgram && e.shaderProgram.destroy(), this._cubeMap = this._cubeMap && this._cubeMap.destroy(), le(this) }; var i4 = n4; function uq(e) { e = y(e, 1), this._radius = y(e, 1) } Object.defineProperties(uq.prototype, { radius: { get: function () { return this._radius }, set: function (e) { this._radius = e } } }); uq.prototype.emit = function (e) { let t = I.randomBetween(0, I.TWO_PI), n = I.randomBetween(0, I.PI), i = I.randomBetween(0, this._radius), o = i * Math.cos(t) * Math.sin(n), r = i * Math.sin(t) * Math.sin(n), s = i * Math.cos(n); e.position = h.fromElements(o, r, s, e.position), e.velocity = h.normalize(e.position, e.velocity) }; var s0e = uq; function Mv() { } Mv.prototype.evaluate = function (e, t) { ye.throwInstantiationError() }; Mv.prototype.evaluateColor = function (e, t) { ye.throwInstantiationError() }; Mv.prototype.getShaderFunction = function (e, t, n, i) { ye.throwInstantiationError() }; Mv.prototype.getVariables = function () { ye.throwInstantiationError() }; var a0e = Mv; var o4 = `uniform sampler2D u_texture;
varying vec2 v_textureCoordinates;
void main()
{
vec4 color = texture2D(u_texture, v_textureCoordinates);
gl_FragColor = czm_gammaCorrect(color);
}
`; var r4 = `uniform float u_radiusTS;
varying vec2 v_textureCoordinates;
vec2 rotate(vec2 p, vec2 direction)
{
return vec2(p.x * direction.x - p.y * direction.y, p.x * direction.y + p.y * direction.x);
}
vec4 addBurst(vec2 position, vec2 direction, float lengthScalar)
{
vec2 rotatedPosition = rotate(position, direction) * vec2(25.0, 0.75);
float radius = length(rotatedPosition) * lengthScalar;
float burst = 1.0 - smoothstep(0.0, 0.55, radius);
return vec4(burst);
}
void main()
{
float lengthScalar = 2.0 / sqrt(2.0);
vec2 position = v_textureCoordinates - vec2(0.5);
float radius = length(position) * lengthScalar;
float surface = step(radius, u_radiusTS);
vec4 color = vec4(vec2(1.0), surface + 0.2, surface);
float glow = 1.0 - smoothstep(0.0, 0.55, radius);
color.ba += mix(vec2(0.0), vec2(1.0), glow) * 0.75;
vec4 burst = vec4(0.0);
burst += 0.4 * addBurst(position, vec2(0.38942,  0.92106), lengthScalar);
burst += 0.4 * addBurst(position, vec2(0.99235,  0.12348), lengthScalar);
burst += 0.4 * addBurst(position, vec2(0.60327, -0.79754), lengthScalar);
burst += 0.3 * addBurst(position, vec2(0.31457,  0.94924), lengthScalar);
burst += 0.3 * addBurst(position, vec2(0.97931,  0.20239), lengthScalar);
burst += 0.3 * addBurst(position, vec2(0.66507, -0.74678), lengthScalar);
color += clamp(burst, vec4(0.0), vec4(1.0)) * 0.15;
gl_FragColor = clamp(color, vec4(0.0), vec4(1.0));
}
`; var s4 = `attribute vec2 direction;
uniform float u_size;
varying vec2 v_textureCoordinates;
void main()
{
vec4 position;
if (czm_morphTime == 1.0)
{
position = vec4(czm_sunPositionWC, 1.0);
}
else
{
position = vec4(czm_sunPositionColumbusView.zxy, 1.0);
}
vec4 positionEC = czm_view * position;
vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);
vec2 halfSize = vec2(u_size * 0.5);
halfSize *= ((direction * 2.0) - 1.0);
gl_Position = czm_viewportOrthographic * vec4(positionWC.xy + halfSize, -positionWC.z, 1.0);
v_textureCoordinates = direction;
}
`; function Fv() { this.show = !0, this._drawCommand = new $e({ primitiveType: Oe.TRIANGLES, boundingVolume: new re, owner: this }), this._commands = { drawCommand: this._drawCommand, computeCommand: void 0 }, this._boundingVolume = new re, this._boundingVolume2D = new re, this._texture = void 0, this._drawingBufferWidth = void 0, this._drawingBufferHeight = void 0, this._radiusTS = void 0, this._size = void 0, this.glowFactor = 1, this._glowFactorDirty = !1, this._useHdr = void 0; let e = this; this._uniformMap = { u_texture: function () { return e._texture }, u_size: function () { return e._size } } } Object.defineProperties(Fv.prototype, { glowFactor: { get: function () { return this._glowFactor }, set: function (e) { e = Math.max(e, 0), this._glowFactor = e, this._glowFactorDirty = !0 } } }); var Tdt = new H, Edt = new H, bdt = new se, Lv = new se; Fv.prototype.update = function (e, t, n) { if (!this.show) return; let i = e.mode; if (i === ee.SCENE2D || i === ee.MORPHING || !e.passes.render) return; let o = e.context, r = t.viewport.width, s = t.viewport.height; if (!l(this._texture) || r !== this._drawingBufferWidth || s !== this._drawingBufferHeight || this._glowFactorDirty || n !== this._useHdr) { this._texture = this._texture && this._texture.destroy(), this._drawingBufferWidth = r, this._drawingBufferHeight = s, this._glowFactorDirty = !1, this._useHdr = n; let S = Math.max(r, s); S = Math.pow(2, Math.ceil(Math.log(S) / Math.log(2)) - 2), S = Math.max(1, S); let D = n ? o.halfFloatingPointTexture ? Ye.HALF_FLOAT : Ye.FLOAT : Ye.UNSIGNED_BYTE; this._texture = new Rt({ context: o, width: S, height: S, pixelFormat: ht.RGBA, pixelDatatype: D }), this._glowLengthTS = this._glowFactor * 5, this._radiusTS = 1 / (1 + 2 * this._glowLengthTS) * .5; let P = this, B = { u_radiusTS: function () { return P._radiusTS } }; this._commands.computeCommand = new pf({ fragmentShaderSource: r4, outputTexture: this._texture, uniformMap: B, persists: !1, owner: this, postExecute: function () { P._commands.computeCommand = void 0 } }) } let a = this._drawCommand; if (!l(a.vertexArray)) { let S = { direction: 0 }, D = new Uint8Array(4 * 2); D[0] = 0, D[1] = 0, D[2] = 255, D[3] = 0, D[4] = 255, D[5] = 255, D[6] = 0, D[7] = 255; let P = ct.createVertexBuffer({ context: o, typedArray: D, usage: Re.STATIC_DRAW }), B = [{ index: S.direction, vertexBuffer: P, componentsPerAttribute: 2, normalize: !0, componentDatatype: Y.UNSIGNED_BYTE }], R = ct.createIndexBuffer({ context: o, typedArray: new Uint16Array([0, 1, 2, 0, 2, 3]), usage: Re.STATIC_DRAW, indexDatatype: Me.UNSIGNED_SHORT }); a.vertexArray = new Qn({ context: o, attributes: B, indexBuffer: R }), a.shaderProgram = qt.fromCache({ context: o, vertexShaderSource: s4, fragmentShaderSource: o4, attributeLocations: S }), a.renderState = Ve.fromCache({ blending: an.ALPHA_BLEND }), a.uniformMap = this._uniformMap } let c = o.uniformState.sunPositionWC, u = o.uniformState.sunPositionColumbusView, f = this._boundingVolume, d = this._boundingVolume2D; h.clone(c, f.center), d.center.x = u.z, d.center.y = u.x, d.center.z = u.y, f.radius = I.SOLAR_RADIUS + I.SOLAR_RADIUS * this._glowLengthTS, d.radius = f.radius, i === ee.SCENE3D ? re.clone(f, a.boundingVolume) : i === ee.COLUMBUS_VIEW && re.clone(d, a.boundingVolume); let p = ji.computeActualWgs84Position(e, c, Lv), g = h.magnitude(h.subtract(p, e.camera.position, Lv)), m = o.uniformState.projection, A = bdt; A.x = 0, A.y = 0, A.z = -g, A.w = 1; let C = F.multiplyByVector(m, A, Lv), x = ji.clipToGLWindowCoordinates(t.viewport, C, Tdt); A.x = I.SOLAR_RADIUS; let T = F.multiplyByVector(m, A, Lv), b = ji.clipToGLWindowCoordinates(t.viewport, T, Edt); return this._size = H.magnitude(H.subtract(b, x, Lv)), this._size = 2 * this._size * (1 + 2 * this._glowLengthTS), this._size = Math.ceil(this._size), this._commands }; Fv.prototype.isDestroyed = function () { return !1 }; Fv.prototype.destroy = function () { let e = this._drawCommand; return e.vertexArray = e.vertexArray && e.vertexArray.destroy(), e.shaderProgram = e.shaderProgram && e.shaderProgram.destroy(), this._texture = this._texture && this._texture.destroy(), le(this) }; var a4 = Fv; function qE() { } qE.prototype.boundingVolume = void 0; qE.prototype.boundingSphere = void 0; qE.prototype.distanceToCamera = function (e) { ye.throwInstantiationError() }; qE.prototype.intersectPlane = function (e) { ye.throwInstantiationError() }; qE.prototype.createDebugVolume = function (e) { ye.throwInstantiationError() }; var c0e = qE; function Nv(e) { e = y(e, y.EMPTY_OBJECT), this._tilingScheme = l(e.tilingScheme) ? e.tilingScheme : new Hi({ ellipsoid: e.ellipsoid }), this._color = y(e.color, U.YELLOW), this._errorEvent = new _e, this._tileWidth = y(e.tileWidth, 256), this._tileHeight = y(e.tileHeight, 256), this._readyPromise = Promise.resolve(!0), this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0 } Object.defineProperties(Nv.prototype, { proxy: { get: function () { } }, tileWidth: { get: function () { return this._tileWidth } }, tileHeight: { get: function () { return this._tileHeight } }, maximumLevel: { get: function () { } }, minimumLevel: { get: function () { } }, tilingScheme: { get: function () { return this._tilingScheme } }, rectangle: { get: function () { return this._tilingScheme.rectangle } }, tileDiscardPolicy: { get: function () { } }, errorEvent: { get: function () { return this._errorEvent } }, ready: { get: function () { return !0 } }, readyPromise: { get: function () { return this._readyPromise } }, credit: { get: function () { } }, hasAlphaChannel: { get: function () { return !0 } } }); Nv.prototype.getTileCredits = function (e, t, n) { }; Nv.prototype.requestImage = function (e, t, n, i) { let o = document.createElement("canvas"); o.width = 256, o.height = 256; let r = o.getContext("2d"), s = this._color.toCssColorString(); return r.strokeStyle = s, r.lineWidth = 2, r.strokeRect(1, 1, 255, 255), r.font = "bold 25px Arial", r.textAlign = "center", r.fillStyle = s, r.fillText(`L: ${n}`, 124, 86), r.fillText(`X: ${e}`, 124, 136), r.fillText(`Y: ${t}`, 124, 186), Promise.resolve(o) }; Nv.prototype.pickFeatures = function (e, t, n, i, o) { }; var c4 = Nv; function fq(e) { ye.throwInstantiationError() } fq.prototype.isReady = ye.throwInstantiationError; fq.prototype.shouldDiscardImage = ye.throwInstantiationError; var l0e = fq; var Sdt = { START: 0, LOADING: 1, READY: 2, UPSAMPLED_ONLY: 3 }, u0e = Object.freeze(Sdt); function xA(e) { e = y(e, y.EMPTY_OBJECT), this.show = y(e.show, !0), this.modelMatrix = F.clone(y(e.modelMatrix, F.IDENTITY)), this.shadows = y(e.shadows, hn.ENABLED), this.maximumMemoryUsage = y(e.maximumMemoryUsage, 256), this.shading = new bm(e.shading), this.style = e.style, this.frameFailed = new _e, this.frameChanged = new _e, this._clock = e.clock, this._intervals = e.intervals, this._clippingPlanes = void 0, this.clippingPlanes = e.clippingPlanes, this._pointCloudEyeDomeLighting = new m_, this._loadTimestamp = void 0, this._clippingPlanesState = 0, this._styleDirty = !1, this._pickId = void 0, this._totalMemoryUsageInBytes = 0, this._frames = [], this._previousInterval = void 0, this._nextInterval = void 0, this._lastRenderedFrame = void 0, this._clockMultiplier = 0, this._resolveReadyPromise = void 0; let t = this; this._readyPromise = new Promise(function (n) { t._resolveReadyPromise = n }), this._runningSum = 0, this._runningLength = 0, this._runningIndex = 0, this._runningSamples = new Array(5).fill(0), this._runningAverage = 0 } Object.defineProperties(xA.prototype, { clippingPlanes: { get: function () { return this._clippingPlanes }, set: function (e) { Ks.setOwner(e, this, "_clippingPlanes") } }, totalMemoryUsageInBytes: { get: function () { return this._totalMemoryUsageInBytes } }, boundingSphere: { get: function () { if (l(this._lastRenderedFrame)) return this._lastRenderedFrame.pointCloud.boundingSphere } }, readyPromise: { get: function () { return this._readyPromise } } }); function wdt(e) {
        return `uniform vec4 czm_pickColor;
${e}`
    } function Ddt(e) { return function (t) { return yt(t, { czm_pickColor: function () { return e._pickId.color } }) } } function vdt() { return "czm_pickColor" } xA.prototype.makeStyleDirty = function () { this._styleDirty = !0 }; xA.prototype._getAverageLoadTime = function () { return this._runningLength === 0 ? .05 : this._runningAverage }; var Pdt = new $; function hq(e) { let t = e._clock, n = t.canAnimate && t.shouldAnimate, i = t.multiplier; return n ? i : 0 } function CA(e, t) { return e._intervals.indexOf(t.start) } function Idt(e, t) { let n = e._intervals, i = e._clock, o = hq(e); if (o === 0) return; let r = e._getAverageLoadTime(), s = $.addSeconds(i.currentTime, r * o, Pdt), a = n.indexOf(s), c = CA(e, t); return a === c && (o >= 0 ? ++a : --a), n.get(a) } function Odt(e) { let t = e._intervals, i = e._clock.currentTime, o = t.indexOf(i); return t.get(o) } function Bdt(e, t, n) { let i = hq(e), o = CA(e, t), r = CA(e, n); return i >= 0 ? o >= r : o <= r } function Rdt(e, t) { return function (n) { let i = l(n.message) ? n.message : n.toString(); e.frameFailed.numberOfListeners > 0 ? e.frameFailed.raiseEvent({ uri: t, message: i }) : (console.log(`A frame failed to load: ${t}`), console.log(`Error: ${i}`)) } } function Mdt(e, t, n) { let i = CA(e, t), o = e._frames, r = o[i]; if (!l(r)) { let s = t.data.transform, a = l(s) ? F.fromArray(s) : void 0, c = t.data.uri; r = { pointCloud: void 0, transform: a, timestamp: Ei(), sequential: !0, ready: !1, touchedFrameNumber: n.frameNumber }, o[i] = r, Pe.fetchArrayBuffer({ url: c }).then(function (u) { return r.pointCloud = new hU({ arrayBuffer: u, cull: !0, fragmentShaderLoaded: wdt, uniformMapLoaded: Ddt(e), pickIdLoaded: vdt }), r.pointCloud.readyPromise }).catch(Rdt(e, c)) } return r } function Ldt(e, t) { e._runningSum += t, e._runningSum -= e._runningSamples[e._runningIndex], e._runningSamples[e._runningIndex] = t, e._runningLength = Math.min(e._runningLength + 1, e._runningSamples.length), e._runningIndex = (e._runningIndex + 1) % e._runningSamples.length, e._runningAverage = e._runningSum / e._runningLength } function Fdt(e, t, n, i) { t.touchedFrameNumber < i.frameNumber - 1 && (t.sequential = !1); let o = t.pointCloud; if (l(o) && !t.ready) { let r = i.commandList, s = r.length; if (d0e(e, t, n, i), o.ready && (t.ready = !0, e._totalMemoryUsageInBytes += o.geometryByteLength, r.length = s, t.sequential)) { let a = (Ei() - t.timestamp) / 1e3; Ldt(e, a) } } t.touchedFrameNumber = i.frameNumber } var Ndt = new F; function Vdt(e, t) { let n = e.shading; return l(n) && l(n.baseResolution) ? n.baseResolution : l(t.boundingSphere) ? I.cbrt(t.boundingSphere.volume() / t.pointsLength) : 0 } function kdt(e) { let t = e.shading; return l(t) && l(t.maximumAttenuation) ? t.maximumAttenuation : 10 } var Udt = new bm; function d0e(e, t, n, i) { let o = y(e.shading, Udt), r = t.pointCloud, s = y(t.transform, F.IDENTITY); r.modelMatrix = F.multiplyTransformation(e.modelMatrix, s, Ndt), r.style = e.style, r.time = n.timeSinceLoad, r.shadows = e.shadows, r.clippingPlanes = e._clippingPlanes, r.isClipped = n.isClipped, r.attenuation = o.attenuation, r.backFaceCulling = o.backFaceCulling, r.normalShading = o.normalShading, r.geometricError = Vdt(e, r), r.geometricErrorScale = o.geometricErrorScale, r.maximumAttenuation = kdt(e), r.update(i), t.touchedFrameNumber = i.frameNumber } function dq(e, t, n, i) { let o = Mdt(e, t, i); Fdt(e, o, n, i) } function zdt(e) { return function (t) { return t.touchedFrameNumber < e.frameNumber } } function h0e(e, t) { let n = e._frames, i = n.length; for (let o = 0; o < i; ++o) { let r = n[o]; if (l(r) && (!l(t) || t(r))) { let s = r.pointCloud; r.ready && (e._totalMemoryUsageInBytes -= s.geometryByteLength), l(s) && s.destroy(), r === e._lastRenderedFrame && (e._lastRenderedFrame = void 0), n[o] = void 0 } } } function Hdt(e, t) { let n = CA(e, t), i = e._frames[n]; if (l(i) && i.ready) return i } function f0e(e, t, n, i, o) { return l(n) ? n.ready ? !0 : (dq(e, t, i, o), n.ready) : !1 } function Gdt(e, t, n, i, o) { let r, s, a, c = e._intervals, u = e._frames, f = CA(e, n), d = CA(e, t); if (f >= d) { for (r = f; r >= d; --r)if (s = c.get(r), a = u[r], f0e(e, s, a, i, o)) return s } else for (r = f; r <= d; ++r)if (s = c.get(r), a = u[r], f0e(e, s, a, i, o)) return s; return t } function Wdt(e, t, n) { let i = e._frames, o = i.length; for (let r = 0; r < o; ++r) { let s = i[r]; l(s) && l(s.pointCloud) && (s.pointCloud.clippingPlanesDirty = t, s.pointCloud.styleDirty = n) } } var YE = { timeSinceLoad: 0, isClipped: !1, clippingPlanesDirty: !1 }; xA.prototype.update = function (e) { if (e.mode === ee.MORPHING || !this.show) return; l(this._pickId) || (this._pickId = e.context.createPickId({ primitive: this })), l(this._loadTimestamp) || (this._loadTimestamp = $.clone(e.time)); let t = Math.max($.secondsDifference(e.time, this._loadTimestamp) * 1e3, 0), n = this._clippingPlanes, i = 0, o = !1, r = l(n) && n.enabled; r && (n.update(e), i = n.clippingPlanesState), this._clippingPlanesState !== i && (this._clippingPlanesState = i, o = !0); let s = this._styleDirty; this._styleDirty = !1, (o || s) && Wdt(this, o, s), YE.timeSinceLoad = t, YE.isClipped = r; let a = this.shading, c = this._pointCloudEyeDomeLighting, u = e.commandList, f = u.length, d = this._previousInterval, p = this._nextInterval, g = Odt(this); if (!l(g)) return; let m = !1, A = hq(this), C = A === 0; A !== this._clockMultiplier && (m = !0, this._clockMultiplier = A), (!l(d) || C) && (d = g), (!l(p) || m || Bdt(this, g, p)) && (p = Idt(this, g)), d = Gdt(this, d, g, YE, e); let x = Hdt(this, d); l(x) || (dq(this, d, YE, e), x = this._lastRenderedFrame), l(x) && d0e(this, x, YE, e), l(p) && dq(this, p, YE, e); let T = this; l(x) && !l(this._lastRenderedFrame) && e.afterRender.push(function () { T._resolveReadyPromise(T) }), l(x) && x !== this._lastRenderedFrame && T.frameChanged.numberOfListeners > 0 && e.afterRender.push(function () { T.frameChanged.raiseEvent(T) }), this._previousInterval = d, this._nextInterval = p, this._lastRenderedFrame = x; let b = this._totalMemoryUsageInBytes, S = this.maximumMemoryUsage * 1024 * 1024; b > S && h0e(this, zdt(e)); let P = u.length - f; l(a) && a.attenuation && a.eyeDomeLighting && P > 0 && c.update(e, f, a, this.boundingSphere) }; xA.prototype.isDestroyed = function () { return !1 }; xA.prototype.destroy = function () { return h0e(this), this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy(), this._pickId = this._pickId && this._pickId.destroy(), le(this) }; var Vv = xA; var l4 = `varying vec2 v_textureCoordinates;
void main()
{
czm_materialInput materialInput;
materialInput.s = v_textureCoordinates.s;
materialInput.st = v_textureCoordinates;
materialInput.str = vec3(v_textureCoordinates, 0.0);
materialInput.normalEC = vec3(0.0, 0.0, -1.0);
czm_material material = czm_getMaterial(materialInput);
gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);
}
`; function u4(e, t) { this.show = !0, l(e) || (e = new Ge), this.rectangle = Ge.clone(e), l(t) || (t = Ki.fromType(Ki.ColorType, { color: new U(1, 1, 1, 1) })), this.material = t, this._material = void 0, this._overlayCommand = void 0, this._rs = void 0 } u4.prototype.update = function (e) { if (!this.show) return; let t = this._rs; if ((!l(t) || !Ge.equals(t.viewport, this.rectangle)) && (this._rs = Ve.fromCache({ blending: an.ALPHA_BLEND, viewport: this.rectangle })), e.passes.render) { let i = e.context; if (this._material !== this.material || !l(this._overlayCommand)) { this._material = this.material, l(this._overlayCommand) && this._overlayCommand.shaderProgram.destroy(); let o = new Ue({ sources: [this._material.shaderSource, l4] }); this._overlayCommand = i.createViewportQuadCommand(o, { renderState: this._rs, uniformMap: this._material._uniforms, owner: this }), this._overlayCommand.pass = xe.OVERLAY } this._material.update(i), this._overlayCommand.renderState = this._rs, this._overlayCommand.uniformMap = this._material._uniforms, e.commandList.push(this._overlayCommand) } }; u4.prototype.isDestroyed = function () { return !1 }; u4.prototype.destroy = function () { return l(this._overlayCommand) && (this._overlayCommand.shaderProgram = this._overlayCommand.shaderProgram && this._overlayCommand.shaderProgram.destroy()), le(this) }; var m0e = u4; function kv(e) { l(e) || (e = new sh), this._clock = e, this._eventHelper = new Pr, this._eventHelper.add(e.onTick, this.synchronize, this), this.systemTime = Ae.observable($.now()), this.systemTime.equalityComparer = $.equals, this.startTime = Ae.observable(e.startTime), this.startTime.equalityComparer = $.equals, this.startTime.subscribe(function (t) { e.startTime = t, this.synchronize() }, this), this.stopTime = Ae.observable(e.stopTime), this.stopTime.equalityComparer = $.equals, this.stopTime.subscribe(function (t) { e.stopTime = t, this.synchronize() }, this), this.currentTime = Ae.observable(e.currentTime), this.currentTime.equalityComparer = $.equals, this.currentTime.subscribe(function (t) { e.currentTime = t, this.synchronize() }, this), this.multiplier = Ae.observable(e.multiplier), this.multiplier.subscribe(function (t) { e.multiplier = t, this.synchronize() }, this), this.clockStep = Ae.observable(e.clockStep), this.clockStep.subscribe(function (t) { e.clockStep = t, this.synchronize() }, this), this.clockRange = Ae.observable(e.clockRange), this.clockRange.subscribe(function (t) { e.clockRange = t, this.synchronize() }, this), this.canAnimate = Ae.observable(e.canAnimate), this.canAnimate.subscribe(function (t) { e.canAnimate = t, this.synchronize() }, this), this.shouldAnimate = Ae.observable(e.shouldAnimate), this.shouldAnimate.subscribe(function (t) { e.shouldAnimate = t, this.synchronize() }, this), Ae.track(this, ["systemTime", "startTime", "stopTime", "currentTime", "multiplier", "clockStep", "clockRange", "canAnimate", "shouldAnimate"]) } Object.defineProperties(kv.prototype, { clock: { get: function () { return this._clock } } }); kv.prototype.synchronize = function () { let e = this._clock; this.systemTime = $.now(), this.startTime = e.startTime, this.stopTime = e.stopTime, this.currentTime = e.currentTime, this.multiplier = e.multiplier, this.clockStep = e.clockStep, this.clockRange = e.clockRange, this.canAnimate = e.canAnimate, this.shouldAnimate = e.shouldAnimate }; kv.prototype.isDestroyed = function () { return !1 }; kv.prototype.destroy = function () { this._eventHelper.removeAll(), le(this) }; var f4 = kv; function jdt() { this.canExecute = void 0, this.beforeExecute = void 0, this.afterExecute = void 0, ye.throwInstantiationError() } var p0e = jdt; function qdt(e, t) { t = y(t, !0); let n = new _e, i = new _e; function o() { let r = { args: arguments, cancel: !1 }, s; return n.raiseEvent(r), r.cancel || (s = e.apply(null, arguments), i.raiseEvent(s)), s } return o.canExecute = t, Ae.track(o, ["canExecute"]), Object.defineProperties(o, { beforeExecute: { value: n }, afterExecute: { value: i } }), o } var An = qdt; var mq = {}; mq.createCheckbox = function (e, t, n) { let i = document.createElement("div"), o = document.createElement("label"), r = document.createElement("input"); r.type = "checkbox"; let s = `checked: ${t}`; return l(n) && (s += `, enable: ${n}`), r.setAttribute("data-bind", s), o.appendChild(r), o.appendChild(document.createTextNode(e)), i.appendChild(o), i }; mq.createSection = function (e, t, n, i) { let o = document.createElement("div"); o.className = "cesium-cesiumInspector-section", o.setAttribute("data-bind", `css: { "cesium-cesiumInspector-section-collapsed": !${n} }`), e.appendChild(o); let r = document.createElement("h3"); r.className = "cesium-cesiumInspector-sectionHeader", r.appendChild(document.createTextNode(t)), r.setAttribute("data-bind", `click: ${i}`), o.appendChild(r); let s = document.createElement("div"); return s.className = "cesium-cesiumInspector-sectionContent", o.appendChild(s), s }; var Zg = mq; function Ydt(e, t, n, i, o) { return n.call(i, e[t]), Ae.getObservable(e, t).subscribe(n, i, o) } var aa = Ydt; function _0e(e, t) { this._command = e, t = y(t, y.EMPTY_OBJECT), this.toggled = y(t.toggled, !1), this.tooltip = y(t.tooltip, ""), Ae.track(this, ["toggled", "tooltip"]) } Object.defineProperties(_0e.prototype, { command: { get: function () { return this._command } } }); var TA = _0e; var Xdt = { FLOAT: "float", VEC2: "vec2", VEC3: "vec3", VEC4: "vec4", INT: "int", INT_VEC2: "ivec2", INT_VEC3: "ivec3", INT_VEC4: "ivec4", BOOL: "bool", BOOL_VEC2: "bvec2", BOOL_VEC3: "bvec3", BOOL_VEC4: "bvec4", MAT2: "mat2", MAT3: "mat2", MAT4: "mat4", SAMPLER_2D: "sampler2D", SAMPLER_CUBE: "samplerCube" }, Uv = Object.freeze(Xdt); function XE() { this._defaultTexture = void 0, this._textures = {}, this._loadedImages = [], this._lastUpdatedFrame = -1 } XE.prototype.getTexture = function (e) { return this._textures[e] }; function Kdt(e, t, n) { n.resource.fetchImage().then(function (i) { e._loadedImages.push({ id: t, image: i, textureUniform: n }) }).catch(function () { let i = e._textures[t]; l(i) && i !== e._defaultTexture && i.destroy(), e._textures[t] = e._defaultTexture }) } XE.prototype.loadTexture2D = function (e, t) { l(t.typedArray) ? this._loadedImages.push({ id: e, textureUniform: t }) : Kdt(this, e, t) }; function Jdt(e, t, n) { let { id: i, textureUniform: o, image: r } = t, s = n.webgl2 ? d4(o, r, n) : Zdt(o, r, n), a = e._textures[i]; l(a) && a !== n.defaultTexture && a.destroy(), e._textures[i] = s } function d4(e, t, n) { let { typedArray: i, sampler: o } = e, r = l(i) ? y0e(e, n) : new Rt({ context: n, source: t, sampler: o }); return g0e(o) && r.generateMipmap(), r } function Zdt(e, t, n) { let { typedArray: i, sampler: o } = e, r = g0e(o), s = o.wrapS === In.REPEAT || o.wrapS === In.MIRRORED_REPEAT || o.wrapT === In.REPEAT || o.wrapT === In.MIRRORED_REPEAT, { width: a, height: c } = l(i) ? e : t, u = [a, c].every(I.isPowerOfTwo); if ((r || s) && !u) if (l(i)) { if (e.pixelDatatype === Ye.UNSIGNED_BYTE) { let d = G3(i, a, c), p = V0(d); return d4({ sampler: o }, p, n) } } else { let d = V0(t); return d4(e, d, n) } else return d4(e, t, n); return r ? console.warn("Texture requires resizing for mipmaps but pixelDataType cannot be resized. The texture may be rendered incorrectly.") : s && console.warn("Texture requires resizing for wrapping but pixelDataType cannot be resized. The texture may be rendered incorrectly."), y0e(e, n) } function g0e(e) { return [ln.NEAREST_MIPMAP_NEAREST, ln.NEAREST_MIPMAP_LINEAR, ln.LINEAR_MIPMAP_NEAREST, ln.LINEAR_MIPMAP_LINEAR].includes(e.minificationFilter) } function y0e(e, t) { let { pixelFormat: n, pixelDatatype: i, width: o, height: r, typedArray: s, sampler: a } = e; return new Rt({ context: t, pixelFormat: n, pixelDatatype: i, source: { arrayBufferView: s, width: o, height: r }, sampler: a, flipY: !1 }) } XE.prototype.update = function (e) { if (e.frameNumber === this._lastUpdatedFrame) return; this._lastUpdatedFrame = e.frameNumber; let t = e.context; this._defaultTexture = t.defaultTexture; let n = this._loadedImages; for (let i = 0; i < n.length; i++) { let o = n[i]; Jdt(this, o, t) } n.length = 0 }; XE.prototype.isDestroyed = function () { return !1 }; XE.prototype.destroy = function () { let e = this._textures; for (let t in e) if (e.hasOwnProperty(t)) { let n = e[t]; n !== this._defaultTexture && n.destroy() } return le(this) }; var h4 = XE; function zv(e) { e = y(e, y.EMPTY_OBJECT), this.mode = y(e.mode, C_.MODIFY_MATERIAL), this.lightingModel = e.lightingModel, this.uniforms = y(e.uniforms, y.EMPTY_OBJECT), this.varyings = y(e.varyings, y.EMPTY_OBJECT), this.vertexShaderText = e.vertexShaderText, this.fragmentShaderText = e.fragmentShaderText, this.translucencyMode = y(e.translucencyMode, X0.INHERIT), this._textureManager = new h4, this._defaultTexture = void 0, this.uniformMap = Qdt(this), this.usedVariablesVertex = { attributeSet: {}, featureIdSet: {}, metadataSet: {} }, this.usedVariablesFragment = { attributeSet: {}, featureIdSet: {}, metadataSet: {}, materialSet: {} }, tht(this), nht(this) } function Qdt(e) { let t = e.uniforms, n = {}; for (let i in t) if (t.hasOwnProperty(i)) { let o = t[i]; o.type === Uv.SAMPLER_2D ? (e._textureManager.loadTexture2D(i, o.value), n[i] = $dt(e, i)) : n[i] = eht(e, i) } return n } function $dt(e, t) { return function () { return y(e._textureManager.getTexture(t), e._defaultTexture) } } function eht(e, t) { return function () { return e.uniforms[t].value } } function EA(e, t, n) { let i; for (; (i = t.exec(e)) !== null;) { let o = i[1]; n[o] = !0 } } function tht(e) { let t = /[vf]sInput\.attributes\.(\w+)/g, n = /[vf]sInput\.featureIds\.(\w+)/g, i = /[vf]sInput\.metadata.(\w+)/g, o, r = e.vertexShaderText; l(r) && (o = e.usedVariablesVertex.attributeSet, EA(r, t, o), o = e.usedVariablesVertex.featureIdSet, EA(r, n, o), o = e.usedVariablesVertex.metadataSet, EA(r, i, o)); let s = e.fragmentShaderText; if (l(s)) { o = e.usedVariablesFragment.attributeSet, EA(s, t, o), o = e.usedVariablesFragment.featureIdSet, EA(s, n, o), o = e.usedVariablesFragment.metadataSet, EA(s, i, o); let a = /material\.(\w+)/g, c = e.usedVariablesFragment.materialSet; EA(s, a, c) } } function A0e(e) { let t = /^.*MC$/, n = /^.*WC$/, i = /^.*EC$/; return t.test(e) ? `${e} (model coordinates)` : n.test(e) ? `${e} (Cartesian world coordinates)` : i.test(e) ? `${e} (eye coordinates)` : e } function Ga(e, t, n, i) { if (e.hasOwnProperty(t)) { let o = `${A0e(t)} is not available in the ${i} shader. Did you mean ${A0e(n)} instead?`; throw new ye(o) } } function nht(e) { let t = e.usedVariablesVertex.attributeSet; Ga(t, "position", "positionMC", "vertex"), Ga(t, "normal", "normalMC", "vertex"), Ga(t, "tangent", "tangentMC", "vertex"), Ga(t, "bitangent", "bitangentMC", "vertex"), Ga(t, "positionWC", "positionMC", "vertex"), Ga(t, "positionEC", "positionMC", "vertex"), Ga(t, "normalEC", "normalMC", "vertex"), Ga(t, "tangentEC", "tangentMC", "vertex"), Ga(t, "bitangentEC", "bitangentMC", "vertex"); let n = e.usedVariablesFragment.attributeSet; Ga(n, "position", "positionEC", "fragment"), Ga(n, "normal", "normalEC", "fragment"), Ga(n, "tangent", "tangentEC", "fragment"), Ga(n, "bitangent", "bitangentEC", "fragment"), Ga(n, "normalMC", "normalEC", "fragment"), Ga(n, "tangentMC", "tangentEC", "fragment"), Ga(n, "bitangentMC", "bitangentEC", "fragment") } zv.prototype.setUniform = function (e, t) { let n = this.uniforms[e]; n.type === Uv.SAMPLER_2D ? this._textureManager.loadTexture2D(e, t) : l(t.clone) ? n.value = t.clone(n.value) : n.value = t }; zv.prototype.update = function (e) { this._defaultTexture = e.context.defaultTexture, this._textureManager.update(e) }; zv.prototype.isDestroyed = function () { return !1 }; zv.prototype.destroy = function () { this._textureManager = this._textureManager && this._textureManager.destroy(), le(this) }; var C0e = zv; function iht(e) { e = y(e, y.EMPTY_OBJECT), this.typedArray = e.typedArray, this.width = e.width, this.height = e.height, this.pixelFormat = y(e.pixelFormat, ht.RGBA), this.pixelDatatype = y(e.pixelDatatype, Ye.UNSIGNED_BYTE); let t = e.url; typeof t == "string" && (t = Pe.createIfNeeded(t)), this.resource = t; let i = y(e.repeat, !0) ? In.REPEAT : In.CLAMP_TO_EDGE; this.sampler = new dn({ wrapS: i, wrapT: i, minificationFilter: e.minificationFilter, magnificationFilter: e.magnificationFilter, maximumAnisotropy: e.maximumAnisotropy }) } var x0e = iht; var oht = { FLOAT: "float", VEC2: "vec2", VEC3: "vec3", VEC4: "vec4", MAT2: "mat2", MAT3: "mat2", MAT4: "mat4" }, T0e = Object.freeze(oht); function E0e(e) {
        e = y(e, y.EMPTY_OBJECT); let t = e.globe, n = y(e.imageryProviderViewModels, []), i = y(e.terrainProviderViewModels, []); this._globe = t, this.imageryProviderViewModels = n.slice(0), this.terrainProviderViewModels = i.slice(0), this.dropDownVisible = !1, Ae.track(this, ["imageryProviderViewModels", "terrainProviderViewModels", "dropDownVisible"]); let o = Ae.getObservable(this, "imageryProviderViewModels"), r = Ae.pureComputed(function () { let d = o(), p = {}, g; for (g = 0; g < d.length; g++) { let C = d[g], x = C.category; l(p[x]) ? p[x].push(C) : p[x] = [C] } let m = Object.keys(p), A = []; for (g = 0; g < m.length; g++) { let C = m[g]; A.push({ name: C, providers: p[C] }) } return A }); this._imageryProviders = r; let s = Ae.getObservable(this, "terrainProviderViewModels"), a = Ae.pureComputed(function () { let d = s(), p = {}, g; for (g = 0; g < d.length; g++) { let C = d[g], x = C.category; l(p[x]) ? p[x].push(C) : p[x] = [C] } let m = Object.keys(p), A = []; for (g = 0; g < m.length; g++) { let C = m[g]; A.push({ name: C, providers: p[C] }) } return A }); this._terrainProviders = a, this.buttonTooltip = void 0, Ae.defineProperty(this, "buttonTooltip", function () {
            let d = this.selectedImagery, p = this.selectedTerrain, g = l(d) ? d.name : void 0, m = l(p) ? p.name : void 0; return l(g) && l(m) ? `${g}
${m}` : l(g) ? g : m
        }), this.buttonImageUrl = void 0, Ae.defineProperty(this, "buttonImageUrl", function () { let d = this.selectedImagery; if (l(d)) return d.iconUrl }), this.selectedImagery = void 0; let c = Ae.observable(); this._currentImageryProviders = [], Ae.defineProperty(this, "selectedImagery", { get: function () { return c() }, set: function (d) { if (c() === d) { this.dropDownVisible = !1; return } let p, g = this._currentImageryProviders, m = g.length, A = this._globe.imageryLayers, C = !1; for (p = 0; p < m; p++) { let x = A.length; for (let T = 0; T < x; T++) { let b = A.get(T); if (b.imageryProvider === g[p]) { A.remove(b), C = !0; break } } } if (l(d)) { let x = d.creationCommand(); if (Array.isArray(x)) { let T = x.length; for (p = T - 1; p >= 0; p--)A.addImageryProvider(x[p], 0); this._currentImageryProviders = x.slice(0) } else if (this._currentImageryProviders = [x], C) A.addImageryProvider(x, 0); else { let T = A.get(0); l(T) && A.remove(T), A.addImageryProvider(x, 0) } } c(d), this.dropDownVisible = !1 } }), this.selectedTerrain = void 0; let u = Ae.observable(); Ae.defineProperty(this, "selectedTerrain", { get: function () { return u() }, set: function (d) { if (u() === d) { this.dropDownVisible = !1; return } let p; l(d) && (p = d.creationCommand()), this._globe.depthTestAgainstTerrain = !(p instanceof Pg), this._globe.terrainProvider = p, u(d), this.dropDownVisible = !1 } }); let f = this; this._toggleDropDown = An(function () { f.dropDownVisible = !f.dropDownVisible }), this.selectedImagery = y(e.selectedImageryProviderViewModel, n[0]), this.selectedTerrain = y(e.selectedTerrainProviderViewModel, i[0])
    } Object.defineProperties(E0e.prototype, { toggleDropDown: { get: function () { return this._toggleDropDown } }, globe: { get: function () { return this._globe } } }); var m4 = E0e; function p4(e, t) { e = vn(e); let n = new m4(t), i = document.createElement("button"); i.type = "button", i.className = "cesium-button cesium-toolbar-button", i.setAttribute("data-bind", "attr: { title: buttonTooltip },click: toggleDropDown"), e.appendChild(i); let o = document.createElement("img"); o.setAttribute("draggable", "false"), o.className = "cesium-baseLayerPicker-selected", o.setAttribute("data-bind", "attr: { src: buttonImageUrl }, visible: !!buttonImageUrl"), i.appendChild(o); let r = document.createElement("div"); r.className = "cesium-baseLayerPicker-dropDown", r.setAttribute("data-bind", 'css: { "cesium-baseLayerPicker-dropDown-visible" : dropDownVisible }'), e.appendChild(r); let s = document.createElement("div"); s.className = "cesium-baseLayerPicker-sectionTitle", s.setAttribute("data-bind", "visible: imageryProviderViewModels.length > 0"), s.innerHTML = "Imagery", r.appendChild(s); let a = document.createElement("div"); a.className = "cesium-baseLayerPicker-section", a.setAttribute("data-bind", "foreach: _imageryProviders"), r.appendChild(a); let c = document.createElement("div"); c.className = "cesium-baseLayerPicker-category", a.appendChild(c); let u = document.createElement("div"); u.className = "cesium-baseLayerPicker-categoryTitle", u.setAttribute("data-bind", "text: name"), c.appendChild(u); let f = document.createElement("div"); f.className = "cesium-baseLayerPicker-choices", f.setAttribute("data-bind", "foreach: providers"), c.appendChild(f); let d = document.createElement("div"); d.className = "cesium-baseLayerPicker-item", d.setAttribute("data-bind", 'css: { "cesium-baseLayerPicker-selectedItem" : $data === $parents[1].selectedImagery },attr: { title: tooltip },visible: creationCommand.canExecute,click: function($data) { $parents[1].selectedImagery = $data; }'), f.appendChild(d); let p = document.createElement("img"); p.className = "cesium-baseLayerPicker-itemIcon", p.setAttribute("data-bind", "attr: { src: iconUrl }"), p.setAttribute("draggable", "false"), d.appendChild(p); let g = document.createElement("div"); g.className = "cesium-baseLayerPicker-itemLabel", g.setAttribute("data-bind", "text: name"), d.appendChild(g); let m = document.createElement("div"); m.className = "cesium-baseLayerPicker-sectionTitle", m.setAttribute("data-bind", "visible: terrainProviderViewModels.length > 0"), m.innerHTML = "Terrain", r.appendChild(m); let A = document.createElement("div"); A.className = "cesium-baseLayerPicker-section", A.setAttribute("data-bind", "foreach: _terrainProviders"), r.appendChild(A); let C = document.createElement("div"); C.className = "cesium-baseLayerPicker-category", A.appendChild(C); let x = document.createElement("div"); x.className = "cesium-baseLayerPicker-categoryTitle", x.setAttribute("data-bind", "text: name"), C.appendChild(x); let T = document.createElement("div"); T.className = "cesium-baseLayerPicker-choices", T.setAttribute("data-bind", "foreach: providers"), C.appendChild(T); let b = document.createElement("div"); b.className = "cesium-baseLayerPicker-item", b.setAttribute("data-bind", 'css: { "cesium-baseLayerPicker-selectedItem" : $data === $parents[1].selectedTerrain },attr: { title: tooltip },visible: creationCommand.canExecute,click: function($data) { $parents[1].selectedTerrain = $data; }'), T.appendChild(b); let S = document.createElement("img"); S.className = "cesium-baseLayerPicker-itemIcon", S.setAttribute("data-bind", "attr: { src: iconUrl }"), S.setAttribute("draggable", "false"), b.appendChild(S); let D = document.createElement("div"); D.className = "cesium-baseLayerPicker-itemLabel", D.setAttribute("data-bind", "text: name"), b.appendChild(D), Ae.applyBindings(n, i), Ae.applyBindings(n, r), this._viewModel = n, this._container = e, this._element = i, this._dropPanel = r, this._closeDropDown = function (P) { i.contains(P.target) || r.contains(P.target) || (n.dropDownVisible = !1) }, Nt.supportsPointerEvents() ? document.addEventListener("pointerdown", this._closeDropDown, !0) : (document.addEventListener("mousedown", this._closeDropDown, !0), document.addEventListener("touchstart", this._closeDropDown, !0)) } Object.defineProperties(p4.prototype, { container: { get: function () { return this._container } }, viewModel: { get: function () { return this._viewModel } } }); p4.prototype.isDestroyed = function () { return !1 }; p4.prototype.destroy = function () { return Nt.supportsPointerEvents() ? document.removeEventListener("pointerdown", this._closeDropDown, !0) : (document.removeEventListener("mousedown", this._closeDropDown, !0), document.removeEventListener("touchstart", this._closeDropDown, !0)), Ae.cleanNode(this._element), Ae.cleanNode(this._dropPanel), this._container.removeChild(this._element), this._container.removeChild(this._dropPanel), le(this) }; var _4 = p4; function b0e(e) { let t = e.creationFunction; l(t.canExecute) || (t = An(t)), this._creationCommand = t, this.name = e.name, this.tooltip = e.tooltip, this.iconUrl = e.iconUrl, this._category = y(e.category, ""), Ae.track(this, ["name", "tooltip", "iconUrl"]) } Object.defineProperties(b0e.prototype, { creationCommand: { get: function () { return this._creationCommand } }, category: { get: function () { return this._category } } }); var _s = b0e; function rht() {
        let e = []; return e.push(new _s({ name: "Bing Maps Aerial", iconUrl: Jt("Widgets/Images/ImageryProviders/bingAerial.png"), tooltip: "Bing Maps aerial imagery, provided by Cesium ion", category: "Cesium ion", creationFunction: function () { return Ug({ style: kg.AERIAL }) } })), e.push(new _s({ name: "Bing Maps Aerial with Labels", iconUrl: Jt("Widgets/Images/ImageryProviders/bingAerialLabels.png"), tooltip: "Bing Maps aerial imagery with labels, provided by Cesium ion", category: "Cesium ion", creationFunction: function () { return Ug({ style: kg.AERIAL_WITH_LABELS }) } })), e.push(new _s({ name: "Bing Maps Roads", iconUrl: Jt("Widgets/Images/ImageryProviders/bingRoads.png"), tooltip: "Bing Maps standard road maps, provided by Cesium ion", category: "Cesium ion", creationFunction: function () { return Ug({ style: kg.ROAD }) } })), e.push(new _s({
            name: "ESRI World Imagery", iconUrl: Jt("Widgets/Images/ImageryProviders/esriWorldImagery.png"), tooltip: `World Imagery provides one meter or better satellite and aerial imagery in many parts of the world and lower resolution satellite imagery worldwide.  The map includes NASA Blue Marble: Next Generation 500m resolution imagery at small scales (above 1:1,000,000), i-cubed 15m eSAT imagery at medium-to-large scales (down to 1:70,000) for the world, and USGS 15m Landsat imagery for Antarctica. The map features 0.3m resolution imagery in the continental United States and 0.6m resolution imagery in parts of Western Europe from DigitalGlobe. In other parts of the world, 1 meter resolution imagery is available from GeoEye IKONOS, i-cubed Nationwide Prime, Getmapping, AeroGRID, IGN Spain, and IGP Portugal.  Additionally, imagery at different resolutions has been contributed by the GIS User Community.
http://www.esri.com`, category: "Other", creationFunction: function () { return new Mg({ url: "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer", enablePickFeatures: !1 }) }
        })), e.push(new _s({
            name: "ESRI World Street Map", iconUrl: Jt("Widgets/Images/ImageryProviders/esriWorldStreetMap.png"), tooltip: `This worldwide street map presents highway-level data for the world. Street-level data includes the United States; much of Canada; Japan; most countries in Europe; Australia and New Zealand; India; parts of South America including Argentina, Brazil, Chile, Colombia, and Venezuela; Ghana; and parts of southern Africa including Botswana, Lesotho, Namibia, South Africa, and Swaziland.
http://www.esri.com`, category: "Other", creationFunction: function () { return new Mg({ url: "https://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer", enablePickFeatures: !1 }) }
        })), e.push(new _s({
            name: "ESRI National Geographic", iconUrl: Jt("Widgets/Images/ImageryProviders/esriNationalGeographic.png"), tooltip: `This web map contains the National Geographic World Map service. This map service is designed to be used as a general reference map for informational and educational purposes as well as a basemap by GIS professionals and other users for creating web maps and web mapping applications.
http://www.esri.com`, category: "Other", creationFunction: function () { return new Mg({ url: "https://services.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/", enablePickFeatures: !1 }) }
        })), e.push(new _s({
            name: "Open\xADStreet\xADMap", iconUrl: Jt("Widgets/Images/ImageryProviders/openStreetMap.png"), tooltip: `OpenStreetMap (OSM) is a collaborative project to create a free editable map of the world.
http://www.openstreetmap.org`, category: "Other", creationFunction: function () { return new NE({ url: "https://a.tile.openstreetmap.org/" }) }
        })), e.push(new _s({
            name: "Stamen Watercolor", iconUrl: Jt("Widgets/Images/ImageryProviders/stamenWatercolor.png"), tooltip: `Reminiscent of hand drawn maps, Stamen watercolor maps apply raster effect area washes and organic edges over a paper texture to add warm pop to any map.
http://maps.stamen.com`, category: "Other", creationFunction: function () { return new NE({ url: "https://stamen-tiles.a.ssl.fastly.net/watercolor/", credit: "Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under CC BY SA." }) }
        })), e.push(new _s({
            name: "Stamen Toner", iconUrl: Jt("Widgets/Images/ImageryProviders/stamenToner.png"), tooltip: `A high contrast black and white map.
http://maps.stamen.com`, category: "Other", creationFunction: function () { return new NE({ url: "https://stamen-tiles.a.ssl.fastly.net/toner/", credit: "Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under CC BY SA." }) }
        })), e.push(new _s({ name: "Sentinel-2", iconUrl: Jt("Widgets/Images/ImageryProviders/sentinel-2.png"), tooltip: "Sentinel-2 cloudless by EOX IT Services GmbH (Contains modified Copernicus Sentinel data 2016 and 2017).", category: "Cesium ion", creationFunction: function () { return new Vg({ assetId: 3954 }) } })), e.push(new _s({ name: "Blue Marble", iconUrl: Jt("Widgets/Images/ImageryProviders/blueMarble.png"), tooltip: "Blue Marble Next Generation July, 2004 imagery from NASA.", category: "Cesium ion", creationFunction: function () { return new Vg({ assetId: 3845 }) } })), e.push(new _s({ name: "Earth at night", iconUrl: Jt("Widgets/Images/ImageryProviders/earthAtNight.png"), tooltip: "The Earth at night, also known as The Black Marble, is a 500 meter resolution global composite imagery layer released by NASA.", category: "Cesium ion", creationFunction: function () { return new Vg({ assetId: 3812 }) } })), e.push(new _s({
            name: "Natural Earth\xA0II", iconUrl: Jt("Widgets/Images/ImageryProviders/naturalEarthII.png"), tooltip: `Natural Earth II, darkened for contrast.
http://www.naturalearthdata.com/`, category: "Cesium ion", creationFunction: function () { return new tA({ url: Jt("Assets/Textures/NaturalEarthII") }) }
        })), e
    } var g4 = rht; function sht() { let e = []; return e.push(new _s({ name: "WGS84 Ellipsoid", iconUrl: Jt("Widgets/Images/TerrainProviders/Ellipsoid.png"), tooltip: "WGS84 standard ellipsoid, also known as EPSG:4326", category: "Cesium ion", creationFunction: function () { return new Pg } })), e.push(new _s({ name: "Cesium World Terrain", iconUrl: Jt("Widgets/Images/TerrainProviders/CesiumWorldTerrain.png"), tooltip: "High-resolution global terrain tileset curated from several datasources and hosted by Cesium ion", category: "Cesium ion", creationFunction: function () { return V3({ requestWaterMask: !0, requestVertexNormals: !0 }) } })), e } var y4 = sht; var bA = "http://www.w3.org/2000/svg", D0e = "http://www.w3.org/1999/xlink", A4, Hv = U.fromCssColorString("rgba(247,250,255,0.384)"), C4 = U.fromCssColorString("rgba(143,191,255,0.216)"), pq = U.fromCssColorString("rgba(153,197,255,0.098)"), x4 = U.fromCssColorString("rgba(255,255,255,0.086)"), aht = U.fromCssColorString("rgba(255,255,255,0.267)"), cht = U.fromCssColorString("rgba(255,255,255,0)"), S0e = U.fromCssColorString("rgba(66,67,68,0.3)"), w0e = U.fromCssColorString("rgba(0,0,0,0.5)"); function Qg(e) { return U.fromCssColorString(window.getComputedStyle(e).getPropertyValue("color")) } var Gv = { animation_pathReset: { tagName: "path", transform: "translate(16,16) scale(0.85) translate(-16,-16)", d: "M24.316,5.318,9.833,13.682,9.833,5.5,5.5,5.5,5.5,25.5,9.833,25.5,9.833,17.318,24.316,25.682z" }, animation_pathPause: { tagName: "path", transform: "translate(16,16) scale(0.85) translate(-16,-16)", d: "M13,5.5,7.5,5.5,7.5,25.5,13,25.5zM24.5,5.5,19,5.5,19,25.5,24.5,25.5z" }, animation_pathPlay: { tagName: "path", transform: "translate(16,16) scale(0.85) translate(-16,-16)", d: "M6.684,25.682L24.316,15.5L6.684,5.318V25.682z" }, animation_pathPlayReverse: { tagName: "path", transform: "translate(16,16) scale(-0.85,0.85) translate(-16,-16)", d: "M6.684,25.682L24.316,15.5L6.684,5.318V25.682z" }, animation_pathLoop: { tagName: "path", transform: "translate(16,16) scale(0.85) translate(-16,-16)", d: "M24.249,15.499c-0.009,4.832-3.918,8.741-8.75,8.75c-2.515,0-4.768-1.064-6.365-2.763l2.068-1.442l-7.901-3.703l0.744,8.694l2.193-1.529c2.244,2.594,5.562,4.242,9.26,4.242c6.767,0,12.249-5.482,12.249-12.249H24.249zM15.499,6.75c2.516,0,4.769,1.065,6.367,2.764l-2.068,1.443l7.901,3.701l-0.746-8.693l-2.192,1.529c-2.245-2.594-5.562-4.245-9.262-4.245C8.734,3.25,3.25,8.734,3.249,15.499H6.75C6.758,10.668,10.668,6.758,15.499,6.75z" }, animation_pathClock: { tagName: "path", transform: "translate(16,16) scale(0.85) translate(-16,-15.5)", d: "M15.5,2.374C8.251,2.375,2.376,8.251,2.374,15.5C2.376,22.748,8.251,28.623,15.5,28.627c7.249-0.004,13.124-5.879,13.125-13.127C28.624,8.251,22.749,2.375,15.5,2.374zM15.5,25.623C9.909,25.615,5.385,21.09,5.375,15.5C5.385,9.909,9.909,5.384,15.5,5.374c5.59,0.01,10.115,4.535,10.124,10.125C25.615,21.09,21.091,25.615,15.5,25.623zM8.625,15.5c-0.001-0.552-0.448-0.999-1.001-1c-0.553,0-1,0.448-1,1c0,0.553,0.449,1,1,1C8.176,16.5,8.624,16.053,8.625,15.5zM8.179,18.572c-0.478,0.277-0.642,0.889-0.365,1.367c0.275,0.479,0.889,0.641,1.365,0.365c0.479-0.275,0.643-0.887,0.367-1.367C9.27,18.461,8.658,18.297,8.179,18.572zM9.18,10.696c-0.479-0.276-1.09-0.112-1.366,0.366s-0.111,1.09,0.365,1.366c0.479,0.276,1.09,0.113,1.367-0.366C9.821,11.584,9.657,10.973,9.18,10.696zM22.822,12.428c0.478-0.275,0.643-0.888,0.366-1.366c-0.275-0.478-0.89-0.642-1.366-0.366c-0.479,0.278-0.642,0.89-0.366,1.367C21.732,12.54,22.344,12.705,22.822,12.428zM12.062,21.455c-0.478-0.275-1.089-0.111-1.366,0.367c-0.275,0.479-0.111,1.09,0.366,1.365c0.478,0.277,1.091,0.111,1.365-0.365C12.704,22.344,12.54,21.732,12.062,21.455zM12.062,9.545c0.479-0.276,0.642-0.888,0.366-1.366c-0.276-0.478-0.888-0.642-1.366-0.366s-0.642,0.888-0.366,1.366C10.973,9.658,11.584,9.822,12.062,9.545zM22.823,18.572c-0.48-0.275-1.092-0.111-1.367,0.365c-0.275,0.479-0.112,1.092,0.367,1.367c0.477,0.275,1.089,0.113,1.365-0.365C23.464,19.461,23.3,18.848,22.823,18.572zM19.938,7.813c-0.477-0.276-1.091-0.111-1.365,0.366c-0.275,0.48-0.111,1.091,0.366,1.367s1.089,0.112,1.366-0.366C20.581,8.702,20.418,8.089,19.938,7.813zM23.378,14.5c-0.554,0.002-1.001,0.45-1.001,1c0.001,0.552,0.448,1,1.001,1c0.551,0,1-0.447,1-1C24.378,14.949,23.929,14.5,23.378,14.5zM15.501,6.624c-0.552,0-1,0.448-1,1l-0.466,7.343l-3.004,1.96c-0.478,0.277-0.642,0.889-0.365,1.365c0.275,0.479,0.889,0.643,1.365,0.367l3.305-1.676C15.39,16.99,15.444,17,15.501,17c0.828,0,1.5-0.671,1.5-1.5l-0.5-7.876C16.501,7.072,16.053,6.624,15.501,6.624zM15.501,22.377c-0.552,0-1,0.447-1,1s0.448,1,1,1s1-0.447,1-1S16.053,22.377,15.501,22.377zM18.939,21.455c-0.479,0.277-0.643,0.889-0.366,1.367c0.275,0.477,0.888,0.643,1.366,0.365c0.478-0.275,0.642-0.889,0.366-1.365C20.028,21.344,19.417,21.18,18.939,21.455z" }, animation_pathWingButton: { tagName: "path", d: "m 4.5,0.5 c -2.216,0 -4,1.784 -4,4 l 0,24 c 0,2.216 1.784,4 4,4 l 13.71875,0 C 22.478584,27.272785 27.273681,22.511272 32.5,18.25 l 0,-13.75 c 0,-2.216 -1.784,-4 -4,-4 l -24,0 z" }, animation_pathPointer: { tagName: "path", d: "M-15,-65,-15,-55,15,-55,15,-65,0,-95z" }, animation_pathSwooshFX: { tagName: "path", d: "m 85,0 c 0,16.617 -4.813944,35.356 -13.131081,48.4508 h 6.099803 c 8.317138,-13.0948 13.13322,-28.5955 13.13322,-45.2124 0,-46.94483 -38.402714,-85.00262 -85.7743869,-85.00262 -1.0218522,0 -2.0373001,0.0241 -3.0506131,0.0589 45.958443,1.59437 82.723058,35.77285 82.723058,81.70532 z" } }; function _d(e) { let t = document.createElementNS(bA, e.tagName); for (let n in e) if (e.hasOwnProperty(n) && n !== "tagName") if (n === "children") { let i = e.children.length; for (let o = 0; o < i; ++o)t.appendChild(_d(e.children[o])) } else n.indexOf("xlink:") === 0 ? t.setAttributeNS(D0e, n.substring(6), e[n]) : n === "textContent" ? t.textContent = e[n] : t.setAttribute(n, e[n]); return t } function _q(e, t, n) { let i = document.createElementNS(bA, "text"); i.setAttribute("x", e), i.setAttribute("y", t), i.setAttribute("class", "cesium-animation-svgText"); let o = document.createElementNS(bA, "tspan"); return o.textContent = n, i.appendChild(o), i } function lht(e, t, n) { e.setAttribute("transform", `translate(100,100) rotate(${n})`), t.setAttribute("transform", `rotate(${n})`) } var T4 = new U; function Lr(e, t) { let n = t.alpha, i = 1 - n; return T4.red = e.red * i + t.red * n, T4.green = e.green * i + t.green * n, T4.blue = e.blue * i + t.blue * n, T4.toCssColorString() } function gq(e, t, n) { let i = Gv[n], o = { tagName: "g", class: "cesium-animation-rectButton", transform: `translate(${e},${t})`, children: [{ tagName: "rect", class: "cesium-animation-buttonGlow", width: 32, height: 32, rx: 2, ry: 2 }, { tagName: "rect", class: "cesium-animation-buttonMain", width: 32, height: 32, rx: 4, ry: 4 }, { class: "cesium-animation-buttonPath", id: n, tagName: i.tagName, transform: i.transform, d: i.d }, { tagName: "title", textContent: "" }] }; return _d(o) } function uht(e, t, n) { let i = Gv[n], o = Gv.animation_pathWingButton, r = { tagName: "g", class: "cesium-animation-rectButton", transform: `translate(${e},${t})`, children: [{ class: "cesium-animation-buttonGlow", id: "animation_pathWingButton", tagName: o.tagName, d: o.d }, { class: "cesium-animation-buttonMain", id: "animation_pathWingButton", tagName: o.tagName, d: o.d }, { class: "cesium-animation-buttonPath", id: n, tagName: i.tagName, transform: i.transform, d: i.d }, { tagName: "title", textContent: "" }] }; return _d(r) } function fht(e, t) { let n = e._viewModel, i = n.shuttleRingDragging; if (!(i && A4 !== e)) if (t.type === "mousedown" || i && t.type === "mousemove" || t.type === "touchstart" && t.touches.length === 1 || i && t.type === "touchmove" && t.touches.length === 1) { let o = e._centerX, r = e._centerY, a = e._svgNode.getBoundingClientRect(), c, u; if (t.type === "touchstart" || t.type === "touchmove" ? (c = t.touches[0].clientX, u = t.touches[0].clientY) : (c = t.clientX, u = t.clientY), !i && (c > a.right || c < a.left || u < a.top || u > a.bottom)) return; let f = e._shuttleRingPointer.getBoundingClientRect(), d = c - o - a.left, p = u - r - a.top, g = Math.atan2(p, d) * 180 / Math.PI + 90; g > 180 && (g -= 360); let m = n.shuttleRingAngle; i || c < f.right && c > f.left && u > f.top && u < f.bottom ? (A4 = e, n.shuttleRingDragging = !0, n.shuttleRingAngle = g) : g < m ? n.slower() : g > m && n.faster(), t.preventDefault() } else e === A4 && (A4 = void 0), n.shuttleRingDragging = !1 } function Ap(e, t) { this._viewModel = t, this.svgElement = e, this._enabled = void 0, this._toggled = void 0; let n = this; this._clickFunction = function () { let i = n._viewModel.command; i.canExecute && i() }, e.addEventListener("click", this._clickFunction, !0), this._subscriptions = [aa(t, "toggled", this.setToggled, this), aa(t, "tooltip", this.setTooltip, this), aa(t.command, "canExecute", this.setEnabled, this)] } Ap.prototype.destroy = function () { this.svgElement.removeEventListener("click", this._clickFunction, !0); let e = this._subscriptions; for (let t = 0, n = e.length; t < n; t++)e[t].dispose(); le(this) }; Ap.prototype.isDestroyed = function () { return !1 }; Ap.prototype.setEnabled = function (e) { if (this._enabled !== e) { if (this._enabled = e, !e) { this.svgElement.setAttribute("class", "cesium-animation-buttonDisabled"); return } if (this._toggled) { this.svgElement.setAttribute("class", "cesium-animation-rectButton cesium-animation-buttonToggled"); return } this.svgElement.setAttribute("class", "cesium-animation-rectButton") } }; Ap.prototype.setToggled = function (e) { this._toggled !== e && (this._toggled = e, this._enabled && (e ? this.svgElement.setAttribute("class", "cesium-animation-rectButton cesium-animation-buttonToggled") : this.svgElement.setAttribute("class", "cesium-animation-rectButton"))) }; Ap.prototype.setTooltip = function (e) { this.svgElement.getElementsByTagName("title")[0].textContent = e }; function KE(e, t) { e = vn(e), this._viewModel = t, this._container = e, this._centerX = 0, this._centerY = 0, this._defsElement = void 0, this._svgNode = void 0, this._topG = void 0, this._lastHeight = void 0, this._lastWidth = void 0; let n = e.ownerDocument, i = document.createElement("style"); i.textContent = ".cesium-animation-rectButton .cesium-animation-buttonGlow { filter: url(#animation_blurred); }.cesium-animation-rectButton .cesium-animation-buttonMain { fill: url(#animation_buttonNormal); }.cesium-animation-buttonToggled .cesium-animation-buttonMain { fill: url(#animation_buttonToggled); }.cesium-animation-rectButton:hover .cesium-animation-buttonMain { fill: url(#animation_buttonHovered); }.cesium-animation-buttonDisabled .cesium-animation-buttonMain { fill: url(#animation_buttonDisabled); }.cesium-animation-shuttleRingG .cesium-animation-shuttleRingSwoosh { fill: url(#animation_shuttleRingSwooshGradient); }.cesium-animation-shuttleRingG:hover .cesium-animation-shuttleRingSwoosh { fill: url(#animation_shuttleRingSwooshHovered); }.cesium-animation-shuttleRingPointer { fill: url(#animation_shuttleRingPointerGradient); }.cesium-animation-shuttleRingPausePointer { fill: url(#animation_shuttleRingPointerPaused); }.cesium-animation-knobOuter { fill: url(#animation_knobOuter); }.cesium-animation-knobInner { fill: url(#animation_knobInner); }", n.head.insertBefore(i, n.head.childNodes[0]); let o = document.createElement("div"); o.className = "cesium-animation-theme", o.innerHTML = '<div class="cesium-animation-themeNormal"></div><div class="cesium-animation-themeHover"></div><div class="cesium-animation-themeSelect"></div><div class="cesium-animation-themeDisabled"></div><div class="cesium-animation-themeKnob"></div><div class="cesium-animation-themePointer"></div><div class="cesium-animation-themeSwoosh"></div><div class="cesium-animation-themeSwooshHover"></div>', this._theme = o, this._themeNormal = o.childNodes[0], this._themeHover = o.childNodes[1], this._themeSelect = o.childNodes[2], this._themeDisabled = o.childNodes[3], this._themeKnob = o.childNodes[4], this._themePointer = o.childNodes[5], this._themeSwoosh = o.childNodes[6], this._themeSwooshHover = o.childNodes[7]; let r = document.createElementNS(bA, "svg:svg"); this._svgNode = r, r.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", D0e); let s = document.createElementNS(bA, "g"); this._topG = s, this._realtimeSVG = new Ap(uht(3, 4, "animation_pathClock"), t.playRealtimeViewModel), this._playReverseSVG = new Ap(gq(44, 99, "animation_pathPlayReverse"), t.playReverseViewModel), this._playForwardSVG = new Ap(gq(124, 99, "animation_pathPlay"), t.playForwardViewModel), this._pauseSVG = new Ap(gq(84, 99, "animation_pathPause"), t.pauseViewModel); let a = document.createElementNS(bA, "g"); a.appendChild(this._realtimeSVG.svgElement), a.appendChild(this._playReverseSVG.svgElement), a.appendChild(this._playForwardSVG.svgElement), a.appendChild(this._pauseSVG.svgElement); let c = _d({ tagName: "circle", class: "cesium-animation-shuttleRingBack", cx: 100, cy: 100, r: 99 }); this._shuttleRingBackPanel = c; let u = Gv.animation_pathSwooshFX, f = Gv.animation_pathPointer, d = _d({ tagName: "g", class: "cesium-animation-shuttleRingSwoosh", children: [{ tagName: u.tagName, transform: "translate(100,97) scale(-1,1)", id: "animation_pathSwooshFX", d: u.d }, { tagName: u.tagName, transform: "translate(100,97)", id: "animation_pathSwooshFX", d: u.d }, { tagName: "line", x1: 100, y1: 8, x2: 100, y2: 22 }] }); this._shuttleRingSwooshG = d, this._shuttleRingPointer = _d({ class: "cesium-animation-shuttleRingPointer", id: "animation_pathPointer", tagName: f.tagName, d: f.d }); let p = _d({ tagName: "g", transform: "translate(100,100)" }); this._knobOuter = _d({ tagName: "circle", class: "cesium-animation-knobOuter", cx: 0, cy: 0, r: 71 }); let g = 61, m = _d({ tagName: "circle", class: "cesium-animation-knobInner", cx: 0, cy: 0, r: g }); this._knobDate = _q(0, -24, ""), this._knobTime = _q(0, -7, ""), this._knobStatus = _q(0, -41, ""); let A = _d({ tagName: "circle", class: "cesium-animation-blank", cx: 0, cy: 0, r: g }), C = document.createElementNS(bA, "g"); C.setAttribute("class", "cesium-animation-shuttleRingG"), e.appendChild(o), s.appendChild(C), s.appendChild(p), s.appendChild(a), C.appendChild(c), C.appendChild(d), C.appendChild(this._shuttleRingPointer), p.appendChild(this._knobOuter), p.appendChild(m), p.appendChild(this._knobDate), p.appendChild(this._knobTime), p.appendChild(this._knobStatus), p.appendChild(A), r.appendChild(s), e.appendChild(r); let x = this; function T(B) { fht(x, B) } this._mouseCallback = T, c.addEventListener("mousedown", T, !0), c.addEventListener("touchstart", T, !0), d.addEventListener("mousedown", T, !0), d.addEventListener("touchstart", T, !0), n.addEventListener("mousemove", T, !0), n.addEventListener("touchmove", T, !0), n.addEventListener("mouseup", T, !0), n.addEventListener("touchend", T, !0), n.addEventListener("touchcancel", T, !0), this._shuttleRingPointer.addEventListener("mousedown", T, !0), this._shuttleRingPointer.addEventListener("touchstart", T, !0), this._knobOuter.addEventListener("mousedown", T, !0), this._knobOuter.addEventListener("touchstart", T, !0); let b = this._knobTime.childNodes[0], S = this._knobDate.childNodes[0], D = this._knobStatus.childNodes[0], P; this._subscriptions = [aa(t.pauseViewModel, "toggled", function (B) { P !== B && (P = B, P ? x._shuttleRingPointer.setAttribute("class", "cesium-animation-shuttleRingPausePointer") : x._shuttleRingPointer.setAttribute("class", "cesium-animation-shuttleRingPointer")) }), aa(t, "shuttleRingAngle", function (B) { lht(x._shuttleRingPointer, x._knobOuter, B) }), aa(t, "dateLabel", function (B) { S.textContent !== B && (S.textContent = B) }), aa(t, "timeLabel", function (B) { b.textContent !== B && (b.textContent = B) }), aa(t, "multiplierLabel", function (B) { D.textContent !== B && (D.textContent = B) })], this.applyThemeChanges(), this.resize() } Object.defineProperties(KE.prototype, { container: { get: function () { return this._container } }, viewModel: { get: function () { return this._viewModel } } }); KE.prototype.isDestroyed = function () { return !1 }; KE.prototype.destroy = function () { l(this._observer) && (this._observer.disconnect(), this._observer = void 0); let e = this._container.ownerDocument, t = this._mouseCallback; this._shuttleRingBackPanel.removeEventListener("mousedown", t, !0), this._shuttleRingBackPanel.removeEventListener("touchstart", t, !0), this._shuttleRingSwooshG.removeEventListener("mousedown", t, !0), this._shuttleRingSwooshG.removeEventListener("touchstart", t, !0), e.removeEventListener("mousemove", t, !0), e.removeEventListener("touchmove", t, !0), e.removeEventListener("mouseup", t, !0), e.removeEventListener("touchend", t, !0), e.removeEventListener("touchcancel", t, !0), this._shuttleRingPointer.removeEventListener("mousedown", t, !0), this._shuttleRingPointer.removeEventListener("touchstart", t, !0), this._knobOuter.removeEventListener("mousedown", t, !0), this._knobOuter.removeEventListener("touchstart", t, !0), this._container.removeChild(this._svgNode), this._container.removeChild(this._theme), this._realtimeSVG.destroy(), this._playReverseSVG.destroy(), this._playForwardSVG.destroy(), this._pauseSVG.destroy(); let n = this._subscriptions; for (let i = 0, o = n.length; i < o; i++)n[i].dispose(); return le(this) }; KE.prototype.resize = function () { let e = this._container.clientWidth, t = this._container.clientHeight; if (e === this._lastWidth && t === this._lastHeight) return; let n = this._svgNode, i = 200, o = 132, r = e, s = t; e === 0 && t === 0 ? (r = i, s = o) : e === 0 ? (s = t, r = i * (t / o)) : t === 0 && (r = e, s = o * (e / i)); let a = r / i, c = s / o; n.style.cssText = `width: ${r}px; height: ${s}px; position: absolute; bottom: 0; left: 0; overflow: hidden;`, n.setAttribute("width", r), n.setAttribute("height", s), n.setAttribute("viewBox", `0 0 ${r} ${s}`), this._topG.setAttribute("transform", `scale(${a},${c})`), this._centerX = Math.max(1, 100 * a), this._centerY = Math.max(1, 100 * c), this._lastHeight = e, this._lastWidth = t }; KE.prototype.applyThemeChanges = function () { let e = this._container.ownerDocument; if (!e.body.contains(this._container)) { if (l(this._observer)) return; let f = this; f._observer = new MutationObserver(function () { e.body.contains(f._container) && (f._observer.disconnect(), f._observer = void 0, f.applyThemeChanges()) }), f._observer.observe(e, { childList: !0, subtree: !0 }); return } let t = Qg(this._themeNormal), n = Qg(this._themeHover), i = Qg(this._themeSelect), o = Qg(this._themeDisabled), r = Qg(this._themeKnob), s = Qg(this._themePointer), a = Qg(this._themeSwoosh), c = Qg(this._themeSwooshHover), u = _d({ tagName: "defs", children: [{ id: "animation_buttonNormal", tagName: "linearGradient", x1: "50%", y1: "0%", x2: "50%", y2: "100%", children: [{ tagName: "stop", offset: "0%", "stop-color": Lr(t, Hv) }, { tagName: "stop", offset: "12%", "stop-color": Lr(t, C4) }, { tagName: "stop", offset: "46%", "stop-color": Lr(t, pq) }, { tagName: "stop", offset: "81%", "stop-color": Lr(t, x4) }] }, { id: "animation_buttonHovered", tagName: "linearGradient", x1: "50%", y1: "0%", x2: "50%", y2: "100%", children: [{ tagName: "stop", offset: "0%", "stop-color": Lr(n, Hv) }, { tagName: "stop", offset: "12%", "stop-color": Lr(n, C4) }, { tagName: "stop", offset: "46%", "stop-color": Lr(n, pq) }, { tagName: "stop", offset: "81%", "stop-color": Lr(n, x4) }] }, { id: "animation_buttonToggled", tagName: "linearGradient", x1: "50%", y1: "0%", x2: "50%", y2: "100%", children: [{ tagName: "stop", offset: "0%", "stop-color": Lr(i, Hv) }, { tagName: "stop", offset: "12%", "stop-color": Lr(i, C4) }, { tagName: "stop", offset: "46%", "stop-color": Lr(i, pq) }, { tagName: "stop", offset: "81%", "stop-color": Lr(i, x4) }] }, { id: "animation_buttonDisabled", tagName: "linearGradient", x1: "50%", y1: "0%", x2: "50%", y2: "100%", children: [{ tagName: "stop", offset: "0%", "stop-color": Lr(o, aht) }, { tagName: "stop", offset: "75%", "stop-color": Lr(o, cht) }] }, { id: "animation_blurred", tagName: "filter", width: "200%", height: "200%", x: "-50%", y: "-50%", children: [{ tagName: "feGaussianBlur", stdDeviation: 4, in: "SourceGraphic" }] }, { id: "animation_shuttleRingSwooshGradient", tagName: "linearGradient", x1: "50%", y1: "0%", x2: "50%", y2: "100%", children: [{ tagName: "stop", offset: "0%", "stop-opacity": .2, "stop-color": a.toCssColorString() }, { tagName: "stop", offset: "85%", "stop-opacity": .85, "stop-color": a.toCssColorString() }, { tagName: "stop", offset: "95%", "stop-opacity": .05, "stop-color": a.toCssColorString() }] }, { id: "animation_shuttleRingSwooshHovered", tagName: "linearGradient", x1: "50%", y1: "0%", x2: "50%", y2: "100%", children: [{ tagName: "stop", offset: "0%", "stop-opacity": .2, "stop-color": c.toCssColorString() }, { tagName: "stop", offset: "85%", "stop-opacity": .85, "stop-color": c.toCssColorString() }, { tagName: "stop", offset: "95%", "stop-opacity": .05, "stop-color": c.toCssColorString() }] }, { id: "animation_shuttleRingPointerGradient", tagName: "linearGradient", x1: "0%", y1: "50%", x2: "100%", y2: "50%", children: [{ tagName: "stop", offset: "0%", "stop-color": s.toCssColorString() }, { tagName: "stop", offset: "40%", "stop-color": s.toCssColorString() }, { tagName: "stop", offset: "60%", "stop-color": Lr(s, w0e) }, { tagName: "stop", offset: "100%", "stop-color": Lr(s, w0e) }] }, { id: "animation_shuttleRingPointerPaused", tagName: "linearGradient", x1: "0%", y1: "50%", x2: "100%", y2: "50%", children: [{ tagName: "stop", offset: "0%", "stop-color": "#CCC" }, { tagName: "stop", offset: "40%", "stop-color": "#CCC" }, { tagName: "stop", offset: "60%", "stop-color": "#555" }, { tagName: "stop", offset: "100%", "stop-color": "#555" }] }, { id: "animation_knobOuter", tagName: "linearGradient", x1: "20%", y1: "0%", x2: "90%", y2: "100%", children: [{ tagName: "stop", offset: "5%", "stop-color": Lr(r, Hv) }, { tagName: "stop", offset: "60%", "stop-color": Lr(r, S0e) }, { tagName: "stop", offset: "85%", "stop-color": Lr(r, C4) }] }, { id: "animation_knobInner", tagName: "linearGradient", x1: "20%", y1: "0%", x2: "90%", y2: "100%", children: [{ tagName: "stop", offset: "5%", "stop-color": Lr(r, S0e) }, { tagName: "stop", offset: "60%", "stop-color": Lr(r, Hv) }, { tagName: "stop", offset: "85%", "stop-color": Lr(r, x4) }] }] }); l(this._defsElement) ? this._svgNode.replaceChild(u, this._defsElement) : this._svgNode.appendChild(u), this._defsElement = u }; var E4 = KE; var dht = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], $g = 15, JE = 105; function v0e(e, t) { return e - t } function yq(e, t) { let n = Wo(t, e, v0e); return n < 0 ? ~n : n } function hht(e, t) { if (Math.abs(e) <= $g) return e / $g; let n = $g, i = JE, o, r = 0, s; return e > 0 ? (o = Math.log(t[t.length - 1]), s = (o - r) / (i - n), Math.exp(r + s * (e - n))) : (o = Math.log(-t[0]), s = (o - r) / (i - n), -Math.exp(r + s * (Math.abs(e) - n))) } function mht(e, t, n) { if (n.clockStep === uo.SYSTEM_CLOCK) return $g; if (Math.abs(e) <= 1) return e * $g; let i = t[t.length - 1]; e > i ? e = i : e < -i && (e = -i); let o = $g, r = JE, s, a = 0, c; return e > 0 ? (s = Math.log(i), c = (s - a) / (r - o), (Math.log(e) - a) / c + o) : (s = Math.log(-t[0]), c = (s - a) / (r - o), -((Math.log(Math.abs(e)) - a) / c + o)) } function of(e) { let t = this; this._clockViewModel = e, this._allShuttleRingTicks = [], this._dateFormatter = of.defaultDateFormatter, this._timeFormatter = of.defaultTimeFormatter, this.shuttleRingDragging = !1, this.snapToTicks = !1, Ae.track(this, ["_allShuttleRingTicks", "_dateFormatter", "_timeFormatter", "shuttleRingDragging", "snapToTicks"]), this._sortedFilteredPositiveTicks = [], this.setShuttleRingTicks(of.defaultTicks), this.timeLabel = void 0, Ae.defineProperty(this, "timeLabel", function () { return t._timeFormatter(t._clockViewModel.currentTime, t) }), this.dateLabel = void 0, Ae.defineProperty(this, "dateLabel", function () { return t._dateFormatter(t._clockViewModel.currentTime, t) }), this.multiplierLabel = void 0, Ae.defineProperty(this, "multiplierLabel", function () { let s = t._clockViewModel; if (s.clockStep === uo.SYSTEM_CLOCK) return "Today"; let a = s.multiplier; return a % 1 === 0 ? `${a.toFixed(0)}x` : `${a.toFixed(3).replace(/0{0,3}$/, "")}x` }), this.shuttleRingAngle = void 0, Ae.defineProperty(this, "shuttleRingAngle", { get: function () { return mht(e.multiplier, t._allShuttleRingTicks, e) }, set: function (s) { s = Math.max(Math.min(s, JE), -JE); let a = t._allShuttleRingTicks, c = t._clockViewModel; if (c.clockStep = uo.SYSTEM_CLOCK_MULTIPLIER, Math.abs(s) === JE) { c.multiplier = s > 0 ? a[a.length - 1] : a[0]; return } let u = hht(s, a); if (t.snapToTicks) u = a[yq(u, a)]; else if (u !== 0) { let f = Math.abs(u); if (f > 100) { let d = f.toFixed(0).length - 2, p = Math.pow(10, d); u = Math.round(u / p) * p | 0 } else f > $g ? u = Math.round(u) : f > 1 ? u = +u.toFixed(1) : f > 0 && (u = +u.toFixed(2)) } c.multiplier = u } }), this._canAnimate = void 0, Ae.defineProperty(this, "_canAnimate", function () { let s = t._clockViewModel, a = s.clockRange; if (t.shuttleRingDragging || a === Br.UNBOUNDED) return !0; let c = s.multiplier, u = s.currentTime, f = s.startTime, d = !1; if (a === Br.LOOP_STOP) d = $.greaterThan(u, f) || u.equals(f) && c > 0; else { let p = s.stopTime; d = $.greaterThan(u, f) && $.lessThan(u, p) || u.equals(f) && c > 0 || u.equals(p) && c < 0 } return d || (s.shouldAnimate = !1), d }), this._isSystemTimeAvailable = void 0, Ae.defineProperty(this, "_isSystemTimeAvailable", function () { let s = t._clockViewModel; if (s.clockRange === Br.UNBOUNDED) return !0; let c = s.systemTime; return $.greaterThanOrEquals(c, s.startTime) && $.lessThanOrEquals(c, s.stopTime) }), this._isAnimating = void 0, Ae.defineProperty(this, "_isAnimating", function () { return t._clockViewModel.shouldAnimate && (t._canAnimate || t.shuttleRingDragging) }); let n = An(function () { let s = t._clockViewModel; s.shouldAnimate ? s.shouldAnimate = !1 : t._canAnimate && (s.shouldAnimate = !0) }); this._pauseViewModel = new TA(n, { toggled: Ae.computed(function () { return !t._isAnimating }), tooltip: "Pause" }); let i = An(function () { let s = t._clockViewModel, a = s.multiplier; a > 0 && (s.multiplier = -a), s.shouldAnimate = !0 }); this._playReverseViewModel = new TA(i, { toggled: Ae.computed(function () { return t._isAnimating && e.multiplier < 0 }), tooltip: "Play Reverse" }); let o = An(function () { let s = t._clockViewModel, a = s.multiplier; a < 0 && (s.multiplier = -a), s.shouldAnimate = !0 }); this._playForwardViewModel = new TA(o, { toggled: Ae.computed(function () { return t._isAnimating && e.multiplier > 0 && e.clockStep !== uo.SYSTEM_CLOCK }), tooltip: "Play Forward" }); let r = An(function () { t._clockViewModel.clockStep = uo.SYSTEM_CLOCK }, Ae.getObservable(this, "_isSystemTimeAvailable")); this._playRealtimeViewModel = new TA(r, { toggled: Ae.computed(function () { return e.clockStep === uo.SYSTEM_CLOCK }), tooltip: Ae.computed(function () { return t._isSystemTimeAvailable ? "Today (real-time)" : "Current time not in range" }) }), this._slower = An(function () { let s = t._clockViewModel, a = t._allShuttleRingTicks, c = s.multiplier, u = yq(c, a) - 1; u >= 0 && (s.multiplier = a[u]) }), this._faster = An(function () { let s = t._clockViewModel, a = t._allShuttleRingTicks, c = s.multiplier, u = yq(c, a) + 1; u < a.length && (s.multiplier = a[u]) }) } of.defaultDateFormatter = function (e, t) { let n = $.toGregorianDate(e); return `${dht[n.month - 1]} ${n.day} ${n.year}` }; of.defaultTicks = [.001, .002, .005, .01, .02, .05, .1, .25, .5, 1, 2, 5, 10, 15, 30, 60, 120, 300, 600, 900, 1800, 3600, 7200, 14400, 21600, 43200, 86400, 172800, 345600, 604800]; of.defaultTimeFormatter = function (e, t) { let n = $.toGregorianDate(e), i = Math.round(n.millisecond); return Math.abs(t._clockViewModel.multiplier) < 1 ? `${n.hour.toString().padStart(2, "0")}:${n.minute.toString().padStart(2, "0")}:${n.second.toString().padStart(2, "0")}.${i.toString().padStart(3, "0")}` : `${n.hour.toString().padStart(2, "0")}:${n.minute.toString().padStart(2, "0")}:${n.second.toString().padStart(2, "0")} UTC` }; of.prototype.getShuttleRingTicks = function () { return this._sortedFilteredPositiveTicks.slice(0) }; of.prototype.setShuttleRingTicks = function (e) { let t, n, i, o = {}, r = this._sortedFilteredPositiveTicks; for (r.length = 0, t = 0, n = e.length; t < n; ++t)i = e[t], o.hasOwnProperty(i) || (o[i] = !0, r.push(i)); r.sort(v0e); let s = []; for (n = r.length, t = n - 1; t >= 0; --t)i = r[t], i !== 0 && s.push(-i); Array.prototype.push.apply(s, r), this._allShuttleRingTicks = s }; Object.defineProperties(of.prototype, { slower: { get: function () { return this._slower } }, faster: { get: function () { return this._faster } }, clockViewModel: { get: function () { return this._clockViewModel } }, pauseViewModel: { get: function () { return this._pauseViewModel } }, playReverseViewModel: { get: function () { return this._playReverseViewModel } }, playForwardViewModel: { get: function () { return this._playForwardViewModel } }, playRealtimeViewModel: { get: function () { return this._playRealtimeViewModel } }, dateFormatter: { get: function () { return this._dateFormatter }, set: function (e) { this._dateFormatter = e } }, timeFormatter: { get: function () { return this._timeFormatter }, set: function (e) { this._timeFormatter = e } } }); of._maxShuttleRingAngle = JE; of._realtimeShuttleRingAngle = $g; var b4 = of; function pht(e) { return function (t) { let n = e._scene.pick(t.position); l(n) && n.primitive instanceof Su && (e.tileset = n.primitive), e.pickActive = !1 } } function I0e(e, t) { t ? e._eventHandler.setInputAction(function (n) { let i = e._scene.pick(n.endPosition); l(i) && i.primitive instanceof Su && (e.tileset = i.primitive) }, pn.MOUSE_MOVE) : (e._eventHandler.removeInputAction(pn.MOUSE_MOVE), e.picking = e.picking) } var _ht = { maximumFractionDigits: 3 }; function Wv(e) { let t = e / 1048576; return t < 1 ? t.toLocaleString(void 0, _ht) : Math.round(t).toLocaleString() } function jv(e, t) { if (!l(e)) return ""; let n = t ? e._statisticsPerPass[Qo.PICK] : e._statisticsPerPass[Qo.RENDER], i = '<ul class="cesium-cesiumInspector-statistics">'; return i += `<li><strong>Visited: </strong>${n.visited.toLocaleString()}</li><li><strong>Selected: </strong>${n.selected.toLocaleString()}</li><li><strong>Commands: </strong>${n.numberOfCommands.toLocaleString()}</li>`, i += "</ul>", t || (i += '<ul class="cesium-cesiumInspector-statistics">', i += `<li><strong>Requests: </strong>${n.numberOfPendingRequests.toLocaleString()}</li><li><strong>Attempted: </strong>${n.numberOfAttemptedRequests.toLocaleString()}</li><li><strong>Processing: </strong>${n.numberOfTilesProcessing.toLocaleString()}</li><li><strong>Content Ready: </strong>${n.numberOfTilesWithContentReady.toLocaleString()}</li><li><strong>Total: </strong>${n.numberOfTilesTotal.toLocaleString()}</li>`, i += "</ul>", i += '<ul class="cesium-cesiumInspector-statistics">', i += `<li><strong>Features Selected: </strong>${n.numberOfFeaturesSelected.toLocaleString()}</li><li><strong>Features Loaded: </strong>${n.numberOfFeaturesLoaded.toLocaleString()}</li><li><strong>Points Selected: </strong>${n.numberOfPointsSelected.toLocaleString()}</li><li><strong>Points Loaded: </strong>${n.numberOfPointsLoaded.toLocaleString()}</li><li><strong>Triangles Selected: </strong>${n.numberOfTrianglesSelected.toLocaleString()}</li>`, i += "</ul>", i += '<ul class="cesium-cesiumInspector-statistics">', i += `<li><strong>Tiles styled: </strong>${n.numberOfTilesStyled.toLocaleString()}</li><li><strong>Features styled: </strong>${n.numberOfFeaturesStyled.toLocaleString()}</li>`, i += "</ul>", i += '<ul class="cesium-cesiumInspector-statistics">', i += `<li><strong>Children Union Culled: </strong>${n.numberOfTilesCulledWithChildrenUnion.toLocaleString()}</li>`, i += "</ul>", i += '<ul class="cesium-cesiumInspector-statistics">', i += `<li><strong>Geometry Memory (MB): </strong>${Wv(n.geometryByteLength)}</li><li><strong>Texture Memory (MB): </strong>${Wv(n.texturesByteLength)}</li><li><strong>Batch Table Memory (MB): </strong>${Wv(n.batchTableByteLength)}</li>`, i += "</ul>"), i } function O0e() {
        let e = ao.statistics; return `
  <ul class="cesium-cesiumInspector-statistics">
    <li><strong>Geometry Memory (MB): </strong>${Wv(e.geometryByteLength)}</li>
    <li><strong>Texture Memory (MB): </strong>${Wv(e.texturesByteLength)}</li>
  </ul>
  `} var ght = [{ text: "Highlight", value: _l.HIGHLIGHT }, { text: "Replace", value: _l.REPLACE }, { text: "Mix", value: _l.MIX }], P0e = new U(1, 1, 0, .4), yht = new U, S4 = new U; function zs(e, t) { let n = this, i = e.canvas; this._eventHandler = new Xu(i), this._scene = e, this._performanceContainer = t, this._canvas = i, this._performanceDisplay = new jg({ container: t }), this._statisticsText = "", this._pickStatisticsText = "", this._resourceCacheStatisticsText = "", this._editorError = "", this.performance = !1, this.showStatistics = !0, this.showPickStatistics = !0, this.showResourceCacheStatistics = !1, this.inspectorVisible = !0, this.tilesetVisible = !1, this.displayVisible = !1, this.updateVisible = !1, this.loggingVisible = !1, this.styleVisible = !1, this.tileDebugLabelsVisible = !1, this.optimizationVisible = !1, this.styleString = "{}", this.hasEnabledWireframe = !1, this._tileset = void 0, this._feature = void 0, this._tile = void 0, Ae.track(this, ["performance", "inspectorVisible", "_statisticsText", "_pickStatisticsText", "_resourceCacheStatisticsText", "_editorError", "showPickStatistics", "showStatistics", "showResourceCacheStatistics", "tilesetVisible", "displayVisible", "updateVisible", "loggingVisible", "styleVisible", "optimizationVisible", "tileDebugLabelsVisible", "styleString", "_feature", "_tile", "_tileset", "hasEnabledWireframe"]), this._properties = Ae.observable({}), this.properties = [], Ae.defineProperty(this, "properties", function () { let N = [], X = n._properties(); for (let q in X) X.hasOwnProperty(q) && N.push(q); return N }); let o = Ae.observable(); Ae.defineProperty(this, "dynamicScreenSpaceError", { get: function () { return o() }, set: function (N) { o(N), l(n._tileset) && (n._tileset.dynamicScreenSpaceError = N) } }), this.dynamicScreenSpaceError = !1; let r = Ae.observable(); Ae.defineProperty(this, "colorBlendMode", { get: function () { return r() }, set: function (N) { r(N), l(n._tileset) && (n._tileset.colorBlendMode = N, n._scene.requestRender()) } }), this.colorBlendMode = _l.HIGHLIGHT; let s = Ae.observable(), a = Ae.observable(); Ae.defineProperty(this, "picking", { get: function () { return a() }, set: function (N) { a(N), N ? n._eventHandler.setInputAction(function (X) { let q = e.pick(X.endPosition); if (q instanceof xs ? (n.feature = q, n.tile = q.content.tile) : l(q) && l(q.content) ? (n.feature = void 0, n.tile = q.content.tile) : (n.feature = void 0, n.tile = void 0), !!l(n._tileset)) { if (s && l(q) && l(q.content)) { let J; e.pickPositionSupported && (J = e.pickPosition(X.endPosition), l(J) && (n._tileset.debugPickPosition = J)), n._tileset.debugPickedTile = q.content.tile } else n._tileset.debugPickedTile = void 0; n._scene.requestRender() } }, pn.MOUSE_MOVE) : (n.feature = void 0, n.tile = void 0, n._eventHandler.removeInputAction(pn.MOUSE_MOVE)) } }), this.picking = !0; let c = Ae.observable(); Ae.defineProperty(this, "colorize", { get: function () { return c() }, set: function (N) { c(N), l(n._tileset) && (n._tileset.debugColorizeTiles = N, n._scene.requestRender()) } }), this.colorize = !1; let u = Ae.observable(); Ae.defineProperty(this, "wireframe", { get: function () { return u() }, set: function (N) { u(N), l(n._tileset) && (n._tileset.debugWireframe = N, n._scene.requestRender()) } }), this.wireframe = !1; let f = Ae.observable(); Ae.defineProperty(this, "showBoundingVolumes", { get: function () { return f() }, set: function (N) { f(N), l(n._tileset) && (n._tileset.debugShowBoundingVolume = N, n._scene.requestRender()) } }), this.showBoundingVolumes = !1; let d = Ae.observable(); Ae.defineProperty(this, "showContentBoundingVolumes", { get: function () { return d() }, set: function (N) { d(N), l(n._tileset) && (n._tileset.debugShowContentBoundingVolume = N, n._scene.requestRender()) } }), this.showContentBoundingVolumes = !1; let p = Ae.observable(); Ae.defineProperty(this, "showRequestVolumes", { get: function () { return p() }, set: function (N) { p(N), l(n._tileset) && (n._tileset.debugShowViewerRequestVolume = N, n._scene.requestRender()) } }), this.showRequestVolumes = !1; let g = Ae.observable(); Ae.defineProperty(this, "freezeFrame", { get: function () { return g() }, set: function (N) { g(N), l(n._tileset) && (n._tileset.debugFreezeFrame = N, n._scene.debugShowFrustumPlanes = N, n._scene.requestRender()) } }), this.freezeFrame = !1, Ae.defineProperty(this, "showOnlyPickedTileDebugLabel", { get: function () { return s() }, set: function (N) { s(N), l(n._tileset) && (n._tileset.debugPickedTileLabelOnly = N, n._scene.requestRender()) } }), this.showOnlyPickedTileDebugLabel = !1; let m = Ae.observable(); Ae.defineProperty(this, "showGeometricError", { get: function () { return m() }, set: function (N) { m(N), l(n._tileset) && (n._tileset.debugShowGeometricError = N, n._scene.requestRender()) } }), this.showGeometricError = !1; let A = Ae.observable(); Ae.defineProperty(this, "showRenderingStatistics", { get: function () { return A() }, set: function (N) { A(N), l(n._tileset) && (n._tileset.debugShowRenderingStatistics = N, n._scene.requestRender()) } }), this.showRenderingStatistics = !1; let C = Ae.observable(); Ae.defineProperty(this, "showMemoryUsage", { get: function () { return C() }, set: function (N) { C(N), l(n._tileset) && (n._tileset.debugShowMemoryUsage = N, n._scene.requestRender()) } }), this.showMemoryUsage = !1; let x = Ae.observable(); Ae.defineProperty(this, "showUrl", { get: function () { return x() }, set: function (N) { x(N), l(n._tileset) && (n._tileset.debugShowUrl = N, n._scene.requestRender()) } }), this.showUrl = !1; let T = Ae.observable(); Ae.defineProperty(this, "maximumScreenSpaceError", { get: function () { return T() }, set: function (N) { N = Number(N), isNaN(N) || (T(N), l(n._tileset) && (n._tileset.maximumScreenSpaceError = N)) } }), this.maximumScreenSpaceError = 16; let b = Ae.observable(); Ae.defineProperty(this, "dynamicScreenSpaceErrorDensity", { get: function () { return b() }, set: function (N) { N = Number(N), isNaN(N) || (b(N), l(n._tileset) && (n._tileset.dynamicScreenSpaceErrorDensity = N)) } }), this.dynamicScreenSpaceErrorDensity = .00278, this.dynamicScreenSpaceErrorDensitySliderValue = void 0, Ae.defineProperty(this, "dynamicScreenSpaceErrorDensitySliderValue", { get: function () { return Math.pow(b(), 1 / 6) }, set: function (N) { b(Math.pow(N, 6)) } }); let S = Ae.observable(); Ae.defineProperty(this, "dynamicScreenSpaceErrorFactor", { get: function () { return S() }, set: function (N) { N = Number(N), isNaN(N) || (S(N), l(n._tileset) && (n._tileset.dynamicScreenSpaceErrorFactor = N)) } }), this.dynamicScreenSpaceErrorFactor = 4; let D = pht(this), P = Ae.observable(); Ae.defineProperty(this, "pickActive", { get: function () { return P() }, set: function (N) { P(N), N ? n._eventHandler.setInputAction(D, pn.LEFT_CLICK) : n._eventHandler.removeInputAction(pn.LEFT_CLICK) } }); let B = Ae.observable(); Ae.defineProperty(this, "pointCloudShading", { get: function () { return B() }, set: function (N) { B(N), l(n._tileset) && (n._tileset.pointCloudShading.attenuation = N) } }), this.pointCloudShading = !1; let R = Ae.observable(); Ae.defineProperty(this, "geometricErrorScale", { get: function () { return R() }, set: function (N) { N = Number(N), isNaN(N) || (R(N), l(n._tileset) && (n._tileset.pointCloudShading.geometricErrorScale = N)) } }), this.geometricErrorScale = 1; let M = Ae.observable(); Ae.defineProperty(this, "maximumAttenuation", { get: function () { return M() }, set: function (N) { N = Number(N), isNaN(N) || (M(N), l(n._tileset) && (n._tileset.pointCloudShading.maximumAttenuation = N === 0 ? void 0 : N)) } }), this.maximumAttenuation = 0; let L = Ae.observable(); Ae.defineProperty(this, "baseResolution", { get: function () { return L() }, set: function (N) { N = Number(N), isNaN(N) || (L(N), l(n._tileset) && (n._tileset.pointCloudShading.baseResolution = N === 0 ? void 0 : N)) } }), this.baseResolution = 0; let _ = Ae.observable(); Ae.defineProperty(this, "eyeDomeLighting", { get: function () { return _() }, set: function (N) { _(N), l(n._tileset) && (n._tileset.pointCloudShading.eyeDomeLighting = N) } }), this.eyeDomeLighting = !1; let E = Ae.observable(); Ae.defineProperty(this, "eyeDomeLightingStrength", { get: function () { return E() }, set: function (N) { N = Number(N), isNaN(N) || (E(N), l(n._tileset) && (n._tileset.pointCloudShading.eyeDomeLightingStrength = N)) } }), this.eyeDomeLightingStrength = 1; let w = Ae.observable(); Ae.defineProperty(this, "eyeDomeLightingRadius", { get: function () { return w() }, set: function (N) { N = Number(N), isNaN(N) || (w(N), l(n._tileset) && (n._tileset.pointCloudShading.eyeDomeLightingRadius = N)) } }), this.eyeDomeLightingRadius = 1, this.pickActive = !1; let v = Ae.observable(); Ae.defineProperty(this, "skipLevelOfDetail", { get: function () { return v() }, set: function (N) { v(N), l(n._tileset) && (n._tileset.skipLevelOfDetail = N) } }), this.skipLevelOfDetail = !0; let O = Ae.observable(); Ae.defineProperty(this, "skipScreenSpaceErrorFactor", { get: function () { return O() }, set: function (N) { N = Number(N), isNaN(N) || (O(N), l(n._tileset) && (n._tileset.skipScreenSpaceErrorFactor = N)) } }), this.skipScreenSpaceErrorFactor = 16; let V = Ae.observable(); Ae.defineProperty(this, "baseScreenSpaceError", { get: function () { return V() }, set: function (N) { N = Number(N), isNaN(N) || (V(N), l(n._tileset) && (n._tileset.baseScreenSpaceError = N)) } }), this.baseScreenSpaceError = 1024; let z = Ae.observable(); Ae.defineProperty(this, "skipLevels", { get: function () { return z() }, set: function (N) { N = Number(N), isNaN(N) || (z(N), l(n._tileset) && (n._tileset.skipLevels = N)) } }), this.skipLevels = 1; let k = Ae.observable(); Ae.defineProperty(this, "immediatelyLoadDesiredLevelOfDetail", { get: function () { return k() }, set: function (N) { k(N), l(n._tileset) && (n._tileset.immediatelyLoadDesiredLevelOfDetail = N) } }), this.immediatelyLoadDesiredLevelOfDetail = !1; let G = Ae.observable(); Ae.defineProperty(this, "loadSiblings", { get: function () { return G() }, set: function (N) { G(N), l(n._tileset) && (n._tileset.loadSiblings = N) } }), this.loadSiblings = !1, this._style = void 0, this._shouldStyle = !1, this._definedProperties = ["properties", "dynamicScreenSpaceError", "colorBlendMode", "picking", "colorize", "wireframe", "showBoundingVolumes", "showContentBoundingVolumes", "showRequestVolumes", "freezeFrame", "maximumScreenSpaceError", "dynamicScreenSpaceErrorDensity", "baseScreenSpaceError", "skipScreenSpaceErrorFactor", "skipLevelOfDetail", "skipLevels", "immediatelyLoadDesiredLevelOfDetail", "loadSiblings", "dynamicScreenSpaceErrorDensitySliderValue", "dynamicScreenSpaceErrorFactor", "pickActive", "showOnlyPickedTileDebugLabel", "showGeometricError", "showRenderingStatistics", "showMemoryUsage", "showUrl", "pointCloudShading", "geometricErrorScale", "maximumAttenuation", "baseResolution", "eyeDomeLighting", "eyeDomeLightingStrength", "eyeDomeLightingRadius"], this._removePostRenderEvent = e.postRender.addEventListener(function () { n._update() }), l(this._tileset) || I0e(this, !0) } Object.defineProperties(zs.prototype, { scene: { get: function () { return this._scene } }, performanceContainer: { get: function () { return this._performanceContainer } }, statisticsText: { get: function () { return this._statisticsText } }, pickStatisticsText: { get: function () { return this._pickStatisticsText } }, resourceCacheStatisticsText: { get: function () { return this._resourceCacheStatisticsText } }, colorBlendModes: { get: function () { return ght } }, editorError: { get: function () { return this._editorError } }, tileset: { get: function () { return this._tileset }, set: function (e) { if (this._tileset = e, this._style = void 0, this.styleString = "{}", this.feature = void 0, this.tile = void 0, l(e)) { let t = this; e.readyPromise.then(function (r) { t.isDestroyed() || t._properties(r.properties) }); let n = ["colorize", "wireframe", "showBoundingVolumes", "showContentBoundingVolumes", "showRequestVolumes", "freezeFrame", "showOnlyPickedTileDebugLabel", "showGeometricError", "showRenderingStatistics", "showMemoryUsage", "showUrl"], i = n.length; for (let r = 0; r < i; ++r) { let s = n[r]; this[s] = this[s] } this.maximumScreenSpaceError = e.maximumScreenSpaceError, this.dynamicScreenSpaceError = e.dynamicScreenSpaceError, this.dynamicScreenSpaceErrorDensity = e.dynamicScreenSpaceErrorDensity, this.dynamicScreenSpaceErrorFactor = e.dynamicScreenSpaceErrorFactor, this.colorBlendMode = e.colorBlendMode, this.skipLevelOfDetail = e.skipLevelOfDetail, this.skipScreenSpaceErrorFactor = e.skipScreenSpaceErrorFactor, this.baseScreenSpaceError = e.baseScreenSpaceError, this.skipLevels = e.skipLevels, this.immediatelyLoadDesiredLevelOfDetail = e.immediatelyLoadDesiredLevelOfDetail, this.loadSiblings = e.loadSiblings, this.hasEnabledWireframe = e._enableDebugWireframe; let o = e.pointCloudShading; this.pointCloudShading = o.attenuation, this.geometricErrorScale = o.geometricErrorScale, this.maximumAttenuation = o.maximumAttenuation ? o.maximumAttenuation : 0, this.baseResolution = o.baseResolution ? o.baseResolution : 0, this.eyeDomeLighting = o.eyeDomeLighting, this.eyeDomeLightingStrength = o.eyeDomeLightingStrength, this.eyeDomeLightingRadius = o.eyeDomeLightingRadius, this._scene.requestRender() } else this._properties({}); this._statisticsText = jv(e, !1), this._pickStatisticsText = jv(e, !0), this._resourceCacheStatisticsText = O0e(), I0e(this, !1) } }, feature: { get: function () { return this._feature }, set: function (e) { if (this._feature === e) return; let t = this._feature; l(t) && !t.content.isDestroyed() && (!this.colorize && l(this._style) ? t.color = l(this._style.color) ? this._style.color.evaluateColor(t, yht) : U.WHITE : t.color = S4, this._scene.requestRender()), l(e) && (U.clone(e.color, S4), e.color = P0e, this._scene.requestRender()), this._feature = e } }, tile: { get: function () { return this._tile }, set: function (e) { if (this._tile === e) return; let t = this._tile; l(t) && !t.isDestroyed() && !Aq(t.content) && (t.color = S4, this._scene.requestRender()), l(e) && !Aq(e.content) && (U.clone(e.color, S4), e.color = P0e, this._scene.requestRender()), this._tile = e } } }); function Aq(e) { if (!l(e)) return !1; if (e.featuresLength > 0) return !0; let t = e.innerContents; if (l(t)) { let n = t.length; for (let i = 0; i < n; ++i)if (!Aq(t[i])) return !1; return !0 } return !1 } zs.prototype.togglePickTileset = function () { this.pickActive = !this.pickActive }; zs.prototype.toggleInspector = function () { this.inspectorVisible = !this.inspectorVisible }; zs.prototype.toggleTileset = function () { this.tilesetVisible = !this.tilesetVisible }; zs.prototype.toggleDisplay = function () { this.displayVisible = !this.displayVisible }; zs.prototype.toggleUpdate = function () { this.updateVisible = !this.updateVisible }; zs.prototype.toggleLogging = function () { this.loggingVisible = !this.loggingVisible }; zs.prototype.toggleStyle = function () { this.styleVisible = !this.styleVisible }; zs.prototype.toggleTileDebugLabels = function () { this.tileDebugLabelsVisible = !this.tileDebugLabelsVisible }; zs.prototype.toggleOptimization = function () { this.optimizationVisible = !this.optimizationVisible }; zs.prototype.trimTilesCache = function () { l(this._tileset) && this._tileset.trimLoadedTiles() }; zs.prototype.compileStyle = function () { let e = this._tileset; if (!(!l(e) || this.styleString === JSON.stringify(e.style))) { this._editorError = ""; try { this.styleString.length === 0 && (this.styleString = "{}"), this._style = new xE(JSON.parse(this.styleString)), this._shouldStyle = !0, this._scene.requestRender() } catch (t) { this._editorError = t.toString() } this.feature = this._feature, this.tile = this._tile } }; zs.prototype.styleEditorKeyPress = function (e, t) {
        if (t.keyCode === 9) {
            t.preventDefault(); let n = t.target, i = n.selectionStart, o = n.selectionEnd, r = o, a = n.value.slice(i, o).split(`
`), c = a.length, u; if (t.shiftKey) for (u = 0; u < c; ++u)a[u][0] === " " && (a[u][1] === " " ? (a[u] = a[u].substr(2), r -= 2) : (a[u] = a[u].substr(1), r -= 1)); else for (u = 0; u < c; ++u)a[u] = `  ${a[u]}`, r += 2; let f = a.join(`
`); n.value = n.value.slice(0, i) + f + n.value.slice(o), n.selectionStart = i !== o ? i : r, n.selectionEnd = r
        } else t.ctrlKey && (t.keyCode === 10 || t.keyCode === 13) && this.compileStyle(); return !0
    }; zs.prototype._update = function () { let e = this._tileset; if (this.performance && this._performanceDisplay.update(), l(e)) { if (e.isDestroyed()) { this.tile = void 0, this.feature = void 0, this.tileset = void 0; return } let t = e.style; this._style !== e.style && (this._shouldStyle ? (e.style = this._style, this._shouldStyle = !1) : (this._style = t, this.styleString = JSON.stringify(t.style, null, "  "))) } this.showStatistics && (this._statisticsText = jv(e, !1), this._pickStatisticsText = jv(e, !0), this._resourceCacheStatisticsText = O0e()) }; zs.prototype.isDestroyed = function () { return !1 }; zs.prototype.destroy = function () { this._eventHandler.destroy(), this._removePostRenderEvent(); let e = this; return this._definedProperties.forEach(function (t) { Ae.getObservable(e, t).dispose() }), le(this) }; zs.getStatistics = jv; var w4 = zs; function D4(e, t) { e = vn(e); let n = document.createElement("div"), i = document.createElement("div"); i.setAttribute("data-bind", "visible: performance"); let o = new w4(t, i); this._viewModel = o, this._container = e, this._element = n; let r = document.createElement("div"); r.textContent = "3D Tiles Inspector", r.className = "cesium-cesiumInspector-button", r.setAttribute("data-bind", "click: toggleInspector"), n.appendChild(r), n.className = "cesium-cesiumInspector cesium-3DTilesInspector", n.setAttribute("data-bind", 'css: { "cesium-cesiumInspector-visible" : inspectorVisible, "cesium-cesiumInspector-hidden" : !inspectorVisible}'), e.appendChild(n); let s = document.createElement("div"); this._panel = s, s.className = "cesium-cesiumInspector-dropDown", n.appendChild(s); let a = Zg.createSection, c = Zg.createCheckbox, u = a(s, "Tileset", "tilesetVisible", "toggleTileset"), f = a(s, "Display", "displayVisible", "toggleDisplay"), d = a(s, "Update", "updateVisible", "toggleUpdate"), p = a(s, "Logging", "loggingVisible", "toggleLogging"), g = a(s, "Tile Debug Labels", "tileDebugLabelsVisible", "toggleTileDebugLabels"), m = a(s, "Style", "styleVisible", "toggleStyle"), A = a(s, "Optimization", "optimizationVisible", "toggleOptimization"), C = document.createElement("div"); C.className = "field-group"; let x = document.createElement("label"); x.className = "field-label", x.appendChild(document.createTextNode("Properties: ")); let T = document.createElement("div"); T.setAttribute("data-bind", "text: properties"), C.appendChild(x), C.appendChild(T), u.appendChild(C), u.appendChild(Cq("togglePickTileset", "Pick Tileset", "pickActive")), u.appendChild(Cq("trimTilesCache", "Trim Tiles Cache")), u.appendChild(c("Enable Picking", "picking")), f.appendChild(c("Colorize", "colorize")), f.appendChild(c("Wireframe", "wireframe", "_tileset === undefined || hasEnabledWireframe")); let b = document.createElement("p"); b.setAttribute("data-bind", "visible: _tileset !== undefined && !hasEnabledWireframe"), b.setAttribute("class", "cesium-3DTilesInspector-disabledElementsInfo"), b.innerText = "Set enableDebugWireframe to true in the tileset constructor to enable this option.", f.lastChild.appendChild(b), f.appendChild(c("Bounding Volumes", "showBoundingVolumes")), f.appendChild(c("Content Volumes", "showContentBoundingVolumes")), f.appendChild(c("Request Volumes", "showRequestVolumes")), f.appendChild(c("Point Cloud Shading", "pointCloudShading")); let S = document.createElement("div"); S.setAttribute("data-bind", "visible: pointCloudShading"), S.appendChild(gd("geometricErrorScale", 0, 2, .01, "Geometric Error Scale")), S.appendChild(gd("maximumAttenuation", 0, 32, 1, "Maximum Attenuation")), S.appendChild(gd("baseResolution", 0, 1, .01, "Base Resolution")), S.appendChild(c("Eye Dome Lighting (EDL)", "eyeDomeLighting")), f.appendChild(S); let D = document.createElement("div"); D.setAttribute("data-bind", "visible: eyeDomeLighting"), D.appendChild(gd("eyeDomeLightingStrength", 0, 2, .1, "EDL Strength")), D.appendChild(gd("eyeDomeLightingRadius", 0, 4, .1, "EDL Radius")), S.appendChild(D), d.appendChild(c("Freeze Frame", "freezeFrame")), d.appendChild(c("Dynamic Screen Space Error", "dynamicScreenSpaceError")); let P = document.createElement("div"); P.appendChild(gd("maximumScreenSpaceError", 0, 128, 1, "Maximum Screen Space Error")), d.appendChild(P); let B = document.createElement("div"); B.setAttribute("data-bind", "visible: dynamicScreenSpaceError"), B.appendChild(gd("dynamicScreenSpaceErrorDensitySliderValue", 0, 1, .005, "Screen Space Error Density", "dynamicScreenSpaceErrorDensity")), B.appendChild(gd("dynamicScreenSpaceErrorFactor", 1, 10, .1, "Screen Space Error Factor")), d.appendChild(B), p.appendChild(c("Performance", "performance")), p.appendChild(i), p.appendChild(c("Statistics", "showStatistics")); let R = document.createElement("div"); R.className = "cesium-3dTilesInspector-statistics", R.setAttribute("data-bind", "html: statisticsText, visible: showStatistics"), p.appendChild(R), p.appendChild(c("Pick Statistics", "showPickStatistics")); let M = document.createElement("div"); M.className = "cesium-3dTilesInspector-statistics", M.setAttribute("data-bind", "html: pickStatisticsText, visible: showPickStatistics"), p.appendChild(M), p.appendChild(c("Resource Cache Statistics", "showResourceCacheStatistics")); let L = document.createElement("div"); L.className = "cesium-3dTilesInspector-statistics", L.setAttribute("data-bind", "html: resourceCacheStatisticsText, visible: showResourceCacheStatistics"), p.appendChild(L); let _ = document.createElement("div"); m.appendChild(_), _.appendChild(document.createTextNode("Color Blend Mode: ")); let E = document.createElement("select"); E.setAttribute("data-bind", 'options: colorBlendModes, optionsText: "text", optionsValue: "value", value: colorBlendMode'), _.appendChild(E); let w = document.createElement("textarea"); w.setAttribute("data-bind", "textInput: styleString, event: { keydown: styleEditorKeyPress }"), _.className = "cesium-cesiumInspector-styleEditor", _.appendChild(w); let v = Cq("compileStyle", "Compile (Ctrl+Enter)"); _.appendChild(v); let O = document.createElement("div"); O.className = "cesium-cesiumInspector-error", O.setAttribute("data-bind", "text: editorError"), _.appendChild(O), g.appendChild(c("Show Picked Only", "showOnlyPickedTileDebugLabel")), g.appendChild(c("Geometric Error", "showGeometricError")), g.appendChild(c("Rendering Statistics", "showRenderingStatistics")), g.appendChild(c("Memory Usage (MB)", "showMemoryUsage")), g.appendChild(c("Url", "showUrl")), A.appendChild(c("Skip Tile LODs", "skipLevelOfDetail")); let V = document.createElement("div"); V.appendChild(gd("skipScreenSpaceErrorFactor", 1, 50, 1, "Skip SSE Factor")), A.appendChild(V); let z = document.createElement("div"); z.appendChild(gd("baseScreenSpaceError", 0, 4096, 1, "SSE before skipping LOD")), A.appendChild(z); let k = document.createElement("div"); k.appendChild(gd("skipLevels", 0, 10, 1, "Min. levels to skip")), A.appendChild(k), A.appendChild(c("Load only tiles that meet the max SSE.", "immediatelyLoadDesiredLevelOfDetail")), A.appendChild(c("Load siblings of visible tiles", "loadSiblings")), Ae.applyBindings(o, n) } Object.defineProperties(D4.prototype, { container: { get: function () { return this._container } }, viewModel: { get: function () { return this._viewModel } } }); D4.prototype.isDestroyed = function () { return !1 }; D4.prototype.destroy = function () { return Ae.cleanNode(this._element), this._container.removeChild(this._element), this.viewModel.destroy(), le(this) }; function gd(e, t, n, i, o, r) { r = y(r, e); let s = document.createElement("input"); s.setAttribute("data-bind", `value: ${r}`), s.type = "number"; let a = document.createElement("input"); a.type = "range", a.min = t, a.max = n, a.step = i, a.setAttribute("data-bind", `valueUpdate: "input", value: ${e}`); let c = document.createElement("div"); c.appendChild(a); let u = document.createElement("div"); return u.className = "cesium-cesiumInspector-slider", u.appendChild(document.createTextNode(o)), u.appendChild(s), u.appendChild(c), u } function Cq(e, t, n) { let i = document.createElement("button"); i.type = "button", i.textContent = t, i.className = "cesium-cesiumInspector-pickButton"; let o = `click: ${e}`; return l(n) && (o += `, css: {"cesium-cesiumInspector-pickButtonHighlight" : ${n}}`), i.setAttribute("data-bind", o), i } var v4 = D4; function Aht(e) { let t; if (l(e)) { t = "Command Statistics"; let n = e.commandsInFrustums; for (let i in n) if (n.hasOwnProperty(i)) { let o = parseInt(i, 10), r; if (o === 7) r = "1, 2 and 3"; else { let s = []; for (let a = 2; a >= 0; a--) { let c = Math.pow(2, a); o >= c && (s.push(a + 1), o -= c) } r = s.reverse().join(" and ") } t += `<br>&nbsp;&nbsp;&nbsp;&nbsp;${n[i]} in frustum ${r}` } t += `<br>Total: ${e.totalCommands}` } return t } function xq(e, t, n) { let i = Math.min(n, t); return i = Math.max(i, e), i } var Cht = new En, xht = new h; function qv(e, t) { let n = this, i = e.canvas, o = new Xu(i); this._eventHandler = o, this._scene = e, this._canvas = i, this._primitive = void 0, this._tile = void 0, this._modelMatrixPrimitive = void 0, this._performanceDisplay = void 0, this._performanceContainer = t; let r = this._scene.globe; r.depthTestAgainstTerrain = !0, this.frustums = !1, this.frustumPlanes = !1, this.performance = !1, this.shaderCacheText = "", this.primitiveBoundingSphere = !1, this.primitiveReferenceFrame = !1, this.filterPrimitive = !1, this.tileBoundingSphere = !1, this.filterTile = !1, this.wireframe = !1, this.depthFrustum = 1, this._numberOfFrustums = 1, this.suspendUpdates = !1, this.tileCoordinates = !1, this.frustumStatisticText = !1, this.tileText = "", this.hasPickedPrimitive = !1, this.hasPickedTile = !1, this.pickPrimitiveActive = !1, this.pickTileActive = !1, this.dropDownVisible = !0, this.generalVisible = !0, this.primitivesVisible = !1, this.terrainVisible = !1, this.depthFrustumText = "", Ae.track(this, ["frustums", "frustumPlanes", "performance", "shaderCacheText", "primitiveBoundingSphere", "primitiveReferenceFrame", "filterPrimitive", "tileBoundingSphere", "filterTile", "wireframe", "depthFrustum", "suspendUpdates", "tileCoordinates", "frustumStatisticText", "tileText", "hasPickedPrimitive", "hasPickedTile", "pickPrimitiveActive", "pickTileActive", "dropDownVisible", "generalVisible", "primitivesVisible", "terrainVisible", "depthFrustumText"]), this._toggleDropDown = An(function () { n.dropDownVisible = !n.dropDownVisible }), this._toggleGeneral = An(function () { n.generalVisible = !n.generalVisible }), this._togglePrimitives = An(function () { n.primitivesVisible = !n.primitivesVisible }), this._toggleTerrain = An(function () { n.terrainVisible = !n.terrainVisible }), this._frustumsSubscription = Ae.getObservable(this, "frustums").subscribe(function (u) { n._scene.debugShowFrustums = u, n._scene.requestRender() }), this._frustumPlanesSubscription = Ae.getObservable(this, "frustumPlanes").subscribe(function (u) { n._scene.debugShowFrustumPlanes = u, n._scene.requestRender() }), this._performanceSubscription = Ae.getObservable(this, "performance").subscribe(function (u) { u ? n._performanceDisplay = new jg({ container: n._performanceContainer }) : n._performanceContainer.innerHTML = "" }), this._showPrimitiveBoundingSphere = An(function () { return n._primitive.debugShowBoundingVolume = n.primitiveBoundingSphere, n._scene.requestRender(), !0 }), this._primitiveBoundingSphereSubscription = Ae.getObservable(this, "primitiveBoundingSphere").subscribe(function () { n._showPrimitiveBoundingSphere() }), this._showPrimitiveReferenceFrame = An(function () { if (n.primitiveReferenceFrame) { let u = n._primitive.modelMatrix; n._modelMatrixPrimitive = new JV({ modelMatrix: u }), n._scene.primitives.add(n._modelMatrixPrimitive) } else l(n._modelMatrixPrimitive) && (n._scene.primitives.remove(n._modelMatrixPrimitive), n._modelMatrixPrimitive = void 0); return n._scene.requestRender(), !0 }), this._primitiveReferenceFrameSubscription = Ae.getObservable(this, "primitiveReferenceFrame").subscribe(function () { n._showPrimitiveReferenceFrame() }), this._doFilterPrimitive = An(function () { return n.filterPrimitive ? n._scene.debugCommandFilter = function (u) { return l(n._modelMatrixPrimitive) && u.owner === n._modelMatrixPrimitive._primitive ? !0 : l(n._primitive) ? u.owner === n._primitive || u.owner === n._primitive._billboardCollection || u.owner.primitive === n._primitive : !1 } : n._scene.debugCommandFilter = void 0, !0 }), this._filterPrimitiveSubscription = Ae.getObservable(this, "filterPrimitive").subscribe(function () { n._doFilterPrimitive(), n._scene.requestRender() }), this._wireframeSubscription = Ae.getObservable(this, "wireframe").subscribe(function (u) { r._surface.tileProvider._debug.wireframe = u, n._scene.requestRender() }), this._depthFrustumSubscription = Ae.getObservable(this, "depthFrustum").subscribe(function (u) { n._scene.debugShowDepthFrustum = u, n._scene.requestRender() }), this._incrementDepthFrustum = An(function () { let u = n.depthFrustum + 1; return n.depthFrustum = xq(1, n._numberOfFrustums, u), n._scene.requestRender(), !0 }), this._decrementDepthFrustum = An(function () { let u = n.depthFrustum - 1; return n.depthFrustum = xq(1, n._numberOfFrustums, u), n._scene.requestRender(), !0 }), this._suspendUpdatesSubscription = Ae.getObservable(this, "suspendUpdates").subscribe(function (u) { r._surface._debug.suspendLodUpdate = u, u || (n.filterTile = !1) }); let s; this._showTileCoordinates = An(function () { return n.tileCoordinates && !l(s) ? s = e.imageryLayers.addImageryProvider(new c4({ tilingScheme: e.terrainProvider.tilingScheme })) : !n.tileCoordinates && l(s) && (e.imageryLayers.remove(s), s = void 0), !0 }), this._tileCoordinatesSubscription = Ae.getObservable(this, "tileCoordinates").subscribe(function () { n._showTileCoordinates(), n._scene.requestRender() }), this._tileBoundingSphereSubscription = Ae.getObservable(this, "tileBoundingSphere").subscribe(function () { n._showTileBoundingSphere(), n._scene.requestRender() }), this._showTileBoundingSphere = An(function () { return n.tileBoundingSphere ? r._surface.tileProvider._debug.boundingSphereTile = n._tile : r._surface.tileProvider._debug.boundingSphereTile = void 0, n._scene.requestRender(), !0 }), this._doFilterTile = An(function () { return n.filterTile ? (n.suspendUpdates = !0, r._surface._tilesToRender = [], l(n._tile) && n._tile.renderable && r._surface._tilesToRender.push(n._tile)) : n.suspendUpdates = !1, !0 }), this._filterTileSubscription = Ae.getObservable(this, "filterTile").subscribe(function () { n.doFilterTile(), n._scene.requestRender() }); function a(u) { let f = n._scene.pick({ x: u.position.x, y: u.position.y }); l(f) && (n.primitive = l(f.collection) ? f.collection : f.primitive), n._scene.requestRender(), n.pickPrimitiveActive = !1 } this._pickPrimitive = An(function () { n.pickPrimitiveActive = !n.pickPrimitiveActive }), this._pickPrimitiveActiveSubscription = Ae.getObservable(this, "pickPrimitiveActive").subscribe(function (u) { u ? o.setInputAction(a, pn.LEFT_CLICK) : o.removeInputAction(pn.LEFT_CLICK) }); function c(u) { let f, d = r.ellipsoid, p = n._scene.camera.getPickRay(u.position, Cht), g = r.pick(p, n._scene, xht); if (l(g)) { let m = d.cartesianToCartographic(g), A = r._surface.tileProvider._tilesToRenderByTextureCount; for (let C = 0; !f && C < A.length; ++C) { let x = A[C]; if (!!l(x)) for (let T = 0; !f && T < x.length; ++T) { let b = x[T]; ce.contains(b.rectangle, m) && (f = b) } } } n.tile = f, n.pickTileActive = !1 } this._pickTile = An(function () { n.pickTileActive = !n.pickTileActive }), this._pickTileActiveSubscription = Ae.getObservable(this, "pickTileActive").subscribe(function (u) { u ? o.setInputAction(c, pn.LEFT_CLICK) : o.removeInputAction(pn.LEFT_CLICK) }), this._removePostRenderEvent = e.postRender.addEventListener(function () { n._update() }) } Object.defineProperties(qv.prototype, { scene: { get: function () { return this._scene } }, performanceContainer: { get: function () { return this._performanceContainer } }, toggleDropDown: { get: function () { return this._toggleDropDown } }, showPrimitiveBoundingSphere: { get: function () { return this._showPrimitiveBoundingSphere } }, showPrimitiveReferenceFrame: { get: function () { return this._showPrimitiveReferenceFrame } }, doFilterPrimitive: { get: function () { return this._doFilterPrimitive } }, incrementDepthFrustum: { get: function () { return this._incrementDepthFrustum } }, decrementDepthFrustum: { get: function () { return this._decrementDepthFrustum } }, showTileCoordinates: { get: function () { return this._showTileCoordinates } }, showTileBoundingSphere: { get: function () { return this._showTileBoundingSphere } }, doFilterTile: { get: function () { return this._doFilterTile } }, toggleGeneral: { get: function () { return this._toggleGeneral } }, togglePrimitives: { get: function () { return this._togglePrimitives } }, toggleTerrain: { get: function () { return this._toggleTerrain } }, pickPrimitive: { get: function () { return this._pickPrimitive } }, pickTile: { get: function () { return this._pickTile } }, selectParent: { get: function () { let e = this; return An(function () { e.tile = e.tile.parent }) } }, selectNW: { get: function () { let e = this; return An(function () { e.tile = e.tile.northwestChild }) } }, selectNE: { get: function () { let e = this; return An(function () { e.tile = e.tile.northeastChild }) } }, selectSW: { get: function () { let e = this; return An(function () { e.tile = e.tile.southwestChild }) } }, selectSE: { get: function () { let e = this; return An(function () { e.tile = e.tile.southeastChild }) } }, primitive: { get: function () { return this._primitive }, set: function (e) { let t = this._primitive; e !== t && (this.hasPickedPrimitive = !0, l(t) && (t.debugShowBoundingVolume = !1), this._scene.debugCommandFilter = void 0, l(this._modelMatrixPrimitive) && (this._scene.primitives.remove(this._modelMatrixPrimitive), this._modelMatrixPrimitive = void 0), this._primitive = e, e.show = !1, setTimeout(function () { e.show = !0 }, 50), this.showPrimitiveBoundingSphere(), this.showPrimitiveReferenceFrame(), this.doFilterPrimitive()) } }, tile: { get: function () { return this._tile }, set: function (e) { if (l(e)) { this.hasPickedTile = !0; let t = this._tile; if (e !== t) { this.tileText = `L: ${e.level} X: ${e.x} Y: ${e.y}`, this.tileText += `<br>SW corner: ${e.rectangle.west}, ${e.rectangle.south}`, this.tileText += `<br>NE corner: ${e.rectangle.east}, ${e.rectangle.north}`; let n = e.data; l(n) && l(n.tileBoundingRegion) ? this.tileText += `<br>Min: ${n.tileBoundingRegion.minimumHeight} Max: ${n.tileBoundingRegion.maximumHeight}` : this.tileText += "<br>(Tile is not loaded)" } this._tile = e, this.showTileBoundingSphere(), this.doFilterTile() } else this.hasPickedTile = !1, this._tile = void 0 } } }); qv.prototype._update = function () { this.frustums && (this.frustumStatisticText = Aht(this._scene.debugFrustumStatistics)); let e = this._scene.numberOfFrustums; this._numberOfFrustums = e, this.depthFrustum = xq(1, e, this.depthFrustum), this.depthFrustumText = `${this.depthFrustum} of ${e}`, this.performance && this._performanceDisplay.update(), this.primitiveReferenceFrame && (this._modelMatrixPrimitive.modelMatrix = this._primitive.modelMatrix), this.shaderCacheText = `Cached shaders: ${this._scene.context.shaderCache.numberOfShaders}` }; qv.prototype.isDestroyed = function () { return !1 }; qv.prototype.destroy = function () { return this._eventHandler.destroy(), this._removePostRenderEvent(), this._frustumsSubscription.dispose(), this._frustumPlanesSubscription.dispose(), this._performanceSubscription.dispose(), this._primitiveBoundingSphereSubscription.dispose(), this._primitiveReferenceFrameSubscription.dispose(), this._filterPrimitiveSubscription.dispose(), this._wireframeSubscription.dispose(), this._depthFrustumSubscription.dispose(), this._suspendUpdatesSubscription.dispose(), this._tileCoordinatesSubscription.dispose(), this._tileBoundingSphereSubscription.dispose(), this._filterTileSubscription.dispose(), this._pickPrimitiveActiveSubscription.dispose(), this._pickTileActiveSubscription.dispose(), le(this) }; var P4 = qv; function I4(e, t) { e = vn(e); let n = document.createElement("div"), i = new P4(t, n); this._viewModel = i, this._container = e; let o = document.createElement("div"); this._element = o; let r = document.createElement("div"); r.textContent = "Cesium Inspector", r.className = "cesium-cesiumInspector-button", r.setAttribute("data-bind", "click: toggleDropDown"), o.appendChild(r), o.className = "cesium-cesiumInspector", o.setAttribute("data-bind", 'css: { "cesium-cesiumInspector-visible" : dropDownVisible, "cesium-cesiumInspector-hidden" : !dropDownVisible }'), e.appendChild(this._element); let s = document.createElement("div"); this._panel = s, s.className = "cesium-cesiumInspector-dropDown", o.appendChild(s); let a = Zg.createSection, c = Zg.createCheckbox, u = a(s, "General", "generalVisible", "toggleGeneral"), f = c("Show Frustums", "frustums"), d = document.createElement("div"); d.className = "cesium-cesiumInspector-frustumStatistics", d.setAttribute("data-bind", "visible: frustums, html: frustumStatisticText"), f.appendChild(d), u.appendChild(f), u.appendChild(c("Show Frustum Planes", "frustumPlanes")), u.appendChild(c("Performance Display", "performance")), n.className = "cesium-cesiumInspector-performanceDisplay", u.appendChild(n); let p = document.createElement("div"); p.className = "cesium-cesiumInspector-shaderCache", p.setAttribute("data-bind", "html: shaderCacheText"), u.appendChild(p); let g = document.createElement("div"); u.appendChild(g); let m = document.createElement("span"); m.setAttribute("data-bind", 'html: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frustum:"'), g.appendChild(m); let A = document.createElement("span"); A.setAttribute("data-bind", "text: depthFrustumText"), g.appendChild(A); let C = document.createElement("input"); C.type = "button", C.value = "-", C.className = "cesium-cesiumInspector-pickButton", C.setAttribute("data-bind", "click: decrementDepthFrustum"), g.appendChild(C); let x = document.createElement("input"); x.type = "button", x.value = "+", x.className = "cesium-cesiumInspector-pickButton", x.setAttribute("data-bind", "click: incrementDepthFrustum"), g.appendChild(x); let T = a(s, "Primitives", "primitivesVisible", "togglePrimitives"), b = document.createElement("div"); b.className = "cesium-cesiumInspector-pickSection", T.appendChild(b); let S = document.createElement("input"); S.type = "button", S.value = "Pick a primitive", S.className = "cesium-cesiumInspector-pickButton", S.setAttribute("data-bind", 'css: {"cesium-cesiumInspector-pickButtonHighlight" : pickPrimitiveActive}, click: pickPrimitive'); let D = document.createElement("div"); D.className = "cesium-cesiumInspector-center", D.appendChild(S), b.appendChild(D), b.appendChild(c("Show bounding sphere", "primitiveBoundingSphere", "hasPickedPrimitive")), b.appendChild(c("Show reference frame", "primitiveReferenceFrame", "hasPickedPrimitive")), this._primitiveOnly = c("Show only selected", "filterPrimitive", "hasPickedPrimitive"), b.appendChild(this._primitiveOnly); let P = a(s, "Terrain", "terrainVisible", "toggleTerrain"), B = document.createElement("div"); B.className = "cesium-cesiumInspector-pickSection", P.appendChild(B); let R = document.createElement("input"); R.type = "button", R.value = "Pick a tile", R.className = "cesium-cesiumInspector-pickButton", R.setAttribute("data-bind", 'css: {"cesium-cesiumInspector-pickButtonHighlight" : pickTileActive}, click: pickTile'), D = document.createElement("div"), D.appendChild(R), D.className = "cesium-cesiumInspector-center", B.appendChild(D); let M = document.createElement("div"); B.appendChild(M); let L = document.createElement("input"); L.type = "button", L.value = "Parent", L.className = "cesium-cesiumInspector-pickButton", L.setAttribute("data-bind", "click: selectParent"); let _ = document.createElement("input"); _.type = "button", _.value = "NW", _.className = "cesium-cesiumInspector-pickButton", _.setAttribute("data-bind", "click: selectNW"); let E = document.createElement("input"); E.type = "button", E.value = "NE", E.className = "cesium-cesiumInspector-pickButton", E.setAttribute("data-bind", "click: selectNE"); let w = document.createElement("input"); w.type = "button", w.value = "SW", w.className = "cesium-cesiumInspector-pickButton", w.setAttribute("data-bind", "click: selectSW"); let v = document.createElement("input"); v.type = "button", v.value = "SE", v.className = "cesium-cesiumInspector-pickButton", v.setAttribute("data-bind", "click: selectSE"); let O = document.createElement("div"); O.className = "cesium-cesiumInspector-tileText", M.className = "cesium-cesiumInspector-frustumStatistics", M.appendChild(O), M.setAttribute("data-bind", "visible: hasPickedTile"), O.setAttribute("data-bind", "html: tileText"); let V = document.createElement("div"); V.className = "cesium-cesiumInspector-relativeText", V.textContent = "Select relative:", M.appendChild(V); let z = document.createElement("table"), k = document.createElement("tr"), G = document.createElement("tr"), N = document.createElement("td"); N.appendChild(L); let X = document.createElement("td"); X.appendChild(_); let q = document.createElement("td"); q.appendChild(E), k.appendChild(N), k.appendChild(X), k.appendChild(q); let J = document.createElement("td"), W = document.createElement("td"); W.appendChild(w); let K = document.createElement("td"); K.appendChild(v), G.appendChild(J), G.appendChild(W), G.appendChild(K), z.appendChild(k), z.appendChild(G), M.appendChild(z), B.appendChild(c("Show bounding volume", "tileBoundingSphere", "hasPickedTile")), B.appendChild(c("Show only selected", "filterTile", "hasPickedTile")), P.appendChild(c("Wireframe", "wireframe")), P.appendChild(c("Suspend LOD update", "suspendUpdates")), P.appendChild(c("Show tile coordinates", "tileCoordinates")), Ae.applyBindings(i, this._element) } Object.defineProperties(I4.prototype, { container: { get: function () { return this._container } }, viewModel: { get: function () { return this._viewModel } } }); I4.prototype.isDestroyed = function () { return !1 }; I4.prototype.destroy = function () { return Ae.cleanNode(this._element), this._container.removeChild(this._element), this.viewModel.destroy(), le(this) }; var O4 = I4; function B4(e, t) { l(t) || (t = document.body), t = vn(t); let n = this, i = Ae.observable(hr.fullscreen), o = Ae.observable(hr.enabled), r = t.ownerDocument; this.isFullscreen = void 0, Ae.defineProperty(this, "isFullscreen", { get: function () { return i() } }), this.isFullscreenEnabled = void 0, Ae.defineProperty(this, "isFullscreenEnabled", { get: function () { return o() }, set: function (s) { o(s && hr.enabled) } }), this.tooltip = void 0, Ae.defineProperty(this, "tooltip", function () { return this.isFullscreenEnabled ? i() ? "Exit full screen" : "Full screen" : "Full screen unavailable" }), this._command = An(function () { hr.fullscreen ? hr.exitFullscreen() : hr.requestFullscreen(n._fullscreenElement) }, Ae.getObservable(this, "isFullscreenEnabled")), this._fullscreenElement = y(vn(e), r.body), this._callback = function () { i(hr.fullscreen) }, r.addEventListener(hr.changeEventName, this._callback) } Object.defineProperties(B4.prototype, { fullscreenElement: { get: function () { return this._fullscreenElement }, set: function (e) { this._fullscreenElement = e } }, command: { get: function () { return this._command } } }); B4.prototype.isDestroyed = function () { return !1 }; B4.prototype.destroy = function () { document.removeEventListener(hr.changeEventName, this._callback), le(this) }; var R4 = B4; var Tht = "M 83.96875 17.5625 L 83.96875 17.59375 L 76.65625 24.875 L 97.09375 24.96875 L 76.09375 45.96875 L 81.9375 51.8125 L 102.78125 30.9375 L 102.875 51.15625 L 110.15625 43.875 L 110.1875 17.59375 L 83.96875 17.5625 z M 44.125 17.59375 L 17.90625 17.625 L 17.9375 43.90625 L 25.21875 51.1875 L 25.3125 30.96875 L 46.15625 51.8125 L 52 45.96875 L 31 25 L 51.4375 24.90625 L 44.125 17.59375 z M 46.0625 76.03125 L 25.1875 96.875 L 25.09375 76.65625 L 17.8125 83.9375 L 17.8125 110.21875 L 44 110.25 L 51.3125 102.9375 L 30.90625 102.84375 L 51.875 81.875 L 46.0625 76.03125 z M 82 76.15625 L 76.15625 82 L 97.15625 103 L 76.71875 103.0625 L 84.03125 110.375 L 110.25 110.34375 L 110.21875 84.0625 L 102.9375 76.8125 L 102.84375 97 L 82 76.15625 z", Eht = "M 104.34375 17.5625 L 83.5 38.4375 L 83.40625 18.21875 L 76.125 25.5 L 76.09375 51.78125 L 102.3125 51.8125 L 102.3125 51.78125 L 109.625 44.5 L 89.1875 44.40625 L 110.1875 23.40625 L 104.34375 17.5625 z M 23.75 17.59375 L 17.90625 23.4375 L 38.90625 44.4375 L 18.5 44.53125 L 25.78125 51.8125 L 52 51.78125 L 51.96875 25.53125 L 44.6875 18.25 L 44.625 38.46875 L 23.75 17.59375 z M 25.6875 76.03125 L 18.375 83.3125 L 38.78125 83.40625 L 17.8125 104.40625 L 23.625 110.25 L 44.5 89.375 L 44.59375 109.59375 L 51.875 102.3125 L 51.875 76.0625 L 25.6875 76.03125 z M 102.375 76.15625 L 76.15625 76.1875 L 76.1875 102.4375 L 83.46875 109.71875 L 83.5625 89.53125 L 104.40625 110.375 L 110.25 104.53125 L 89.25 83.53125 L 109.6875 83.46875 L 102.375 76.15625 z"; function M4(e, t) { e = vn(e); let n = new R4(t, e); n._exitFullScreenPath = Eht, n._enterFullScreenPath = Tht; let i = document.createElement("button"); i.type = "button", i.className = "cesium-button cesium-fullscreenButton", i.setAttribute("data-bind", "attr: { title: tooltip },click: command,enable: isFullscreenEnabled,cesiumSvgPath: { path: isFullscreen ? _exitFullScreenPath : _enterFullScreenPath, width: 128, height: 128 }"), e.appendChild(i), Ae.applyBindings(n, i), this._container = e, this._viewModel = n, this._element = i } Object.defineProperties(M4.prototype, { container: { get: function () { return this._container } }, viewModel: { get: function () { return this._viewModel } } }); M4.prototype.isDestroyed = function () { return !1 }; M4.prototype.destroy = function () { return this._viewModel.destroy(), Ae.cleanNode(this._element), this._container.removeChild(this._element), le(this) }; var L4 = M4; var B0e = 1e3; function kh(e) { l(e.geocoderServices) ? this._geocoderServices = e.geocoderServices : this._geocoderServices = [new B3, new Z3({ scene: e.scene })], this._viewContainer = e.container, this._scene = e.scene, this._flightDuration = e.flightDuration, this._searchText = "", this._isSearchInProgress = !1, this._geocodePromise = void 0, this._complete = new _e, this._suggestions = [], this._selectedSuggestion = void 0, this._showSuggestions = !0, this._handleArrowDown = M0e, this._handleArrowUp = R0e; let t = this; this._suggestionsVisible = Ae.pureComputed(function () { let o = Ae.getObservable(t, "_suggestions")().length > 0, r = Ae.getObservable(t, "_showSuggestions")(); return o && r }), this._searchCommand = An(function (i) { if (i = y(i, qy.SEARCH), t._focusTextbox = !1, l(t._selectedSuggestion)) return t.activateSuggestion(t._selectedSuggestion), !1; t.hideSuggestions(), t.isSearchInProgress ? Pht(t) : Dht(t, t._geocoderServices, i) }), this.deselectSuggestion = function () { t._selectedSuggestion = void 0 }, this.handleKeyDown = function (i, o) { let r = o.key === "ArrowDown" || o.key === "Down" || o.keyCode === 40, s = o.key === "ArrowUp" || o.key === "Up" || o.keyCode === 38; return (r || s) && o.preventDefault(), !0 }, this.handleKeyUp = function (i, o) { let r = o.key === "ArrowDown" || o.key === "Down" || o.keyCode === 40, s = o.key === "ArrowUp" || o.key === "Up" || o.keyCode === 38, a = o.key === "Enter" || o.keyCode === 13; return s ? R0e(t) : r ? M0e(t) : a && t._searchCommand(), !0 }, this.activateSuggestion = function (i) { t.hideSuggestions(), t._searchText = i.displayName; let o = i.destination; F0e(t), t.destinationFound(t, o) }, this.hideSuggestions = function () { t._showSuggestions = !1, t._selectedSuggestion = void 0 }, this.showSuggestions = function () { t._showSuggestions = !0 }, this.handleMouseover = function (i, o) { i !== t._selectedSuggestion && (t._selectedSuggestion = i) }, this.keepExpanded = !1, this.autoComplete = y(e.autocomplete, !0), this.destinationFound = y(e.destinationFound, kh.flyToDestination), this._focusTextbox = !1, Ae.track(this, ["_searchText", "_isSearchInProgress", "keepExpanded", "_suggestions", "_selectedSuggestion", "_showSuggestions", "_focusTextbox"]); let n = Ae.getObservable(this, "_searchText"); n.extend({ rateLimit: { timeout: 500 } }), this._suggestionSubscription = n.subscribe(function () { kh._updateSearchSuggestions(t) }), this.isSearchInProgress = void 0, Ae.defineProperty(this, "isSearchInProgress", { get: function () { return this._isSearchInProgress } }), this.searchText = void 0, Ae.defineProperty(this, "searchText", { get: function () { return this.isSearchInProgress ? "Searching..." : this._searchText }, set: function (i) { this._searchText = i } }), this.flightDuration = void 0, Ae.defineProperty(this, "flightDuration", { get: function () { return this._flightDuration }, set: function (i) { this._flightDuration = i } }) } Object.defineProperties(kh.prototype, { complete: { get: function () { return this._complete } }, scene: { get: function () { return this._scene } }, search: { get: function () { return this._searchCommand } }, selectedSuggestion: { get: function () { return this._selectedSuggestion } }, suggestions: { get: function () { return this._suggestions } } }); kh.prototype.destroy = function () { this._suggestionSubscription.dispose() }; function R0e(e) { if (e._suggestions.length === 0) return; let t = e._suggestions.indexOf(e._selectedSuggestion); if (t === -1 || t === 0) { e._selectedSuggestion = void 0; return } let n = t - 1; e._selectedSuggestion = e._suggestions[n], kh._adjustSuggestionsScroll(e, n) } function M0e(e) { if (e._suggestions.length === 0) return; let t = e._suggestions.length, i = (e._suggestions.indexOf(e._selectedSuggestion) + 1) % t; e._selectedSuggestion = e._suggestions[i], kh._adjustSuggestionsScroll(e, i) } function bht(e, t) { let n = l(t) ? t.availability : void 0; return l(n) ? rg(t, [e]).then(function (i) { return e = i[0], e.height += B0e, e }) : (e.height += B0e, Promise.resolve(e)) } function Sht(e, t) { let n = e._scene, o = n.mapProjection.ellipsoid, r = n.camera, s = n.terrainProvider, a = t, c; return t instanceof ce ? I.equalsEpsilon(t.south, t.north, I.EPSILON7) && I.equalsEpsilon(t.east, t.west, I.EPSILON7) ? t = ce.center(t) : c = TE(t, n) : t = o.cartesianToCartographic(t), l(c) || (c = bht(t, s)), c.then(function (u) { a = o.cartographicToCartesian(u) }).finally(function () { r.flyTo({ destination: a, complete: function () { e._complete.raiseEvent() }, duration: e._flightDuration, endTransform: F.IDENTITY }) }) } function wht(e, t, n, i) { return e.then(function (o) { return l(o) && o.state === "fulfilled" && o.value.length > 0 ? o : t.geocode(n, i).then(function (s) { return { state: "fulfilled", value: s } }).catch(function (s) { return { state: "rejected", reason: s } }) }) } function Dht(e, t, n) { let i = e._searchText; if (L0e(i)) { e.showSuggestions(); return } e._isSearchInProgress = !0; let o = Promise.resolve(); for (let r = 0; r < t.length; r++)o = wht(o, t[r], i, n); e._geocodePromise = o, o.then(function (r) { if (o.cancel) return; e._isSearchInProgress = !1; let s = r.value; if (r.state === "fulfilled" && l(s) && s.length > 0) { e._searchText = s[0].displayName, e.destinationFound(e, s[0].destination); return } e._searchText = `${i} (not found)` }) } function vht(e, t) { let n = vn(e._viewContainer), i = n.getElementsByClassName("search-results")[0], r = n.getElementsByTagName("li")[t]; if (t === 0) { i.scrollTop = 0; return } let s = r.offsetTop; s + r.clientHeight > i.clientHeight ? i.scrollTop = s + r.clientHeight : s < i.scrollTop && (i.scrollTop = s) } function Pht(e) { e._isSearchInProgress = !1, l(e._geocodePromise) && (e._geocodePromise.cancel = !0, e._geocodePromise = void 0) } function L0e(e) { return /^\s*$/.test(e) } function F0e(e) { Ae.getObservable(e, "_suggestions").removeAll() } function Iht(e) { if (!e.autoComplete) return; let t = e._searchText; if (F0e(e), L0e(t)) return; let n = Promise.resolve([]); return e._geocoderServices.forEach(function (i) { n = n.then(function (o) { return o.length >= 5 ? o : i.geocode(t, qy.AUTOCOMPLETE).then(function (r) { return o = o.concat(r), o }) }) }), n.then(function (i) { let o = e._suggestions; for (let r = 0; r < i.length; r++)o.push(i[r]) }) } kh.flyToDestination = Sht; kh._updateSearchSuggestions = Iht; kh._adjustSuggestionsScroll = vht; var F4 = kh; var Oht = "M29.772,26.433l-7.126-7.126c0.96-1.583,1.523-3.435,1.524-5.421C24.169,8.093,19.478,3.401,13.688,3.399C7.897,3.401,3.204,8.093,3.204,13.885c0,5.789,4.693,10.481,10.484,10.481c1.987,0,3.839-0.563,5.422-1.523l7.128,7.127L29.772,26.433zM7.203,13.885c0.006-3.582,2.903-6.478,6.484-6.486c3.579,0.008,6.478,2.904,6.484,6.486c-0.007,3.58-2.905,6.476-6.484,6.484C10.106,20.361,7.209,17.465,7.203,13.885z", Bht = "M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z"; function N4(e) { let t = vn(e.container), n = new F4(e); n._startSearchPath = Oht, n._stopSearchPath = Bht; let i = document.createElement("form"); i.setAttribute("data-bind", "submit: search"); let o = document.createElement("input"); o.type = "search", o.className = "cesium-geocoder-input", o.setAttribute("placeholder", "Enter an address or landmark..."), o.setAttribute("data-bind", 'textInput: searchText,disable: isSearchInProgress,event: { keyup: handleKeyUp, keydown: handleKeyDown, mouseover: deselectSuggestion },css: { "cesium-geocoder-input-wide" : keepExpanded || searchText.length > 0 },hasFocus: _focusTextbox'), this._onTextBoxFocus = function () { setTimeout(function () { o.select() }, 0) }, o.addEventListener("focus", this._onTextBoxFocus, !1), i.appendChild(o), this._textBox = o; let r = document.createElement("span"); r.className = "cesium-geocoder-searchButton", r.setAttribute("data-bind", "click: search,cesiumSvgPath: { path: isSearchInProgress ? _stopSearchPath : _startSearchPath, width: 32, height: 32 }"), i.appendChild(r), t.appendChild(i); let s = document.createElement("div"); s.className = "search-results", s.setAttribute("data-bind", "visible: _suggestionsVisible"); let a = document.createElement("ul"); a.setAttribute("data-bind", "foreach: _suggestions"); let c = document.createElement("li"); a.appendChild(c), c.setAttribute("data-bind", "text: $data.displayName, click: $parent.activateSuggestion, event: { mouseover: $parent.handleMouseover}, css: { active: $data === $parent._selectedSuggestion }"), s.appendChild(a), t.appendChild(s), Ae.applyBindings(n, i), Ae.applyBindings(n, s), this._container = t, this._searchSuggestionsContainer = s, this._viewModel = n, this._form = i, this._onInputBegin = function (u) { let f = u.target; typeof u.composedPath == "function" && (f = u.composedPath()[0]), t.contains(f) || (n._focusTextbox = !1, n.hideSuggestions()) }, this._onInputEnd = function (u) { n._focusTextbox = !0, n.showSuggestions() }, Nt.supportsPointerEvents() ? (document.addEventListener("pointerdown", this._onInputBegin, !0), t.addEventListener("pointerup", this._onInputEnd, !0), t.addEventListener("pointercancel", this._onInputEnd, !0)) : (document.addEventListener("mousedown", this._onInputBegin, !0), t.addEventListener("mouseup", this._onInputEnd, !0), document.addEventListener("touchstart", this._onInputBegin, !0), t.addEventListener("touchend", this._onInputEnd, !0), t.addEventListener("touchcancel", this._onInputEnd, !0)) } Object.defineProperties(N4.prototype, { container: { get: function () { return this._container } }, searchSuggestionsContainer: { get: function () { return this._searchSuggestionsContainer } }, viewModel: { get: function () { return this._viewModel } } }); N4.prototype.isDestroyed = function () { return !1 }; N4.prototype.destroy = function () { let e = this._container; return Nt.supportsPointerEvents() ? (document.removeEventListener("pointerdown", this._onInputBegin, !0), e.removeEventListener("pointerup", this._onInputEnd, !0)) : (document.removeEventListener("mousedown", this._onInputBegin, !0), e.removeEventListener("mouseup", this._onInputEnd, !0), document.removeEventListener("touchstart", this._onInputBegin, !0), e.removeEventListener("touchend", this._onInputEnd, !0)), this._viewModel.destroy(), Ae.cleanNode(this._form), Ae.cleanNode(this._searchSuggestionsContainer), e.removeChild(this._form), e.removeChild(this._searchSuggestionsContainer), this._textBox.removeEventListener("focus", this._onTextBoxFocus, !1), le(this) }; var V4 = N4; function N0e(e, t) { this._scene = e, this._duration = t; let n = this; this._command = An(function () { n._scene.camera.flyHome(n._duration) }), this.tooltip = "View Home", Ae.track(this, ["tooltip"]) } Object.defineProperties(N0e.prototype, { scene: { get: function () { return this._scene } }, command: { get: function () { return this._command } }, duration: { get: function () { return this._duration }, set: function (e) { this._duration = e } } }); var k4 = N0e; function U4(e, t, n) { e = vn(e); let i = new k4(t, n); i._svgPath = "M14,4l-10,8.75h20l-4.25-3.7188v-4.6562h-2.812v2.1875l-2.938-2.5625zm-7.0938,9.906v10.094h14.094v-10.094h-14.094zm2.1876,2.313h3.3122v4.25h-3.3122v-4.25zm5.8442,1.281h3.406v6.438h-3.406v-6.438z"; let o = document.createElement("button"); o.type = "button", o.className = "cesium-button cesium-toolbar-button cesium-home-button", o.setAttribute("data-bind", "attr: { title: tooltip },click: command,cesiumSvgPath: { path: _svgPath, width: 28, height: 28 }"), e.appendChild(o), Ae.applyBindings(i, o), this._container = e, this._viewModel = i, this._element = o } Object.defineProperties(U4.prototype, { container: { get: function () { return this._container } }, viewModel: { get: function () { return this._viewModel } } }); U4.prototype.isDestroyed = function () { return !1 }; U4.prototype.destroy = function () { return Ae.cleanNode(this._element), this._container.removeChild(this._element), le(this) }; var z4 = U4; function ZE(e) { return Jt(`Assets/Textures/SkyBox/tycho2t3_80_${e}.jpg`) } function Rht(e) { e._renderLoopRunning = !0; let t = 0; function n(i) { if (!e.isDestroyed()) if (e._useDefaultRenderLoop) try { let o = e._targetFrameRate; if (!l(o)) e.resize(), e.render(), requestAnimationFrame(n); else { let r = 1e3 / o, s = i - t; s > r && (e.resize(), e.render(), t = i - s % r), requestAnimationFrame(n) } } catch (o) { if (e._useDefaultRenderLoop = !1, e._renderLoopRunning = !1, e._showRenderLoopErrors) { let r = "An error occurred while rendering.  Rendering has stopped."; e.showErrorPanel(r, void 0, o) } } else e._renderLoopRunning = !1 } requestAnimationFrame(n) } function V0e(e) { let t = e._useBrowserRecommendedResolution ? 1 : window.devicePixelRatio; return t *= e._resolutionScale, l(e._scene) && (e._scene.pixelRatio = t), t } function k0e(e) { let t = e._canvas, n = t.clientWidth, i = t.clientHeight, o = V0e(e); e._canvasClientWidth = n, e._canvasClientHeight = i, n *= o, i *= o, t.width = n, t.height = i, e._canRender = n !== 0 && i !== 0, e._lastDevicePixelRatio = window.devicePixelRatio } function U0e(e) { let t = e._canvas, n = t.width, i = t.height; if (n !== 0 && i !== 0) { let o = e._scene.camera.frustum; l(o.aspectRatio) ? o.aspectRatio = n / i : (o.top = o.right * (i / n), o.bottom = -o.top) } } function SA(e, t) { e = vn(e), t = y(t, y.EMPTY_OBJECT); let n = document.createElement("div"); n.className = "cesium-widget", e.appendChild(n); let i = document.createElement("canvas"), o = Nt.supportsImageRenderingPixelated(); this._supportsImageRenderingPixelated = o, o && (i.style.imageRendering = Nt.imageRenderingValue()), i.oncontextmenu = function () { return !1 }, i.onselectstart = function () { return !1 }; function r() { i !== i.ownerDocument.activeElement && i.ownerDocument.activeElement.blur() } y(t.blurActiveElementOnCanvasFocus, !0) && (i.addEventListener("mousedown", r), i.addEventListener("pointerdown", r)), n.appendChild(i); let a = document.createElement("div"); a.className = "cesium-widget-credits"; let c = l(t.creditContainer) ? vn(t.creditContainer) : n; c.appendChild(a); let u = l(t.creditViewport) ? vn(t.creditViewport) : n, f = y(t.showRenderLoopErrors, !0), d = y(t.useBrowserRecommendedResolution, !0); this._element = n, this._container = e, this._canvas = i, this._canvasClientWidth = 0, this._canvasClientHeight = 0, this._lastDevicePixelRatio = 0, this._creditViewport = u, this._creditContainer = c, this._innerCreditContainer = a, this._canRender = !1, this._renderLoopRunning = !1, this._showRenderLoopErrors = f, this._resolutionScale = 1, this._useBrowserRecommendedResolution = d, this._forceResize = !1, this._clock = l(t.clock) ? t.clock : new sh, k0e(this); try { let p = new JU({ canvas: i, contextOptions: t.contextOptions, creditContainer: a, creditViewport: u, mapProjection: t.mapProjection, orderIndependentTranslucency: t.orderIndependentTranslucency, scene3DOnly: y(t.scene3DOnly, !1), shadows: t.shadows, mapMode2D: t.mapMode2D, requestRenderMode: t.requestRenderMode, maximumRenderTimeChange: t.maximumRenderTimeChange, depthPlaneEllipsoidOffset: t.depthPlaneEllipsoidOffset, msaaSamples: t.msaaSamples }); this._scene = p, p.camera.constrainedAxis = h.UNIT_Z, V0e(this), U0e(this); let g = y(p.mapProjection.ellipsoid, ie.WGS84), m = t.globe; l(m) || (m = new Uk(g)), m !== !1 && (p.globe = m, p.globe.shadows = y(t.terrainShadows, hn.RECEIVE_ONLY)); let A = t.skyBox; l(A) || (A = new i4({ sources: { positiveX: ZE("px"), negativeX: ZE("mx"), positiveY: ZE("py"), negativeY: ZE("my"), positiveZ: ZE("pz"), negativeZ: ZE("mz") } })), A !== !1 && (p.skyBox = A, p.sun = new a4, p.moon = new Xk); let C = t.skyAtmosphere; l(C) || (C = new $U(g)), C !== !1 && (p.skyAtmosphere = C); let x = t.globe === !1 ? !1 : t.imageryProvider; l(x) || (x = Ug()), x !== !1 && p.imageryLayers.addImageryProvider(x), l(t.terrainProvider) && t.globe !== !1 && (p.terrainProvider = t.terrainProvider), this._screenSpaceEventHandler = new Xu(i), l(t.sceneMode) && (t.sceneMode === ee.SCENE2D && this._scene.morphTo2D(0), t.sceneMode === ee.COLUMBUS_VIEW && this._scene.morphToColumbusView(0)), this._useDefaultRenderLoop = void 0, this.useDefaultRenderLoop = y(t.useDefaultRenderLoop, !0), this._targetFrameRate = void 0, this.targetFrameRate = t.targetFrameRate; let T = this; this._onRenderError = function (b, S) { if (T._useDefaultRenderLoop = !1, T._renderLoopRunning = !1, T._showRenderLoopErrors) { let D = "An error occurred while rendering.  Rendering has stopped."; T.showErrorPanel(D, void 0, S) } }, p.renderError.addEventListener(this._onRenderError) } catch (p) { if (f) { let g = "Error constructing CesiumWidget.", m = 'Visit <a href="http://get.webgl.org">http://get.webgl.org</a> to verify that your web browser and hardware support WebGL.  Consider trying a different web browser or updating your video drivers.  Detailed error information is below:'; this.showErrorPanel(g, m, p) } throw p } } Object.defineProperties(SA.prototype, { container: { get: function () { return this._container } }, canvas: { get: function () { return this._canvas } }, creditContainer: { get: function () { return this._creditContainer } }, creditViewport: { get: function () { return this._creditViewport } }, scene: { get: function () { return this._scene } }, imageryLayers: { get: function () { return this._scene.imageryLayers } }, terrainProvider: { get: function () { return this._scene.terrainProvider }, set: function (e) { this._scene.terrainProvider = e } }, camera: { get: function () { return this._scene.camera } }, clock: { get: function () { return this._clock } }, screenSpaceEventHandler: { get: function () { return this._screenSpaceEventHandler } }, targetFrameRate: { get: function () { return this._targetFrameRate }, set: function (e) { this._targetFrameRate = e } }, useDefaultRenderLoop: { get: function () { return this._useDefaultRenderLoop }, set: function (e) { this._useDefaultRenderLoop !== e && (this._useDefaultRenderLoop = e, e && !this._renderLoopRunning && Rht(this)) } }, resolutionScale: { get: function () { return this._resolutionScale }, set: function (e) { this._resolutionScale !== e && (this._resolutionScale = e, this._forceResize = !0) } }, useBrowserRecommendedResolution: { get: function () { return this._useBrowserRecommendedResolution }, set: function (e) { this._useBrowserRecommendedResolution !== e && (this._useBrowserRecommendedResolution = e, this._forceResize = !0) } } }); SA.prototype.showErrorPanel = function (e, t, n) {
        let i = this._element, o = document.createElement("div"); o.className = "cesium-widget-errorPanel"; let r = document.createElement("div"); r.className = "cesium-widget-errorPanel-content", o.appendChild(r); let s = document.createElement("div"); s.className = "cesium-widget-errorPanel-header", s.appendChild(document.createTextNode(e)), r.appendChild(s); let a = document.createElement("div"); a.className = "cesium-widget-errorPanel-scroll", r.appendChild(a); function c() { a.style.maxHeight = `${Math.max(Math.round(i.clientHeight * .9 - 100), 30)}px` } c(), l(window.addEventListener) && window.addEventListener("resize", c, !1); let u = l(t), f = l(n); if (u || f) {
            let g = document.createElement("div"); if (g.className = "cesium-widget-errorPanel-message", a.appendChild(g), f) {
                let m = ap(n); u || (typeof n == "string" && (n = new Error(n)), t = ap({ name: n.name, message: n.message }), m = n.stack), typeof console < "u" && console.error(`${e}
${t}
${m}`); let A = document.createElement("div"); A.className = "cesium-widget-errorPanel-message-details collapsed"; let C = document.createElement("span"); C.className = "cesium-widget-errorPanel-more-details", C.appendChild(document.createTextNode("See more...")), A.appendChild(C), A.onclick = function (x) { A.removeChild(C), A.appendChild(document.createTextNode(m)), A.className = "cesium-widget-errorPanel-message-details", r.className = "cesium-widget-errorPanel-content expanded", A.onclick = void 0 }, a.appendChild(A)
            } g.innerHTML = `<p>${t}</p>`
        } let d = document.createElement("div"); d.className = "cesium-widget-errorPanel-buttonPanel", r.appendChild(d); let p = document.createElement("button"); p.setAttribute("type", "button"), p.className = "cesium-button", p.appendChild(document.createTextNode("OK")), p.onclick = function () { l(c) && l(window.removeEventListener) && window.removeEventListener("resize", c, !1), i.removeChild(o) }, d.appendChild(p), i.appendChild(o)
    }; SA.prototype.isDestroyed = function () { return !1 }; SA.prototype.destroy = function () { l(this._scene) && (this._scene.renderError.removeEventListener(this._onRenderError), this._scene = this._scene.destroy()), this._container.removeChild(this._element), this._creditContainer.removeChild(this._innerCreditContainer), le(this) }; SA.prototype.resize = function () { let e = this._canvas; !this._forceResize && this._canvasClientWidth === e.clientWidth && this._canvasClientHeight === e.clientHeight && this._lastDevicePixelRatio === window.devicePixelRatio || (this._forceResize = !1, k0e(this), U0e(this), this._scene.requestRender()) }; SA.prototype.render = function () { if (this._canRender) { this._scene.initializeFrame(); let e = this._clock.tick(); this._scene.render(e) } else this._clock.tick() }; var H4 = SA; var Mht = "M 13.84375 7.03125 C 11.412798 7.03125 9.46875 8.975298 9.46875 11.40625 L 9.46875 11.59375 L 2.53125 7.21875 L 2.53125 24.0625 L 9.46875 19.6875 C 9.4853444 22.104033 11.423165 24.0625 13.84375 24.0625 L 25.875 24.0625 C 28.305952 24.0625 30.28125 22.087202 30.28125 19.65625 L 30.28125 11.40625 C 30.28125 8.975298 28.305952 7.03125 25.875 7.03125 L 13.84375 7.03125 z", Lht = "M 27.34375 1.65625 L 5.28125 27.9375 L 8.09375 30.3125 L 30.15625 4.03125 L 27.34375 1.65625 z M 13.84375 7.03125 C 11.412798 7.03125 9.46875 8.975298 9.46875 11.40625 L 9.46875 11.59375 L 2.53125 7.21875 L 2.53125 24.0625 L 9.46875 19.6875 C 9.4724893 20.232036 9.5676108 20.7379 9.75 21.21875 L 21.65625 7.03125 L 13.84375 7.03125 z M 28.21875 7.71875 L 14.53125 24.0625 L 25.875 24.0625 C 28.305952 24.0625 30.28125 22.087202 30.28125 19.65625 L 30.28125 11.40625 C 30.28125 9.8371439 29.456025 8.4902779 28.21875 7.71875 z"; function Tq() { this._cameraClicked = new _e, this._closeClicked = new _e, this.maxHeight = 500, this.enableCamera = !1, this.isCameraTracking = !1, this.showInfo = !1, this.titleText = "", this.description = "", Ae.track(this, ["showInfo", "titleText", "description", "maxHeight", "enableCamera", "isCameraTracking"]), this._loadingIndicatorHtml = '<div class="cesium-infoBox-loadingContainer"><span class="cesium-infoBox-loading"></span></div>', this.cameraIconPath = void 0, Ae.defineProperty(this, "cameraIconPath", { get: function () { return !this.enableCamera || this.isCameraTracking ? Lht : Mht } }), Ae.defineProperty(this, "_bodyless", { get: function () { return !l(this.description) || this.description.length === 0 } }) } Tq.prototype.maxHeightOffset = function (e) { return `${this.maxHeight - e}px` }; Object.defineProperties(Tq.prototype, { cameraClicked: { get: function () { return this._cameraClicked } }, closeClicked: { get: function () { return this._closeClicked } } }); var G4 = Tq; function W4(e) { e = vn(e); let t = document.createElement("div"); t.className = "cesium-infoBox", t.setAttribute("data-bind", 'css: { "cesium-infoBox-visible" : showInfo, "cesium-infoBox-bodyless" : _bodyless }'), e.appendChild(t); let n = document.createElement("div"); n.className = "cesium-infoBox-title", n.setAttribute("data-bind", "text: titleText"), t.appendChild(n); let i = document.createElement("button"); i.type = "button", i.className = "cesium-button cesium-infoBox-camera", i.setAttribute("data-bind", 'attr: { title: "Focus camera on object" },click: function () { cameraClicked.raiseEvent(this); },enable: enableCamera,cesiumSvgPath: { path: cameraIconPath, width: 32, height: 32 }'), t.appendChild(i); let o = document.createElement("button"); o.type = "button", o.className = "cesium-infoBox-close", o.setAttribute("data-bind", "click: function () { closeClicked.raiseEvent(this); }"), o.innerHTML = "&times;", t.appendChild(o); let r = document.createElement("iframe"); r.className = "cesium-infoBox-iframe", r.setAttribute("sandbox", "allow-same-origin allow-popups allow-forms"), r.setAttribute("data-bind", "style : { maxHeight : maxHeightOffset(40) }"), r.setAttribute("allowfullscreen", !0), t.appendChild(r); let s = new G4; Ae.applyBindings(s, t), this._container = e, this._element = t, this._frame = r, this._viewModel = s, this._descriptionSubscription = void 0; let a = this; r.addEventListener("load", function () { let c = r.contentDocument, u = c.createElement("link"); u.href = Jt("Widgets/InfoBox/InfoBoxDescription.css"), u.rel = "stylesheet", u.type = "text/css"; let f = c.createElement("div"); f.className = "cesium-infoBox-description", c.head.appendChild(u), c.body.appendChild(f), a._descriptionSubscription = aa(s, "description", function (d) { r.style.height = "5px", f.innerHTML = d; let p = null, g = f.firstElementChild; if (g !== null && f.childNodes.length === 1) { let A = window.getComputedStyle(g); if (A !== null) { let C = A["background-color"], x = U.fromCssColorString(C); l(x) && x.alpha !== 0 && (p = A["background-color"]) } } t.style["background-color"] = p; let m = f.getBoundingClientRect().height; r.style.height = `${m}px` }) }), r.setAttribute("src", "about:blank") } Object.defineProperties(W4.prototype, { container: { get: function () { return this._container } }, viewModel: { get: function () { return this._viewModel } }, frame: { get: function () { return this._frame } } }); W4.prototype.isDestroyed = function () { return !1 }; W4.prototype.destroy = function () { let e = this._container; return Ae.cleanNode(this._element), e.removeChild(this._element), l(this._descriptionSubscription) && this._descriptionSubscription.dispose(), le(this) }; var j4 = W4; function Eq(e) { this._scene = e.scene, this.lowFrameRateMessage = y(e.lowFrameRateMessage, "This application appears to be performing poorly on your system.  Please try using a different web browser or updating your video drivers."), this.lowFrameRateMessageDismissed = !1, this.showingLowFrameRateMessage = !1, Ae.track(this, ["lowFrameRateMessage", "lowFrameRateMessageDismissed", "showingLowFrameRateMessage"]); let t = this; this._dismissMessage = An(function () { t.showingLowFrameRateMessage = !1, t.lowFrameRateMessageDismissed = !0 }); let n = lk.fromScene(e.scene); this._unsubscribeLowFrameRate = n.lowFrameRate.addEventListener(function () { t.lowFrameRateMessageDismissed || (t.showingLowFrameRateMessage = !0) }), this._unsubscribeNominalFrameRate = n.nominalFrameRate.addEventListener(function () { t.showingLowFrameRateMessage = !1 }) } Object.defineProperties(Eq.prototype, { scene: { get: function () { return this._scene } }, dismissMessage: { get: function () { return this._dismissMessage } } }); Eq.prototype.destroy = function () { return this._unsubscribeLowFrameRate(), this._unsubscribeNominalFrameRate(), le(this) }; var q4 = Eq; function Y4(e) { let t = vn(e.container), n = new q4(e), i = document.createElement("div"); i.className = "cesium-performance-watchdog-message-area", i.setAttribute("data-bind", "visible: showingLowFrameRateMessage"); let o = document.createElement("button"); o.setAttribute("type", "button"), o.className = "cesium-performance-watchdog-message-dismiss", o.innerHTML = "&times;", o.setAttribute("data-bind", "click: dismissMessage"), i.appendChild(o); let r = document.createElement("div"); r.className = "cesium-performance-watchdog-message", r.setAttribute("data-bind", "html: lowFrameRateMessage"), i.appendChild(r), t.appendChild(i), Ae.applyBindings(n, i), this._container = t, this._viewModel = n, this._element = i } Object.defineProperties(Y4.prototype, { container: { get: function () { return this._container } }, viewModel: { get: function () { return this._viewModel } } }); Y4.prototype.isDestroyed = function () { return !1 }; Y4.prototype.destroy = function () { return this._viewModel.destroy(), Ae.cleanNode(this._element), this._container.removeChild(this._element), le(this) }; var X4 = Y4; function z0e() { this.showInstructions = !1; let e = this; this._command = An(function () { e.showInstructions = !e.showInstructions }), this._showClick = An(function () { e._touch = !1 }), this._showTouch = An(function () { e._touch = !0 }), this._touch = !1, this.tooltip = "Navigation Instructions", Ae.track(this, ["tooltip", "showInstructions", "_touch"]) } Object.defineProperties(z0e.prototype, { command: { get: function () { return this._command } }, showClick: { get: function () { return this._showClick } }, showTouch: { get: function () { return this._showTouch } } }); var K4 = z0e; function J4(e) { let t = vn(e.container), n = new K4, i = y(e.instructionsInitiallyVisible, !1); n.showInstructions = i, n._svgPath = "M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466z M17.328,24.371h-2.707v-2.596h2.707V24.371zM17.328,19.003v0.858h-2.707v-1.057c0-3.19,3.63-3.696,3.63-5.963c0-1.034-0.924-1.826-2.134-1.826c-1.254,0-2.354,0.924-2.354,0.924l-1.541-1.915c0,0,1.519-1.584,4.137-1.584c2.487,0,4.796,1.54,4.796,4.136C21.156,16.208,17.328,16.627,17.328,19.003z"; let o = document.createElement("span"); o.className = "cesium-navigationHelpButton-wrapper", t.appendChild(o); let r = document.createElement("button"); r.type = "button", r.className = "cesium-button cesium-toolbar-button cesium-navigation-help-button", r.setAttribute("data-bind", "attr: { title: tooltip },click: command,cesiumSvgPath: { path: _svgPath, width: 32, height: 32 }"), o.appendChild(r); let s = document.createElement("div"); s.className = "cesium-navigation-help", s.setAttribute("data-bind", 'css: { "cesium-navigation-help-visible" : showInstructions}'), o.appendChild(s); let a = document.createElement("button"); a.type = "button", a.className = "cesium-navigation-button cesium-navigation-button-left", a.setAttribute("data-bind", 'click: showClick, css: {"cesium-navigation-button-selected": !_touch, "cesium-navigation-button-unselected": _touch}'); let c = document.createElement("img"); c.src = Jt("Widgets/Images/NavigationHelp/Mouse.svg"), c.className = "cesium-navigation-button-icon", c.style.width = "25px", c.style.height = "25px", a.appendChild(c), a.appendChild(document.createTextNode("Mouse")); let u = document.createElement("button"); u.type = "button", u.className = "cesium-navigation-button cesium-navigation-button-right", u.setAttribute("data-bind", 'click: showTouch, css: {"cesium-navigation-button-selected": _touch, "cesium-navigation-button-unselected": !_touch}'); let f = document.createElement("img"); f.src = Jt("Widgets/Images/NavigationHelp/Touch.svg"), f.className = "cesium-navigation-button-icon", f.style.width = "25px", f.style.height = "25px", u.appendChild(f), u.appendChild(document.createTextNode("Touch")), s.appendChild(a), s.appendChild(u); let d = document.createElement("div"); d.className = "cesium-click-navigation-help cesium-navigation-help-instructions", d.setAttribute("data-bind", 'css: { "cesium-click-navigation-help-visible" : !_touch}'), d.innerHTML = `            <table>                <tr>                    <td><img src="${Jt("Widgets/Images/NavigationHelp/MouseLeft.svg")}" width="48" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-pan">Pan view</div>                        <div class="cesium-navigation-help-details">Left click + drag</div>                    </td>                </tr>                <tr>                    <td><img src="${Jt("Widgets/Images/NavigationHelp/MouseRight.svg")}" width="48" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-zoom">Zoom view</div>                        <div class="cesium-navigation-help-details">Right click + drag, or</div>                        <div class="cesium-navigation-help-details">Mouse wheel scroll</div>                    </td>                </tr>                <tr>                    <td><img src="${Jt("Widgets/Images/NavigationHelp/MouseMiddle.svg")}" width="48" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-rotate">Rotate view</div>                        <div class="cesium-navigation-help-details">Middle click + drag, or</div>                        <div class="cesium-navigation-help-details">CTRL + Left/Right click + drag</div>                    </td>                </tr>            </table>`, s.appendChild(d); let p = document.createElement("div"); p.className = "cesium-touch-navigation-help cesium-navigation-help-instructions", p.setAttribute("data-bind", 'css: { "cesium-touch-navigation-help-visible" : _touch}'), p.innerHTML = `            <table>                <tr>                    <td><img src="${Jt("Widgets/Images/NavigationHelp/TouchDrag.svg")}" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-pan">Pan view</div>                        <div class="cesium-navigation-help-details">One finger drag</div>                    </td>                </tr>                <tr>                    <td><img src="${Jt("Widgets/Images/NavigationHelp/TouchZoom.svg")}" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-zoom">Zoom view</div>                        <div class="cesium-navigation-help-details">Two finger pinch</div>                    </td>                </tr>                <tr>                    <td><img src="${Jt("Widgets/Images/NavigationHelp/TouchTilt.svg")}" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-rotate">Tilt view</div>                        <div class="cesium-navigation-help-details">Two finger drag, same direction</div>                    </td>                </tr>                <tr>                    <td><img src="${Jt("Widgets/Images/NavigationHelp/TouchRotate.svg")}" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-tilt">Rotate view</div>                        <div class="cesium-navigation-help-details">Two finger drag, opposite direction</div>                    </td>                </tr>            </table>`, s.appendChild(p), Ae.applyBindings(n, o), this._container = t, this._viewModel = n, this._wrapper = o, this._closeInstructions = function (g) { o.contains(g.target) || (n.showInstructions = !1) }, Nt.supportsPointerEvents() ? document.addEventListener("pointerdown", this._closeInstructions, !0) : (document.addEventListener("mousedown", this._closeInstructions, !0), document.addEventListener("touchstart", this._closeInstructions, !0)) } Object.defineProperties(J4.prototype, { container: { get: function () { return this._container } }, viewModel: { get: function () { return this._viewModel } } }); J4.prototype.isDestroyed = function () { return !1 }; J4.prototype.destroy = function () { return Nt.supportsPointerEvents() ? document.removeEventListener("pointerdown", this._closeInstructions, !0) : (document.removeEventListener("mousedown", this._closeInstructions, !0), document.removeEventListener("touchstart", this._closeInstructions, !0)), Ae.cleanNode(this._wrapper), this._container.removeChild(this._wrapper), le(this) }; var Z4 = J4; function Q4(e) { this._scene = e, this._orthographic = e.camera.frustum instanceof Zt, this._flightInProgress = !1, this.dropDownVisible = !1, this.tooltipPerspective = "Perspective Projection", this.tooltipOrthographic = "Orthographic Projection", this.selectedTooltip = void 0, this.sceneMode = e.mode, Ae.track(this, ["_orthographic", "_flightInProgress", "sceneMode", "dropDownVisible", "tooltipPerspective", "tooltipOrthographic"]); let t = this; Ae.defineProperty(this, "selectedTooltip", function () { return t._orthographic ? t.tooltipOrthographic : t.tooltipPerspective }), this._toggleDropDown = An(function () { t.sceneMode === ee.SCENE2D || t._flightInProgress || (t.dropDownVisible = !t.dropDownVisible) }), this._eventHelper = new Pr, this._eventHelper.add(e.morphComplete, function (n, i, o, r) { t.sceneMode = o, t._orthographic = o === ee.SCENE2D || t._scene.camera.frustum instanceof Zt }), this._eventHelper.add(e.preRender, function () { t._flightInProgress = l(e.camera._currentFlight) }), this._switchToPerspective = An(function () { t.sceneMode !== ee.SCENE2D && (t._scene.camera.switchToPerspectiveFrustum(), t._orthographic = !1, t.dropDownVisible = !1) }), this._switchToOrthographic = An(function () { t.sceneMode !== ee.SCENE2D && (t._scene.camera.switchToOrthographicFrustum(), t._orthographic = !0, t.dropDownVisible = !1) }), this._sceneMode = ee } Object.defineProperties(Q4.prototype, { scene: { get: function () { return this._scene } }, toggleDropDown: { get: function () { return this._toggleDropDown } }, switchToPerspective: { get: function () { return this._switchToPerspective } }, switchToOrthographic: { get: function () { return this._switchToOrthographic } }, isOrthographicProjection: { get: function () { return this._orthographic } } }); Q4.prototype.isDestroyed = function () { return !1 }; Q4.prototype.destroy = function () { this._eventHelper.removeAll(), le(this) }; var $4 = Q4; var Fht = "M 28.15625,10.4375 9.125,13.21875 13.75,43.25 41.75,55.09375 50.8125,37 54.5,11.9375 z m 0.125,3 19.976451,0.394265 L 43.03125,16.875 22.6875,14.28125 z M 50.971746,15.705477 47.90625,36.03125 42.53125,46 44.84375,19.3125 z M 12.625,16.03125 l 29.15625,3.6875 -2.65625,31 L 16.4375,41.125 z", Nht = "m 31.560594,6.5254438 -20.75,12.4687502 0.1875,24.5625 22.28125,11.8125 19.5,-12 0.65625,-0.375 0,-0.75 0.0312,-23.21875 z m 0.0625,3.125 16.65625,9.5000002 -16.125,10.28125 -17.34375,-9.71875 z m 18.96875,11.1875002 0.15625,20.65625 -17.46875,10.59375 0.15625,-20.28125 z m -37.0625,1.25 17.21875,9.625 -0.15625,19.21875 -16.9375,-9 z"; function ez(e, t) { e = vn(e); let n = new $4(t); n._perspectivePath = Fht, n._orthographicPath = Nht; let i = document.createElement("span"); i.className = "cesium-projectionPicker-wrapper cesium-toolbar-button", e.appendChild(i); let o = document.createElement("button"); o.type = "button", o.className = "cesium-button cesium-toolbar-button", o.setAttribute("data-bind", 'css: { "cesium-projectionPicker-buttonPerspective": !_orthographic,       "cesium-projectionPicker-buttonOrthographic": _orthographic,       "cesium-button-disabled" : sceneMode === _sceneMode.SCENE2D || _flightInProgress,        "cesium-projectionPicker-selected": dropDownVisible },attr: { title: selectedTooltip },click: toggleDropDown'), o.innerHTML = '<!-- ko cesiumSvgPath: { path: _perspectivePath, width: 64, height: 64, css: "cesium-projectionPicker-iconPerspective" } --><!-- /ko --><!-- ko cesiumSvgPath: { path: _orthographicPath, width: 64, height: 64, css: "cesium-projectionPicker-iconOrthographic" } --><!-- /ko -->', i.appendChild(o); let r = document.createElement("button"); r.type = "button", r.className = "cesium-button cesium-toolbar-button cesium-projectionPicker-dropDown-icon", r.setAttribute("data-bind", 'css: { "cesium-projectionPicker-visible" : (dropDownVisible && _orthographic),       "cesium-projectionPicker-none" : !_orthographic,       "cesium-projectionPicker-hidden" : !dropDownVisible },attr: { title: tooltipPerspective },click: switchToPerspective,cesiumSvgPath: { path: _perspectivePath, width: 64, height: 64 }'), i.appendChild(r); let s = document.createElement("button"); s.type = "button", s.className = "cesium-button cesium-toolbar-button cesium-projectionPicker-dropDown-icon", s.setAttribute("data-bind", 'css: { "cesium-projectionPicker-visible" : (dropDownVisible && !_orthographic),       "cesium-projectionPicker-none" : _orthographic,       "cesium-projectionPicker-hidden" : !dropDownVisible},attr: { title: tooltipOrthographic },click: switchToOrthographic,cesiumSvgPath: { path: _orthographicPath, width: 64, height: 64 }'), i.appendChild(s), Ae.applyBindings(n, i), this._viewModel = n, this._container = e, this._wrapper = i, this._closeDropDown = function (a) { i.contains(a.target) || (n.dropDownVisible = !1) }, Nt.supportsPointerEvents() ? document.addEventListener("pointerdown", this._closeDropDown, !0) : (document.addEventListener("mousedown", this._closeDropDown, !0), document.addEventListener("touchstart", this._closeDropDown, !0)) } Object.defineProperties(ez.prototype, { container: { get: function () { return this._container } }, viewModel: { get: function () { return this._viewModel } } }); ez.prototype.isDestroyed = function () { return !1 }; ez.prototype.destroy = function () { return this._viewModel.destroy(), Nt.supportsPointerEvents() ? document.removeEventListener("pointerdown", this._closeDropDown, !0) : (document.removeEventListener("mousedown", this._closeDropDown, !0), document.removeEventListener("touchstart", this._closeDropDown, !0)), Ae.cleanNode(this._wrapper), this._container.removeChild(this._wrapper), le(this) }; var tz = ez; function nz(e, t) { this._scene = e; let n = this, i = function (o, r, s, a) { n.sceneMode = s, n.dropDownVisible = !1 }; this._eventHelper = new Pr, this._eventHelper.add(e.morphStart, i), this._duration = y(t, 2), this.sceneMode = e.mode, this.dropDownVisible = !1, this.tooltip2D = "2D", this.tooltip3D = "3D", this.tooltipColumbusView = "Columbus View", Ae.track(this, ["sceneMode", "dropDownVisible", "tooltip2D", "tooltip3D", "tooltipColumbusView"]), this.selectedTooltip = void 0, Ae.defineProperty(this, "selectedTooltip", function () { let o = n.sceneMode; return o === ee.SCENE2D ? n.tooltip2D : o === ee.SCENE3D ? n.tooltip3D : n.tooltipColumbusView }), this._toggleDropDown = An(function () { n.dropDownVisible = !n.dropDownVisible }), this._morphTo2D = An(function () { e.morphTo2D(n._duration) }), this._morphTo3D = An(function () { e.morphTo3D(n._duration) }), this._morphToColumbusView = An(function () { e.morphToColumbusView(n._duration) }), this._sceneMode = ee } Object.defineProperties(nz.prototype, { scene: { get: function () { return this._scene } }, duration: { get: function () { return this._duration }, set: function (e) { this._duration = e } }, toggleDropDown: { get: function () { return this._toggleDropDown } }, morphTo2D: { get: function () { return this._morphTo2D } }, morphTo3D: { get: function () { return this._morphTo3D } }, morphToColumbusView: { get: function () { return this._morphToColumbusView } } }); nz.prototype.isDestroyed = function () { return !1 }; nz.prototype.destroy = function () { this._eventHelper.removeAll(), le(this) }; var iz = nz; var Vht = "m 32.401392,4.9330437 c -7.087603,0 -14.096095,2.884602 -19.10793,7.8946843 -5.0118352,5.010083 -7.9296167,11.987468 -7.9296167,19.072999 0,7.085531 2.9177815,14.097848 7.9296167,19.107931 4.837653,4.835961 11.541408,7.631372 18.374354,7.82482 0.05712,0.01231 0.454119,0.139729 0.454119,0.139729 l 0.03493,-0.104797 c 0.08246,7.84e-4 0.162033,0.03493 0.244525,0.03493 0.08304,0 0.161515,-0.03414 0.244526,-0.03493 l 0.03493,0.104797 c 0,0 0.309474,-0.129487 0.349323,-0.139729 6.867765,-0.168094 13.582903,-2.965206 18.444218,-7.82482 2.558195,-2.5573 4.551081,-5.638134 5.903547,-8.977584 1.297191,-3.202966 2.02607,-6.661489 2.02607,-10.130347 0,-6.237309 -2.366261,-12.31219 -6.322734,-17.116794 -0.0034,-0.02316 0.0049,-0.04488 0,-0.06986 -0.01733,-0.08745 -0.104529,-0.278855 -0.104797,-0.279458 -5.31e-4,-0.0012 -0.522988,-0.628147 -0.523984,-0.62878         -3.47e-4,-2.2e-4 -0.133444,-0.03532 -0.244525,-0.06987 C 51.944299,13.447603 51.751076,13.104317 51.474391,12.827728 46.462556,7.8176457 39.488996,4.9330437 32.401392,4.9330437 z m -2.130866,3.5281554 0.104797,9.6762289 c -4.111695,-0.08361 -7.109829,-0.423664 -9.257041,-0.943171 1.198093,-2.269271 2.524531,-4.124404 3.91241,-5.414496 2.167498,-2.0147811 3.950145,-2.8540169 5.239834,-3.3185619 z m 2.794579,0 c 1.280302,0.4754953 3.022186,1.3285948 5.065173,3.2486979 1.424667,1.338973 2.788862,3.303645 3.982275,5.728886 -2.29082,0.403367 -5.381258,0.621049 -8.942651,0.698645 L 33.065105,8.4611991 z m 5.728886,0.2445256 c 4.004072,1.1230822 7.793098,3.1481363 10.724195,6.0782083 0.03468,0.03466 0.07033,0.06991 0.104797,0.104797 -0.45375,0.313891 -0.923054,0.663002 -1.956205,1.082899 -0.647388,0.263114 -1.906242,0.477396 -2.829511,0.733577 -1.382296,-2.988132         -3.027146,-5.368585 -4.785716,-7.0213781 -0.422866,-0.397432 -0.835818,-0.6453247 -1.25756,-0.9781032 z m -15.33525,0.7685092 c -0.106753,0.09503 -0.207753,0.145402 -0.31439,0.244526 -1.684973,1.5662541 -3.298068,3.8232211 -4.680919,6.5672591 -0.343797,-0.14942 -1.035052,-0.273198 -1.292493,-0.419186 -0.956528,-0.542427 -1.362964,-1.022024 -1.537018,-1.292493 -0.0241,-0.03745 -0.01868,-0.0401 -0.03493,-0.06986 2.250095,-2.163342 4.948824,-3.869984 7.859752,-5.0302421 z m -9.641296,7.0912431 c 0.464973,0.571618 0.937729,1.169056 1.956205,1.746612 0.349907,0.198425 1.107143,0.335404 1.537018,0.523983 -1.20166,3.172984 -1.998037,7.051901 -2.165798,11.772162 C 14.256557,30.361384 12.934823,30.161483 12.280427,29.90959 10.644437,29.279855 9.6888882,28.674891 9.1714586,28.267775 8.6540289,27.860658 8.6474751,27.778724 8.6474751,27.778724 l -0.069864,0.03493 C 9.3100294,23.691285         11.163248,19.798527 13.817445,16.565477 z m 37.552149,0.523984 c 2.548924,3.289983 4.265057,7.202594 4.890513,11.318043 -0.650428,0.410896 -1.756876,1.001936 -3.563088,1.606882 -1.171552,0.392383 -3.163859,0.759153 -4.960377,1.117832 -0.04367,-4.752703 -0.784809,-8.591423 -1.88634,-11.807094 0.917574,-0.263678 2.170552,-0.486495 2.864443,-0.76851 1.274693,-0.518066 2.003942,-1.001558 2.654849,-1.467153 z m -31.439008,2.619917 c 2.487341,0.672766 5.775813,1.137775 10.479669,1.222628 l 0.104797,10.689263 0,0.03493 0,0.733577 c -5.435005,-0.09059 -9.512219,-0.519044 -12.610536,-1.117831 0.106127,-4.776683 0.879334,-8.55791 2.02607,-11.562569 z m 23.264866,0.31439 c 1.073459,3.067541 1.833795,6.821314 1.816476,11.702298 -3.054474,0.423245 -7.062018,0.648559 -11.702298,0.698644 l 0,-0.838373 -0.104796,-10.654331 c 4.082416,-0.0864 7.404468,-0.403886 9.990618,-0.908238 z         M 8.2632205,30.922625 c 0.7558676,0.510548 1.5529563,1.013339 3.0041715,1.57195 0.937518,0.360875 2.612202,0.647642 3.91241,0.978102 0.112814,3.85566 0.703989,7.107756 1.606883,9.920754 -1.147172,-0.324262 -2.644553,-0.640648 -3.423359,-0.978102 -1.516688,-0.657177 -2.386627,-1.287332 -2.864443,-1.71168 -0.477816,-0.424347 -0.489051,-0.489051 -0.489051,-0.489051 L 9.8002387,40.319395 C 8.791691,37.621767 8.1584238,34.769583 8.1584238,31.900727 c 0,-0.330153 0.090589,-0.648169 0.1047967,-0.978102 z m 48.2763445,0.419186 c 0.0047,0.188973 0.06986,0.36991 0.06986,0.558916 0,2.938869 -0.620228,5.873558 -1.676747,8.628261 -0.07435,0.07583 -0.06552,0.07411 -0.454119,0.349323 -0.606965,0.429857 -1.631665,1.042044 -3.318562,1.676747 -1.208528,0.454713 -3.204964,0.850894 -5.135038,1.25756 0.84593,-2.765726 1.41808,-6.005357 1.606883,-9.815957 2.232369,-0.413371 4.483758,-0.840201         5.938479,-1.327425 1.410632,-0.472457 2.153108,-0.89469 2.96924,-1.327425 z m -38.530252,2.864443 c 3.208141,0.56697 7.372279,0.898588 12.575603,0.978103 l 0.174662,9.885821 c -4.392517,-0.06139 -8.106722,-0.320566 -10.863925,-0.803441 -1.051954,-2.664695 -1.692909,-6.043794 -1.88634,-10.060483 z m 26.793022,0.31439 c -0.246298,3.923551 -0.877762,7.263679 -1.816476,9.885822 -2.561957,0.361954 -5.766249,0.560708 -9.431703,0.62878 l -0.174661,-9.815957 c 4.491734,-0.04969 8.334769,-0.293032 11.42284,-0.698645 z M 12.035901,44.860585 c 0.09977,0.04523 0.105535,0.09465 0.209594,0.139729 1.337656,0.579602 3.441099,1.058072 5.589157,1.537018 1.545042,3.399208 3.548524,5.969402 5.589157,7.789888 -3.034411,-1.215537 -5.871615,-3.007978 -8.174142,-5.309699 -1.245911,-1.245475 -2.271794,-2.662961 -3.213766,-4.156936 z m 40.69605,0 c -0.941972,1.493975 -1.967855,2.911461         -3.213765,4.156936 -2.74253,2.741571 -6.244106,4.696717 -9.955686,5.868615 0.261347,-0.241079 0.507495,-0.394491 0.768509,-0.663713 1.674841,-1.727516 3.320792,-4.181056 4.645987,-7.265904 2.962447,-0.503021 5.408965,-1.122293 7.161107,-1.781544 0.284034,-0.106865 0.337297,-0.207323 0.593848,-0.31439 z m -31.404076,2.305527 c 2.645807,0.376448 5.701178,0.649995 9.466635,0.698645 l 0.139729,7.789888 c -1.38739,-0.480844 -3.316218,-1.29837 -5.659022,-3.388427 -1.388822,-1.238993 -2.743668,-3.0113 -3.947342,-5.100106 z m 20.365491,0.104797 c -1.04872,2.041937 -2.174337,3.779068 -3.353494,4.995309 -1.853177,1.911459 -3.425515,2.82679 -4.611055,3.353494 l -0.139729,-7.789887 c 3.13091,-0.05714 5.728238,-0.278725 8.104278,-0.558916 z", kht = "m 2.9825053,17.550598 0,1.368113 0,26.267766 0,1.368113 1.36811,0 54.9981397,0 1.36811,0 0,-1.368113 0,-26.267766 0,-1.368113 -1.36811,0 -54.9981397,0 -1.36811,0 z m 2.73623,2.736226 10.3292497,0 0,10.466063 -10.3292497,0 0,-10.466063 z m 13.0654697,0 11.69737,0 0,10.466063 -11.69737,0 0,-10.466063 z m 14.43359,0 11.69737,0 0,10.466063 -11.69737,0 0,-10.466063 z m 14.43359,0 10.32926,0 0,10.466063 -10.32926,0 0,-10.466063 z m -41.9326497,13.202288 10.3292497,0 0,10.329252 -10.3292497,0 0,-10.329252 z m 13.0654697,0 11.69737,0 0,10.329252 -11.69737,0 0,-10.329252 z m 14.43359,0 11.69737,0 0,10.329252 -11.69737,0 0,-10.329252 z m 14.43359,0 10.32926,0 0,10.329252 -10.32926,0 0,-10.329252 z", Uht = "m 14.723969,17.675598 -0.340489,0.817175 -11.1680536,26.183638 -0.817175,1.872692 2.076986,0 54.7506996,0 2.07698,0 -0.81717,-1.872692 -11.16805,-26.183638 -0.34049,-0.817175 -0.91933,0 -32.414586,0 -0.919322,0 z m 1.838643,2.723916 6.196908,0 -2.928209,10.418977 -7.729111,0 4.460412,-10.418977 z m 9.02297,0 4.903049,0 0,10.418977 -7.831258,0 2.928209,-10.418977 z m 7.626964,0 5.584031,0 2.62176,10.418977 -8.205791,0 0,-10.418977 z m 8.410081,0 5.51593,0 4.46042,10.418977 -7.38863,0 -2.58772,-10.418977 z m -30.678091,13.142892 8.103649,0 -2.89416,10.282782 -9.6018026,0 4.3923136,-10.282782 z m 10.929711,0 8.614384,0 0,10.282782 -11.508544,0 2.89416,-10.282782 z m 11.338299,0 8.852721,0 2.58772,10.282782 -11.440441,0 0,-10.282782 z m 11.678781,0 7.86531,0 4.39231,10.282782 -9.6699,0 -2.58772,-10.282782 z"; function oz(e, t, n) { e = vn(e); let i = new iz(t, n); i._globePath = Vht, i._flatMapPath = kht, i._columbusViewPath = Uht; let o = document.createElement("span"); o.className = "cesium-sceneModePicker-wrapper cesium-toolbar-button", e.appendChild(o); let r = document.createElement("button"); r.type = "button", r.className = "cesium-button cesium-toolbar-button", r.setAttribute("data-bind", 'css: { "cesium-sceneModePicker-button2D": sceneMode === _sceneMode.SCENE2D,       "cesium-sceneModePicker-button3D": sceneMode === _sceneMode.SCENE3D,       "cesium-sceneModePicker-buttonColumbusView": sceneMode === _sceneMode.COLUMBUS_VIEW,       "cesium-sceneModePicker-selected": dropDownVisible },attr: { title: selectedTooltip },click: toggleDropDown'), r.innerHTML = '<!-- ko cesiumSvgPath: { path: _globePath, width: 64, height: 64, css: "cesium-sceneModePicker-slide-svg cesium-sceneModePicker-icon3D" } --><!-- /ko --><!-- ko cesiumSvgPath: { path: _flatMapPath, width: 64, height: 64, css: "cesium-sceneModePicker-slide-svg cesium-sceneModePicker-icon2D" } --><!-- /ko --><!-- ko cesiumSvgPath: { path: _columbusViewPath, width: 64, height: 64, css: "cesium-sceneModePicker-slide-svg cesium-sceneModePicker-iconColumbusView" } --><!-- /ko -->', o.appendChild(r); let s = document.createElement("button"); s.type = "button", s.className = "cesium-button cesium-toolbar-button cesium-sceneModePicker-dropDown-icon", s.setAttribute("data-bind", 'css: { "cesium-sceneModePicker-visible" : (dropDownVisible && (sceneMode !== _sceneMode.SCENE3D)) || (!dropDownVisible && (sceneMode === _sceneMode.SCENE3D)),       "cesium-sceneModePicker-none" : sceneMode === _sceneMode.SCENE3D,       "cesium-sceneModePicker-hidden" : !dropDownVisible },attr: { title: tooltip3D },click: morphTo3D,cesiumSvgPath: { path: _globePath, width: 64, height: 64 }'), o.appendChild(s); let a = document.createElement("button"); a.type = "button", a.className = "cesium-button cesium-toolbar-button cesium-sceneModePicker-dropDown-icon", a.setAttribute("data-bind", 'css: { "cesium-sceneModePicker-visible" : (dropDownVisible && (sceneMode !== _sceneMode.SCENE2D)),       "cesium-sceneModePicker-none" : sceneMode === _sceneMode.SCENE2D,       "cesium-sceneModePicker-hidden" : !dropDownVisible },attr: { title: tooltip2D },click: morphTo2D,cesiumSvgPath: { path: _flatMapPath, width: 64, height: 64 }'), o.appendChild(a); let c = document.createElement("button"); c.type = "button", c.className = "cesium-button cesium-toolbar-button cesium-sceneModePicker-dropDown-icon", c.setAttribute("data-bind", 'css: { "cesium-sceneModePicker-visible" : (dropDownVisible && (sceneMode !== _sceneMode.COLUMBUS_VIEW)) || (!dropDownVisible && (sceneMode === _sceneMode.COLUMBUS_VIEW)),       "cesium-sceneModePicker-none" : sceneMode === _sceneMode.COLUMBUS_VIEW,       "cesium-sceneModePicker-hidden" : !dropDownVisible},attr: { title: tooltipColumbusView },click: morphToColumbusView,cesiumSvgPath: { path: _columbusViewPath, width: 64, height: 64 }'), o.appendChild(c), Ae.applyBindings(i, o), this._viewModel = i, this._container = e, this._wrapper = o, this._closeDropDown = function (u) { o.contains(u.target) || (i.dropDownVisible = !1) }, Nt.supportsPointerEvents() ? document.addEventListener("pointerdown", this._closeDropDown, !0) : (document.addEventListener("mousedown", this._closeDropDown, !0), document.addEventListener("touchstart", this._closeDropDown, !0)) } Object.defineProperties(oz.prototype, { container: { get: function () { return this._container } }, viewModel: { get: function () { return this._viewModel } } }); oz.prototype.isDestroyed = function () { return !1 }; oz.prototype.destroy = function () { return this._viewModel.destroy(), Nt.supportsPointerEvents() ? document.removeEventListener("pointerdown", this._closeDropDown, !0) : (document.removeEventListener("mousedown", this._closeDropDown, !0), document.removeEventListener("touchstart", this._closeDropDown, !0)), Ae.cleanNode(this._wrapper), this._container.removeChild(this._wrapper), le(this) }; var rz = oz; var zht = new H, sz = "-1000px"; function Yv(e, t, n) { this._scene = e, this._screenPositionX = sz, this._screenPositionY = sz, this._tweens = e.tweens, this._container = y(n, document.body), this._selectionIndicatorElement = t, this._scale = 1, this.position = void 0, this.showSelection = !1, Ae.track(this, ["position", "_screenPositionX", "_screenPositionY", "_scale", "showSelection"]), this.isVisible = void 0, Ae.defineProperty(this, "isVisible", { get: function () { return this.showSelection && l(this.position) } }), Ae.defineProperty(this, "_transform", { get: function () { return `scale(${this._scale})` } }), this.computeScreenSpacePosition = function (i, o) { return ji.wgs84ToWindowCoordinates(e, i, o) } } Yv.prototype.update = function () { if (this.showSelection && l(this.position)) { let e = this.computeScreenSpacePosition(this.position, zht); if (!l(e)) this._screenPositionX = sz, this._screenPositionY = sz; else { let t = this._container, n = t.parentNode.clientWidth, i = t.parentNode.clientHeight, o = this._selectionIndicatorElement.clientWidth, r = o * .5; e.x = Math.min(Math.max(e.x, -o), n + o) - r, e.y = Math.min(Math.max(e.y, -o), i + o) - r, this._screenPositionX = `${Math.floor(e.x + .25)}px`, this._screenPositionY = `${Math.floor(e.y + .25)}px` } } }; Yv.prototype.animateAppear = function () { this._tweens.addProperty({ object: this, property: "_scale", startValue: 2, stopValue: 1, duration: .8, easingFunction: Mr.EXPONENTIAL_OUT }) }; Yv.prototype.animateDepart = function () { this._tweens.addProperty({ object: this, property: "_scale", startValue: this._scale, stopValue: 1.5, duration: .8, easingFunction: Mr.EXPONENTIAL_OUT }) }; Object.defineProperties(Yv.prototype, { container: { get: function () { return this._container } }, selectionIndicatorElement: { get: function () { return this._selectionIndicatorElement } }, scene: { get: function () { return this._scene } } }); var az = Yv; function cz(e, t) { e = vn(e), this._container = e; let n = document.createElement("div"); n.className = "cesium-selection-wrapper", n.setAttribute("data-bind", 'style: { "top" : _screenPositionY, "left" : _screenPositionX },css: { "cesium-selection-wrapper-visible" : isVisible }'), e.appendChild(n), this._element = n; let i = "http://www.w3.org/2000/svg", o = "M -34 -34 L -34 -11.25 L -30 -15.25 L -30 -30 L -15.25 -30 L -11.25 -34 L -34 -34 z M 11.25 -34 L 15.25 -30 L 30 -30 L 30 -15.25 L 34 -11.25 L 34 -34 L 11.25 -34 z M -34 11.25 L -34 34 L -11.25 34 L -15.25 30 L -30 30 L -30 15.25 L -34 11.25 z M 34 11.25 L 30 15.25 L 30 30 L 15.25 30 L 11.25 34 L 34 34 L 34 11.25 z", r = document.createElementNS(i, "svg:svg"); r.setAttribute("width", 160), r.setAttribute("height", 160), r.setAttribute("viewBox", "0 0 160 160"); let s = document.createElementNS(i, "g"); s.setAttribute("transform", "translate(80,80)"), r.appendChild(s); let a = document.createElementNS(i, "path"); a.setAttribute("data-bind", "attr: { transform: _transform }"), a.setAttribute("d", o), s.appendChild(a), n.appendChild(r); let c = new az(t, this._element, this._container); this._viewModel = c, Ae.applyBindings(this._viewModel, this._element) } Object.defineProperties(cz.prototype, { container: { get: function () { return this._container } }, viewModel: { get: function () { return this._viewModel } } }); cz.prototype.isDestroyed = function () { return !1 }; cz.prototype.destroy = function () { let e = this._container; return Ae.cleanNode(this._element), e.removeChild(this._element), le(this) }; var lz = cz; function wA(e, t, n) { this._color = e, this._height = t, this._base = y(n, 0) } wA.prototype.getHeight = function () { return this._height }; wA.prototype.getBase = function () { return this._base }; wA.prototype.getStartTime = function () { return this._start }; wA.prototype.getStopTime = function () { return this._stop }; wA.prototype.setRange = function (e, t) { this._start = e, this._stop = t }; wA.prototype.render = function (e) { let t = ""; if (this._start && this._stop && this._color) { let n = $.secondsDifference(this._start, e.epochJulian), i = Math.round(e.timeBarWidth * e.getAlpha(n)), o = $.secondsDifference(this._stop, e.epochJulian), r = Math.round(e.timeBarWidth * e.getAlpha(o)) - i; i < 0 && (r += i, i = 0), i + r > e.timeBarWidth && (r = e.timeBarWidth - i), r > 0 && (t = `<span class="cesium-timeline-highlight" style="left: ${i.toString()}px; width: ${r.toString()}px; bottom: ${this._base.toString()}px; height: ${this._height}px; background-color: ${this._color};"></span>`) } return t }; var uz = wA; function H0e(e, t, n, i) { this.interval = e, this.height = t, this.color = n || new U(.5, .5, .5, 1), this.backgroundColor = i || new U(0, 0, 0, 0) } H0e.prototype.render = function (e, t) { let n = this.interval.start, i = this.interval.stop, o = t.startJulian, r = $.addSeconds(t.startJulian, t.duration, new $); if ($.lessThan(n, o) && $.greaterThan(i, r)) e.fillStyle = this.color.toCssColorString(), e.fillRect(0, t.y, t.timeBarWidth, this.height); else if ($.lessThanOrEquals(n, r) && $.greaterThanOrEquals(i, o)) { let s, a, c; for (s = 0; s < t.timeBarWidth; ++s) { let u = $.addSeconds(t.startJulian, s / t.timeBarWidth * t.duration, new $); !l(a) && $.greaterThanOrEquals(u, n) ? a = s : !l(c) && $.greaterThanOrEquals(u, i) && (c = s) } e.fillStyle = this.backgroundColor.toCssColorString(), e.fillRect(0, t.y, t.timeBarWidth, this.height), l(a) && (l(c) || (c = t.timeBarWidth), e.fillStyle = this.color.toCssColorString(), e.fillRect(a, t.y, Math.max(c - a, 1), this.height)) } }; var fz = H0e; var bq = 1e12, rf = { none: 0, scrub: 1, slide: 2, zoom: 3, touchOnly: 4 }, Ec = { none: 0, scrub: 1, slideZoom: 2, singleTap: 3, ignore: 4 }, e0 = [.001, .002, .005, .01, .02, .05, .1, .25, .5, 1, 2, 5, 10, 15, 30, 60, 120, 300, 600, 900, 1800, 3600, 7200, 14400, 21600, 43200, 86400, 172800, 345600, 604800, 1296e3, 2592e3, 5184e3, 7776e3, 15552e3, 31536e3, 63072e3, 126144e3, 15768e4, 31536e4, 63072e4, 126144e4, 15768e5, 31536e5, 63072e5, 126144e5, 15768e6, 31536e6], Hht = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; function bc(e, t) { e = vn(e); let n = e.ownerDocument; this.container = e; let i = n.createElement("div"); i.className = "cesium-timeline-main", e.appendChild(i), this._topDiv = i, this._endJulian = void 0, this._epochJulian = void 0, this._lastXPos = void 0, this._scrubElement = void 0, this._startJulian = void 0, this._timeBarSecondsSpan = void 0, this._clock = t, this._scrubJulian = t.currentTime, this._mainTicSpan = -1, this._mouseMode = rf.none, this._touchMode = Ec.none, this._touchState = { centerX: 0, spanX: 0 }, this._mouseX = 0, this._timelineDrag = 0, this._timelineDragLocation = void 0, this._lastHeight = void 0, this._lastWidth = void 0, this._topDiv.innerHTML = '<div class="cesium-timeline-bar"></div><div class="cesium-timeline-trackContainer"><canvas class="cesium-timeline-tracks" width="10" height="1"></canvas></div><div class="cesium-timeline-needle"></div><span class="cesium-timeline-ruler"></span>', this._timeBarEle = this._topDiv.childNodes[0], this._trackContainer = this._topDiv.childNodes[1], this._trackListEle = this._topDiv.childNodes[1].childNodes[0], this._needleEle = this._topDiv.childNodes[2], this._rulerEle = this._topDiv.childNodes[3], this._context = this._trackListEle.getContext("2d"), this._trackList = [], this._highlightRanges = [], this.zoomTo(t.startTime, t.stopTime), this._onMouseDown = Ght(this), this._onMouseUp = Wht(this), this._onMouseMove = jht(this), this._onMouseWheel = qht(this), this._onTouchStart = Yht(this), this._onTouchMove = Kht(this), this._onTouchEnd = Xht(this); let o = this._timeBarEle; n.addEventListener("mouseup", this._onMouseUp, !1), n.addEventListener("mousemove", this._onMouseMove, !1), o.addEventListener("mousedown", this._onMouseDown, !1), o.addEventListener("DOMMouseScroll", this._onMouseWheel, !1), o.addEventListener("mousewheel", this._onMouseWheel, !1), o.addEventListener("touchstart", this._onTouchStart, !1), o.addEventListener("touchmove", this._onTouchMove, !1), o.addEventListener("touchend", this._onTouchEnd, !1), o.addEventListener("touchcancel", this._onTouchEnd, !1), this._topDiv.oncontextmenu = function () { return !1 }, t.onTick.addEventListener(this.updateFromClock, this), this.updateFromClock() } bc.prototype.addEventListener = function (e, t, n) { this._topDiv.addEventListener(e, t, n) }; bc.prototype.removeEventListener = function (e, t, n) { this._topDiv.removeEventListener(e, t, n) }; bc.prototype.isDestroyed = function () { return !1 }; bc.prototype.destroy = function () { this._clock.onTick.removeEventListener(this.updateFromClock, this); let e = this.container.ownerDocument; e.removeEventListener("mouseup", this._onMouseUp, !1), e.removeEventListener("mousemove", this._onMouseMove, !1); let t = this._timeBarEle; t.removeEventListener("mousedown", this._onMouseDown, !1), t.removeEventListener("DOMMouseScroll", this._onMouseWheel, !1), t.removeEventListener("mousewheel", this._onMouseWheel, !1), t.removeEventListener("touchstart", this._onTouchStart, !1), t.removeEventListener("touchmove", this._onTouchMove, !1), t.removeEventListener("touchend", this._onTouchEnd, !1), t.removeEventListener("touchcancel", this._onTouchEnd, !1), this.container.removeChild(this._topDiv), le(this) }; bc.prototype.addHighlightRange = function (e, t, n) { let i = new uz(e, t, n); return this._highlightRanges.push(i), this.resize(), i }; bc.prototype.addTrack = function (e, t, n, i) { let o = new fz(e, t, n, i); return this._trackList.push(o), this._lastHeight = void 0, this.resize(), o }; bc.prototype.zoomTo = function (e, t) { if (this._startJulian = e, this._endJulian = t, this._timeBarSecondsSpan = $.secondsDifference(t, e), this._clock && this._clock.clockRange !== Br.UNBOUNDED) { let i = this._clock.startTime, o = this._clock.stopTime, r = $.secondsDifference(o, i), s = $.secondsDifference(i, this._startJulian), a = $.secondsDifference(o, this._endJulian); this._timeBarSecondsSpan >= r ? (this._timeBarSecondsSpan = r, this._startJulian = this._clock.startTime, this._endJulian = this._clock.stopTime) : s > 0 ? (this._endJulian = $.addSeconds(this._endJulian, s, new $), this._startJulian = i, this._timeBarSecondsSpan = $.secondsDifference(this._endJulian, this._startJulian)) : a < 0 && (this._startJulian = $.addSeconds(this._startJulian, a, new $), this._endJulian = o, this._timeBarSecondsSpan = $.secondsDifference(this._endJulian, this._startJulian)) } this._makeTics(); let n = document.createEvent("Event"); n.initEvent("setzoom", !0, !0), n.startJulian = this._startJulian, n.endJulian = this._endJulian, n.epochJulian = this._epochJulian, n.totalSpan = this._timeBarSecondsSpan, n.mainTicSpan = this._mainTicSpan, this._topDiv.dispatchEvent(n) }; bc.prototype.zoomFrom = function (e) { let t = $.secondsDifference(this._scrubJulian, this._startJulian); e > 1 || t < 0 || t > this._timeBarSecondsSpan ? t = this._timeBarSecondsSpan * .5 : t += t - this._timeBarSecondsSpan * .5; let n = this._timeBarSecondsSpan - t; this.zoomTo($.addSeconds(this._startJulian, t - t * e, new $), $.addSeconds(this._endJulian, n * e - n, new $)) }; function Sq(e) { return e < 10 ? `0${e.toString()}` : e.toString() } bc.prototype.makeLabel = function (e) { let t = $.toGregorianDate(e), n = t.millisecond, i = " UTC"; if (n > 0 && this._timeBarSecondsSpan < 3600) { for (i = Math.floor(n).toString(); i.length < 3;)i = `0${i}`; i = `.${i}` } return `${Hht[t.month - 1]} ${t.day} ${t.year} ${Sq(t.hour)}:${Sq(t.minute)}:${Sq(t.second)}${i}` }; bc.prototype.smallestTicInPixels = 7; bc.prototype._makeTics = function () { let e = this._timeBarEle, t = $.secondsDifference(this._scrubJulian, this._startJulian), n = Math.round(t * this._topDiv.clientWidth / this._timeBarSecondsSpan), i = n - 8, o, r = this; this._needleEle.style.left = `${n.toString()}px`; let s = "", a = .01, c = 31536e6, u = 1e-10, f = 0, d = this._timeBarSecondsSpan; d < a ? (d = a, this._timeBarSecondsSpan = a, this._endJulian = $.addSeconds(this._startJulian, a, new $)) : d > c && (d = c, this._timeBarSecondsSpan = c, this._endJulian = $.addSeconds(this._startJulian, c, new $)); let p = this._timeBarEle.clientWidth; p < 10 && (p = 10); let g = this._startJulian, m = Math.min(d / p * 1e-5, .4), A, C = $.toGregorianDate(g); d > 31536e4 ? A = $.fromDate(new Date(Date.UTC(Math.floor(C.year / 100) * 100, 0))) : d > 31536e3 ? A = $.fromDate(new Date(Date.UTC(Math.floor(C.year / 10) * 10, 0))) : d > 86400 ? A = $.fromDate(new Date(Date.UTC(C.year, 0))) : A = $.fromDate(new Date(Date.UTC(C.year, C.month, C.day))); let x = $.secondsDifference(this._startJulian, $.addSeconds(A, m, new $)), T = x + d; this._epochJulian = A; function b(N) { return Math.floor(x / N) * N } function S(N, X) { return Math.ceil(N / X + .5) * X } function D(N) { return (N - x) / d } function P(N, X) { return N - X * Math.round(N / X) } this._rulerEle.innerHTML = this.makeLabel($.addSeconds(this._endJulian, -a, new $)); let B = this._rulerEle.offsetWidth + 20; B < 30 && (B = 180); let R = f; f -= u; let M = { startTime: x, startJulian: g, epochJulian: A, duration: d, timeBarWidth: p, getAlpha: D }; this._highlightRanges.forEach(function (N) { s += N.render(M) }); let L = 0, _ = 0, E = 0, w = B / p; w > 1 && (w = 1), w *= this._timeBarSecondsSpan; let v = -1, O = -1, V = e0.length, z; for (z = 0; z < V; ++z) { let N = e0[z]; if (++v, L = N, N > w && N > f) break; O < 0 && p * (N / this._timeBarSecondsSpan) >= this.smallestTicInPixels && (O = v) } if (v > 0) { for (; v > 0;)if (--v, Math.abs(P(L, e0[v])) < 1e-5) { e0[v] >= f && (_ = e0[v]); break } if (O >= 0) for (; O < v;) { if (Math.abs(P(_, e0[O])) < 1e-5 && e0[O] >= f) { E = e0[O]; break } ++O } } f = R, f > u && E < 1e-5 && Math.abs(f - L) > u && (E = f, f <= L + u && (_ = 0)); let k = -999999, G; if (p * (E / this._timeBarSecondsSpan) >= 3) for (o = b(E); o <= T; o = S(o, E))s += `<span class="cesium-timeline-ticTiny" style="left: ${Math.round(p * D(o)).toString()}px;"></span>`; if (p * (_ / this._timeBarSecondsSpan) >= 3) for (o = b(_); o <= T; o = S(o, _))s += `<span class="cesium-timeline-ticSub" style="left: ${Math.round(p * D(o)).toString()}px;"></span>`; if (p * (L / this._timeBarSecondsSpan) >= 2) { this._mainTicSpan = L, T += L, o = b(L); let N = $.computeTaiMinusUtc(A); for (; o <= T;) { let X = $.addSeconds(g, o - x, new $); if (L > 2.1) { let K = $.computeTaiMinusUtc(X); Math.abs(K - N) > .1 && (o += K - N, X = $.addSeconds(g, o - x, new $)) } let q = Math.round(p * D(o)), J = this.makeLabel(X); this._rulerEle.innerHTML = J, G = this._rulerEle.offsetWidth, G < 10 && (G = B); let W = q - (G / 2 - 1); W > k ? (k = W + G + 5, s += `<span class="cesium-timeline-ticMain" style="left: ${q.toString()}px;"></span><span class="cesium-timeline-ticLabel" style="left: ${W.toString()}px;">${J}</span>`) : s += `<span class="cesium-timeline-ticSub" style="left: ${q.toString()}px;"></span>`, o = S(o, L) } } else this._mainTicSpan = -1; s += `<span class="cesium-timeline-icon16" style="left:${i}px;bottom:0;background-position: 0 0;"></span>`, e.innerHTML = s, this._scrubElement = e.lastChild, this._context.clearRect(0, 0, this._trackListEle.width, this._trackListEle.height), M.y = 0, this._trackList.forEach(function (N) { N.render(r._context, M), M.y += N.height }) }; bc.prototype.updateFromClock = function () { this._scrubJulian = this._clock.currentTime; let e = this._scrubElement; if (l(this._scrubElement)) { let t = $.secondsDifference(this._scrubJulian, this._startJulian), n = Math.round(t * this._topDiv.clientWidth / this._timeBarSecondsSpan); this._lastXPos !== n && (this._lastXPos = n, e.style.left = `${n - 8}px`, this._needleEle.style.left = `${n}px`) } l(this._timelineDragLocation) && (this._setTimeBarTime(this._timelineDragLocation, this._timelineDragLocation * this._timeBarSecondsSpan / this._topDiv.clientWidth), this.zoomTo($.addSeconds(this._startJulian, this._timelineDrag, new $), $.addSeconds(this._endJulian, this._timelineDrag, new $))) }; bc.prototype._setTimeBarTime = function (e, t) { if (e = Math.round(e), this._scrubJulian = $.addSeconds(this._startJulian, t, new $), this._scrubElement) { let i = e - 8; this._scrubElement.style.left = `${i.toString()}px`, this._needleEle.style.left = `${e.toString()}px` } let n = document.createEvent("Event"); n.initEvent("settime", !0, !0), n.clientX = e, n.timeSeconds = t, n.timeJulian = this._scrubJulian, n.clock = this._clock, this._topDiv.dispatchEvent(n) }; function Ght(e) { return function (t) { e._mouseMode !== rf.touchOnly && (t.button === 0 ? (e._mouseMode = rf.scrub, e._scrubElement && (e._scrubElement.style.backgroundPosition = "-16px 0"), e._onMouseMove(t)) : (e._mouseX = t.clientX, t.button === 2 ? e._mouseMode = rf.zoom : e._mouseMode = rf.slide)), t.preventDefault() } } function Wht(e) { return function (t) { e._mouseMode = rf.none, e._scrubElement && (e._scrubElement.style.backgroundPosition = "0 0"), e._timelineDrag = 0, e._timelineDragLocation = void 0 } } function jht(e) { return function (t) { let n; if (e._mouseMode === rf.scrub) { t.preventDefault(); let i = t.clientX - e._topDiv.getBoundingClientRect().left; i < 0 ? (e._timelineDragLocation = 0, e._timelineDrag = -.01 * e._timeBarSecondsSpan) : i > e._topDiv.clientWidth ? (e._timelineDragLocation = e._topDiv.clientWidth, e._timelineDrag = .01 * e._timeBarSecondsSpan) : (e._timelineDragLocation = void 0, e._setTimeBarTime(i, i * e._timeBarSecondsSpan / e._topDiv.clientWidth)) } else if (e._mouseMode === rf.slide) { if (n = e._mouseX - t.clientX, e._mouseX = t.clientX, n !== 0) { let i = n * e._timeBarSecondsSpan / e._topDiv.clientWidth; e.zoomTo($.addSeconds(e._startJulian, i, new $), $.addSeconds(e._endJulian, i, new $)) } } else e._mouseMode === rf.zoom && (n = e._mouseX - t.clientX, e._mouseX = t.clientX, n !== 0 && e.zoomFrom(Math.pow(1.01, n))) } } function qht(e) { return function (t) { let n = t.wheelDeltaY || t.wheelDelta || -t.detail; bq = Math.max(Math.min(Math.abs(n), bq), 1), n /= bq, e.zoomFrom(Math.pow(1.05, -n)) } } function Yht(e) { return function (t) { let n = t.touches.length, i, o, r = e._topDiv.getBoundingClientRect().left; t.preventDefault(), e._mouseMode = rf.touchOnly, n === 1 ? (i = $.secondsDifference(e._scrubJulian, e._startJulian), o = Math.round(i * e._topDiv.clientWidth / e._timeBarSecondsSpan + r), Math.abs(t.touches[0].clientX - o) < 50 ? (e._touchMode = Ec.scrub, e._scrubElement && (e._scrubElement.style.backgroundPosition = n === 1 ? "-16px 0" : "0 0")) : (e._touchMode = Ec.singleTap, e._touchState.centerX = t.touches[0].clientX - r)) : n === 2 ? (e._touchMode = Ec.slideZoom, e._touchState.centerX = (t.touches[0].clientX + t.touches[1].clientX) * .5 - r, e._touchState.spanX = Math.abs(t.touches[0].clientX - t.touches[1].clientX)) : e._touchMode = Ec.ignore } } function Xht(e) { return function (t) { let n = t.touches.length, i = e._topDiv.getBoundingClientRect().left; e._touchMode === Ec.singleTap ? (e._touchMode = Ec.scrub, e._onTouchMove(t)) : e._touchMode === Ec.scrub && e._onTouchMove(t), e._mouseMode = rf.touchOnly, n !== 1 ? e._touchMode = n > 0 ? Ec.ignore : Ec.none : e._touchMode === Ec.slideZoom && (e._touchState.centerX = t.touches[0].clientX - i), e._scrubElement && (e._scrubElement.style.backgroundPosition = "0 0") } } function Kht(e) { return function (t) { let n, i, o, r, s, a, c = 1, u = e._topDiv.getBoundingClientRect().left; e._touchMode === Ec.singleTap && (e._touchMode = Ec.slideZoom), e._mouseMode = rf.touchOnly, e._touchMode === Ec.scrub ? (t.preventDefault(), t.changedTouches.length === 1 && (i = t.changedTouches[0].clientX - u, i >= 0 && i <= e._topDiv.clientWidth && e._setTimeBarTime(i, i * e._timeBarSecondsSpan / e._topDiv.clientWidth))) : e._touchMode === Ec.slideZoom && (o = t.touches.length, o === 2 ? (r = (t.touches[0].clientX + t.touches[1].clientX) * .5 - u, s = Math.abs(t.touches[0].clientX - t.touches[1].clientX)) : o === 1 && (r = t.touches[0].clientX - u, s = 0), l(r) && (s > 0 && e._touchState.spanX > 0 ? (c = e._touchState.spanX / s, a = $.addSeconds(e._startJulian, (e._touchState.centerX * e._timeBarSecondsSpan - r * e._timeBarSecondsSpan * c) / e._topDiv.clientWidth, new $)) : (n = e._touchState.centerX - r, a = $.addSeconds(e._startJulian, n * e._timeBarSecondsSpan / e._topDiv.clientWidth, new $)), e.zoomTo(a, $.addSeconds(a, e._timeBarSecondsSpan * c, new $)), e._touchState.centerX = r, e._touchState.spanX = s)) } } bc.prototype.resize = function () { let e = this.container.clientWidth, t = this.container.clientHeight; if (e === this._lastWidth && t === this._lastHeight) return; this._trackContainer.style.height = `${t}px`; let n = 1; this._trackList.forEach(function (i) { n += i.height }), this._trackListEle.style.height = `${n.toString()}px`, this._trackListEle.width = this._trackListEle.clientWidth, this._trackListEle.height = n, this._makeTics(), this._lastXPos = void 0, this._lastWidth = e, this._lastHeight = t }; var dz = bc; var Y0e = po(q0e(), 1); function Qht(e) { let t = !1, n = window.screen; return l(n) && (l(n.lockOrientation) ? t = n.lockOrientation(e) : l(n.mozLockOrientation) ? t = n.mozLockOrientation(e) : l(n.msLockOrientation) ? t = n.msLockOrientation(e) : l(n.orientation && n.orientation.lock) && (t = n.orientation.lock(e))), t } function X0e() { let e = window.screen; l(e) && (l(e.unlockOrientation) ? e.unlockOrientation() : l(e.mozUnlockOrientation) ? e.mozUnlockOrientation() : l(e.msUnlockOrientation) ? e.msUnlockOrientation() : l(e.orientation && e.orientation.unlock) && e.orientation.unlock()) } function $ht(e, t, n, i) { i() || (n() ? (t.useWebVR = !1, e._locked && (X0e(), e._locked = !1), e._noSleep.disable(), hr.exitFullscreen(), n(!1)) : (hr.fullscreen || hr.requestFullscreen(e._vrElement), e._noSleep.enable(), e._locked || (e._locked = Qht("landscape")), t.useWebVR = !0, n(!0))) } function hz(e, t) { let n = this, i = Ae.observable(hr.enabled), o = Ae.observable(!1); this.isVRMode = void 0, Ae.defineProperty(this, "isVRMode", { get: function () { return o() } }), this.isVREnabled = void 0, Ae.defineProperty(this, "isVREnabled", { get: function () { return i() }, set: function (s) { i(s && hr.enabled) } }), this.tooltip = void 0, Ae.defineProperty(this, "tooltip", function () { return i() ? o() ? "Exit VR mode" : "Enter VR mode" : "VR mode is unavailable" }); let r = Ae.observable(!1); this._isOrthographic = void 0, Ae.defineProperty(this, "_isOrthographic", { get: function () { return r() } }), this._eventHelper = new Pr, this._eventHelper.add(e.preRender, function () { r(e.camera.frustum instanceof Zt) }), this._locked = !1, this._noSleep = new Y0e.default, this._command = An(function () { $ht(n, e, o, r) }, Ae.getObservable(this, "isVREnabled")), this._vrElement = y(vn(t), document.body), this._callback = function () { !hr.fullscreen && o() && (e.useWebVR = !1, n._locked && (X0e(), n._locked = !1), n._noSleep.disable(), o(!1)) }, document.addEventListener(hr.changeEventName, this._callback) } Object.defineProperties(hz.prototype, { vrElement: { get: function () { return this._vrElement }, set: function (e) { this._vrElement = e } }, command: { get: function () { return this._command } } }); hz.prototype.isDestroyed = function () { return !1 }; hz.prototype.destroy = function () { this._eventHelper.removeAll(), document.removeEventListener(hr.changeEventName, this._callback), le(this) }; var mz = hz; var emt = "M 5.3125 6.375 C 4.008126 6.375 2.96875 7.4141499 2.96875 8.71875 L 2.96875 19.5 C 2.96875 20.8043 4.008126 21.875 5.3125 21.875 L 13.65625 21.875 C 13.71832 20.0547 14.845166 18.59375 16.21875 18.59375 C 17.592088 18.59375 18.71881 20.0552 18.78125 21.875 L 27.09375 21.875 C 28.398125 21.875 29.4375 20.8043 29.4375 19.5 L 29.4375 8.71875 C 29.4375 7.4141499 28.398125 6.375 27.09375 6.375 L 5.3125 6.375 z M 9.625 10.4375 C 11.55989 10.4375 13.125 12.03385 13.125 13.96875 C 13.125 15.90365 11.55989 17.46875 9.625 17.46875 C 7.69011 17.46875 6.125 15.90365 6.125 13.96875 C 6.125 12.03385 7.69011 10.4375 9.625 10.4375 z M 22.46875 10.4375 C 24.40364 10.4375 25.96875 12.03385 25.96875 13.96875 C 25.96875 15.90365 24.40364 17.46875 22.46875 17.46875 C 20.53386 17.46875 18.96875 15.90365 18.96875 13.96875 C 18.96875 12.03385 20.53386 10.4375 22.46875 10.4375 z", tmt = "M 25.770585,2.4552065 C 15.72282,13.962707 10.699956,19.704407 8.1768352,22.580207 c -1.261561,1.4379 -1.902282,2.1427 -2.21875,2.5 -0.141624,0.1599 -0.208984,0.2355 -0.25,0.2813 l 0.6875,0.75 c 10e-5,-10e-5 0.679191,0.727 0.6875,0.7187 0.01662,-0.016 0.02451,-0.024 0.03125,-0.031 0.01348,-0.014 0.04013,-0.038 0.0625,-0.062 0.04474,-0.05 0.120921,-0.1315 0.28125,-0.3126 0.320657,-0.3619 0.956139,-1.0921 2.2187499,-2.5312 2.5252219,-2.8781 7.5454589,-8.6169 17.5937499,-20.1250005 l -1.5,-1.3125 z m -20.5624998,3.9063 c -1.304375,0 -2.34375,1.0391 -2.34375,2.3437 l 0,10.8125005 c 0,1.3043 1.039375,2.375 2.34375,2.375 l 2.25,0 c 1.9518039,-2.2246 7.4710958,-8.5584 13.5624998,-15.5312005 l -15.8124998,0 z m 21.1249998,0 c -1.855467,2.1245 -2.114296,2.4005 -3.59375,4.0936995 1.767282,0.1815 3.15625,1.685301 3.15625,3.500001 0,1.9349 -1.56511,3.5 -3.5,3.5 -1.658043,0 -3.043426,-1.1411 -3.40625,-2.6875 -1.089617,1.2461 -2.647139,2.9988 -3.46875,3.9375 0.191501,-0.062 0.388502,-0.094 0.59375,-0.094 1.373338,0 2.50006,1.4614 2.5625,3.2812 l 8.3125,0 c 1.304375,0 2.34375,-1.0707 2.34375,-2.375 l 0,-10.8125005 c 0,-1.3046 -1.039375,-2.3437 -2.34375,-2.3437 l -0.65625,0 z M 9.5518351,10.423906 c 1.9348899,0 3.4999999,1.596401 3.4999999,3.531301 0,1.9349 -1.56511,3.5 -3.4999999,3.5 -1.9348899,0 -3.4999999,-1.5651 -3.4999999,-3.5 0,-1.9349 1.56511,-3.531301 3.4999999,-3.531301 z m 4.2187499,10.312601 c -0.206517,0.2356 -0.844218,0.9428 -1.03125,1.1562 l 0.8125,0 c 0.01392,-0.4081 0.107026,-0.7968 0.21875,-1.1562 z"; function pz(e, t, n) { e = vn(e); let i = new mz(t, n); i._exitVRPath = tmt, i._enterVRPath = emt; let o = document.createElement("button"); o.type = "button", o.className = "cesium-button cesium-vrButton", o.setAttribute("data-bind", 'css: { "cesium-button-disabled" : _isOrthographic }, attr: { title: tooltip },click: command,enable: isVREnabled,cesiumSvgPath: { path: isVRMode ? _exitVRPath : _enterVRPath, width: 32, height: 32 }'), e.appendChild(o), Ae.applyBindings(i, o), this._container = e, this._viewModel = i, this._element = o } Object.defineProperties(pz.prototype, { container: { get: function () { return this._container } }, viewModel: { get: function () { return this._viewModel } } }); pz.prototype.isDestroyed = function () { return !1 }; pz.prototype.destroy = function () { return this._viewModel.destroy(), Ae.cleanNode(this._element), this._container.removeChild(this._element), le(this) }; var _z = pz; var t0 = new re; function Z0e(e) { let t = e.clock; t.currentTime = e.timeJulian, t.shouldAnimate = !1 } function nmt(e) { let t = e.getPropertyIds(), n = ""; return t.forEach(function (i) { let o = e.getProperty(i); l(o) && (n += `<tr><th>${i}</th><td>${o}</td></tr>`) }), n.length > 0 && (n = `<table class="cesium-infoBox-defaultTable"><tbody>${n}</tbody></table>`), n } function imt(e) { let t, n = [], i = e.getPropertyIds(); for (t = 0; t < i.length; t++) { let r = i[t]; /^name$/i.test(r) ? n[0] = e.getProperty(r) : /name/i.test(r) ? n[1] = e.getProperty(r) : /^title$/i.test(r) ? n[2] = e.getProperty(r) : /^(id|identifier)$/i.test(r) ? n[3] = e.getProperty(r) : /element/i.test(r) ? n[4] = e.getProperty(r) : /(id|identifier)$/i.test(r) && (n[5] = e.getProperty(r)) } let o = n.length; for (t = 0; t < o; t++) { let r = n[t]; if (l(r) && r !== "") return r } return "Unnamed Feature" } function K0e(e, t) { let n = e.scene.pick(t.position); if (l(n)) { let i = y(n.id, n.primitive.id); if (i instanceof Xo) return i; if (n instanceof xs) return new Xo({ name: imt(n), description: nmt(n), feature: n }) } if (l(e.scene.globe)) return smt(e, t.position) } var omt = new $; function Q0e(e, t, n) { if (l(n)) { let i = n.clock; if (l(i) && (i.getValue(t), l(e))) { let o = i.startTime, r = i.stopTime; $.equals(o, r) && (r = $.addSeconds(o, I.EPSILON2, omt)), e.updateFromClock(), e.zoomTo(o, r) } } } var rmt = new h; function smt(e, t) { let n = e.scene, i = n.camera.getPickRay(t), o = n.imageryLayers.pickImageryLayerFeatures(i, n); if (!l(o)) return; let r = new Xo({ id: "Loading...", description: "Loading feature information..." }); return o.then(function (s) { if (e.selectedEntity !== r) return; if (!l(s) || s.length === 0) { e.selectedEntity = J0e(); return } let a = s[0], c = new Xo({ id: a.name, description: a.description }); if (l(a.position)) { let u = e.scene.globe.ellipsoid.cartographicToCartesian(a.position, rmt); c.position = new Mc(u) } e.selectedEntity = c }, function () { e.selectedEntity === r && (e.selectedEntity = J0e()) }), r } function J0e() { return new Xo({ id: "None", description: "No features found." }) } function amt(e, t) { let n = e._geocoder, i = e._homeButton, o = e._sceneModePicker, r = e._projectionPicker, s = e._baseLayerPicker, a = e._animation, c = e._timeline, u = e._fullscreenButton, f = e._infoBox, d = e._selectionIndicator, p = t ? "hidden" : "visible"; if (l(n) && (n.container.style.visibility = p), l(i) && (i.container.style.visibility = p), l(o) && (o.container.style.visibility = p), l(r) && (r.container.style.visibility = p), l(s) && (s.container.style.visibility = p), l(a) && (a.container.style.visibility = p), l(c) && (c.container.style.visibility = p), l(u) && u.viewModel.isFullscreenEnabled && (u.container.style.visibility = p), l(f) && (f.container.style.visibility = p), l(d) && (d.container.style.visibility = p), e._container) { let g = t || !l(u) ? 0 : u.container.clientWidth; e._vrButton.container.style.right = `${g}px`, e.forceResize() } } function pi(e, t) { e = vn(e), t = y(t, y.EMPTY_OBJECT); let n = (!l(t.globe) || t.globe !== !1) && (!l(t.baseLayerPicker) || t.baseLayerPicker !== !1), i = this, o = document.createElement("div"); o.className = "cesium-viewer", e.appendChild(o); let r = document.createElement("div"); r.className = "cesium-viewer-cesiumWidgetContainer", o.appendChild(r); let s = document.createElement("div"); s.className = "cesium-viewer-bottom", o.appendChild(s); let a = y(t.scene3DOnly, !1), c, u, f = !1; l(t.clockViewModel) ? (u = t.clockViewModel, c = u.clock) : (c = new sh, u = new f4(c), f = !0), l(t.shouldAnimate) && (c.shouldAnimate = t.shouldAnimate); let d = new H4(r, { imageryProvider: n || l(t.imageryProvider) ? !1 : void 0, clock: c, skyBox: t.skyBox, skyAtmosphere: t.skyAtmosphere, sceneMode: t.sceneMode, mapProjection: t.mapProjection, globe: t.globe, orderIndependentTranslucency: t.orderIndependentTranslucency, contextOptions: t.contextOptions, useDefaultRenderLoop: t.useDefaultRenderLoop, targetFrameRate: t.targetFrameRate, showRenderLoopErrors: t.showRenderLoopErrors, useBrowserRecommendedResolution: t.useBrowserRecommendedResolution, creditContainer: l(t.creditContainer) ? t.creditContainer : s, creditViewport: t.creditViewport, scene3DOnly: a, shadows: t.shadows, terrainShadows: t.terrainShadows, mapMode2D: t.mapMode2D, blurActiveElementOnCanvasFocus: t.blurActiveElementOnCanvasFocus, requestRenderMode: t.requestRenderMode, maximumRenderTimeChange: t.maximumRenderTimeChange, depthPlaneEllipsoidOffset: t.depthPlaneEllipsoidOffset, msaaSamples: t.msaaSamples }), p = t.dataSources, g = !1; l(p) || (p = new ZF, g = !0); let m = d.scene, A = new UN({ scene: m, dataSourceCollection: p }), C = new Pr; C.add(c.onTick, pi.prototype._onTick, this), C.add(m.morphStart, pi.prototype._clearTrackedObject, this); let x; if (!l(t.selectionIndicator) || t.selectionIndicator !== !1) { let q = document.createElement("div"); q.className = "cesium-viewer-selectionIndicatorContainer", o.appendChild(q), x = new lz(q, m) } let T; if (!l(t.infoBox) || t.infoBox !== !1) { let q = document.createElement("div"); q.className = "cesium-viewer-infoBoxContainer", o.appendChild(q), T = new j4(q); let J = T.viewModel; C.add(J.cameraClicked, pi.prototype._onInfoBoxCameraClicked, this), C.add(J.closeClicked, pi.prototype._onInfoBoxClockClicked, this) } let b = document.createElement("div"); b.className = "cesium-viewer-toolbar", o.appendChild(b); let S; if (!l(t.geocoder) || t.geocoder !== !1) { let q = document.createElement("div"); q.className = "cesium-viewer-geocoderContainer", b.appendChild(q); let J; l(t.geocoder) && typeof t.geocoder != "boolean" && (J = Array.isArray(t.geocoder) ? t.geocoder : [t.geocoder]), S = new V4({ container: q, geocoderServices: J, scene: m }), C.add(S.viewModel.search.beforeExecute, pi.prototype._clearObjects, this) } let D; (!l(t.homeButton) || t.homeButton !== !1) && (D = new z4(b, m), l(S) && C.add(D.viewModel.command.afterExecute, function () { let q = S.viewModel; q.searchText = "", q.isSearchInProgress && q.search() }), C.add(D.viewModel.command.beforeExecute, pi.prototype._clearTrackedObject, this)); let P; !a && (!l(t.sceneModePicker) || t.sceneModePicker !== !1) && (P = new rz(b, m)); let B; t.projectionPicker && (B = new tz(b, m)); let R, M; if (n) { let q = y(t.imageryProviderViewModels, g4()), J = y(t.terrainProviderViewModels, y4()); R = new _4(b, { globe: m.globe, imageryProviderViewModels: q, selectedImageryProviderViewModel: t.selectedImageryProviderViewModel, terrainProviderViewModels: J, selectedTerrainProviderViewModel: t.selectedTerrainProviderViewModel }), M = b.getElementsByClassName("cesium-baseLayerPicker-dropDown")[0] } l(t.imageryProvider) && t.imageryProvider !== !1 && (n && (R.viewModel.selectedImagery = void 0), m.imageryLayers.removeAll(), m.imageryLayers.addImageryProvider(t.imageryProvider)), l(t.terrainProvider) && (n && (R.viewModel.selectedTerrain = void 0), m.terrainProvider = t.terrainProvider); let L; if (!l(t.navigationHelpButton) || t.navigationHelpButton !== !1) { let q = !0; try { if (l(window.localStorage)) { let J = window.localStorage.getItem("cesium-hasSeenNavHelp"); l(J) && Boolean(J) ? q = !1 : window.localStorage.setItem("cesium-hasSeenNavHelp", "true") } } catch { } L = new Z4({ container: b, instructionsInitiallyVisible: y(t.navigationInstructionsInitiallyVisible, q) }) } let _; if (!l(t.animation) || t.animation !== !1) { let q = document.createElement("div"); q.className = "cesium-viewer-animationContainer", o.appendChild(q), _ = new E4(q, new b4(u)) } let E; if (!l(t.timeline) || t.timeline !== !1) { let q = document.createElement("div"); q.className = "cesium-viewer-timelineContainer", o.appendChild(q), E = new dz(q, c), E.addEventListener("settime", Z0e, !1), E.zoomTo(c.startTime, c.stopTime) } let w, v, O; (!l(t.fullscreenButton) || t.fullscreenButton !== !1) && (O = document.createElement("div"), O.className = "cesium-viewer-fullscreenContainer", o.appendChild(O), w = new L4(O, t.fullscreenElement), v = aa(w.viewModel, "isFullscreenEnabled", function (q) { O.style.display = q ? "block" : "none", l(E) && (E.container.style.right = `${O.clientWidth}px`, E.resize()) })); let V, z, k; if (t.vrButton) { let q = document.createElement("div"); q.className = "cesium-viewer-vrContainer", o.appendChild(q), V = new _z(q, m, t.fullScreenElement), z = aa(V.viewModel, "isVREnabled", function (J) { q.style.display = J ? "block" : "none", l(w) && (q.style.right = `${O.clientWidth}px`), l(E) && (E.container.style.right = `${q.clientWidth}px`, E.resize()) }), k = aa(V.viewModel, "isVRMode", function (J) { amt(i, J) }) } this._baseLayerPickerDropDown = M, this._fullscreenSubscription = v, this._vrSubscription = z, this._vrModeSubscription = k, this._dataSourceChangedListeners = {}, this._automaticallyTrackDataSourceClocks = y(t.automaticallyTrackDataSourceClocks, !0), this._container = e, this._bottomContainer = s, this._element = o, this._cesiumWidget = d, this._selectionIndicator = x, this._infoBox = T, this._dataSourceCollection = p, this._destroyDataSourceCollection = g, this._dataSourceDisplay = A, this._clockViewModel = u, this._destroyClockViewModel = f, this._toolbar = b, this._homeButton = D, this._sceneModePicker = P, this._projectionPicker = B, this._baseLayerPicker = R, this._navigationHelpButton = L, this._animation = _, this._timeline = E, this._fullscreenButton = w, this._vrButton = V, this._geocoder = S, this._eventHelper = C, this._lastWidth = 0, this._lastHeight = 0, this._allowDataSourcesToSuspendAnimation = !0, this._entityView = void 0, this._enableInfoOrSelection = l(T) || l(x), this._clockTrackedDataSource = void 0, this._trackedEntity = void 0, this._needTrackedEntityUpdate = !1, this._selectedEntity = void 0, this._zoomIsFlight = !1, this._zoomTarget = void 0, this._zoomPromise = void 0, this._zoomOptions = void 0, this._selectedEntityChanged = new _e, this._trackedEntityChanged = new _e, Ae.track(this, ["_trackedEntity", "_selectedEntity", "_clockTrackedDataSource"]), C.add(p.dataSourceAdded, pi.prototype._onDataSourceAdded, this), C.add(p.dataSourceRemoved, pi.prototype._onDataSourceRemoved, this), C.add(m.postUpdate, pi.prototype.resize, this), C.add(m.postRender, pi.prototype._postRender, this); let G = p.length; for (let q = 0; q < G; q++)this._dataSourceAdded(p, p.get(q)); this._dataSourceAdded(void 0, A.defaultDataSource), C.add(p.dataSourceAdded, pi.prototype._dataSourceAdded, this), C.add(p.dataSourceRemoved, pi.prototype._dataSourceRemoved, this); function N(q) { let J = K0e(i, q); l(J) ? j.getValueOrUndefined(J.position, i.clock.currentTime) ? i.trackedEntity = J : i.zoomTo(J) : l(i.trackedEntity) && (i.trackedEntity = void 0) } function X(q) { i.selectedEntity = K0e(i, q) } d.screenSpaceEventHandler.setInputAction(X, pn.LEFT_CLICK), d.screenSpaceEventHandler.setInputAction(N, pn.LEFT_DOUBLE_CLICK) } Object.defineProperties(pi.prototype, { container: { get: function () { return this._container } }, bottomContainer: { get: function () { return this._bottomContainer } }, cesiumWidget: { get: function () { return this._cesiumWidget } }, selectionIndicator: { get: function () { return this._selectionIndicator } }, infoBox: { get: function () { return this._infoBox } }, geocoder: { get: function () { return this._geocoder } }, homeButton: { get: function () { return this._homeButton } }, sceneModePicker: { get: function () { return this._sceneModePicker } }, projectionPicker: { get: function () { return this._projectionPicker } }, baseLayerPicker: { get: function () { return this._baseLayerPicker } }, navigationHelpButton: { get: function () { return this._navigationHelpButton } }, animation: { get: function () { return this._animation } }, timeline: { get: function () { return this._timeline } }, fullscreenButton: { get: function () { return this._fullscreenButton } }, vrButton: { get: function () { return this._vrButton } }, dataSourceDisplay: { get: function () { return this._dataSourceDisplay } }, entities: { get: function () { return this._dataSourceDisplay.defaultDataSource.entities } }, dataSources: { get: function () { return this._dataSourceCollection } }, canvas: { get: function () { return this._cesiumWidget.canvas } }, scene: { get: function () { return this._cesiumWidget.scene } }, shadows: { get: function () { return this.scene.shadowMap.enabled }, set: function (e) { this.scene.shadowMap.enabled = e } }, terrainShadows: { get: function () { return this.scene.globe.shadows }, set: function (e) { this.scene.globe.shadows = e } }, shadowMap: { get: function () { return this.scene.shadowMap } }, imageryLayers: { get: function () { return this.scene.imageryLayers } }, terrainProvider: { get: function () { return this.scene.terrainProvider }, set: function (e) { this.scene.terrainProvider = e } }, camera: { get: function () { return this.scene.camera } }, postProcessStages: { get: function () { return this.scene.postProcessStages } }, clock: { get: function () { return this._clockViewModel.clock } }, clockViewModel: { get: function () { return this._clockViewModel } }, screenSpaceEventHandler: { get: function () { return this._cesiumWidget.screenSpaceEventHandler } }, targetFrameRate: { get: function () { return this._cesiumWidget.targetFrameRate }, set: function (e) { this._cesiumWidget.targetFrameRate = e } }, useDefaultRenderLoop: { get: function () { return this._cesiumWidget.useDefaultRenderLoop }, set: function (e) { this._cesiumWidget.useDefaultRenderLoop = e } }, resolutionScale: { get: function () { return this._cesiumWidget.resolutionScale }, set: function (e) { this._cesiumWidget.resolutionScale = e } }, useBrowserRecommendedResolution: { get: function () { return this._cesiumWidget.useBrowserRecommendedResolution }, set: function (e) { this._cesiumWidget.useBrowserRecommendedResolution = e } }, allowDataSourcesToSuspendAnimation: { get: function () { return this._allowDataSourcesToSuspendAnimation }, set: function (e) { this._allowDataSourcesToSuspendAnimation = e } }, trackedEntity: { get: function () { return this._trackedEntity }, set: function (e) { if (this._trackedEntity !== e) { this._trackedEntity = e, gz(this); let t = this.scene, n = t.mode; !l(e) || !l(e.position) ? (this._needTrackedEntityUpdate = !1, (n === ee.COLUMBUS_VIEW || n === ee.SCENE2D) && (t.screenSpaceCameraController.enableTranslate = !0), (n === ee.COLUMBUS_VIEW || n === ee.SCENE3D) && (t.screenSpaceCameraController.enableTilt = !0), this._entityView = void 0, this.camera.lookAtTransform(F.IDENTITY)) : this._needTrackedEntityUpdate = !0, this._trackedEntityChanged.raiseEvent(e), this.scene.requestRender() } } }, selectedEntity: { get: function () { return this._selectedEntity }, set: function (e) { if (this._selectedEntity !== e) { this._selectedEntity = e; let t = l(this._selectionIndicator) ? this._selectionIndicator.viewModel : void 0; l(e) ? l(t) && t.animateAppear() : l(t) && t.animateDepart(), this._selectedEntityChanged.raiseEvent(e) } } }, selectedEntityChanged: { get: function () { return this._selectedEntityChanged } }, trackedEntityChanged: { get: function () { return this._trackedEntityChanged } }, clockTrackedDataSource: { get: function () { return this._clockTrackedDataSource }, set: function (e) { this._clockTrackedDataSource !== e && (this._clockTrackedDataSource = e, Q0e(this._timeline, this.clock, e)) } } }); pi.prototype.extend = function (e, t) { e(this, t) }; pi.prototype.resize = function () { let e = this._cesiumWidget, t = this._container, n = t.clientWidth, i = t.clientHeight, o = l(this._animation), r = l(this._timeline); if (e.resize(), n === this._lastWidth && i === this._lastHeight) return; let s = i - 125, a = this._baseLayerPickerDropDown; if (l(a) && (a.style.maxHeight = `${s}px`), l(this._geocoder)) { let g = this._geocoder.searchSuggestionsContainer; g.style.maxHeight = `${s}px` } l(this._infoBox) && (this._infoBox.viewModel.maxHeight = s); let c = this._timeline, u, f = 0, d = 0, p = 0; if (o && window.getComputedStyle(this._animation.container).visibility !== "hidden") { let g = this._lastWidth; u = this._animation.container, n > 900 ? (f = 169, g <= 900 && (u.style.width = "169px", u.style.height = "112px", this._animation.resize())) : n >= 600 ? (f = 136, (g < 600 || g > 900) && (u.style.width = "136px", u.style.height = "90px", this._animation.resize())) : (f = 106, (g > 600 || g === 0) && (u.style.width = "106px", u.style.height = "70px", this._animation.resize())), d = f + 5 } if (r && window.getComputedStyle(this._timeline.container).visibility !== "hidden") { let g = this._fullscreenButton, m = this._vrButton, A = c.container, C = A.style; p = A.clientHeight + 3, C.left = `${f}px`; let x = 0; l(g) && (x += g.container.clientWidth), l(m) && (x += m.container.clientWidth), C.right = `${x}px`, c.resize() } this._bottomContainer.style.left = `${d}px`, this._bottomContainer.style.bottom = `${p}px`, this._lastWidth = n, this._lastHeight = i }; pi.prototype.forceResize = function () { this._lastWidth = 0, this.resize() }; pi.prototype.render = function () { this._cesiumWidget.render() }; pi.prototype.isDestroyed = function () { return !1 }; pi.prototype.destroy = function () { let e; this.screenSpaceEventHandler.removeInputAction(pn.LEFT_CLICK), this.screenSpaceEventHandler.removeInputAction(pn.LEFT_DOUBLE_CLICK); let t = this.dataSources, n = t.length; for (e = 0; e < n; e++)this._dataSourceRemoved(t, t.get(e)); return this._dataSourceRemoved(void 0, this._dataSourceDisplay.defaultDataSource), this._container.removeChild(this._element), this._element.removeChild(this._toolbar), this._eventHelper.removeAll(), l(this._geocoder) && (this._geocoder = this._geocoder.destroy()), l(this._homeButton) && (this._homeButton = this._homeButton.destroy()), l(this._sceneModePicker) && (this._sceneModePicker = this._sceneModePicker.destroy()), l(this._projectionPicker) && (this._projectionPicker = this._projectionPicker.destroy()), l(this._baseLayerPicker) && (this._baseLayerPicker = this._baseLayerPicker.destroy()), l(this._animation) && (this._element.removeChild(this._animation.container), this._animation = this._animation.destroy()), l(this._timeline) && (this._timeline.removeEventListener("settime", Z0e, !1), this._element.removeChild(this._timeline.container), this._timeline = this._timeline.destroy()), l(this._fullscreenButton) && (this._fullscreenSubscription.dispose(), this._element.removeChild(this._fullscreenButton.container), this._fullscreenButton = this._fullscreenButton.destroy()), l(this._vrButton) && (this._vrSubscription.dispose(), this._vrModeSubscription.dispose(), this._element.removeChild(this._vrButton.container), this._vrButton = this._vrButton.destroy()), l(this._infoBox) && (this._element.removeChild(this._infoBox.container), this._infoBox = this._infoBox.destroy()), l(this._selectionIndicator) && (this._element.removeChild(this._selectionIndicator.container), this._selectionIndicator = this._selectionIndicator.destroy()), this._destroyClockViewModel && (this._clockViewModel = this._clockViewModel.destroy()), this._dataSourceDisplay = this._dataSourceDisplay.destroy(), this._cesiumWidget = this._cesiumWidget.destroy(), this._destroyDataSourceCollection && (this._dataSourceCollection = this._dataSourceCollection.destroy()), le(this) }; pi.prototype._dataSourceAdded = function (e, t) { t.entities.collectionChanged.addEventListener(pi.prototype._onEntityCollectionChanged, this) }; pi.prototype._dataSourceRemoved = function (e, t) { let n = t.entities; n.collectionChanged.removeEventListener(pi.prototype._onEntityCollectionChanged, this), l(this.trackedEntity) && n.getById(this.trackedEntity.id) === this.trackedEntity && (this.trackedEntity = void 0), l(this.selectedEntity) && n.getById(this.selectedEntity.id) === this.selectedEntity && (this.selectedEntity = void 0) }; pi.prototype._onTick = function (e) { let t = e.currentTime, n = this._dataSourceDisplay.update(t); this._allowDataSourcesToSuspendAnimation && (this._clockViewModel.canAnimate = n); let i = this._entityView; if (l(i)) { let f = this._trackedEntity; this._dataSourceDisplay.getBoundingSphere(f, !1, t0) === rt.DONE && i.update(t, t0) } let o, r = !1, s = this.selectedEntity, a = l(s) && this._enableInfoOrSelection; a && s.isShowing && s.isAvailable(t) && (this._dataSourceDisplay.getBoundingSphere(s, !0, t0) !== rt.FAILED ? o = t0.center : l(s.position) && (o = s.position.getValue(t, o)), r = l(o)); let c = l(this._selectionIndicator) ? this._selectionIndicator.viewModel : void 0; l(c) && (c.position = h.clone(o, c.position), c.showSelection = a && r, c.update()); let u = l(this._infoBox) ? this._infoBox.viewModel : void 0; l(u) && (u.showInfo = a, u.enableCamera = r, u.isCameraTracking = this.trackedEntity === this.selectedEntity, a ? (u.titleText = y(s.name, s.id), u.description = j.getValueOrDefault(s.description, t, "")) : (u.titleText = "", u.description = "")) }; pi.prototype._onEntityCollectionChanged = function (e, t, n) { let i = n.length; for (let o = 0; o < i; o++) { let r = n[o]; this.trackedEntity === r && (this.trackedEntity = void 0), this.selectedEntity === r && (this.selectedEntity = void 0) } }; pi.prototype._onInfoBoxCameraClicked = function (e) { if (e.isCameraTracking && this.trackedEntity === this.selectedEntity) this.trackedEntity = void 0; else { let n = this.selectedEntity.position; l(n) ? this.trackedEntity = this.selectedEntity : this.zoomTo(this.selectedEntity) } }; pi.prototype._clearTrackedObject = function () { this.trackedEntity = void 0 }; pi.prototype._onInfoBoxClockClicked = function (e) { this.selectedEntity = void 0 }; pi.prototype._clearObjects = function () { this.trackedEntity = void 0, this.selectedEntity = void 0 }; pi.prototype._onDataSourceChanged = function (e) { this.clockTrackedDataSource === e && Q0e(this.timeline, this.clock, e) }; pi.prototype._onDataSourceAdded = function (e, t) { this._automaticallyTrackDataSourceClocks && (this.clockTrackedDataSource = t); let n = t.entities.id, i = this._eventHelper.add(t.changedEvent, pi.prototype._onDataSourceChanged, this); this._dataSourceChangedListeners[n] = i }; pi.prototype._onDataSourceRemoved = function (e, t) { let n = this.clockTrackedDataSource === t, i = t.entities.id; if (this._dataSourceChangedListeners[i](), this._dataSourceChangedListeners[i] = void 0, n) { let o = e.length; this._automaticallyTrackDataSourceClocks && o > 0 ? this.clockTrackedDataSource = e.get(o - 1) : this.clockTrackedDataSource = void 0 } }; pi.prototype.zoomTo = function (e, t) { return $0e(this, e, { offset: t }, !1) }; pi.prototype.flyTo = function (e, t) { return $0e(this, e, t, !0) }; function $0e(e, t, n, i) { gz(e); let o = new Promise(r => { e._completeZoom = function (s) { r(s) } }); return e._zoomPromise = o, e._zoomIsFlight = i, e._zoomOptions = n, Promise.resolve(t).then(function (r) { if (e._zoomPromise === o) { if (r instanceof Qu) { r.getViewableRectangle().then(function (s) { return TE(s, e.scene) }).then(function (s) { e._zoomPromise === o && (e._zoomTarget = s) }); return } if (r instanceof Su) { e._zoomTarget = r; return } if (r instanceof Vv) { e._zoomTarget = r; return } if (r.isLoading && l(r.loadingEvent)) { let s = r.loadingEvent.addEventListener(function () { s(), e._zoomPromise === o && (e._zoomTarget = r.entities.values.slice(0)) }); return } if (Array.isArray(r)) { e._zoomTarget = r.slice(0); return } r = y(r.values, r), l(r.entities) && (r = r.entities.values), Array.isArray(r) ? e._zoomTarget = r.slice(0) : e._zoomTarget = [r] } }), e.scene.requestRender(), o } function QE(e) { e._zoomPromise = void 0, e._zoomTarget = void 0, e._zoomOptions = void 0 } function gz(e) { let t = e._zoomPromise; l(t) && (QE(e), e._completeZoom(!1)) } pi.prototype._postRender = function () { cmt(this), lmt(this) }; function cmt(e) { let t = e._zoomTarget; if (!l(t) || e.scene.mode === ee.MORPHING) return; let n = e.scene, i = n.camera, o = y(e._zoomOptions, {}), r; if (t instanceof Su) return t.readyPromise.then(function () { let u = t.boundingSphere; l(o.offset) || (o.offset = new ku(0, -.5, u.radius)), r = { offset: o.offset, duration: o.duration, maximumHeight: o.maximumHeight, complete: function () { e._completeZoom(!0) }, cancel: function () { e._completeZoom(!1) } }, e._zoomIsFlight ? i.flyToBoundingSphere(t.boundingSphere, r) : (i.viewBoundingSphere(u, o.offset), i.lookAtTransform(F.IDENTITY), e._completeZoom(!0)), QE(e) }).catch(() => { gz(e) }); if (t instanceof Vv) return t.readyPromise.then(function () { let u = t.boundingSphere; l(o.offset) || (o.offset = new ku(0, -.5, u.radius)), r = { offset: o.offset, duration: o.duration, maximumHeight: o.maximumHeight, complete: function () { e._completeZoom(!0) }, cancel: function () { e._completeZoom(!1) } }, e._zoomIsFlight ? i.flyToBoundingSphere(u, r) : (i.viewBoundingSphere(u, o.offset), i.lookAtTransform(F.IDENTITY), e._completeZoom(!0)), QE(e) }); if (t instanceof he) { r = { destination: n.mapProjection.ellipsoid.cartographicToCartesian(t), duration: o.duration, maximumHeight: o.maximumHeight, complete: function () { e._completeZoom(!0) }, cancel: function () { e._completeZoom(!1) } }, e._zoomIsFlight ? i.flyTo(r) : (i.setView(r), e._completeZoom(!0)), QE(e); return } let s = t, a = []; for (let u = 0, f = s.length; u < f; u++) { let d = e._dataSourceDisplay.getBoundingSphere(s[u], !1, t0); if (d === rt.PENDING) return; d !== rt.FAILED && a.push(re.clone(t0)) } if (a.length === 0) { gz(e); return } e.trackedEntity = void 0; let c = re.fromBoundingSpheres(a); e._zoomIsFlight ? (QE(e), i.flyToBoundingSphere(c, { duration: o.duration, maximumHeight: o.maximumHeight, complete: function () { e._completeZoom(!0) }, cancel: function () { e._completeZoom(!1) }, offset: o.offset })) : (i.viewBoundingSphere(c, o.offset), i.lookAtTransform(F.IDENTITY), QE(e), e._completeZoom(!0)) } function lmt(e) { if (!e._needTrackedEntityUpdate) return; let t = e._trackedEntity, n = e.clock.currentTime, i = j.getValueOrUndefined(t.position, n); if (!l(i)) return; let o = e.scene, r = e._dataSourceDisplay.getBoundingSphere(t, !1, t0); if (r === rt.PENDING) return; let s = o.mode; (s === ee.COLUMBUS_VIEW || s === ee.SCENE2D) && (o.screenSpaceCameraController.enableTranslate = !1), (s === ee.COLUMBUS_VIEW || s === ee.SCENE3D) && (o.screenSpaceCameraController.enableTilt = !1); let a = r !== rt.FAILED ? t0 : void 0; e._entityView = new GN(t, o, o.mapProjection.ellipsoid), e._entityView.update(n, a), e._needTrackedEntityUpdate = !1 } var eye = pi; function umt(e) { let t = document.createElement("div"); t.className = "cesium-viewer-cesium3DTilesInspectorContainer", e.container.appendChild(t); let n = new v4(t, e.scene); Object.defineProperties(e, { cesium3DTilesInspector: { get: function () { return n } } }) } var tye = umt; function fmt(e) { let t = document.createElement("div"); t.className = "cesium-viewer-cesiumInspectorContainer", e.container.appendChild(t); let n = new O4(t, e.scene); Object.defineProperties(e, { cesiumInspector: { get: function () { return n } } }) } var nye = fmt; function dmt(e, t) { t = y(t, y.EMPTY_OBJECT); let n = !0, i = y(t.flyToOnDrop, !0), o = new _e, r = y(t.clearOnDrop, !0), s = y(t.dropTarget, e.container), a = y(t.clampToGround, !0), c = t.proxy; s = vn(s), Object.defineProperties(e, { dropTarget: { get: function () { return s }, set: function (f) { iye(s, u), s = f, Pq(s, u) } }, dropEnabled: { get: function () { return n }, set: function (f) { f !== n && (f ? Pq(s, u) : iye(s, u), n = f) } }, dropError: { get: function () { return o } }, clearOnDrop: { get: function () { return r }, set: function (f) { r = f } }, flyToOnDrop: { get: function () { return i }, set: function (f) { i = f } }, proxy: { get: function () { return c }, set: function (f) { c = f } }, clampToGround: { get: function () { return a }, set: function (f) { a = f } } }); function u(f) { DA(f), r && (e.entities.removeAll(), e.dataSources.removeAll()); let d = f.dataTransfer.files, p = d.length; for (let g = 0; g < p; g++) { let m = d[g], A = new FileReader; A.onload = hmt(e, m, c, a), A.onerror = mmt(e, m), A.readAsText(m) } } Pq(s, u), e.destroy = aV(e, e.destroy, function () { e.dropEnabled = !1 }), e._handleDrop = u } function DA(e) { e.stopPropagation(), e.preventDefault() } function iye(e, t) { let n = e; l(n) && (n.removeEventListener("drop", t, !1), n.removeEventListener("dragenter", DA, !1), n.removeEventListener("dragover", DA, !1), n.removeEventListener("dragexit", DA, !1)) } function Pq(e, t) { e.addEventListener("drop", t, !1), e.addEventListener("dragenter", DA, !1), e.addEventListener("dragover", DA, !1), e.addEventListener("dragexit", DA, !1) } function hmt(e, t, n, i) { let o = e.scene; return function (r) { let s = t.name; try { let a; if (/\.czml$/i.test(s)) a = KF.load(JSON.parse(r.target.result), { sourceUri: s }); else if (/\.geojson$/i.test(s) || /\.json$/i.test(s) || /\.topojson$/i.test(s)) a = k2.load(JSON.parse(r.target.result), { sourceUri: s, clampToGround: i }); else if (/\.(kml|kmz)$/i.test(s)) a = _3.load(t, { sourceUri: s, proxy: n, camera: o.camera, canvas: o.canvas, clampToGround: i, screenOverlayContainer: e.container }); else if (/\.gpx$/i.test(s)) a = n3.load(t, { sourceUri: s, proxy: n }); else { e.dropError.raiseEvent(e, s, `Unrecognized file: ${s}`); return } l(a) && e.dataSources.add(a).then(function (c) { e.flyToOnDrop && e.flyTo(c) }).catch(function (c) { e.dropError.raiseEvent(e, s, c) }) } catch (a) { e.dropError.raiseEvent(e, s, a) } } } function mmt(e, t) { return function (n) { e.dropError.raiseEvent(e, t.name, n.target.error) } } var oye = dmt; function pmt(e, t) { t = y(t, y.EMPTY_OBJECT); let n = new X4({ scene: e.scene, container: e.bottomContainer, lowFrameRateMessage: t.lowFrameRateMessage }); Object.defineProperties(e, { performanceWatchdog: { get: function () { return n } } }) } var rye = pmt; var sye = `uniform sampler2D u_depthTexture;
varying vec2 v_textureCoordinates;
void main()
{
float z_window = czm_unpackDepth(texture2D(u_depthTexture, v_textureCoordinates));
z_window = czm_reverseLogDepth(z_window);
float n_range = czm_depthRange.near;
float f_range = czm_depthRange.far;
float z_ndc = (2.0 * z_window - n_range - f_range) / (f_range - n_range);
float scale = pow(z_ndc * 0.5 + 0.5, 8.0);
gl_FragColor = vec4(mix(vec3(0.0), vec3(1.0), scale), 1.0);
}
`; function _mt(e, t, n) { let i; try { return i = e(t, n), i } catch (o) { return Promise.reject(o) } } function gmt(e) {
        let t; return function (n) {
            let i = n.data, o = [], r = { id: i.id, result: void 0, error: void 0 }; return Promise.resolve(_mt(e, i.parameters, o)).then(function (s) { r.result = s }).catch(function (s) { s instanceof Error ? r.error = { name: s.name, message: s.message, stack: s.stack } : r.error = s }).finally(function () {
                l(t) || (t = y(self.webkitPostMessage, self.postMessage)), i.canTransferArrayBuffer || (o.length = 0); try { t(r, o) } catch (s) {
                    r.result = void 0, r.error = `postMessage failed with error: ${ap(s)}
  with responseMessage: ${JSON.stringify(r)}`, t(r)
                }
            })
        }
    } var aye = gmt; var ymt = "1.97"; return Tye(Amt);
})();
